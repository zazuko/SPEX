{"version":3,"file":"js/565.3919b150.js","mappings":"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","sources":["webpack://@zazuko/spex/./node_modules/@graphy/content.trig.read/main.js","webpack://@zazuko/spex/./node_modules/@graphy/core.iso.stream/main.js","webpack://@zazuko/spex/./node_modules/uri-js/dist/es5/uri.all.js"],"sourcesContent":["\n\n\n// queueMicrotask shim\n{\n\t// not defined or not a function\n\tif('function' !== typeof queueMicrotask) {\n\t\t// create resolved promise\n\t\tlet dp_resolve = Promise.resolve();\n\n\t\t// try to redefine\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-global-assign\n\t\t\tqueueMicrotask = fk => dp_resolve.then(fk)\n\t\t\t\t.catch(e_callback => setTimeout(() => {\n\t\t\t\t\tthrow e_callback;\n\t\t\t\t}, 0));\n\t\t}\n\t\t// oh well, at least we tried\n\t\tcatch(e_define) {}\n\t}\n}\n\n\n\nconst uri = require('uri-js');\nconst string_decoder = require('string_decoder');\n\nconst stream = require('@graphy/core.iso.stream');\nconst factory = require('@graphy/core.data.factory');\nconst quad = k => factory.quad(k._kt_subject, k._kt_predicate, k._kt_object, k._kt_graph);\n\n// eslint-disable-next-line no-misleading-character-class\nconst RT_PREFIXED_NAME_NAMESPACE_VALID = /^([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}]([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}.]*[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}])?)?$/u;\n// eslint-disable-next-line no-misleading-character-class\nconst RT_PREFIXED_NAME_LOCAL_NAME_VALID = /^([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_:0-9]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&'()*+,;=/?#@%])(([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}.:]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&'()*+,;=/?#@%])*([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}:]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&'()*+,;=/?#@%]))?$/u;\n// eslint-disable-next-line no-misleading-character-class\nconst RT_BLANK_NODE_VALID = /^[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_0-9]([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}.]*[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}])?$/u;\nconst RT_NAMED_NODE_VALID = /^([^\\0-\\x20<>\"{}|^`\\\\]|\\\\u[A-Fa-f0-9]{4}|\\\\U[A-Fa-f0-9]{8})*$/;\nconst RT_NAMED_NODE_ESCAPELESS_VALID = /^([^\\0-\\x20<>\"{}|^`])*$/;\n\nconst RT_LITERAL_CONTENTS_VALID = /^(?:[^\\\\]|\\\\[tbnrf\"'\\\\]|\\\\u[A-Fa-f0-9]{4}|\\\\U[A-Fa-f0-9]{8})*$/;\n\nconst R_UNICODE_ANY = /\\\\u([0-9A-Fa-f]{4})|\\\\U([0-9A-Fa-f]{8})/g;\n\nconst F_REPLACE_UNICODE_ANY = \t(s_, s_4, s_8) => String.fromCodePoint(parseInt(s_4 || s_8, 16));\n\nconst OPHOP = Object.prototype.hasOwnProperty;\n\n\n\nconst R_PREFIXED_NAME_QUICK = /([A-Za-z][A-Za-z0-9_-]*)?:([A-Za-z_0-9:][A-Za-z0-9_:-]*)(?:\\s+|(?=\\.?[<[(\"';,)\\]#{}]|\\.[\\s\\0]))/y;\n\n\nconst R_PREFIXED_NAME_ESCAPELESS = /([^\\s#@<[(\"':_{}][^\\s#@<[(\"':{}]*)?:((?:[^\\s#@<[(\"'.;,{})\\]\\\\](?:[^\\s#@<[(\"';,{})\\]\\\\]*[^\\s#@<[(\"'.;,{})\\]\\\\])?)?)(?:\\s+|(?=\\.?[<[(\"';,)\\]#{}]|\\.[\\s\\0]))/y;\n\n\n\nconst R_PREFIXED_NAME = /([^\\s#@<[(\"':_{}][^\\s#@<[(\"':{}]*)?:((?:(?:[^\\s#@<[(\"'.;,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"]))(?:(?:[^\\s#@<[(\"';,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"]))*(?:[^\\s#@<[(\"'.;,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"])))?)?)(?:\\s+|(?=\\.?[<[(\"';,)\\]#{}]|\\.[\\s\\0]))/y;\n\nconst R_PN_LOCAL_ESCAPES = /\\\\(.)/g;\n\n\nconst R_BLANK_NODE_LABEL = /_:(.(?:[^\\s:<;,)\\]#}]*[^\\s:<.;,)\\]#}])?)(?:\\s+|(?=[<:{,;\\])#]))/y;\nconst R_BLANK_NODE_LABEL_TERMINAL = /_:(.(?:[^\\s:<;,)\\]#}]*[^\\s:<.;,)\\]#}])?)(?:\\s+|(?=\\.?[<:{,;\\])#])|(?=\\.[\\s@#<({[}]))/y;\n\nconst R_IRIREF_ESCAPELESS = /<([^\\\\>]*)>\\s*/y;\nconst R_IRIREF = /<([^>]*)>\\s*/y;\n\nconst R_NUMERIC_LITERAL = /([+-]?(?:[0-9]+(\\.[0-9]+)?|(\\.[0-9]+))(\\.?[eE][+-]?[0-9]+)?)(?:\\s+|(?=\\.[^eE0-9]|[;,)\\]]))/y;\nconst R_BOOLEAN_LITERAL = /(?:(true|TRUE)|false|FALSE)\\s*/y;\nconst R_A = /a(?:\\s+|(?=[[(\"'<#]))/y;\n\nconst R_DOUBLE_CARET = /\\^\\^/y;\nconst R_WS = /\\s*/y;\nconst R_LANGTAG = /@([A-Za-z]+(?:-[A-Za-z0-9-]+)*)(?:\\s+|(?=[.},;\\])#]))/y;\n\nconst R_PREFIX_KEYWORD = /(?:(@prefix)|[pP][rR][eE][fF][iI][xX])\\s*/y;\nconst R_PREFIX_ID = /([^#:]*):\\s*/iy;\nconst R_BASE_KEYWORD = /(?:(@base)|[bB][aA][sS][eE])\\s*/y;\n\nconst R_GRAPH_IRI_ESCAPELESS = /(?:graph)?\\s*<([^\\\\>]*)>\\s*\\{\\s*/iy;\nconst R_GRAPH_PREFIXED_NAME = /(?:graph)?\\s*([^\\s#@<[(\"':_{}][^\\s#@<[(\"':{}]*)?:((?:(?:[^\\s#@<[(\"'.;,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"]))(?:(?:[^\\s#@<[(\"';,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"]))*(?:[^\\s#@<[(\"'.;,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"])))?)?)\\s*\\{\\s*/iy;\nconst R_GRAPH_LABELED_BLANK_NODE = /(?:graph)?\\s*_:(.(?:[^\\s:<;,)\\]#}]*[^\\s:<.;,)\\]#}])?)\\s*\\{\\s*/iy;\nconst R_GRAPH_ANONYMOUS_BLANK_NODE = /(?:graph)?\\s*\\[\\s*\\]\\s*\\{\\s*/iy;\nconst R_GRAPH_IRI = /(?:graph)?\\s*<([^>]*)>\\s*\\{\\s*/iy;\nconst R_GRAPH = /graph(?:\\s+|(?=[#<[{]))/iy;\n\nconst R_COMMENT = /(#[^\\n]*\\n\\s*)+/y;\n\nconst RT_IRI_ABSOLUTE = /^[A-Za-z][A-Za-z0-9.\\-+]*:/;\nconst R_RELATIVE_URI = /^(\\/[^?#]+)([?#].*)?$/;\nconst R_BASE_IRI = /^((([A-Za-z0-9.\\-+]*:\\/)?\\/[^/>]*)?(\\/(?:[^/>]*\\/)*)?[^>]*)$/;\n\nconst R_ANONYMOUS_BLANK_NODE = /\\[\\s*\\]\\s*/y;\nconst R_CHAR_BLANK_NODE = /\\[(?:\\s+|(?=[^\\]]))/y;\nconst R_CHAR_COLLECTION = /\\(\\s*/y;\n\nconst R_CHAR_KET = /\\]\\s*/y;\n\nconst R_CHAR_OPEN = /\\{\\s*/y;\nconst R_CHAR_CLOSE = /\\}\\s*/y;\n\nconst R_CHAR_STOP = /\\.\\s*/y;\n\n\n\nconst R_STRLIT_SHORT_DOUBLE_BREAK = /[\\\\\"\\r\\n]/g;\nconst R_STRLIT_SHORT_SINGLE_BREAK = /[\\\\'\\r\\n]/g;\n\nconst R_STRLIT_LONG_DOUBLE_UNFINISHED_TERM = /\"{1,2}$/g;\nconst R_STRLIT_LONG_SINGLE_UNFINISHED_TERM = /'{1,2}$/g;\n\nconst R_STRLIT_LONG_DOUBLE_BREAK = /(\\\\|\"\"\")/g;\nconst R_STRLIT_LONG_SINGLE_BREAK = /(\\\\|''')/g;\n\n\nconst F_REPLACE_STRLIT_CONTENTS = (s_, s_whitespace, s_auto, s_4, s_8, s_invalid) => {\n\tif(s_whitespace) {\n\t\tswitch(s_whitespace) {\n\t\t\tcase 't': return '\\t';\n\t\t\tcase 'n': return '\\n';\n\t\t\tcase 'r': return '\\r';\n\t\t\tcase 'f': return '\\f';\n\t\t\tcase 'b': return '\\b';\n\t\t\tdefault: {\n\t\t\t\tconsole.assert(`bad regex escape char mapping: '${s_whitespace}'`);\n\t\t\t}\n\t\t}\n\t}\n\telse if(s_auto) {\n\t\treturn s_auto;\n\t}\n\telse if(s_4) {\n\t\treturn String.fromCodePoint(parseInt(s_4, 16));\n\t}\n\telse if(s_8) {\n\t\treturn String.fromCodePoint(parseInt(s_8, 16));\n\t}\n\telse if(s_invalid) {\n\t\t// pointless escape\n\t\tif('\\\\' === s_invalid[0]) {\n\t\t\t\t// // relaxed\n\t\t\t\t// return s_invalid[1];\n\t\t\t// if relaxed then return s_invalid, otherwise throw:\n\t\t\tthrow new Error(`expected string_literal but invalid escape sequence within contents: '${s_invalid}'. failed to parse a valid token`);\n\t\t}\n\t\t// bad character\n\t\telse {\n\t\t\tthrow new Error(`expected string_literal but invalid whitespace character within contents: ${JSON.stringify(s_invalid)}. failed to parse a valid token`);\n\t\t}\n\t}\n\telse {\n\t\tconsole.assert(`unexpected no match branch in escape sequence replace callback`);\n\t}\n};\n\n\nconst R_STRLIT_SHORT_CONTENTS_ESCAPES_HARD = /(?:\\\\(?:([tnrfb])|([\\\\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|([\\r\\n]|\\\\.))/g;\nconst R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT = /(?:\\\\(?:([tnrfb])|([\\\\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|([\\r\\n]|\\\\[^uU]|\\\\u[^]{4}|\\\\U[^]{8}))/g;\n\nconst unescape_literal_short_hard = s_literal => s_literal\n\t.replace(R_STRLIT_SHORT_CONTENTS_ESCAPES_HARD, F_REPLACE_STRLIT_CONTENTS);\n\nconst unescape_literal_short_soft = (s_literal) => {\n\tlet m_incomplete = R_STRLIT_ESCAPE_INCOMPLETE.exec(s_literal);\n\n\t// incomplete escape\n\tif(m_incomplete) {\n\t\tlet i_safe = m_incomplete.index;\n\n\t\t// rewind\n\t\treturn [\n\t\t\ts_literal.slice(0, i_safe)\n\t\t\t\t.replace(R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),\n\t\t\ts_literal.slice(i_safe),\n\t\t];\n\t}\n\t// done\n\telse {\n\t\treturn [\n\t\t\ts_literal\n\t\t\t\t.replace(R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),\n\t\t\t'',\n\t\t];\n\t}\n};\n\n\nconst R_STRLIT_LONG_CONTENTS_ESCAPES_HARD = /(?:\\\\(?:([tnrfb])|([\\\\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|(\\\\.))/g;\nconst R_STRLIT_LONG_CONTENTS_ESCAPES_SOFT = /(?:\\\\(?:([tnrfb])|([\\\\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|(\\\\[^uU]|\\\\u[^]{4}|\\\\U[^]{8}))/g;\n\nconst unescape_literal_long_hard = s_literal => s_literal\n\t.replace(R_STRLIT_LONG_CONTENTS_ESCAPES_HARD, F_REPLACE_STRLIT_CONTENTS);\n\nconst unescape_literal_long_soft = (s_literal) => {\n\tlet m_incomplete = R_STRLIT_ESCAPE_INCOMPLETE.exec(s_literal);\n\n\t// incomplete escape\n\tif(m_incomplete) {\n\t\tlet i_safe = m_incomplete.index;\n\n\t\t// rewind\n\t\treturn [\n\t\t\ts_literal.slice(0, i_safe)\n\t\t\t\t.replace(R_STRLIT_LONG_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),\n\t\t\ts_literal.slice(i_safe),\n\t\t];\n\t}\n\t// done\n\telse {\n\t\treturn [\n\t\t\ts_literal\n\t\t\t\t.replace(R_STRLIT_LONG_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),\n\t\t\t'',\n\t\t];\n\t}\n};\n\n// lookbehind regexes\nconst [\n\tR_STRLIT_ESCAPE_INCOMPLETE,\n\tR_STRLIT_SHORT_DOUBLE_TERM,\n\tR_STRLIT_SHORT_SINGLE_TERM,\n\tR_STRLIT_LONG_DOUBLE_TERM,\n\tR_STRLIT_LONG_SINGLE_TERM,\n] = (() => {\n\tfunction RegExp_$lookbehind_polyfill(s_input) {\n\t\tlet m_match = RegExp.prototype.exec.call(this, s_input);\n\n\t\tif(m_match) {\n\t\t\tlet i_start = m_match[0].length - m_match[1].length;\n\t\t\tm_match.index += i_start;\n\t\t\tm_match[0] = m_match[0].slice(i_start);\n\t\t}\n\n\t\treturn m_match;\n\t}\n\tlet mk_lookbehind_regex = (() => {\n\t\ttry {\n\t\t\tnew RegExp('(?<!h)i');  // eslint-disable-line no-new\n\t\t}\n\t\tcatch(e_compile) {\n\t\t\treturn (f_lookbehind, r_polyfill, f_polyfill) => {\n\t\t\t\tr_polyfill.exec = f_polyfill;\n\t\t\t\treturn r_polyfill;\n\t\t\t};\n\t\t}\n\t\treturn f_lookbehind => f_lookbehind();\n\t})();\n\treturn [\n\t\t// R_STRLIT_ESCAPE_INCOMPLETE\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\\\\\\\\(|u[0-9A-Fa-f]{0,3}|U[0-9A-Fa-f]{0,7})$'),\n\t\t\t/^(?:(?:[^\\\\]|\\\\.)*)(\\\\(?:|u[0-9A-Fa-f]{0,3}|U[0-9A-Fa-f]{0,7}))$/,\n\t\t\tfunction RegExp_$lookbehind_polyfill_n(s_input) {\n\t\t\t\tlet m_match = RegExp.prototype.exec.call(this, s_input);\n\t\t\t\tif(m_match) {\n\t\t\t\t\tm_match.index += m_match[0].length - m_match[1].length;\n\t\t\t\t}\n\n\t\t\t\treturn m_match;\n\t\t\t},\n\t\t),\n\t\t// R_STRLIT_SHORT_DOUBLE_TERM\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\"\\\\s*', 'g'),\n\t\t\t/(?:[^\\\\\"]|\\\\.)*(\"\\s*)/y,\n\t\t\tRegExp_$lookbehind_polyfill,\n\t\t),\n\t\t// R_STRLIT_SHORT_SINGLE_TERM\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\\'\\\\s*', 'g'),\n\t\t\t/(?:[^\\\\']|\\\\.)*('\\s*)/y,\n\t\t\tRegExp_$lookbehind_polyfill,\n\t\t),\n\n\t\t// R_STRLIT_LONG_DOUBLE_TERM\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\"\"\"\\\\s*', 'g'),\n\t\t\t/(?:[^\\\\\"]|\\\\.|\"\"?(?!\"))*(\"\"\"\\s*)/y,\n\t\t\tRegExp_$lookbehind_polyfill,\n\t\t),\n\n\t\t// R_STRLIT_LONG_SINGLE_TERM\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\\'\\'\\'\\\\s*', 'g'),\n\t\t\t/(?:[^\\\\']|\\\\.|''?(?!'))*('''\\s*)/y,\n\t\t\tRegExp_$lookbehind_polyfill,\n\t\t),\n\n\t];\n})();\n\nconst match_prefixed_name_quick = (s, i) => {\n\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\treturn [R_PREFIXED_NAME_QUICK.exec(s), R_PREFIXED_NAME_QUICK.lastIndex];\n};\n\nconst match_prefixed_name_escapeless = (s, i) => {\n\tR_PREFIXED_NAME_ESCAPELESS.lastIndex = i;\n\treturn [R_PREFIXED_NAME_ESCAPELESS.exec(s), R_PREFIXED_NAME_ESCAPELESS.lastIndex];\n};\n\nconst match_prefixed_name = (s, i) => {\n\tR_PREFIXED_NAME.lastIndex = i;\n\treturn [R_PREFIXED_NAME.exec(s), R_PREFIXED_NAME.lastIndex];\n};\n\n\n\nfunction Reader$syntax_error(k_self, i, si_state, s_info) {\n\tlet i_off = Math.min(i, Math.abs(i-15));\n\n\tlet s = k_self.s;\n\n\treturn k_self.error(`\\n\\`${s.substr(i_off, i_off+90).replace(/[\\n\\t]/g, ' ')}\\`\\n`\n\t\t+` ${' '.repeat(i-i_off)}^\\n`\n\t\t+`expected ${si_state} ${s_info || ''}.  failed to parse a valid token starting at ${s[i]? '\"'+s[i]+'\"': '<<EOF>>'}`);\n}\n\n\n\nclass TriG_Reader extends stream.Transform {\n\tconstructor(g_impls) {\n\t\tsuper({\n\t\t\t// do not decode strings into buffers\n\t\t\tdecodeStrings: false,\n\n\t\t\t// accept strings as input on writable side\n\t\t\twritableObjectMode: false,\n\n\t\t\t// output quad objects on readable side\n\t\t\treadableObjectMode: true,\n\n\t\t\t// implementations\n\t\t\tflush: g_impls.flush,\n\t\t\ttransform: g_impls.transform,\n\t\t});\n\t}\n\n\t// intercept pipe\n\tpipe(ds_out) {\n\t\tlet ds_dst = ds_out;\n\n\t\t// non-object mode\n\t\tif(!ds_dst._writableState.objectMode) {\n\t\t\t// transform to JSON\n\t\t\tds_out = stream.quads_to_json();\n\t\t}\n\t\t// yet object mode and graphy writable\n\t\telse if(ds_out.isGraphyWritable) {\n\t\t\t// transform to writable data events\n\t\t\tds_out = stream.quads_to_writable();\n\t\t}\n\n\t\t// interim stream created\n\t\tif(ds_out !== ds_dst) {\n\t\t\t// forward output to super\n\t\t\tsuper.pipe(ds_out);\n\n\t\t\t// pipe outpu to destination\n\t\t\treturn ds_out.pipe(ds_dst);\n\t\t}\n\t\t// forward as-is to super\n\t\telse {\n\t\t\treturn super.pipe(ds_dst);\n\t\t}\n\t}\n}\n\n\nclass Reader {\n\tconstructor(g_config={}) {\n\t\t// impl-specific configs\n\t\tlet {\n\t\t\t// input medium\n\t\t\tinput: g_input=null,\n\n\t\t\t// a state to inherit\n\t\t\tstate: g_state={},\n\t\t} = g_config;\n\n\t\t// inherit state from creator\n\t\tlet {\n\t\t\t// index for anonymous blank node labels\n\t\t\tblank_node_index: i_anon=0,\n\n\t\t\t// prefix map\n\t\t\tprefixes: h_prefixes={},\n\n\t\t\t// blank node label map\n\t\t\tlabels: h_labels={},\n\t\t} = g_state;\n\n\n\t\tlet dc_factory = factory.adopt(g_config.dataFactory || g_config.data_factory || factory.unfiltered);\n\n\t\tlet kt_default_graph = dc_factory.defaultGraph();\n\n\t\t// if data factory is not graphy, it might be returning the same object on each call to .defaultGraph()\n\t\tif(dc_factory !== factory.unfiltered) {\n\t\t\t// do not trust it, create a new object\n\t\t\tkt_default_graph = Object.create(kt_default_graph);\n\t\t}\n\n\t\tlet kt_rdf_first = dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#first');\n\n\t\tlet blankNode = dc_factory.blankNode;\n\t\tlet namedNode = dc_factory.namedNode;\n\n\t\tthis.emit_data = factory.unfiltered === dc_factory\n\t\t\t? function() {\n\t\t\t\tds_transform.push(quad(this));\n\t\t\t}\n\t\t\t: function() {\n\t\t\t\tlet g_quad = dc_factory.quad(this._kt_subject, this._kt_predicate, this._kt_object, this._kt_graph);\n\t\t\t\tds_transform.push(g_quad);\n\t\t\t};\n\n\t\t// fields\n\t\tObject.assign(this, {\n\t\t\t// read index\n\t\t\ti: 0,\n\n\t\t\t// string buffer\n\t\t\ts: '',\n\n\t\t\t// string buffer length\n\t\t\tn: 0,\n\n\t\t\t// left-over string from previous data chunk\n\t\t\tpre: g_config.prepend || '',\n\n\t\t\t// debug state\n\t\t\t_b_debug: g_config.debug || false,\n\n\t\t\t// relax\n\t\t\t_b_relax: g_config.relax || false,\n\n\t\t\t// factory\n\t\t\t_dc_factory: dc_factory,\n\n\t\t\t// current reader state\n\t\t\t_f_state: this.block,\n\n\t\t\t// map of current prefix ids => iris\n\t\t\t_h_prefixes: h_prefixes,\n\n\n\t\t\t// reader was destroyed by an error\n\t\t\t_b_destroyed: false,\n\n\t\t\t// current @base url\n\t\t\t_s_base_url: '',\n\t\t\t_s_base_url_scheme: '',\n\t\t\t_s_base_url_root: '',\n\t\t\t_s_base_url_path: '',\n\n\t\t\t// current data\n\t\t\t_kt_subject: null,\n\t\t\t_kt_predicate: kt_rdf_first,\n\t\t\t_kt_object: null,\n\t\t\t_kt_graph: kt_default_graph,\n\t\t\t_s_literal: '',\n\n\t\t\t// static terms\n\t\t\t_kt_rdf_type: dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),\n\t\t\t_kt_rdf_first: kt_rdf_first,\n\t\t\t_kt_rdf_rest: dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#rest'),\n\t\t\t_kt_rdf_nil: dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#nil'),\n\t\t\t_kt_default_graph: kt_default_graph,\n\n\t\t\t// queue of nested subject, predicate, state for blanknodes and collections\n\t\t\t_a_nested: [],\n\n\t\t\t// hash to keep track of all blank node labels in use\n\t\t\t_h_labels: h_labels,\n\n\t\t\t// event routing\n\t\t\tevent: this.emit,\n\t\t\tdata: this.emit_data,\n\n\t\t\t// for restoring the original event callback when resuming paused stream\n\t\t\trestore_data: this.emit_data,\n\n\t\t\t// keep a queue of data events to hold onto until stream resumes (only happens in rare conditions)\n\t\t\t_a_queue_event: [],\n\n\t\t\t// helper states\n\t\t\t_b_expecting_full_stop: false,\n\t\t\t_s_temp_prefix_id: null,\n\t\t\t_b_trim_start: true,\n\n\t\t\tanonymous_blank_node: s_label => blankNode(s_label, true),\n\n\t\t\t// finds the next non-conflicting blank node label\n\t\t\tnext_label() {\n\t\t\t\tlet s_label = '';\n\t\t\t\tdo {\n\t\t\t\t\ts_label = 'g'+(i_anon++);\n\t\t\t\t} while(this._h_labels[s_label]);\n\n\t\t\t\t// claim this label, and remember that we invented it\n\t\t\t\tthis._h_labels[s_label] = 2;\n\n\t\t\t\t// return the label\n\t\t\t\treturn s_label;\n\t\t\t},\n\n\t\t\t// what to do when reach eos\n\t\t\teos: null,\n\n\t\t\t// which state to go to after end of statement\n\t\t\tafter_end_of_statement: this.post_object,\n\n\t\t\t// maximum length of a token: defaults to 2048 => http://stackoverflow.com/a/417184/1641160\n\t\t\t_n_max_token_length: g_config.max_token_length || g_config.maxTokenLength || 2048,\n\n\t\t\t// maximum length of a string (overrides max_token_length): defaults to Infinity\n\t\t\t_n_max_string_length: g_config.max_string_length || g_config.maxStringLength || Infinity,\n\n\t\t\t// byte tracking\n\t\t\t_b_byte_tracking: g_config.byte_tracking || g_config.byteTracking || false,\n\t\t\t_nb_seen: 0,\n\t\t\t_nb_last: 0,\n\t\t\t_nb_curr: 0,\n\t\t});\n\n\t\tif(g_config.relaxed) {\n\t\t\tconsole.warn((new Error(`no such option 'relaxed'; did you mean 'relax' ?`)).stack.replace(/^Error:/, 'Warning:'));\n\t\t}\n\t\tif('validate' in g_config) {\n\t\t\tconsole.warn((new Error(`option 'validate' has been deprecated. Validation is now enabled by default. Use the 'relax' option if you wish to disable validation.`)).stack.replace(/^Error:/, 'Warning:'));\n\t\t}\n\n\n\n\t\t// term constructors\n\t\tObject.assign(this, !g_config.relax\n\t\t\t? {\n\t\t\t\tblank_node(s_label) {\n\t\t\t\t\t// test valid blank node label\n\t\t\t\t\tif(!RT_BLANK_NODE_VALID.test(s_label)) return this.error(`invalid blank node label: \"${s_label}\"`);\n\n\t\t\t\t\t// not first time use of label\n\t\t\t\t\tlet z_label_state = this._h_labels[s_label];\n\t\t\t\t\tif(z_label_state) {\n\t\t\t\t\t\t// label was used previously by document and has no conflict\n\t\t\t\t\t\tif(1 === z_label_state) {}  // eslint-disable-line no-empty\n\t\t\t\t\t\t// label is in use by invention, this would cause a conflict\n\t\t\t\t\t\telse if(2 === z_label_state) {\n\t\t\t\t\t\t\t// so create a redirect mapping for this actual label & use it instead\n\t\t\t\t\t\t\ts_label = this._h_labels[s_label] = this.next_label();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// label already has a redirect mapping\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// use redirected label\n\t\t\t\t\t\t\ts_label = this._h_labels[s_label];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// first time use of label\n\t\t\t\t\telse {\n\t\t\t\t\t\t// store label in hash so we avoid future collisions\n\t\t\t\t\t\tthis._h_labels[s_label] = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// make term\n\t\t\t\t\treturn blankNode(s_label);\n\t\t\t\t},\n\n\t\t\t\tcheck_named_node(p_iri) {\n\t\t\t\t\tif(!RT_NAMED_NODE_VALID.test(p_iri)) return this.error(`invalid IRI: \"${p_iri}\"`);\n\t\t\t\t\treturn namedNode(p_iri);\n\t\t\t\t},\n\n\t\t\t\tcheck_named_node_escapeless(p_iri) {\n\t\t\t\t\tif(!RT_NAMED_NODE_ESCAPELESS_VALID.test(p_iri)) return this.error(`invalid IRI: \"${p_iri}\"`);\n\t\t\t\t\treturn namedNode(p_iri);\n\t\t\t\t},\n\n\t\t\t\tmatch_prefixed_name_quick(s, i) {\n\t\t\t\t\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\t\t\t\t\treturn [R_PREFIXED_NAME_QUICK.exec(s), R_PREFIXED_NAME_QUICK.lastIndex];\n\t\t\t\t},\n\n\t\t\t\tmatch_prefixed_name_escapeless(s, i) {\n\t\t\t\t\tlet [m_prefixed_name_e, im_prefixed_name_e] = match_prefixed_name_escapeless(s, i);\n\t\t\t\t\tif(m_prefixed_name_e) {\n\t\t\t\t\t\t// invalid local name\n\t\t\t\t\t\tif(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name_e[2]) && m_prefixed_name_e[2]) {\n\t\t\t\t\t\t\tthis.error(`invalid prefixed name local name: \"${m_prefixed_name_e[2]}:\"`);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [m_prefixed_name_e, im_prefixed_name_e];\n\t\t\t\t},\n\n\t\t\t\tmatch_prefixed_name(s, i) {\n\t\t\t\t\tlet [m_prefixed_name, im_prefixed_name] = match_prefixed_name(s, i);\n\t\t\t\t\tif(m_prefixed_name) {\n\t\t\t\t\t\t// invalid local name\n\t\t\t\t\t\tif(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name[2])) {\n\t\t\t\t\t\t\tthis.error(`invalid prefixed name local name: \"${m_prefixed_name[2]}:\"`);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [m_prefixed_name, im_prefixed_name];\n\t\t\t\t},\n\t\t\t}\n\t\t\t: {\n\t\t\t\t// term constructors\n\t\t\t\tblank_node(s_label) {\n\t\t\t\t\t// not first time use of label\n\t\t\t\t\tlet z_label_state = this._h_labels[s_label];\n\t\t\t\t\tif(z_label_state) {\n\t\t\t\t\t\t// label was used previously by document and has no conflict\n\t\t\t\t\t\tif(1 === z_label_state) {}  // eslint-disable-line no-empty\n\t\t\t\t\t\t// label is in use by invention, this would cause a conflict\n\t\t\t\t\t\telse if(2 === z_label_state) {\n\t\t\t\t\t\t\t// so create a redirect mapping for this actual label & use it instead\n\t\t\t\t\t\t\ts_label = this._h_labels[s_label] = this.next_label();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// label already has a redirect mapping\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// use redirected label\n\t\t\t\t\t\t\ts_label = this._h_labels[s_label];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// first time use of label\n\t\t\t\t\telse {\n\t\t\t\t\t\t// store label in hash so we avoid future collisions\n\t\t\t\t\t\tthis._h_labels[s_label] = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// make term\n\t\t\t\t\treturn blankNode(s_label);\n\t\t\t\t},\n\n\t\t\t\tcheck_named_node: namedNode,\n\n\t\t\t\tcheck_named_node_escapeless: namedNode,\n\n\t\t\t\tmatch_prefixed_name_escapeless,\n\n\t\t\t\tmatch_prefixed_name,\n\t\t\t});\n\n\n\t\tthis.named_node = namedNode;\n\n\t\tthis.prefixed_name = function(si_prefix, s_suffix) {\n\t\t\treturn namedNode(h_prefixes[si_prefix] + s_suffix);\n\t\t};\n\n\n\t\t// oops -- user passed string into `base`\n\t\tif('string' === typeof g_config.base) {\n\t\t\tthrow new TypeError(`invalid type 'string' was given for 'base' event listener: '${g_config.base}'\\n`\n\t\t\t\t+`did you mean to use the 'base_uri' key instead?`);\n\t\t}\n\n\t\t// base uri\n\t\tlet p_set_base_uri = g_config.base_uri || g_config.baseUri || g_config.baseURI || g_config.base_iri || g_config.baseIri || g_config.baseIRI;\n\t\tif(p_set_base_uri) {\n\t\t\tlet m_base_iri = R_BASE_IRI.exec(p_set_base_uri);\n\t\t\tthis._s_base_url = m_base_iri[1];\n\t\t\tthis._s_base_url_root = m_base_iri[2] || '';\n\t\t\tthis._s_base_url_scheme = m_base_iri[3] || '';\n\t\t\tthis._s_base_url_path = m_base_iri[4] || '';\n\t\t}\n\t\t// not set; 'url' variant is\n\t\telse if(g_config.base_url || g_config.baseUrl || g_config.baseURL) {\n\t\t\tthrow new Error(`invalid option: .base${g_config.base_url? '_url': g_config.baseUrl? 'Url': g_config.baseURL? 'URL': ''}; use the '.base_uri' key instead`);\n\t\t}\n\n\t\t// transform stream\n\t\tlet ds_transform = this.transform = new TriG_Reader({\n\t\t\t// on data event\n\t\t\ttransform: (s_chunk, s_encoding, fke_chunk) => {\n\t\t\t\t// concatenate current chunk to previous chunk\n\t\t\t\tlet s = this.s = this.pre + s_chunk;\n\n\t\t\t\t// cache chunk length\n\t\t\t\tthis.n = s.length;\n\n\t\t\t\t// eat whitespace before token and reset index\n\t\t\t\tif(this._b_trim_start) {\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\tR_WS.lastIndex = 0;\n\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\tthis.i = R_WS.lastIndex;\n\t\t\t\t}\n\t\t\t\t// do not eat whitespace; start at beginning\n\t\t\t\telse {\n\t\t\t\t\tthis.i = 0;\n\t\t\t\t}\n\n\t\t\t\t// resume parsing; no errors\n\t\t\t\tif(this.safe_parse(true)) {\n\t\t\t\t\t// emit progress event updates\n\t\t\t\t\tds_transform.emit('progress', s_chunk.length);\n\n\t\t\t\t\t// done transforming this chunk\n\t\t\t\t\tfke_chunk();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// once there's no more data to consume, invoke eof\n\t\t\tflush: (fke_flush) => {\n\t\t\t\t// now that input stream has ended, clean up remainder\n\t\t\t\ttry {\n\t\t\t\t\tthis.eof(1);\n\t\t\t\t}\n\t\t\t\t// read error occurred\n\t\t\t\tcatch(e_eof) {\n\t\t\t\t\t// destroy self and stream\n\t\t\t\t\tthis.destroy(e_eof);\n\n\t\t\t\t\t// exit gracefully\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// no errors. done flushing, close read stream\n\t\t\t\tfke_flush();\n\t\t\t},\n\t\t});\n\n\t\t// when the writable side is piped into\n\t\tds_transform.on('pipe', (ds_input) => {\n\t\t\tthis._ds_input = ds_input;\n\n\t\t\tlet b_byte_tracking = this._b_byte_tracking;\n\n\t\t\t// byte-tracking is disable & input stream has encoding option; ensure stream encoding is utf8\n\t\t\tif(!b_byte_tracking && 'function' === typeof ds_input.setEncoding) {\n\t\t\t\tds_input.setEncoding('utf8');\n\t\t\t}\n\t\t\t// set decoding on write\n\t\t\telse {\n\t\t\t\tlet f_write = ds_transform.write;\n\t\t\t\tlet d_decoder = new string_decoder.StringDecoder('utf8');\n\n\t\t\t\tlet f_write_track = (s_chunk, s_encoding, fk_write) => {\n\t\t\t\t\t// TODO: optimize by testing for multibyte chars and using string length instead?\n\t\t\t\t\tlet nb_chunk = Buffer.from(s_chunk, 'utf8').length;\n\t\t\t\t\tthis._nb_seen += nb_chunk;\n\t\t\t\t\tthis._nb_last = nb_chunk;\n\t\t\t\t\treturn f_write.call(ds_transform, s_chunk, s_encoding, fk_write);\n\t\t\t\t};\n\n\t\t\t\tlet f_decode_write_track = (ab_chunk, s_encoding, fk_write) => {\n\t\t\t\t\tlet nb_chunk = this._nb_last = ab_chunk.length;\n\t\t\t\t\tthis._nb_seen += nb_chunk;\n\t\t\t\t\treturn f_write.call(ds_transform, d_decoder.write(ab_chunk), s_encoding, fk_write);\n\t\t\t\t};\n\n\t\t\t\tlet f_decode_write = (ab_chunk, s_encoding, fk_write) => f_write.call(ds_transform, d_decoder.write(ab_chunk), s_encoding, fk_write);\n\n\t\t\t\tds_transform.write = function(z_chunk, s_encoding, fk_write) {\n\t\t\t\t\t// not null\n\t\t\t\t\tif(null !== z_chunk) {\n\t\t\t\t\t\t// chunk is string; adapt by resetting method to original\n\t\t\t\t\t\tif('string' === typeof z_chunk) {\n\t\t\t\t\t\t\tds_transform.write = b_byte_tracking? f_write_track: f_write;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// chunk is buffer; adapt by setting decoder write method\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tds_transform.write = b_byte_tracking? f_decode_write_track: f_decode_write;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// use set method\n\t\t\t\t\t\treturn ds_transform.write(z_chunk, s_encoding, fk_write);\n\t\t\t\t\t}\n\n\t\t\t\t\t// null, use parent\n\t\t\t\t\treturn f_write.call(ds_transform, z_chunk, s_encoding, fk_write);\n\t\t\t\t};\n\n\t\t\t\t// byte tracking is enabled\n\t\t\t\tif(b_byte_tracking) {\n\t\t\t\t\t// overwrite emit_data method\n\t\t\t\t\tthis.emit_data = this.data = this.restore_data = function() {\n\t\t\t\t\t\tlet g_quad = this._dc_factory.quad(this._kt_subject, this._kt_predicate, this._kt_object, this._kt_graph);\n\t\t\t\t\t\tlet nb_post = Buffer.from(this.s.slice(this.i)).length;\n\t\t\t\t\t\tlet ib_post = this._nb_seen - nb_post;\n\t\t\t\t\t\tg_quad.byteRange = [this._nb_curr, ib_post];\n\t\t\t\t\t\tthis._nb_curr = ib_post;\n\t\t\t\t\t\tthis.transform.push(g_quad);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// new listener added\n\t\tds_transform.on('newListener', (s_event) => {\n\t\t\t// comment\n\t\t\tif('comment' === s_event) {\n\t\t\t\tthis.emit_comments = (s_captured) => {\n\t\t\t\t\tlet a_comments = s_captured.slice(1).replace(/\\n\\s+$/, '').split(/\\n+\\s*#/g);\n\n\t\t\t\t\tfor(let s_comment of a_comments) {\n\t\t\t\t\t\tds_transform.emit('comment', s_comment);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\t// destroy\n\t\tds_transform._destroy = (...a_args) => {\n\t\t\tthis.destroy(...a_args);\n\t\t};\n\n\t\t// bind events to transform stream\n\t\tthis.bind(g_config);\n\n\t\t// input given\n\t\tif(g_input) {\n\t\t\t// input is stream\n\t\t\tif(g_input.stream) {\n\t\t\t\tlet ds_input = g_input.stream;\n\n\t\t\t\t// go async so caller has chance to bind event listeners\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tds_input.pipe(ds_transform);\n\t\t\t\t});\n\t\t\t}\n\t\t\t// string\n\t\t\telse if('string' === typeof g_input.string) {\n\t\t\t\tlet s_input = g_input.string;\n\n\t\t\t\t// go async so caller has chance to bind event listeners\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tds_transform.end(s_input, 'utf8');\n\t\t\t\t});\n\t\t\t}\n\t\t\t// invalid arg\n\t\t\telse {\n\t\t\t\tthrow new TypeError(`Invalid argument for input parameter: ${'object' === typeof g_input? JSON.stringify(g_input): g_input}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t// begin parsing, keep applying until no more stack bail-outs\n\tsafe_parse() {\n\t\ttry {\n\t\t\tlet f_sync = this._f_state();\n\t\t\twhile('function' === typeof f_sync) {\n\t\t\t\tf_sync = f_sync.apply(this);\n\t\t\t}\n\t\t}\n\t\t// read error occurred\n\t\tcatch(e_read) {\n\t\t\t// destroy self and stream\n\t\t\tthis.destroy(e_read);\n\n\t\t\t// failure\n\t\t\treturn false;\n\t\t}\n\n\t\t// okay\n\t\treturn true;\n\t}\n\n\n\temit(s_event, ...a_args) {\n\t\tthis.transform.emit(s_event, ...a_args);\n\t}\n\n\tqueue(s_event, ...a_args) {\n\t\tthis._a_queue_event.push({\n\t\t\tevent: s_event,\n\t\t\targs: a_args,\n\t\t});\n\t}\n\n\terror(s_message) {\n\t\t// bail out\n\t\tthrow new Error(s_message);\n\t}\n\n\t// parse_error (not meant to be an event callback)\n\tparse_error(s_expected, b_eof=false) {\n\t\tlet i = this.i;\n\n\t\tlet i_off = Math.min(i, Math.abs(i-15));\n\n\t\tlet s = this.s;\n\n\t\treturn this.error(`\\n\\`${s.substr(i_off, i_off+90).replace(/[\\n\\t]/g, ' ')}\\`\\n`\n\t\t\t+` ${' '.repeat(i-i_off)}^\\n`\n\t\t\t+`expected ${s_expected} ${b_eof? 'but encountered <<EOF>>': ''}.  failed to parse a valid token starting at ${s[i]? '\"'+s[i]+'\"': '<<EOF>>'}`);\n\t}\n\n\tinfo_error(s_message) {\n\t\tlet i = this.i;\n\n\t\tlet i_off = Math.min(i, Math.abs(i-15));\n\n\t\tlet s = this.s;\n\n\t\tthis.error(`\\n\\`${s.substr(i_off, i_off+90).replace(/[\\n\\t]/g, ' ')}\\`\\n`\n\t\t\t+` ${' '.repeat(i-i_off)}^\\n`\n\t\t\t+s_message);\n\t}\n\n\t// end of file\n\teof() {\n\t\t// there are events queued\n\t\tif(this._a_queue_event.length) {\n\t\t\tlet a_queue = this._a_queue_event;\n\n\t\t\t// drain event queue\n\t\t\twhile(a_queue.length) {\n\t\t\t\t// remove event from front of queue\n\t\t\t\tlet h_event = a_queue.shift();\n\n\t\t\t\t// make event callback\n\t\t\t\tthis[h_event.event](h_event.data);\n\t\t\t}\n\t\t}\n\n\t\t// invalid parsing state\n\t\tif(this.block !== this._f_state) {\n\t\t\t// append EOF char\n\t\t\tthis.s += '\\0';\n\n\t\t\t// exit \"flowing\" mode\n\t\t\tthis.n = this.s.length;\n\n\t\t\t// resume parsing; no errors\n\t\t\tif(this.safe_parse()) {\n\t\t\t\t// eof has occurred under safe parse\n\t\t\t\tif(null === this.s) return;\n\n\t\t\t\t// still invalid parsing state\n\t\t\t\tif(this.block !== this._f_state) {\n\t\t\t\t\treturn this.parse_error(this._f_state.name, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// there are still unparsed characters\n\t\tif(this.i < this.n) {\n\t\t\t// consume whitespace and comments\n\t\t\tlet s = this.s;\n\t\t\tlet i = this.i;\n\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\tR_WS.lastIndex = i;\n\t\t\tR_WS.exec(s);\n\t\t\ti = R_WS.lastIndex;\n\t\t\tR_COMMENT.lastIndex = i;\n\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t// advance beyond comment\n\t\t\tif(R_COMMENT.lastIndex > i) {\n\t\t\t\tthis.i = i = R_COMMENT.lastIndex;\n\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t}\n\n\t\t\t// still unparsed characters\n\t\t\tif(i < this.n) {\n\t\t\t\t// not EOF\n\t\t\t\tif(!(i === this.n - 1 && '\\0' === s[i])) {\n\t\t\t\t\t// bad input; parse error\n\t\t\t\t\treturn this.parse_error(this._f_state.name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// make buffer's alloc eligible for gc\n\t\tthis.s = null;\n\n\t\t// transform stream\n\t\tlet ds_transform = this.transform;\n\n\t\t// final progress update: no additional bytes were read\n\t\tds_transform.emit('progress', 0);\n\n\t\t// call end event listener\n\t\tds_transform.emit('eof', this._h_prefixes);\n\n\t\t// close write stream (EOF-signaling)\n\t\tds_transform.push(null);\n\t}\n\n\n\n\t// bind event listeners to transform stream\n\tbind(g_config) {\n\t\tlet ds_transform = this.transform;\n\t\tif(g_config.base) ds_transform.on('base', g_config.base);\n\t\tif(g_config.prefix) ds_transform.on('prefix', g_config.prefix);\n\t\tif(g_config.enter) ds_transform.on('enter', g_config.enter);\n\t\tif(g_config.exit) ds_transform.on('exit', g_config.exit);\n\t\tif(g_config.comment) ds_transform.on('comment', g_config.comment);\n\t\tif(g_config.error) ds_transform.on('error', g_config.error);\n\t\tif(g_config.read) ds_transform.once('read', g_config.read);\n\t\tif(g_config.progress) ds_transform.on('progress', g_config.progress);\n\t\tif(g_config.eof) ds_transform.once('eof', g_config.eof);\n\t\tif(g_config.end) ds_transform.once('end', g_config.end);\n\t\tif(g_config.finish) ds_transform.once('finish', g_config.finish);\n\t\tif(g_config.data) ds_transform.on('data', g_config.data);\n\t}\n\n\t// after a blank node subject (either property-list or colleciton)\n\tpost_blank_subject() {\n\t\tlet {s, i} = this;\n\t\tif('.' === s[i]) {\n\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\tR_WS.lastIndex = i+1;\n\t\t\tR_WS.exec(s);\n\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t// not inside block\n\t\t\tif(this._kt_default_graph === this._kt_graph) {\n\t\t\t\treturn this.block();\n\t\t\t}\n\t\t\t// inside block\n\t\t\telse {\n\t\t\t\treturn this.statement();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// prepare sticky regex index\n\t\t\tR_CHAR_CLOSE.lastIndex = i;\n\n\t\t\tif(R_CHAR_CLOSE.exec(s)) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_CHAR_CLOSE.lastIndex;\n\t\t\t\t// empty collection\n\t\t\t\tif(this._kt_rdf_nil.equals(this._kt_subject)) {\n\t\t\t\t\treturn this.error('empty collection');\n\t\t\t\t}\n\n\t\t\t\t// emit graph_close event\n\t\t\t\tthis.emit('exit', this._kt_graph);\n\n\t\t\t\t// reset graph\n\t\t\t\tthis._kt_graph = this._kt_default_graph;\n\n\t\t\t\t// goto block state\n\t\t\t\treturn this.block();\n\t\t\t}\n\t\t} // brace #1\n\n\t\treturn this.pairs();\n\t}\n\n\n\n\t// parse state for statement\n\tstatement() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// prefixed name quick\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_pnq_subject = R_PREFIXED_NAME_QUICK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_pnq_subject) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_PREFIXED_NAME_QUICK.lastIndex;\n\t\t\t\t// check valid prefix\n\t\t\t\tlet s_prefix_id = m_pnq_subject[1] || '';\n\t\t\t\t// invalid prefix\n\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t// commit subject iri from resolve prefixed name\n\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, m_pnq_subject[2]);\n\n\t\t\t\t// predicate-object pairs state\n\t\t\t\treturn this.pairs();\n\n\t\t\t// iriref\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_e_subject = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_e_subject) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_e_subject[1];\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set subject\n\t\t\t\t\t\tthis._kt_subject = this.check_named_node_escapeless(s_iri);\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis._kt_subject = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t}\n\n\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\treturn this.pairs();\n\n\n\n\t\t\t\t// prefixed name\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// try match\n\t\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t\t// stack bail out\n\t\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\t\tlet [m_prefixed_named_e_subject, im_prefixed_named_e_subject] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\t\tif(m_prefixed_named_e_subject) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = im_prefixed_named_e_subject;\n\n\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_subject[1] || '';\n\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, m_prefixed_named_e_subject[2]);\n\n\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t// blank node label\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_blank_node_label_subject = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_blank_node_label_subject) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t\t// extract label\n\t\t\t\t\t\t\tlet s_label = m_blank_node_label_subject[1];\n\n\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\tthis._kt_subject = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t// anonymous blank node subject\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_ANONYMOUS_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\t\tif(R_ANONYMOUS_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_ANONYMOUS_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\t// set new blank node as subject\n\t\t\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t\t// anonymous blank node property list subject\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_CHAR_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\t\t\tif(R_CHAR_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\t\t// enter blank node\n\t\t\t\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t\t// how to resume when we pop state\n\t\t\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'post_blank_subject']);\n\n\t\t\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t\t\t// rdf collection\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\tR_CHAR_COLLECTION.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\tif(R_CHAR_COLLECTION.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_COLLECTION.lastIndex;\n\t\t\t\t\t\t\t\t\t\t// indicate that collection subject should emit an initial statement\n\t\t\t\t\t\t\t\t\t\tthis._kt_subject = null;\n\n// (don't push state, we don't have a subject yet)\n\n\t\t\t\t\t\t\t\t\t\t// goto collection-subject state\n\t\t\t\t\t\t\t\t\t\treturn this.collection_subject();\n\n\n\t\t\t\t\t\t\t\t\t// closing graph '}'\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_CHAR_CLOSE.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\tif(R_CHAR_CLOSE.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_CLOSE.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t// emit graph_close event\n\t\t\t\t\t\t\t\t\t\t\tthis.emit('exit', this._kt_graph);\n\n\t\t\t\t\t\t\t\t\t\t\t// reset graph\n\t\t\t\t\t\t\t\t\t\t\tthis._kt_graph = this._kt_default_graph;\n\n\t\t\t\t\t\t\t\t\t\t\t// goto block state\n\t\t\t\t\t\t\t\t\t\t\treturn this.block();\n\n\t\t\t\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\tlet m_iriref_subject = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\tif(m_iriref_subject) {\n\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_subject[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// set subject\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_subject, im_prefixed_named_subject] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\t\t\t\tif(m_prefixed_named_subject) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_subject;\n\t\t\t\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_subject[1] || '';\n\t\t\t\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_subject[2]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.pairs();\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t// comment\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not blank node label, not prefix id, not base\n\t\t\t// match counter: 10\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} // brace #10\n\t\t\t\t\t\t\t\t\t\t\t} // brace #9\n\t\t\t\t\t\t\t\t\t\t} // brace #8\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('statement');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.statement;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for block\n\tblock() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// prepare sticky regex index\n\t\t\tR_GRAPH_IRI_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_graph_iriref_e_graph = R_GRAPH_IRI_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_graph_iriref_e_graph) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_GRAPH_IRI_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_graph_iriref_e_graph[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set graph\n\t\t\t\t\tthis._kt_graph = this.check_named_node_escapeless(s_iri);\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_graph = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t}\n\n\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t// statement state\n\t\t\t\treturn this.statement();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_GRAPH_PREFIXED_NAME.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_graph_prefixed_name = R_GRAPH_PREFIXED_NAME.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_graph_prefixed_name) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_GRAPH_PREFIXED_NAME.lastIndex;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_graph_prefixed_name[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// make subject key\n\t\t\t\t\tthis._kt_graph = this.prefixed_name(s_prefix_id, m_graph_prefixed_name[2]);\n\n\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t// statement state\n\t\t\t\t\treturn this.statement();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_CHAR_OPEN.lastIndex = i;\n\n\t\t\t\t\tif(R_CHAR_OPEN.exec(s)) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_CHAR_OPEN.lastIndex;\n\t\t\t\t\t\t// make new default graph\n\t\t\t\t\t\tthis._kt_graph = this._dc_factory.defaultGraph();\n\n\t\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t\t// goto statement state\n\t\t\t\t\t\treturn this.statement();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_GRAPH_ANONYMOUS_BLANK_NODE.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_graph_anonymous_blank_node = R_GRAPH_ANONYMOUS_BLANK_NODE.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_graph_anonymous_blank_node) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_GRAPH_ANONYMOUS_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t// make new label & set graph to blank node\n\t\t\t\t\t\t\tthis._kt_graph = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t\t\t// statement state\n\t\t\t\t\t\t\treturn this.statement();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_GRAPH_LABELED_BLANK_NODE.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_graph_labeled_blank_node = R_GRAPH_LABELED_BLANK_NODE.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_graph_labeled_blank_node) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_GRAPH_LABELED_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\tlet s_label = m_graph_labeled_blank_node[1];\n\n\t\t\t\t\t\t\t\tthis._kt_graph = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t\t\t\t// statement state\n\t\t\t\t\t\t\t\treturn this.statement();\n\n\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\tlet m_iriref_e_graph_subject = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\tif(m_iriref_e_graph_subject) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_e_graph_subject[1];\n\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t// set subject\n\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node_escapeless(s_iri);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// graph or subject\n\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\n\n\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_e_subject, im_prefixed_named_e_subject] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\t\t\t\t\t\tif(m_prefixed_named_e_subject) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_e_subject;\n\n\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_subject[1] || '';\n\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, m_prefixed_named_e_subject[2]);\n\n\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\t\t\t\t\t\t\t\t\t// blank node label\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\tlet m_blank_node_label_subject = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\tif(m_blank_node_label_subject) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\tthis.i = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t// extract label\n\t\t\t\t\t\t\t\t\t\t\tlet s_label = m_blank_node_label_subject[1];\n\n\t\t\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\t\t\t\t\t\t\t\t\t\t// anonymous blank node subject\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\tR_ANONYMOUS_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\t\tif(R_ANONYMOUS_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_ANONYMOUS_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t// set new blank node as subject\n\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\t\t\t\t\t\t\t\t\t\t\t// anonymous blank node property list subject\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\tR_CHAR_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif(R_CHAR_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t// enter blank node\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// how to resume when we pop state\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'post_blank_subject']);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject_property_list();\n\n\t\t\t\t\t\t\t\t\t\t\t\t// rdf collection\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\tR_CHAR_COLLECTION.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(R_CHAR_COLLECTION.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_COLLECTION.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// indicate that collection subject should emit an initial statement\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = null;\n\n// (don't push state, we don't have a subject yet)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// goto collection-subject state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.collection_subject();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// prefix with interupt (e.g., a comment)\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_PREFIX_KEYWORD.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_prefix_keyword = R_PREFIX_KEYWORD.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_prefix_keyword) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_PREFIX_KEYWORD.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// save whether or not to expect a full stop\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._b_expecting_full_stop = !!m_prefix_keyword[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// goto prefix state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.prefix_id();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// base with interupt (e.g., a comment)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_BASE_KEYWORD.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_base_keyword = R_BASE_KEYWORD.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_base_keyword) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_BASE_KEYWORD.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// save whether or not to expect a full stop\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._b_expecting_full_stop = !!m_base_keyword[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// goto base state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.base_iri();\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_iriref_subject = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_iriref_subject) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_subject[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// set subject\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_subject, im_prefixed_named_subject] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_prefixed_named_subject) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_subject;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_subject[1] || '';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_subject[2]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_GRAPH_IRI.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_graph_iriref_graph = R_GRAPH_IRI.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_graph_iriref_graph) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_GRAPH_IRI.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_iri = m_graph_iriref_graph[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// set graph\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_graph = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_graph = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// statement state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.statement();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// comment\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_GRAPH.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(R_GRAPH.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_GRAPH.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_keyword();\n\n\t\t\t\t// not iriref, not prefixed name, not blank node label, not prefix id, not base\n\t\t\t\t// match counter: 17\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #17\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #16\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #15\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #14\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #13\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #12\n\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #11\n\t\t\t\t\t\t\t\t\t\t\t\t} // brace #10\n\t\t\t\t\t\t\t\t\t\t\t} // brace #9\n\t\t\t\t\t\t\t\t\t\t} // brace #8\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('block');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.block;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_or_subject\n\tgraph_or_subject() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet x = s[i];\n\n\t\t\tif('{' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// shift placeholder subject\n\t\t\t\tthis._kt_graph = this._kt_subject;\n\n\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t// reset subject in case of collections\n\t\t\t\tthis._kt_subject = null;\n\n\t\t\t\t// statement state\n\t\t\t\treturn this.statement();\n\n\t\t\t// non-comment\n\t\t\t}\n\t\t\telse if('#' !== x) {\n\t\t\t\treturn this.pairs();\n\n\t\t\t// comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_or_subject');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_or_subject;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_or_subject_property_list\n\tgraph_or_subject_property_list() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet x = s[i];\n\n\t\t\tif(']' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// next state\n\t\t\t\treturn this.graph_or_subject_anon();\n\n\t\t\t// non-comment\n\t\t\t}\n\t\t\telse if('#' !== x) {\n\t\t\t\treturn this.pairs();\n\n\t\t\t// comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_or_subject_property_list');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_or_subject_property_list;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_or_subject_anon\n\tgraph_or_subject_anon() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet x = s[i];\n\n\t\t\tif('{' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// shift placeholder subject\n\t\t\t\tthis._kt_graph = this._kt_subject;\n\n\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t// reset subject in case of collections\n\t\t\t\tthis._kt_subject = null;\n\n\t\t\t\t// pop dummy state\n\t\t\t\tthis._a_nested.pop();\n\n\t\t\t\t// statement state\n\t\t\t\treturn this.statement();\n\n\t\t\t// non-comment\n\t\t\t}\n\t\t\telse if('#' !== x) {\n\t\t\t\treturn this.pairs();\n\n\t\t\t// comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_or_subject_anon');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_or_subject_anon;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_keyword\n\tgraph_keyword() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// prefixed name\n\t\t\t// try match\n\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t// stack bail out\n\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\tlet [m_prefixed_named_e_graph, im_prefixed_named_e_graph] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\tif(m_prefixed_named_e_graph) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = im_prefixed_named_e_graph;\n\n\t\t\t\t// check valid prefix\n\t\t\t\tlet s_prefix_id = m_prefixed_named_e_graph[1] || '';\n\t\t\t\t// invalid prefix\n\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t// make subject key\n\t\t\t\tthis._kt_graph = this.prefixed_name(s_prefix_id, m_prefixed_named_e_graph[2]);\n\n\t\t\t\t// predicate-object pairs state\n\t\t\t\treturn this.graph_post_name();\n\n\t\t\t// iriref\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_e_graph = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_e_graph) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_e_graph[1];\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set graph\n\t\t\t\t\t\tthis._kt_graph = this.check_named_node_escapeless(s_iri);\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis._kt_graph = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t}\n\n\t\t\t\t\t// graph\n\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t// blank node label\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_blank_node_label_graph = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_blank_node_label_graph) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t// extract label\n\t\t\t\t\t\tlet s_label = m_blank_node_label_graph[1];\n\n\t\t\t\t\t\t// make graph key\n\t\t\t\t\t\tthis._kt_graph = this.blank_node(s_label);\n\n\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t\t// anonymous blank node graph\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_ANONYMOUS_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\tif(R_ANONYMOUS_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_ANONYMOUS_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t// set new blank node as graph\n\t\t\t\t\t\t\tthis._kt_graph = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_iriref_graph = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_iriref_graph) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\tlet s_iri = m_iriref_graph[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t// set graph\n\t\t\t\t\t\t\t\t\tthis._kt_graph = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tthis._kt_graph = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\tlet [m_prefixed_named_graph, im_prefixed_named_graph] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\tif(m_prefixed_named_graph) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_graph;\n\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_graph[1] || '';\n\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_graph[2]\n\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\tthis._kt_graph = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t\t\t\t\t// comment\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t// not iriref, not prefixed name, not blank node label, not prefix id, not base\n\t\t\t\t// match counter: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_keyword');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_keyword;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_post_name\n\tgraph_post_name() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet x = s[i];\n\n\t\t\tif('{' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t// statement state\n\t\t\t\treturn this.statement();\n\n\t\t\t// comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_post_name');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_post_name;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for pairs\n\tpairs() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// benchmarks indicate: regex for end of blank node property list faster than ch\n\n\n// iriref\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_predicate = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_predicate) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_predicate[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set predicate\n\t\t\t\t\tthis._kt_predicate = this.check_named_node_escapeless(s_iri);\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_predicate = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t}\n\n\t\t\t\t// object-list state\n\t\t\t\treturn this.object_list();\n\n\t\t\t// prefixed name\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// try match\n\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t// stack bail out\n\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\tlet [m_prefixed_named_e_predicate, im_prefixed_named_e_predicate] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\tif(m_prefixed_named_e_predicate) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = im_prefixed_named_e_predicate;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_predicate[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// make predicate key\n\t\t\t\t\tthis._kt_predicate = this.prefixed_name(s_prefix_id, m_prefixed_named_e_predicate[2]);\n\n\t\t\t\t\t// object-list state\n\t\t\t\t\treturn this.object_list();\n\n\t\t\t\t// 'a'\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_A.lastIndex = i;\n\n\t\t\t\t\tif(R_A.exec(s)) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_A.lastIndex;\n\t\t\t\t\t\t// make predicate key\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_type;\n\n\t\t\t\t\t\t// object-list state\n\t\t\t\t\t\treturn this.object_list();\n\n\t\t\t\t\t// ']' end of blank node property list\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_CHAR_KET.lastIndex = i;\n\n\t\t\t\t\t\tif(R_CHAR_KET.exec(s)) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_CHAR_KET.lastIndex;\n\t\t\t\t\t\t\tlet s_resume_state;\n\t\t\t\t\t\t\t[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();\n\t\t\t\t\t\t\treturn this[s_resume_state]();\n\n\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_iriref_predicate = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_iriref_predicate) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\tlet s_iri = m_iriref_predicate[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t// set predicate\n\t\t\t\t\t\t\t\t\tthis._kt_predicate = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tthis._kt_predicate = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// object-list state\n\t\t\t\t\t\t\t\treturn this.object_list();\n\n\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\tlet [m_prefixed_named_predicate, im_prefixed_named_predicate] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\tif(m_prefixed_named_predicate) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_predicate;\n\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_predicate[1] || '';\n\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_predicate[2]\n\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t// make predicate key\n\t\t\t\t\t\t\t\t\tthis._kt_predicate = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t\t\t\t\t\t\t// object-list state\n\t\t\t\t\t\t\t\t\treturn this.object_list();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not 'a'\n\t\t\t// match counter: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('pairs');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.pairs;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for object_list\n\tobject_list() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref char\n\t\t\tlet x = s[i];\n\n\t\t\t// string literal * double\n\t\t\tif('\"' === x) {\n\t\t\t\t// enough chars to deduce type\n\t\t\t\tif((i+2) < n) {\n\t\t\t\t\t// long type\n\t\t\t\t\tif('\"' === s[i+1] && '\"' === s[i+2]) {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 3;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_long_double();\n\t\t\t\t\t}\n\t\t\t\t\t// not long type\n\t\t\t\t\telse {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_short_double();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// enough chars to eliminate long type\n\t\t\t\telse if((i+1) < n && '\"' !== s[i+1]) {\n\t\t\t\t\t// advance index beyond token\n\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t// read contents\n\t\t\t\t\treturn this.string_literal_short_double();\n\t\t\t\t}\n\t\t\t\t// not enough chars to deduce type; retry next chunk\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t// prefixed name quick\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_pnq_object = R_PREFIXED_NAME_QUICK.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_pnq_object) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_PREFIXED_NAME_QUICK.lastIndex;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_pnq_object[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, m_pnq_object[2]);\n\n\t\t\t\t// iriref\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_iriref_e_object = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_iriref_e_object) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\tlet s_iri = m_iriref_e_object[1];\n\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t// set object\n\t\t\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(s_iri);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// prefixed name\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// try match\n\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\t\t\tlet [m_prefixed_named_e_object, im_prefixed_named_e_object] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\t\t\tif(m_prefixed_named_e_object) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = im_prefixed_named_e_object;\n\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_object[1] || '';\n\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, m_prefixed_named_e_object[2]);\n\n\t\t\t\t\t\t// string literal * single\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('\\'' === x) {\n\t\t\t\t\t\t\t// enough chars to deduce type\n\t\t\t\t\t\t\tif((i+2) < n) {\n\t\t\t\t\t\t\t\t// long type\n\t\t\t\t\t\t\t\tif(\"'\" === s[i+1] && \"'\" === s[i+2]) {\n\t\t\t\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\t\t\t\tthis.i = i + 3;\n\n\t\t\t\t\t\t\t\t\t// read contents\n\t\t\t\t\t\t\t\t\treturn this.string_literal_long_single();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// not long type\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t\t\t\t// read contents\n\t\t\t\t\t\t\t\t\treturn this.string_literal_short_single();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// enough chars to eliminate long type\n\t\t\t\t\t\t\telse if((i+1) < n && \"'\" !== s[i+1]) {\n\t\t\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t\t\t// read contents\n\t\t\t\t\t\t\t\treturn this.string_literal_short_single();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// not enough chars to deduce type; retry next chunk\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// numeric literal\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_NUMERIC_LITERAL.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_numeric_literal = R_NUMERIC_LITERAL.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_numeric_literal) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_NUMERIC_LITERAL.lastIndex;\n\t\t\t\t\t\t\t\t// it has exponent term, xsd:double\n\t\t\t\t\t\t\t\tif(m_numeric_literal[4]) {\n\t\t\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.double(m_numeric_literal[1]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// contains decimal point, xsd:decimal\n\t\t\t\t\t\t\t\telse if(m_numeric_literal[2] || m_numeric_literal[3]) {\n\t\t\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.decimal(m_numeric_literal[1]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// otherwise, it is an integer\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.integer(m_numeric_literal[1]);\n\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t// boolean literal\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_BOOLEAN_LITERAL.lastIndex = i;\n\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\tlet m_boolean_literal = R_BOOLEAN_LITERAL.exec(s);\n\n\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\tif(m_boolean_literal) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = R_BOOLEAN_LITERAL.lastIndex;\n\t\t\t\t\t\t\t\t\t// make literal\n\t\t\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.boolean(!!m_boolean_literal[1]);\n\n\n\t\t\t\t\t\t\t\t// blank node property list\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse \tif('[' === x) {\n\t\t\t\t// advance index to next token\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t\t\t// make object\n\t\t\t\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t\t// emit statement event\n\t\t\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t\t\t// push state to stack\n\t\t\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'post_object']);\n\n\t\t\t\t\t\t\t\t\t// set new subject\n\t\t\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\n\t\t\t\t\t\t\t\t\t// goto parsing pairs state\n\t\t\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t\t\t// labeled blank node\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\tR_BLANK_NODE_LABEL_TERMINAL.lastIndex = i;\n\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\tlet m_blank_node_label_object = R_BLANK_NODE_LABEL_TERMINAL.exec(s);\n\n\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\tif(m_blank_node_label_object) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\tthis.i = R_BLANK_NODE_LABEL_TERMINAL.lastIndex;\n\t\t\t\t\t\t\t\t\t\t// ref blank node label\n\t\t\t\t\t\t\t\t\t\tlet s_label = m_blank_node_label_object[1];\n\n\t\t\t\t\t\t\t\t\t\t// make object\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t\t\t// collection\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse \tif('(' === x) {\n\t\t\t\t// advance index to next token\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t// state to resume after collection ends\n\t\t\t\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'post_object']);\n\n\t\t\t\t\t\t\t\t\t\t// goto collection-object state\n\t\t\t\t\t\t\t\t\t\treturn this.collection_object();\n\n\t\t\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\tlet m_iriref_object = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\tif(m_iriref_object) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_object[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t\t\t// set object\n\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_object, im_prefixed_named_object] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\t\t\tif(m_prefixed_named_object) {\n\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_object;\n\t\t\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_object[1] || '';\n\t\t\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_object[2]\n\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, s_suffix);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection\n\t\t\t// match counter: 9\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t} // brace #9\n\t\t\t\t\t\t\t\t\t\t} // brace #8\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\n\n\t\t\t// fall through for cases that did not change state on their own\n\t\t\t// at this point, a new statement has been parsed\n\t\t\tthis.data();\n\n\n\t\t\t// goto next parsing state; bail out of stack\n\t\t\treturn this.after_end_of_statement;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('object_list');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.object_list;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal_short_double\n\tstring_literal_short_double() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\tstring_literal_short_double: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// something breaks string in this chunk\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_STRLIT_SHORT_DOUBLE_BREAK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_break = R_STRLIT_SHORT_DOUBLE_BREAK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_break) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_STRLIT_SHORT_DOUBLE_BREAK.lastIndex;\n\t\t\t\t// index of break\n\t\t\t\tlet i_break = m_break.index;\n\n\t\t\t\t// add to contents\n\t\t\t\tthis._s_literal += s.slice(i, i_break);\n\n\t\t\t\t// depending on char\n\t\t\t\tswitch(s[i_break]) {\n\t\t\t\t\t// terminator\n\t\t\t\t\tcase '\"': {\n\t\t\t\t\t// advance index to next token beyond delimiter\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\tR_WS.lastIndex = i_break + 1;\n\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t}\n\n\t\t\t\t\t// escape\n\t\t\t\t\tcase '\\\\': {\n\t\t\t\t\t\t// try to find end\n\t\t\t\t\t\tR_STRLIT_SHORT_DOUBLE_TERM.lastIndex = i_break;\n\t\t\t\t\t\tlet m_term = R_STRLIT_SHORT_DOUBLE_TERM.exec(s);\n\n\t\t\t\t\t\t// end is in this chunk\n\t\t\t\t\t\tif(m_term) {\n\t\t\t\t\t\t\t// index of terminator\n\t\t\t\t\t\t\tlet i_term = m_term.index;\n\n\t\t\t\t\t\t\t// extract dirty potion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break, i_term);\n\n\t\t\t\t\t\t\t// clean and save\n\t\t\t\t\t\t\tthis._s_literal += unescape_literal_short_hard(s_dirty);\n\n\t\t\t\t\t\t\t// advance index beyond terminator\n\t\t\t\t\t\t\tthis.i = i_term + m_term[0].length;\n\n\t\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// end is not in this chunk\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// extract whole portion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break);\n\n\t\t\t\t\t\t\t// unescape to clean part\n\t\t\t\t\t\t\tlet [s_clean, s_incomplete] = unescape_literal_short_soft(s_dirty);\n\n\t\t\t\t\t\t\t// save\n\t\t\t\t\t\t\tthis._s_literal += s_clean;\n\n\t\t\t\t\t\t\t// set unparsed index\n\t\t\t\t\t\t\ti = n - s_incomplete.length;\n\n\t\t\t\t\t\t\t// reached eos; pause normally\n\t\t\t\t\t\t\tbreak string_literal_short_double;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid '\\n'\n\t\t\t\t\tcase '\\n': {\n\t\t\t\t\t\treturn this.info_error(`expected string_literal_short_double but invalid line feed character '\\\\n' (newline) within contents. failed to parse a valid token`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid '\\r'\n\t\t\t\t\tcase '\\r': {\n\t\t\t\t\t\treturn this.info_error(`expected string_literal_short_double but invalid form feed character '\\\\r' (carriage return) within contents. failed to parse a valid token`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconsole.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_short_double`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t// no terminator and nothing to escape\n\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// save\n\t\t\t\tthis._s_literal += i? s.slice(i): s;\n\n\t\t\t\t// set unparsed index\n\t\t\t\ti = n;\n\n\t\t\t\t// reached eos; pause normally\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// do not eat whitespace at start of next chunk\n\t\tthis._b_trim_start = false;\n\n\t// ran out of characters\n\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('string_literal_short_double');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal_short_double;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal_short_single\n\tstring_literal_short_single() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\tstring_literal_short_single: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// something breaks string in this chunk\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_STRLIT_SHORT_SINGLE_BREAK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_break = R_STRLIT_SHORT_SINGLE_BREAK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_break) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_STRLIT_SHORT_SINGLE_BREAK.lastIndex;\n\t\t\t\t// index of break\n\t\t\t\tlet i_break = m_break.index;\n\n\t\t\t\t// add to contents\n\t\t\t\tthis._s_literal += s.slice(i, i_break);\n\n\t\t\t\t// depending on char\n\t\t\t\tswitch(s[i_break]) {\n\t\t\t\t\t// terminator\n\t\t\t\t\tcase \"'\": {\n\t\t\t\t\t// advance index to next token beyond delimiter\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\tR_WS.lastIndex = i_break + 1;\n\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t}\n\n\t\t\t\t\t// escape\n\t\t\t\t\tcase '\\\\': {\n\t\t\t\t\t\t// try to find end\n\t\t\t\t\t\tR_STRLIT_SHORT_SINGLE_TERM.lastIndex = i_break;\n\t\t\t\t\t\tlet m_term = R_STRLIT_SHORT_SINGLE_TERM.exec(s);\n\n\t\t\t\t\t\t// end is in this chunk\n\t\t\t\t\t\tif(m_term) {\n\t\t\t\t\t\t\t// index of terminator\n\t\t\t\t\t\t\tlet i_term = m_term.index;\n\n\t\t\t\t\t\t\t// extract dirty potion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break, i_term);\n\n\t\t\t\t\t\t\t// clean and save\n\t\t\t\t\t\t\tthis._s_literal += unescape_literal_short_hard(s_dirty);\n\n\t\t\t\t\t\t\t// advance index beyond terminator\n\t\t\t\t\t\t\tthis.i = i_term + m_term[0].length;\n\n\t\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// end is not in this chunk\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// extract whole portion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break);\n\n\t\t\t\t\t\t\t// unescape to clean part\n\t\t\t\t\t\t\tlet [s_clean, s_incomplete] = unescape_literal_short_soft(s_dirty);\n\n\t\t\t\t\t\t\t// save\n\t\t\t\t\t\t\tthis._s_literal += s_clean;\n\n\t\t\t\t\t\t\t// set unparsed index\n\t\t\t\t\t\t\ti = n - s_incomplete.length;\n\n\t\t\t\t\t\t\t// reached eos; pause normally\n\t\t\t\t\t\t\tbreak string_literal_short_single;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid '\\n'\n\t\t\t\t\tcase '\\n': {\n\t\t\t\t\t\treturn this.info_error(`expected string_literal_short_single but invalid line feed character '\\\\n' (newline) within contents. failed to parse a valid token`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid '\\r'\n\t\t\t\t\tcase '\\r': {\n\t\t\t\t\t\treturn this.info_error(`expected string_literal_short_single but invalid form feed character '\\\\r' (carriage return) within contents. failed to parse a valid token`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconsole.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_short_single`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t// no terminator and nothing to escape\n\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// save\n\t\t\t\tthis._s_literal += i? s.slice(i): s;\n\n\t\t\t\t// set unparsed index\n\t\t\t\ti = n;\n\n\t\t\t\t// reached eos; pause normally\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// do not eat whitespace at start of next chunk\n\t\tthis._b_trim_start = false;\n\n\t// ran out of characters\n\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('string_literal_short_single');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal_short_single;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal_long_double\n\tstring_literal_long_double() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\tstring_literal_long_double: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// something breaks string in this chunk\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_STRLIT_LONG_DOUBLE_BREAK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_break = R_STRLIT_LONG_DOUBLE_BREAK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_break) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_STRLIT_LONG_DOUBLE_BREAK.lastIndex;\n\t\t\t\t// index of break\n\t\t\t\tlet i_break = m_break.index;\n\n\t\t\t\t// add to contents\n\t\t\t\tthis._s_literal += s.slice(i, i_break);\n\n\t\t\t\t// depending on char\n\t\t\t\tswitch(s[i_break]) {\n\t\t\t\t\t// terminator\n\t\t\t\t\tcase '\"': {\n\t\t\t\t\t// advance index to next token beyond delimiter\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\tR_WS.lastIndex = i_break + 3;\n\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t}\n\n\t\t\t\t\t// escape\n\t\t\t\t\tcase '\\\\': {\n\t\t\t\t\t\t// try to find end\n\t\t\t\t\t\tR_STRLIT_LONG_DOUBLE_TERM.lastIndex = i_break;\n\t\t\t\t\t\tlet m_term = R_STRLIT_LONG_DOUBLE_TERM.exec(s);\n\n\t\t\t\t\t\t// end is in this chunk\n\t\t\t\t\t\tif(m_term) {\n\t\t\t\t\t\t\t// index of terminator\n\t\t\t\t\t\t\tlet i_term = m_term.index;\n\n\t\t\t\t\t\t\t// extract dirty potion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break, i_term);\n\n\t\t\t\t\t\t\t// clean and save\n\t\t\t\t\t\t\tthis._s_literal += unescape_literal_long_hard(s_dirty);\n\n\t\t\t\t\t\t\t// advance index beyond terminator\n\t\t\t\t\t\t\tthis.i = i_term + m_term[0].length;\n\n\t\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// end is not in this chunk\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// extract whole portion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break);\n\n\t\t\t\t\t\t\t// unescape to clean part\n\t\t\t\t\t\t\tlet [s_clean, s_incomplete] = unescape_literal_long_soft(s_dirty);\n\n\t\t\t\t\t\t\t// save\n\t\t\t\t\t\t\tthis._s_literal += s_clean;\n\n\t\t\t\t\t\t\t// set unparsed index\n\t\t\t\t\t\t\ti = n - s_incomplete.length;\n\n\t\t\t\t\t\t\t// reached eos; pause normally\n\t\t\t\t\t\t\tbreak string_literal_long_double;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconsole.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_long_double`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t// no terminator and nothing to escape\n\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// could be unfinished terminator\n\t\t\t\tR_STRLIT_LONG_DOUBLE_UNFINISHED_TERM.lastIndex = i;\n\t\t\t\tlet m_unfinished = R_STRLIT_LONG_DOUBLE_UNFINISHED_TERM.exec(s);\n\n\t\t\t\t// unfinished terminator\n\t\t\t\tif(m_unfinished) {\n\t\t\t\t\t// save valid portion\n\t\t\t\t\tthis._s_literal += s.slice(i, m_unfinished.index);\n\n\t\t\t\t\t// set unparsed index\n\t\t\t\t\ti = m_unfinished.index;\n\t\t\t\t}\n\t\t\t\t// not unfinished\n\t\t\t\telse {\n\t\t\t\t\t// save\n\t\t\t\t\tthis._s_literal += i? s.slice(i): s;\n\n\t\t\t\t\t// set unparsed index\n\t\t\t\t\ti = n;\n\t\t\t\t}\n\n\t\t\t\t// reached eos; pause normally\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// do not eat whitespace at start of next chunk\n\t\tthis._b_trim_start = false;\n\n\t// ran out of characters\n\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('string_literal_long_double');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal_long_double;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal_long_single\n\tstring_literal_long_single() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\tstring_literal_long_single: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// something breaks string in this chunk\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_STRLIT_LONG_SINGLE_BREAK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_break = R_STRLIT_LONG_SINGLE_BREAK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_break) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_STRLIT_LONG_SINGLE_BREAK.lastIndex;\n\t\t\t\t// index of break\n\t\t\t\tlet i_break = m_break.index;\n\n\t\t\t\t// add to contents\n\t\t\t\tthis._s_literal += s.slice(i, i_break);\n\n\t\t\t\t// depending on char\n\t\t\t\tswitch(s[i_break]) {\n\t\t\t\t\t// terminator\n\t\t\t\t\tcase \"'\": {\n\t\t\t\t\t// advance index to next token beyond delimiter\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\tR_WS.lastIndex = i_break + 3;\n\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t}\n\n\t\t\t\t\t// escape\n\t\t\t\t\tcase '\\\\': {\n\t\t\t\t\t\t// try to find end\n\t\t\t\t\t\tR_STRLIT_LONG_SINGLE_TERM.lastIndex = i_break;\n\t\t\t\t\t\tlet m_term = R_STRLIT_LONG_SINGLE_TERM.exec(s);\n\n\t\t\t\t\t\t// end is in this chunk\n\t\t\t\t\t\tif(m_term) {\n\t\t\t\t\t\t\t// index of terminator\n\t\t\t\t\t\t\tlet i_term = m_term.index;\n\n\t\t\t\t\t\t\t// extract dirty potion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break, i_term);\n\n\t\t\t\t\t\t\t// clean and save\n\t\t\t\t\t\t\tthis._s_literal += unescape_literal_long_hard(s_dirty);\n\n\t\t\t\t\t\t\t// advance index beyond terminator\n\t\t\t\t\t\t\tthis.i = i_term + m_term[0].length;\n\n\t\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// end is not in this chunk\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// extract whole portion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break);\n\n\t\t\t\t\t\t\t// unescape to clean part\n\t\t\t\t\t\t\tlet [s_clean, s_incomplete] = unescape_literal_long_soft(s_dirty);\n\n\t\t\t\t\t\t\t// save\n\t\t\t\t\t\t\tthis._s_literal += s_clean;\n\n\t\t\t\t\t\t\t// set unparsed index\n\t\t\t\t\t\t\ti = n - s_incomplete.length;\n\n\t\t\t\t\t\t\t// reached eos; pause normally\n\t\t\t\t\t\t\tbreak string_literal_long_single;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconsole.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_long_single`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t// no terminator and nothing to escape\n\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// could be unfinished terminator\n\t\t\t\tR_STRLIT_LONG_SINGLE_UNFINISHED_TERM.lastIndex = i;\n\t\t\t\tlet m_unfinished = R_STRLIT_LONG_SINGLE_UNFINISHED_TERM.exec(s);\n\n\t\t\t\t// unfinished terminator\n\t\t\t\tif(m_unfinished) {\n\t\t\t\t\t// save valid portion\n\t\t\t\t\tthis._s_literal += s.slice(i, m_unfinished.index);\n\n\t\t\t\t\t// set unparsed index\n\t\t\t\t\ti = m_unfinished.index;\n\t\t\t\t}\n\t\t\t\t// not unfinished\n\t\t\t\telse {\n\t\t\t\t\t// save\n\t\t\t\t\tthis._s_literal += i? s.slice(i): s;\n\n\t\t\t\t\t// set unparsed index\n\t\t\t\t\ti = n;\n\t\t\t\t}\n\n\t\t\t\t// reached eos; pause normally\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// do not eat whitespace at start of next chunk\n\t\tthis._b_trim_start = false;\n\n\t// ran out of characters\n\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('string_literal_long_single');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal_long_single;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal\n\tstring_literal() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref character\n\t\t\tlet x = s[i];\n\n\t\t\t// string literal * double\n\t\t\tif('\"' === x) {\n\t\t\t\t// enough chars to deduce type\n\t\t\t\tif((i+2) < n) {\n\t\t\t\t\t// long type\n\t\t\t\t\tif('\"' === s[i+1] && '\"' === s[i+2]) {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 3;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_long_double();\n\t\t\t\t\t}\n\t\t\t\t\t// not long type\n\t\t\t\t\telse {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_short_double();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// enough chars to eliminate long type\n\t\t\t\telse if((i+1) < n && '\"' !== s[i+1]) {\n\t\t\t\t\t// advance index beyond token\n\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t// read contents\n\t\t\t\t\treturn this.string_literal_short_double();\n\t\t\t\t}\n\t\t\t\t// not enough chars to deduce type; retry next chunk\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t// string literal * single\n\t\t\t}\n\t\t\telse \tif('\\'' === x) {\n\t\t\t\t// enough chars to deduce type\n\t\t\t\tif((i+2) < n) {\n\t\t\t\t\t// long type\n\t\t\t\t\tif(\"'\" === s[i+1] && \"'\" === s[i+2]) {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 3;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_long_single();\n\t\t\t\t\t}\n\t\t\t\t\t// not long type\n\t\t\t\t\telse {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_short_single();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// enough chars to eliminate long type\n\t\t\t\telse if((i+1) < n && \"'\" !== s[i+1]) {\n\t\t\t\t\t// advance index beyond token\n\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t// read contents\n\t\t\t\t\treturn this.string_literal_short_single();\n\t\t\t\t}\n\t\t\t\t// not enough chars to deduce type; retry next chunk\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t// not string literal long single quote, not string literal single quote\n\t\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_string_length) {\n\t\t\t\t\treturn this.parse_error('string_literal');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for datatype_or_langtag\n\tdatatype_or_langtag() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref character\n\t\t\tlet x = s[i];\n\n\t\t\t// next token indicates datatype or langtag\n\t\t\tif('^' === x || '@' === x) {\n// '^^' datatype\n\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_DOUBLE_CARET.lastIndex = i;\n\n\t\t\t\tif(R_DOUBLE_CARET.exec(s)) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_DOUBLE_CARET.lastIndex;\n\t\t\t\t\treturn this.datatype();\n\n\t\t\t\t// '@' language tag\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_LANGTAG.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_langtag = R_LANGTAG.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_langtag) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_LANGTAG.lastIndex;\n\t\t\t\t\t\tthis._kt_object = this._dc_factory.languagedLiteral(this._s_literal, m_langtag[1]);\n\n\t\t\t\t\t\t// reset literal\n\t\t\t\t\t\tthis._s_literal = '';\n\n\t\t\t\t// next token definitely datatype or langtag, we are just being interrupted by eos\n\t\t\t\t// match counter: 1\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} // brace #1\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_object = this._dc_factory.simpleLiteral(this._s_literal);\n\n\t\t\t\t\t// reset literal\n\t\t\t\t\tthis._s_literal = '';\n\n\t\t\t\t// not datatype, not language tag => that's okay! those are optional\n\t\t\t\t}\n\t\t\t} // brace #1\n\n\n\t\t\t// goto end of statement state\n\t\t\t// at this point, a new statement has been parsed\n\t\t\tthis.data();\n\n\n\t\t\t// goto next parsing state; bail out of stack\n\t\t\treturn this.after_end_of_statement;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('datatype_or_langtag');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.datatype_or_langtag;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for datatype\n\tdatatype() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet kt_datatype = null;\n\n// prefixed name quick\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_pnq_datatype = R_PREFIXED_NAME_QUICK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_pnq_datatype) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_PREFIXED_NAME_QUICK.lastIndex;\n\t\t\t\t// check valid prefix\n\t\t\t\tlet s_prefix_id = m_pnq_datatype[1] || '';\n\t\t\t\t// invalid prefix\n\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\tkt_datatype = this.prefixed_name(s_prefix_id, m_pnq_datatype[2]);\n\n\t\t\t// iriref\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_e_datatype = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_e_datatype) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\t\t\t\t\tlet p_datatype;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_e_datatype[1];\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set p_datatype\n\t\t\t\t\t\tp_datatype = s_iri;\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tp_datatype = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t\t}\n\n\t\t\t\t\tkt_datatype = this.check_named_node_escapeless(p_datatype);\n\n\t\t\t\t// prefixed name\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// try match\n\t\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t\t// stack bail out\n\t\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\t\tlet [m_prefixed_named_e_datatype, im_prefixed_named_e_datatype] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\t\tif(m_prefixed_named_e_datatype) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = im_prefixed_named_e_datatype;\n\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_datatype[1] || '';\n\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\tkt_datatype = this.prefixed_name(s_prefix_id, m_prefixed_named_e_datatype[2]);\n\n\t\t\t\t\t// iriref\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_iriref_datatype = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_iriref_datatype) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\t\t\t\t\t\t\tlet p_datatype;\n\n\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\tlet s_iri = m_iriref_e_datatype[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t// set p_datatype\n\t\t\t\t\t\t\t\tp_datatype = s_iri;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tp_datatype = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tkt_datatype = this.check_named_node(p_datatype);\n\n\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\tlet [m_prefixed_named_datatype, im_prefixed_named_datatype] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\tif(m_prefixed_named_datatype) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_datatype;\n\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_datatype[1] || '';\n\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_datatype[2]\n\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t// set literal datatype\n\t\t\t\t\t\t\t\tkt_datatype = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t// not iriref, not prefixed name\n\t\t\t// match counter: 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\n\n\t\t\tthis._kt_object = this._dc_factory.datatypedLiteral(this._s_literal, kt_datatype);\n\n\t\t\t// reset literal\n\t\t\tthis._s_literal = '';\n\n\t\t\t// goto end of statement state\n\t\t\t// at this point, a new statement has been parsed\n\t\t\tthis.data();\n\n\n\t\t\t// goto next parsing state; bail out of stack\n\t\t\treturn this.after_end_of_statement;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('datatype');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.datatype;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for post_object\n\tpost_object() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet i_reset = i;\n\n\t\t\t// benchmarks confirm: character ref faster than regexes in this context\n\t\t\tlet x = s[i];\n\n\t\t\t// advance index to next token beyond delimiter\n\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\tR_WS.lastIndex = i+1;\n\t\t\tR_WS.exec(s);\n\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t// ',' more objects\n\t\t\tif(',' === x) {\n\t\t\t\treturn this.object_list();\n\n\t\t\t// ';' more predicate-object pairs\n\t\t\t}\n\t\t\telse \tif(';' === x) {\n\t\t\t\tfor(;;) {\n\t\t\t\t\t// next token is end of outer section\n\t\t\t\t\tlet s_peek = s[this.i];\n\t\t\t\t\tif('.' === s_peek || ']' === s_peek || ';' === s_peek || '}' === s_peek) {\n\t\t\t\t\t\t// goto post_object state\n\t\t\t\t\t\treturn this.post_object();\n\t\t\t\t\t}\n\t\t\t\t\t// comment\n\t\t\t\t\telse if('#' === s_peek) {\n\t\t\t\t\t\t// comment\n\t\t\t\t\t\ti = this.i;\n\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t// retry\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t// no eol to close comment (yet)\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// already consumed\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// eos\n\t\t\t\t\telse if(this.i === n) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// something else\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn this.pairs();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// rather than pushing a dedicated state, just try again next chunk\n\t\t\t\ti = i_reset;\n\t\t\t\tbreak;\n\n\t\t\t// '.' end of statement\n\t\t\t}\n\t\t\telse \tif('.' === x) {\n\t\t\t\t// assert not nested\n\t\t\t\tif(this._a_nested.length) {\n\t\t\t\t\t// reset index to that character\n\t\t\t\t\tthis.i = i;\n\n\t\t\t\t\t// emit parse error\n\t\t\t\t\treturn this.parse_error('end_of_property_list');\n\t\t\t\t}\n\n\t\t\t\treturn (this._kt_default_graph === this._kt_graph)? this.block(): this.statement();\n\n\t\t\t// ']' end of property-object pairs\n\t\t\t}\n\t\t\telse \tif(']' === x) {\n\t\t\t\tlet s_resume_state;\n\t\t\t\t[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();\n\t\t\t\treturn this[s_resume_state]();\n\n\t\t\t// ')' end of collection\n\t\t\t}\n\t\t\telse \tif(')' === x) {\n\t\t\t\t// should not be here\n\t\t\t\treturn Reader$syntax_error(this, i, 'post_object', 'but encountered end of collection');\n\n\t\t\t// closing graph '}'\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_CHAR_CLOSE.lastIndex = i;\n\n\t\t\t\tif(R_CHAR_CLOSE.exec(s)) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_CHAR_CLOSE.lastIndex;\n\t\t\t\t\t// emit graph_close event\n\t\t\t\t\tthis.emit('exit', this._kt_graph);\n\n\t\t\t\t\t// reset graph\n\t\t\t\t\tthis._kt_graph = this._kt_default_graph;\n\n\t\t\t\t\treturn this.block();\n\n\t\t\t\t// comment\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t// do not change state\n\t\t\t\t\t\tcontinue;\n\n\t\t\t// comment interrupted by eos?\n\t\t\t// match counter: 2\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('post_object');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.post_object;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for base_iri\n\tbase_iri() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// prefix id\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_base = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_base) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_base[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set base_url\n\t\t\t\t\tthis._s_base_url = s_iri;\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._s_base_url = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t}\t\tlet m_base_iri = R_BASE_IRI.exec(this._s_base_url);\n\t\t\t\tthis._s_base_url = m_base_iri[1];\n\t\t\t\tthis._s_base_url_root = m_base_iri[2] || '';\n\t\t\t\tthis._s_base_url_scheme = m_base_iri[3] || '';\n\t\t\t\tthis._s_base_url_path = m_base_iri[4] || '';\n\n\n\t\t\t\t// emit base event\n\t\t\t\tthis.emit('base', this._s_base_url);\n\n\t\t\t\tif(this._b_expecting_full_stop) {\n\t\t\t\t\t// change state\n\t\t\t\t\treturn this.full_stop();\n\t\t\t\t}\n\n\t\t\t\t// goto prefix iri state\n\t\t\t\treturn this.block();\n\n\t\t\t// prefix id\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_base = R_IRIREF.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_base) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_base[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set base_url\n\t\t\t\t\t\tthis._s_base_url = s_iri;\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis._s_base_url = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t\t}\t\tlet m_base_iri = R_BASE_IRI.exec(this._s_base_url);\n\t\t\t\t\tthis._s_base_url = m_base_iri[1];\n\t\t\t\t\tthis._s_base_url_root = m_base_iri[2] || '';\n\t\t\t\t\tthis._s_base_url_scheme = m_base_iri[3] || '';\n\t\t\t\t\tthis._s_base_url_path = m_base_iri[4] || '';\n\n\n\t\t\t\t\t// emit base event\n\t\t\t\t\tthis.emit('base', this._s_base_url);\n\n\t\t\t\t\tif(this._b_expecting_full_stop) {\n\t\t\t\t\t\t// change state\n\t\t\t\t\t\treturn this.full_stop();\n\t\t\t\t\t}\n\n\t\t\t\t\t// goto prefix iri state\n\t\t\t\t\treturn this.block();\n\n\t\t\t\t// for poorly-placed comments\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t// do not change state\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t// match counter: 2\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('base_iri');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.base_iri;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for prefix_id\n\tprefix_id() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// prefix id\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_PREFIX_ID.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_prefix_id = R_PREFIX_ID.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_prefix_id) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_PREFIX_ID.lastIndex;\n\t\t\t\t// set temp prefix id\n\t\t\t\tthis._s_temp_prefix_id = m_prefix_id[1];\n\n\t\t\t\t// goto prefix iri state\n\t\t\t\treturn this.prefix_iri();\n\n\t\t\t// for poorly-placed comments\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t// do not change state\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('prefix_id');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.prefix_id;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for prefix_iri\n\tprefix_iri() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet h_prefixes = this._h_prefixes;\n\t\t\tlet s_prefix_id = this._s_temp_prefix_id;\n\t\t\tlet p_prefix_iri;\n\n// prefix iri\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_prefix = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_prefix) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_prefix[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set p_prefix_iri\n\t\t\t\t\tp_prefix_iri = s_iri;\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tp_prefix_iri = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t}\n\n\t\t\t\tlet b_relax = this._b_relax;\n\n// existing mapping\n\n\t\t\t\tif(s_prefix_id in h_prefixes) {\n\t\t\t\t\t// doesn't match existing\n\t\t\t\t\tif(p_prefix_iri !== h_prefixes[s_prefix_id]) {\n\t\t\t\t\t\t// emit change event\n\t\t\t\t\t\tif(this.prefix_change) {\n\t\t\t\t\t\t\tthis.prefix_change(s_prefix_id, h_prefixes[s_prefix_id], p_prefix_iri);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// update prefix\n\t\t\t\t\t\th_prefixes[s_prefix_id] = p_prefix_iri;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// first mapping\n\t\t\t\telse {\n\t\t\t\t\t// check namespace, invalid\n\t\t\t\t\tif(!b_relax && !RT_PREFIXED_NAME_NAMESPACE_VALID.test(s_prefix_id)) {\n\t\t\t\t\t\treturn this.error(`Invalid namespace for prefixed name: \"${s_prefix_id}:\"`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// set prefix\n\t\t\t\t\th_prefixes[s_prefix_id] = p_prefix_iri;\n\t\t\t\t}\n\n\t\t\t\t// check iri, invalid\n\t\t\t\tif(!b_relax && !RT_NAMED_NODE_VALID.test(p_prefix_iri)) {\n\t\t\t\t\treturn this.error(`Invalid IRI found in prefix delcaration: \"${s_iri}\"`);\n\t\t\t\t}\n\n\t\t\t\t// emit prefix event\n\t\t\t\tthis.event('prefix', s_prefix_id, p_prefix_iri);\n\n\t\t\t\tif(this._b_expecting_full_stop) {\n\t\t\t\t\t// change state\n\t\t\t\t\treturn this.full_stop();\n\t\t\t\t}\n\n\t\t\t\t// goto statement state\n\t\t\t\treturn this.block();\n\n\t\t\t// prefix iri\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_prefix = R_IRIREF.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_prefix) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_prefix[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set p_prefix_iri\n\t\t\t\t\t\tp_prefix_iri = s_iri;\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tp_prefix_iri = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet b_relax = this._b_relax;\n\n// existing mapping\n\n\t\t\t\t\tif(s_prefix_id in h_prefixes) {\n\t\t\t\t\t\t// doesn't match existing\n\t\t\t\t\t\tif(p_prefix_iri !== h_prefixes[s_prefix_id]) {\n\t\t\t\t\t\t\t// emit change event\n\t\t\t\t\t\t\tif(this.prefix_change) {\n\t\t\t\t\t\t\t\tthis.prefix_change(s_prefix_id, h_prefixes[s_prefix_id], p_prefix_iri);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// update prefix\n\t\t\t\t\t\t\th_prefixes[s_prefix_id] = p_prefix_iri;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// first mapping\n\t\t\t\t\telse {\n\t\t\t\t\t\t// check namespace, invalid\n\t\t\t\t\t\tif(!b_relax && !RT_PREFIXED_NAME_NAMESPACE_VALID.test(s_prefix_id)) {\n\t\t\t\t\t\t\treturn this.error(`Invalid namespace for prefixed name: \"${s_prefix_id}:\"`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// set prefix\n\t\t\t\t\t\th_prefixes[s_prefix_id] = p_prefix_iri;\n\t\t\t\t\t}\n\n\t\t\t\t\t// check iri, invalid\n\t\t\t\t\tif(!b_relax && !RT_NAMED_NODE_VALID.test(p_prefix_iri)) {\n\t\t\t\t\t\treturn this.error(`Invalid IRI found in prefix delcaration: \"${s_iri}\"`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// emit prefix event\n\t\t\t\t\tthis.event('prefix', s_prefix_id, p_prefix_iri);\n\n\t\t\t\t\tif(this._b_expecting_full_stop) {\n\t\t\t\t\t\t// change state\n\t\t\t\t\t\treturn this.full_stop();\n\t\t\t\t\t}\n\n\t\t\t\t\t// goto statement state\n\t\t\t\t\treturn this.block();\n\n\t\t\t\t// for poorly-placed comments\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t// do not change state\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t// match counter: 2\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('prefix_iri');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.prefix_iri;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n// in case eos happens twice during prefix / base (extremely unlikely)\n\n\n\t// parse state for full_stop\n\tfull_stop() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// prepare sticky regex index\n\t\t\tR_CHAR_STOP.lastIndex = i;\n\n\t\t\tif(R_CHAR_STOP.exec(s)) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_CHAR_STOP.lastIndex;\n\t\t\t\t// resume statement\n\t\t\t\treturn this.block();\n\n\t\t\t// poorly-placed comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t// try again\n\t\t\t\t\tcontinue;\n\n\t\t\t// possibly interrupted by eos\n\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('full_stop');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.full_stop;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for collection_subject\n\tcollection_subject() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref char\n\t\t\tlet x = s[i];\n\n\t\t\t// end of collection\n\t\t\tif(')' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// no items in collection subject\n\t\t\t\tif(null === this._kt_subject) {\n\t\t\t\t\t// prepare subject\n\t\t\t\t\tthis._kt_subject = this._kt_rdf_nil;\n\n\t\t\t\t\t// state was never pushed to stack, jump to post_subject state\n\t\t\t\t\treturn this.post_blank_subject();\n\t\t\t\t}\n// otherwise, there must be items in collection\n\n\t\t\t\t// commit collection end\n\t\t\t\tthis._kt_object = this._kt_rdf_nil;\n\t\t\t\tthis.data();\n\n\n\t\t\t\t// restore state from stack\n\t\t\t\tlet s_resume_state;\n\t\t\t\t[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();\n\t\t\t\treturn this[s_resume_state]();\n\t\t\t}\n\n\n\n\t\t\t// otherwise, pre-emptively secure the next blank node label\n\t\t\tlet s_pointer_label;\n\n\t\t\t// very first collection object\n\t\t\tlet b_pushed = false;\n\t\t\tif(null === this._kt_subject) {\n\t\t\t\t// set quasi subject (really for resume state)\n\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\tthis._kt_subject = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'pairs']);\n\t\t\t\t// reset subject for later conditional branch\n\t\t\t\tthis._kt_subject = null;\n\t\t\t\tb_pushed = true;\n\t\t\t}\n\n// iriref\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_object = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_object) {\n\t\t\t\t// advance index\n\t\t\t\ti = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_object[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set object\n\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(s_iri);\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t}\n\n\t\t\t// prefixed name\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// try match\n\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t// stack bail out\n\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\tlet [m_prefixed_named_e_object, im_prefixed_named_e_object] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\tif(m_prefixed_named_e_object) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = im_prefixed_named_e_object;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_object[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, m_prefixed_named_e_object[2]);\n\n\t\t\t\t// string literal\n\t\t\t\t}\n\t\t\t\telse \tif('\"' === x || '\\'' === x) {\n\t\t\t\t\t// first item in list\n\t\t\t\t\tif(null === this._kt_subject) {\n\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t}\n\t\t\t\t\t// not first item in list\n\t\t\t\t\telse {\n\t\t\t\t\t\t// make nest list item\n\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t// setup for object literal\n\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t}\n\n\t\t\t\t\t// how to resume collection subject state after object literal\n\t\t\t\t\tthis.after_end_of_statement = function() {\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\tthis.after_end_of_statement = this.post_object;\n\t\t\t\t\t\treturn this.collection_subject();\n\t\t\t\t\t};\n\t\t\t\t\treturn this.string_literal();\n\n\t\t\t\t// numeric literal\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_NUMERIC_LITERAL.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_numeric_literal = R_NUMERIC_LITERAL.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_numeric_literal) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_NUMERIC_LITERAL.lastIndex;\n\t\t\t\t\t\t// it has exponent term, xsd:double\n\t\t\t\t\t\tif(m_numeric_literal[4]) {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.double(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// contains decimal point, xsd:decimal\n\t\t\t\t\t\telse if(m_numeric_literal[2] || m_numeric_literal[3]) {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.decimal(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// otherwise, it is an integer\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.integer(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t// boolean literal\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_BOOLEAN_LITERAL.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_boolean_literal = R_BOOLEAN_LITERAL.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_boolean_literal) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\ti = R_BOOLEAN_LITERAL.lastIndex;\n\t\t\t\t\t\t\t// make literal\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.boolean(!!m_boolean_literal[1]);\n\n\t\t\t\t\t\t// blank node property list\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('[' === x) {\n\t\t\t\t// advance index to next token\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t// this blank node is just the next item in the list\n\t\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\t\tlet kt_blank_node;\n\t\t\t\t\t\t\tif(null !== this._kt_subject) {\n\t\t\t\t\t\t\t\tkt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\t\t\tthis.data();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// subject needs to be set\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node || this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t\t\tlet s_label = this.next_label();\n\t\t\t\t\t\t\tkt_blank_node = this._kt_object = this.anonymous_blank_node(s_label);\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// when resume\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\n\t\t\t\t\t\t\t// push state\n\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_subject']);\n\n\t\t\t\t\t\t\t// prepare next triple\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\n\t\t\t\t\t\t\t// goto parsing pairs state\n\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t// new collection\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('(' === x) {\n\t\t\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\ti = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t// empty collection\n\t\t\t\t\t\t\tif(')' === s[i]) {\n\t\t\t\t\t\t\t\tthis.i = i;\n\t\t\t\t\t\t\t\tthis._kt_subject = this._a_nested[this._a_nested.length-1][0];\n\t\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t\t\t\tthis._a_nested.push([\n\t\t\t\t\t\t\t\t\tthis._kt_subject,\n\t\t\t\t\t\t\t\t\tthis._kt_rdf_rest,\n\t\t\t\t\t\t\t\t\t'collection_subject',\n\t\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t\t\treturn this.collection_object();\n\t\t\t\t\t\t\t}\n\n\n\n\t\t\t\t\t\t\t// commit list item pointer\n\t\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// add this list as an item to the outer list\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_object']);\n\n\t\t\t\t\t\t\t// prepare next triple\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\n\n\n\t\t\t\t\t\t\t// flowing\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t// labeled blank node\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_blank_node_label_object = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_blank_node_label_object) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\ti = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t\t\t// ref blank node label\n\t\t\t\t\t\t\t\tlet s_label = m_blank_node_label_object[1];\n\n\t\t\t\t\t\t\t\t// make object\n\t\t\t\t\t\t\t\tthis._kt_object = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\tlet m_iriref_object = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\tif(m_iriref_object) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\ti = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_object[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t// set object\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_object, im_prefixed_named_object] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\tif(m_prefixed_named_object) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\ti = im_prefixed_named_object;\n\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_object[1] || '';\n\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_object[2]\n\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, s_suffix);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection\n\t\t\t// match counter: 7\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// ran out of characters after pushing state, pop it\n\t\t\t\t\t\t\t\t\t\t\tif(b_pushed) this._a_nested.pop();\n\n\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\n\n\t\t\tlet kt_blank_node_outer;\n\t\t\tif(!s_pointer_label) s_pointer_label = this.next_label();\n\n\t\t\t// not the very first item of collection subject\n\t\t\tif(this._kt_subject !== null) {\n\t\t\t\t// ref object\n\t\t\t\tlet w_object = this._kt_object;\n\n\t\t\t\t// create blanknode to embed list\n\t\t\t\tkt_blank_node_outer = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\n\t\t\t\t// emit statement that functions as collection's head \"pointer\"\n\t\t\t\tthis.data();\n\n\n\t\t\t\t// swap back object\n\t\t\t\tthis._kt_object = w_object;\n\t\t\t}\n\n\t\t\t// emit statement that is item\n\t\t\tthis._kt_subject = kt_blank_node_outer || this.anonymous_blank_node(s_pointer_label);\n\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\tthis.data();\n\n\n\t\t\t// prepare next predicate\n\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('collection_subject');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.collection_subject;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for collection_object\n\tcollection_object() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref char\n\t\t\tlet x = s[i];\n\n\t\t\t// end of collection\n\t\t\tif(')' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// make & emit collection's tail \"pointer\"\n\t\t\t\tthis._kt_object = this._kt_rdf_nil;\n\t\t\t\tthis.data();\n\n\n\t\t\t\t// restore previous state\n\t\t\t\tlet s_resume_state;\n\t\t\t\t[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();\n\t\t\t\treturn this[s_resume_state]();\n\t\t\t}\n\n\n\n\t\t\t// otherwise, pre-emptively secure the next blank node label\n\t\t\tlet s_pointer_label;\n\n// iriref\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_object = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_object) {\n\t\t\t\t// advance index\n\t\t\t\ti = R_IRIREF_ESCAPELESS.lastIndex;\n// commit object iri as is\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_object[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set object\n\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(s_iri);\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t}\n\n\t\t\t// prefixed name\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// try match\n\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t// stack bail out\n\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\tlet [m_prefixed_named_e_object, im_prefixed_named_e_object] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\tif(m_prefixed_named_e_object) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = im_prefixed_named_e_object;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_object[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, m_prefixed_named_e_object[2]);\n\n\t\t\t\t// string literal\n\t\t\t\t}\n\t\t\t\telse \tif('\"' === x || '\\'' === x) {\n\t\t\t\t\t// update index before changing states\n\t\t\t\t\tthis.i = i;\n\n\t\t\t\t\t// create blanknode to embed list\n\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t// emit statement that functions as collection's head \"pointer\"\n\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t// prepare statement that is item\n\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\n\t\t\t\t\tthis.after_end_of_statement = function() {\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\tthis.after_end_of_statement = this.post_object;\n\t\t\t\t\t\treturn this.collection_object();\n\t\t\t\t\t};\n\t\t\t\t\treturn this.string_literal();\n\n\t\t\t\t// numeric literal\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_NUMERIC_LITERAL.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_numeric_literal = R_NUMERIC_LITERAL.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_numeric_literal) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_NUMERIC_LITERAL.lastIndex;\n\t\t\t\t\t\t// it has exponent term, xsd:double\n\t\t\t\t\t\tif(m_numeric_literal[4]) {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.double(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// contains decimal point, xsd:decimal\n\t\t\t\t\t\telse if(m_numeric_literal[2] || m_numeric_literal[3]) {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.decimal(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// otherwise, it is an integer\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.integer(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t// boolean literal\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_BOOLEAN_LITERAL.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_boolean_literal = R_BOOLEAN_LITERAL.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_boolean_literal) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\ti = R_BOOLEAN_LITERAL.lastIndex;\n\t\t\t\t\t\t\t// make literal\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.boolean(!!m_boolean_literal[1]);\n\n\t\t\t\t\t\t// blank node property list\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('[' === x) {\n\t\t\t\t// advance index to next token\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t// commit head of list pointer\n\t\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// setup state to resume and push\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_object']);\n\n\t\t\t\t\t\t\t// enter blank node\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t\t\tkt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// prepare next triple\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\n\t\t\t\t\t\t\t// goto parsing pairs state\n\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t// new collection\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('(' === x) {\n\t\t\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\ti = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t// commit list item pointer\n\t\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\t\tif(null === this._kt_subject) {\n\t\t\t\t\t\t\t\tlet a_recent = this._a_nested[this._a_nested.length-1];\n\t\t\t\t\t\t\t\tthis._kt_subject = a_recent[0];\n\t\t\t\t\t\t\t\tthis._kt_predicate = a_recent[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// add this list as an item to the outer list\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_object']);\n\n\t\t\t\t\t\t\t// prepare next triple\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\n\t\t\t\t\t\t\t// flowing\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t// labeled blank node\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_blank_node_label_object = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_blank_node_label_object) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\ti = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t\t\t// ref blank node label\n\t\t\t\t\t\t\t\tlet s_label = m_blank_node_label_object[1];\n\n\t\t\t\t\t\t\t\t// make collection pointer label first\n\t\t\t\t\t\t\t\ts_pointer_label = this.next_label();\n\n\t\t\t\t\t\t\t\t// make object\n\t\t\t\t\t\t\t\tthis._kt_object = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\tlet m_iriref_object = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\tif(m_iriref_object) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\ti = R_IRIREF.lastIndex;\n// commit object iri as is\n\n\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_object[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t// set object\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_object, im_prefixed_named_object] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\tif(m_prefixed_named_object) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\ti = im_prefixed_named_object;\n\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_object[1] || '';\n\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_object[2]\n\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, s_suffix);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection\n\t\t\t// match counter: 7\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\n\n\n\t\t\t// ref object\n\t\t\tlet w_object = this._kt_object;\n\n\t\t\t// create blanknode to embed list\n\t\t\tif(!s_pointer_label) s_pointer_label = this.next_label();\n\t\t\tlet kt_blank_node_outer = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\n\t\t\t// emit statement that functions as collection's head \"pointer\"\n\t\t\tthis.data();\n\n\n\t\t\t// emit statement that is item\n\t\t\tthis._kt_subject = kt_blank_node_outer;\n\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\tthis._kt_object = w_object;\n\t\t\tthis.data();\n\n\n\t\t\t// prepare next predicate\n\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('collection_object');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.collection_object;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\tdestroy(e_destroy) {\n\t\tthis.post_blank_subject = () => {};\n\n\t\tthis.statement = () => {};\n\n\t\tthis.block = () => {};\n\n\t\tthis.graph_or_subject = () => {};\n\n\t\tthis.graph_or_subject_property_list = () => {};\n\n\t\tthis.graph_or_subject_anon = () => {};\n\n\t\tthis.graph_keyword = () => {};\n\n\t\tthis.graph_post_name = () => {};\n\n\t\tthis.pairs = () => {};\n\n\t\tthis.object_list = () => {};\n\n\t\tthis.string_literal_short_double = () => {};\n\n\t\tthis.string_literal_short_single = () => {};\n\n\t\tthis.string_literal_long_double = () => {};\n\n\t\tthis.string_literal_long_single = () => {};\n\n\t\tthis.string_literal = () => {};\n\n\t\tthis.datatype_or_langtag = () => {};\n\n\t\tthis.datatype = () => {};\n\n\t\tthis.post_object = () => {};\n\n\t\tthis.base_iri = () => {};\n\n\t\tthis.prefix_id = () => {};\n\n\t\tthis.prefix_iri = () => {};\n\n\t\tthis.full_stop = () => {};\n\n\t\tthis.collection_subject = () => {};\n\n\t\tthis.collection_object = () => {};\n\n\n\t\tthis.eof = () => {\n\t\t\tthis.s = null;\n\t\t};\n\n\t\tthis._b_destroyed = true;\n\n\t\t// propagate input destroy\n\t\tif(!e_destroy && this._ds_input) {\n\t\t\tthis._ds_input.destroy(e_destroy);\n\t\t}\n\n\t\tthis.transform.demolish(e_destroy);\n\t}\n}\n\nmodule.exports = function(...a_args) {\n\tlet g_config = {};\n\n\t// at least one argument\n\tif(a_args.length) {\n\t\tlet z_arg_0 = a_args[0];\n\n\t\t// input given unspecified\n\t\tif(z_arg_0 && z_arg_0.input && 'undefined' === typeof z_arg_0.input.string && !z_arg_0.input.stream) {\n\t\t\tz_arg_0 = z_arg_0.input;\n\t\t}\n\n\t\t// string\n\t\tif('string' === typeof z_arg_0) {\n\t\t\tg_config.input = {string:z_arg_0};\n\t\t}\n\t\t// null\n\t\telse if(null === z_arg_0) {\n\t\t\tg_config.input = null;\n\t\t}\n\t\t// node stream\n\t\telse if('function' === typeof z_arg_0.setEncoding) {\n\t\t\tg_config.input = {stream:z_arg_0};\n\t\t}\n\t\t// whatwg stream\n\t\telse if('function' === typeof z_arg_0.pipeTo) {\n\t\t\tthrow new TypeError(`Sorry, WHATWG streams are currently not supported :(`);\n\t\t// g_config.input = {stream:z_arg_0};\n\t\t}\n\t\t// config struct\n\t\telse if(z_arg_0 && 'object' === typeof z_arg_0 && '[object Object]' === Object.prototype.toString.call(z_arg_0)) {\n\t\t\tg_config = z_arg_0;\n\n\t\t\t// more args; invalid\n\t\t\tif(a_args.length > 1) {\n\t\t\t\tthrow new TypeError(`unexpected argument(s) after config struct: ${a_args.slice(1)}`);\n\t\t\t}\n\t\t}\n\t\t// unknown\n\t\telse {\n\t\t\tthrow new TypeError(`unexpected input type: ${z_arg_0}`);\n\t\t}\n\n\t\t// more args\n\t\tif(a_args.length > 1) {\n\t\t\t// copy onto struct\n\t\t\tObject.assign(g_config, a_args[1]);\n\n\t\t\t// more args\n\t\t\tif(a_args.length > 2) {\n\t\t\t\tthrow new TypeError(`unexpected argument(s) after input and config struct: ${a_args.slice(2)}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t// create reader, return transform stream\n\treturn (new Reader(g_config)).transform;\n};\n","const stream = require('readable-stream');\n\n\n\nclass Readable extends stream.Readable {\n\tconstructor(gc_readable={}) {\n\t\tsuper(gc_readable);\n\n\t\t// use iterator\n\t\tif(gc_readable.iterator) {\n\t\t\tthrow new Error('readable stream iterator shortcut not yet implemented');\n\t\t}\n\t}\n\n\tuntil(s_event, b_return_stream) {\n\t\treturn new Promise((fk_until, fe_until) => {\n\t\t\t// convert error to rejected promise\n\t\t\tthis.on('error', (e_stream) => {\n\t\t\t\tfe_until(e_stream);\n\t\t\t});\n\n\t\t\t// special cases returns `this`\n\t\t\tif(b_return_stream) {\n\t\t\t\tthis.once(s_event, (...a_args) => {\n\t\t\t\t\tfk_until(this, ...a_args);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.once(s_event, fk_until);\n\t\t\t}\n\t\t});\n\t}\n\n\tbucket(s_encoding='utf8') {\n\t\tlet g_readable = this._readableState;\n\n\t\t// object mode\n\t\tif(g_readable.objectMode) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet a_data = [];\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\twrite(w_event, s_write_encoding, fk_write) {\n\t\t\t\t\t\ta_data.push(w_event);\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\n\t\t\t\t\twritev(a_chunks, fk_writev) {\n\t\t\t\t\t\ta_data.push(...a_chunks);\n\t\t\t\t\t\tfk_writev();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(a_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// utf8-encoded strings\n\t\telse if('utf8' === s_encoding || 'utf-8' === s_encoding) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet s_data = '';\n\n\t\t\t\t// set encoding\n\t\t\t\tthis.setEncoding(s_encoding);\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\tdecodeStrings: false,\n\n\t\t\t\t\twrite(s_chunk, s_write_encoding, fk_write) {\n\t\t\t\t\t\ts_data += s_chunk;\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\n\t\t\t\t\twritev(a_chunks, fk_writev) {\n\t\t\t\t\t\ts_data += a_chunks.join('');\n\t\t\t\t\t\tfk_writev();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(s_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// buffer\n\t\telse if('buffer' === s_encoding) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet ab_data = Buffer.from([]);\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\tdecodeStrings: true,\n\n\t\t\t\t\twrite(ab_chunk, s_write_encoding, fk_write) {\n\t\t\t\t\t\tab_data = Buffer.concat([ab_data, ab_chunk], ab_data.length+ab_chunk.length);\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(ab_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n}\n\nclass Writable extends stream.Writable {\n\tuntil(s_event, b_return_stream) {\n\t\treturn new Promise((fk_until, fe_until) => {\n\t\t\t// convert error to rejected promise\n\t\t\tthis.on('error', (e_stream) => {\n\t\t\t\tfe_until(e_stream);\n\t\t\t});\n\n\t\t\t// special cases returns `this`\n\t\t\tif(b_return_stream) {\n\t\t\t\tthis.once(s_event, (...a_args) => {\n\t\t\t\t\tfk_until(this, ...a_args);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.once(s_event, fk_until);\n\t\t\t}\n\t\t});\n\t}\n\n\t// rdfjs impl\n\timport(ds_source) {\n\t\tds_source\n\t\t\t.on('data', w_chunk => this.write(w_chunk))\n\t\t\t.on('end', () => this.end())\n\t\t\t.on('error', e_read => this.emit('error', e_read));\n\n\t\treturn this;\n\t}\n}\n\nclass Duplex extends stream.Duplex {\n\tuntil(s_event, b_return_stream) {\n\t\treturn new Promise((fk_until, fe_until) => {\n\t\t\t// convert error to rejected promise\n\t\t\tthis.on('error', (e_stream) => {\n\t\t\t\tfe_until(e_stream);\n\t\t\t});\n\n\t\t\t// special cases returns `this`\n\t\t\tif(b_return_stream) {\n\t\t\t\tthis.once(s_event, (...a_args) => {\n\t\t\t\t\tfk_until(this, ...a_args);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.once(s_event, fk_until);\n\t\t\t}\n\t\t});\n\t}\n\n\tbucket(s_encoding='utf8') {\n\t\tlet g_readable = this._readableState;\n\n\t\t// object mode\n\t\tif(g_readable.objectMode) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet a_data = [];\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\twrite(w_event, s_write_encoding, fk_write) {\n\t\t\t\t\t\ta_data.push(w_event);\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\n\t\t\t\t\twritev(a_chunks, fk_writev) {\n\t\t\t\t\t\ta_data.push(...a_chunks);\n\t\t\t\t\t\tfk_writev();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(a_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// utf8-encoded strings\n\t\telse if('utf8' === s_encoding || 'utf-8' === s_encoding) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet s_data = '';\n\n\t\t\t\t// set encoding\n\t\t\t\tthis.setEncoding(s_encoding);\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\tdecodeStrings: false,\n\n\t\t\t\t\twrite(s_chunk, s_write_encoding, fk_write) {\n\t\t\t\t\t\ts_data += s_chunk;\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\n\t\t\t\t\twritev(a_chunks, fk_writev) {\n\t\t\t\t\t\ts_data += a_chunks.join('');\n\t\t\t\t\t\tfk_writev();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(s_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// buffer\n\t\telse if('buffer' === s_encoding) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet ab_data = Buffer.from([]);\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\tdecodeStrings: true,\n\n\t\t\t\t\twrite(ab_chunk, s_write_encoding, fk_write) {\n\t\t\t\t\t\tab_data = Buffer.concat([ab_data, ab_chunk], ab_data.length+ab_chunk.length);\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(ab_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n}\n\nclass Transform extends stream.Transform {\n\tuntil(s_event, b_return_stream) {\n\t\treturn new Promise((fk_until, fe_until) => {\n\t\t\t// convert error to rejected promise\n\t\t\tthis.on('error', (e_stream) => {\n\t\t\t\tfe_until(e_stream);\n\t\t\t});\n\n\t\t\t// special cases returns `this`\n\t\t\tif(b_return_stream) {\n\t\t\t\tthis.once(s_event, (...a_args) => {\n\t\t\t\t\tfk_until(this, ...a_args);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.once(s_event, fk_until);\n\t\t\t}\n\t\t});\n\t}\n\n\tbucket(s_encoding='utf8') {\n\t\tlet g_readable = this._readableState;\n\n\t\t// object mode\n\t\tif(g_readable.objectMode) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet a_data = [];\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\twrite(w_event, s_write_encoding, fk_write) {\n\t\t\t\t\t\ta_data.push(w_event);\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\n\t\t\t\t\twritev(a_chunks, fk_writev) {\n\t\t\t\t\t\ta_data.push(...a_chunks);\n\t\t\t\t\t\tfk_writev();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(a_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// utf8-encoded strings\n\t\telse if('utf8' === s_encoding || 'utf-8' === s_encoding) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet s_data = '';\n\n\t\t\t\t// set encoding\n\t\t\t\tthis.setEncoding(s_encoding);\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\tdecodeStrings: false,\n\n\t\t\t\t\twrite(s_chunk, s_write_encoding, fk_write) {\n\t\t\t\t\t\ts_data += s_chunk;\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\n\t\t\t\t\twritev(a_chunks, fk_writev) {\n\t\t\t\t\t\ts_data += a_chunks.join('');\n\t\t\t\t\t\tfk_writev();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(s_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// buffer\n\t\telse if('buffer' === s_encoding) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet ab_data = Buffer.from([]);\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\tdecodeStrings: true,\n\n\t\t\t\t\twrite(ab_chunk, s_write_encoding, fk_write) {\n\t\t\t\t\t\tab_data = Buffer.concat([ab_data, ab_chunk], ab_data.length+ab_chunk.length);\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(ab_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\t// rdfjs impl\n\timport(ds_source) {\n\t\tds_source\n\t\t\t.on('data', w_chunk => this.write(w_chunk))\n\t\t\t.on('end', () => this.end())\n\t\t\t.on('error', e_read => this.emit('error', e_read));\n\n\t\treturn this;\n\t}\n\n\tdemolish(e_destroy) {\n\t\t// do not allow to push\n\t\tthis.push = (z_chunk) => {\n\t\t\t// ignore eof signals from node core\n\t\t\tif(null === z_chunk) return;\n\n\t\t\t// anything else is bad\n\t\t\tthrow new Error(`[ERR_STREAM_DESTROYED]: Cannot push after stream was destroyed`);\n\t\t};\n\n\t\t// do not allow to emit 'end'\n\t\tthis.emit = function(s_event, ...a_args) {\n\t\t\tif('end' === s_event) return;\n\n\t\t\tObject.getPrototypeOf(this).emit.apply(this, [s_event, ...a_args]);\n\t\t};\n\n\t\t// an error was given, destroy the stream as well\n\t\tif(e_destroy) {\n\t\t\treturn stream.Transform.prototype.destroy.call(this, e_destroy);\n\t\t}\n\t}\n}\n\n// eslint-disable-next-line no-new-func\nconst b_is_node = (new Function(/* syntax: js */ `try {return this===global;}catch(e){return false;}`))();\n\n// deduce the runtime environment\nconst [B_BROWSER, B_BROWSERIFY] = (() => 'undefined' === typeof process\n\t? [true, false]\n\t: (process.browser\n\t\t? [true, true]\n\t\t: ('undefined' === process.versions || 'undefined' === process.versions.node\n\t\t\t? [true, false]\n\t\t\t: [false, false])))();\n\n// node.js or browserify; patch for node < v10\nif(B_BROWSERIFY || (b_is_node && (+(/^v(\\d+)/.exec(process.version)[1])) < 10)) {\n\t// override destroy methods\n\tTransform.prototype.destroy = Duplex.prototype.destroy = function(e_destroy, fke_destroy) {\n\t\tthis._readableState.destroyed = true;\n\t\tthis._writableState.destroyed = true;\n\n\t\tlet f_emit_close = () => {\n\t\t\tif(!this._writableState.emitClose) return;\n\t\t\tif(!this._readableState.emitClose) return;\n\t\t\tthis.emit('close');\n\t\t};\n\n\t\tthis._destroy(e_destroy || null, (e_destroy_re) => {\n\t\t\tif(!fke_destroy && e_destroy_re) {\n\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\tthis.emit('error', e_destroy_re);\n\t\t\t\t\tf_emit_close();\n\t\t\t\t});\n\t\t\t\tthis._writableState.errorEmitted = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprocess.nextTick(f_emit_close);\n\t\t\t\tif(fke_destroy) fke_destroy(e_destroy_re);\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t};\n\n\t// override default _destroy implementations\n\tTransform.prototype._destroy = Duplex.prototype._destroy = (e_destroy, fke_destroy) => fke_destroy(e_destroy);\n}\n\nclass QuadsToOther extends Transform {\n\tconstructor(gc_transform={}) {\n\t\tsuper({\n\t\t\t...gc_transform,\n\t\t\twritableObjectMode: true,\n\t\t\treadableObjectMode: true,\n\t\t});\n\n\t\tthis._as_inputs = new Set();\n\n\t\t// forward prefix and comment events\n\t\tthis.on('pipe', (ds_src) => {\n\t\t\tthis._as_inputs.add(ds_src);\n\n\t\t\tds_src\n\t\t\t\t.on('prefix', (...a_args) => {\n\t\t\t\t\tthis.emit('prefix', ...a_args);\n\t\t\t\t})\n\t\t\t\t.on('comment', (...a_args) => {\n\t\t\t\t\tthis.emit('comment', ...a_args);\n\t\t\t\t});\n\t\t});\n\n\t\tthis.on('unpipe', (ds_src) => {\n\t\t\tthis._as_inputs.delete(ds_src);\n\t\t});\n\t}\n\n\t_destroy() {\n\t\tfor(let ds_input of this._as_inputs) {\n\t\t\tds_input.destroy();\n\t\t}\n\t}\n}\n\nclass Quads_To_JSON_Transform extends QuadsToOther {\n\t// serializse json\n\t_transform(g_quad, s_encoding, fk_transform) {\n\t\tfk_transform(null, JSON.stringify(g_quad.isolate())+'\\n');\n\t}\n}\n\nclass Quads_To_Writable extends QuadsToOther {\n\t_transform(g_quad, s_encoding, fk_transform) {\n\t\tfk_transform(null, {\n\t\t\ttype: 'quad',\n\t\t\tvalue: g_quad,\n\t\t});\n\t}\n}\n\nTransform.QuadsToOther = QuadsToOther;\n\nmodule.exports = {\n\t...stream,\n\tReadable,\n\tWritable,\n\tDuplex,\n\tTransform,\n\n\tQuadsToOther,\n\n\t// create a transform from quad objects into JSON strings for trivial serialization\n\tquads_to_json() {\n\t\treturn new Quads_To_JSON_Transform();\n\t},\n\n\t// create a transform from quad objects into writable data events\n\tquads_to_writable() {\n\t\treturn new Quads_To_Writable();\n\t},\n\n\t// create a simple, single-event readable stream\n\tsource(w_push, s_encoding=null) {\n\t\t// encoding not explicit, string given; assume utf8\n\t\tif(!s_encoding && 'string' === typeof w_push) s_encoding = 'utf8';\n\n\t\t// readable\n\t\treturn new Readable({\n\t\t\tobjectMode: !s_encoding && 'string' !== typeof w_push && !Buffer.isBuffer(w_push),\n\n\t\t\tread() {\n\t\t\t\tthis.push(w_push, s_encoding);\n\t\t\t\tthis.push(null);\n\t\t\t},\n\t\t});\n\t},\n};\n","/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.URI = global.URI || {})));\n}(this, (function (exports) { 'use strict';\n\nfunction merge() {\n    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {\n        sets[_key] = arguments[_key];\n    }\n\n    if (sets.length > 1) {\n        sets[0] = sets[0].slice(0, -1);\n        var xl = sets.length - 1;\n        for (var x = 1; x < xl; ++x) {\n            sets[x] = sets[x].slice(1, -1);\n        }\n        sets[xl] = sets[xl].slice(1);\n        return sets.join('');\n    } else {\n        return sets[0];\n    }\n}\nfunction subexp(str) {\n    return \"(?:\" + str + \")\";\n}\nfunction typeOf(o) {\n    return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n}\nfunction toUpperCase(str) {\n    return str.toUpperCase();\n}\nfunction toArray(obj) {\n    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];\n}\nfunction assign(target, source) {\n    var obj = target;\n    if (source) {\n        for (var key in source) {\n            obj[key] = source[key];\n        }\n    }\n    return obj;\n}\n\nfunction buildExps(isIRI) {\n    var ALPHA$$ = \"[A-Za-z]\",\n        CR$ = \"[\\\\x0D]\",\n        DIGIT$$ = \"[0-9]\",\n        DQUOTE$$ = \"[\\\\x22]\",\n        HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),\n        //case-insensitive\n    LF$$ = \"[\\\\x0A]\",\n        SP$$ = \"[\\\\x20]\",\n        PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),\n        //expanded\n    GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n        SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n        UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",\n        //subset, excludes bidi control characters\n    IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",\n        //subset\n    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n        USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n        DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n        DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),\n        //relaxed parsing rules\n    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n        H16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n        LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n        IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$),\n        //                           6( h16 \":\" ) ls32\n    IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$),\n        //                      \"::\" 5( h16 \":\" ) ls32\n    IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$),\n        //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$),\n        //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$),\n        //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$),\n        //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$),\n        //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$),\n        //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"),\n        //[ *6( h16 \":\" ) h16 ] \"::\"\n    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n        ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),\n        //RFC 6874\n    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),\n        //RFC 6874\n    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),\n        //RFC 6874, with relaxed parsing rules\n    IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n        IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),\n        //RFC 6874\n    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n        HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n        PORT$ = subexp(DIGIT$$ + \"*\"),\n        AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n        PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n        SEGMENT$ = subexp(PCHAR$ + \"*\"),\n        SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n        PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n        PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),\n        //simplified\n    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n        PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n        FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n        HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n        RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n        ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n        GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n        SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n    return {\n        NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n        NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n        NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n        ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n        OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n        PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n        IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n        IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n    };\n}\nvar URI_PROTOCOL = buildExps(false);\n\nvar IRI_PROTOCOL = buildExps(true);\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/** Highest positive signed 32-bit float value */\n\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\nvar delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nvar regexPunycode = /^xn--/;\nvar regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nvar regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nvar errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nvar baseMinusTMin = base - tMin;\nvar floor = Math.floor;\nvar stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error$1(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tvar result = [];\n\tvar length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tvar parts = string.split('@');\n\tvar result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tvar labels = string.split('.');\n\tvar encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tvar output = [];\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t// Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nvar ucs2encode = function ucs2encode(array) {\n\treturn String.fromCodePoint.apply(String, toConsumableArray(array));\n};\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nvar basicToDigit = function basicToDigit(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nvar digitToBasic = function digitToBasic(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nvar adapt = function adapt(delta, numPoints, firstTime) {\n\tvar k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nvar decode = function decode(input) {\n\t// Don't use UCS-2.\n\tvar output = [];\n\tvar inputLength = input.length;\n\tvar i = 0;\n\tvar n = initialN;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tvar basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (var j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror$1('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tvar oldi = i;\n\t\tfor (var w = 1, k = base;; /* no condition */k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror$1('invalid-input');\n\t\t\t}\n\n\t\t\tvar digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\t\t}\n\n\t\tvar out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\t}\n\n\treturn String.fromCodePoint.apply(String, output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nvar encode = function encode(input) {\n\tvar output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tvar inputLength = input.length;\n\n\t// Initialize the state.\n\tvar n = initialN;\n\tvar delta = 0;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points.\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar _currentValue2 = _step.value;\n\n\t\t\tif (_currentValue2 < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(_currentValue2));\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar basicLength = output.length;\n\tvar handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tvar m = maxInt;\n\t\tvar _iteratorNormalCompletion2 = true;\n\t\tvar _didIteratorError2 = false;\n\t\tvar _iteratorError2 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\tvar currentValue = _step2.value;\n\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow.\n\t\t} catch (err) {\n\t\t\t_didIteratorError2 = true;\n\t\t\t_iteratorError2 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t_iterator2.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tvar _iteratorNormalCompletion3 = true;\n\t\tvar _didIteratorError3 = false;\n\t\tvar _iteratorError3 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\tvar _currentValue = _step3.value;\n\n\t\t\t\tif (_currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror$1('overflow');\n\t\t\t\t}\n\t\t\t\tif (_currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\t\tvar q = delta;\n\t\t\t\t\tfor (var k = base;; /* no condition */k += base) {\n\t\t\t\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar qMinusT = q - t;\n\t\t\t\t\t\tvar baseMinusT = base - t;\n\t\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError3 = true;\n\t\t\t_iteratorError3 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t_iterator3.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nvar toUnicode = function toUnicode(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nvar toASCII = function toASCII(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nvar punycode = {\n\t/**\n  * A string representing the current Punycode.js version number.\n  * @memberOf punycode\n  * @type String\n  */\n\t'version': '2.1.0',\n\t/**\n  * An object of methods to convert from JavaScript's internal character\n  * representation (UCS-2) to Unicode code points, and back.\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n  * @memberOf punycode\n  * @type Object\n  */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\n/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\nvar SCHEMES = {};\nfunction pctEncChar(chr) {\n    var c = chr.charCodeAt(0);\n    var e = void 0;\n    if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n    return e;\n}\nfunction pctDecChars(str) {\n    var newStr = \"\";\n    var i = 0;\n    var il = str.length;\n    while (i < il) {\n        var c = parseInt(str.substr(i + 1, 2), 16);\n        if (c < 128) {\n            newStr += String.fromCharCode(c);\n            i += 3;\n        } else if (c >= 194 && c < 224) {\n            if (il - i >= 6) {\n                var c2 = parseInt(str.substr(i + 4, 2), 16);\n                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n            } else {\n                newStr += str.substr(i, 6);\n            }\n            i += 6;\n        } else if (c >= 224) {\n            if (il - i >= 9) {\n                var _c = parseInt(str.substr(i + 4, 2), 16);\n                var c3 = parseInt(str.substr(i + 7, 2), 16);\n                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n            } else {\n                newStr += str.substr(i, 9);\n            }\n            i += 9;\n        } else {\n            newStr += str.substr(i, 3);\n            i += 3;\n        }\n    }\n    return newStr;\n}\nfunction _normalizeComponentEncoding(components, protocol) {\n    function decodeUnreserved(str) {\n        var decStr = pctDecChars(str);\n        return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n    }\n    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    return components;\n}\n\nfunction _stripLeadingZeros(str) {\n    return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\nfunction _normalizeIPv4(host, protocol) {\n    var matches = host.match(protocol.IPV4ADDRESS) || [];\n\n    var _matches = slicedToArray(matches, 2),\n        address = _matches[1];\n\n    if (address) {\n        return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n    } else {\n        return host;\n    }\n}\nfunction _normalizeIPv6(host, protocol) {\n    var matches = host.match(protocol.IPV6ADDRESS) || [];\n\n    var _matches2 = slicedToArray(matches, 3),\n        address = _matches2[1],\n        zone = _matches2[2];\n\n    if (address) {\n        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),\n            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),\n            last = _address$toLowerCase$2[0],\n            first = _address$toLowerCase$2[1];\n\n        var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n        var lastFields = last.split(\":\").map(_stripLeadingZeros);\n        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n        var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n        var lastFieldsStart = lastFields.length - fieldCount;\n        var fields = Array(fieldCount);\n        for (var x = 0; x < fieldCount; ++x) {\n            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n        }\n        if (isLastFieldIPv4Address) {\n            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n        }\n        var allZeroFields = fields.reduce(function (acc, field, index) {\n            if (!field || field === \"0\") {\n                var lastLongest = acc[acc.length - 1];\n                if (lastLongest && lastLongest.index + lastLongest.length === index) {\n                    lastLongest.length++;\n                } else {\n                    acc.push({ index: index, length: 1 });\n                }\n            }\n            return acc;\n        }, []);\n        var longestZeroFields = allZeroFields.sort(function (a, b) {\n            return b.length - a.length;\n        })[0];\n        var newHost = void 0;\n        if (longestZeroFields && longestZeroFields.length > 1) {\n            var newFirst = fields.slice(0, longestZeroFields.index);\n            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n            newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n        } else {\n            newHost = fields.join(\":\");\n        }\n        if (zone) {\n            newHost += \"%\" + zone;\n        }\n        return newHost;\n    } else {\n        return host;\n    }\n}\nvar URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nvar NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\nfunction parse(uriString) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var components = {};\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n    var matches = uriString.match(URI_PARSE);\n    if (matches) {\n        if (NO_MATCH_IS_UNDEFINED) {\n            //store each component\n            components.scheme = matches[1];\n            components.userinfo = matches[3];\n            components.host = matches[4];\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = matches[7];\n            components.fragment = matches[8];\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = matches[5];\n            }\n        } else {\n            //IE FIX for improper RegExp matching\n            //store each component\n            components.scheme = matches[1] || undefined;\n            components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n            components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n            components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n            }\n        }\n        if (components.host) {\n            //normalize IP hosts\n            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n        }\n        //determine reference type\n        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n            components.reference = \"same-document\";\n        } else if (components.scheme === undefined) {\n            components.reference = \"relative\";\n        } else if (components.fragment === undefined) {\n            components.reference = \"absolute\";\n        } else {\n            components.reference = \"uri\";\n        }\n        //check for reference errors\n        if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n            components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n        }\n        //find scheme handler\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n        //check if scheme can't handle IRIs\n        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n            //if host component is a domain name\n            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            }\n            //convert IRI -> URI\n            _normalizeComponentEncoding(components, URI_PROTOCOL);\n        } else {\n            //normalize encodings\n            _normalizeComponentEncoding(components, protocol);\n        }\n        //perform scheme specific parsing\n        if (schemeHandler && schemeHandler.parse) {\n            schemeHandler.parse(components, options);\n        }\n    } else {\n        components.error = components.error || \"URI can not be parsed.\";\n    }\n    return components;\n}\n\nfunction _recomposeAuthority(components, options) {\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    if (components.userinfo !== undefined) {\n        uriTokens.push(components.userinfo);\n        uriTokens.push(\"@\");\n    }\n    if (components.host !== undefined) {\n        //normalize IP hosts, add brackets and escape zone separator for IPv6\n        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {\n            return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n        }));\n    }\n    if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n        uriTokens.push(\":\");\n        uriTokens.push(String(components.port));\n    }\n    return uriTokens.length ? uriTokens.join(\"\") : undefined;\n}\n\nvar RDS1 = /^\\.\\.?\\//;\nvar RDS2 = /^\\/\\.(\\/|$)/;\nvar RDS3 = /^\\/\\.\\.(\\/|$)/;\nvar RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\nfunction removeDotSegments(input) {\n    var output = [];\n    while (input.length) {\n        if (input.match(RDS1)) {\n            input = input.replace(RDS1, \"\");\n        } else if (input.match(RDS2)) {\n            input = input.replace(RDS2, \"/\");\n        } else if (input.match(RDS3)) {\n            input = input.replace(RDS3, \"/\");\n            output.pop();\n        } else if (input === \".\" || input === \"..\") {\n            input = \"\";\n        } else {\n            var im = input.match(RDS5);\n            if (im) {\n                var s = im[0];\n                input = input.slice(s.length);\n                output.push(s);\n            } else {\n                throw new Error(\"Unexpected dot segment condition\");\n            }\n        }\n    }\n    return output.join(\"\");\n}\n\nfunction serialize(components) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    //find scheme handler\n    var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n    //perform scheme specific serialization\n    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n    if (components.host) {\n        //if host component is an IPv6 address\n        if (protocol.IPV6ADDRESS.test(components.host)) {}\n        //TODO: normalize IPv6 address as per RFC 5952\n\n        //if host component is a domain name\n        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n                //convert IDN via punycode\n                try {\n                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n            }\n    }\n    //normalize encoding\n    _normalizeComponentEncoding(components, protocol);\n    if (options.reference !== \"suffix\" && components.scheme) {\n        uriTokens.push(components.scheme);\n        uriTokens.push(\":\");\n    }\n    var authority = _recomposeAuthority(components, options);\n    if (authority !== undefined) {\n        if (options.reference !== \"suffix\") {\n            uriTokens.push(\"//\");\n        }\n        uriTokens.push(authority);\n        if (components.path && components.path.charAt(0) !== \"/\") {\n            uriTokens.push(\"/\");\n        }\n    }\n    if (components.path !== undefined) {\n        var s = components.path;\n        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n            s = removeDotSegments(s);\n        }\n        if (authority === undefined) {\n            s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n        }\n        uriTokens.push(s);\n    }\n    if (components.query !== undefined) {\n        uriTokens.push(\"?\");\n        uriTokens.push(components.query);\n    }\n    if (components.fragment !== undefined) {\n        uriTokens.push(\"#\");\n        uriTokens.push(components.fragment);\n    }\n    return uriTokens.join(\"\"); //merge tokens into a string\n}\n\nfunction resolveComponents(base, relative) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var skipNormalization = arguments[3];\n\n    var target = {};\n    if (!skipNormalization) {\n        base = parse(serialize(base, options), options); //normalize base components\n        relative = parse(serialize(relative, options), options); //normalize relative components\n    }\n    options = options || {};\n    if (!options.tolerant && relative.scheme) {\n        target.scheme = relative.scheme;\n        //target.authority = relative.authority;\n        target.userinfo = relative.userinfo;\n        target.host = relative.host;\n        target.port = relative.port;\n        target.path = removeDotSegments(relative.path || \"\");\n        target.query = relative.query;\n    } else {\n        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n            //target.authority = relative.authority;\n            target.userinfo = relative.userinfo;\n            target.host = relative.host;\n            target.port = relative.port;\n            target.path = removeDotSegments(relative.path || \"\");\n            target.query = relative.query;\n        } else {\n            if (!relative.path) {\n                target.path = base.path;\n                if (relative.query !== undefined) {\n                    target.query = relative.query;\n                } else {\n                    target.query = base.query;\n                }\n            } else {\n                if (relative.path.charAt(0) === \"/\") {\n                    target.path = removeDotSegments(relative.path);\n                } else {\n                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n                        target.path = \"/\" + relative.path;\n                    } else if (!base.path) {\n                        target.path = relative.path;\n                    } else {\n                        target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n                    }\n                    target.path = removeDotSegments(target.path);\n                }\n                target.query = relative.query;\n            }\n            //target.authority = base.authority;\n            target.userinfo = base.userinfo;\n            target.host = base.host;\n            target.port = base.port;\n        }\n        target.scheme = base.scheme;\n    }\n    target.fragment = relative.fragment;\n    return target;\n}\n\nfunction resolve(baseURI, relativeURI, options) {\n    var schemelessOptions = assign({ scheme: 'null' }, options);\n    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n}\n\nfunction normalize(uri, options) {\n    if (typeof uri === \"string\") {\n        uri = serialize(parse(uri, options), options);\n    } else if (typeOf(uri) === \"object\") {\n        uri = parse(serialize(uri, options), options);\n    }\n    return uri;\n}\n\nfunction equal(uriA, uriB, options) {\n    if (typeof uriA === \"string\") {\n        uriA = serialize(parse(uriA, options), options);\n    } else if (typeOf(uriA) === \"object\") {\n        uriA = serialize(uriA, options);\n    }\n    if (typeof uriB === \"string\") {\n        uriB = serialize(parse(uriB, options), options);\n    } else if (typeOf(uriB) === \"object\") {\n        uriB = serialize(uriB, options);\n    }\n    return uriA === uriB;\n}\n\nfunction escapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n}\n\nfunction unescapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n}\n\nvar handler = {\n    scheme: \"http\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        //report missing host\n        if (!components.host) {\n            components.error = components.error || \"HTTP URIs must have a host.\";\n        }\n        return components;\n    },\n    serialize: function serialize(components, options) {\n        var secure = String(components.scheme).toLowerCase() === \"https\";\n        //normalize the default port\n        if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n            components.port = undefined;\n        }\n        //normalize the empty path\n        if (!components.path) {\n            components.path = \"/\";\n        }\n        //NOTE: We do not parse query strings for HTTP URIs\n        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n        //and not the HTTP spec.\n        return components;\n    }\n};\n\nvar handler$1 = {\n    scheme: \"https\",\n    domainHost: handler.domainHost,\n    parse: handler.parse,\n    serialize: handler.serialize\n};\n\nfunction isSecure(wsComponents) {\n    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n//RFC 6455\nvar handler$2 = {\n    scheme: \"ws\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        var wsComponents = components;\n        //indicate if the secure flag is set\n        wsComponents.secure = isSecure(wsComponents);\n        //construct resouce name\n        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n        wsComponents.path = undefined;\n        wsComponents.query = undefined;\n        return wsComponents;\n    },\n    serialize: function serialize(wsComponents, options) {\n        //normalize the default port\n        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n            wsComponents.port = undefined;\n        }\n        //ensure scheme matches secure flag\n        if (typeof wsComponents.secure === 'boolean') {\n            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';\n            wsComponents.secure = undefined;\n        }\n        //reconstruct path from resource name\n        if (wsComponents.resourceName) {\n            var _wsComponents$resourc = wsComponents.resourceName.split('?'),\n                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),\n                path = _wsComponents$resourc2[0],\n                query = _wsComponents$resourc2[1];\n\n            wsComponents.path = path && path !== '/' ? path : undefined;\n            wsComponents.query = query;\n            wsComponents.resourceName = undefined;\n        }\n        //forbid fragment component\n        wsComponents.fragment = undefined;\n        return wsComponents;\n    }\n};\n\nvar handler$3 = {\n    scheme: \"wss\",\n    domainHost: handler$2.domainHost,\n    parse: handler$2.parse,\n    serialize: handler$2.serialize\n};\n\nvar O = {};\nvar isIRI = true;\n//RFC 3986\nvar UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nvar HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\nvar PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nvar ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nvar QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nvar VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nvar SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nvar UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nvar PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nvar NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nvar NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nvar NOT_HFVALUE = NOT_HFNAME;\nfunction decodeUnreserved(str) {\n    var decStr = pctDecChars(str);\n    return !decStr.match(UNRESERVED) ? str : decStr;\n}\nvar handler$4 = {\n    scheme: \"mailto\",\n    parse: function parse$$1(components, options) {\n        var mailtoComponents = components;\n        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n        mailtoComponents.path = undefined;\n        if (mailtoComponents.query) {\n            var unknownHeaders = false;\n            var headers = {};\n            var hfields = mailtoComponents.query.split(\"&\");\n            for (var x = 0, xl = hfields.length; x < xl; ++x) {\n                var hfield = hfields[x].split(\"=\");\n                switch (hfield[0]) {\n                    case \"to\":\n                        var toAddrs = hfield[1].split(\",\");\n                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {\n                            to.push(toAddrs[_x]);\n                        }\n                        break;\n                    case \"subject\":\n                        mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                        break;\n                    case \"body\":\n                        mailtoComponents.body = unescapeComponent(hfield[1], options);\n                        break;\n                    default:\n                        unknownHeaders = true;\n                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                        break;\n                }\n            }\n            if (unknownHeaders) mailtoComponents.headers = headers;\n        }\n        mailtoComponents.query = undefined;\n        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {\n            var addr = to[_x2].split(\"@\");\n            addr[0] = unescapeComponent(addr[0]);\n            if (!options.unicodeSupport) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n                } catch (e) {\n                    mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            } else {\n                addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n            }\n            to[_x2] = addr.join(\"@\");\n        }\n        return mailtoComponents;\n    },\n    serialize: function serialize$$1(mailtoComponents, options) {\n        var components = mailtoComponents;\n        var to = toArray(mailtoComponents.to);\n        if (to) {\n            for (var x = 0, xl = to.length; x < xl; ++x) {\n                var toAddr = String(to[x]);\n                var atIdx = toAddr.lastIndexOf(\"@\");\n                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n                var domain = toAddr.slice(atIdx + 1);\n                //convert IDN via punycode\n                try {\n                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n                } catch (e) {\n                    components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n                to[x] = localPart + \"@\" + domain;\n            }\n            components.path = to.join(\",\");\n        }\n        var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n        if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n        if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n        var fields = [];\n        for (var name in headers) {\n            if (headers[name] !== O[name]) {\n                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n            }\n        }\n        if (fields.length) {\n            components.query = fields.join(\"&\");\n        }\n        return components;\n    }\n};\n\nvar URN_PARSE = /^([^\\:]+)\\:(.*)/;\n//RFC 2141\nvar handler$5 = {\n    scheme: \"urn\",\n    parse: function parse$$1(components, options) {\n        var matches = components.path && components.path.match(URN_PARSE);\n        var urnComponents = components;\n        if (matches) {\n            var scheme = options.scheme || urnComponents.scheme || \"urn\";\n            var nid = matches[1].toLowerCase();\n            var nss = matches[2];\n            var urnScheme = scheme + \":\" + (options.nid || nid);\n            var schemeHandler = SCHEMES[urnScheme];\n            urnComponents.nid = nid;\n            urnComponents.nss = nss;\n            urnComponents.path = undefined;\n            if (schemeHandler) {\n                urnComponents = schemeHandler.parse(urnComponents, options);\n            }\n        } else {\n            urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n        }\n        return urnComponents;\n    },\n    serialize: function serialize$$1(urnComponents, options) {\n        var scheme = options.scheme || urnComponents.scheme || \"urn\";\n        var nid = urnComponents.nid;\n        var urnScheme = scheme + \":\" + (options.nid || nid);\n        var schemeHandler = SCHEMES[urnScheme];\n        if (schemeHandler) {\n            urnComponents = schemeHandler.serialize(urnComponents, options);\n        }\n        var uriComponents = urnComponents;\n        var nss = urnComponents.nss;\n        uriComponents.path = (nid || options.nid) + \":\" + nss;\n        return uriComponents;\n    }\n};\n\nvar UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n//RFC 4122\nvar handler$6 = {\n    scheme: \"urn:uuid\",\n    parse: function parse(urnComponents, options) {\n        var uuidComponents = urnComponents;\n        uuidComponents.uuid = uuidComponents.nss;\n        uuidComponents.nss = undefined;\n        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n            uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n        }\n        return uuidComponents;\n    },\n    serialize: function serialize(uuidComponents, options) {\n        var urnComponents = uuidComponents;\n        //normalize UUID\n        urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n        return urnComponents;\n    }\n};\n\nSCHEMES[handler.scheme] = handler;\nSCHEMES[handler$1.scheme] = handler$1;\nSCHEMES[handler$2.scheme] = handler$2;\nSCHEMES[handler$3.scheme] = handler$3;\nSCHEMES[handler$4.scheme] = handler$4;\nSCHEMES[handler$5.scheme] = handler$5;\nSCHEMES[handler$6.scheme] = handler$6;\n\nexports.SCHEMES = SCHEMES;\nexports.pctEncChar = pctEncChar;\nexports.pctDecChars = pctDecChars;\nexports.parse = parse;\nexports.removeDotSegments = removeDotSegments;\nexports.serialize = serialize;\nexports.resolveComponents = resolveComponents;\nexports.resolve = resolve;\nexports.normalize = normalize;\nexports.equal = equal;\nexports.escapeComponent = escapeComponent;\nexports.unescapeComponent = unescapeComponent;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=uri.all.js.map\n"],"names":["queueMicrotask","dp_resolve","Promise","resolve","fk","then","catch","e_callback","setTimeout","e_define","uri","string_decoder","stream","factory","quad","k","_kt_subject","_kt_predicate","_kt_object","_kt_graph","RT_PREFIXED_NAME_NAMESPACE_VALID","RT_PREFIXED_NAME_LOCAL_NAME_VALID","RT_BLANK_NODE_VALID","RT_NAMED_NODE_VALID","RT_NAMED_NODE_ESCAPELESS_VALID","R_UNICODE_ANY","F_REPLACE_UNICODE_ANY","s_","s_4","s_8","String","fromCodePoint","parseInt","OPHOP","Object","prototype","hasOwnProperty","R_PREFIXED_NAME_QUICK","R_PREFIXED_NAME_ESCAPELESS","R_PREFIXED_NAME","R_PN_LOCAL_ESCAPES","R_BLANK_NODE_LABEL","R_BLANK_NODE_LABEL_TERMINAL","R_IRIREF_ESCAPELESS","R_IRIREF","R_NUMERIC_LITERAL","R_BOOLEAN_LITERAL","R_A","R_DOUBLE_CARET","R_WS","R_LANGTAG","R_PREFIX_KEYWORD","R_PREFIX_ID","R_BASE_KEYWORD","R_GRAPH_IRI_ESCAPELESS","R_GRAPH_PREFIXED_NAME","R_GRAPH_LABELED_BLANK_NODE","R_GRAPH_ANONYMOUS_BLANK_NODE","R_GRAPH_IRI","R_GRAPH","R_COMMENT","RT_IRI_ABSOLUTE","R_BASE_IRI","R_ANONYMOUS_BLANK_NODE","R_CHAR_BLANK_NODE","R_CHAR_COLLECTION","R_CHAR_KET","R_CHAR_OPEN","R_CHAR_CLOSE","R_CHAR_STOP","R_STRLIT_SHORT_DOUBLE_BREAK","R_STRLIT_SHORT_SINGLE_BREAK","R_STRLIT_LONG_DOUBLE_UNFINISHED_TERM","R_STRLIT_LONG_SINGLE_UNFINISHED_TERM","R_STRLIT_LONG_DOUBLE_BREAK","R_STRLIT_LONG_SINGLE_BREAK","F_REPLACE_STRLIT_CONTENTS","s_whitespace","s_auto","s_invalid","console","assert","Error","JSON","stringify","R_STRLIT_SHORT_CONTENTS_ESCAPES_HARD","R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT","unescape_literal_short_hard","s_literal","replace","unescape_literal_short_soft","m_incomplete","R_STRLIT_ESCAPE_INCOMPLETE","exec","i_safe","index","slice","R_STRLIT_LONG_CONTENTS_ESCAPES_HARD","R_STRLIT_LONG_CONTENTS_ESCAPES_SOFT","unescape_literal_long_hard","unescape_literal_long_soft","R_STRLIT_SHORT_DOUBLE_TERM","R_STRLIT_SHORT_SINGLE_TERM","R_STRLIT_LONG_DOUBLE_TERM","R_STRLIT_LONG_SINGLE_TERM","RegExp_$lookbehind_polyfill","s_input","m_match","RegExp","call","this","i_start","length","mk_lookbehind_regex","e_compile","f_lookbehind","r_polyfill","f_polyfill","match_prefixed_name_escapeless","s","i","lastIndex","match_prefixed_name","Reader$syntax_error","k_self","si_state","s_info","i_off","Math","min","abs","error","substr","repeat","TriG_Reader","Transform","constructor","g_impls","super","decodeStrings","writableObjectMode","readableObjectMode","flush","transform","pipe","ds_out","ds_dst","_writableState","objectMode","isGraphyWritable","quads_to_writable","quads_to_json","Reader","g_config","input","g_input","state","g_state","blank_node_index","i_anon","prefixes","h_prefixes","labels","h_labels","dc_factory","adopt","dataFactory","data_factory","unfiltered","kt_default_graph","defaultGraph","create","kt_rdf_first","namedNode","blankNode","emit_data","ds_transform","push","g_quad","assign","n","pre","prepend","_b_debug","debug","_b_relax","relax","_dc_factory","_f_state","block","_h_prefixes","_b_destroyed","_s_base_url","_s_base_url_scheme","_s_base_url_root","_s_base_url_path","_s_literal","_kt_rdf_type","_kt_rdf_first","_kt_rdf_rest","_kt_rdf_nil","_kt_default_graph","_a_nested","_h_labels","event","emit","data","restore_data","_a_queue_event","_b_expecting_full_stop","_s_temp_prefix_id","_b_trim_start","anonymous_blank_node","s_label","next_label","eos","after_end_of_statement","post_object","_n_max_token_length","max_token_length","maxTokenLength","_n_max_string_length","max_string_length","maxStringLength","Infinity","_b_byte_tracking","byte_tracking","byteTracking","_nb_seen","_nb_last","_nb_curr","relaxed","warn","stack","blank_node","z_label_state","check_named_node","check_named_node_escapeless","test","p_iri","match_prefixed_name_quick","m_prefixed_name_e","im_prefixed_name_e","m_prefixed_name","im_prefixed_name","named_node","prefixed_name","si_prefix","s_suffix","base","TypeError","p_set_base_uri","base_uri","baseUri","baseURI","base_iri","baseIri","baseIRI","m_base_iri","base_url","baseUrl","baseURL","s_chunk","s_encoding","fke_chunk","safe_parse","fke_flush","eof","e_eof","destroy","on","ds_input","_ds_input","b_byte_tracking","setEncoding","f_write","write","d_decoder","StringDecoder","f_write_track","fk_write","nb_chunk","Buffer","from","f_decode_write_track","ab_chunk","f_decode_write","z_chunk","nb_post","ib_post","byteRange","s_event","emit_comments","s_captured","a_comments","split","s_comment","_destroy","a_args","bind","string","end","f_sync","apply","e_read","queue","args","s_message","parse_error","s_expected","b_eof","info_error","a_queue","h_event","shift","name","m_comment","prefix","enter","exit","comment","read","once","progress","finish","post_blank_subject","statement","equals","pairs","m_pnq_subject","s_prefix_id","m_iriref_e_subject","s_iri","aw_valid_this_match_prefixed_name_escapeless","m_prefixed_named_e_subject","im_prefixed_named_e_subject","m_blank_node_label_subject","collection_subject","m_iriref_subject","aw_valid_this_match_prefixed_name","m_prefixed_named_subject","im_prefixed_named_subject","m_graph_iriref_e_graph","m_graph_prefixed_name","m_graph_anonymous_blank_node","m_graph_labeled_blank_node","m_iriref_e_graph_subject","graph_or_subject","graph_or_subject_property_list","m_prefix_keyword","prefix_id","m_base_keyword","m_graph_iriref_graph","graph_keyword","x","graph_or_subject_anon","pop","m_prefixed_named_e_graph","im_prefixed_named_e_graph","graph_post_name","m_iriref_e_graph","m_blank_node_label_graph","m_iriref_graph","m_prefixed_named_graph","im_prefixed_named_graph","m_iriref_e_predicate","object_list","m_prefixed_named_e_predicate","im_prefixed_named_e_predicate","s_resume_state","m_iriref_predicate","m_prefixed_named_predicate","im_prefixed_named_predicate","string_literal_long_double","string_literal_short_double","m_pnq_object","m_iriref_e_object","m_prefixed_named_e_object","im_prefixed_named_e_object","string_literal_long_single","string_literal_short_single","m_numeric_literal","double","decimal","integer","m_boolean_literal","boolean","kt_blank_node","m_blank_node_label_object","collection_object","m_iriref_object","m_prefixed_named_object","im_prefixed_named_object","m_break","i_break","datatype_or_langtag","m_term","i_term","s_dirty","s_clean","s_incomplete","m_unfinished","string_literal","datatype","m_langtag","languagedLiteral","simpleLiteral","kt_datatype","m_pnq_datatype","m_iriref_e_datatype","p_datatype","m_prefixed_named_e_datatype","im_prefixed_named_e_datatype","m_iriref_datatype","m_prefixed_named_datatype","im_prefixed_named_datatype","datatypedLiteral","i_reset","s_peek","m_iriref_e_base","full_stop","m_iriref_base","m_prefix_id","prefix_iri","p_prefix_iri","m_iriref_e_prefix","b_relax","prefix_change","m_iriref_prefix","s_pointer_label","b_pushed","kt_blank_node_outer","w_object","a_recent","e_destroy","demolish","module","exports","z_arg_0","pipeTo","toString","Readable","gc_readable","iterator","until","b_return_stream","fk_until","fe_until","e_stream","bucket","g_readable","_readableState","fk_bucket","fe_bucket","a_data","Writable","w_event","s_write_encoding","writev","a_chunks","fk_writev","s_data","join","ab_data","concat","import","ds_source","w_chunk","Duplex","getPrototypeOf","b_is_node","Function","B_BROWSER","B_BROWSERIFY","process","browser","versions","node","version","fke_destroy","destroyed","f_emit_close","emitClose","e_destroy_re","nextTick","errorEmitted","QuadsToOther","gc_transform","_as_inputs","Set","ds_src","add","delete","Quads_To_JSON_Transform","_transform","fk_transform","isolate","Quads_To_Writable","type","value","source","w_push","isBuffer","global","merge","_len","arguments","sets","Array","_key","xl","subexp","str","typeOf","o","undefined","toLowerCase","toUpperCase","toArray","obj","setInterval","target","key","buildExps","isIRI","ALPHA$$","DIGIT$$","HEXDIG$$","PCT_ENCODED$","GEN_DELIMS$$","SUB_DELIMS$$","RESERVED$$","UCSCHAR$$","IPRIVATE$$","UNRESERVED$$","SCHEME$","USERINFO$","DEC_OCTET_RELAXED$","IPV4ADDRESS$","H16$","LS32$","IPV6ADDRESS1$","IPV6ADDRESS2$","IPV6ADDRESS3$","IPV6ADDRESS4$","IPV6ADDRESS5$","IPV6ADDRESS6$","IPV6ADDRESS7$","IPV6ADDRESS8$","IPV6ADDRESS9$","IPV6ADDRESS$","ZONEID$","IPV6ADDRZ_RELAXED$","IPVFUTURE$","IP_LITERAL$","REG_NAME$","HOST$","PORT$","AUTHORITY$","PCHAR$","SEGMENT$","SEGMENT_NZ$","SEGMENT_NZ_NC$","PATH_ABEMPTY$","PATH_ABSOLUTE$","PATH_NOSCHEME$","PATH_ROOTLESS$","PATH_EMPTY$","QUERY$","FRAGMENT$","HIER_PART$","URI$","RELATIVE_PART$","RELATIVE$","NOT_SCHEME","NOT_USERINFO","NOT_HOST","NOT_PATH","NOT_PATH_NOSCHEME","NOT_QUERY","NOT_FRAGMENT","ESCAPE","UNRESERVED","OTHER_CHARS","PCT_ENCODED","IPV4ADDRESS","IPV6ADDRESS","URI_PROTOCOL","IRI_PROTOCOL","slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","next","done","err","isArray","toConsumableArray","arr2","maxInt","tMin","tMax","skew","damp","initialBias","initialN","delimiter","regexPunycode","regexNonASCII","regexSeparators","errors","baseMinusTMin","floor","stringFromCharCode","fromCharCode","error$1","RangeError","map","array","fn","result","mapDomain","parts","encoded","ucs2decode","output","counter","charCodeAt","extra","ucs2encode","basicToDigit","codePoint","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","decode","inputLength","bias","basic","lastIndexOf","j","oldi","w","t","baseMinusT","out","splice","encode","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","_currentValue2","return","basicLength","handledCPCount","m","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","currentValue","handledCPCountPlusOne","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_currentValue","q","qMinusT","toUnicode","toASCII","punycode","SCHEMES","pctEncChar","chr","c","e","pctDecChars","newStr","il","c2","_c","c3","_normalizeComponentEncoding","components","protocol","decodeUnreserved","decStr","match","scheme","userinfo","host","path","query","fragment","_stripLeadingZeros","_normalizeIPv4","matches","_matches","address","_normalizeIPv6","_matches2","zone","_address$toLowerCase$","reverse","_address$toLowerCase$2","last","first","firstFields","lastFields","isLastFieldIPv4Address","fieldCount","lastFieldsStart","fields","allZeroFields","reduce","acc","field","lastLongest","longestZeroFields","sort","a","b","newHost","newFirst","newLast","URI_PARSE","NO_MATCH_IS_UNDEFINED","parse","uriString","options","iri","reference","port","isNaN","indexOf","schemeHandler","unicodeSupport","domainHost","_recomposeAuthority","uriTokens","_","$1","$2","RDS1","RDS2","RDS3","RDS5","removeDotSegments","im","serialize","authority","charAt","absolutePath","resolveComponents","relative","skipNormalization","tolerant","relativeURI","schemelessOptions","normalize","equal","uriA","uriB","escapeComponent","unescapeComponent","handler","secure","handler$1","isSecure","wsComponents","handler$2","resourceName","_wsComponents$resourc","_wsComponents$resourc2","handler$3","O","ATEXT$$","QTEXT$$","VCHAR$$","SOME_DELIMS$$","NOT_LOCAL_PART","NOT_HFNAME","NOT_HFVALUE","handler$4","mailtoComponents","to","unknownHeaders","headers","hfields","hfield","toAddrs","_x","_xl","subject","body","_x2","_xl2","addr","toAddr","atIdx","localPart","domain","URN_PARSE","handler$5","urnComponents","nid","nss","urnScheme","uriComponents","UUID","handler$6","uuidComponents","uuid","defineProperty"],"sourceRoot":""}