{"version":3,"file":"js/844.ef8908ec.js","mappings":"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","sources":["webpack://@zazuko/spex/./node_modules/canonicalize/lib/canonicalize.js","webpack://@zazuko/spex/./node_modules/cross-fetch/dist/browser-polyfill.js","webpack://@zazuko/spex/./node_modules/http-link-header/lib/link.js","webpack://@zazuko/spex/./node_modules/jsonld-context-parser/index.js","webpack://@zazuko/spex/./node_modules/jsonld-context-parser/lib/ContextParser.js","webpack://@zazuko/spex/./node_modules/jsonld-context-parser/lib/ErrorCoded.js","webpack://@zazuko/spex/./node_modules/jsonld-context-parser/lib/FetchDocumentLoader.js","webpack://@zazuko/spex/./node_modules/jsonld-context-parser/lib/IDocumentLoader.js","webpack://@zazuko/spex/./node_modules/jsonld-context-parser/lib/JsonLdContext.js","webpack://@zazuko/spex/./node_modules/jsonld-context-parser/lib/JsonLdContextNormalized.js","webpack://@zazuko/spex/./node_modules/jsonld-context-parser/lib/Util.js","webpack://@zazuko/spex/./node_modules/rdf-data-factory/index.js","webpack://@zazuko/spex/./node_modules/rdf-data-factory/lib/BlankNode.js","webpack://@zazuko/spex/./node_modules/rdf-data-factory/lib/DataFactory.js","webpack://@zazuko/spex/./node_modules/rdf-data-factory/lib/DefaultGraph.js","webpack://@zazuko/spex/./node_modules/rdf-data-factory/lib/Literal.js","webpack://@zazuko/spex/./node_modules/rdf-data-factory/lib/NamedNode.js","webpack://@zazuko/spex/./node_modules/rdf-data-factory/lib/Quad.js","webpack://@zazuko/spex/./node_modules/rdf-data-factory/lib/Variable.js","webpack://@zazuko/spex/./node_modules/relative-to-absolute-iri/index.js","webpack://@zazuko/spex/./node_modules/relative-to-absolute-iri/lib/Resolve.js"],"sourcesContent":["/* jshint esversion: 6 */\n/* jslint node: true */\n'use strict';\n\nmodule.exports = function serialize (object) {\n  if (object === null || typeof object !== 'object' || object.toJSON != null) {\n    return JSON.stringify(object);\n  }\n\n  if (Array.isArray(object)) {\n    return '[' + object.reduce((t, cv, ci) => {\n      const comma = ci === 0 ? '' : ',';\n      const value = cv === undefined || typeof cv === 'symbol' ? null : cv;\n      return t + comma + serialize(value);\n    }, '') + ']';\n  }\n\n  return '{' + Object.keys(object).sort().reduce((t, cv, ci) => {\n    if (object[cv] === undefined ||\n        typeof object[cv] === 'symbol') {\n      return t;\n    }\n    const comma = t.length === 0 ? '' : ',';\n    return t + comma + serialize(cv) + ':' + serialize(object[cv]);\n  }, '') + '}';\n};\n","(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n})({});\n})(typeof self !== 'undefined' ? self : this);\n","'use strict'\n\nvar COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i\nvar WS_TRIM_PATTERN = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g\nvar WS_CHAR_PATTERN = /\\s|\\uFEFF|\\xA0/\nvar WS_FOLD_PATTERN = /\\r?\\n[\\x20\\x09]+/g\nvar DELIMITER_PATTERN = /[;,\"]/\nvar WS_DELIMITER_PATTERN = /[;,\"]|\\s/\n\n/**\n * Token character pattern\n * @type {RegExp}\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\nvar TOKEN_PATTERN = /^[!#$%&'*+\\-\\.^_`|~\\da-zA-Z]+$/\n\nvar STATE = {\n  IDLE: 1 << 0,\n  URI: 1 << 1,\n  ATTR: 1 << 2,\n}\n\nfunction trim( value ) {\n  return value.replace( WS_TRIM_PATTERN, '' )\n}\n\nfunction hasWhitespace( value ) {\n  return WS_CHAR_PATTERN.test( value )\n}\n\nfunction skipWhitespace( value, offset ) {\n  while( hasWhitespace( value[offset] ) ) {\n    offset++\n  }\n  return offset\n}\n\nfunction needsQuotes( value ) {\n  return WS_DELIMITER_PATTERN.test( value ) ||\n    !TOKEN_PATTERN.test( value )\n}\n\n/**\n * Shallow compares two objects to check if their properties match.\n * @param {object} object1 First object to compare.\n * @param {object} object2 Second object to compare.\n * @returns {boolean} Do the objects have matching properties.\n */\nfunction shallowCompareObjects( object1, object2 ) {\n  return (\n    Object.keys( object1 ).length === Object.keys( object2 ).length &&\n    Object.keys( object1 ).every(\n      ( key ) => key in object2 && object1[ key ] === object2[ key ]\n    )\n  );\n}\n\nclass Link {\n\n  /**\n   * Link\n   * @constructor\n   * @param {String} [value]\n   * @returns {Link}\n   */\n  constructor( value ) {\n\n    /** @type {Array} URI references */\n    this.refs = []\n\n    if( value ) {\n      this.parse( value )\n    }\n\n  }\n\n  /**\n   * Get refs with given relation type\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  rel( value ) {\n\n    var links = []\n    var type = value.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ].rel.toLowerCase() === type ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /**\n   * Get refs where given attribute has a given value\n   * @param {String} attr\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  get( attr, value ) {\n\n    attr = attr.toLowerCase()\n\n    var links = []\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ][ attr ] === value ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /** Sets a reference. */\n  set( link ) {\n    this.refs.push( link )\n    return this\n  }\n\n  /**\n   * Sets a reference if a reference with similar properties isnt already set.\n   */\n  setUnique( link ) {\n\n    if( !this.refs.some(( ref ) => shallowCompareObjects( ref, link )) ) {\n      this.refs.push( link )\n    }\n\n    return this\n\n  }\n\n  has( attr, value ) {\n\n    attr = attr.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ][ attr ] === value ) {\n        return true\n      }\n    }\n\n    return false\n\n  }\n\n  parse( value, offset ) {\n\n    offset = offset || 0\n    value = offset ? value.slice( offset ) : value\n\n    // Trim & unfold folded lines\n    value = trim( value ).replace( WS_FOLD_PATTERN, '' )\n\n    var state = STATE.IDLE\n    var length = value.length\n    var offset = 0\n    var ref = null\n\n    while( offset < length ) {\n      if( state === STATE.IDLE ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === '<' ) {\n          if( ref != null ) {\n            ref.rel != null ?\n              this.refs.push( ...Link.expandRelations( ref ) ) :\n              this.refs.push( ref )\n          }\n          var end = value.indexOf( '>', offset )\n          if( end === -1 ) throw new Error( 'Expected end of URI delimiter at offset ' + offset )\n          ref = { uri: value.slice( offset + 1, end ) }\n          // this.refs.push( ref )\n          offset = end\n          state = STATE.URI\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n        offset++\n      } else if( state === STATE.URI ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === ';' ) {\n          state = STATE.ATTR\n          offset++\n        } else if( value[offset] === ',' ) {\n          state = STATE.IDLE\n          offset++\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n      } else if( state === STATE.ATTR ) {\n        if( value[offset] ===';' || hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        }\n        var end = value.indexOf( '=', offset )\n        if( end === -1 ) end = value.indexOf( ';', offset )\n        if( end === -1 ) end = value.length\n        var attr = trim( value.slice( offset, end ) ).toLowerCase()\n        var attrValue = ''\n        offset = end + 1\n        offset = skipWhitespace( value, offset )\n        if( value[offset] === '\"' ) {\n          offset++\n          while( offset < length ) {\n            if( value[offset] === '\"' ) {\n              offset++; break\n            }\n            if( value[offset] === '\\\\' ) {\n              offset++\n            }\n            attrValue += value[offset]\n            offset++\n          }\n        } else {\n          var end = offset + 1\n          while( !DELIMITER_PATTERN.test( value[end] ) && end < length ) {\n            end++\n          }\n          attrValue = value.slice( offset, end )\n          offset = end\n        }\n        if( ref[ attr ] && Link.isSingleOccurenceAttr( attr ) ) {\n          // Ignore multiples of attributes which may only appear once\n        } else if( attr[ attr.length - 1 ] === '*' ) {\n          ref[ attr ] = Link.parseExtendedValue( attrValue )\n        } else {\n          attrValue = attr === 'type' ?\n            attrValue.toLowerCase() : attrValue\n          if( ref[ attr ] != null ) {\n            if( Array.isArray( ref[ attr ] ) ) {\n              ref[ attr ].push( attrValue )\n            } else {\n              ref[ attr ] = [ ref[ attr ], attrValue ]\n            }\n          } else {\n            ref[ attr ] = attrValue\n          }\n        }\n        switch( value[offset] ) {\n          case ',': state = STATE.IDLE; break\n          case ';': state = STATE.ATTR; break\n        }\n        offset++\n      } else {\n        throw new Error( 'Unknown parser state \"' + state + '\"' )\n      }\n    }\n\n    if( ref != null ) {\n      ref.rel != null ?\n        this.refs.push( ...Link.expandRelations( ref ) ) :\n        this.refs.push( ref )\n    }\n\n    ref = null\n\n    return this\n\n  }\n\n  toString() {\n\n    var refs = []\n    var link = ''\n    var ref = null\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      ref = this.refs[i]\n      link = Object.keys( this.refs[i] ).reduce( function( link, attr ) {\n        if( attr === 'uri' ) return link\n        return link + '; ' + Link.formatAttribute( attr, ref[ attr ] )\n      }, '<' + ref.uri + '>' )\n      refs.push( link )\n    }\n\n    return refs.join( ', ' )\n\n  }\n\n}\n\n/**\n * Determines whether an encoding can be\n * natively handled with a `Buffer`\n * @param {String} value\n * @returns {Boolean}\n */\nLink.isCompatibleEncoding = function( value ) {\n  return COMPATIBLE_ENCODING_PATTERN.test( value )\n}\n\nLink.parse = function( value, offset ) {\n  return new Link().parse( value, offset )\n}\n\nLink.isSingleOccurenceAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'media' ||\n    attr === 'title' || attr === 'title*'\n}\n\nLink.isTokenAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'anchor'\n}\n\nLink.escapeQuotes = function( value ) {\n  return value.replace( /\"/g, '\\\\\"' )\n}\n\nLink.expandRelations = function( ref ) {\n  var rels = ref.rel.split( ' ' )\n  return rels.map( function( rel ) {\n    var value = Object.assign( {}, ref )\n    value.rel = rel\n    return value\n  })\n}\n\n/**\n * Parses an extended value and attempts to decode it\n * @internal\n * @param {String} value\n * @return {Object}\n */\nLink.parseExtendedValue = function( value ) {\n  var parts = /([^']+)?(?:'([^']*)')?(.+)/.exec( value )\n  return {\n    language: parts[2].toLowerCase(),\n    encoding: Link.isCompatibleEncoding( parts[1] ) ?\n      null : parts[1].toLowerCase(),\n    value: Link.isCompatibleEncoding( parts[1] ) ?\n      decodeURIComponent( parts[3] ) : parts[3]\n  }\n}\n\n/**\n * Format a given extended attribute and it's value\n * @param {String} attr\n * @param {Object} data\n * @return {String}\n */\nLink.formatExtendedAttribute = function( attr, data ) {\n\n  var encoding = ( data.encoding || 'utf-8' ).toUpperCase()\n  var language = data.language || 'en'\n\n  var encodedValue = ''\n\n  if( Buffer.isBuffer( data.value ) && Link.isCompatibleEncoding( encoding ) ) {\n    encodedValue = data.value.toString( encoding )\n  } else if( Buffer.isBuffer( data.value ) ) {\n    encodedValue = data.value.toString( 'hex' )\n      .replace( /[0-9a-f]{2}/gi, '%$1' )\n  } else {\n    encodedValue = encodeURIComponent( data.value )\n  }\n\n  return attr + '=' + encoding + '\\'' +\n    language + '\\'' + encodedValue\n\n}\n\n/**\n * Format a given attribute and it's value\n * @param {String} attr\n * @param {String|Object} value\n * @return {String}\n */\nLink.formatAttribute = function( attr, value ) {\n\n  if( Array.isArray( value ) ) {\n    return value.map(( item ) => {\n      return Link.formatAttribute( attr, item )\n    }).join( '; ' )\n  }\n\n  if( attr[ attr.length - 1 ] === '*' || typeof value !== 'string' ) {\n    return Link.formatExtendedAttribute( attr, value )\n  }\n\n  if( Link.isTokenAttr( attr ) ) {\n    value = needsQuotes( value ) ?\n      '\"' + Link.escapeQuotes( value ) + '\"' :\n      Link.escapeQuotes( value )\n  } else if( needsQuotes( value ) ) {\n    value = encodeURIComponent( value )\n    // We don't need to escape <SP> <,> <;> within quotes\n    value = value\n      .replace( /%20/g, ' ' )\n      .replace( /%2C/g, ',' )\n      .replace( /%3B/g, ';' )\n\n    value = '\"' + value + '\"'\n  }\n\n  return attr + '=' + value\n\n}\n\nmodule.exports = Link\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/ContextParser\"), exports);\n__exportStar(require(\"./lib/ErrorCoded\"), exports);\n__exportStar(require(\"./lib/FetchDocumentLoader\"), exports);\n__exportStar(require(\"./lib/IDocumentLoader\"), exports);\n__exportStar(require(\"./lib/JsonLdContext\"), exports);\n__exportStar(require(\"./lib/JsonLdContextNormalized\"), exports);\n__exportStar(require(\"./lib/Util\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultExpandOptions = exports.ContextParser = void 0;\nrequire(\"cross-fetch/polyfill\");\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\nconst FetchDocumentLoader_1 = require(\"./FetchDocumentLoader\");\nconst JsonLdContextNormalized_1 = require(\"./JsonLdContextNormalized\");\nconst Util_1 = require(\"./Util\");\n// tslint:disable-next-line:no-var-requires\nconst canonicalizeJson = require('canonicalize');\n/**\n * Parses JSON-LD contexts.\n */\nclass ContextParser {\n    constructor(options) {\n        options = options || {};\n        this.documentLoader = options.documentLoader || new FetchDocumentLoader_1.FetchDocumentLoader();\n        this.documentCache = {};\n        this.validateContext = !options.skipValidation;\n        this.expandContentTypeToBase = !!options.expandContentTypeToBase;\n        this.remoteContextsDepthLimit = options.remoteContextsDepthLimit || 32;\n        this.redirectSchemaOrgHttps = 'redirectSchemaOrgHttps' in options ? !!options.redirectSchemaOrgHttps : true;\n    }\n    /**\n     * Validate the given @language value.\n     * An error will be thrown if it is invalid.\n     * @param value An @language value.\n     * @param {boolean} strictRange If the string value should be strictly checked against a regex.\n     * @param {string} errorCode The error code to emit on errors.\n     * @return {boolean} If validation passed.\n     *                   Can only be false if strictRange is false and the string value did not pass the regex.\n     */\n    static validateLanguage(value, strictRange, errorCode) {\n        if (typeof value !== 'string') {\n            throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a string, got '${JSON.stringify(value)}'`, errorCode);\n        }\n        if (!Util_1.Util.REGEX_LANGUAGE_TAG.test(value)) {\n            if (strictRange) {\n                throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a valid language tag, got '${JSON.stringify(value)}'`, errorCode);\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Validate the given @direction value.\n     * An error will be thrown if it is invalid.\n     * @param value An @direction value.\n     * @param {boolean} strictValues If the string value should be strictly checked against a regex.\n     * @return {boolean} If validation passed.\n     *                   Can only be false if strictRange is false and the string value did not pass the regex.\n     */\n    static validateDirection(value, strictValues) {\n        if (typeof value !== 'string') {\n            throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be a string, got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);\n        }\n        if (!Util_1.Util.REGEX_DIRECTION_TAG.test(value)) {\n            if (strictValues) {\n                throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be 'ltr' or 'rtl', got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Add an @id term for all @reverse terms.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @return {IJsonLdContextNormalizedRaw} The mutated input context.\n     */\n    idifyReverseTerms(context) {\n        for (const key of Object.keys(context)) {\n            const value = context[key];\n            if (value && typeof value === 'object') {\n                if (value['@reverse'] && !value['@id']) {\n                    if (typeof value['@reverse'] !== 'string' || Util_1.Util.isValidKeyword(value['@reverse'])) {\n                        throw new ErrorCoded_1.ErrorCoded(`Invalid @reverse value, must be absolute IRI or blank node: '${value['@reverse']}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                    }\n                    value['@id'] = value['@reverse'];\n                    if (Util_1.Util.isPotentialKeyword(value['@reverse'])) {\n                        delete value['@reverse'];\n                    }\n                    else {\n                        value['@reverse'] = true;\n                    }\n                }\n            }\n        }\n        return context;\n    }\n    /**\n     * Expand all prefixed terms in the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {boolean} expandContentTypeToBase If @type inside the context may be expanded\n     *                                          via @base if @vocab is set to null.\n     */\n    expandPrefixedTerms(context, expandContentTypeToBase) {\n        const contextRaw = context.getContextRaw();\n        for (const key of Object.keys(contextRaw)) {\n            // Only expand allowed keys\n            if (Util_1.Util.EXPAND_KEYS_BLACKLIST.indexOf(key) < 0 && !Util_1.Util.isReservedInternalKeyword(key)) {\n                // Error if we try to alias a keyword to something else.\n                const keyValue = contextRaw[key];\n                if (Util_1.Util.isPotentialKeyword(key) && Util_1.Util.ALIAS_DOMAIN_BLACKLIST.indexOf(key) >= 0) {\n                    if (key !== '@type' || typeof contextRaw[key] === 'object'\n                        && !(contextRaw[key]['@protected'] || contextRaw[key]['@container'] === '@set')) {\n                        throw new ErrorCoded_1.ErrorCoded(`Keywords can not be aliased to something else.\nTried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);\n                    }\n                }\n                // Error if we try to alias to an illegal keyword\n                if (Util_1.Util.ALIAS_RANGE_BLACKLIST.indexOf(Util_1.Util.getContextValueId(keyValue)) >= 0) {\n                    throw new ErrorCoded_1.ErrorCoded(`Aliasing to certain keywords is not allowed.\nTried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.INVALID_KEYWORD_ALIAS);\n                }\n                // Error if this term was marked as prefix as well\n                if (keyValue && Util_1.Util.isPotentialKeyword(Util_1.Util.getContextValueId(keyValue))\n                    && keyValue['@prefix'] === true) {\n                    throw new ErrorCoded_1.ErrorCoded(`Tried to use keyword aliases as prefix: '${key}': '${JSON.stringify(keyValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n                // Loop because prefixes might be nested\n                while (Util_1.Util.isPrefixValue(contextRaw[key])) {\n                    const value = contextRaw[key];\n                    let changed = false;\n                    if (typeof value === 'string') {\n                        contextRaw[key] = context.expandTerm(value, true);\n                        changed = changed || value !== contextRaw[key];\n                    }\n                    else {\n                        const id = value['@id'];\n                        const type = value['@type'];\n                        // If @id is missing, don't allow @id to be added if @prefix: true and key not being a valid IRI.\n                        const canAddIdEntry = !('@prefix' in value) || Util_1.Util.isValidIri(key);\n                        if ('@id' in value) {\n                            // Use @id value for expansion\n                            if (id !== undefined && id !== null && typeof id === 'string') {\n                                contextRaw[key]['@id'] = context.expandTerm(id, true);\n                                changed = changed || id !== contextRaw[key]['@id'];\n                            }\n                        }\n                        else if (!Util_1.Util.isPotentialKeyword(key) && canAddIdEntry) {\n                            // Add an explicit @id value based on the expanded key value\n                            const newId = context.expandTerm(key, true);\n                            if (newId !== key) {\n                                // Don't set @id if expansion failed\n                                contextRaw[key]['@id'] = newId;\n                                changed = true;\n                            }\n                        }\n                        if (type && typeof type === 'string' && type !== '@vocab'\n                            && (!value['@container'] || !value['@container']['@type'])\n                            && canAddIdEntry) {\n                            // First check @vocab, then fallback to @base\n                            contextRaw[key]['@type'] = context.expandTerm(type, true);\n                            if (expandContentTypeToBase && type === contextRaw[key]['@type']) {\n                                contextRaw[key]['@type'] = context.expandTerm(type, false);\n                            }\n                            changed = changed || type !== contextRaw[key]['@type'];\n                        }\n                    }\n                    if (!changed) {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Normalize the @language entries in the given context to lowercase.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} parseOptions The parsing options.\n     */\n    normalize(context, { processingMode, normalizeLanguageTags }) {\n        // Lowercase language keys in 1.0\n        if (normalizeLanguageTags || processingMode === 1.0) {\n            for (const key of Object.keys(context)) {\n                if (key === '@language' && typeof context[key] === 'string') {\n                    context[key] = context[key].toLowerCase();\n                }\n                else {\n                    const value = context[key];\n                    if (value && typeof value === 'object') {\n                        if (typeof value['@language'] === 'string') {\n                            value['@language'] = value['@language'].toLowerCase();\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Convert all @container strings and array values to hash-based values.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     */\n    containersToHash(context) {\n        for (const key of Object.keys(context)) {\n            const value = context[key];\n            if (value && typeof value === 'object') {\n                if (typeof value['@container'] === 'string') {\n                    value['@container'] = { [value['@container']]: true };\n                }\n                else if (Array.isArray(value['@container'])) {\n                    const newValue = {};\n                    for (const containerValue of value['@container']) {\n                        newValue[containerValue] = true;\n                    }\n                    value['@container'] = newValue;\n                }\n            }\n        }\n    }\n    /**\n     * Normalize and apply context-levevl @protected terms onto each term separately.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {number} processingMode The processing mode.\n     */\n    applyScopedProtected(context, { processingMode }) {\n        if (processingMode && processingMode >= 1.1) {\n            if (context['@protected']) {\n                for (const key of Object.keys(context)) {\n                    if (Util_1.Util.isReservedInternalKeyword(key)) {\n                        continue;\n                    }\n                    if (!Util_1.Util.isPotentialKeyword(key) && !Util_1.Util.isTermProtected(context, key)) {\n                        const value = context[key];\n                        if (value && typeof value === 'object') {\n                            if (!('@protected' in context[key])) {\n                                // Mark terms with object values as protected if they don't have an @protected: false annotation\n                                context[key]['@protected'] = true;\n                            }\n                        }\n                        else {\n                            // Convert string-based term values to object-based values with @protected: true\n                            context[key] = {\n                                '@id': value,\n                                '@protected': true,\n                            };\n                        }\n                    }\n                }\n                delete context['@protected'];\n            }\n        }\n    }\n    /**\n     * Check if the given context inheritance does not contain any overrides of protected terms.\n     * @param {IJsonLdContextNormalizedRaw} contextBefore The context that may contain some protected terms.\n     * @param {IJsonLdContextNormalizedRaw} contextAfter A new context that is being applied on the first one.\n     * @param {IExpandOptions} expandOptions Options that are needed for any expansions during this validation.\n     */\n    validateKeywordRedefinitions(contextBefore, contextAfter, expandOptions) {\n        for (const key of Object.keys(contextAfter)) {\n            if (Util_1.Util.isTermProtected(contextBefore, key)) {\n                // The entry in the context before will always be in object-mode\n                // If the new entry is in string-mode, convert it to object-mode\n                // before checking if it is identical.\n                if (typeof contextAfter[key] === 'string') {\n                    const isPrefix = Util_1.Util.isSimpleTermDefinitionPrefix(contextAfter[key], expandOptions);\n                    contextAfter[key] = { '@id': contextAfter[key] };\n                    // If the simple term def was a prefix, explicitly mark the term as a prefix in the expanded term definition,\n                    // because otherwise we loose this information due to JSON-LD interpreting prefixes differently\n                    // in simple vs expanded term definitions.\n                    if (isPrefix) {\n                        contextAfter[key]['@prefix'] = true;\n                        contextBefore[key]['@prefix'] = true; // Also on before, to make sure the next step still considers them ==\n                    }\n                }\n                // Convert term values to strings for each comparison\n                const valueBefore = canonicalizeJson(contextBefore[key]);\n                // We modify this deliberately,\n                // as we need it for the value comparison (they must be identical modulo '@protected')),\n                // and for the fact that this new value will override the first one.\n                contextAfter[key]['@protected'] = true;\n                const valueAfter = canonicalizeJson(contextAfter[key]);\n                // Error if they are not identical\n                if (valueBefore !== valueAfter) {\n                    throw new ErrorCoded_1.ErrorCoded(`Attempted to override the protected keyword ${key} from ${JSON.stringify(Util_1.Util.getContextValueId(contextBefore[key]))} to ${JSON.stringify(Util_1.Util.getContextValueId(contextAfter[key]))}`, ErrorCoded_1.ERROR_CODES.PROTECTED_TERM_REDEFINITION);\n                }\n            }\n        }\n    }\n    /**\n     * Validate the entries of the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} options The parse options.\n     */\n    validate(context, { processingMode }) {\n        for (const key of Object.keys(context)) {\n            // Ignore reserved internal keywords.\n            if (Util_1.Util.isReservedInternalKeyword(key)) {\n                continue;\n            }\n            // Do not allow empty term\n            if (key === '') {\n                throw new ErrorCoded_1.ErrorCoded(`The empty term is not allowed, got: '${key}': '${JSON.stringify(context[key])}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n            }\n            const value = context[key];\n            const valueType = typeof value;\n            // First check if the key is a keyword\n            if (Util_1.Util.isPotentialKeyword(key)) {\n                switch (key.substr(1)) {\n                    case 'vocab':\n                        if (value !== null && valueType !== 'string') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @vocab IRI: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);\n                        }\n                        break;\n                    case 'base':\n                        if (value !== null && valueType !== 'string') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @base IRI: ${context[key]}`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_IRI);\n                        }\n                        break;\n                    case 'language':\n                        if (value !== null) {\n                            ContextParser.validateLanguage(value, true, ErrorCoded_1.ERROR_CODES.INVALID_DEFAULT_LANGUAGE);\n                        }\n                        break;\n                    case 'version':\n                        if (value !== null && valueType !== 'number') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @version number: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VERSION_VALUE);\n                        }\n                        break;\n                    case 'direction':\n                        if (value !== null) {\n                            ContextParser.validateDirection(value, true);\n                        }\n                        break;\n                    case 'propagate':\n                        if (processingMode === 1.0) {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an illegal @propagate keyword: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n                        }\n                        if (value !== null && valueType !== 'boolean') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @propagate value: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_PROPAGATE_VALUE);\n                        }\n                        break;\n                }\n                // Don't allow keywords to be overridden\n                if (Util_1.Util.isValidKeyword(key) && Util_1.Util.isValidKeyword(Util_1.Util.getContextValueId(value))) {\n                    throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${Util_1.Util\n                        .getContextValueId(value)}'`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);\n                }\n                continue;\n            }\n            // Otherwise, consider the key a term\n            if (value !== null) {\n                switch (valueType) {\n                    case 'string':\n                        if (Util_1.Util.getPrefix(value, context) === key) {\n                            throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON\n                                .stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);\n                        }\n                        if (Util_1.Util.isValidIriWeak(key)) {\n                            if (value === '@type') {\n                                throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                            }\n                            else if (Util_1.Util.isValidIri(value) && value !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {\n                                throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                            }\n                        }\n                        break;\n                    case 'object':\n                        if (!Util_1.Util.isCompactIri(key) && !('@id' in value)\n                            && (value['@type'] === '@id' ? !context['@base'] : !context['@vocab'])) {\n                            throw new ErrorCoded_1.ErrorCoded(`Missing @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                        }\n                        for (const objectKey of Object.keys(value)) {\n                            const objectValue = value[objectKey];\n                            if (!objectValue) {\n                                continue;\n                            }\n                            switch (objectKey) {\n                                case '@id':\n                                    if (Util_1.Util.isValidKeyword(objectValue)\n                                        && objectValue !== '@type' && objectValue !== '@id' && objectValue !== '@graph' && objectValue !== '@nest') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                    }\n                                    if (Util_1.Util.isValidIriWeak(key)) {\n                                        if (objectValue === '@type') {\n                                            throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                        }\n                                        else if (Util_1.Util.isValidIri(objectValue)\n                                            && objectValue !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {\n                                            throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                        }\n                                    }\n                                    if (typeof objectValue !== 'string') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Detected non-string @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                    }\n                                    if (Util_1.Util.getPrefix(objectValue, context) === key) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON\n                                            .stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);\n                                    }\n                                    break;\n                                case '@type':\n                                    if (value['@container'] === '@type' && objectValue !== '@id' && objectValue !== '@vocab') {\n                                        throw new ErrorCoded_1.ErrorCoded(`@container: @type only allows @type: @id or @vocab, but got: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    if (typeof objectValue !== 'string') {\n                                        throw new ErrorCoded_1.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(valueType)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    if (objectValue !== '@id' && objectValue !== '@vocab'\n                                        && (processingMode === 1.0 || objectValue !== '@json')\n                                        && (processingMode === 1.0 || objectValue !== '@none')\n                                        && (objectValue[0] === '_' || !Util_1.Util.isValidIri(objectValue))) {\n                                        throw new ErrorCoded_1.ErrorCoded(`A context @type must be an absolute IRI, found: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    break;\n                                case '@reverse':\n                                    if (typeof objectValue === 'string' && value['@id'] && value['@id'] !== objectValue) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found non-matching @id and @reverse term values in '${key}':\\\n'${objectValue}' and '${value['@id']}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                    }\n                                    if ('@nest' in value) {\n                                        throw new ErrorCoded_1.ErrorCoded(`@nest is not allowed in the reverse property '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                    }\n                                    break;\n                                case '@container':\n                                    if (processingMode === 1.0) {\n                                        if (Object.keys(objectValue).length > 1\n                                            || Util_1.Util.CONTAINERS_1_0.indexOf(Object.keys(objectValue)[0]) < 0) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${Object.keys(objectValue)}') in 1.0, \\\nmust be only one of ${Util_1.Util.CONTAINERS_1_0.join(', ')}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);\n                                        }\n                                    }\n                                    for (const containerValue of Object.keys(objectValue)) {\n                                        if (containerValue === '@list' && value['@reverse']) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Term value can not be @container: @list and @reverse at the same time on '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                        }\n                                        if (Util_1.Util.CONTAINERS.indexOf(containerValue) < 0) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${containerValue}'), \\\nmust be one of ${Util_1.Util.CONTAINERS.join(', ')}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);\n                                        }\n                                    }\n                                    break;\n                                case '@language':\n                                    ContextParser.validateLanguage(objectValue, true, ErrorCoded_1.ERROR_CODES.INVALID_LANGUAGE_MAPPING);\n                                    break;\n                                case '@direction':\n                                    ContextParser.validateDirection(objectValue, true);\n                                    break;\n                                case '@prefix':\n                                    if (objectValue !== null && typeof objectValue !== 'boolean') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @prefix boolean in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_PREFIX_VALUE);\n                                    }\n                                    if (!('@id' in value) && !Util_1.Util.isValidIri(key)) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Invalid @prefix definition for '${key}' ('${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                                    }\n                                    break;\n                                case '@index':\n                                    if (processingMode === 1.0 || !value['@container'] || !value['@container']['@index']) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Attempt to add illegal key to value object: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                                    }\n                                    break;\n                                case '@nest':\n                                    if (Util_1.Util.isPotentialKeyword(objectValue) && objectValue !== '@nest') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @nest value in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_NEST_VALUE);\n                                    }\n                            }\n                        }\n                        break;\n                    default:\n                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term value: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n            }\n        }\n    }\n    /**\n     * Apply the @base context entry to the given context under certain circumstances.\n     * @param context A context.\n     * @param options Parsing options.\n     * @param inheritFromParent If the @base value from the parent context can be inherited.\n     * @return The given context.\n     */\n    applyBaseEntry(context, options, inheritFromParent) {\n        // In some special cases, this can be a string, so ignore those.\n        if (typeof context === 'string') {\n            return context;\n        }\n        // Give priority to @base in the parent context\n        if (inheritFromParent && !('@base' in context) && options.parentContext\n            && typeof options.parentContext === 'object' && '@base' in options.parentContext) {\n            context['@base'] = options.parentContext['@base'];\n            if (options.parentContext['@__baseDocument']) {\n                context['@__baseDocument'] = true;\n            }\n        }\n        // Override the base IRI if provided.\n        if (options.baseIRI && !options.external) {\n            if (!('@base' in context)) {\n                // The context base is the document base\n                context['@base'] = options.baseIRI;\n                context['@__baseDocument'] = true;\n            }\n            else if (context['@base'] !== null && typeof context['@base'] === 'string'\n                && !Util_1.Util.isValidIri(context['@base'])) {\n                // The context base is relative to the document base\n                context['@base'] = (0, relative_to_absolute_iri_1.resolve)(context['@base'], options.parentContext && options.parentContext['@base'] || options.baseIRI);\n            }\n        }\n        return context;\n    }\n    /**\n     * Resolve relative context IRIs, or return full IRIs as-is.\n     * @param {string} contextIri A context IRI.\n     * @param {string} baseIRI A base IRI.\n     * @return {string} The normalized context IRI.\n     */\n    normalizeContextIri(contextIri, baseIRI) {\n        if (!Util_1.Util.isValidIri(contextIri)) {\n            try {\n                contextIri = (0, relative_to_absolute_iri_1.resolve)(contextIri, baseIRI);\n            }\n            catch (_a) {\n                throw new Error(`Invalid context IRI: ${contextIri}`);\n            }\n        }\n        // TODO: Temporary workaround for fixing schema.org CORS issues (https://github.com/schemaorg/schemaorg/issues/2578#issuecomment-652324465)\n        if (this.redirectSchemaOrgHttps && contextIri.startsWith('http://schema.org')) {\n            contextIri = 'https://schema.org/';\n        }\n        return contextIri;\n    }\n    /**\n     * Parse scoped contexts in the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} options Parsing options.\n     * @return {IJsonLdContextNormalizedRaw} The mutated input context.\n     */\n    async parseInnerContexts(context, options) {\n        for (const key of Object.keys(context)) {\n            const value = context[key];\n            if (value && typeof value === 'object') {\n                if ('@context' in value && value['@context'] !== null && !options.ignoreScopedContexts) {\n                    // Simulate a processing based on the parent context to check if there are any (potential errors).\n                    // Honestly, I find it a bit weird to do this here, as the context may be unused,\n                    // and the final effective context may differ based on any other embedded/scoped contexts.\n                    // But hey, it's part of the spec, so we have no choice...\n                    // https://w3c.github.io/json-ld-api/#h-note-10\n                    if (this.validateContext) {\n                        try {\n                            const parentContext = Object.assign({}, context);\n                            parentContext[key] = Object.assign({}, parentContext[key]);\n                            delete parentContext[key]['@context'];\n                            await this.parse(value['@context'], Object.assign(Object.assign({}, options), { external: false, parentContext, ignoreProtection: true, ignoreRemoteScopedContexts: true, ignoreScopedContexts: true }));\n                        }\n                        catch (e) {\n                            throw new ErrorCoded_1.ErrorCoded(e.message, ErrorCoded_1.ERROR_CODES.INVALID_SCOPED_CONTEXT);\n                        }\n                    }\n                    value['@context'] = (await this.parse(value['@context'], Object.assign(Object.assign({}, options), { external: false, minimalProcessing: true, ignoreRemoteScopedContexts: true, parentContext: context })))\n                        .getContextRaw();\n                }\n            }\n        }\n        return context;\n    }\n    /**\n     * Parse a JSON-LD context in any form.\n     * @param {JsonLdContext} context A context, URL to a context, or an array of contexts/URLs.\n     * @param {IParseOptions} options Optional parsing options.\n     * @return {Promise<JsonLdContextNormalized>} A promise resolving to the context.\n     */\n    async parse(context, options = {}) {\n        const { baseIRI, parentContext: parentContextInitial, external, processingMode = ContextParser.DEFAULT_PROCESSING_MODE, normalizeLanguageTags, ignoreProtection, minimalProcessing, } = options;\n        let parentContext = parentContextInitial;\n        const remoteContexts = options.remoteContexts || {};\n        // Avoid remote context overflows\n        if (Object.keys(remoteContexts).length >= this.remoteContextsDepthLimit) {\n            throw new ErrorCoded_1.ErrorCoded('Detected an overflow in remote context inclusions: ' + Object.keys(remoteContexts), ErrorCoded_1.ERROR_CODES.CONTEXT_OVERFLOW);\n        }\n        if (context === null || context === undefined) {\n            // Don't allow context nullification and there are protected terms\n            if (!ignoreProtection && parentContext && Util_1.Util.hasProtectedTerms(parentContext)) {\n                throw new ErrorCoded_1.ErrorCoded('Illegal context nullification when terms are protected', ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_NULLIFICATION);\n            }\n            // Context that are explicitly set to null are empty.\n            return new JsonLdContextNormalized_1.JsonLdContextNormalized(this.applyBaseEntry({}, options, false));\n        }\n        else if (typeof context === 'string') {\n            const contextIri = this.normalizeContextIri(context, baseIRI);\n            const overriddenLoad = this.getOverriddenLoad(contextIri, options);\n            if (overriddenLoad) {\n                return new JsonLdContextNormalized_1.JsonLdContextNormalized(overriddenLoad);\n            }\n            const parsedStringContext = await this.parse(await this.load(contextIri), Object.assign(Object.assign({}, options), { baseIRI: contextIri, external: true, remoteContexts: Object.assign(Object.assign({}, remoteContexts), { [contextIri]: true }) }));\n            this.applyBaseEntry(parsedStringContext.getContextRaw(), options, true);\n            return parsedStringContext;\n        }\n        else if (Array.isArray(context)) {\n            // As a performance consideration, first load all external contexts in parallel.\n            const contextIris = [];\n            const contexts = await Promise.all(context.map((subContext, i) => {\n                if (typeof subContext === 'string') {\n                    const contextIri = this.normalizeContextIri(subContext, baseIRI);\n                    contextIris[i] = contextIri;\n                    const overriddenLoad = this.getOverriddenLoad(contextIri, options);\n                    if (overriddenLoad) {\n                        return overriddenLoad;\n                    }\n                    return this.load(contextIri);\n                }\n                else {\n                    return subContext;\n                }\n            }));\n            // Don't apply inheritance logic on minimal processing\n            if (minimalProcessing) {\n                return new JsonLdContextNormalized_1.JsonLdContextNormalized(contexts);\n            }\n            const reducedContexts = await contexts.reduce((accContextPromise, contextEntry, i) => accContextPromise\n                .then((accContext) => this.parse(contextEntry, Object.assign(Object.assign({}, options), { baseIRI: contextIris[i] || options.baseIRI, external: !!contextIris[i] || options.external, parentContext: accContext.getContextRaw(), remoteContexts: contextIris[i] ? Object.assign(Object.assign({}, remoteContexts), { [contextIris[i]]: true }) : remoteContexts }))), Promise.resolve(new JsonLdContextNormalized_1.JsonLdContextNormalized(parentContext || {})));\n            // Override the base IRI if provided.\n            this.applyBaseEntry(reducedContexts.getContextRaw(), options, true);\n            return reducedContexts;\n        }\n        else if (typeof context === 'object') {\n            if ('@context' in context) {\n                return await this.parse(context['@context'], options);\n            }\n            // Make a deep clone of the given context, to avoid modifying it.\n            context = JSON.parse(JSON.stringify(context)); // No better way in JS at the moment.\n            if (parentContext && !minimalProcessing) {\n                parentContext = JSON.parse(JSON.stringify(parentContext));\n            }\n            // We have an actual context object.\n            let newContext = {};\n            // According to the JSON-LD spec, @base must be ignored from external contexts.\n            if (external) {\n                delete context['@base'];\n            }\n            // Override the base IRI if provided.\n            this.applyBaseEntry(context, options, true);\n            // Hashify container entries\n            // Do this before protected term validation as that influences term format\n            this.containersToHash(context);\n            // Don't perform any other modifications if only minimal processing is needed.\n            if (minimalProcessing) {\n                return new JsonLdContextNormalized_1.JsonLdContextNormalized(context);\n            }\n            // In JSON-LD 1.1, load @import'ed context prior to processing.\n            let importContext = {};\n            if ('@import' in context) {\n                if (processingMode >= 1.1) {\n                    // Only accept string values\n                    if (typeof context['@import'] !== 'string') {\n                        throw new ErrorCoded_1.ErrorCoded('An @import value must be a string, but got ' + typeof context['@import'], ErrorCoded_1.ERROR_CODES.INVALID_IMPORT_VALUE);\n                    }\n                    // Load context\n                    importContext = await this.loadImportContext(this.normalizeContextIri(context['@import'], baseIRI));\n                    delete context['@import'];\n                }\n                else {\n                    throw new ErrorCoded_1.ErrorCoded('Context importing is not supported in JSON-LD 1.0', ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n                }\n            }\n            // Merge different parts of the final context in order\n            newContext = Object.assign(Object.assign(Object.assign(Object.assign({}, newContext), (typeof parentContext === 'object' ? parentContext : {})), importContext), context);\n            const newContextWrapped = new JsonLdContextNormalized_1.JsonLdContextNormalized(newContext);\n            // Parse inner contexts with minimal processing\n            await this.parseInnerContexts(newContext, options);\n            // In JSON-LD 1.1, @vocab can be relative to @vocab in the parent context, or a compact IRI.\n            if ((newContext && newContext['@version'] || ContextParser.DEFAULT_PROCESSING_MODE) >= 1.1\n                && ((context['@vocab'] && typeof context['@vocab'] === 'string') || context['@vocab'] === '')) {\n                if (parentContext && '@vocab' in parentContext && context['@vocab'].indexOf(':') < 0) {\n                    newContext['@vocab'] = parentContext['@vocab'] + context['@vocab'];\n                }\n                else {\n                    if (Util_1.Util.isCompactIri(context['@vocab']) || context['@vocab'] in newContextWrapped.getContextRaw()) {\n                        // @vocab is a compact IRI or refers exactly to a prefix\n                        newContext['@vocab'] = newContextWrapped.expandTerm(context['@vocab'], true);\n                    }\n                }\n            }\n            // Handle terms (before protection checks)\n            this.idifyReverseTerms(newContext);\n            this.expandPrefixedTerms(newContextWrapped, this.expandContentTypeToBase);\n            // In JSON-LD 1.1, check if we are not redefining any protected keywords\n            if (!ignoreProtection && parentContext && processingMode >= 1.1) {\n                this.validateKeywordRedefinitions(parentContext, newContext, exports.defaultExpandOptions);\n            }\n            this.normalize(newContext, { processingMode, normalizeLanguageTags });\n            this.applyScopedProtected(newContext, { processingMode });\n            if (this.validateContext) {\n                this.validate(newContext, { processingMode });\n            }\n            return newContextWrapped;\n        }\n        else {\n            throw new ErrorCoded_1.ErrorCoded(`Tried parsing a context that is not a string, array or object, but got ${context}`, ErrorCoded_1.ERROR_CODES.INVALID_LOCAL_CONTEXT);\n        }\n    }\n    /**\n     * Fetch the given URL as a raw JSON-LD context.\n     * @param url An URL.\n     * @return A promise resolving to a raw JSON-LD context.\n     */\n    async load(url) {\n        // First try to retrieve the context from cache\n        const cached = this.documentCache[url];\n        if (cached) {\n            return typeof cached === 'string' ? cached : Array.isArray(cached) ? cached.slice() : Object.assign({}, cached);\n        }\n        // If not in cache, load it\n        let document;\n        try {\n            document = await this.documentLoader.load(url);\n        }\n        catch (e) {\n            throw new ErrorCoded_1.ErrorCoded(`Failed to load remote context ${url}: ${e.message}`, ErrorCoded_1.ERROR_CODES.LOADING_REMOTE_CONTEXT_FAILED);\n        }\n        // Validate the context\n        if (!('@context' in document)) {\n            throw new ErrorCoded_1.ErrorCoded(`Missing @context in remote context at ${url}`, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);\n        }\n        return this.documentCache[url] = document['@context'];\n    }\n    /**\n     * Override the given context that may be loaded.\n     *\n     * This will check whether or not the url is recursively being loaded.\n     * @param url An URL.\n     * @param options Parsing options.\n     * @return An overridden context, or null.\n     *         Optionally an error can be thrown if a cyclic context is detected.\n     */\n    getOverriddenLoad(url, options) {\n        if (url in (options.remoteContexts || {})) {\n            if (options.ignoreRemoteScopedContexts) {\n                return url;\n            }\n            else {\n                throw new ErrorCoded_1.ErrorCoded('Detected a cyclic context inclusion of ' + url, ErrorCoded_1.ERROR_CODES.RECURSIVE_CONTEXT_INCLUSION);\n            }\n        }\n        return null;\n    }\n    /**\n     * Load an @import'ed context.\n     * @param importContextIri The full URI of an @import value.\n     */\n    async loadImportContext(importContextIri) {\n        // Load the context\n        const importContext = await this.load(importContextIri);\n        // Require the context to be a non-array object\n        if (typeof importContext !== 'object' || Array.isArray(importContext)) {\n            throw new ErrorCoded_1.ErrorCoded('An imported context must be a single object: ' + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);\n        }\n        // Error if the context contains another @import\n        if ('@import' in importContext) {\n            throw new ErrorCoded_1.ErrorCoded('An imported context can not import another context: ' + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n        }\n        // Containers have to be converted into hash values the same way as for the importing context\n        // Otherwise context validation will fail for container values\n        this.containersToHash(importContext);\n        return importContext;\n    }\n}\nexports.ContextParser = ContextParser;\nContextParser.DEFAULT_PROCESSING_MODE = 1.1;\nexports.defaultExpandOptions = {\n    allowPrefixForcing: true,\n    allowPrefixNonGenDelims: false,\n    allowVocabRelativeToBase: true,\n};\n//# sourceMappingURL=ContextParser.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ERROR_CODES = exports.ErrorCoded = void 0;\n/**\n * An error that has a certain error code.\n *\n * The error code can be any string.\n * All standardized error codes are listed in {@link ERROR_CODES}.\n */\nclass ErrorCoded extends Error {\n    /* istanbul ignore next */\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n    }\n}\nexports.ErrorCoded = ErrorCoded;\n/**\n * All standardized JSON-LD error codes.\n * @see https://w3c.github.io/json-ld-api/#dom-jsonlderrorcode\n */\n// tslint:disable:object-literal-sort-keys\nvar ERROR_CODES;\n(function (ERROR_CODES) {\n    ERROR_CODES[\"COLLIDING_KEYWORDS\"] = \"colliding keywords\";\n    ERROR_CODES[\"CONFLICTING_INDEXES\"] = \"conflicting indexes\";\n    ERROR_CODES[\"CYCLIC_IRI_MAPPING\"] = \"cyclic IRI mapping\";\n    ERROR_CODES[\"INVALID_ID_VALUE\"] = \"invalid @id value\";\n    ERROR_CODES[\"INVALID_INDEX_VALUE\"] = \"invalid @index value\";\n    ERROR_CODES[\"INVALID_NEST_VALUE\"] = \"invalid @nest value\";\n    ERROR_CODES[\"INVALID_PREFIX_VALUE\"] = \"invalid @prefix value\";\n    ERROR_CODES[\"INVALID_PROPAGATE_VALUE\"] = \"invalid @propagate value\";\n    ERROR_CODES[\"INVALID_REVERSE_VALUE\"] = \"invalid @reverse value\";\n    ERROR_CODES[\"INVALID_IMPORT_VALUE\"] = \"invalid @import value\";\n    ERROR_CODES[\"INVALID_VERSION_VALUE\"] = \"invalid @version value\";\n    ERROR_CODES[\"INVALID_BASE_IRI\"] = \"invalid base IRI\";\n    ERROR_CODES[\"INVALID_CONTAINER_MAPPING\"] = \"invalid container mapping\";\n    ERROR_CODES[\"INVALID_CONTEXT_ENTRY\"] = \"invalid context entry\";\n    ERROR_CODES[\"INVALID_CONTEXT_NULLIFICATION\"] = \"invalid context nullification\";\n    ERROR_CODES[\"INVALID_DEFAULT_LANGUAGE\"] = \"invalid default language\";\n    ERROR_CODES[\"INVALID_INCLUDED_VALUE\"] = \"invalid @included value\";\n    ERROR_CODES[\"INVALID_IRI_MAPPING\"] = \"invalid IRI mapping\";\n    ERROR_CODES[\"INVALID_JSON_LITERAL\"] = \"invalid JSON literal\";\n    ERROR_CODES[\"INVALID_KEYWORD_ALIAS\"] = \"invalid keyword alias\";\n    ERROR_CODES[\"INVALID_LANGUAGE_MAP_VALUE\"] = \"invalid language map value\";\n    ERROR_CODES[\"INVALID_LANGUAGE_MAPPING\"] = \"invalid language mapping\";\n    ERROR_CODES[\"INVALID_LANGUAGE_TAGGED_STRING\"] = \"invalid language-tagged string\";\n    ERROR_CODES[\"INVALID_LANGUAGE_TAGGED_VALUE\"] = \"invalid language-tagged value\";\n    ERROR_CODES[\"INVALID_LOCAL_CONTEXT\"] = \"invalid local context\";\n    ERROR_CODES[\"INVALID_REMOTE_CONTEXT\"] = \"invalid remote context\";\n    ERROR_CODES[\"INVALID_REVERSE_PROPERTY\"] = \"invalid reverse property\";\n    ERROR_CODES[\"INVALID_REVERSE_PROPERTY_MAP\"] = \"invalid reverse property map\";\n    ERROR_CODES[\"INVALID_REVERSE_PROPERTY_VALUE\"] = \"invalid reverse property value\";\n    ERROR_CODES[\"INVALID_SCOPED_CONTEXT\"] = \"invalid scoped context\";\n    ERROR_CODES[\"INVALID_SCRIPT_ELEMENT\"] = \"invalid script element\";\n    ERROR_CODES[\"INVALID_SET_OR_LIST_OBJECT\"] = \"invalid set or list object\";\n    ERROR_CODES[\"INVALID_TERM_DEFINITION\"] = \"invalid term definition\";\n    ERROR_CODES[\"INVALID_TYPE_MAPPING\"] = \"invalid type mapping\";\n    ERROR_CODES[\"INVALID_TYPE_VALUE\"] = \"invalid type value\";\n    ERROR_CODES[\"INVALID_TYPED_VALUE\"] = \"invalid typed value\";\n    ERROR_CODES[\"INVALID_VALUE_OBJECT\"] = \"invalid value object\";\n    ERROR_CODES[\"INVALID_VALUE_OBJECT_VALUE\"] = \"invalid value object value\";\n    ERROR_CODES[\"INVALID_VOCAB_MAPPING\"] = \"invalid vocab mapping\";\n    ERROR_CODES[\"IRI_CONFUSED_WITH_PREFIX\"] = \"IRI confused with prefix\";\n    ERROR_CODES[\"KEYWORD_REDEFINITION\"] = \"keyword redefinition\";\n    ERROR_CODES[\"LOADING_DOCUMENT_FAILED\"] = \"loading document failed\";\n    ERROR_CODES[\"LOADING_REMOTE_CONTEXT_FAILED\"] = \"loading remote context failed\";\n    ERROR_CODES[\"MULTIPLE_CONTEXT_LINK_HEADERS\"] = \"multiple context link headers\";\n    ERROR_CODES[\"PROCESSING_MODE_CONFLICT\"] = \"processing mode conflict\";\n    ERROR_CODES[\"PROTECTED_TERM_REDEFINITION\"] = \"protected term redefinition\";\n    ERROR_CODES[\"CONTEXT_OVERFLOW\"] = \"context overflow\";\n    ERROR_CODES[\"INVALID_BASE_DIRECTION\"] = \"invalid base direction\";\n    ERROR_CODES[\"RECURSIVE_CONTEXT_INCLUSION\"] = \"recursive context inclusion\";\n    ERROR_CODES[\"INVALID_STREAMING_KEY_ORDER\"] = \"invalid streaming key order\";\n    /**\n     * JSON-LD-star\n     */\n    ERROR_CODES[\"INVALID_EMBEDDED_NODE\"] = \"invalid embedded node\";\n    ERROR_CODES[\"INVALID_ANNOTATION\"] = \"invalid annotation\";\n})(ERROR_CODES = exports.ERROR_CODES || (exports.ERROR_CODES = {}));\n//# sourceMappingURL=ErrorCoded.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FetchDocumentLoader = void 0;\nrequire(\"cross-fetch/polyfill\");\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\nconst http_link_header_1 = require(\"http-link-header\");\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\n/**\n * Loads documents via the fetch API.\n */\nclass FetchDocumentLoader {\n    constructor(fetcher) {\n        this.fetcher = fetcher;\n    }\n    async load(url) {\n        const response = await (this.fetcher || fetch)(url, { headers: new Headers({ accept: 'application/ld+json' }) });\n        if (response.ok && response.headers) {\n            let mediaType = response.headers.get('Content-Type');\n            if (mediaType) {\n                const colonPos = mediaType.indexOf(';');\n                if (colonPos > 0) {\n                    mediaType = mediaType.substr(0, colonPos);\n                }\n            }\n            if (mediaType === 'application/ld+json') {\n                // Return JSON-LD if proper content type was returned\n                return (await response.json());\n            }\n            else {\n                // Check for alternate link for a non-JSON-LD response\n                if (response.headers.has('Link')) {\n                    let alternateUrl;\n                    response.headers.forEach((value, key) => {\n                        if (key === 'link') {\n                            const linkHeader = (0, http_link_header_1.parse)(value);\n                            for (const link of linkHeader.get('type', 'application/ld+json')) {\n                                if (link.rel === 'alternate') {\n                                    if (alternateUrl) {\n                                        throw new Error('Multiple JSON-LD alternate links were found on ' + url);\n                                    }\n                                    alternateUrl = (0, relative_to_absolute_iri_1.resolve)(link.uri, url);\n                                }\n                            }\n                        }\n                    });\n                    if (alternateUrl) {\n                        return this.load(alternateUrl);\n                    }\n                }\n                throw new ErrorCoded_1.ErrorCoded(`Unsupported JSON-LD media type ${mediaType}`, ErrorCoded_1.ERROR_CODES.LOADING_DOCUMENT_FAILED);\n            }\n        }\n        else {\n            throw new Error(response.statusText || `Status code: ${response.status}`);\n        }\n    }\n}\nexports.FetchDocumentLoader = FetchDocumentLoader;\n//# sourceMappingURL=FetchDocumentLoader.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=IDocumentLoader.js.map","\"use strict\";\n// tslint:disable:max-line-length\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=JsonLdContext.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JsonLdContextNormalized = void 0;\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst ContextParser_1 = require(\"./ContextParser\");\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\nconst Util_1 = require(\"./Util\");\n/**\n * A class exposing operations over a normalized JSON-LD context.\n */\nclass JsonLdContextNormalized {\n    constructor(contextRaw) {\n        this.contextRaw = contextRaw;\n    }\n    /**\n     * @return The raw inner context.\n     */\n    getContextRaw() {\n        return this.contextRaw;\n    }\n    /**\n     * Expand the term or prefix of the given term if it has one,\n     * otherwise return the term as-is.\n     *\n     * This will try to expand the IRI as much as possible.\n     *\n     * Iff in vocab-mode, then other references to other terms in the context can be used,\n     * such as to `myTerm`:\n     * ```\n     * {\n     *   \"myTerm\": \"http://example.org/myLongTerm\"\n     * }\n     * ```\n     *\n     * @param {string} term A term that is an URL or a prefixed URL.\n     * @param {boolean} expandVocab If the term is a predicate or type and should be expanded based on @vocab,\n     *                              otherwise it is considered a regular term that is expanded based on @base.\n     * @param {IExpandOptions} options Options that define the way how expansion must be done.\n     * @return {string} The expanded term, the term as-is, or null if it was explicitly disabled in the context.\n     * @throws If the term is aliased to an invalid value (not a string, IRI or keyword).\n     */\n    expandTerm(term, expandVocab, options = ContextParser_1.defaultExpandOptions) {\n        const contextValue = this.contextRaw[term];\n        // Immediately return if the term was disabled in the context\n        if (contextValue === null || (contextValue && contextValue['@id'] === null)) {\n            return null;\n        }\n        // Check the @id\n        let validIriMapping = true;\n        if (contextValue && expandVocab) {\n            const value = Util_1.Util.getContextValueId(contextValue);\n            if (value && value !== term) {\n                if (typeof value !== 'string' || (!Util_1.Util.isValidIri(value) && !Util_1.Util.isValidKeyword(value))) {\n                    // Don't mark this mapping as invalid if we have an unknown keyword, but of the correct form.\n                    if (!Util_1.Util.isPotentialKeyword(value)) {\n                        validIriMapping = false;\n                    }\n                }\n                else {\n                    return value;\n                }\n            }\n        }\n        // Check if the term is prefixed\n        const prefix = Util_1.Util.getPrefix(term, this.contextRaw);\n        const vocab = this.contextRaw['@vocab'];\n        const vocabRelative = (!!vocab || vocab === '') && vocab.indexOf(':') < 0;\n        const base = this.contextRaw['@base'];\n        const potentialKeyword = Util_1.Util.isPotentialKeyword(term);\n        if (prefix) {\n            const contextPrefixValue = this.contextRaw[prefix];\n            const value = Util_1.Util.getContextValueId(contextPrefixValue);\n            if (value) {\n                if (typeof contextPrefixValue === 'string' || !options.allowPrefixForcing) {\n                    // If we have a simple term definition,\n                    // check the last character of the prefix to determine whether or not it is a prefix.\n                    // Validate that prefix ends with gen-delim character, unless @prefix is true\n                    if (!Util_1.Util.isSimpleTermDefinitionPrefix(value, options)) {\n                        // Treat the term as an absolute IRI\n                        return term;\n                    }\n                }\n                else {\n                    // If we have an expanded term definition, default to @prefix: false\n                    if (value[0] !== '_' && !potentialKeyword && !contextPrefixValue['@prefix'] && !(term in this.contextRaw)) {\n                        // Treat the term as an absolute IRI\n                        return term;\n                    }\n                }\n                return value + term.substr(prefix.length + 1);\n            }\n        }\n        else if (expandVocab && ((vocab || vocab === '') || (options.allowVocabRelativeToBase && (base && vocabRelative)))\n            && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {\n            if (vocabRelative) {\n                if (options.allowVocabRelativeToBase) {\n                    return ((vocab || base) ? (0, relative_to_absolute_iri_1.resolve)(vocab, base) : '') + term;\n                }\n                else {\n                    throw new ErrorCoded_1.ErrorCoded(`Relative vocab expansion for term '${term}' with vocab '${vocab}' is not allowed.`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);\n                }\n            }\n            else {\n                return vocab + term;\n            }\n        }\n        else if (!expandVocab && base && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {\n            return (0, relative_to_absolute_iri_1.resolve)(term, base);\n        }\n        // Return the term as-is, unless we discovered an invalid IRI mapping for this term in the context earlier.\n        if (validIriMapping) {\n            return term;\n        }\n        else {\n            throw new ErrorCoded_1.ErrorCoded(`Invalid IRI mapping found for context entry '${term}': '${JSON.stringify(contextValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n        }\n    }\n    /**\n     * Compact the given term using @base, @vocab, an aliased term, or a prefixed term.\n     *\n     * This will try to compact the IRI as much as possible.\n     *\n     * @param {string} iri An IRI to compact.\n     * @param {boolean} vocab If the term is a predicate or type and should be compacted based on @vocab,\n     *                        otherwise it is considered a regular term that is compacted based on @base.\n     * @return {string} The compacted term or the IRI as-is.\n     */\n    compactIri(iri, vocab) {\n        // Try @vocab compacting\n        if (vocab && this.contextRaw['@vocab'] && iri.startsWith(this.contextRaw['@vocab'])) {\n            return iri.substr(this.contextRaw['@vocab'].length);\n        }\n        // Try @base compacting\n        if (!vocab && this.contextRaw['@base'] && iri.startsWith(this.contextRaw['@base'])) {\n            return iri.substr(this.contextRaw['@base'].length);\n        }\n        // Loop over all terms in the context\n        // This will try to prefix as short as possible.\n        // Once a fully compacted alias is found, return immediately, as we can not go any shorter.\n        const shortestPrefixing = { prefix: '', suffix: iri };\n        for (const key in this.contextRaw) {\n            const value = this.contextRaw[key];\n            if (value && !Util_1.Util.isPotentialKeyword(key)) {\n                const contextIri = Util_1.Util.getContextValueId(value);\n                if (iri.startsWith(contextIri)) {\n                    const suffix = iri.substr(contextIri.length);\n                    if (!suffix) {\n                        if (vocab) {\n                            // Immediately return on compacted alias\n                            return key;\n                        }\n                    }\n                    else if (suffix.length < shortestPrefixing.suffix.length) {\n                        // Overwrite the shortest prefix\n                        shortestPrefixing.prefix = key;\n                        shortestPrefixing.suffix = suffix;\n                    }\n                }\n            }\n        }\n        // Return the shortest prefix\n        if (shortestPrefixing.prefix) {\n            return shortestPrefixing.prefix + ':' + shortestPrefixing.suffix;\n        }\n        return iri;\n    }\n}\nexports.JsonLdContextNormalized = JsonLdContextNormalized;\n//# sourceMappingURL=JsonLdContextNormalized.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Util = void 0;\nclass Util {\n    /**\n     * Check if the given term is a valid compact IRI.\n     * Otherwise, it may be an IRI.\n     * @param {string} term A term.\n     * @return {boolean} If it is a compact IRI.\n     */\n    static isCompactIri(term) {\n        return term.indexOf(':') > 0 && !(term && term[0] === '#');\n    }\n    /**\n     * Get the prefix from the given term.\n     * @see https://json-ld.org/spec/latest/json-ld/#compact-iris\n     * @param {string} term A term that is an URL or a prefixed URL.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @return {string} The prefix or null.\n     */\n    static getPrefix(term, context) {\n        // Do not consider relative IRIs starting with a hash as compact IRIs\n        if (term && term[0] === '#') {\n            return null;\n        }\n        const separatorPos = term.indexOf(':');\n        if (separatorPos >= 0) {\n            // Suffix can not begin with two slashes\n            if (term.length > separatorPos + 1\n                && term.charAt(separatorPos + 1) === '/'\n                && term.charAt(separatorPos + 2) === '/') {\n                return null;\n            }\n            const prefix = term.substr(0, separatorPos);\n            // Prefix can not be an underscore (this is a blank node)\n            if (prefix === '_') {\n                return null;\n            }\n            // Prefix must match a term in the active context\n            if (context[prefix]) {\n                return prefix;\n            }\n        }\n        return null;\n    }\n    /**\n     * From a given context entry value, get the string value, or the @id field.\n     * @param contextValue A value for a term in a context.\n     * @return {string} The id value, or null.\n     */\n    static getContextValueId(contextValue) {\n        if (contextValue === null || typeof contextValue === 'string') {\n            return contextValue;\n        }\n        const id = contextValue['@id'];\n        return id ? id : null;\n    }\n    /**\n     * Check if the given simple term definition (string-based value of a context term)\n     * should be considered a prefix.\n     * @param value A simple term definition value.\n     * @param options Options that define the way how expansion must be done.\n     */\n    static isSimpleTermDefinitionPrefix(value, options) {\n        return !Util.isPotentialKeyword(value)\n            && (value[0] === '_' || options.allowPrefixNonGenDelims || Util.isPrefixIriEndingWithGenDelim(value));\n    }\n    /**\n     * Check if the given keyword is of the keyword format \"@\"1*ALPHA.\n     * @param {string} keyword A potential keyword.\n     * @return {boolean} If the given keyword is of the keyword format.\n     */\n    static isPotentialKeyword(keyword) {\n        return typeof keyword === 'string' && Util.KEYWORD_REGEX.test(keyword);\n    }\n    /**\n     * Check if the given prefix ends with a gen-delim character.\n     * @param {string} prefixIri A prefix IRI.\n     * @return {boolean} If the given prefix IRI is valid.\n     */\n    static isPrefixIriEndingWithGenDelim(prefixIri) {\n        return Util.ENDS_WITH_GEN_DELIM.test(prefixIri);\n    }\n    /**\n     * Check if the given context value can be a prefix value.\n     * @param value A context value.\n     * @return {boolean} If it can be a prefix value.\n     */\n    static isPrefixValue(value) {\n        return value && (typeof value === 'string' || (value && typeof value === 'object'));\n    }\n    /**\n     * Check if the given IRI is valid.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIri(iri) {\n        return Boolean(iri && Util.IRI_REGEX.test(iri));\n    }\n    /**\n     * Check if the given IRI is valid, this includes the possibility of being a relative IRI.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIriWeak(iri) {\n        return !!iri && iri[0] !== ':' && Util.IRI_REGEX_WEAK.test(iri);\n    }\n    /**\n     * Check if the given keyword is a defined according to the JSON-LD specification.\n     * @param {string} keyword A potential keyword.\n     * @return {boolean} If the given keyword is valid.\n     */\n    static isValidKeyword(keyword) {\n        return Util.VALID_KEYWORDS[keyword];\n    }\n    /**\n     * Check if the given term is protected in the context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {string} key A context term.\n     * @return {boolean} If the given term has an @protected flag.\n     */\n    static isTermProtected(context, key) {\n        const value = context[key];\n        return !(typeof value === 'string') && value && value['@protected'];\n    }\n    /**\n     * Check if the given context has at least one protected term.\n     * @param context A context.\n     * @return If the context has a protected term.\n     */\n    static hasProtectedTerms(context) {\n        for (const key of Object.keys(context)) {\n            if (Util.isTermProtected(context, key)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Check if the given key is an internal reserved keyword.\n     * @param key A context key.\n     */\n    static isReservedInternalKeyword(key) {\n        return key.startsWith('@__');\n    }\n}\nexports.Util = Util;\n// Regex for valid IRIs\nUtil.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ \"<>{}|\\\\\\[\\]`#]*(#[^#]*)?$/;\n// Weaker regex for valid IRIs, this includes relative IRIs\nUtil.IRI_REGEX_WEAK = /(?::[^:])|\\//;\n// Regex for keyword form\nUtil.KEYWORD_REGEX = /^@[a-z]+$/i;\n// Regex to see if an IRI ends with a gen-delim character (see RFC 3986)\nUtil.ENDS_WITH_GEN_DELIM = /[:/?#\\[\\]@]$/;\n// Regex for language tags\nUtil.REGEX_LANGUAGE_TAG = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/;\n// Regex for base directions\nUtil.REGEX_DIRECTION_TAG = /^(ltr)|(rtl)$/;\n// All known valid JSON-LD keywords\n// @see https://www.w3.org/TR/json-ld11/#keywords\nUtil.VALID_KEYWORDS = {\n    '@annotation': true,\n    '@base': true,\n    '@container': true,\n    '@context': true,\n    '@direction': true,\n    '@graph': true,\n    '@id': true,\n    '@import': true,\n    '@included': true,\n    '@index': true,\n    '@json': true,\n    '@language': true,\n    '@list': true,\n    '@nest': true,\n    '@none': true,\n    '@prefix': true,\n    '@propagate': true,\n    '@protected': true,\n    '@reverse': true,\n    '@set': true,\n    '@type': true,\n    '@value': true,\n    '@version': true,\n    '@vocab': true,\n};\n// Keys in the contexts that will not be expanded based on the base IRI\nUtil.EXPAND_KEYS_BLACKLIST = [\n    '@base',\n    '@vocab',\n    '@language',\n    '@version',\n    '@direction',\n];\n// Keys in the contexts that may not be aliased from\nUtil.ALIAS_DOMAIN_BLACKLIST = [\n    '@container',\n    '@graph',\n    '@id',\n    '@index',\n    '@list',\n    '@nest',\n    '@none',\n    '@prefix',\n    '@reverse',\n    '@set',\n    '@type',\n    '@value',\n    '@version',\n];\n// Keys in the contexts that may not be aliased to\nUtil.ALIAS_RANGE_BLACKLIST = [\n    '@context',\n    '@preserve',\n];\n// All valid @container values\nUtil.CONTAINERS = [\n    '@list',\n    '@set',\n    '@index',\n    '@language',\n    '@graph',\n    '@id',\n    '@type',\n];\n// All valid @container values under processing mode 1.0\nUtil.CONTAINERS_1_0 = [\n    '@list',\n    '@set',\n    '@index',\n];\n//# sourceMappingURL=Util.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/BlankNode\"), exports);\n__exportStar(require(\"./lib/DataFactory\"), exports);\n__exportStar(require(\"./lib/DefaultGraph\"), exports);\n__exportStar(require(\"./lib/Literal\"), exports);\n__exportStar(require(\"./lib/NamedNode\"), exports);\n__exportStar(require(\"./lib/Quad\"), exports);\n__exportStar(require(\"./lib/Variable\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlankNode = void 0;\n/**\n * A term that represents an RDF blank node with a label.\n */\nclass BlankNode {\n    constructor(value) {\n        this.termType = 'BlankNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'BlankNode' && other.value === this.value;\n    }\n}\nexports.BlankNode = BlankNode;\n//# sourceMappingURL=BlankNode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataFactory = void 0;\nconst BlankNode_1 = require(\"./BlankNode\");\nconst DefaultGraph_1 = require(\"./DefaultGraph\");\nconst Literal_1 = require(\"./Literal\");\nconst NamedNode_1 = require(\"./NamedNode\");\nconst Quad_1 = require(\"./Quad\");\nconst Variable_1 = require(\"./Variable\");\nlet dataFactoryCounter = 0;\n/**\n * A factory for instantiating RDF terms and quads.\n */\nclass DataFactory {\n    constructor(options) {\n        this.blankNodeCounter = 0;\n        options = options || {};\n        this.blankNodePrefix = options.blankNodePrefix || `df_${dataFactoryCounter++}_`;\n    }\n    /**\n     * @param value The IRI for the named node.\n     * @return A new instance of NamedNode.\n     * @see NamedNode\n     */\n    namedNode(value) {\n        return new NamedNode_1.NamedNode(value);\n    }\n    /**\n     * @param value The optional blank node identifier.\n     * @return A new instance of BlankNode.\n     *         If the `value` parameter is undefined a new identifier\n     *         for the blank node is generated for each call.\n     * @see BlankNode\n     */\n    blankNode(value) {\n        return new BlankNode_1.BlankNode(value || `${this.blankNodePrefix}${this.blankNodeCounter++}`);\n    }\n    /**\n     * @param value              The literal value.\n     * @param languageOrDatatype The optional language or datatype.\n     *                           If `languageOrDatatype` is a NamedNode,\n     *                           then it is used for the value of `NamedNode.datatype`.\n     *                           Otherwise `languageOrDatatype` is used for the value\n     *                           of `NamedNode.language`.\n     * @return A new instance of Literal.\n     * @see Literal\n     */\n    literal(value, languageOrDatatype) {\n        return new Literal_1.Literal(value, languageOrDatatype);\n    }\n    /**\n     * This method is optional.\n     * @param value The variable name\n     * @return A new instance of Variable.\n     * @see Variable\n     */\n    variable(value) {\n        return new Variable_1.Variable(value);\n    }\n    /**\n     * @return An instance of DefaultGraph.\n     */\n    defaultGraph() {\n        return DefaultGraph_1.DefaultGraph.INSTANCE;\n    }\n    /**\n     * @param subject   The quad subject term.\n     * @param predicate The quad predicate term.\n     * @param object    The quad object term.\n     * @param graph     The quad graph term.\n     * @return A new instance of Quad.\n     * @see Quad\n     */\n    quad(subject, predicate, object, graph) {\n        return new Quad_1.Quad(subject, predicate, object, graph || this.defaultGraph());\n    }\n    /**\n     * Create a deep copy of the given term using this data factory.\n     * @param original An RDF term.\n     * @return A deep copy of the given term.\n     */\n    fromTerm(original) {\n        // TODO: remove nasty any casts when this TS bug has been fixed:\n        //  https://github.com/microsoft/TypeScript/issues/26933\n        switch (original.termType) {\n            case 'NamedNode':\n                return this.namedNode(original.value);\n            case 'BlankNode':\n                return this.blankNode(original.value);\n            case 'Literal':\n                if (original.language) {\n                    return this.literal(original.value, original.language);\n                }\n                if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {\n                    return this.literal(original.value, this.fromTerm(original.datatype));\n                }\n                return this.literal(original.value);\n            case 'Variable':\n                return this.variable(original.value);\n            case 'DefaultGraph':\n                return this.defaultGraph();\n            case 'Quad':\n                return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));\n        }\n    }\n    /**\n     * Create a deep copy of the given quad using this data factory.\n     * @param original An RDF quad.\n     * @return A deep copy of the given quad.\n     */\n    fromQuad(original) {\n        return this.fromTerm(original);\n    }\n    /**\n     * Reset the internal blank node counter.\n     */\n    resetBlankNodeCounter() {\n        this.blankNodeCounter = 0;\n    }\n}\nexports.DataFactory = DataFactory;\n//# sourceMappingURL=DataFactory.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultGraph = void 0;\n/**\n * A singleton term instance that represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass DefaultGraph {\n    constructor() {\n        this.termType = 'DefaultGraph';\n        this.value = '';\n        // Private constructor\n    }\n    equals(other) {\n        return !!other && other.termType === 'DefaultGraph';\n    }\n}\nexports.DefaultGraph = DefaultGraph;\nDefaultGraph.INSTANCE = new DefaultGraph();\n//# sourceMappingURL=DefaultGraph.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Literal = void 0;\nconst NamedNode_1 = require(\"./NamedNode\");\n/**\n * A term that represents an RDF literal, containing a string with an optional language tag or datatype.\n */\nclass Literal {\n    constructor(value, languageOrDatatype) {\n        this.termType = 'Literal';\n        this.value = value;\n        if (typeof languageOrDatatype === 'string') {\n            this.language = languageOrDatatype;\n            this.datatype = Literal.RDF_LANGUAGE_STRING;\n        }\n        else if (languageOrDatatype) {\n            this.language = '';\n            this.datatype = languageOrDatatype;\n        }\n        else {\n            this.language = '';\n            this.datatype = Literal.XSD_STRING;\n        }\n    }\n    equals(other) {\n        return !!other && other.termType === 'Literal' && other.value === this.value &&\n            other.language === this.language && other.datatype.equals(this.datatype);\n    }\n}\nexports.Literal = Literal;\nLiteral.RDF_LANGUAGE_STRING = new NamedNode_1.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');\nLiteral.XSD_STRING = new NamedNode_1.NamedNode('http://www.w3.org/2001/XMLSchema#string');\n//# sourceMappingURL=Literal.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NamedNode = void 0;\n/**\n * A term that contains an IRI.\n */\nclass NamedNode {\n    constructor(value) {\n        this.termType = 'NamedNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'NamedNode' && other.value === this.value;\n    }\n}\nexports.NamedNode = NamedNode;\n//# sourceMappingURL=NamedNode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Quad = void 0;\n/**\n * An instance of DefaultGraph represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass Quad {\n    constructor(subject, predicate, object, graph) {\n        this.termType = 'Quad';\n        this.value = '';\n        this.subject = subject;\n        this.predicate = predicate;\n        this.object = object;\n        this.graph = graph;\n    }\n    equals(other) {\n        // `|| !other.termType` is for backwards-compatibility with old factories without RDF* support.\n        return !!other && (other.termType === 'Quad' || !other.termType) &&\n            this.subject.equals(other.subject) &&\n            this.predicate.equals(other.predicate) &&\n            this.object.equals(other.object) &&\n            this.graph.equals(other.graph);\n    }\n}\nexports.Quad = Quad;\n//# sourceMappingURL=Quad.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Variable = void 0;\n/**\n * A term that represents a variable.\n */\nclass Variable {\n    constructor(value) {\n        this.termType = 'Variable';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'Variable' && other.value === this.value;\n    }\n}\nexports.Variable = Variable;\n//# sourceMappingURL=Variable.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/Resolve\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.removeDotSegmentsOfPath = exports.removeDotSegments = exports.resolve = void 0;\n/**\n * Convert the given relative IRI to an absolute IRI\n * by taking into account the given optional baseIRI.\n *\n * @param {string} relativeIRI The relative IRI to convert to an absolute IRI.\n * @param {string} baseIRI The optional base IRI.\n * @return {string} an absolute IRI.\n */\nfunction resolve(relativeIRI, baseIRI) {\n    baseIRI = baseIRI || '';\n    const baseFragmentPos = baseIRI.indexOf('#');\n    // Ignore any fragments in the base IRI\n    if (baseFragmentPos > 0) {\n        baseIRI = baseIRI.substr(0, baseFragmentPos);\n    }\n    // Convert empty value directly to base IRI\n    if (!relativeIRI.length) {\n        // At this point, the baseIRI MUST be absolute, otherwise we error\n        if (baseIRI.indexOf(':') < 0) {\n            throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n        }\n        return baseIRI;\n    }\n    // If the value starts with a query character, concat directly (but strip the existing query)\n    if (relativeIRI.startsWith('?')) {\n        const baseQueryPos = baseIRI.indexOf('?');\n        if (baseQueryPos > 0) {\n            baseIRI = baseIRI.substr(0, baseQueryPos);\n        }\n        return baseIRI + relativeIRI;\n    }\n    // If the value starts with a fragment character, concat directly\n    if (relativeIRI.startsWith('#')) {\n        return baseIRI + relativeIRI;\n    }\n    // Ignore baseIRI if it is empty\n    if (!baseIRI.length) {\n        const relativeColonPos = relativeIRI.indexOf(':');\n        if (relativeColonPos < 0) {\n            throw new Error(`Found invalid relative IRI '${relativeIRI}' for a missing baseIRI`);\n        }\n        return removeDotSegmentsOfPath(relativeIRI, relativeColonPos);\n    }\n    // Ignore baseIRI if the value is absolute\n    const valueColonPos = relativeIRI.indexOf(':');\n    if (valueColonPos >= 0) {\n        return removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // At this point, the baseIRI MUST be absolute, otherwise we error\n    const baseColonPos = baseIRI.indexOf(':');\n    if (baseColonPos < 0) {\n        throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n    }\n    const baseIRIScheme = baseIRI.substr(0, baseColonPos + 1);\n    // Inherit the baseIRI scheme if the value starts with '//'\n    if (relativeIRI.indexOf('//') === 0) {\n        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // Check cases where '://' occurs in the baseIRI, and where there is no '/' after a ':' anymore.\n    let baseSlashAfterColonPos;\n    if (baseIRI.indexOf('//', baseColonPos) === baseColonPos + 1) {\n        // If there is no additional '/' after the '//'.\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 3);\n        if (baseSlashAfterColonPos < 0) {\n            // If something other than a '/' follows the '://', append the value after a '/',\n            // otherwise, prefix the value with only the baseIRI scheme.\n            if (baseIRI.length > baseColonPos + 3) {\n                return baseIRI + '/' + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n            else {\n                return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n        }\n    }\n    else {\n        // If there is not even a single '/' after the ':'\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 1);\n        if (baseSlashAfterColonPos < 0) {\n            // If we don't have a '/' after the ':',\n            // prefix the value with only the baseIRI scheme.\n            return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n        }\n    }\n    // If the value starts with a '/', then prefix it with everything before the first effective slash of the base IRI.\n    if (relativeIRI.indexOf('/') === 0) {\n        return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);\n    }\n    let baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);\n    const baseIRILastSlashPos = baseIRIPath.lastIndexOf('/');\n    // Ignore everything after the last '/' in the baseIRI path\n    if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {\n        baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1);\n        // Also remove the first character of the relative path if it starts with '.' (and not '..' or './')\n        // This change is only allowed if there is something else following the path\n        if (relativeIRI[0] === '.' && relativeIRI[1] !== '.' && relativeIRI[1] !== '/' && relativeIRI[2]) {\n            relativeIRI = relativeIRI.substr(1);\n        }\n    }\n    // Prefix the value with the baseIRI path where\n    relativeIRI = baseIRIPath + relativeIRI;\n    // Remove dot segment from the IRI\n    relativeIRI = removeDotSegments(relativeIRI);\n    // Prefix our transformed value with the part of the baseIRI until the first '/' after the first ':'.\n    return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;\n}\nexports.resolve = resolve;\n/**\n * Remove dot segments from the given path,\n * as described in https://www.ietf.org/rfc/rfc3986.txt (page 32).\n * @param {string} path An IRI path.\n * @return {string} A path, will always start with a '/'.\n */\nfunction removeDotSegments(path) {\n    // Prepare a buffer with segments between each '/.\n    // Each segment represents an array of characters.\n    const segmentBuffers = [];\n    let i = 0;\n    while (i < path.length) {\n        // Remove '/.' or '/..'\n        switch (path[i]) {\n            case '/':\n                if (path[i + 1] === '.') {\n                    if (path[i + 2] === '.') {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Go to parent directory,\n                        // so we remove a parent segment\n                        segmentBuffers.pop();\n                        // Ensure that we end with a slash if there is a trailing '/..'\n                        if (!path[i + 3]) {\n                            segmentBuffers.push([]);\n                        }\n                        i += 3;\n                    }\n                    else {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Ensure that we end with a slash if there is a trailing '/.'\n                        if (!path[i + 2]) {\n                            segmentBuffers.push([]);\n                        }\n                        // Go to the current directory,\n                        // so we do nothing\n                        i += 2;\n                    }\n                }\n                else {\n                    // Start a new segment\n                    segmentBuffers.push([]);\n                    i++;\n                }\n                break;\n            case '#':\n            case '?':\n                // Query and fragment string should be appended unchanged\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path.substr(i));\n                // Break the while loop\n                i = path.length;\n                break;\n            default:\n                // Not a special character, just append it to our buffer\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path[i]);\n                i++;\n                break;\n        }\n    }\n    return '/' + segmentBuffers.map((buffer) => buffer.join('')).join('/');\n}\nexports.removeDotSegments = removeDotSegments;\n/**\n * Removes dot segments of the given IRI.\n * @param {string} iri An IRI (or part of IRI).\n * @param {number} colonPosition The position of the first ':' in the IRI.\n * @return {string} The IRI where dot segments were removed.\n */\nfunction removeDotSegmentsOfPath(iri, colonPosition) {\n    // Determine where we should start looking for the first '/' that indicates the start of the path\n    let searchOffset = colonPosition + 1;\n    if (colonPosition >= 0) {\n        if (iri[colonPosition + 1] === '/' && iri[colonPosition + 2] === '/') {\n            searchOffset = colonPosition + 3;\n        }\n    }\n    else {\n        if (iri[0] === '/' && iri[1] === '/') {\n            searchOffset = 2;\n        }\n    }\n    // Determine the path\n    const pathSeparator = iri.indexOf('/', searchOffset);\n    if (pathSeparator < 0) {\n        return iri;\n    }\n    const base = iri.substr(0, pathSeparator);\n    const path = iri.substr(pathSeparator);\n    // Remove dot segments from the path\n    return base + removeDotSegments(path);\n}\nexports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;\nfunction isCharacterAllowedAfterRelativePathSegment(character) {\n    return !character || character === '#' || character === '?' || character === '/';\n}\n//# sourceMappingURL=Resolve.js.map"],"names":["module","exports","serialize","object","toJSON","JSON","stringify","Array","isArray","reduce","t","cv","ci","comma","value","undefined","Object","keys","sort","length","self","support","searchParams","iterable","Symbol","blob","Blob","e","formData","arrayBuffer","isDataView","obj","DataView","prototype","isPrototypeOf","viewClasses","isArrayBufferView","ArrayBuffer","isView","indexOf","toString","call","normalizeName","name","String","test","TypeError","toLowerCase","normalizeValue","iteratorFor","items","iterator","next","shift","done","Headers","headers","this","map","forEach","append","header","getOwnPropertyNames","consumed","body","bodyUsed","Promise","reject","fileReaderReady","reader","resolve","onload","result","onerror","error","readBlobAsArrayBuffer","FileReader","promise","readAsArrayBuffer","readBlobAsText","readAsText","readArrayBufferAsText","buf","view","Uint8Array","chars","i","fromCharCode","join","bufferClone","slice","byteLength","set","buffer","Body","_initBody","_bodyInit","_bodyText","_bodyBlob","FormData","_bodyFormData","URLSearchParams","_bodyArrayBuffer","get","type","rejected","Error","then","text","decode","json","parse","oldValue","has","hasOwnProperty","callback","thisArg","push","values","entries","methods","normalizeMethod","method","upcased","toUpperCase","Request","input","options","url","credentials","mode","signal","referrer","form","trim","split","bytes","replace","decodeURIComponent","parseHeaders","rawHeaders","preProcessedHeaders","line","parts","key","Response","bodyInit","status","ok","statusText","clone","response","redirectStatuses","redirect","RangeError","location","DOMException","err","message","stack","create","constructor","fetch","init","request","aborted","xhr","XMLHttpRequest","abortXhr","abort","getAllResponseHeaders","responseURL","responseText","ontimeout","onabort","open","withCredentials","responseType","setRequestHeader","addEventListener","onreadystatechange","readyState","removeEventListener","send","polyfill","defineProperty","COMPATIBLE_ENCODING_PATTERN","WS_TRIM_PATTERN","WS_CHAR_PATTERN","WS_FOLD_PATTERN","DELIMITER_PATTERN","WS_DELIMITER_PATTERN","TOKEN_PATTERN","STATE","IDLE","URI","ATTR","hasWhitespace","skipWhitespace","offset","needsQuotes","shallowCompareObjects","object1","object2","every","Link","refs","rel","links","attr","link","setUnique","some","ref","state","expandRelations","end","uri","attrValue","isSingleOccurenceAttr","parseExtendedValue","formatAttribute","isCompatibleEncoding","isTokenAttr","escapeQuotes","rels","assign","exec","language","encoding","formatExtendedAttribute","data","encodedValue","Buffer","isBuffer","encodeURIComponent","item","__createBinding","o","m","k","k2","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","__exportStar","p","defaultExpandOptions","ContextParser","relative_to_absolute_iri_1","ErrorCoded_1","FetchDocumentLoader_1","JsonLdContextNormalized_1","Util_1","canonicalizeJson","documentLoader","FetchDocumentLoader","documentCache","validateContext","skipValidation","expandContentTypeToBase","remoteContextsDepthLimit","redirectSchemaOrgHttps","static","strictRange","errorCode","ErrorCoded","Util","REGEX_LANGUAGE_TAG","strictValues","ERROR_CODES","INVALID_BASE_DIRECTION","REGEX_DIRECTION_TAG","idifyReverseTerms","context","isValidKeyword","INVALID_IRI_MAPPING","isPotentialKeyword","expandPrefixedTerms","contextRaw","getContextRaw","EXPAND_KEYS_BLACKLIST","isReservedInternalKeyword","keyValue","ALIAS_DOMAIN_BLACKLIST","KEYWORD_REDEFINITION","ALIAS_RANGE_BLACKLIST","getContextValueId","INVALID_KEYWORD_ALIAS","INVALID_TERM_DEFINITION","isPrefixValue","changed","expandTerm","id","canAddIdEntry","isValidIri","newId","normalize","processingMode","normalizeLanguageTags","containersToHash","newValue","containerValue","applyScopedProtected","isTermProtected","validateKeywordRedefinitions","contextBefore","contextAfter","expandOptions","isPrefix","isSimpleTermDefinitionPrefix","valueBefore","valueAfter","PROTECTED_TERM_REDEFINITION","validate","valueType","substr","INVALID_VOCAB_MAPPING","INVALID_BASE_IRI","validateLanguage","INVALID_DEFAULT_LANGUAGE","INVALID_VERSION_VALUE","validateDirection","INVALID_CONTEXT_ENTRY","INVALID_PROPAGATE_VALUE","getPrefix","CYCLIC_IRI_MAPPING","isValidIriWeak","JsonLdContextNormalized","isCompactIri","objectKey","objectValue","INVALID_TYPE_MAPPING","INVALID_REVERSE_PROPERTY","CONTAINERS_1_0","INVALID_CONTAINER_MAPPING","CONTAINERS","INVALID_LANGUAGE_MAPPING","INVALID_PREFIX_VALUE","INVALID_NEST_VALUE","applyBaseEntry","inheritFromParent","parentContext","baseIRI","external","normalizeContextIri","contextIri","_a","startsWith","async","ignoreScopedContexts","ignoreProtection","ignoreRemoteScopedContexts","INVALID_SCOPED_CONTEXT","minimalProcessing","parentContextInitial","DEFAULT_PROCESSING_MODE","remoteContexts","CONTEXT_OVERFLOW","hasProtectedTerms","INVALID_CONTEXT_NULLIFICATION","overriddenLoad","getOverriddenLoad","parsedStringContext","load","contextIris","contexts","all","subContext","reducedContexts","accContextPromise","contextEntry","accContext","newContext","importContext","INVALID_IMPORT_VALUE","loadImportContext","newContextWrapped","parseInnerContexts","INVALID_LOCAL_CONTEXT","cached","document","LOADING_REMOTE_CONTEXT_FAILED","INVALID_REMOTE_CONTEXT","RECURSIVE_CONTEXT_INCLUSION","importContextIri","allowPrefixForcing","allowPrefixNonGenDelims","allowVocabRelativeToBase","code","super","http_link_header_1","fetcher","accept","mediaType","colonPos","alternateUrl","linkHeader","LOADING_DOCUMENT_FAILED","ContextParser_1","term","expandVocab","contextValue","validIriMapping","prefix","vocab","vocabRelative","base","potentialKeyword","contextPrefixValue","compactIri","iri","shortestPrefixing","suffix","separatorPos","charAt","isPrefixIriEndingWithGenDelim","keyword","KEYWORD_REGEX","prefixIri","ENDS_WITH_GEN_DELIM","Boolean","IRI_REGEX","IRI_REGEX_WEAK","VALID_KEYWORDS","BlankNode","termType","equals","other","DataFactory","BlankNode_1","DefaultGraph_1","Literal_1","NamedNode_1","Quad_1","Variable_1","dataFactoryCounter","blankNodeCounter","blankNodePrefix","namedNode","NamedNode","blankNode","literal","languageOrDatatype","Literal","variable","Variable","defaultGraph","DefaultGraph","INSTANCE","quad","subject","predicate","graph","Quad","fromTerm","original","datatype","XSD_STRING","fromQuad","resetBlankNodeCounter","RDF_LANGUAGE_STRING","relativeIRI","baseFragmentPos","baseQueryPos","relativeColonPos","removeDotSegmentsOfPath","valueColonPos","baseColonPos","baseIRIScheme","baseSlashAfterColonPos","removeDotSegments","baseIRIPath","baseIRILastSlashPos","lastIndexOf","path","segmentBuffers","isCharacterAllowedAfterRelativePathSegment","pop","colonPosition","searchOffset","pathSeparator","character"],"sourceRoot":""}