{"version":3,"file":"main-CJ_e1MxV.js","sources":["../node_modules/@graphy/content.nq.read/main.js"],"sourcesContent":["\n\n\n// queueMicrotask shim\n{\n\t// not defined or not a function\n\tif('function' !== typeof queueMicrotask) {\n\t\t// create resolved promise\n\t\tlet dp_resolve = Promise.resolve();\n\n\t\t// try to redefine\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-global-assign\n\t\t\tqueueMicrotask = fk => dp_resolve.then(fk)\n\t\t\t\t.catch(e_callback => setTimeout(() => {\n\t\t\t\t\tthrow e_callback;\n\t\t\t\t}, 0));\n\t\t}\n\t\t// oh well, at least we tried\n\t\tcatch(e_define) {}\n\t}\n}\n\n\n\nconst stream = require('@graphy/core.iso.stream');\nconst factory = require('@graphy/core.data.factory');\n\nconst RT_ABSOLUTE_IRI_VALID = /^[a-z][a-z0-9+\\-.]*:(?:[^\\0-\\x20<>\"{}|^`\\\\]|\\\\u[A-Fa-f0-9]{4}|\\\\U[A-Fa-f0-9]{8})*$/;\nconst RT_ABSOLUTE_IRI_ESCAPELESS_VALID = /^[a-z][a-z0-9+\\-.]*:[^\\0-\\x20<>\"{}|^`]*$/;\nconst RT_NAMED_NODE_VALID = /^([^\\0-\\x20<>\"{}|^`\\\\]|\\\\u[A-Fa-f0-9]{4}|\\\\U[A-Fa-f0-9]{8})*$/;\nconst RT_NAMED_NODE_ESCAPELESS_VALID = /^([^\\0-\\x20<>\"{}|^`])*$/;\n\nconst R_UNICODE_ANY = /\\\\u([0-9A-Fa-f]{4})|\\\\U([0-9A-Fa-f]{8})/g;\n\nconst F_REPLACE_UNICODE_ANY = \t(s_, s_4, s_8) => String.fromCodePoint(parseInt(s_4 || s_8, 16));\n\n\nconst R_CLEAN = /\\s*(?:#[^\\n]*\\n\\s*)*\\s*/y;\nconst R_CLEAN_COMMENTS = /\\s*(#[^\\n]*\\n\\s*)*\\s*/y;\nconst RT_HAS_ESCAPES = /[\\\\]/;\nconst R_EOL = /[^\\n]+\\n/y;\n\n// eslint-disable-next-line no-misleading-character-class\nconst RT_BLANK_NODE_LABEL_VALID = /^(?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_0-9])(?:(?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}.])*[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}])?$/u;\nconst RT_LANGUAGE_VALID = /^[a-z]+(-[a-z0-9]+)*$/;\n\nconst R_WS = /\\s*/y;\nconst R_HWS = /[ \\t]*/y;\nconst R_LANGTAG = /@([A-Za-z]+(?:-[A-Za-z0-9-]+)*)(?:\\s+|(?=[.,;\\])#]))/y;\n\nconst R_IRIREF = /<([^>]*)>\\s*/y;\n\n\n\nconst F_REPLACE_STRLIT_CONTENTS = (s_, s_whitespace, s_auto, s_4, s_8, s_invalid) => {\n\tif(s_whitespace) {\n\t\tswitch(s_whitespace) {\n\t\t\tcase 't': return '\\t';\n\t\t\tcase 'n': return '\\n';\n\t\t\tcase 'r': return '\\r';\n\t\t\tcase 'f': return '\\f';\n\t\t\tcase 'b': return '\\b';\n\t\t\tdefault: {\n\t\t\t\tconsole.assert(`bad regex escape char mapping: '${s_whitespace}'`);\n\t\t\t}\n\t\t}\n\t}\n\telse if(s_auto) {\n\t\treturn s_auto;\n\t}\n\telse if(s_4) {\n\t\treturn String.fromCodePoint(parseInt(s_4, 16));\n\t}\n\telse if(s_8) {\n\t\treturn String.fromCodePoint(parseInt(s_8, 16));\n\t}\n\telse if(s_invalid) {\n\t\t// pointless escape\n\t\tif('\\\\' === s_invalid[0]) {\n\t\t\t\t// // relaxed\n\t\t\t\t// return s_invalid[1];\n\t\t\t// if relaxed then return s_invalid, otherwise throw:\n\t\t\tthrow new Error(`expected string_literal but invalid escape sequence within contents: '${s_invalid}'. failed to parse a valid token`);\n\t\t}\n\t\t// bad character\n\t\telse {\n\t\t\tthrow new Error(`expected string_literal but invalid whitespace character within contents: ${JSON.stringify(s_invalid)}. failed to parse a valid token`);\n\t\t}\n\t}\n\telse {\n\t\tconsole.assert(`unexpected no match branch in escape sequence replace callback`);\n\t}\n};\n\n\nconst R_STRLIT_SHORT_CONTENTS_ESCAPES_HARD = /(?:\\\\(?:([tnrfb])|([\\\\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|([\\r\\n]|\\\\.))/g;\nconst R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT = /(?:\\\\(?:([tnrfb])|([\\\\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|([\\r\\n]|\\\\[^uU]|\\\\u[^]{4}|\\\\U[^]{8}))/g;\n\nconst unescape_literal_short_hard = s_literal => s_literal\n\t.replace(R_STRLIT_SHORT_CONTENTS_ESCAPES_HARD, F_REPLACE_STRLIT_CONTENTS);\n\nconst unescape_literal_short_soft = (s_literal) => {\n\tlet m_incomplete = R_STRLIT_ESCAPE_INCOMPLETE.exec(s_literal);\n\n\t// incomplete escape\n\tif(m_incomplete) {\n\t\tlet i_safe = m_incomplete.index;\n\n\t\t// rewind\n\t\treturn [\n\t\t\ts_literal.slice(0, i_safe)\n\t\t\t\t.replace(R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),\n\t\t\ts_literal.slice(i_safe),\n\t\t];\n\t}\n\t// done\n\telse {\n\t\treturn [\n\t\t\ts_literal\n\t\t\t\t.replace(R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),\n\t\t\t'',\n\t\t];\n\t}\n};\n\n// lookbehind regexes\nconst [\n\tR_STRLIT_ESCAPE_INCOMPLETE,\n\tR_STRLIT_SHORT_DOUBLE_TERM,\n] = (() => {\n\tfunction RegExp_$lookbehind_polyfill(s_input) {\n\t\tlet m_match = RegExp.prototype.exec.call(this, s_input);\n\n\t\tif(m_match) {\n\t\t\tlet i_start = m_match[0].length - m_match[1].length;\n\t\t\tm_match.index += i_start;\n\t\t\tm_match[0] = m_match[0].slice(i_start);\n\t\t}\n\n\t\treturn m_match;\n\t}\n\tlet mk_lookbehind_regex = (() => {\n\t\ttry {\n\t\t\tnew RegExp('(?<!h)i');  // eslint-disable-line no-new\n\t\t}\n\t\tcatch(e_compile) {\n\t\t\treturn (f_lookbehind, r_polyfill, f_polyfill) => {\n\t\t\t\tr_polyfill.exec = f_polyfill;\n\t\t\t\treturn r_polyfill;\n\t\t\t};\n\t\t}\n\t\treturn f_lookbehind => f_lookbehind();\n\t})();\n\treturn [\n\t\t// R_STRLIT_ESCAPE_INCOMPLETE\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\\\\\\\\(|u[0-9A-Fa-f]{0,3}|U[0-9A-Fa-f]{0,7})$'),\n\t\t\t/^(?:(?:[^\\\\]|\\\\.)*)(\\\\(?:|u[0-9A-Fa-f]{0,3}|U[0-9A-Fa-f]{0,7}))$/,\n\t\t\tfunction RegExp_$lookbehind_polyfill_n(s_input) {\n\t\t\t\tlet m_match = RegExp.prototype.exec.call(this, s_input);\n\t\t\t\tif(m_match) {\n\t\t\t\t\tm_match.index += m_match[0].length - m_match[1].length;\n\t\t\t\t}\n\n\t\t\t\treturn m_match;\n\t\t\t},\n\t\t),\n\t\t// R_STRLIT_SHORT_DOUBLE_TERM\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\"\\\\s*', 'g'),\n\t\t\t/(?:[^\\\\\"]|\\\\.)*(\"\\s*)/y,\n\t\t\tRegExp_$lookbehind_polyfill,\n\t\t),\n\n\t];\n})();\n\n\n\nconst R_QUAD_ESCAPELESS_SP = /(?:<([^\\\\>]*)>|_:([^\\x20\\t<]+))[\\x20\\t]*<([^\\\\>]*)>[\\x20\\t]*(?:(?:(<[^\\\\>]*)>|_:([^\\x20\\t<]+))[\\x20\\t]*(?:<([^\\\\>]*)>|_:([^\\x20\\t<]+)|)[\\x20\\t]*\\.\\s*(#[^\\n]*\\n\\s*|\\n\\s*)+|\"([^\"\\\\]*)(?:(\")(?:\\^\\^<([^\\\\>]*)>|@([^\\x20\\t.]+)|)[\\x20\\t]*(?:<([^\\\\>]*)>|_:([^\\x20\\t<]+)|)[\\x20\\t]*\\.\\s*(#[^\\n]*\\n\\s*|\\n\\s*)+)?)/y;\nconst R_QUAD = /(?:<([^>]*)>|_:([^\\x20\\t<]+))[\\x20\\t]*<([^>]*)>[\\x20\\t]*(?:(?:(<[^>]*)>|_:([^\\x20\\t<]+))[\\x20\\t]*(?:<([^>]*)>|_:([^\\x20\\t<]+)|)[\\x20\\t]*\\.\\s*(#[^\\n]*\\n\\s*|\\n\\s*)+|\"((?:[^\"\\\\]|\\\\.)*)(?:(\")(?:\\^\\^<([^>]*)>|@([^\\x20\\t.]+)|)[\\x20\\t]*(?:<([^>]*)>|_:([^\\x20\\t<]+)|)[\\x20\\t]*\\.\\s*(#[^\\n]*\\n\\s*|\\n\\s*)+)?)/y;\nconst R_BLANK_NODE = /_:([^\\x20\\t<]+)/y;\n\n\n\nclass NQuads_Reader extends stream.Transform {\n\tconstructor(g_impls) {\n\t\tsuper({\n\t\t\t// do not decode strings into buffers\n\t\t\tdecodeStrings: false,\n\n\t\t\t// accept strings as input on writable side\n\t\t\twritableObjectMode: false,\n\n\t\t\t// output quad objects on readable side\n\t\t\treadableObjectMode: true,\n\n\t\t\t// implementations\n\t\t\tflush: g_impls.flush,\n\t\t\ttransform: g_impls.transform,\n\t\t});\n\n\t\t// when the writable side is piped into\n\t\tthis.on('pipe', (ds_input) => {\n\t\t\tthis._ds_input = ds_input;\n\n\t\t\t// input stream has encoding option; ensure stream encoding is utf8\n\t\t\tif('function' === typeof ds_input.setEncoding) {\n\t\t\t\tds_input.setEncoding('utf8');\n\t\t\t}\n\t\t});\n\t}\n\n\t// intercept pipe\n\tpipe(ds_out) {\n\t\tlet ds_dst = ds_out;\n\n\t\t// non-object mode\n\t\tif(!ds_dst._writableState.objectMode) {\n\t\t\t// transform to JSON\n\t\t\tds_out = stream.quads_to_json();\n\t\t}\n\t\t// yet object mode and graphy writable\n\t\telse if(ds_out.isGraphyWritable) {\n\t\t\t// transform to quad-stream\n\t\t\tds_out = stream.quads_to_writable();\n\t\t}\n\n\t\t// interim stream created\n\t\tif(ds_out !== ds_dst) {\n\t\t\t// forward output to super\n\t\t\tsuper.pipe(ds_out);\n\n\t\t\t// pipe outpu to destination\n\t\t\treturn ds_out.pipe(ds_dst);\n\t\t}\n\t\t// forward as-is to super\n\t\telse {\n\t\t\treturn super.pipe(ds_dst);\n\t\t}\n\t}\n}\n\nclass Reader {\n\tconstructor(g_config) {\n\t\tlet {\n\t\t\t// input medium\n\t\t\tinput: g_input=null,\n\n\t\t\t// relax validation\n\t\t\trelax: b_relax=false,\n\n\t\t\t// debug\n\t\t\tdebug: b_debug=false,\n\t\t} = g_config;\n\n\t\t// allow relative iris flag\n\t\tlet b_allow_relative_iris = g_config.allow_relative_iris || g_config.allowRelativeIRIs || g_config.allowRelativeIris || false;\n\n\t\t// adopt factory\n\t\tlet dc_factory = this._dc_factory = factory.adopt(g_config.dataFactory || g_config.data_factory || factory.unfiltered);\n\n\t\tlet f_quad = this._f_quad = dc_factory.quad;\n\n\t\t// fields\n\t\tObject.assign(this, {\n\t\t\t// string buffer, accept left-over string from previous data chunk\n\t\t\ts: g_config.prepend || '',\n\n\t\t\t// string buffer length\n\t\t\tn: 0,\n\n\t\t\t_b_debug: b_debug,\n\n\t\t\t_b_relax: b_relax,\n\n\t\t\t_b_destroyed: false,\n\n\t\t\t_b_trim_start: true,\n\n\t\t\t_f_state: this.statement,\n\n\t\t\t_kt_subject: null,\n\t\t\t_kt_predicate: null,\n\t\t\t_kt_object: null,\n\n\t\t\t_s_literal: '',\n\t\t});\n\n\t\tthis._kt_default_graph = dc_factory.defaultGraph();\n\t\tthis._kt_rdfs_lang_string = dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');\n\n\t\t// clean regex\n\t\tlet r_clean = this._r_clean = R_CLEAN;\n\n\t\tif(g_config.relaxed) {\n\t\t\tconsole.warn((new Error(`no such option 'relaxed'; did you mean 'relax' ?`)).stack.replace(/^Error:/, 'Warning:'));\n\t\t}\n\t\tif('validate' in g_config) {\n\t\t\tconsole.warn((new Error(`option 'validate' has been removed and validation is now on by default. Use 'relax' option if you wish to disable validation.`)).stack.replace(/^Error:/, 'Warning:'));\n\t\t}\n\n\t\tlet namedNode = dc_factory.namedNode;\n\t\tlet blankNode = dc_factory.blankNode;\n\t\tlet languagedLiteral = dc_factory.languagedLiteral;\n\n\t\t// test for valid named node\n\t\tlet rt_named_node_valid = b_allow_relative_iris? RT_NAMED_NODE_VALID: RT_ABSOLUTE_IRI_VALID;\n\n\t\t// test for valid named node escapeless\n\t\tlet rt_named_node_valid_escapeless = b_allow_relative_iris? RT_NAMED_NODE_ESCAPELESS_VALID: RT_ABSOLUTE_IRI_ESCAPELESS_VALID;\n\n\t\t// validation\n\t\tlet k_self = this;\n\t\tObject.assign(this, !b_relax\n\t\t\t? {\n\t\t\t\tcreate_named_node(p_iri) {\n\t\t\t\t\tif(!rt_named_node_valid.test(p_iri)) return k_self._error(`invalid IRI: \"${p_iri}\"`);\n\t\t\t\t\treturn namedNode(p_iri);\n\t\t\t\t},\n\n\t\t\t\tcreate_named_node_escapeless(p_iri) {\n\t\t\t\t\tif(!rt_named_node_valid_escapeless.test(p_iri)) return k_self._error(`invalid IRI: \"${p_iri}\"`);\n\t\t\t\t\treturn namedNode(p_iri);\n\t\t\t\t},\n\n\t\t\t\tcreate_blank_node(s_label) {\n\t\t\t\t\tif(!RT_BLANK_NODE_LABEL_VALID.test(s_label)) return k_self._error(`Invalid blank node label: \"${s_label}\"`);\n\t\t\t\t\treturn blankNode(s_label);\n\t\t\t\t},\n\n\t\t\t\tcreate_languaged_literal(s_contents, s_language) {\n\t\t\t\t\tif(!RT_LANGUAGE_VALID.test(s_language)) {\n\t\t\t\t\t\treturn k_self._error(`Invalid literal language tag: ${s_language}`);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn languagedLiteral(s_contents, s_language);\n\t\t\t\t},\n\t\t\t}\n\t\t\t: {\n\t\t\t\tcreate_named_node: namedNode,\n\n\t\t\t\tcreate_named_node_escapeless: namedNode,\n\n\t\t\t\tcreate_blank_node: blankNode,\n\n\t\t\t\tcreate_languaged_literal: languagedLiteral,\n\t\t\t});\n\n\t\t// transform stream\n\t\tlet ds_transform;\n\n\t\t// whether or not data has been received before\n\t\tlet b_init = false;\n\n\t\t// create transform\n\t\tds_transform = this.transform = new NQuads_Reader({\n\t\t\t// on data event\n\t\t\ttransform: (s_chunk, s_encoding, fk_chunk) => {\n\t\t\t\t// first transform\n\t\t\t\tif(!b_init) {\n\t\t\t\t\t// notify that data will begin\n\t\t\t\t\tds_transform.emit('ready');\n\n\t\t\t\t\t// do not emit 'ready' event again\n\t\t\t\t\tb_init = false;\n\t\t\t\t}\n\n\t\t\t\t// concatenate current chunk to previous chunk\n\t\t\t\tlet s = this.s += s_chunk;\n\n\t\t\t\t// remove whitespace & comments from beginning\n\t\t\t\tif(this._b_trim_start) {\n\t\t\t\t\tr_clean.lastIndex = 0;\n\t\t\t\t\tlet m_clean = r_clean.exec(s);\n\t\t\t\t\tif(this.emit_comments) {\n\t\t\t\t\t\tthis.emit_comments(m_clean[1]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// update index and prepare to match statement\n\t\t\t\t\tthis.i = r_clean.lastIndex;\n\t\t\t\t}\n\t\t\t\t// do not remove whitespace; reset index\n\t\t\t\telse {\n\t\t\t\t\tthis.i = 0;\n\t\t\t\t}\n\n\t\t\t\t// cache chunk length\n\t\t\t\tthis.n = s.length;\n\n\t\t\t\t// resume parsing\n\t\t\t\ttry {\n\t\t\t\t\tthis.parse(true);\n\t\t\t\t}\n\t\t\t\t// read error occurred; emit and destroy stream\n\t\t\t\tcatch(e_read) {\n\t\t\t\t\treturn ds_transform.destroy(e_read);\n\t\t\t\t}\n\n\t\t\t\t// emit progress event updates\n\t\t\t\tds_transform.emit('progress', s_chunk.length);\n\n\t\t\t\t// done transforming this chunk\n\t\t\t\tfk_chunk();\n\t\t\t},\n\n\t\t\t// once there's no more data to consume, invoke eof\n\t\t\tflush: (fk_flush) => {\n\t\t\t\t// there is still unparsed data\n\t\t\t\tif(this.s.length) {\n\t\t\t\t\t// append newline to end so we can match token\n\t\t\t\t\tthis.s += '\\n';\n\n\t\t\t\t\t// remove whitespace & comments from beginning\n\t\t\t\t\tif(this._b_trim_start) {\n\t\t\t\t\t\tr_clean.lastIndex = 0;\n\t\t\t\t\t\tlet m_clean = r_clean.exec(this.s);\n\t\t\t\t\t\tif(this.emit_comments) {\n\t\t\t\t\t\t\tthis.emit_comments(m_clean[1]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// update index and prepare to match statement\n\t\t\t\t\t\tthis.i = r_clean.lastIndex;\n\t\t\t\t\t}\n\t\t\t\t\t// do not remove whitespace; reset index\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.i = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t// parse\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.parse();\n\t\t\t\t\t}\n\t\t\t\t\t// read error occurred; pass to flush errback and exit method\n\t\t\t\t\tcatch(e_read) {\n\t\t\t\t\t\t// destroying during flush means overriding push\n\t\t\t\t\t\treturn ds_transform.demolish(e_read);\n\t\t\t\t\t}\n\n\t\t\t\t\t// still unparsed characters; pass to flush errback and exit method\n\t\t\t\t\tif(this.s.length) {\n\t\t\t\t\t\treturn ds_transform.demolish(new Error(`parsing error occurred in state: statement\\n  ${this.s.substr(0, 50)}\\n  ^ starting here`));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// invalid state\n\t\t\t\tif(this._f_state !== this.statement) {\n\t\t\t\t\treturn ds_transform.demolish(new Error(`parsing error occurred in state: ${this._f_state.name}\\n  ${this.s.substr(0, 50)}\\n  ^ starting here`));\n\t\t\t\t}\n\n\t\t\t\t// make buffer's alloc eligible for gc\n\t\t\t\tthis.s = null;\n\n\t\t\t\t// final progress update: no additional bytes were read\n\t\t\t\tds_transform.emit('progress', 0);\n\n\t\t\t\t// call end event listener\n\t\t\t\tds_transform.emit('eof');\n\n\t\t\t\t// done flushing, close read stream\n\t\t\t\tfk_flush();\n\t\t\t},\n\t\t});\n\n\t\t// destroy\n\t\tds_transform._destroy = (...a_args) => {\n\t\t\tthis.destroy(...a_args);\n\t\t};\n\n\t\t// data quad\n\t\tthis._f_data_quad = (kt_subject, kt_predicate, kt_object, kt_graph) => ds_transform.push(f_quad(kt_subject, kt_predicate, kt_object, kt_graph));\n\n\t\t// new listener added\n\t\tds_transform.on('newListener', (s_event) => {\n\t\t\t// comment\n\t\t\tif('comment' === s_event) {\n\t\t\t\tr_clean = R_CLEAN_COMMENTS;\n\t\t\t\tthis.emit_comments = (s_captured) => {\n\t\t\t\t\tif(!s_captured) return;\n\t\t\t\t\tlet a_comments = s_captured.slice(1).replace(/\\n\\s+$/, '').split(/\\n+\\s*#/g);\n\n\t\t\t\t\tfor(let s_comment of a_comments) {\n\t\t\t\t\t\tds_transform.emit('comment', s_comment);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\t// bind events to transform stream\n\t\tthis.bind(g_config);\n\n\t\t// input given\n\t\tif(g_input) {\n\t\t\t// input is stream\n\t\t\tif(g_input.stream) {\n\t\t\t\tlet ds_input = g_input.stream;\n\n\t\t\t\t// go async so caller has chance to bind event listeners\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tds_input.pipe(ds_transform);\n\t\t\t\t});\n\t\t\t}\n\t\t\t// string\n\t\t\telse if('string' === typeof g_input.string) {\n\t\t\t\tlet s_input = g_input.string;\n\n\t\t\t\t// go async so caller has chance to bind event listeners\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tds_transform.end(s_input, 'utf8');\n\t\t\t\t});\n\t\t\t}\n\t\t\t// invalid arg\n\t\t\telse {\n\t\t\t\tthrow new TypeError(`Invalid argument for input parameter: ${'object' === typeof g_input? JSON.stringify(g_input): g_input}`);\n\t\t\t}\n\t\t}\n\n\t\tds_transform._graphy_reader = this;\n\t}\n\n\t_error(s_message) {\n\t\tthis._b_destroyed = true;\n\t\tthrow new Error(s_message);\n\t}\n\n\n\n\tbind(g_config) {\n\t\tlet ds_transform = this.transform;\n\t\tif(g_config.error) ds_transform.on('error', g_config.error);\n\t\tif(g_config.comment) ds_transform.on('comment', g_config.comment);\n\t\tif(g_config.read) ds_transform.once('read', g_config.read);\n\t\tif(g_config.progress) ds_transform.on('progress', g_config.progress);\n\t\tif(g_config.eof) ds_transform.once('eof', g_config.eof);\n\t\tif(g_config.end) ds_transform.once('end', g_config.end);\n\t\tif(g_config.finish) ds_transform.once('finish', g_config.finish);\n\t\tif(g_config.data) ds_transform.on('data', g_config.data);\n\t}\n\n\t// begin parsing, keep applying until no more stack bail-outs\n\tparse() {\n\t\tlet f_sync = this._f_state();\n\t\twhile('function' === typeof f_sync) {\n\t\t\tf_sync = f_sync.apply(this);\n\t\t}\n\t}\n\n\tstatement() {\n\t\tlet s = this.s;\n\t\tlet n = this.n;\n\t\tlet i = this.i;\n\t\tlet f_data_quad = this._f_data_quad;\n\t\tlet create_named_node = this.create_named_node;\n\t\tlet create_named_node_escapeless = this.create_named_node_escapeless;\n\t\tlet create_languaged_literal = this.create_languaged_literal;\n\t\tlet create_blank_node = this.create_blank_node;\n\t\tlet simpleLiteral = this._dc_factory.simpleLiteral;\n\t\tlet datatypedLiteral = this._dc_factory.datatypedLiteral;\n\t\tlet kt_default_graph = this._kt_default_graph;\n\n\t\t// match triples/quads\n\t\tfor(;;) {\n\t\t\t// prepare sticky regex index\n\t\t\tR_QUAD_ESCAPELESS_SP.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_statement_e_sp = R_QUAD_ESCAPELESS_SP.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_statement_e_sp) {\n\t\t\t\t// advance index\n\t\t\t\ti = R_QUAD_ESCAPELESS_SP.lastIndex;\n\n\t\t\t\t// prep object term\n\t\t\t\tlet kt_object;\n\t\t\t\t// where to find the graph component\n\t\t\t\tlet b_graph_late = false;\n\n\t\t\t\t// object term type is named node\n\t\t\t\tif(m_statement_e_sp[4]) {\n\t\t\t\t\tlet p_object = m_statement_e_sp[4].slice(1);\n\t\t\t\t\tkt_object = create_named_node_escapeless(p_object);\n\t\t\t\t}\n\t\t\t\t// object term type is blank node\n\t\t\t\telse if(m_statement_e_sp[5]) {\n\t\t\t\t\tkt_object = create_blank_node(m_statement_e_sp[5]);\n\t\t\t\t}\n\t\t\t\t// object term type is literal\n\t\t\t\telse {\n\t\t\t\t\t// graph is in late capture group\n\t\t\t\t\tb_graph_late = true;\n\n\t\t\t\t\t// contents\n\t\t\t\t\tlet s_contents = m_statement_e_sp[9];\n\t\t\t\t\t// string terminator\n\t\t\t\t\tif(m_statement_e_sp[10]) {\n\t\t\t\t\t\t// datatype is present\n\t\t\t\t\t\tif(m_statement_e_sp[11]) {\n\t\t\t\t\t\t\t// create datatype term\n\t\t\t\t\t\t\tlet kt_datatype = this.create_named_node_escapeless(m_statement_e_sp[11]);\n\t\t\t\t\t\t\t// create object term\n\t\t\t\t\t\t\tkt_object = datatypedLiteral(s_contents, kt_datatype);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// language tag is present\n\t\t\t\t\t\telse if(m_statement_e_sp[12]) {\n\t\t\t\t\t\t\t// normalize language\n\t\t\t\t\t\t\tlet s_language = m_statement_e_sp[12].toLowerCase();\n\t\t\t\t\t\t\t// create object term\n\t\t\t\t\t\t\tkt_object = create_languaged_literal(s_contents, s_language);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// simple literal\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tkt_object = simpleLiteral(s_contents);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// no string terminator\n\t\t\t\t\telse {\n\t\t\t\t\t\t// save contents\n\t\t\t\t\t\tthis._s_literal = s_contents;\n\t\t\t\t\t\t// update index\n\t\t\t\t\t\tthis.i = i;\n\t\t\t\t\t\t// save subject\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet s_subject = m_statement_e_sp[1];\n\t\t\t\t\t\t\t// named node\n\t\t\t\t\t\t\tif(s_subject || 'string' === typeof s_subject) {\n\t\t\t\t\t\t\t\tthis._kt_subject = create_named_node_escapeless(s_subject);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// blank node\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthis._kt_subject = create_blank_node(m_statement_e_sp[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// save predicate\n\t\t\t\t\t\tthis._kt_predicate = create_named_node_escapeless(m_statement_e_sp[3]);\n\t\t\t\t\t\t// parse contents\n\t\t\t\t\t\tlet z_bail = this.strlit_contents();\n\t\t\t\t\t\t// bail out of stack\n\t\t\t\t\t\tif(z_bail && this.statement !== z_bail) {\n\t\t\t\t\t\t\treturn z_bail;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// statement completed\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// clean\n\t\t\t\t\t\t\tlet r_clean = this._r_clean;\n\t\t\t\t\t\t\tr_clean.lastIndex = this.i;\n\t\t\t\t\t\t\tlet m_clean = r_clean.exec(s);\n\t\t\t\t\t\t\tif(this.emit_comments) {\n\t\t\t\t\t\t\t\tthis.emit_comments(m_clean[1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// update local index and prepare to match next statement\n\t\t\t\t\t\t\ti = r_clean.lastIndex;\n\t\t\t\t\t\t\t// resume\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet kt_graph = kt_default_graph;\n\n\t\t\t\t// graph after literal\n\t\t\t\tif(b_graph_late) {\n\t\t\t\t\t// ref capture group\n\t\t\t\t\tlet s_graph = m_statement_e_sp[13];\n\n\t\t\t\t\t// named node\n\t\t\t\t\tif(s_graph || 'string' === typeof s_graph) {\n\t\t\t\t\t\tkt_graph = create_named_node_escapeless(s_graph);\n\t\t\t\t\t}\n\t\t\t\t\t// blank node\n\t\t\t\t\telse if(m_statement_e_sp[14]) {\n\t\t\t\t\t\tkt_graph = create_blank_node(m_statement_e_sp[14]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// graph after node\n\t\t\t\telse {\n\t\t\t\t\t// ref capture group\n\t\t\t\t\tlet s_graph = m_statement_e_sp[6];\n\n\t\t\t\t\t// named node\n\t\t\t\t\tif(s_graph || 'string' === typeof s_graph) {\n\t\t\t\t\t\tkt_graph = create_named_node_escapeless(s_graph);\n\t\t\t\t\t}\n\t\t\t\t\t// blank node\n\t\t\t\t\telse if(m_statement_e_sp[7]) {\n\t\t\t\t\t\tkt_graph = create_blank_node(m_statement_e_sp[7]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet kt_subject;\n\t\t\t\t{\n\t\t\t\t\tlet s_subject = m_statement_e_sp[1];\n\t\t\t\t\t// named node\n\t\t\t\t\tif(s_subject || 'string' === typeof s_subject) {\n\t\t\t\t\t\tkt_subject = create_named_node_escapeless(s_subject);\n\t\t\t\t\t}\n\t\t\t\t\t// blank node\n\t\t\t\t\telse {\n\t\t\t\t\t\tkt_subject = create_blank_node(m_statement_e_sp[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet s_predicate = m_statement_e_sp[3];\n\t\t\t\t// emit data event\n\t\t\t\tf_data_quad(\n\t\t\t\t\tkt_subject,\n\t\t\t\t\tcreate_named_node_escapeless(s_predicate),\n\t\t\t\t\tkt_object,\n\t\t\t\t\tkt_graph,\n\t\t\t\t);\n\t\t\t\t// comments\n\t\t\t\tif(this.emit_comments) {\n\t\t\t\t\tthis.emit_comments(m_statement_e_sp[8] || m_statement_e_sp[15]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_QUAD.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_statement = R_QUAD.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_statement) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_QUAD.lastIndex;\n\n\t\t\t\t\t// prep object term\n\t\t\t\t\tlet kt_object;\n\t\t\t\t\t// where to find the graph component\n\t\t\t\t\tlet b_graph_late = false;\n\n\t\t\t\t\t// object term type is named node\n\t\t\t\t\tif(m_statement[4]) {\n\t\t\t\t\t\tlet p_object = m_statement[4].slice(1);\n\t\t\t\t\t\tkt_object = create_named_node(RT_HAS_ESCAPES.test(p_object)? p_object.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY): p_object);\n\t\t\t\t\t}\n\t\t\t\t\t// object term type is blank node\n\t\t\t\t\telse if(m_statement[5]) {\n\t\t\t\t\t\tkt_object = create_blank_node(RT_HAS_ESCAPES.test(m_statement[5])? m_statement[5].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY): m_statement[5]);\n\t\t\t\t\t}\n\t\t\t\t\t// object term type is literal\n\t\t\t\t\telse {\n\t\t\t\t\t\t// graph is in late capture group\n\t\t\t\t\t\tb_graph_late = true;\n\n\t\t\t\t\t\t// contents\n\t\t\t\t\t\tlet s_contents = m_statement[9];\n\t\t\t\t\t\t// string terminator\n\t\t\t\t\t\tif(m_statement[10]) {\n\t\t\t\t\t\t\t// unescape contents\n\t\t\t\t\t\t\ts_contents = unescape_literal_short_hard(s_contents);\n\n\t\t\t\t\t\t\t// datatype is present\n\t\t\t\t\t\t\tif(m_statement[11]) {\n\t\t\t\t\t\t\t\t// create datatype term\n\t\t\t\t\t\t\t\tlet kt_datatype = this.create_named_node(m_statement[11]);\n\t\t\t\t\t\t\t\t// create object term\n\t\t\t\t\t\t\t\tkt_object = datatypedLiteral(s_contents, kt_datatype);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// language tag is present\n\t\t\t\t\t\t\telse if(m_statement[12]) {\n\t\t\t\t\t\t\t\t// normalize language\n\t\t\t\t\t\t\t\tlet s_language = m_statement[12].toLowerCase();\n\t\t\t\t\t\t\t\t// create object term\n\t\t\t\t\t\t\t\tkt_object = create_languaged_literal(s_contents, s_language);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// simple literal\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tkt_object = simpleLiteral(s_contents);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// no string terminator\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// save contents\n\t\t\t\t\t\t\tthis._s_literal = s_contents;\n\t\t\t\t\t\t\t// update index\n\t\t\t\t\t\t\tthis.i = i;\n\t\t\t\t\t\t\t// save subject\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlet s_subject = m_statement[1];\n\t\t\t\t\t\t\t\t// named node\n\t\t\t\t\t\t\t\tif(s_subject || 'string' === typeof s_subject) {\n\t\t\t\t\t\t\t\t\tthis._kt_subject = create_named_node(RT_HAS_ESCAPES.test(s_subject)? s_subject.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY): s_subject);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// blank node\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tthis._kt_subject = create_blank_node(m_statement[2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// save predicate\n\t\t\t\t\t\t\tthis._kt_predicate = create_named_node(RT_HAS_ESCAPES.test(m_statement[3])? m_statement[3].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY): m_statement[3]);\n\t\t\t\t\t\t\t// parse contents\n\t\t\t\t\t\t\tlet z_bail = this.strlit_contents();\n\t\t\t\t\t\t\t// bail out of stack\n\t\t\t\t\t\t\tif(z_bail && this.statement !== z_bail) {\n\t\t\t\t\t\t\t\treturn z_bail;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// statement completed\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// clean\n\t\t\t\t\t\t\t\tlet r_clean = this._r_clean;\n\t\t\t\t\t\t\t\tr_clean.lastIndex = this.i;\n\t\t\t\t\t\t\t\tlet m_clean = r_clean.exec(s);\n\t\t\t\t\t\t\t\tif(this.emit_comments) {\n\t\t\t\t\t\t\t\t\tthis.emit_comments(m_clean[1]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// update local index and prepare to match next statement\n\t\t\t\t\t\t\t\ti = r_clean.lastIndex;\n\t\t\t\t\t\t\t\t// resume\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet kt_graph = kt_default_graph;\n\n\t\t\t\t\t// graph after literal\n\t\t\t\t\tif(b_graph_late) {\n\t\t\t\t\t\t// ref capture group\n\t\t\t\t\t\tlet s_graph = m_statement[13];\n\n\t\t\t\t\t\t// named node\n\t\t\t\t\t\tif(s_graph || 'string' === typeof s_graph) {\n\t\t\t\t\t\t\tkt_graph = create_named_node(RT_HAS_ESCAPES.test(s_graph)? s_graph.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY): s_graph);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// blank node\n\t\t\t\t\t\telse if(m_statement[14]) {\n\t\t\t\t\t\t\tkt_graph = create_blank_node(m_statement[14]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// graph after node\n\t\t\t\t\telse {\n\t\t\t\t\t\t// ref capture group\n\t\t\t\t\t\tlet s_graph = m_statement[6];\n\n\t\t\t\t\t\t// named node\n\t\t\t\t\t\tif(s_graph || 'string' === typeof s_graph) {\n\t\t\t\t\t\t\tkt_graph = create_named_node(RT_HAS_ESCAPES.test(s_graph)? s_graph.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY): s_graph);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// blank node\n\t\t\t\t\t\telse if(m_statement[7]) {\n\t\t\t\t\t\t\tkt_graph = create_blank_node(m_statement[7]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet kt_subject;\n\t\t\t\t\t{\n\t\t\t\t\t\tlet s_subject = m_statement[1];\n\t\t\t\t\t\t// named node\n\t\t\t\t\t\tif(s_subject || 'string' === typeof s_subject) {\n\t\t\t\t\t\t\tkt_subject = create_named_node(RT_HAS_ESCAPES.test(s_subject)? s_subject.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY): s_subject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// blank node\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tkt_subject = create_blank_node(m_statement[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet s_predicate = m_statement[3];\n\t\t\t\t\t// emit data event\n\t\t\t\t\tf_data_quad(\n\t\t\t\t\t\tkt_subject,\n\t\t\t\t\t\tcreate_named_node(RT_HAS_ESCAPES.test(s_predicate)? s_predicate.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY): s_predicate),\n\t\t\t\t\t\tkt_object,\n\t\t\t\t\t\tkt_graph,\n\t\t\t\t\t);\n\t\t\t\t\t// comments\n\t\t\t\t\tif(this.emit_comments) {\n\t\t\t\t\t\tthis.emit_comments(m_statement[8] || m_statement[15]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_EOL.lastIndex = i;\n\n\t\t\t\t\tif(R_EOL.exec(s)) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_EOL.lastIndex;\n\t\t\t\t\t\tthis._error(`Failed to read statement:\\n\\`${s.substr(i, 80).replace(/\\n/g, '\\u23CE')} [...]\\`\\n ^ starting here`);\n\n\t\t\t\t\t// match counter: 2\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t} // end of while\n\n\t\t// update unparsed data string\n\t\tthis.s = s.substr(i);\n\n\t\t// resume here\n\t\tthis._f_state = this.statement;\n\n\t\t// exit\n\t\treturn 1;\n\t}\n\n\n\tstrlit_contents() {\n\t\tlet {s, n, i} = this;\n\n\t\t// try to find end\n\t\tR_STRLIT_SHORT_DOUBLE_TERM.lastIndex = i;\n\t\tlet m_term = R_STRLIT_SHORT_DOUBLE_TERM.exec(s);\n\n\t\t// end is in this chunk\n\t\tif(m_term) {\n\t\t\t// index of terminator\n\t\t\tlet i_term = m_term.index;\n\n\t\t\t// extract dirty potion\n\t\t\tlet s_dirty = s.slice(i, i_term);\n\n\t\t\t// clean and save\n\t\t\tthis._s_literal += unescape_literal_short_hard(s_dirty);\n\n\t\t\t// advance index beyond terminator\n\t\t\tthis.i = i_term + m_term[0].length;\n\n\t\t\t// resume eating whitespace at start of next chunk\n\t\t\tthis._b_trim_start = true;\n\n\t\t\t// proceed with datatype_or_lang, then bail out of stack or resume parsing\n\t\t\treturn this.datatype_or_langtag() || this.statement;\n\t\t}\n\t\t// end is not in this chunk\n\t\telse {\n\t\t\t// extract whole portion\n\t\t\tlet s_dirty = s.slice(i);\n\n\t\t\t// unescape to clean part\n\t\t\tlet [s_clean, s_incomplete] = unescape_literal_short_soft(s_dirty);\n\n\t\t\t// save\n\t\t\tthis._s_literal += s_clean;\n\n\t\t\t// set unparsed index\n\t\t\tthis.i = i = n - s_incomplete.length;\n\n\t\t\t// do not eat whitespace at start of next chunk\n\t\t\tthis._b_trim_start = false;\n\t\t}\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('strlit_contents');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// resume here\n\t\tthis._f_state = this.strlit_contents;\n\n\t\t// store what is unparsed\n\t\tthis.s = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn 1;\n\t}\n\n\n\n\t// parse state for datatype_or_langtag\n\tdatatype_or_langtag() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// ref character\n\t\tlet x = s[i];\n\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// datatype\n\t\t\tif('^' === x) {\n\t\t\t\t// enough to speculate datatype\n\t\t\t\tif((i+2) < n) {\n\t\t\t\t\t// correct token\n\t\t\t\t\tif('^' === s[i+1]) {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tR_IRIREF.lastIndex = i + 2;\n\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_iriref = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_iriref) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t// prepare iri\n\t\t\t\t\t\t\tlet p_datatype = m_iriref[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\n\t\t\t\t\t\t\t// create datatype term\n\t\t\t\t\t\t\tlet kt_datatype = this.create_named_node(p_datatype);\n\n\t\t\t\t\t\t\t// create object term\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.datatypedLiteral(this._s_literal, kt_datatype);\n\n\t\t\t\t\t\t\t// free literal string\n\t\t\t\t\t\t\tthis._s_literal = '';\n\n\t\t\t\t\t\t\t// graph state\n\t\t\t\t\t\t\treturn this.post_object();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// failed to match; try again next chunk\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// invalid\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis._error(`Failed to read token after literal:\\n\\`${s.substr(i+1, 80).replace(/\\n/g, '\\u23CE')} [...]\\`\\n ^ starting here`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// not enough to speculate; try again next chunk\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// language tag\n\t\t\telse if('@' === x) {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_LANGTAG.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_langtag = R_LANGTAG.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_langtag) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_LANGTAG.lastIndex;\n\n\t\t\t\t\t// use direct factory method since regex is validation\n\t\t\t\t\tthis._kt_object = this._dc_factory.languagedLiteral(this._s_literal, m_langtag[1]);\n\n\t\t\t\t\t// free literal string\n\t\t\t\t\tthis._s_literal = '';\n\n\t\t\t\t\t// graph state\n\t\t\t\t\treturn this.post_object();\n\t\t\t\t}\n\t\t\t\t// interrupted by eos; try again next chunk\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// graph component\n\t\t\telse if('<' === x || '_' === x) {\n\t\t\t\t// save simple literal\n\t\t\t\tthis._kt_object = this._dc_factory.simpleLiteral(this._s_literal);\n\n\t\t\t\t// free literal string\n\t\t\t\tthis._s_literal = '';\n\n\t\t\t\t// continue parsing graph component\n\t\t\t\treturn this.graph();\n\t\t\t}\n\t\t\t// triple terminator\n\t\t\telse if('.' === x) {\n\t\t\t\t// save simple literal\n\t\t\t\tlet kt_object = this._dc_factory.simpleLiteral(this._s_literal);\n\n\t\t\t\t// free literal string\n\t\t\t\tthis._s_literal = '';\n\n\t\t\t\t// advance index beyond terminator\n\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t// emit data event\n\t\t\t\tthis._f_data_quad(this._kt_subject, this._kt_predicate, kt_object, this._kt_default_graph);\n\n\t\t\t\t// reset state\n\t\t\t\treturn this.statement;\n\n\t\t\t\t// // consume whitespace (and incidentally reset index)\n\t\t\t\t// R_WS.lastIndex = i + 1;\n\t\t\t\t// R_WS.exec(s);\n\t\t\t\t// this.i = R_WS.lastIndex;\n\n\t\t\t\t// // done\n\t\t\t\t// return;\n\t\t\t}\n\t\t\t// other\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// ran out of characters\n\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('datatype_or_langtag');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// resume here\n\t\tthis._f_state = this.datatype_or_langtag;\n\n\t\t// store what is unparsed\n\t\tthis.s = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn 1;\n\t}\n\n\tstatement_term() {\n\t\tlet {s, n, i} = this;\n\n\t\t// find full stop\n\t\tlet i_stop = s.indexOf('.', i);\n\n\t\t// found\n\t\tif(i_stop > -1) {\n\t\t\t// consume whitespace again\n\t\t\tthis._b_trim_start = true;\n\n\t\t\t// advance beyond token\n\t\t\tthis.i = i_stop + 1;\n\n\t\t\t// reset state\n\t\t\treturn this.statement;\n\t\t}\n\t\t// anything other than whitespace\n\t\telse if(!/^\\s*$/.test(s.slice(i))) {\n\t\t\tthis.parse_error('statement_term');\n\t\t}\n\n\t\t// do not consume whitespace\n\t\tthis._b_trim_start = false;\n\n\t\t// resume here\n\t\tthis._f_state = this.statement_term;\n\n\t\t// store what is unparsed\n\t\tthis.s = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn 1;\n\t}\n\n\tpost_object() {\n\t\tlet {s, n, i} = this;\n\n\t\t// eat horizontal whitespace\n\t\tR_HWS.lastIndex = i;\n\t\tR_HWS.exec(s);\n\t\ti = R_HWS.lastIndex;\n\n\t\t// ran out of characters\n\t\tif(i >= n) {\n\t\t\t// resume here\n\t\t\tthis._f_state = this.post_object;\n\n\t\t\t// store what is unparsed\n\t\t\tthis.s = s.slice(i);\n\n\t\t\t// if we're not parsing a stream, then this is an error\n\t\t\tif(this.eos) this.eos();\n\t\t\treturn 1;\n\t\t}\n\n\t\t// depending on char\n\t\tswitch(s[i]) {\n\t\t\t// statement term\n\t\t\tcase '.': {\n\t\t\t\t// advance index beyond terminator\n\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t// emit data event\n\t\t\t\tthis._f_data_quad(this._kt_subject, this._kt_predicate, this._kt_object, this._kt_default_graph);\n\n\t\t\t\t// reset state\n\t\t\t\treturn this.statement;\n\t\t\t}\n\n\t\t\t// graph\n\t\t\tcase '<':\n\t\t\tcase '_': {\n\t\t\t\t// save index\n\t\t\t\tthis.i = i;\n\n\t\t\t\t// consume graph component\n\t\t\t\treturn this.graph();\n\t\t\t}\n\n\t\t\t// invalid\n\t\t\tdefault: {\n\t\t\t\t// save index\n\t\t\t\tthis.i = i;\n\n\t\t\t\t// emit parsing error\n\t\t\t\tthis.parse_error('post_object');\n\t\t\t}\n\t\t}\n\t}\n\n\tgraph() {\n\t\tlet {s, n, i} = this;\n\n\n\t\t// prepare sticky regex index\n\t\tR_IRIREF.lastIndex = i;\n\t\t// execute regex\n\t\tlet m_iriref = R_IRIREF.exec(s);\n\n\t\t// regex was a match\n\t\tif(m_iriref) {\n\t\t\t// advance index\n\t\t\tthis.i = R_IRIREF.lastIndex;\n\t\t\t// create graph term\n\t\t\tlet kt_graph = this.create_named_node(m_iriref[1]);\n\n\t\t\t// emit data event\n\t\t\tthis._f_data_quad(this._kt_subject, this._kt_predicate, this._kt_object, kt_graph);\n\n\t\t\t// complete with statement_term\n\t\t\treturn this.statement_term();\n\t\t}\n\t\telse {\n\t\t\t// prepare sticky regex index\n\t\t\tR_BLANK_NODE.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_blank = R_BLANK_NODE.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_blank) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_BLANK_NODE.lastIndex;\n\t\t\t\t// create graph term\n\t\t\t\tlet kt_graph = this._dc_factory.blankNode(m_blank[1]);\n\n\t\t\t\t// emit data event\n\t\t\t\tthis._f_data_quad(this._kt_subject, this._kt_predicate, this._kt_object, kt_graph);\n\n\t\t\t\t// complete with statement_term\n\t\t\t\treturn this.statement_term();\n\t\t\t}\n\t\t} // brace #1\n\n\n\t\t// resume here\n\t\tthis._f_state = this.graph;\n\n\t\t// store what is unparsed\n\t\tthis.s = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn 1;\n\t}\n\n\tparse_error(s_state) {\n\t\treturn this._error(`Failed to read ${s_state}:\\n\\`${this.s.substr(this.i, 80).replace(/\\n/g, '\\u23CE')} [...]\\`\\n ^ starting here`);\n\t}\n\n\tdestroy(e_destroy) {\n\t\tthis._f_data_quad = () => {};\n\n\t\tif(!e_destroy && this._ds_input) {\n\t\t\tthis._ds_input.destroy(e_destroy);\n\t\t}\n\n\t\tthis.transform.demolish(e_destroy);\n\t}\n}\n\n\nmodule.exports = function(...a_args) {\n\tlet g_config = {};\n\n\t// at least one argument\n\tif(a_args.length) {\n\t\tlet z_arg_0 = a_args[0];\n\n\t\t// input given unspecified\n\t\tif(z_arg_0 && z_arg_0.input && 'undefined' === typeof z_arg_0.input.string && !z_arg_0.input.stream) {\n\t\t\tz_arg_0 = z_arg_0.input;\n\t\t}\n\n\t\t// string\n\t\tif('string' === typeof z_arg_0) {\n\t\t\tg_config.input = {string:z_arg_0};\n\t\t}\n\t\t// null\n\t\telse if(null === z_arg_0) {\n\t\t\tg_config.input = null;\n\t\t}\n\t\t// node stream\n\t\telse if('function' === typeof z_arg_0.setEncoding) {\n\t\t\tg_config.input = {stream:z_arg_0};\n\t\t}\n\t\t// whatwg stream\n\t\telse if('function' === typeof z_arg_0.pipeTo) {\n\t\t\tthrow new TypeError(`Sorry, WHATWG streams are currently not supported :(`);\n\t\t// g_config.input = {stream:z_arg_0};\n\t\t}\n\t\t// config struct\n\t\telse if(z_arg_0 && 'object' === typeof z_arg_0 && '[object Object]' === Object.prototype.toString.call(z_arg_0)) {\n\t\t\tg_config = z_arg_0;\n\n\t\t\t// more args; invalid\n\t\t\tif(a_args.length > 1) {\n\t\t\t\tthrow new TypeError(`unexpected argument(s) after config struct: ${a_args.slice(1)}`);\n\t\t\t}\n\t\t}\n\t\t// unknown\n\t\telse {\n\t\t\tthrow new TypeError(`unexpected input type: ${z_arg_0}`);\n\t\t}\n\n\t\t// more args\n\t\tif(a_args.length > 1) {\n\t\t\t// copy onto struct\n\t\t\tObject.assign(g_config, a_args[1]);\n\n\t\t\t// more args\n\t\t\tif(a_args.length > 2) {\n\t\t\t\tthrow new TypeError(`unexpected argument(s) after input and config struct: ${a_args.slice(2)}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t// create reader, return transform stream\n\treturn (new Reader(g_config)).transform;\n};\n"],"names":["dp_resolve","fk","e_callback","stream","require$$0","factory","require$$1","RT_ABSOLUTE_IRI_VALID","RT_ABSOLUTE_IRI_ESCAPELESS_VALID","RT_NAMED_NODE_VALID","RT_NAMED_NODE_ESCAPELESS_VALID","R_UNICODE_ANY","F_REPLACE_UNICODE_ANY","s_","s_4","s_8","R_CLEAN","R_CLEAN_COMMENTS","RT_HAS_ESCAPES","R_EOL","RT_BLANK_NODE_LABEL_VALID","RT_LANGUAGE_VALID","R_HWS","R_LANGTAG","R_IRIREF","F_REPLACE_STRLIT_CONTENTS","s_whitespace","s_auto","s_invalid","R_STRLIT_SHORT_CONTENTS_ESCAPES_HARD","R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT","unescape_literal_short_hard","s_literal","unescape_literal_short_soft","m_incomplete","R_STRLIT_ESCAPE_INCOMPLETE","i_safe","R_STRLIT_SHORT_DOUBLE_TERM","RegExp_$lookbehind_polyfill","s_input","m_match","i_start","mk_lookbehind_regex","f_lookbehind","r_polyfill","f_polyfill","R_QUAD_ESCAPELESS_SP","R_QUAD","R_BLANK_NODE","NQuads_Reader","g_impls","ds_input","ds_out","ds_dst","Reader","g_config","g_input","b_relax","b_debug","b_allow_relative_iris","dc_factory","f_quad","r_clean","namedNode","blankNode","languagedLiteral","rt_named_node_valid","rt_named_node_valid_escapeless","k_self","p_iri","s_label","s_contents","s_language","ds_transform","b_init","s_chunk","s_encoding","fk_chunk","s","m_clean","e_read","fk_flush","a_args","kt_subject","kt_predicate","kt_object","kt_graph","s_event","s_captured","a_comments","s_comment","s_message","f_sync","i","f_data_quad","create_named_node","create_named_node_escapeless","create_languaged_literal","create_blank_node","simpleLiteral","datatypedLiteral","kt_default_graph","m_statement_e_sp","b_graph_late","p_object","kt_datatype","s_subject","z_bail","s_graph","s_predicate","m_statement","n","m_term","i_term","s_dirty","s_clean","s_incomplete","x","m_iriref","p_datatype","m_langtag","i_stop","m_blank","s_state","e_destroy","main","z_arg_0"],"mappings":"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","x_google_ignoreList":[0]}