var pW = Object.defineProperty;
var gW = (e, t, r) => t in e ? pW(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var As = (e, t, r) => (gW(e, typeof t != "symbol" ? t + "" : t, r), r);
const $E = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get _void() {
    return FG;
  },
  get acl() {
    return u9;
  },
  get as() {
    return c9;
  },
  get bibo() {
    return h9;
  },
  get cc() {
    return g9;
  },
  get cert() {
    return y9;
  },
  get cnt() {
    return m9;
  },
  get constant() {
    return w9;
  },
  get crm() {
    return E9;
  },
  get csvw() {
    return R9;
  },
  get ctag() {
    return T9;
  },
  get dash() {
    return C9;
  },
  get dashSparql() {
    return N9;
  },
  get dbo() {
    return M9;
  },
  get dc11() {
    return L9;
  },
  get dcam() {
    return D9;
  },
  get dcat() {
    return j9;
  },
  get dcmitype() {
    return q9;
  },
  get dcterms() {
    return U9;
  },
  get default() {
    return w3;
  },
  get dig() {
    return V9;
  },
  get discipline() {
    return G9;
  },
  get doap() {
    return Y9;
  },
  get dpv() {
    return J9;
  },
  get dqv() {
    return Z9;
  },
  get dtype() {
    return tV;
  },
  get duv() {
    return nV;
  },
  get earl() {
    return oV;
  },
  get ebucore() {
    return aV;
  },
  get exif() {
    return uV;
  },
  get foaf() {
    return cV;
  },
  get frbr() {
    return hV;
  },
  get geo() {
    return gV;
  },
  get geof() {
    return yV;
  },
  get geor() {
    return mV;
  },
  get gml() {
    return wV;
  },
  get gn() {
    return EV;
  },
  get gr() {
    return RV;
  },
  get grddl() {
    return TV;
  },
  get gs1() {
    return NV;
  },
  get gtfs() {
    return CV;
  },
  get http() {
    return MV;
  },
  get hydra() {
    return LV;
  },
  get ical() {
    return DV;
  },
  get la() {
    return jV;
  },
  get ldp() {
    return qV;
  },
  get list() {
    return UV;
  },
  get locn() {
    return VV;
  },
  get log() {
    return GV;
  },
  get lvont() {
    return YV;
  },
  get m4i() {
    return JV;
  },
  get ma() {
    return ZV;
  },
  get mads() {
    return tz;
  },
  get math() {
    return nz;
  },
  get oa() {
    return oz;
  },
  get og() {
    return az;
  },
  get oidc() {
    return uz;
  },
  get org() {
    return cz;
  },
  get owl() {
    return hz;
  },
  get pim() {
    return gz;
  },
  get prefix() {
    return yz;
  },
  get prov() {
    return mz;
  },
  get qb() {
    return wz;
  },
  get qkdv() {
    return Ez;
  },
  get quantitykind() {
    return Rz;
  },
  get qudt() {
    return Tz;
  },
  get rdau() {
    return Nz;
  },
  get rdf() {
    return Bn;
  },
  get rdfa() {
    return Iz;
  },
  get rdfs() {
    return Oz;
  },
  get rev() {
    return Pz;
  },
  get rico() {
    return Fz;
  },
  get rif() {
    return JG;
  },
  get rr() {
    return Bz;
  },
  get rss() {
    return Wz;
  },
  get schema() {
    return Hz;
  },
  get sd() {
    return zz;
  },
  get sdmx() {
    return Kz;
  },
  get sem() {
    return Xz;
  },
  get set() {
    return Qz;
  },
  get sf() {
    return eG;
  },
  get sh() {
    return rG;
  },
  get shex() {
    return iG;
  },
  get shsh() {
    return sG;
  },
  get sioc() {
    return lG;
  },
  get skos() {
    return fG;
  },
  get skosxl() {
    return dG;
  },
  get solid() {
    return pG;
  },
  get sosa() {
    return bG;
  },
  get sou() {
    return vG;
  },
  get ssn() {
    return _G;
  },
  get stat() {
    return SG;
  },
  get string() {
    return xG;
  },
  get test() {
    return AG;
  },
  get time() {
    return $G;
  },
  get unit() {
    return kG;
  },
  get v() {
    return ZG;
  },
  get vaem() {
    return IG;
  },
  get vann() {
    return OG;
  },
  get vcard() {
    return PG;
  },
  get vs() {
    return BG;
  },
  get wdr() {
    return tK;
  },
  get wdrs() {
    return WG;
  },
  get wgs() {
    return HG;
  },
  get xhv() {
    return zG;
  },
  get xkos() {
    return KG;
  },
  get xml() {
    return nK;
  },
  get xsd() {
    return mf;
  }
}, Symbol.toStringTag, { value: "Module" }));
var hTe = typeof globalThis < "u" ? globalThis : typeof window < "u" || typeof window < "u" ? window : typeof self < "u" ? self : {};
function Tn(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function bW(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else
    r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var o = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(r, n, o.get ? o : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), r;
}
var ZP = { exports: {} }, Vt = ZP.exports = {}, ci, di;
function d1() {
  throw new Error("setTimeout has not been defined");
}
function h1() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? ci = setTimeout : ci = d1;
  } catch {
    ci = d1;
  }
  try {
    typeof clearTimeout == "function" ? di = clearTimeout : di = h1;
  } catch {
    di = h1;
  }
})();
function eD(e) {
  if (ci === setTimeout)
    return setTimeout(e, 0);
  if ((ci === d1 || !ci) && setTimeout)
    return ci = setTimeout, setTimeout(e, 0);
  try {
    return ci(e, 0);
  } catch {
    try {
      return ci.call(null, e, 0);
    } catch {
      return ci.call(this, e, 0);
    }
  }
}
function yW(e) {
  if (di === clearTimeout)
    return clearTimeout(e);
  if ((di === h1 || !di) && clearTimeout)
    return di = clearTimeout, clearTimeout(e);
  try {
    return di(e);
  } catch {
    try {
      return di.call(null, e);
    } catch {
      return di.call(this, e);
    }
  }
}
var Ji = [], $l = !1, Ys, Od = -1;
function vW() {
  !$l || !Ys || ($l = !1, Ys.length ? Ji = Ys.concat(Ji) : Od = -1, Ji.length && tD());
}
function tD() {
  if (!$l) {
    var e = eD(vW);
    $l = !0;
    for (var t = Ji.length; t; ) {
      for (Ys = Ji, Ji = []; ++Od < t; )
        Ys && Ys[Od].run();
      Od = -1, t = Ji.length;
    }
    Ys = null, $l = !1, yW(e);
  }
}
Vt.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
  Ji.push(new rD(e, t)), Ji.length === 1 && !$l && eD(tD);
};
function rD(e, t) {
  this.fun = e, this.array = t;
}
rD.prototype.run = function() {
  this.fun.apply(null, this.array);
};
Vt.title = "browser";
Vt.browser = !0;
Vt.env = {};
Vt.argv = [];
Vt.version = "";
Vt.versions = {};
function So() {
}
Vt.on = So;
Vt.addListener = So;
Vt.once = So;
Vt.off = So;
Vt.removeListener = So;
Vt.removeAllListeners = So;
Vt.emit = So;
Vt.prependListener = So;
Vt.prependOnceListener = So;
Vt.listeners = function(e) {
  return [];
};
Vt.binding = function(e) {
  throw new Error("process.binding is not supported");
};
Vt.cwd = function() {
  return "/";
};
Vt.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
Vt.umask = function() {
  return 0;
};
var St = ZP.exports;
const te = /* @__PURE__ */ Tn(St);
function bs(e, t) {
  const r = /* @__PURE__ */ Object.create(null), n = e.split(",");
  for (let o = 0; o < n.length; o++)
    r[n[o]] = !0;
  return t ? (o) => !!r[o.toLowerCase()] : (o) => !!r[o];
}
const Rt = te.env.NODE_ENV !== "production" ? Object.freeze({}) : {}, Nl = te.env.NODE_ENV !== "production" ? Object.freeze([]) : [], hr = () => {
}, nD = () => !1, mW = /^on[^a-z]/, pc = (e) => mW.test(e), ih = (e) => e.startsWith("onUpdate:"), Ct = Object.assign, NE = (e, t) => {
  const r = e.indexOf(t);
  r > -1 && e.splice(r, 1);
}, _W = Object.prototype.hasOwnProperty, lt = (e, t) => _W.call(e, t), We = Array.isArray, na = (e) => rp(e) === "[object Map]", iD = (e) => rp(e) === "[object Set]", Je = (e) => typeof e == "function", Ot = (e) => typeof e == "string", kE = (e) => typeof e == "symbol", _t = (e) => e !== null && typeof e == "object", CE = (e) => _t(e) && Je(e.then) && Je(e.catch), oD = Object.prototype.toString, rp = (e) => oD.call(e), IE = (e) => rp(e).slice(8, -1), sD = (e) => rp(e) === "[object Object]", ME = (e) => Ot(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, Ld = /* @__PURE__ */ bs(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), wW = /* @__PURE__ */ bs(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), np = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (r) => t[r] || (t[r] = e(r));
}, SW = /-(\w)/g, Ri = np((e) => e.replace(SW, (t, r) => r ? r.toUpperCase() : "")), EW = /\B([A-Z])/g, is = np(
  (e) => e.replace(EW, "-$1").toLowerCase()
), wa = np(
  (e) => e.charAt(0).toUpperCase() + e.slice(1)
), Fs = np(
  (e) => e ? `on${wa(e)}` : ""
), Pf = (e, t) => !Object.is(e, t), dl = (e, t) => {
  for (let r = 0; r < e.length; r++)
    e[r](t);
}, oh = (e, t, r) => {
  Object.defineProperty(e, t, {
    configurable: !0,
    enumerable: !1,
    value: r
  });
}, p1 = (e) => {
  const t = parseFloat(e);
  return isNaN(t) ? e : t;
}, xW = (e) => {
  const t = Ot(e) ? Number(e) : NaN;
  return isNaN(t) ? e : t;
};
let NA;
const sh = () => NA || (NA = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" || typeof window < "u" ? window : {});
function ip(e) {
  if (We(e)) {
    const t = {};
    for (let r = 0; r < e.length; r++) {
      const n = e[r], o = Ot(n) ? $W(n) : ip(n);
      if (o)
        for (const s in o)
          t[s] = o[s];
    }
    return t;
  } else {
    if (Ot(e))
      return e;
    if (_t(e))
      return e;
  }
}
const RW = /;(?![^(]*\))/g, AW = /:([^]+)/, TW = /\/\*[^]*?\*\//g;
function $W(e) {
  const t = {};
  return e.replace(TW, "").split(RW).forEach((r) => {
    if (r) {
      const n = r.split(AW);
      n.length > 1 && (t[n[0].trim()] = n[1].trim());
    }
  }), t;
}
function lr(e) {
  let t = "";
  if (Ot(e))
    t = e;
  else if (We(e))
    for (let r = 0; r < e.length; r++) {
      const n = lr(e[r]);
      n && (t += n + " ");
    }
  else if (_t(e))
    for (const r in e)
      e[r] && (t += r + " ");
  return t.trim();
}
const NW = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", kW = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", CW = /* @__PURE__ */ bs(NW), IW = /* @__PURE__ */ bs(kW), MW = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", OW = /* @__PURE__ */ bs(MW);
function aD(e) {
  return !!e || e === "";
}
const gt = (e) => Ot(e) ? e : e == null ? "" : We(e) || _t(e) && (e.toString === oD || !Je(e.toString)) ? JSON.stringify(e, lD, 2) : String(e), lD = (e, t) => t && t.__v_isRef ? lD(e, t.value) : na(t) ? {
  [`Map(${t.size})`]: [...t.entries()].reduce((r, [n, o]) => (r[`${n} =>`] = o, r), {})
} : iD(t) ? {
  [`Set(${t.size})`]: [...t.values()]
} : _t(t) && !We(t) && !sD(t) ? String(t) : t;
function g1(e, ...t) {
  console.warn(`[Vue warn] ${e}`, ...t);
}
let Fn;
class LW {
  constructor(t = !1) {
    this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Fn, !t && Fn && (this.index = (Fn.scopes || (Fn.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  run(t) {
    if (this._active) {
      const r = Fn;
      try {
        return Fn = this, t();
      } finally {
        Fn = r;
      }
    } else
      te.env.NODE_ENV !== "production" && g1("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    Fn = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    Fn = this.parent;
  }
  stop(t) {
    if (this._active) {
      let r, n;
      for (r = 0, n = this.effects.length; r < n; r++)
        this.effects[r].stop();
      for (r = 0, n = this.cleanups.length; r < n; r++)
        this.cleanups[r]();
      if (this.scopes)
        for (r = 0, n = this.scopes.length; r < n; r++)
          this.scopes[r].stop(!0);
      if (!this.detached && this.parent && !t) {
        const o = this.parent.scopes.pop();
        o && o !== this && (this.parent.scopes[this.index] = o, o.index = this.index);
      }
      this.parent = void 0, this._active = !1;
    }
  }
}
function PW(e, t = Fn) {
  t && t.active && t.effects.push(e);
}
function DW() {
  return Fn;
}
const Df = (e) => {
  const t = new Set(e);
  return t.w = 0, t.n = 0, t;
}, uD = (e) => (e.w & os) > 0, fD = (e) => (e.n & os) > 0, FW = ({ deps: e }) => {
  if (e.length)
    for (let t = 0; t < e.length; t++)
      e[t].w |= os;
}, jW = (e) => {
  const { deps: t } = e;
  if (t.length) {
    let r = 0;
    for (let n = 0; n < t.length; n++) {
      const o = t[n];
      uD(o) && !fD(o) ? o.delete(e) : t[r++] = o, o.w &= ~os, o.n &= ~os;
    }
    t.length = r;
  }
}, b1 = /* @__PURE__ */ new WeakMap();
let Hu = 0, os = 1;
const y1 = 30;
let Fr;
const ia = Symbol(te.env.NODE_ENV !== "production" ? "iterate" : ""), v1 = Symbol(te.env.NODE_ENV !== "production" ? "Map key iterate" : "");
class OE {
  constructor(t, r = null, n) {
    this.fn = t, this.scheduler = r, this.active = !0, this.deps = [], this.parent = void 0, PW(this, n);
  }
  run() {
    if (!this.active)
      return this.fn();
    let t = Fr, r = Zo;
    for (; t; ) {
      if (t === this)
        return;
      t = t.parent;
    }
    try {
      return this.parent = Fr, Fr = this, Zo = !0, os = 1 << ++Hu, Hu <= y1 ? FW(this) : kA(this), this.fn();
    } finally {
      Hu <= y1 && jW(this), os = 1 << --Hu, Fr = this.parent, Zo = r, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    Fr === this ? this.deferStop = !0 : this.active && (kA(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function kA(e) {
  const { deps: t } = e;
  if (t.length) {
    for (let r = 0; r < t.length; r++)
      t[r].delete(e);
    t.length = 0;
  }
}
let Zo = !0;
const cD = [];
function Pa() {
  cD.push(Zo), Zo = !1;
}
function Da() {
  const e = cD.pop();
  Zo = e === void 0 ? !0 : e;
}
function mr(e, t, r) {
  if (Zo && Fr) {
    let n = b1.get(e);
    n || b1.set(e, n = /* @__PURE__ */ new Map());
    let o = n.get(r);
    o || n.set(r, o = Df());
    const s = te.env.NODE_ENV !== "production" ? { effect: Fr, target: e, type: t, key: r } : void 0;
    m1(o, s);
  }
}
function m1(e, t) {
  let r = !1;
  Hu <= y1 ? fD(e) || (e.n |= os, r = !uD(e)) : r = !e.has(Fr), r && (e.add(Fr), Fr.deps.push(e), te.env.NODE_ENV !== "production" && Fr.onTrack && Fr.onTrack(
    Ct(
      {
        effect: Fr
      },
      t
    )
  ));
}
function Ai(e, t, r, n, o, s) {
  const a = b1.get(e);
  if (!a)
    return;
  let l = [];
  if (t === "clear")
    l = [...a.values()];
  else if (r === "length" && We(e)) {
    const f = Number(n);
    a.forEach((c, d) => {
      (d === "length" || d >= f) && l.push(c);
    });
  } else
    switch (r !== void 0 && l.push(a.get(r)), t) {
      case "add":
        We(e) ? ME(r) && l.push(a.get("length")) : (l.push(a.get(ia)), na(e) && l.push(a.get(v1)));
        break;
      case "delete":
        We(e) || (l.push(a.get(ia)), na(e) && l.push(a.get(v1)));
        break;
      case "set":
        na(e) && l.push(a.get(ia));
        break;
    }
  const u = te.env.NODE_ENV !== "production" ? { target: e, type: t, key: r, newValue: n, oldValue: o, oldTarget: s } : void 0;
  if (l.length === 1)
    l[0] && (te.env.NODE_ENV !== "production" ? El(l[0], u) : El(l[0]));
  else {
    const f = [];
    for (const c of l)
      c && f.push(...c);
    te.env.NODE_ENV !== "production" ? El(Df(f), u) : El(Df(f));
  }
}
function El(e, t) {
  const r = We(e) ? e : [...e];
  for (const n of r)
    n.computed && CA(n, t);
  for (const n of r)
    n.computed || CA(n, t);
}
function CA(e, t) {
  (e !== Fr || e.allowRecurse) && (te.env.NODE_ENV !== "production" && e.onTrigger && e.onTrigger(Ct({ effect: e }, t)), e.scheduler ? e.scheduler() : e.run());
}
const BW = /* @__PURE__ */ bs("__proto__,__v_isRef,__isVue"), dD = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(kE)
), qW = /* @__PURE__ */ op(), WW = /* @__PURE__ */ op(!1, !0), UW = /* @__PURE__ */ op(!0), HW = /* @__PURE__ */ op(!0, !0), IA = /* @__PURE__ */ VW();
function VW() {
  const e = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((t) => {
    e[t] = function(...r) {
      const n = je(this);
      for (let s = 0, a = this.length; s < a; s++)
        mr(n, "get", s + "");
      const o = n[t](...r);
      return o === -1 || o === !1 ? n[t](...r.map(je)) : o;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((t) => {
    e[t] = function(...r) {
      Pa();
      const n = je(this)[t].apply(this, r);
      return Da(), n;
    };
  }), e;
}
function zW(e) {
  const t = je(this);
  return mr(t, "has", e), t.hasOwnProperty(e);
}
function op(e = !1, t = !1) {
  return function(n, o, s) {
    if (o === "__v_isReactive")
      return !e;
    if (o === "__v_isReadonly")
      return e;
    if (o === "__v_isShallow")
      return t;
    if (o === "__v_raw" && s === (e ? t ? _D : mD : t ? vD : yD).get(n))
      return n;
    const a = We(n);
    if (!e) {
      if (a && lt(IA, o))
        return Reflect.get(IA, o, s);
      if (o === "hasOwnProperty")
        return zW;
    }
    const l = Reflect.get(n, o, s);
    return (kE(o) ? dD.has(o) : BW(o)) || (e || mr(n, "get", o), t) ? l : rr(l) ? a && ME(o) ? l : l.value : _t(l) ? e ? wD(l) : lp(l) : l;
  };
}
const GW = /* @__PURE__ */ hD(), KW = /* @__PURE__ */ hD(!0);
function hD(e = !1) {
  return function(r, n, o, s) {
    let a = r[n];
    if (ss(a) && rr(a) && !rr(o))
      return !1;
    if (!e && (!ah(o) && !ss(o) && (a = je(a), o = je(o)), !We(r) && rr(a) && !rr(o)))
      return a.value = o, !0;
    const l = We(r) && ME(n) ? Number(n) < r.length : lt(r, n), u = Reflect.set(r, n, o, s);
    return r === je(s) && (l ? Pf(o, a) && Ai(r, "set", n, o, a) : Ai(r, "add", n, o)), u;
  };
}
function YW(e, t) {
  const r = lt(e, t), n = e[t], o = Reflect.deleteProperty(e, t);
  return o && r && Ai(e, "delete", t, void 0, n), o;
}
function XW(e, t) {
  const r = Reflect.has(e, t);
  return (!kE(t) || !dD.has(t)) && mr(e, "has", t), r;
}
function JW(e) {
  return mr(e, "iterate", We(e) ? "length" : ia), Reflect.ownKeys(e);
}
const pD = {
  get: qW,
  set: GW,
  deleteProperty: YW,
  has: XW,
  ownKeys: JW
}, gD = {
  get: UW,
  set(e, t) {
    return te.env.NODE_ENV !== "production" && g1(
      `Set operation on key "${String(t)}" failed: target is readonly.`,
      e
    ), !0;
  },
  deleteProperty(e, t) {
    return te.env.NODE_ENV !== "production" && g1(
      `Delete operation on key "${String(t)}" failed: target is readonly.`,
      e
    ), !0;
  }
}, QW = /* @__PURE__ */ Ct(
  {},
  pD,
  {
    get: WW,
    set: KW
  }
), ZW = /* @__PURE__ */ Ct(
  {},
  gD,
  {
    get: HW
  }
), LE = (e) => e, sp = (e) => Reflect.getPrototypeOf(e);
function Wc(e, t, r = !1, n = !1) {
  e = e.__v_raw;
  const o = je(e), s = je(t);
  r || (t !== s && mr(o, "get", t), mr(o, "get", s));
  const { has: a } = sp(o), l = n ? LE : r ? PE : Ff;
  if (a.call(o, t))
    return l(e.get(t));
  if (a.call(o, s))
    return l(e.get(s));
  e !== o && e.get(t);
}
function Uc(e, t = !1) {
  const r = this.__v_raw, n = je(r), o = je(e);
  return t || (e !== o && mr(n, "has", e), mr(n, "has", o)), e === o ? r.has(e) : r.has(e) || r.has(o);
}
function Hc(e, t = !1) {
  return e = e.__v_raw, !t && mr(je(e), "iterate", ia), Reflect.get(e, "size", e);
}
function MA(e) {
  e = je(e);
  const t = je(this);
  return sp(t).has.call(t, e) || (t.add(e), Ai(t, "add", e, e)), this;
}
function OA(e, t) {
  t = je(t);
  const r = je(this), { has: n, get: o } = sp(r);
  let s = n.call(r, e);
  s ? te.env.NODE_ENV !== "production" && bD(r, n, e) : (e = je(e), s = n.call(r, e));
  const a = o.call(r, e);
  return r.set(e, t), s ? Pf(t, a) && Ai(r, "set", e, t, a) : Ai(r, "add", e, t), this;
}
function LA(e) {
  const t = je(this), { has: r, get: n } = sp(t);
  let o = r.call(t, e);
  o ? te.env.NODE_ENV !== "production" && bD(t, r, e) : (e = je(e), o = r.call(t, e));
  const s = n ? n.call(t, e) : void 0, a = t.delete(e);
  return o && Ai(t, "delete", e, void 0, s), a;
}
function PA() {
  const e = je(this), t = e.size !== 0, r = te.env.NODE_ENV !== "production" ? na(e) ? new Map(e) : new Set(e) : void 0, n = e.clear();
  return t && Ai(e, "clear", void 0, void 0, r), n;
}
function Vc(e, t) {
  return function(n, o) {
    const s = this, a = s.__v_raw, l = je(a), u = t ? LE : e ? PE : Ff;
    return !e && mr(l, "iterate", ia), a.forEach((f, c) => n.call(o, u(f), u(c), s));
  };
}
function zc(e, t, r) {
  return function(...n) {
    const o = this.__v_raw, s = je(o), a = na(s), l = e === "entries" || e === Symbol.iterator && a, u = e === "keys" && a, f = o[e](...n), c = r ? LE : t ? PE : Ff;
    return !t && mr(
      s,
      "iterate",
      u ? v1 : ia
    ), {
      // iterator protocol
      next() {
        const { value: d, done: h } = f.next();
        return h ? { value: d, done: h } : {
          value: l ? [c(d[0]), c(d[1])] : c(d),
          done: h
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Co(e) {
  return function(...t) {
    if (te.env.NODE_ENV !== "production") {
      const r = t[0] ? `on key "${t[0]}" ` : "";
      console.warn(
        `${wa(e)} operation ${r}failed: target is readonly.`,
        je(this)
      );
    }
    return e === "delete" ? !1 : this;
  };
}
function e4() {
  const e = {
    get(s) {
      return Wc(this, s);
    },
    get size() {
      return Hc(this);
    },
    has: Uc,
    add: MA,
    set: OA,
    delete: LA,
    clear: PA,
    forEach: Vc(!1, !1)
  }, t = {
    get(s) {
      return Wc(this, s, !1, !0);
    },
    get size() {
      return Hc(this);
    },
    has: Uc,
    add: MA,
    set: OA,
    delete: LA,
    clear: PA,
    forEach: Vc(!1, !0)
  }, r = {
    get(s) {
      return Wc(this, s, !0);
    },
    get size() {
      return Hc(this, !0);
    },
    has(s) {
      return Uc.call(this, s, !0);
    },
    add: Co("add"),
    set: Co("set"),
    delete: Co("delete"),
    clear: Co("clear"),
    forEach: Vc(!0, !1)
  }, n = {
    get(s) {
      return Wc(this, s, !0, !0);
    },
    get size() {
      return Hc(this, !0);
    },
    has(s) {
      return Uc.call(this, s, !0);
    },
    add: Co("add"),
    set: Co("set"),
    delete: Co("delete"),
    clear: Co("clear"),
    forEach: Vc(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((s) => {
    e[s] = zc(
      s,
      !1,
      !1
    ), r[s] = zc(
      s,
      !0,
      !1
    ), t[s] = zc(
      s,
      !1,
      !0
    ), n[s] = zc(
      s,
      !0,
      !0
    );
  }), [
    e,
    r,
    t,
    n
  ];
}
const [
  t4,
  r4,
  n4,
  i4
] = /* @__PURE__ */ e4();
function ap(e, t) {
  const r = t ? e ? i4 : n4 : e ? r4 : t4;
  return (n, o, s) => o === "__v_isReactive" ? !e : o === "__v_isReadonly" ? e : o === "__v_raw" ? n : Reflect.get(
    lt(r, o) && o in n ? r : n,
    o,
    s
  );
}
const o4 = {
  get: /* @__PURE__ */ ap(!1, !1)
}, s4 = {
  get: /* @__PURE__ */ ap(!1, !0)
}, a4 = {
  get: /* @__PURE__ */ ap(!0, !1)
}, l4 = {
  get: /* @__PURE__ */ ap(!0, !0)
};
function bD(e, t, r) {
  const n = je(r);
  if (n !== r && t.call(e, n)) {
    const o = IE(e);
    console.warn(
      `Reactive ${o} contains both the raw and reactive versions of the same object${o === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const yD = /* @__PURE__ */ new WeakMap(), vD = /* @__PURE__ */ new WeakMap(), mD = /* @__PURE__ */ new WeakMap(), _D = /* @__PURE__ */ new WeakMap();
function u4(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function f4(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : u4(IE(e));
}
function lp(e) {
  return ss(e) ? e : up(
    e,
    !1,
    pD,
    o4,
    yD
  );
}
function c4(e) {
  return up(
    e,
    !1,
    QW,
    s4,
    vD
  );
}
function wD(e) {
  return up(
    e,
    !0,
    gD,
    a4,
    mD
  );
}
function Vu(e) {
  return up(
    e,
    !0,
    ZW,
    l4,
    _D
  );
}
function up(e, t, r, n, o) {
  if (!_t(e))
    return te.env.NODE_ENV !== "production" && console.warn(`value cannot be made reactive: ${String(e)}`), e;
  if (e.__v_raw && !(t && e.__v_isReactive))
    return e;
  const s = o.get(e);
  if (s)
    return s;
  const a = f4(e);
  if (a === 0)
    return e;
  const l = new Proxy(
    e,
    a === 2 ? n : r
  );
  return o.set(e, l), l;
}
function oa(e) {
  return ss(e) ? oa(e.__v_raw) : !!(e && e.__v_isReactive);
}
function ss(e) {
  return !!(e && e.__v_isReadonly);
}
function ah(e) {
  return !!(e && e.__v_isShallow);
}
function _1(e) {
  return oa(e) || ss(e);
}
function je(e) {
  const t = e && e.__v_raw;
  return t ? je(t) : e;
}
function SD(e) {
  return oh(e, "__v_skip", !0), e;
}
const Ff = (e) => _t(e) ? lp(e) : e, PE = (e) => _t(e) ? wD(e) : e;
function ED(e) {
  Zo && Fr && (e = je(e), te.env.NODE_ENV !== "production" ? m1(e.dep || (e.dep = Df()), {
    target: e,
    type: "get",
    key: "value"
  }) : m1(e.dep || (e.dep = Df())));
}
function xD(e, t) {
  e = je(e);
  const r = e.dep;
  r && (te.env.NODE_ENV !== "production" ? El(r, {
    target: e,
    type: "set",
    key: "value",
    newValue: t
  }) : El(r));
}
function rr(e) {
  return !!(e && e.__v_isRef === !0);
}
function Ne(e) {
  return RD(e, !1);
}
function d4(e) {
  return RD(e, !0);
}
function RD(e, t) {
  return rr(e) ? e : new h4(e, t);
}
class h4 {
  constructor(t, r) {
    this.__v_isShallow = r, this.dep = void 0, this.__v_isRef = !0, this._rawValue = r ? t : je(t), this._value = r ? t : Ff(t);
  }
  get value() {
    return ED(this), this._value;
  }
  set value(t) {
    const r = this.__v_isShallow || ah(t) || ss(t);
    t = r ? t : je(t), Pf(t, this._rawValue) && (this._rawValue = t, this._value = r ? t : Ff(t), xD(this, t));
  }
}
function De(e) {
  return rr(e) ? e.value : e;
}
const p4 = {
  get: (e, t, r) => De(Reflect.get(e, t, r)),
  set: (e, t, r, n) => {
    const o = e[t];
    return rr(o) && !rr(r) ? (o.value = r, !0) : Reflect.set(e, t, r, n);
  }
};
function AD(e) {
  return oa(e) ? e : new Proxy(e, p4);
}
class g4 {
  constructor(t, r, n, o) {
    this._setter = r, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new OE(t, () => {
      this._dirty || (this._dirty = !0, xD(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !o, this.__v_isReadonly = n;
  }
  get value() {
    const t = je(this);
    return ED(t), (t._dirty || !t._cacheable) && (t._dirty = !1, t._value = t.effect.run()), t._value;
  }
  set value(t) {
    this._setter(t);
  }
}
function b4(e, t, r = !1) {
  let n, o;
  const s = Je(e);
  s ? (n = e, o = te.env.NODE_ENV !== "production" ? () => {
    console.warn("Write operation failed: computed value is readonly");
  } : hr) : (n = e.get, o = e.set);
  const a = new g4(n, o, s || !o, r);
  return te.env.NODE_ENV !== "production" && t && !r && (a.effect.onTrack = t.onTrack, a.effect.onTrigger = t.onTrigger), a;
}
const sa = [];
function Pd(e) {
  sa.push(e);
}
function Dd() {
  sa.pop();
}
function Re(e, ...t) {
  if (te.env.NODE_ENV === "production")
    return;
  Pa();
  const r = sa.length ? sa[sa.length - 1].component : null, n = r && r.appContext.config.warnHandler, o = y4();
  if (n)
    ro(
      n,
      r,
      11,
      [
        e + t.join(""),
        r && r.proxy,
        o.map(
          ({ vnode: s }) => `at <${yp(r, s.type)}>`
        ).join(`
`),
        o
      ]
    );
  else {
    const s = [`[Vue warn]: ${e}`, ...t];
    o.length && s.push(`
`, ...v4(o)), console.warn(...s);
  }
  Da();
}
function y4() {
  let e = sa[sa.length - 1];
  if (!e)
    return [];
  const t = [];
  for (; e; ) {
    const r = t[0];
    r && r.vnode === e ? r.recurseCount++ : t.push({
      vnode: e,
      recurseCount: 0
    });
    const n = e.component && e.component.parent;
    e = n && n.vnode;
  }
  return t;
}
function v4(e) {
  const t = [];
  return e.forEach((r, n) => {
    t.push(...n === 0 ? [] : [`
`], ...m4(r));
  }), t;
}
function m4({ vnode: e, recurseCount: t }) {
  const r = t > 0 ? `... (${t} recursive calls)` : "", n = e.component ? e.component.parent == null : !1, o = ` at <${yp(
    e.component,
    e.type,
    n
  )}`, s = ">" + r;
  return e.props ? [o, ..._4(e.props), s] : [o + s];
}
function _4(e) {
  const t = [], r = Object.keys(e);
  return r.slice(0, 3).forEach((n) => {
    t.push(...TD(n, e[n]));
  }), r.length > 3 && t.push(" ..."), t;
}
function TD(e, t, r) {
  return Ot(t) ? (t = JSON.stringify(t), r ? t : [`${e}=${t}`]) : typeof t == "number" || typeof t == "boolean" || t == null ? r ? t : [`${e}=${t}`] : rr(t) ? (t = TD(e, je(t.value), !0), r ? t : [`${e}=Ref<`, t, ">"]) : Je(t) ? [`${e}=fn${t.name ? `<${t.name}>` : ""}`] : (t = je(t), r ? t : [`${e}=`, t]);
}
function w4(e, t) {
  te.env.NODE_ENV !== "production" && e !== void 0 && (typeof e != "number" ? Re(`${t} is not a valid number - got ${JSON.stringify(e)}.`) : isNaN(e) && Re(`${t} is NaN - the duration expression might be incorrect.`));
}
const DE = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function ro(e, t, r, n) {
  let o;
  try {
    o = n ? e(...n) : e();
  } catch (s) {
    fp(s, t, r);
  }
  return o;
}
function Sn(e, t, r, n) {
  if (Je(e)) {
    const s = ro(e, t, r, n);
    return s && CE(s) && s.catch((a) => {
      fp(a, t, r);
    }), s;
  }
  const o = [];
  for (let s = 0; s < e.length; s++)
    o.push(Sn(e[s], t, r, n));
  return o;
}
function fp(e, t, r, n = !0) {
  const o = t ? t.vnode : null;
  if (t) {
    let s = t.parent;
    const a = t.proxy, l = te.env.NODE_ENV !== "production" ? DE[r] : r;
    for (; s; ) {
      const f = s.ec;
      if (f) {
        for (let c = 0; c < f.length; c++)
          if (f[c](e, a, l) === !1)
            return;
      }
      s = s.parent;
    }
    const u = t.appContext.config.errorHandler;
    if (u) {
      ro(
        u,
        null,
        10,
        [e, a, l]
      );
      return;
    }
  }
  S4(e, r, o, n);
}
function S4(e, t, r, n = !0) {
  if (te.env.NODE_ENV !== "production") {
    const o = DE[t];
    if (r && Pd(r), Re(`Unhandled error${o ? ` during execution of ${o}` : ""}`), r && Dd(), n)
      throw e;
    console.error(e);
  } else
    console.error(e);
}
let jf = !1, w1 = !1;
const $r = [];
let pi = 0;
const kl = [];
let ui = null, Po = 0;
const $D = /* @__PURE__ */ Promise.resolve();
let FE = null;
const E4 = 100;
function br(e) {
  const t = FE || $D;
  return e ? t.then(this ? e.bind(this) : e) : t;
}
function x4(e) {
  let t = pi + 1, r = $r.length;
  for (; t < r; ) {
    const n = t + r >>> 1;
    Bf($r[n]) < e ? t = n + 1 : r = n;
  }
  return t;
}
function cp(e) {
  (!$r.length || !$r.includes(
    e,
    jf && e.allowRecurse ? pi + 1 : pi
  )) && (e.id == null ? $r.push(e) : $r.splice(x4(e.id), 0, e), ND());
}
function ND() {
  !jf && !w1 && (w1 = !0, FE = $D.then(ID));
}
function R4(e) {
  const t = $r.indexOf(e);
  t > pi && $r.splice(t, 1);
}
function kD(e) {
  We(e) ? kl.push(...e) : (!ui || !ui.includes(
    e,
    e.allowRecurse ? Po + 1 : Po
  )) && kl.push(e), ND();
}
function DA(e, t = jf ? pi + 1 : 0) {
  for (te.env.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map()); t < $r.length; t++) {
    const r = $r[t];
    if (r && r.pre) {
      if (te.env.NODE_ENV !== "production" && jE(e, r))
        continue;
      $r.splice(t, 1), t--, r();
    }
  }
}
function CD(e) {
  if (kl.length) {
    const t = [...new Set(kl)];
    if (kl.length = 0, ui) {
      ui.push(...t);
      return;
    }
    for (ui = t, te.env.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map()), ui.sort((r, n) => Bf(r) - Bf(n)), Po = 0; Po < ui.length; Po++)
      te.env.NODE_ENV !== "production" && jE(e, ui[Po]) || ui[Po]();
    ui = null, Po = 0;
  }
}
const Bf = (e) => e.id == null ? 1 / 0 : e.id, A4 = (e, t) => {
  const r = Bf(e) - Bf(t);
  if (r === 0) {
    if (e.pre && !t.pre)
      return -1;
    if (t.pre && !e.pre)
      return 1;
  }
  return r;
};
function ID(e) {
  w1 = !1, jf = !0, te.env.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map()), $r.sort(A4);
  const t = te.env.NODE_ENV !== "production" ? (r) => jE(e, r) : hr;
  try {
    for (pi = 0; pi < $r.length; pi++) {
      const r = $r[pi];
      if (r && r.active !== !1) {
        if (te.env.NODE_ENV !== "production" && t(r))
          continue;
        ro(r, null, 14);
      }
    }
  } finally {
    pi = 0, $r.length = 0, CD(e), jf = !1, FE = null, ($r.length || kl.length) && ID(e);
  }
}
function jE(e, t) {
  if (!e.has(t))
    e.set(t, 1);
  else {
    const r = e.get(t);
    if (r > E4) {
      const n = t.ownerInstance, o = n && GE(n.type);
      return Re(
        `Maximum recursive updates exceeded${o ? ` in component <${o}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`
      ), !0;
    } else
      e.set(t, r + 1);
  }
}
let es = !1;
const hl = /* @__PURE__ */ new Set();
te.env.NODE_ENV !== "production" && (sh().__VUE_HMR_RUNTIME__ = {
  createRecord: pb(MD),
  rerender: pb(N4),
  reload: pb(k4)
});
const Sa = /* @__PURE__ */ new Map();
function T4(e) {
  const t = e.type.__hmrId;
  let r = Sa.get(t);
  r || (MD(t, e.type), r = Sa.get(t)), r.instances.add(e);
}
function $4(e) {
  Sa.get(e.type.__hmrId).instances.delete(e);
}
function MD(e, t) {
  return Sa.has(e) ? !1 : (Sa.set(e, {
    initialDef: pf(t),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function pf(e) {
  return f3(e) ? e.__vccOpts : e;
}
function N4(e, t) {
  const r = Sa.get(e);
  r && (r.initialDef.render = t, [...r.instances].forEach((n) => {
    t && (n.render = t, pf(n.type).render = t), n.renderCache = [], es = !0, n.update(), es = !1;
  }));
}
function k4(e, t) {
  const r = Sa.get(e);
  if (!r)
    return;
  t = pf(t), FA(r.initialDef, t);
  const n = [...r.instances];
  for (const o of n) {
    const s = pf(o.type);
    hl.has(s) || (s !== r.initialDef && FA(s, t), hl.add(s)), o.appContext.propsCache.delete(o.type), o.appContext.emitsCache.delete(o.type), o.appContext.optionsCache.delete(o.type), o.ceReload ? (hl.add(s), o.ceReload(t.styles), hl.delete(s)) : o.parent ? cp(o.parent.update) : o.appContext.reload ? o.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    );
  }
  kD(() => {
    for (const o of n)
      hl.delete(
        pf(o.type)
      );
  });
}
function FA(e, t) {
  Ct(e, t);
  for (const r in e)
    r !== "__file" && !(r in t) && delete e[r];
}
function pb(e) {
  return (t, r) => {
    try {
      return e(t, r);
    } catch (n) {
      console.error(n), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
let gi, zu = [], S1 = !1;
function gc(e, ...t) {
  gi ? gi.emit(e, ...t) : S1 || zu.push({ event: e, args: t });
}
function OD(e, t) {
  var r, n;
  gi = e, gi ? (gi.enabled = !0, zu.forEach(({ event: o, args: s }) => gi.emit(o, ...s)), zu = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  !((n = (r = window.navigator) == null ? void 0 : r.userAgent) != null && n.includes("jsdom")) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((s) => {
    OD(s, t);
  }), setTimeout(() => {
    gi || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, S1 = !0, zu = []);
  }, 3e3)) : (S1 = !0, zu = []);
}
function C4(e, t) {
  gc("app:init", e, t, {
    Fragment: ut,
    Text: yc,
    Comment: ar,
    Static: yf
  });
}
function I4(e) {
  gc("app:unmount", e);
}
const M4 = /* @__PURE__ */ BE(
  "component:added"
  /* COMPONENT_ADDED */
), LD = /* @__PURE__ */ BE(
  "component:updated"
  /* COMPONENT_UPDATED */
), O4 = /* @__PURE__ */ BE(
  "component:removed"
  /* COMPONENT_REMOVED */
), L4 = (e) => {
  gi && typeof gi.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !gi.cleanupBuffer(e) && O4(e);
};
function BE(e) {
  return (t) => {
    gc(
      e,
      t.appContext.app,
      t.uid,
      t.parent ? t.parent.uid : void 0,
      t
    );
  };
}
const P4 = /* @__PURE__ */ PD(
  "perf:start"
  /* PERFORMANCE_START */
), D4 = /* @__PURE__ */ PD(
  "perf:end"
  /* PERFORMANCE_END */
);
function PD(e) {
  return (t, r, n) => {
    gc(e, t.appContext.app, t.uid, t, r, n);
  };
}
function F4(e, t, r) {
  gc(
    "component:emit",
    e.appContext.app,
    e,
    t,
    r
  );
}
function j4(e, t, ...r) {
  if (e.isUnmounted)
    return;
  const n = e.vnode.props || Rt;
  if (te.env.NODE_ENV !== "production") {
    const {
      emitsOptions: c,
      propsOptions: [d]
    } = e;
    if (c)
      if (!(t in c))
        (!d || !(Fs(t) in d)) && Re(
          `Component emitted event "${t}" but it is neither declared in the emits option nor as an "${Fs(t)}" prop.`
        );
      else {
        const h = c[t];
        Je(h) && (h(...r) || Re(
          `Invalid event arguments: event validation failed for event "${t}".`
        ));
      }
  }
  let o = r;
  const s = t.startsWith("update:"), a = s && t.slice(7);
  if (a && a in n) {
    const c = `${a === "modelValue" ? "model" : a}Modifiers`, { number: d, trim: h } = n[c] || Rt;
    h && (o = r.map((p) => Ot(p) ? p.trim() : p)), d && (o = r.map(p1));
  }
  if (te.env.NODE_ENV !== "production" && F4(e, t, o), te.env.NODE_ENV !== "production") {
    const c = t.toLowerCase();
    c !== t && n[Fs(c)] && Re(
      `Event "${c}" is emitted in component ${yp(
        e,
        e.type
      )} but the handler is registered for "${t}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${is(t)}" instead of "${t}".`
    );
  }
  let l, u = n[l = Fs(t)] || // also try camelCase event handler (#2249)
  n[l = Fs(Ri(t))];
  !u && s && (u = n[l = Fs(is(t))]), u && Sn(
    u,
    e,
    6,
    o
  );
  const f = n[l + "Once"];
  if (f) {
    if (!e.emitted)
      e.emitted = {};
    else if (e.emitted[l])
      return;
    e.emitted[l] = !0, Sn(
      f,
      e,
      6,
      o
    );
  }
}
function DD(e, t, r = !1) {
  const n = t.emitsCache, o = n.get(e);
  if (o !== void 0)
    return o;
  const s = e.emits;
  let a = {}, l = !1;
  if (!Je(e)) {
    const u = (f) => {
      const c = DD(f, t, !0);
      c && (l = !0, Ct(a, c));
    };
    !r && t.mixins.length && t.mixins.forEach(u), e.extends && u(e.extends), e.mixins && e.mixins.forEach(u);
  }
  return !s && !l ? (_t(e) && n.set(e, null), null) : (We(s) ? s.forEach((u) => a[u] = null) : Ct(a, s), _t(e) && n.set(e, a), a);
}
function dp(e, t) {
  return !e || !pc(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), lt(e, t[0].toLowerCase() + t.slice(1)) || lt(e, is(t)) || lt(e, t));
}
let nr = null, hp = null;
function lh(e) {
  const t = nr;
  return nr = e, hp = e && e.type.__scopeId || null, t;
}
function B4(e) {
  hp = e;
}
function q4() {
  hp = null;
}
function Ge(e, t = nr, r) {
  if (!t || e._n)
    return e;
  const n = (...o) => {
    n._d && ZA(-1);
    const s = lh(t);
    let a;
    try {
      a = e(...o);
    } finally {
      lh(s), n._d && ZA(1);
    }
    return te.env.NODE_ENV !== "production" && LD(t), a;
  };
  return n._n = !0, n._c = !0, n._d = !0, n;
}
let E1 = !1;
function uh() {
  E1 = !0;
}
function gb(e) {
  const {
    type: t,
    vnode: r,
    proxy: n,
    withProxy: o,
    props: s,
    propsOptions: [a],
    slots: l,
    attrs: u,
    emit: f,
    render: c,
    renderCache: d,
    data: h,
    setupState: p,
    ctx: v,
    inheritAttrs: y
  } = e;
  let w, S;
  const x = lh(e);
  te.env.NODE_ENV !== "production" && (E1 = !1);
  try {
    if (r.shapeFlag & 4) {
      const C = o || n;
      w = Wn(
        c.call(
          C,
          C,
          d,
          s,
          p,
          h,
          v
        )
      ), S = u;
    } else {
      const C = t;
      te.env.NODE_ENV !== "production" && u === s && uh(), w = Wn(
        C.length > 1 ? C(
          s,
          te.env.NODE_ENV !== "production" ? {
            get attrs() {
              return uh(), u;
            },
            slots: l,
            emit: f
          } : { attrs: u, slots: l, emit: f }
        ) : C(
          s,
          null
          /* we know it doesn't need it */
        )
      ), S = t.props ? u : U4(u);
    }
  } catch (C) {
    vf.length = 0, fp(C, e, 1), w = xe(ar);
  }
  let E = w, N;
  if (te.env.NODE_ENV !== "production" && w.patchFlag > 0 && w.patchFlag & 2048 && ([E, N] = W4(w)), S && y !== !1) {
    const C = Object.keys(S), { shapeFlag: j } = E;
    if (C.length) {
      if (j & 7)
        a && C.some(ih) && (S = H4(
          S,
          a
        )), E = Xn(E, S);
      else if (te.env.NODE_ENV !== "production" && !E1 && E.type !== ar) {
        const J = Object.keys(u), z = [], $ = [];
        for (let G = 0, I = J.length; G < I; G++) {
          const W = J[G];
          pc(W) ? ih(W) || z.push(W[2].toLowerCase() + W.slice(3)) : $.push(W);
        }
        $.length && Re(
          `Extraneous non-props attributes (${$.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`
        ), z.length && Re(
          `Extraneous non-emits event listeners (${z.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
        );
      }
    }
  }
  return r.dirs && (te.env.NODE_ENV !== "production" && !jA(E) && Re(
    "Runtime directive used on component with non-element root node. The directives will not function as intended."
  ), E = Xn(E), E.dirs = E.dirs ? E.dirs.concat(r.dirs) : r.dirs), r.transition && (te.env.NODE_ENV !== "production" && !jA(E) && Re(
    "Component inside <Transition> renders non-element root node that cannot be animated."
  ), E.transition = r.transition), te.env.NODE_ENV !== "production" && N ? N(E) : w = E, lh(x), w;
}
const W4 = (e) => {
  const t = e.children, r = e.dynamicChildren, n = FD(t);
  if (!n)
    return [e, void 0];
  const o = t.indexOf(n), s = r ? r.indexOf(n) : -1, a = (l) => {
    t[o] = l, r && (s > -1 ? r[s] = l : l.patchFlag > 0 && (e.dynamicChildren = [...r, l]));
  };
  return [Wn(n), a];
};
function FD(e) {
  let t;
  for (let r = 0; r < e.length; r++) {
    const n = e[r];
    if (Ul(n)) {
      if (n.type !== ar || n.children === "v-if") {
        if (t)
          return;
        t = n;
      }
    } else
      return;
  }
  return t;
}
const U4 = (e) => {
  let t;
  for (const r in e)
    (r === "class" || r === "style" || pc(r)) && ((t || (t = {}))[r] = e[r]);
  return t;
}, H4 = (e, t) => {
  const r = {};
  for (const n in e)
    (!ih(n) || !(n.slice(9) in t)) && (r[n] = e[n]);
  return r;
}, jA = (e) => e.shapeFlag & 7 || e.type === ar;
function V4(e, t, r) {
  const { props: n, children: o, component: s } = e, { props: a, children: l, patchFlag: u } = t, f = s.emitsOptions;
  if (te.env.NODE_ENV !== "production" && (o || l) && es || t.dirs || t.transition)
    return !0;
  if (r && u >= 0) {
    if (u & 1024)
      return !0;
    if (u & 16)
      return n ? BA(n, a, f) : !!a;
    if (u & 8) {
      const c = t.dynamicProps;
      for (let d = 0; d < c.length; d++) {
        const h = c[d];
        if (a[h] !== n[h] && !dp(f, h))
          return !0;
      }
    }
  } else
    return (o || l) && (!l || !l.$stable) ? !0 : n === a ? !1 : n ? a ? BA(n, a, f) : !0 : !!a;
  return !1;
}
function BA(e, t, r) {
  const n = Object.keys(t);
  if (n.length !== Object.keys(e).length)
    return !0;
  for (let o = 0; o < n.length; o++) {
    const s = n[o];
    if (t[s] !== e[s] && !dp(r, s))
      return !0;
  }
  return !1;
}
function z4({ vnode: e, parent: t }, r) {
  for (; t && t.subTree === e; )
    (e = t.vnode).el = r, t = t.parent;
}
const G4 = (e) => e.__isSuspense;
function K4(e, t) {
  t && t.pendingBranch ? We(e) ? t.effects.push(...e) : t.effects.push(e) : kD(e);
}
function Qn(e, t) {
  return qE(e, null, t);
}
const Gc = {};
function yr(e, t, r) {
  return te.env.NODE_ENV !== "production" && !Je(t) && Re(
    "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
  ), qE(e, t, r);
}
function qE(e, t, { immediate: r, deep: n, flush: o, onTrack: s, onTrigger: a } = Rt) {
  var l;
  te.env.NODE_ENV !== "production" && !t && (r !== void 0 && Re(
    'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
  ), n !== void 0 && Re(
    'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
  ));
  const u = (C) => {
    Re(
      "Invalid watch source: ",
      C,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  }, f = DW() === ((l = Zt) == null ? void 0 : l.scope) ? Zt : null;
  let c, d = !1, h = !1;
  if (rr(e) ? (c = () => e.value, d = ah(e)) : oa(e) ? (c = () => e, n = !0) : We(e) ? (h = !0, d = e.some((C) => oa(C) || ah(C)), c = () => e.map((C) => {
    if (rr(C))
      return C.value;
    if (oa(C))
      return Xs(C);
    if (Je(C))
      return ro(C, f, 2);
    te.env.NODE_ENV !== "production" && u(C);
  })) : Je(e) ? t ? c = () => ro(e, f, 2) : c = () => {
    if (!(f && f.isUnmounted))
      return p && p(), Sn(
        e,
        f,
        3,
        [v]
      );
  } : (c = hr, te.env.NODE_ENV !== "production" && u(e)), t && n) {
    const C = c;
    c = () => Xs(C());
  }
  let p, v = (C) => {
    p = E.onStop = () => {
      ro(C, f, 4);
    };
  }, y;
  if (Wf)
    if (v = hr, t ? r && Sn(t, f, 3, [
      c(),
      h ? [] : void 0,
      v
    ]) : c(), o === "sync") {
      const C = iH();
      y = C.__watcherHandles || (C.__watcherHandles = []);
    } else
      return hr;
  let w = h ? new Array(e.length).fill(Gc) : Gc;
  const S = () => {
    if (E.active)
      if (t) {
        const C = E.run();
        (n || d || (h ? C.some(
          (j, J) => Pf(j, w[J])
        ) : Pf(C, w))) && (p && p(), Sn(t, f, 3, [
          C,
          // pass undefined as the old value when it's changed for the first time
          w === Gc ? void 0 : h && w[0] === Gc ? [] : w,
          v
        ]), w = C);
      } else
        E.run();
  };
  S.allowRecurse = !!t;
  let x;
  o === "sync" ? x = S : o === "post" ? x = () => Xr(S, f && f.suspense) : (S.pre = !0, f && (S.id = f.uid), x = () => cp(S));
  const E = new OE(c, x);
  te.env.NODE_ENV !== "production" && (E.onTrack = s, E.onTrigger = a), t ? r ? S() : w = E.run() : o === "post" ? Xr(
    E.run.bind(E),
    f && f.suspense
  ) : E.run();
  const N = () => {
    E.stop(), f && f.scope && NE(f.scope.effects, E);
  };
  return y && y.push(N), N;
}
function Y4(e, t, r) {
  const n = this.proxy, o = Ot(e) ? e.includes(".") ? jD(n, e) : () => n[e] : e.bind(n, n);
  let s;
  Je(t) ? s = t : (s = t.handler, r = t);
  const a = Zt;
  Hl(this);
  const l = qE(o, s.bind(n), r);
  return a ? Hl(a) : la(), l;
}
function jD(e, t) {
  const r = t.split(".");
  return () => {
    let n = e;
    for (let o = 0; o < r.length && n; o++)
      n = n[r[o]];
    return n;
  };
}
function Xs(e, t) {
  if (!_t(e) || e.__v_skip || (t = t || /* @__PURE__ */ new Set(), t.has(e)))
    return e;
  if (t.add(e), rr(e))
    Xs(e.value, t);
  else if (We(e))
    for (let r = 0; r < e.length; r++)
      Xs(e[r], t);
  else if (iD(e) || na(e))
    e.forEach((r) => {
      Xs(r, t);
    });
  else if (sD(e))
    for (const r in e)
      Xs(e[r], t);
  return e;
}
function BD(e) {
  wW(e) && Re("Do not use built-in directive ids as custom directive id: " + e);
}
function jr(e, t) {
  const r = nr;
  if (r === null)
    return te.env.NODE_ENV !== "production" && Re("withDirectives can only be used inside render functions."), e;
  const n = bp(r) || r.proxy, o = e.dirs || (e.dirs = []);
  for (let s = 0; s < t.length; s++) {
    let [a, l, u, f = Rt] = t[s];
    a && (Je(a) && (a = {
      mounted: a,
      updated: a
    }), a.deep && Xs(l), o.push({
      dir: a,
      instance: n,
      value: l,
      oldValue: void 0,
      arg: u,
      modifiers: f
    }));
  }
  return e;
}
function Ts(e, t, r, n) {
  const o = e.dirs, s = t && t.dirs;
  for (let a = 0; a < o.length; a++) {
    const l = o[a];
    s && (l.oldValue = s[a].value);
    let u = l.dir[n];
    u && (Pa(), Sn(u, r, 8, [
      e.el,
      l,
      e,
      t
    ]), Da());
  }
}
function X4() {
  const e = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return Dt(() => {
    e.isMounted = !0;
  }), VD(() => {
    e.isUnmounting = !0;
  }), e;
}
const vn = [Function, Array], qD = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: vn,
  onEnter: vn,
  onAfterEnter: vn,
  onEnterCancelled: vn,
  // leave
  onBeforeLeave: vn,
  onLeave: vn,
  onAfterLeave: vn,
  onLeaveCancelled: vn,
  // appear
  onBeforeAppear: vn,
  onAppear: vn,
  onAfterAppear: vn,
  onAppearCancelled: vn
}, J4 = {
  name: "BaseTransition",
  props: qD,
  setup(e, { slots: t }) {
    const r = KU(), n = X4();
    let o;
    return () => {
      const s = t.default && UD(t.default(), !0);
      if (!s || !s.length)
        return;
      let a = s[0];
      if (s.length > 1) {
        let y = !1;
        for (const w of s)
          if (w.type !== ar) {
            if (te.env.NODE_ENV !== "production" && y) {
              Re(
                "<transition> can only be used on a single element or component. Use <transition-group> for lists."
              );
              break;
            }
            if (a = w, y = !0, te.env.NODE_ENV === "production")
              break;
          }
      }
      const l = je(e), { mode: u } = l;
      if (te.env.NODE_ENV !== "production" && u && u !== "in-out" && u !== "out-in" && u !== "default" && Re(`invalid <transition> mode: ${u}`), n.isLeaving)
        return bb(a);
      const f = qA(a);
      if (!f)
        return bb(a);
      const c = x1(
        f,
        l,
        n,
        r
      );
      R1(f, c);
      const d = r.subTree, h = d && qA(d);
      let p = !1;
      const { getTransitionKey: v } = f.type;
      if (v) {
        const y = v();
        o === void 0 ? o = y : y !== o && (o = y, p = !0);
      }
      if (h && h.type !== ar && (!zs(f, h) || p)) {
        const y = x1(
          h,
          l,
          n,
          r
        );
        if (R1(h, y), u === "out-in")
          return n.isLeaving = !0, y.afterLeave = () => {
            n.isLeaving = !1, r.update.active !== !1 && r.update();
          }, bb(a);
        u === "in-out" && f.type !== ar && (y.delayLeave = (w, S, x) => {
          const E = WD(
            n,
            h
          );
          E[String(h.key)] = h, w._leaveCb = () => {
            S(), w._leaveCb = void 0, delete c.delayedLeave;
          }, c.delayedLeave = x;
        });
      }
      return a;
    };
  }
}, Q4 = J4;
function WD(e, t) {
  const { leavingVNodes: r } = e;
  let n = r.get(t.type);
  return n || (n = /* @__PURE__ */ Object.create(null), r.set(t.type, n)), n;
}
function x1(e, t, r, n) {
  const {
    appear: o,
    mode: s,
    persisted: a = !1,
    onBeforeEnter: l,
    onEnter: u,
    onAfterEnter: f,
    onEnterCancelled: c,
    onBeforeLeave: d,
    onLeave: h,
    onAfterLeave: p,
    onLeaveCancelled: v,
    onBeforeAppear: y,
    onAppear: w,
    onAfterAppear: S,
    onAppearCancelled: x
  } = t, E = String(e.key), N = WD(r, e), C = (z, $) => {
    z && Sn(
      z,
      n,
      9,
      $
    );
  }, j = (z, $) => {
    const G = $[1];
    C(z, $), We(z) ? z.every((I) => I.length <= 1) && G() : z.length <= 1 && G();
  }, J = {
    mode: s,
    persisted: a,
    beforeEnter(z) {
      let $ = l;
      if (!r.isMounted)
        if (o)
          $ = y || l;
        else
          return;
      z._leaveCb && z._leaveCb(
        !0
        /* cancelled */
      );
      const G = N[E];
      G && zs(e, G) && G.el._leaveCb && G.el._leaveCb(), C($, [z]);
    },
    enter(z) {
      let $ = u, G = f, I = c;
      if (!r.isMounted)
        if (o)
          $ = w || u, G = S || f, I = x || c;
        else
          return;
      let W = !1;
      const k = z._enterCb = (U) => {
        W || (W = !0, U ? C(I, [z]) : C(G, [z]), J.delayedLeave && J.delayedLeave(), z._enterCb = void 0);
      };
      $ ? j($, [z, k]) : k();
    },
    leave(z, $) {
      const G = String(e.key);
      if (z._enterCb && z._enterCb(
        !0
        /* cancelled */
      ), r.isUnmounting)
        return $();
      C(d, [z]);
      let I = !1;
      const W = z._leaveCb = (k) => {
        I || (I = !0, $(), k ? C(v, [z]) : C(p, [z]), z._leaveCb = void 0, N[G] === e && delete N[G]);
      };
      N[G] = e, h ? j(h, [z, W]) : W();
    },
    clone(z) {
      return x1(z, t, r, n);
    }
  };
  return J;
}
function bb(e) {
  if (bc(e))
    return e = Xn(e), e.children = null, e;
}
function qA(e) {
  return bc(e) ? e.children ? e.children[0] : void 0 : e;
}
function R1(e, t) {
  e.shapeFlag & 6 && e.component ? R1(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t;
}
function UD(e, t = !1, r) {
  let n = [], o = 0;
  for (let s = 0; s < e.length; s++) {
    let a = e[s];
    const l = r == null ? a.key : String(r) + String(a.key != null ? a.key : s);
    a.type === ut ? (a.patchFlag & 128 && o++, n = n.concat(
      UD(a.children, t, l)
    )) : (t || a.type !== ar) && n.push(l != null ? Xn(a, { key: l }) : a);
  }
  if (o > 1)
    for (let s = 0; s < n.length; s++)
      n[s].patchFlag = -2;
  return n;
}
function it(e, t) {
  return Je(e) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Ct({ name: e.name }, t, { setup: e })
  ) : e;
}
const gf = (e) => !!e.type.__asyncLoader, bc = (e) => e.type.__isKeepAlive;
function Z4(e, t) {
  HD(e, "a", t);
}
function eU(e, t) {
  HD(e, "da", t);
}
function HD(e, t, r = Zt) {
  const n = e.__wdc || (e.__wdc = () => {
    let o = r;
    for (; o; ) {
      if (o.isDeactivated)
        return;
      o = o.parent;
    }
    return e();
  });
  if (pp(t, n, r), r) {
    let o = r.parent;
    for (; o && o.parent; )
      bc(o.parent.vnode) && tU(n, t, r, o), o = o.parent;
  }
}
function tU(e, t, r, n) {
  const o = pp(
    t,
    e,
    n,
    !0
    /* prepend */
  );
  xn(() => {
    NE(n[t], o);
  }, r);
}
function pp(e, t, r = Zt, n = !1) {
  if (r) {
    const o = r[e] || (r[e] = []), s = t.__weh || (t.__weh = (...a) => {
      if (r.isUnmounted)
        return;
      Pa(), Hl(r);
      const l = Sn(t, r, e, a);
      return la(), Da(), l;
    });
    return n ? o.unshift(s) : o.push(s), s;
  } else if (te.env.NODE_ENV !== "production") {
    const o = Fs(DE[e].replace(/ hook$/, ""));
    Re(
      `${o} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
const Eo = (e) => (t, r = Zt) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!Wf || e === "sp") && pp(e, (...n) => t(...n), r)
), rU = Eo("bm"), Dt = Eo("m"), nU = Eo("bu"), iU = Eo("u"), VD = Eo("bum"), xn = Eo("um"), oU = Eo("sp"), sU = Eo(
  "rtg"
), aU = Eo(
  "rtc"
);
function lU(e, t = Zt) {
  pp("ec", e, t);
}
const A1 = "components";
function T1(e, t) {
  return fU(A1, e, !0, t) || e;
}
const uU = Symbol.for("v-ndc");
function fU(e, t, r = !0, n = !1) {
  const o = nr || Zt;
  if (o) {
    const s = o.type;
    if (e === A1) {
      const l = GE(
        s,
        !1
        /* do not include inferred name to avoid breaking existing code */
      );
      if (l && (l === t || l === Ri(t) || l === wa(Ri(t))))
        return s;
    }
    const a = (
      // local registration
      // check instance[type] first which is resolved for options API
      WA(o[e] || s[e], t) || // global registration
      WA(o.appContext[e], t)
    );
    if (!a && n)
      return s;
    if (te.env.NODE_ENV !== "production" && r && !a) {
      const l = e === A1 ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
      Re(`Failed to resolve ${e.slice(0, -1)}: ${t}${l}`);
    }
    return a;
  } else
    te.env.NODE_ENV !== "production" && Re(
      `resolve${wa(e.slice(0, -1))} can only be used in render() or setup().`
    );
}
function WA(e, t) {
  return e && (e[t] || e[Ri(t)] || e[wa(Ri(t))]);
}
function gr(e, t, r, n) {
  let o;
  const s = r && r[n];
  if (We(e) || Ot(e)) {
    o = new Array(e.length);
    for (let a = 0, l = e.length; a < l; a++)
      o[a] = t(e[a], a, void 0, s && s[a]);
  } else if (typeof e == "number") {
    te.env.NODE_ENV !== "production" && !Number.isInteger(e) && Re(`The v-for range expect an integer value but got ${e}.`), o = new Array(e);
    for (let a = 0; a < e; a++)
      o[a] = t(a + 1, a, void 0, s && s[a]);
  } else if (_t(e))
    if (e[Symbol.iterator])
      o = Array.from(
        e,
        (a, l) => t(a, l, void 0, s && s[l])
      );
    else {
      const a = Object.keys(e);
      o = new Array(a.length);
      for (let l = 0, u = a.length; l < u; l++) {
        const f = a[l];
        o[l] = t(e[f], f, l, s && s[l]);
      }
    }
  else
    o = [];
  return r && (r[n] = o), o;
}
function io(e, t, r = {}, n, o) {
  if (nr.isCE || nr.parent && gf(nr.parent) && nr.parent.isCE)
    return t !== "default" && (r.name = t), xe("slot", r, n && n());
  let s = e[t];
  te.env.NODE_ENV !== "production" && s && s.length > 1 && (Re(
    "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
  ), s = () => []), s && s._c && (s._d = !1), we();
  const a = s && zD(s(r)), l = xt(
    ut,
    {
      key: r.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      a && a.key || `_${t}`
    },
    a || (n ? n() : []),
    a && e._ === 1 ? 64 : -2
  );
  return !o && l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]), s && s._c && (s._d = !0), l;
}
function zD(e) {
  return e.some((t) => Ul(t) ? !(t.type === ar || t.type === ut && !zD(t.children)) : !0) ? e : null;
}
const $1 = (e) => e ? l3(e) ? bp(e) || e.proxy : $1(e.parent) : null, aa = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Ct(/* @__PURE__ */ Object.create(null), {
    $: (e) => e,
    $el: (e) => e.vnode.el,
    $data: (e) => e.data,
    $props: (e) => te.env.NODE_ENV !== "production" ? Vu(e.props) : e.props,
    $attrs: (e) => te.env.NODE_ENV !== "production" ? Vu(e.attrs) : e.attrs,
    $slots: (e) => te.env.NODE_ENV !== "production" ? Vu(e.slots) : e.slots,
    $refs: (e) => te.env.NODE_ENV !== "production" ? Vu(e.refs) : e.refs,
    $parent: (e) => $1(e.parent),
    $root: (e) => $1(e.root),
    $emit: (e) => e.emit,
    $options: (e) => UE(e),
    $forceUpdate: (e) => e.f || (e.f = () => cp(e.update)),
    $nextTick: (e) => e.n || (e.n = br.bind(e.proxy)),
    $watch: (e) => Y4.bind(e)
  })
), WE = (e) => e === "_" || e === "$", yb = (e, t) => e !== Rt && !e.__isScriptSetup && lt(e, t), GD = {
  get({ _: e }, t) {
    const { ctx: r, setupState: n, data: o, props: s, accessCache: a, type: l, appContext: u } = e;
    if (te.env.NODE_ENV !== "production" && t === "__isVue")
      return !0;
    let f;
    if (t[0] !== "$") {
      const p = a[t];
      if (p !== void 0)
        switch (p) {
          case 1:
            return n[t];
          case 2:
            return o[t];
          case 4:
            return r[t];
          case 3:
            return s[t];
        }
      else {
        if (yb(n, t))
          return a[t] = 1, n[t];
        if (o !== Rt && lt(o, t))
          return a[t] = 2, o[t];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (f = e.propsOptions[0]) && lt(f, t)
        )
          return a[t] = 3, s[t];
        if (r !== Rt && lt(r, t))
          return a[t] = 4, r[t];
        N1 && (a[t] = 0);
      }
    }
    const c = aa[t];
    let d, h;
    if (c)
      return t === "$attrs" ? (mr(e, "get", t), te.env.NODE_ENV !== "production" && uh()) : te.env.NODE_ENV !== "production" && t === "$slots" && mr(e, "get", t), c(e);
    if (
      // css module (injected by vue-loader)
      (d = l.__cssModules) && (d = d[t])
    )
      return d;
    if (r !== Rt && lt(r, t))
      return a[t] = 4, r[t];
    if (
      // global properties
      h = u.config.globalProperties, lt(h, t)
    )
      return h[t];
    te.env.NODE_ENV !== "production" && nr && (!Ot(t) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    t.indexOf("__v") !== 0) && (o !== Rt && WE(t[0]) && lt(o, t) ? Re(
      `Property ${JSON.stringify(
        t
      )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
    ) : e === nr && Re(
      `Property ${JSON.stringify(t)} was accessed during render but is not defined on instance.`
    ));
  },
  set({ _: e }, t, r) {
    const { data: n, setupState: o, ctx: s } = e;
    return yb(o, t) ? (o[t] = r, !0) : te.env.NODE_ENV !== "production" && o.__isScriptSetup && lt(o, t) ? (Re(`Cannot mutate <script setup> binding "${t}" from Options API.`), !1) : n !== Rt && lt(n, t) ? (n[t] = r, !0) : lt(e.props, t) ? (te.env.NODE_ENV !== "production" && Re(`Attempting to mutate prop "${t}". Props are readonly.`), !1) : t[0] === "$" && t.slice(1) in e ? (te.env.NODE_ENV !== "production" && Re(
      `Attempting to mutate public property "${t}". Properties starting with $ are reserved and readonly.`
    ), !1) : (te.env.NODE_ENV !== "production" && t in e.appContext.config.globalProperties ? Object.defineProperty(s, t, {
      enumerable: !0,
      configurable: !0,
      value: r
    }) : s[t] = r, !0);
  },
  has({
    _: { data: e, setupState: t, accessCache: r, ctx: n, appContext: o, propsOptions: s }
  }, a) {
    let l;
    return !!r[a] || e !== Rt && lt(e, a) || yb(t, a) || (l = s[0]) && lt(l, a) || lt(n, a) || lt(aa, a) || lt(o.config.globalProperties, a);
  },
  defineProperty(e, t, r) {
    return r.get != null ? e._.accessCache[t] = 0 : lt(r, "value") && this.set(e, t, r.value, null), Reflect.defineProperty(e, t, r);
  }
};
te.env.NODE_ENV !== "production" && (GD.ownKeys = (e) => (Re(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(e)));
function cU(e) {
  const t = {};
  return Object.defineProperty(t, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => e
  }), Object.keys(aa).forEach((r) => {
    Object.defineProperty(t, r, {
      configurable: !0,
      enumerable: !1,
      get: () => aa[r](e),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: hr
    });
  }), t;
}
function dU(e) {
  const {
    ctx: t,
    propsOptions: [r]
  } = e;
  r && Object.keys(r).forEach((n) => {
    Object.defineProperty(t, n, {
      enumerable: !0,
      configurable: !0,
      get: () => e.props[n],
      set: hr
    });
  });
}
function hU(e) {
  const { ctx: t, setupState: r } = e;
  Object.keys(je(r)).forEach((n) => {
    if (!r.__isScriptSetup) {
      if (WE(n[0])) {
        Re(
          `setup() return property ${JSON.stringify(
            n
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(t, n, {
        enumerable: !0,
        configurable: !0,
        get: () => r[n],
        set: hr
      });
    }
  });
}
function UA(e) {
  return We(e) ? e.reduce(
    (t, r) => (t[r] = null, t),
    {}
  ) : e;
}
function pU() {
  const e = /* @__PURE__ */ Object.create(null);
  return (t, r) => {
    e[r] ? Re(`${t} property "${r}" is already defined in ${e[r]}.`) : e[r] = t;
  };
}
let N1 = !0;
function gU(e) {
  const t = UE(e), r = e.proxy, n = e.ctx;
  N1 = !1, t.beforeCreate && HA(t.beforeCreate, e, "bc");
  const {
    // state
    data: o,
    computed: s,
    methods: a,
    watch: l,
    provide: u,
    inject: f,
    // lifecycle
    created: c,
    beforeMount: d,
    mounted: h,
    beforeUpdate: p,
    updated: v,
    activated: y,
    deactivated: w,
    beforeDestroy: S,
    beforeUnmount: x,
    destroyed: E,
    unmounted: N,
    render: C,
    renderTracked: j,
    renderTriggered: J,
    errorCaptured: z,
    serverPrefetch: $,
    // public API
    expose: G,
    inheritAttrs: I,
    // assets
    components: W,
    directives: k,
    filters: U
  } = t, Z = te.env.NODE_ENV !== "production" ? pU() : null;
  if (te.env.NODE_ENV !== "production") {
    const [re] = e.propsOptions;
    if (re)
      for (const ae in re)
        Z("Props", ae);
  }
  if (f && bU(f, n, Z), a)
    for (const re in a) {
      const ae = a[re];
      Je(ae) ? (te.env.NODE_ENV !== "production" ? Object.defineProperty(n, re, {
        value: ae.bind(r),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : n[re] = ae.bind(r), te.env.NODE_ENV !== "production" && Z("Methods", re)) : te.env.NODE_ENV !== "production" && Re(
        `Method "${re}" has type "${typeof ae}" in the component definition. Did you reference the function correctly?`
      );
    }
  if (o) {
    te.env.NODE_ENV !== "production" && !Je(o) && Re(
      "The data option must be a function. Plain object usage is no longer supported."
    );
    const re = o.call(r, r);
    if (te.env.NODE_ENV !== "production" && CE(re) && Re(
      "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
    ), !_t(re))
      te.env.NODE_ENV !== "production" && Re("data() should return an object.");
    else if (e.data = lp(re), te.env.NODE_ENV !== "production")
      for (const ae in re)
        Z("Data", ae), WE(ae[0]) || Object.defineProperty(n, ae, {
          configurable: !0,
          enumerable: !0,
          get: () => re[ae],
          set: hr
        });
  }
  if (N1 = !0, s)
    for (const re in s) {
      const ae = s[re], ce = Je(ae) ? ae.bind(r, r) : Je(ae.get) ? ae.get.bind(r, r) : hr;
      te.env.NODE_ENV !== "production" && ce === hr && Re(`Computed property "${re}" has no getter.`);
      const pe = !Je(ae) && Je(ae.set) ? ae.set.bind(r) : te.env.NODE_ENV !== "production" ? () => {
        Re(
          `Write operation failed: computed property "${re}" is readonly.`
        );
      } : hr, le = Oe({
        get: ce,
        set: pe
      });
      Object.defineProperty(n, re, {
        enumerable: !0,
        configurable: !0,
        get: () => le.value,
        set: (ye) => le.value = ye
      }), te.env.NODE_ENV !== "production" && Z("Computed", re);
    }
  if (l)
    for (const re in l)
      KD(l[re], n, r, re);
  if (u) {
    const re = Je(u) ? u.call(r) : u;
    Reflect.ownKeys(re).forEach((ae) => {
      $n(ae, re[ae]);
    });
  }
  c && HA(c, e, "c");
  function Y(re, ae) {
    We(ae) ? ae.forEach((ce) => re(ce.bind(r))) : ae && re(ae.bind(r));
  }
  if (Y(rU, d), Y(Dt, h), Y(nU, p), Y(iU, v), Y(Z4, y), Y(eU, w), Y(lU, z), Y(aU, j), Y(sU, J), Y(VD, x), Y(xn, N), Y(oU, $), We(G))
    if (G.length) {
      const re = e.exposed || (e.exposed = {});
      G.forEach((ae) => {
        Object.defineProperty(re, ae, {
          get: () => r[ae],
          set: (ce) => r[ae] = ce
        });
      });
    } else
      e.exposed || (e.exposed = {});
  C && e.render === hr && (e.render = C), I != null && (e.inheritAttrs = I), W && (e.components = W), k && (e.directives = k);
}
function bU(e, t, r = hr) {
  We(e) && (e = k1(e));
  for (const n in e) {
    const o = e[n];
    let s;
    _t(o) ? "default" in o ? s = vr(
      o.from || n,
      o.default,
      !0
      /* treat default function as factory */
    ) : s = vr(o.from || n) : s = vr(o), rr(s) ? Object.defineProperty(t, n, {
      enumerable: !0,
      configurable: !0,
      get: () => s.value,
      set: (a) => s.value = a
    }) : t[n] = s, te.env.NODE_ENV !== "production" && r("Inject", n);
  }
}
function HA(e, t, r) {
  Sn(
    We(e) ? e.map((n) => n.bind(t.proxy)) : e.bind(t.proxy),
    t,
    r
  );
}
function KD(e, t, r, n) {
  const o = n.includes(".") ? jD(r, n) : () => r[n];
  if (Ot(e)) {
    const s = t[e];
    Je(s) ? yr(o, s) : te.env.NODE_ENV !== "production" && Re(`Invalid watch handler specified by key "${e}"`, s);
  } else if (Je(e))
    yr(o, e.bind(r));
  else if (_t(e))
    if (We(e))
      e.forEach((s) => KD(s, t, r, n));
    else {
      const s = Je(e.handler) ? e.handler.bind(r) : t[e.handler];
      Je(s) ? yr(o, s, e) : te.env.NODE_ENV !== "production" && Re(`Invalid watch handler specified by key "${e.handler}"`, s);
    }
  else
    te.env.NODE_ENV !== "production" && Re(`Invalid watch option: "${n}"`, e);
}
function UE(e) {
  const t = e.type, { mixins: r, extends: n } = t, {
    mixins: o,
    optionsCache: s,
    config: { optionMergeStrategies: a }
  } = e.appContext, l = s.get(t);
  let u;
  return l ? u = l : !o.length && !r && !n ? u = t : (u = {}, o.length && o.forEach(
    (f) => fh(u, f, a, !0)
  ), fh(u, t, a)), _t(t) && s.set(t, u), u;
}
function fh(e, t, r, n = !1) {
  const { mixins: o, extends: s } = t;
  s && fh(e, s, r, !0), o && o.forEach(
    (a) => fh(e, a, r, !0)
  );
  for (const a in t)
    if (n && a === "expose")
      te.env.NODE_ENV !== "production" && Re(
        '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
      );
    else {
      const l = yU[a] || r && r[a];
      e[a] = l ? l(e[a], t[a]) : t[a];
    }
  return e;
}
const yU = {
  data: VA,
  props: zA,
  emits: zA,
  // objects
  methods: Gu,
  computed: Gu,
  // lifecycle
  beforeCreate: Dr,
  created: Dr,
  beforeMount: Dr,
  mounted: Dr,
  beforeUpdate: Dr,
  updated: Dr,
  beforeDestroy: Dr,
  beforeUnmount: Dr,
  destroyed: Dr,
  unmounted: Dr,
  activated: Dr,
  deactivated: Dr,
  errorCaptured: Dr,
  serverPrefetch: Dr,
  // assets
  components: Gu,
  directives: Gu,
  // watch
  watch: mU,
  // provide / inject
  provide: VA,
  inject: vU
};
function VA(e, t) {
  return t ? e ? function() {
    return Ct(
      Je(e) ? e.call(this, this) : e,
      Je(t) ? t.call(this, this) : t
    );
  } : t : e;
}
function vU(e, t) {
  return Gu(k1(e), k1(t));
}
function k1(e) {
  if (We(e)) {
    const t = {};
    for (let r = 0; r < e.length; r++)
      t[e[r]] = e[r];
    return t;
  }
  return e;
}
function Dr(e, t) {
  return e ? [...new Set([].concat(e, t))] : t;
}
function Gu(e, t) {
  return e ? Ct(/* @__PURE__ */ Object.create(null), e, t) : t;
}
function zA(e, t) {
  return e ? We(e) && We(t) ? [.../* @__PURE__ */ new Set([...e, ...t])] : Ct(
    /* @__PURE__ */ Object.create(null),
    UA(e),
    UA(t ?? {})
  ) : t;
}
function mU(e, t) {
  if (!e)
    return t;
  if (!t)
    return e;
  const r = Ct(/* @__PURE__ */ Object.create(null), e);
  for (const n in t)
    r[n] = Dr(e[n], t[n]);
  return r;
}
function YD() {
  return {
    app: null,
    config: {
      isNativeTag: nD,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let _U = 0;
function wU(e, t) {
  return function(n, o = null) {
    Je(n) || (n = Ct({}, n)), o != null && !_t(o) && (te.env.NODE_ENV !== "production" && Re("root props passed to app.mount() must be an object."), o = null);
    const s = YD();
    te.env.NODE_ENV !== "production" && Object.defineProperty(s.config, "unwrapInjectedRef", {
      get() {
        return !0;
      },
      set() {
        Re(
          "app.config.unwrapInjectedRef has been deprecated. 3.3 now alawys unwraps injected refs in Options API."
        );
      }
    });
    const a = /* @__PURE__ */ new Set();
    let l = !1;
    const u = s.app = {
      _uid: _U++,
      _component: n,
      _props: o,
      _container: null,
      _context: s,
      _instance: null,
      version: nT,
      get config() {
        return s.config;
      },
      set config(f) {
        te.env.NODE_ENV !== "production" && Re(
          "app.config cannot be replaced. Modify individual options instead."
        );
      },
      use(f, ...c) {
        return a.has(f) ? te.env.NODE_ENV !== "production" && Re("Plugin has already been applied to target app.") : f && Je(f.install) ? (a.add(f), f.install(u, ...c)) : Je(f) ? (a.add(f), f(u, ...c)) : te.env.NODE_ENV !== "production" && Re(
          'A plugin must either be a function or an object with an "install" function.'
        ), u;
      },
      mixin(f) {
        return s.mixins.includes(f) ? te.env.NODE_ENV !== "production" && Re(
          "Mixin has already been applied to target app" + (f.name ? `: ${f.name}` : "")
        ) : s.mixins.push(f), u;
      },
      component(f, c) {
        return te.env.NODE_ENV !== "production" && L1(f, s.config), c ? (te.env.NODE_ENV !== "production" && s.components[f] && Re(`Component "${f}" has already been registered in target app.`), s.components[f] = c, u) : s.components[f];
      },
      directive(f, c) {
        return te.env.NODE_ENV !== "production" && BD(f), c ? (te.env.NODE_ENV !== "production" && s.directives[f] && Re(`Directive "${f}" has already been registered in target app.`), s.directives[f] = c, u) : s.directives[f];
      },
      mount(f, c, d) {
        if (l)
          te.env.NODE_ENV !== "production" && Re(
            "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
          );
        else {
          te.env.NODE_ENV !== "production" && f.__vue_app__ && Re(
            "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
          );
          const h = xe(
            n,
            o
          );
          return h.appContext = s, te.env.NODE_ENV !== "production" && (s.reload = () => {
            e(Xn(h), f, d);
          }), c && t ? t(h, f) : e(h, f, d), l = !0, u._container = f, f.__vue_app__ = u, te.env.NODE_ENV !== "production" && (u._instance = h.component, C4(u, nT)), bp(h.component) || h.component.proxy;
        }
      },
      unmount() {
        l ? (e(null, u._container), te.env.NODE_ENV !== "production" && (u._instance = null, I4(u)), delete u._container.__vue_app__) : te.env.NODE_ENV !== "production" && Re("Cannot unmount an app that is not mounted.");
      },
      provide(f, c) {
        return te.env.NODE_ENV !== "production" && f in s.provides && Re(
          `App already provides property with key "${String(f)}". It will be overwritten with the new value.`
        ), s.provides[f] = c, u;
      },
      runWithContext(f) {
        ch = u;
        try {
          return f();
        } finally {
          ch = null;
        }
      }
    };
    return u;
  };
}
let ch = null;
function $n(e, t) {
  if (!Zt)
    te.env.NODE_ENV !== "production" && Re("provide() can only be used inside setup().");
  else {
    let r = Zt.provides;
    const n = Zt.parent && Zt.parent.provides;
    n === r && (r = Zt.provides = Object.create(n)), r[e] = t;
  }
}
function vr(e, t, r = !1) {
  const n = Zt || nr;
  if (n || ch) {
    const o = n ? n.parent == null ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides : ch._context.provides;
    if (o && e in o)
      return o[e];
    if (arguments.length > 1)
      return r && Je(t) ? t.call(n && n.proxy) : t;
    te.env.NODE_ENV !== "production" && Re(`injection "${String(e)}" not found.`);
  } else
    te.env.NODE_ENV !== "production" && Re("inject() can only be used inside setup() or functional components.");
}
function SU(e, t, r, n = !1) {
  const o = {}, s = {};
  oh(s, gp, 1), e.propsDefaults = /* @__PURE__ */ Object.create(null), XD(e, t, o, s);
  for (const a in e.propsOptions[0])
    a in o || (o[a] = void 0);
  te.env.NODE_ENV !== "production" && QD(t || {}, o, e), r ? e.props = n ? o : c4(o) : e.type.props ? e.props = o : e.props = s, e.attrs = s;
}
function EU(e) {
  for (; e; ) {
    if (e.type.__hmrId)
      return !0;
    e = e.parent;
  }
}
function xU(e, t, r, n) {
  const {
    props: o,
    attrs: s,
    vnode: { patchFlag: a }
  } = e, l = je(o), [u] = e.propsOptions;
  let f = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(te.env.NODE_ENV !== "production" && EU(e)) && (n || a > 0) && !(a & 16)
  ) {
    if (a & 8) {
      const c = e.vnode.dynamicProps;
      for (let d = 0; d < c.length; d++) {
        let h = c[d];
        if (dp(e.emitsOptions, h))
          continue;
        const p = t[h];
        if (u)
          if (lt(s, h))
            p !== s[h] && (s[h] = p, f = !0);
          else {
            const v = Ri(h);
            o[v] = C1(
              u,
              l,
              v,
              p,
              e,
              !1
              /* isAbsent */
            );
          }
        else
          p !== s[h] && (s[h] = p, f = !0);
      }
    }
  } else {
    XD(e, t, o, s) && (f = !0);
    let c;
    for (const d in l)
      (!t || // for camelCase
      !lt(t, d) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((c = is(d)) === d || !lt(t, c))) && (u ? r && // for camelCase
      (r[d] !== void 0 || // for kebab-case
      r[c] !== void 0) && (o[d] = C1(
        u,
        l,
        d,
        void 0,
        e,
        !0
        /* isAbsent */
      )) : delete o[d]);
    if (s !== l)
      for (const d in s)
        (!t || !lt(t, d)) && (delete s[d], f = !0);
  }
  f && Ai(e, "set", "$attrs"), te.env.NODE_ENV !== "production" && QD(t || {}, o, e);
}
function XD(e, t, r, n) {
  const [o, s] = e.propsOptions;
  let a = !1, l;
  if (t)
    for (let u in t) {
      if (Ld(u))
        continue;
      const f = t[u];
      let c;
      o && lt(o, c = Ri(u)) ? !s || !s.includes(c) ? r[c] = f : (l || (l = {}))[c] = f : dp(e.emitsOptions, u) || (!(u in n) || f !== n[u]) && (n[u] = f, a = !0);
    }
  if (s) {
    const u = je(r), f = l || Rt;
    for (let c = 0; c < s.length; c++) {
      const d = s[c];
      r[d] = C1(
        o,
        u,
        d,
        f[d],
        e,
        !lt(f, d)
      );
    }
  }
  return a;
}
function C1(e, t, r, n, o, s) {
  const a = e[r];
  if (a != null) {
    const l = lt(a, "default");
    if (l && n === void 0) {
      const u = a.default;
      if (a.type !== Function && !a.skipFactory && Je(u)) {
        const { propsDefaults: f } = o;
        r in f ? n = f[r] : (Hl(o), n = f[r] = u.call(
          null,
          t
        ), la());
      } else
        n = u;
    }
    a[
      0
      /* shouldCast */
    ] && (s && !l ? n = !1 : a[
      1
      /* shouldCastTrue */
    ] && (n === "" || n === is(r)) && (n = !0));
  }
  return n;
}
function JD(e, t, r = !1) {
  const n = t.propsCache, o = n.get(e);
  if (o)
    return o;
  const s = e.props, a = {}, l = [];
  let u = !1;
  if (!Je(e)) {
    const c = (d) => {
      u = !0;
      const [h, p] = JD(d, t, !0);
      Ct(a, h), p && l.push(...p);
    };
    !r && t.mixins.length && t.mixins.forEach(c), e.extends && c(e.extends), e.mixins && e.mixins.forEach(c);
  }
  if (!s && !u)
    return _t(e) && n.set(e, Nl), Nl;
  if (We(s))
    for (let c = 0; c < s.length; c++) {
      te.env.NODE_ENV !== "production" && !Ot(s[c]) && Re("props must be strings when using array syntax.", s[c]);
      const d = Ri(s[c]);
      GA(d) && (a[d] = Rt);
    }
  else if (s) {
    te.env.NODE_ENV !== "production" && !_t(s) && Re("invalid props options", s);
    for (const c in s) {
      const d = Ri(c);
      if (GA(d)) {
        const h = s[c], p = a[d] = We(h) || Je(h) ? { type: h } : Ct({}, h);
        if (p) {
          const v = YA(Boolean, p.type), y = YA(String, p.type);
          p[
            0
            /* shouldCast */
          ] = v > -1, p[
            1
            /* shouldCastTrue */
          ] = y < 0 || v < y, (v > -1 || lt(p, "default")) && l.push(d);
        }
      }
    }
  }
  const f = [a, l];
  return _t(e) && n.set(e, f), f;
}
function GA(e) {
  return e[0] !== "$" ? !0 : (te.env.NODE_ENV !== "production" && Re(`Invalid prop name: "${e}" is a reserved property.`), !1);
}
function I1(e) {
  const t = e && e.toString().match(/^\s*(function|class) (\w+)/);
  return t ? t[2] : e === null ? "null" : "";
}
function KA(e, t) {
  return I1(e) === I1(t);
}
function YA(e, t) {
  return We(t) ? t.findIndex((r) => KA(r, e)) : Je(t) && KA(t, e) ? 0 : -1;
}
function QD(e, t, r) {
  const n = je(t), o = r.propsOptions[0];
  for (const s in o) {
    let a = o[s];
    a != null && RU(
      s,
      n[s],
      a,
      !lt(e, s) && !lt(e, is(s))
    );
  }
}
function RU(e, t, r, n) {
  const { type: o, required: s, validator: a, skipCheck: l } = r;
  if (s && n) {
    Re('Missing required prop: "' + e + '"');
    return;
  }
  if (!(t == null && !s)) {
    if (o != null && o !== !0 && !l) {
      let u = !1;
      const f = We(o) ? o : [o], c = [];
      for (let d = 0; d < f.length && !u; d++) {
        const { valid: h, expectedType: p } = TU(t, f[d]);
        c.push(p || ""), u = h;
      }
      if (!u) {
        Re($U(e, t, c));
        return;
      }
    }
    a && !a(t) && Re('Invalid prop: custom validator check failed for prop "' + e + '".');
  }
}
const AU = /* @__PURE__ */ bs(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function TU(e, t) {
  let r;
  const n = I1(t);
  if (AU(n)) {
    const o = typeof e;
    r = o === n.toLowerCase(), !r && o === "object" && (r = e instanceof t);
  } else
    n === "Object" ? r = _t(e) : n === "Array" ? r = We(e) : n === "null" ? r = e === null : r = e instanceof t;
  return {
    valid: r,
    expectedType: n
  };
}
function $U(e, t, r) {
  let n = `Invalid prop: type check failed for prop "${e}". Expected ${r.map(wa).join(" | ")}`;
  const o = r[0], s = IE(t), a = XA(t, o), l = XA(t, s);
  return r.length === 1 && JA(o) && !NU(o, s) && (n += ` with value ${a}`), n += `, got ${s} `, JA(s) && (n += `with value ${l}.`), n;
}
function XA(e, t) {
  return t === "String" ? `"${e}"` : t === "Number" ? `${Number(e)}` : `${e}`;
}
function JA(e) {
  return ["string", "number", "boolean"].some((r) => e.toLowerCase() === r);
}
function NU(...e) {
  return e.some((t) => t.toLowerCase() === "boolean");
}
const ZD = (e) => e[0] === "_" || e === "$stable", HE = (e) => We(e) ? e.map(Wn) : [Wn(e)], kU = (e, t, r) => {
  if (t._n)
    return t;
  const n = Ge((...o) => (te.env.NODE_ENV !== "production" && Zt && Re(
    `Slot "${e}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
  ), HE(t(...o))), r);
  return n._c = !1, n;
}, e3 = (e, t, r) => {
  const n = e._ctx;
  for (const o in e) {
    if (ZD(o))
      continue;
    const s = e[o];
    if (Je(s))
      t[o] = kU(o, s, n);
    else if (s != null) {
      te.env.NODE_ENV !== "production" && Re(
        `Non-function value encountered for slot "${o}". Prefer function slots for better performance.`
      );
      const a = HE(s);
      t[o] = () => a;
    }
  }
}, t3 = (e, t) => {
  te.env.NODE_ENV !== "production" && !bc(e.vnode) && Re(
    "Non-function value encountered for default slot. Prefer function slots for better performance."
  );
  const r = HE(t);
  e.slots.default = () => r;
}, CU = (e, t) => {
  if (e.vnode.shapeFlag & 32) {
    const r = t._;
    r ? (e.slots = je(t), oh(t, "_", r)) : e3(
      t,
      e.slots = {}
    );
  } else
    e.slots = {}, t && t3(e, t);
  oh(e.slots, gp, 1);
}, IU = (e, t, r) => {
  const { vnode: n, slots: o } = e;
  let s = !0, a = Rt;
  if (n.shapeFlag & 32) {
    const l = t._;
    l ? te.env.NODE_ENV !== "production" && es ? (Ct(o, t), Ai(e, "set", "$slots")) : r && l === 1 ? s = !1 : (Ct(o, t), !r && l === 1 && delete o._) : (s = !t.$stable, e3(t, o)), a = t;
  } else
    t && (t3(e, t), a = { default: 1 });
  if (s)
    for (const l in o)
      !ZD(l) && !(l in a) && delete o[l];
};
function M1(e, t, r, n, o = !1) {
  if (We(e)) {
    e.forEach(
      (h, p) => M1(
        h,
        t && (We(t) ? t[p] : t),
        r,
        n,
        o
      )
    );
    return;
  }
  if (gf(n) && !o)
    return;
  const s = n.shapeFlag & 4 ? bp(n.component) || n.component.proxy : n.el, a = o ? null : s, { i: l, r: u } = e;
  if (te.env.NODE_ENV !== "production" && !l) {
    Re(
      "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
    );
    return;
  }
  const f = t && t.r, c = l.refs === Rt ? l.refs = {} : l.refs, d = l.setupState;
  if (f != null && f !== u && (Ot(f) ? (c[f] = null, lt(d, f) && (d[f] = null)) : rr(f) && (f.value = null)), Je(u))
    ro(u, l, 12, [a, c]);
  else {
    const h = Ot(u), p = rr(u);
    if (h || p) {
      const v = () => {
        if (e.f) {
          const y = h ? lt(d, u) ? d[u] : c[u] : u.value;
          o ? We(y) && NE(y, s) : We(y) ? y.includes(s) || y.push(s) : h ? (c[u] = [s], lt(d, u) && (d[u] = c[u])) : (u.value = [s], e.k && (c[e.k] = u.value));
        } else
          h ? (c[u] = a, lt(d, u) && (d[u] = a)) : p ? (u.value = a, e.k && (c[e.k] = a)) : te.env.NODE_ENV !== "production" && Re("Invalid template ref type:", u, `(${typeof u})`);
      };
      a ? (v.id = -1, Xr(v, r)) : v();
    } else
      te.env.NODE_ENV !== "production" && Re("Invalid template ref type:", u, `(${typeof u})`);
  }
}
let ku, Ho;
function Ki(e, t) {
  e.appContext.config.performance && dh() && Ho.mark(`vue-${t}-${e.uid}`), te.env.NODE_ENV !== "production" && P4(e, t, dh() ? Ho.now() : Date.now());
}
function Yi(e, t) {
  if (e.appContext.config.performance && dh()) {
    const r = `vue-${t}-${e.uid}`, n = r + ":end";
    Ho.mark(n), Ho.measure(
      `<${yp(e, e.type)}> ${t}`,
      r,
      n
    ), Ho.clearMarks(r), Ho.clearMarks(n);
  }
  te.env.NODE_ENV !== "production" && D4(e, t, dh() ? Ho.now() : Date.now());
}
function dh() {
  return ku !== void 0 || (typeof window < "u" && window.performance ? (ku = !0, Ho = window.performance) : ku = !1), ku;
}
function MU() {
  const e = [];
  if (te.env.NODE_ENV !== "production" && e.length) {
    const t = e.length > 1;
    console.warn(
      `Feature flag${t ? "s" : ""} ${e.join(", ")} ${t ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
const Xr = K4;
function OU(e) {
  return LU(e);
}
function LU(e, t) {
  MU();
  const r = sh();
  r.__VUE__ = !0, te.env.NODE_ENV !== "production" && OD(r.__VUE_DEVTOOLS_GLOBAL_HOOK__, r);
  const {
    insert: n,
    remove: o,
    patchProp: s,
    createElement: a,
    createText: l,
    createComment: u,
    setText: f,
    setElementText: c,
    parentNode: d,
    nextSibling: h,
    setScopeId: p = hr,
    insertStaticContent: v
  } = e, y = (b, _, T, L = null, O = null, ie = null, fe = !1, se = null, ve = te.env.NODE_ENV !== "production" && es ? !1 : !!_.dynamicChildren) => {
    if (b === _)
      return;
    b && !zs(b, _) && (L = be(b), H(b, O, ie, !0), b = null), _.patchFlag === -2 && (ve = !1, _.dynamicChildren = null);
    const { type: B, ref: me, shapeFlag: ke } = _;
    switch (B) {
      case yc:
        w(b, _, T, L);
        break;
      case ar:
        S(b, _, T, L);
        break;
      case yf:
        b == null ? x(_, T, L, fe) : te.env.NODE_ENV !== "production" && E(b, _, T, fe);
        break;
      case ut:
        k(
          b,
          _,
          T,
          L,
          O,
          ie,
          fe,
          se,
          ve
        );
        break;
      default:
        ke & 1 ? j(
          b,
          _,
          T,
          L,
          O,
          ie,
          fe,
          se,
          ve
        ) : ke & 6 ? U(
          b,
          _,
          T,
          L,
          O,
          ie,
          fe,
          se,
          ve
        ) : ke & 64 || ke & 128 ? B.process(
          b,
          _,
          T,
          L,
          O,
          ie,
          fe,
          se,
          ve,
          Pe
        ) : te.env.NODE_ENV !== "production" && Re("Invalid VNode type:", B, `(${typeof B})`);
    }
    me != null && O && M1(me, b && b.ref, ie, _ || b, !_);
  }, w = (b, _, T, L) => {
    if (b == null)
      n(
        _.el = l(_.children),
        T,
        L
      );
    else {
      const O = _.el = b.el;
      _.children !== b.children && f(O, _.children);
    }
  }, S = (b, _, T, L) => {
    b == null ? n(
      _.el = u(_.children || ""),
      T,
      L
    ) : _.el = b.el;
  }, x = (b, _, T, L) => {
    [b.el, b.anchor] = v(
      b.children,
      _,
      T,
      L,
      b.el,
      b.anchor
    );
  }, E = (b, _, T, L) => {
    if (_.children !== b.children) {
      const O = h(b.anchor);
      C(b), [_.el, _.anchor] = v(
        _.children,
        T,
        O,
        L
      );
    } else
      _.el = b.el, _.anchor = b.anchor;
  }, N = ({ el: b, anchor: _ }, T, L) => {
    let O;
    for (; b && b !== _; )
      O = h(b), n(b, T, L), b = O;
    n(_, T, L);
  }, C = ({ el: b, anchor: _ }) => {
    let T;
    for (; b && b !== _; )
      T = h(b), o(b), b = T;
    o(_);
  }, j = (b, _, T, L, O, ie, fe, se, ve) => {
    fe = fe || _.type === "svg", b == null ? J(
      _,
      T,
      L,
      O,
      ie,
      fe,
      se,
      ve
    ) : G(
      b,
      _,
      O,
      ie,
      fe,
      se,
      ve
    );
  }, J = (b, _, T, L, O, ie, fe, se) => {
    let ve, B;
    const { type: me, props: ke, shapeFlag: Ie, transition: Me, dirs: M } = b;
    if (ve = b.el = a(
      b.type,
      ie,
      ke && ke.is,
      ke
    ), Ie & 8 ? c(ve, b.children) : Ie & 16 && $(
      b.children,
      ve,
      null,
      L,
      O,
      ie && me !== "foreignObject",
      fe,
      se
    ), M && Ts(b, null, L, "created"), z(ve, b, b.scopeId, fe, L), ke) {
      for (const A in ke)
        A !== "value" && !Ld(A) && s(
          ve,
          A,
          null,
          ke[A],
          ie,
          b.children,
          L,
          O,
          ee
        );
      "value" in ke && s(ve, "value", null, ke.value), (B = ke.onVnodeBeforeMount) && li(B, L, b);
    }
    te.env.NODE_ENV !== "production" && (Object.defineProperty(ve, "__vnode", {
      value: b,
      enumerable: !1
    }), Object.defineProperty(ve, "__vueParentComponent", {
      value: L,
      enumerable: !1
    })), M && Ts(b, null, L, "beforeMount");
    const R = (!O || O && !O.pendingBranch) && Me && !Me.persisted;
    R && Me.beforeEnter(ve), n(ve, _, T), ((B = ke && ke.onVnodeMounted) || R || M) && Xr(() => {
      B && li(B, L, b), R && Me.enter(ve), M && Ts(b, null, L, "mounted");
    }, O);
  }, z = (b, _, T, L, O) => {
    if (T && p(b, T), L)
      for (let ie = 0; ie < L.length; ie++)
        p(b, L[ie]);
    if (O) {
      let ie = O.subTree;
      if (te.env.NODE_ENV !== "production" && ie.patchFlag > 0 && ie.patchFlag & 2048 && (ie = FD(ie.children) || ie), _ === ie) {
        const fe = O.vnode;
        z(
          b,
          fe,
          fe.scopeId,
          fe.slotScopeIds,
          O.parent
        );
      }
    }
  }, $ = (b, _, T, L, O, ie, fe, se, ve = 0) => {
    for (let B = ve; B < b.length; B++) {
      const me = b[B] = se ? Do(b[B]) : Wn(b[B]);
      y(
        null,
        me,
        _,
        T,
        L,
        O,
        ie,
        fe,
        se
      );
    }
  }, G = (b, _, T, L, O, ie, fe) => {
    const se = _.el = b.el;
    let { patchFlag: ve, dynamicChildren: B, dirs: me } = _;
    ve |= b.patchFlag & 16;
    const ke = b.props || Rt, Ie = _.props || Rt;
    let Me;
    T && $s(T, !1), (Me = Ie.onVnodeBeforeUpdate) && li(Me, T, _, b), me && Ts(_, b, T, "beforeUpdate"), T && $s(T, !0), te.env.NODE_ENV !== "production" && es && (ve = 0, fe = !1, B = null);
    const M = O && _.type !== "foreignObject";
    if (B ? (I(
      b.dynamicChildren,
      B,
      se,
      T,
      L,
      M,
      ie
    ), te.env.NODE_ENV !== "production" && bf(b, _)) : fe || ce(
      b,
      _,
      se,
      null,
      T,
      L,
      M,
      ie,
      !1
    ), ve > 0) {
      if (ve & 16)
        W(
          se,
          _,
          ke,
          Ie,
          T,
          L,
          O
        );
      else if (ve & 2 && ke.class !== Ie.class && s(se, "class", null, Ie.class, O), ve & 4 && s(se, "style", ke.style, Ie.style, O), ve & 8) {
        const R = _.dynamicProps;
        for (let A = 0; A < R.length; A++) {
          const q = R[A], ne = ke[q], de = Ie[q];
          (de !== ne || q === "value") && s(
            se,
            q,
            ne,
            de,
            O,
            b.children,
            T,
            L,
            ee
          );
        }
      }
      ve & 1 && b.children !== _.children && c(se, _.children);
    } else
      !fe && B == null && W(
        se,
        _,
        ke,
        Ie,
        T,
        L,
        O
      );
    ((Me = Ie.onVnodeUpdated) || me) && Xr(() => {
      Me && li(Me, T, _, b), me && Ts(_, b, T, "updated");
    }, L);
  }, I = (b, _, T, L, O, ie, fe) => {
    for (let se = 0; se < _.length; se++) {
      const ve = b[se], B = _[se], me = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        ve.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (ve.type === ut || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !zs(ve, B) || // - In the case of a component, it could contain anything.
        ve.shapeFlag & 70) ? d(ve.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          T
        )
      );
      y(
        ve,
        B,
        me,
        null,
        L,
        O,
        ie,
        fe,
        !0
      );
    }
  }, W = (b, _, T, L, O, ie, fe) => {
    if (T !== L) {
      if (T !== Rt)
        for (const se in T)
          !Ld(se) && !(se in L) && s(
            b,
            se,
            T[se],
            null,
            fe,
            _.children,
            O,
            ie,
            ee
          );
      for (const se in L) {
        if (Ld(se))
          continue;
        const ve = L[se], B = T[se];
        ve !== B && se !== "value" && s(
          b,
          se,
          B,
          ve,
          fe,
          _.children,
          O,
          ie,
          ee
        );
      }
      "value" in L && s(b, "value", T.value, L.value);
    }
  }, k = (b, _, T, L, O, ie, fe, se, ve) => {
    const B = _.el = b ? b.el : l(""), me = _.anchor = b ? b.anchor : l("");
    let { patchFlag: ke, dynamicChildren: Ie, slotScopeIds: Me } = _;
    te.env.NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
    (es || ke & 2048) && (ke = 0, ve = !1, Ie = null), Me && (se = se ? se.concat(Me) : Me), b == null ? (n(B, T, L), n(me, T, L), $(
      _.children,
      T,
      me,
      O,
      ie,
      fe,
      se,
      ve
    )) : ke > 0 && ke & 64 && Ie && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    b.dynamicChildren ? (I(
      b.dynamicChildren,
      Ie,
      T,
      O,
      ie,
      fe,
      se
    ), te.env.NODE_ENV !== "production" ? bf(b, _) : (
      // #2080 if the stable fragment has a key, it's a <template v-for> that may
      //  get moved around. Make sure all root level vnodes inherit el.
      // #2134 or if it's a component root, it may also get moved around
      // as the component is being moved.
      (_.key != null || O && _ === O.subTree) && bf(
        b,
        _,
        !0
        /* shallow */
      )
    )) : ce(
      b,
      _,
      T,
      me,
      O,
      ie,
      fe,
      se,
      ve
    );
  }, U = (b, _, T, L, O, ie, fe, se, ve) => {
    _.slotScopeIds = se, b == null ? _.shapeFlag & 512 ? O.ctx.activate(
      _,
      T,
      L,
      fe,
      ve
    ) : Z(
      _,
      T,
      L,
      O,
      ie,
      fe,
      ve
    ) : Y(b, _, ve);
  }, Z = (b, _, T, L, O, ie, fe) => {
    const se = b.component = GU(
      b,
      L,
      O
    );
    if (te.env.NODE_ENV !== "production" && se.type.__hmrId && T4(se), te.env.NODE_ENV !== "production" && (Pd(b), Ki(se, "mount")), bc(b) && (se.ctx.renderer = Pe), te.env.NODE_ENV !== "production" && Ki(se, "init"), XU(se), te.env.NODE_ENV !== "production" && Yi(se, "init"), se.asyncDep) {
      if (O && O.registerDep(se, re), !b.el) {
        const ve = se.subTree = xe(ar);
        S(null, ve, _, T);
      }
      return;
    }
    re(
      se,
      b,
      _,
      T,
      O,
      ie,
      fe
    ), te.env.NODE_ENV !== "production" && (Dd(), Yi(se, "mount"));
  }, Y = (b, _, T) => {
    const L = _.component = b.component;
    if (V4(b, _, T))
      if (L.asyncDep && !L.asyncResolved) {
        te.env.NODE_ENV !== "production" && Pd(_), ae(L, _, T), te.env.NODE_ENV !== "production" && Dd();
        return;
      } else
        L.next = _, R4(L.update), L.update();
    else
      _.el = b.el, L.vnode = _;
  }, re = (b, _, T, L, O, ie, fe) => {
    const se = () => {
      if (b.isMounted) {
        let { next: me, bu: ke, u: Ie, parent: Me, vnode: M } = b, R = me, A;
        te.env.NODE_ENV !== "production" && Pd(me || b.vnode), $s(b, !1), me ? (me.el = M.el, ae(b, me, fe)) : me = M, ke && dl(ke), (A = me.props && me.props.onVnodeBeforeUpdate) && li(A, Me, me, M), $s(b, !0), te.env.NODE_ENV !== "production" && Ki(b, "render");
        const q = gb(b);
        te.env.NODE_ENV !== "production" && Yi(b, "render");
        const ne = b.subTree;
        b.subTree = q, te.env.NODE_ENV !== "production" && Ki(b, "patch"), y(
          ne,
          q,
          // parent may have changed if it's in a teleport
          d(ne.el),
          // anchor may have changed if it's in a fragment
          be(ne),
          b,
          O,
          ie
        ), te.env.NODE_ENV !== "production" && Yi(b, "patch"), me.el = q.el, R === null && z4(b, q.el), Ie && Xr(Ie, O), (A = me.props && me.props.onVnodeUpdated) && Xr(
          () => li(A, Me, me, M),
          O
        ), te.env.NODE_ENV !== "production" && LD(b), te.env.NODE_ENV !== "production" && Dd();
      } else {
        let me;
        const { el: ke, props: Ie } = _, { bm: Me, m: M, parent: R } = b, A = gf(_);
        if ($s(b, !1), Me && dl(Me), !A && (me = Ie && Ie.onVnodeBeforeMount) && li(me, R, _), $s(b, !0), ke && V) {
          const q = () => {
            te.env.NODE_ENV !== "production" && Ki(b, "render"), b.subTree = gb(b), te.env.NODE_ENV !== "production" && Yi(b, "render"), te.env.NODE_ENV !== "production" && Ki(b, "hydrate"), V(
              ke,
              b.subTree,
              b,
              O,
              null
            ), te.env.NODE_ENV !== "production" && Yi(b, "hydrate");
          };
          A ? _.type.__asyncLoader().then(
            // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            () => !b.isUnmounted && q()
          ) : q();
        } else {
          te.env.NODE_ENV !== "production" && Ki(b, "render");
          const q = b.subTree = gb(b);
          te.env.NODE_ENV !== "production" && Yi(b, "render"), te.env.NODE_ENV !== "production" && Ki(b, "patch"), y(
            null,
            q,
            T,
            L,
            b,
            O,
            ie
          ), te.env.NODE_ENV !== "production" && Yi(b, "patch"), _.el = q.el;
        }
        if (M && Xr(M, O), !A && (me = Ie && Ie.onVnodeMounted)) {
          const q = _;
          Xr(
            () => li(me, R, q),
            O
          );
        }
        (_.shapeFlag & 256 || R && gf(R.vnode) && R.vnode.shapeFlag & 256) && b.a && Xr(b.a, O), b.isMounted = !0, te.env.NODE_ENV !== "production" && M4(b), _ = T = L = null;
      }
    }, ve = b.effect = new OE(
      se,
      () => cp(B),
      b.scope
      // track it in component's effect scope
    ), B = b.update = () => ve.run();
    B.id = b.uid, $s(b, !0), te.env.NODE_ENV !== "production" && (ve.onTrack = b.rtc ? (me) => dl(b.rtc, me) : void 0, ve.onTrigger = b.rtg ? (me) => dl(b.rtg, me) : void 0, B.ownerInstance = b), B();
  }, ae = (b, _, T) => {
    _.component = b;
    const L = b.vnode.props;
    b.vnode = _, b.next = null, xU(b, _.props, L, T), IU(b, _.children, T), Pa(), DA(), Da();
  }, ce = (b, _, T, L, O, ie, fe, se, ve = !1) => {
    const B = b && b.children, me = b ? b.shapeFlag : 0, ke = _.children, { patchFlag: Ie, shapeFlag: Me } = _;
    if (Ie > 0) {
      if (Ie & 128) {
        le(
          B,
          ke,
          T,
          L,
          O,
          ie,
          fe,
          se,
          ve
        );
        return;
      } else if (Ie & 256) {
        pe(
          B,
          ke,
          T,
          L,
          O,
          ie,
          fe,
          se,
          ve
        );
        return;
      }
    }
    Me & 8 ? (me & 16 && ee(B, O, ie), ke !== B && c(T, ke)) : me & 16 ? Me & 16 ? le(
      B,
      ke,
      T,
      L,
      O,
      ie,
      fe,
      se,
      ve
    ) : ee(B, O, ie, !0) : (me & 8 && c(T, ""), Me & 16 && $(
      ke,
      T,
      L,
      O,
      ie,
      fe,
      se,
      ve
    ));
  }, pe = (b, _, T, L, O, ie, fe, se, ve) => {
    b = b || Nl, _ = _ || Nl;
    const B = b.length, me = _.length, ke = Math.min(B, me);
    let Ie;
    for (Ie = 0; Ie < ke; Ie++) {
      const Me = _[Ie] = ve ? Do(_[Ie]) : Wn(_[Ie]);
      y(
        b[Ie],
        Me,
        T,
        null,
        O,
        ie,
        fe,
        se,
        ve
      );
    }
    B > me ? ee(
      b,
      O,
      ie,
      !0,
      !1,
      ke
    ) : $(
      _,
      T,
      L,
      O,
      ie,
      fe,
      se,
      ve,
      ke
    );
  }, le = (b, _, T, L, O, ie, fe, se, ve) => {
    let B = 0;
    const me = _.length;
    let ke = b.length - 1, Ie = me - 1;
    for (; B <= ke && B <= Ie; ) {
      const Me = b[B], M = _[B] = ve ? Do(_[B]) : Wn(_[B]);
      if (zs(Me, M))
        y(
          Me,
          M,
          T,
          null,
          O,
          ie,
          fe,
          se,
          ve
        );
      else
        break;
      B++;
    }
    for (; B <= ke && B <= Ie; ) {
      const Me = b[ke], M = _[Ie] = ve ? Do(_[Ie]) : Wn(_[Ie]);
      if (zs(Me, M))
        y(
          Me,
          M,
          T,
          null,
          O,
          ie,
          fe,
          se,
          ve
        );
      else
        break;
      ke--, Ie--;
    }
    if (B > ke) {
      if (B <= Ie) {
        const Me = Ie + 1, M = Me < me ? _[Me].el : L;
        for (; B <= Ie; )
          y(
            null,
            _[B] = ve ? Do(_[B]) : Wn(_[B]),
            T,
            M,
            O,
            ie,
            fe,
            se,
            ve
          ), B++;
      }
    } else if (B > Ie)
      for (; B <= ke; )
        H(b[B], O, ie, !0), B++;
    else {
      const Me = B, M = B, R = /* @__PURE__ */ new Map();
      for (B = M; B <= Ie; B++) {
        const ze = _[B] = ve ? Do(_[B]) : Wn(_[B]);
        ze.key != null && (te.env.NODE_ENV !== "production" && R.has(ze.key) && Re(
          "Duplicate keys found during update:",
          JSON.stringify(ze.key),
          "Make sure keys are unique."
        ), R.set(ze.key, B));
      }
      let A, q = 0;
      const ne = Ie - M + 1;
      let de = !1, he = 0;
      const Fe = new Array(ne);
      for (B = 0; B < ne; B++)
        Fe[B] = 0;
      for (B = Me; B <= ke; B++) {
        const ze = b[B];
        if (q >= ne) {
          H(ze, O, ie, !0);
          continue;
        }
        let Ke;
        if (ze.key != null)
          Ke = R.get(ze.key);
        else
          for (A = M; A <= Ie; A++)
            if (Fe[A - M] === 0 && zs(ze, _[A])) {
              Ke = A;
              break;
            }
        Ke === void 0 ? H(ze, O, ie, !0) : (Fe[Ke - M] = B + 1, Ke >= he ? he = Ke : de = !0, y(
          ze,
          _[Ke],
          T,
          null,
          O,
          ie,
          fe,
          se,
          ve
        ), q++);
      }
      const ot = de ? PU(Fe) : Nl;
      for (A = ot.length - 1, B = ne - 1; B >= 0; B--) {
        const ze = M + B, Ke = _[ze], et = ze + 1 < me ? _[ze + 1].el : L;
        Fe[B] === 0 ? y(
          null,
          Ke,
          T,
          et,
          O,
          ie,
          fe,
          se,
          ve
        ) : de && (A < 0 || B !== ot[A] ? ye(Ke, T, et, 2) : A--);
      }
    }
  }, ye = (b, _, T, L, O = null) => {
    const { el: ie, type: fe, transition: se, children: ve, shapeFlag: B } = b;
    if (B & 6) {
      ye(b.component.subTree, _, T, L);
      return;
    }
    if (B & 128) {
      b.suspense.move(_, T, L);
      return;
    }
    if (B & 64) {
      fe.move(b, _, T, Pe);
      return;
    }
    if (fe === ut) {
      n(ie, _, T);
      for (let ke = 0; ke < ve.length; ke++)
        ye(ve[ke], _, T, L);
      n(b.anchor, _, T);
      return;
    }
    if (fe === yf) {
      N(b, _, T);
      return;
    }
    if (L !== 2 && B & 1 && se)
      if (L === 0)
        se.beforeEnter(ie), n(ie, _, T), Xr(() => se.enter(ie), O);
      else {
        const { leave: ke, delayLeave: Ie, afterLeave: Me } = se, M = () => n(ie, _, T), R = () => {
          ke(ie, () => {
            M(), Me && Me();
          });
        };
        Ie ? Ie(ie, M, R) : R();
      }
    else
      n(ie, _, T);
  }, H = (b, _, T, L = !1, O = !1) => {
    const {
      type: ie,
      props: fe,
      ref: se,
      children: ve,
      dynamicChildren: B,
      shapeFlag: me,
      patchFlag: ke,
      dirs: Ie
    } = b;
    if (se != null && M1(se, null, T, b, !0), me & 256) {
      _.ctx.deactivate(b);
      return;
    }
    const Me = me & 1 && Ie, M = !gf(b);
    let R;
    if (M && (R = fe && fe.onVnodeBeforeUnmount) && li(R, _, b), me & 6)
      ue(b.component, T, L);
    else {
      if (me & 128) {
        b.suspense.unmount(T, L);
        return;
      }
      Me && Ts(b, null, _, "beforeUnmount"), me & 64 ? b.type.remove(
        b,
        _,
        T,
        O,
        Pe,
        L
      ) : B && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (ie !== ut || ke > 0 && ke & 64) ? ee(
        B,
        _,
        T,
        !1,
        !0
      ) : (ie === ut && ke & 384 || !O && me & 16) && ee(ve, _, T), L && ge(b);
    }
    (M && (R = fe && fe.onVnodeUnmounted) || Me) && Xr(() => {
      R && li(R, _, b), Me && Ts(b, null, _, "unmounted");
    }, T);
  }, ge = (b) => {
    const { type: _, el: T, anchor: L, transition: O } = b;
    if (_ === ut) {
      te.env.NODE_ENV !== "production" && b.patchFlag > 0 && b.patchFlag & 2048 && O && !O.persisted ? b.children.forEach((fe) => {
        fe.type === ar ? o(fe.el) : ge(fe);
      }) : Ce(T, L);
      return;
    }
    if (_ === yf) {
      C(b);
      return;
    }
    const ie = () => {
      o(T), O && !O.persisted && O.afterLeave && O.afterLeave();
    };
    if (b.shapeFlag & 1 && O && !O.persisted) {
      const { leave: fe, delayLeave: se } = O, ve = () => fe(T, ie);
      se ? se(b.el, ie, ve) : ve();
    } else
      ie();
  }, Ce = (b, _) => {
    let T;
    for (; b !== _; )
      T = h(b), o(b), b = T;
    o(_);
  }, ue = (b, _, T) => {
    te.env.NODE_ENV !== "production" && b.type.__hmrId && $4(b);
    const { bum: L, scope: O, update: ie, subTree: fe, um: se } = b;
    L && dl(L), O.stop(), ie && (ie.active = !1, H(fe, b, _, T)), se && Xr(se, _), Xr(() => {
      b.isUnmounted = !0;
    }, _), _ && _.pendingBranch && !_.isUnmounted && b.asyncDep && !b.asyncResolved && b.suspenseId === _.pendingId && (_.deps--, _.deps === 0 && _.resolve()), te.env.NODE_ENV !== "production" && L4(b);
  }, ee = (b, _, T, L = !1, O = !1, ie = 0) => {
    for (let fe = ie; fe < b.length; fe++)
      H(b[fe], _, T, L, O);
  }, be = (b) => b.shapeFlag & 6 ? be(b.component.subTree) : b.shapeFlag & 128 ? b.suspense.next() : h(b.anchor || b.el), Te = (b, _, T) => {
    b == null ? _._vnode && H(_._vnode, null, null, !0) : y(_._vnode || null, b, _, null, null, null, T), DA(), CD(), _._vnode = b;
  }, Pe = {
    p: y,
    um: H,
    m: ye,
    r: ge,
    mt: Z,
    mc: $,
    pc: ce,
    pbc: I,
    n: be,
    o: e
  };
  let K, V;
  return t && ([K, V] = t(
    Pe
  )), {
    render: Te,
    hydrate: K,
    createApp: wU(Te, K)
  };
}
function $s({ effect: e, update: t }, r) {
  e.allowRecurse = t.allowRecurse = r;
}
function bf(e, t, r = !1) {
  const n = e.children, o = t.children;
  if (We(n) && We(o))
    for (let s = 0; s < n.length; s++) {
      const a = n[s];
      let l = o[s];
      l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = o[s] = Do(o[s]), l.el = a.el), r || bf(a, l)), l.type === yc && (l.el = a.el), te.env.NODE_ENV !== "production" && l.type === ar && !l.el && (l.el = a.el);
    }
}
function PU(e) {
  const t = e.slice(), r = [0];
  let n, o, s, a, l;
  const u = e.length;
  for (n = 0; n < u; n++) {
    const f = e[n];
    if (f !== 0) {
      if (o = r[r.length - 1], e[o] < f) {
        t[n] = o, r.push(n);
        continue;
      }
      for (s = 0, a = r.length - 1; s < a; )
        l = s + a >> 1, e[r[l]] < f ? s = l + 1 : a = l;
      f < e[r[s]] && (s > 0 && (t[n] = r[s - 1]), r[s] = n);
    }
  }
  for (s = r.length, a = r[s - 1]; s-- > 0; )
    r[s] = a, a = t[a];
  return r;
}
const DU = (e) => e.__isTeleport, Cl = (e) => e && (e.disabled || e.disabled === ""), QA = (e) => typeof SVGElement < "u" && e instanceof SVGElement, O1 = (e, t) => {
  const r = e && e.to;
  if (Ot(r))
    if (t) {
      const n = t(r);
      return n || te.env.NODE_ENV !== "production" && Re(
        `Failed to locate Teleport target with selector "${r}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
      ), n;
    } else
      return te.env.NODE_ENV !== "production" && Re(
        "Current renderer does not support string target for Teleports. (missing querySelector renderer option)"
      ), null;
  else
    return te.env.NODE_ENV !== "production" && !r && !Cl(e) && Re(`Invalid Teleport target: ${r}`), r;
}, FU = {
  __isTeleport: !0,
  process(e, t, r, n, o, s, a, l, u, f) {
    const {
      mc: c,
      pc: d,
      pbc: h,
      o: { insert: p, querySelector: v, createText: y, createComment: w }
    } = f, S = Cl(t.props);
    let { shapeFlag: x, children: E, dynamicChildren: N } = t;
    if (te.env.NODE_ENV !== "production" && es && (u = !1, N = null), e == null) {
      const C = t.el = te.env.NODE_ENV !== "production" ? w("teleport start") : y(""), j = t.anchor = te.env.NODE_ENV !== "production" ? w("teleport end") : y("");
      p(C, r, n), p(j, r, n);
      const J = t.target = O1(t.props, v), z = t.targetAnchor = y("");
      J ? (p(z, J), a = a || QA(J)) : te.env.NODE_ENV !== "production" && !S && Re("Invalid Teleport target on mount:", J, `(${typeof J})`);
      const $ = (G, I) => {
        x & 16 && c(
          E,
          G,
          I,
          o,
          s,
          a,
          l,
          u
        );
      };
      S ? $(r, j) : J && $(J, z);
    } else {
      t.el = e.el;
      const C = t.anchor = e.anchor, j = t.target = e.target, J = t.targetAnchor = e.targetAnchor, z = Cl(e.props), $ = z ? r : j, G = z ? C : J;
      if (a = a || QA(j), N ? (h(
        e.dynamicChildren,
        N,
        $,
        o,
        s,
        a,
        l
      ), bf(e, t, !0)) : u || d(
        e,
        t,
        $,
        G,
        o,
        s,
        a,
        l,
        !1
      ), S)
        z || Kc(
          t,
          r,
          C,
          f,
          1
        );
      else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
        const I = t.target = O1(
          t.props,
          v
        );
        I ? Kc(
          t,
          I,
          null,
          f,
          0
        ) : te.env.NODE_ENV !== "production" && Re(
          "Invalid Teleport target on update:",
          j,
          `(${typeof j})`
        );
      } else
        z && Kc(
          t,
          j,
          J,
          f,
          1
        );
    }
    r3(t);
  },
  remove(e, t, r, n, { um: o, o: { remove: s } }, a) {
    const { shapeFlag: l, children: u, anchor: f, targetAnchor: c, target: d, props: h } = e;
    if (d && s(c), (a || !Cl(h)) && (s(f), l & 16))
      for (let p = 0; p < u.length; p++) {
        const v = u[p];
        o(
          v,
          t,
          r,
          !0,
          !!v.dynamicChildren
        );
      }
  },
  move: Kc,
  hydrate: jU
};
function Kc(e, t, r, { o: { insert: n }, m: o }, s = 2) {
  s === 0 && n(e.targetAnchor, t, r);
  const { el: a, anchor: l, shapeFlag: u, children: f, props: c } = e, d = s === 2;
  if (d && n(a, t, r), (!d || Cl(c)) && u & 16)
    for (let h = 0; h < f.length; h++)
      o(
        f[h],
        t,
        r,
        2
      );
  d && n(l, t, r);
}
function jU(e, t, r, n, o, s, {
  o: { nextSibling: a, parentNode: l, querySelector: u }
}, f) {
  const c = t.target = O1(
    t.props,
    u
  );
  if (c) {
    const d = c._lpa || c.firstChild;
    if (t.shapeFlag & 16)
      if (Cl(t.props))
        t.anchor = f(
          a(e),
          t,
          l(e),
          r,
          n,
          o,
          s
        ), t.targetAnchor = d;
      else {
        t.anchor = a(e);
        let h = d;
        for (; h; )
          if (h = a(h), h && h.nodeType === 8 && h.data === "teleport anchor") {
            t.targetAnchor = h, c._lpa = t.targetAnchor && a(t.targetAnchor);
            break;
          }
        f(
          d,
          t,
          c,
          r,
          n,
          o,
          s
        );
      }
    r3(t);
  }
  return t.anchor && a(t.anchor);
}
const BU = FU;
function r3(e) {
  const t = e.ctx;
  if (t && t.ut) {
    let r = e.children[0].el;
    for (; r !== e.targetAnchor; )
      r.nodeType === 1 && r.setAttribute("data-v-owner", t.uid), r = r.nextSibling;
    t.ut();
  }
}
const ut = Symbol.for("v-fgt"), yc = Symbol.for("v-txt"), ar = Symbol.for("v-cmt"), yf = Symbol.for("v-stc"), vf = [];
let Vn = null;
function we(e = !1) {
  vf.push(Vn = e ? null : []);
}
function qU() {
  vf.pop(), Vn = vf[vf.length - 1] || null;
}
let qf = 1;
function ZA(e) {
  qf += e;
}
function n3(e) {
  return e.dynamicChildren = qf > 0 ? Vn || Nl : null, qU(), qf > 0 && Vn && Vn.push(e), e;
}
function $e(e, t, r, n, o, s) {
  return n3(
    oe(
      e,
      t,
      r,
      n,
      o,
      s,
      !0
      /* isBlock */
    )
  );
}
function xt(e, t, r, n, o) {
  return n3(
    xe(
      e,
      t,
      r,
      n,
      o,
      !0
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function Ul(e) {
  return e ? e.__v_isVNode === !0 : !1;
}
function zs(e, t) {
  return te.env.NODE_ENV !== "production" && t.shapeFlag & 6 && hl.has(t.type) ? (e.shapeFlag &= -257, t.shapeFlag &= -513, !1) : e.type === t.type && e.key === t.key;
}
const WU = (...e) => o3(
  ...e
), gp = "__vInternal", i3 = ({ key: e }) => e ?? null, Fd = ({
  ref: e,
  ref_key: t,
  ref_for: r
}) => (typeof e == "number" && (e = "" + e), e != null ? Ot(e) || rr(e) || Je(e) ? { i: nr, r: e, k: t, f: !!r } : e : null);
function oe(e, t = null, r = null, n = 0, o = null, s = e === ut ? 0 : 1, a = !1, l = !1) {
  const u = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && i3(t),
    ref: t && Fd(t),
    scopeId: hp,
    slotScopeIds: null,
    children: r,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: s,
    patchFlag: n,
    dynamicProps: o,
    dynamicChildren: null,
    appContext: null,
    ctx: nr
  };
  return l ? (VE(u, r), s & 128 && e.normalize(u)) : r && (u.shapeFlag |= Ot(r) ? 8 : 16), te.env.NODE_ENV !== "production" && u.key !== u.key && Re("VNode created with invalid key (NaN). VNode type:", u.type), qf > 0 && // avoid a block node from tracking itself
  !a && // has current parent block
  Vn && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (u.patchFlag > 0 || s & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  u.patchFlag !== 32 && Vn.push(u), u;
}
const xe = te.env.NODE_ENV !== "production" ? WU : o3;
function o3(e, t = null, r = null, n = 0, o = null, s = !1) {
  if ((!e || e === uU) && (te.env.NODE_ENV !== "production" && !e && Re(`Invalid vnode type when creating vnode: ${e}.`), e = ar), Ul(e)) {
    const l = Xn(
      e,
      t,
      !0
      /* mergeRef: true */
    );
    return r && VE(l, r), qf > 0 && !s && Vn && (l.shapeFlag & 6 ? Vn[Vn.indexOf(e)] = l : Vn.push(l)), l.patchFlag |= -2, l;
  }
  if (f3(e) && (e = e.__vccOpts), t) {
    t = UU(t);
    let { class: l, style: u } = t;
    l && !Ot(l) && (t.class = lr(l)), _t(u) && (_1(u) && !We(u) && (u = Ct({}, u)), t.style = ip(u));
  }
  const a = Ot(e) ? 1 : G4(e) ? 128 : DU(e) ? 64 : _t(e) ? 4 : Je(e) ? 2 : 0;
  return te.env.NODE_ENV !== "production" && a & 4 && _1(e) && (e = je(e), Re(
    "Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    e
  )), oe(
    e,
    t,
    r,
    n,
    o,
    a,
    s,
    !0
  );
}
function UU(e) {
  return e ? _1(e) || gp in e ? Ct({}, e) : e : null;
}
function Xn(e, t, r = !1) {
  const { props: n, ref: o, patchFlag: s, children: a } = e, l = t ? HU(n || {}, t) : n;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e.type,
    props: l,
    key: l && i3(l),
    ref: t && t.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      r && o ? We(o) ? o.concat(Fd(t)) : [o, Fd(t)] : Fd(t)
    ) : o,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: te.env.NODE_ENV !== "production" && s === -1 && We(a) ? a.map(s3) : a,
    target: e.target,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: t && e.type !== ut ? s === -1 ? 16 : s | 16 : s,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: e.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && Xn(e.ssContent),
    ssFallback: e.ssFallback && Xn(e.ssFallback),
    el: e.el,
    anchor: e.anchor,
    ctx: e.ctx,
    ce: e.ce
  };
}
function s3(e) {
  const t = Xn(e);
  return We(e.children) && (t.children = e.children.map(s3)), t;
}
function tn(e = " ", t = 0) {
  return xe(yc, null, e, t);
}
function a3(e, t) {
  const r = xe(yf, null, e);
  return r.staticCount = t, r;
}
function bt(e = "", t = !1) {
  return t ? (we(), xt(ar, null, e)) : xe(ar, null, e);
}
function Wn(e) {
  return e == null || typeof e == "boolean" ? xe(ar) : We(e) ? xe(
    ut,
    null,
    // #3666, avoid reference pollution when reusing vnode
    e.slice()
  ) : typeof e == "object" ? Do(e) : xe(yc, null, String(e));
}
function Do(e) {
  return e.el === null && e.patchFlag !== -1 || e.memo ? e : Xn(e);
}
function VE(e, t) {
  let r = 0;
  const { shapeFlag: n } = e;
  if (t == null)
    t = null;
  else if (We(t))
    r = 16;
  else if (typeof t == "object")
    if (n & 65) {
      const o = t.default;
      o && (o._c && (o._d = !1), VE(e, o()), o._c && (o._d = !0));
      return;
    } else {
      r = 32;
      const o = t._;
      !o && !(gp in t) ? t._ctx = nr : o === 3 && nr && (nr.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024));
    }
  else
    Je(t) ? (t = { default: t, _ctx: nr }, r = 32) : (t = String(t), n & 64 ? (r = 16, t = [tn(t)]) : r = 8);
  e.children = t, e.shapeFlag |= r;
}
function HU(...e) {
  const t = {};
  for (let r = 0; r < e.length; r++) {
    const n = e[r];
    for (const o in n)
      if (o === "class")
        t.class !== n.class && (t.class = lr([t.class, n.class]));
      else if (o === "style")
        t.style = ip([t.style, n.style]);
      else if (pc(o)) {
        const s = t[o], a = n[o];
        a && s !== a && !(We(s) && s.includes(a)) && (t[o] = s ? [].concat(s, a) : a);
      } else
        o !== "" && (t[o] = n[o]);
  }
  return t;
}
function li(e, t, r, n = null) {
  Sn(e, t, 7, [
    r,
    n
  ]);
}
const VU = YD();
let zU = 0;
function GU(e, t, r) {
  const n = e.type, o = (t ? t.appContext : e.appContext) || VU, s = {
    uid: zU++,
    vnode: e,
    type: n,
    parent: t,
    appContext: o,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new LW(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: t ? t.provides : Object.create(o.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: JD(n, o),
    emitsOptions: DD(n, o),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: Rt,
    // inheritAttrs
    inheritAttrs: n.inheritAttrs,
    // state
    ctx: Rt,
    data: Rt,
    props: Rt,
    attrs: Rt,
    slots: Rt,
    refs: Rt,
    setupState: Rt,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense: r,
    suspenseId: r ? r.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return te.env.NODE_ENV !== "production" ? s.ctx = cU(s) : s.ctx = { _: s }, s.root = t ? t.root : s, s.emit = j4.bind(null, s), e.ce && e.ce(s), s;
}
let Zt = null;
const KU = () => Zt || nr;
let zE, ul, eT = "__VUE_INSTANCE_SETTERS__";
(ul = sh()[eT]) || (ul = sh()[eT] = []), ul.push((e) => Zt = e), zE = (e) => {
  ul.length > 1 ? ul.forEach((t) => t(e)) : ul[0](e);
};
const Hl = (e) => {
  zE(e), e.scope.on();
}, la = () => {
  Zt && Zt.scope.off(), zE(null);
}, YU = /* @__PURE__ */ bs("slot,component");
function L1(e, t) {
  const r = t.isNativeTag || nD;
  (YU(e) || r(e)) && Re(
    "Do not use built-in or reserved HTML elements as component id: " + e
  );
}
function l3(e) {
  return e.vnode.shapeFlag & 4;
}
let Wf = !1;
function XU(e, t = !1) {
  Wf = t;
  const { props: r, children: n } = e.vnode, o = l3(e);
  SU(e, r, o, t), CU(e, n);
  const s = o ? JU(e, t) : void 0;
  return Wf = !1, s;
}
function JU(e, t) {
  var r;
  const n = e.type;
  if (te.env.NODE_ENV !== "production") {
    if (n.name && L1(n.name, e.appContext.config), n.components) {
      const s = Object.keys(n.components);
      for (let a = 0; a < s.length; a++)
        L1(s[a], e.appContext.config);
    }
    if (n.directives) {
      const s = Object.keys(n.directives);
      for (let a = 0; a < s.length; a++)
        BD(s[a]);
    }
    n.compilerOptions && QU() && Re(
      '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
    );
  }
  e.accessCache = /* @__PURE__ */ Object.create(null), e.proxy = SD(new Proxy(e.ctx, GD)), te.env.NODE_ENV !== "production" && dU(e);
  const { setup: o } = n;
  if (o) {
    const s = e.setupContext = o.length > 1 ? eH(e) : null;
    Hl(e), Pa();
    const a = ro(
      o,
      e,
      0,
      [te.env.NODE_ENV !== "production" ? Vu(e.props) : e.props, s]
    );
    if (Da(), la(), CE(a)) {
      if (a.then(la, la), t)
        return a.then((l) => {
          tT(e, l, t);
        }).catch((l) => {
          fp(l, e, 0);
        });
      if (e.asyncDep = a, te.env.NODE_ENV !== "production" && !e.suspense) {
        const l = (r = n.name) != null ? r : "Anonymous";
        Re(
          `Component <${l}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
        );
      }
    } else
      tT(e, a, t);
  } else
    u3(e, t);
}
function tT(e, t, r) {
  Je(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : _t(t) ? (te.env.NODE_ENV !== "production" && Ul(t) && Re(
    "setup() should not return VNodes directly - return a render function instead."
  ), te.env.NODE_ENV !== "production" && (e.devtoolsRawSetupState = t), e.setupState = AD(t), te.env.NODE_ENV !== "production" && hU(e)) : te.env.NODE_ENV !== "production" && t !== void 0 && Re(
    `setup() should return an object. Received: ${t === null ? "null" : typeof t}`
  ), u3(e, r);
}
let P1;
const QU = () => !P1;
function u3(e, t, r) {
  const n = e.type;
  if (!e.render) {
    if (!t && P1 && !n.render) {
      const o = n.template || UE(e).template;
      if (o) {
        te.env.NODE_ENV !== "production" && Ki(e, "compile");
        const { isCustomElement: s, compilerOptions: a } = e.appContext.config, { delimiters: l, compilerOptions: u } = n, f = Ct(
          Ct(
            {
              isCustomElement: s,
              delimiters: l
            },
            a
          ),
          u
        );
        n.render = P1(o, f), te.env.NODE_ENV !== "production" && Yi(e, "compile");
      }
    }
    e.render = n.render || hr;
  }
  Hl(e), Pa(), gU(e), Da(), la(), te.env.NODE_ENV !== "production" && !n.render && e.render === hr && !t && (n.template ? Re(
    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
    /* should not happen */
  ) : Re("Component is missing template or render function."));
}
function rT(e) {
  return e.attrsProxy || (e.attrsProxy = new Proxy(
    e.attrs,
    te.env.NODE_ENV !== "production" ? {
      get(t, r) {
        return uh(), mr(e, "get", "$attrs"), t[r];
      },
      set() {
        return Re("setupContext.attrs is readonly."), !1;
      },
      deleteProperty() {
        return Re("setupContext.attrs is readonly."), !1;
      }
    } : {
      get(t, r) {
        return mr(e, "get", "$attrs"), t[r];
      }
    }
  ));
}
function ZU(e) {
  return e.slotsProxy || (e.slotsProxy = new Proxy(e.slots, {
    get(t, r) {
      return mr(e, "get", "$slots"), t[r];
    }
  }));
}
function eH(e) {
  const t = (r) => {
    if (te.env.NODE_ENV !== "production" && (e.exposed && Re("expose() should be called only once per setup()."), r != null)) {
      let n = typeof r;
      n === "object" && (We(r) ? n = "array" : rr(r) && (n = "ref")), n !== "object" && Re(
        `expose() should be passed a plain object, received ${n}.`
      );
    }
    e.exposed = r || {};
  };
  return te.env.NODE_ENV !== "production" ? Object.freeze({
    get attrs() {
      return rT(e);
    },
    get slots() {
      return ZU(e);
    },
    get emit() {
      return (r, ...n) => e.emit(r, ...n);
    },
    expose: t
  }) : {
    get attrs() {
      return rT(e);
    },
    slots: e.slots,
    emit: e.emit,
    expose: t
  };
}
function bp(e) {
  if (e.exposed)
    return e.exposeProxy || (e.exposeProxy = new Proxy(AD(SD(e.exposed)), {
      get(t, r) {
        if (r in t)
          return t[r];
        if (r in aa)
          return aa[r](e);
      },
      has(t, r) {
        return r in t || r in aa;
      }
    }));
}
const tH = /(?:^|[-_])(\w)/g, rH = (e) => e.replace(tH, (t) => t.toUpperCase()).replace(/[-_]/g, "");
function GE(e, t = !0) {
  return Je(e) ? e.displayName || e.name : e.name || t && e.__name;
}
function yp(e, t, r = !1) {
  let n = GE(t);
  if (!n && t.__file) {
    const o = t.__file.match(/([^/\\]+)\.\w+$/);
    o && (n = o[1]);
  }
  if (!n && e && e.parent) {
    const o = (s) => {
      for (const a in s)
        if (s[a] === t)
          return a;
    };
    n = o(
      e.components || e.parent.type.components
    ) || o(e.appContext.components);
  }
  return n ? rH(n) : r ? "App" : "Anonymous";
}
function f3(e) {
  return Je(e) && "__vccOpts" in e;
}
const Oe = (e, t) => b4(e, t, Wf);
function Ut(e, t, r) {
  const n = arguments.length;
  return n === 2 ? _t(t) && !We(t) ? Ul(t) ? xe(e, null, [t]) : xe(e, t) : xe(e, null, t) : (n > 3 ? r = Array.prototype.slice.call(arguments, 2) : n === 3 && Ul(r) && (r = [r]), xe(e, t, r));
}
const nH = Symbol.for("v-scx"), iH = () => {
  {
    const e = vr(nH);
    return e || te.env.NODE_ENV !== "production" && Re(
      "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
    ), e;
  }
};
function vb(e) {
  return !!(e && e.__v_isShallow);
}
function oH() {
  if (te.env.NODE_ENV === "production" || typeof window > "u")
    return;
  const e = { style: "color:#3ba776" }, t = { style: "color:#0b1bc9" }, r = { style: "color:#b62e24" }, n = { style: "color:#9d288c" }, o = {
    header(d) {
      return _t(d) ? d.__isVue ? ["div", e, "VueInstance"] : rr(d) ? [
        "div",
        {},
        ["span", e, c(d)],
        "<",
        l(d.value),
        ">"
      ] : oa(d) ? [
        "div",
        {},
        ["span", e, vb(d) ? "ShallowReactive" : "Reactive"],
        "<",
        l(d),
        `>${ss(d) ? " (readonly)" : ""}`
      ] : ss(d) ? [
        "div",
        {},
        ["span", e, vb(d) ? "ShallowReadonly" : "Readonly"],
        "<",
        l(d),
        ">"
      ] : null : null;
    },
    hasBody(d) {
      return d && d.__isVue;
    },
    body(d) {
      if (d && d.__isVue)
        return [
          "div",
          {},
          ...s(d.$)
        ];
    }
  };
  function s(d) {
    const h = [];
    d.type.props && d.props && h.push(a("props", je(d.props))), d.setupState !== Rt && h.push(a("setup", d.setupState)), d.data !== Rt && h.push(a("data", je(d.data)));
    const p = u(d, "computed");
    p && h.push(a("computed", p));
    const v = u(d, "inject");
    return v && h.push(a("injected", v)), h.push([
      "div",
      {},
      [
        "span",
        {
          style: n.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: d }]
    ]), h;
  }
  function a(d, h) {
    return h = Ct({}, h), Object.keys(h).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        d
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(h).map((p) => [
          "div",
          {},
          ["span", n, p + ": "],
          l(h[p], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function l(d, h = !0) {
    return typeof d == "number" ? ["span", t, d] : typeof d == "string" ? ["span", r, JSON.stringify(d)] : typeof d == "boolean" ? ["span", n, d] : _t(d) ? ["object", { object: h ? je(d) : d }] : ["span", r, String(d)];
  }
  function u(d, h) {
    const p = d.type;
    if (Je(p))
      return;
    const v = {};
    for (const y in d.ctx)
      f(p, y, h) && (v[y] = d.ctx[y]);
    return v;
  }
  function f(d, h, p) {
    const v = d[p];
    if (We(v) && v.includes(h) || _t(v) && h in v || d.extends && f(d.extends, h, p) || d.mixins && d.mixins.some((y) => f(y, h, p)))
      return !0;
  }
  function c(d) {
    return vb(d) ? "ShallowRef" : d.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(o) : window.devtoolsFormatters = [o];
}
const nT = "3.3.4", sH = "http://www.w3.org/2000/svg", Gs = typeof document < "u" ? document : null, iT = Gs && /* @__PURE__ */ Gs.createElement("template"), aH = {
  insert: (e, t, r) => {
    t.insertBefore(e, r || null);
  },
  remove: (e) => {
    const t = e.parentNode;
    t && t.removeChild(e);
  },
  createElement: (e, t, r, n) => {
    const o = t ? Gs.createElementNS(sH, e) : Gs.createElement(e, r ? { is: r } : void 0);
    return e === "select" && n && n.multiple != null && o.setAttribute("multiple", n.multiple), o;
  },
  createText: (e) => Gs.createTextNode(e),
  createComment: (e) => Gs.createComment(e),
  setText: (e, t) => {
    e.nodeValue = t;
  },
  setElementText: (e, t) => {
    e.textContent = t;
  },
  parentNode: (e) => e.parentNode,
  nextSibling: (e) => e.nextSibling,
  querySelector: (e) => Gs.querySelector(e),
  setScopeId(e, t) {
    e.setAttribute(t, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(e, t, r, n, o, s) {
    const a = r ? r.previousSibling : t.lastChild;
    if (o && (o === s || o.nextSibling))
      for (; t.insertBefore(o.cloneNode(!0), r), !(o === s || !(o = o.nextSibling)); )
        ;
    else {
      iT.innerHTML = n ? `<svg>${e}</svg>` : e;
      const l = iT.content;
      if (n) {
        const u = l.firstChild;
        for (; u.firstChild; )
          l.appendChild(u.firstChild);
        l.removeChild(u);
      }
      t.insertBefore(l, r);
    }
    return [
      // first
      a ? a.nextSibling : t.firstChild,
      // last
      r ? r.previousSibling : t.lastChild
    ];
  }
};
function lH(e, t, r) {
  const n = e._vtc;
  n && (t = (t ? [t, ...n] : [...n]).join(" ")), t == null ? e.removeAttribute("class") : r ? e.setAttribute("class", t) : e.className = t;
}
function uH(e, t, r) {
  const n = e.style, o = Ot(r);
  if (r && !o) {
    if (t && !Ot(t))
      for (const s in t)
        r[s] == null && D1(n, s, "");
    for (const s in r)
      D1(n, s, r[s]);
  } else {
    const s = n.display;
    o ? t !== r && (n.cssText = r) : t && e.removeAttribute("style"), "_vod" in e && (n.display = s);
  }
}
const fH = /[^\\];\s*$/, oT = /\s*!important$/;
function D1(e, t, r) {
  if (We(r))
    r.forEach((n) => D1(e, t, n));
  else if (r == null && (r = ""), te.env.NODE_ENV !== "production" && fH.test(r) && Re(
    `Unexpected semicolon at the end of '${t}' style value: '${r}'`
  ), t.startsWith("--"))
    e.setProperty(t, r);
  else {
    const n = cH(e, t);
    oT.test(r) ? e.setProperty(
      is(n),
      r.replace(oT, ""),
      "important"
    ) : e[n] = r;
  }
}
const sT = ["Webkit", "Moz", "ms"], mb = {};
function cH(e, t) {
  const r = mb[t];
  if (r)
    return r;
  let n = Ri(t);
  if (n !== "filter" && n in e)
    return mb[t] = n;
  n = wa(n);
  for (let o = 0; o < sT.length; o++) {
    const s = sT[o] + n;
    if (s in e)
      return mb[t] = s;
  }
  return t;
}
const aT = "http://www.w3.org/1999/xlink";
function dH(e, t, r, n, o) {
  if (n && t.startsWith("xlink:"))
    r == null ? e.removeAttributeNS(aT, t.slice(6, t.length)) : e.setAttributeNS(aT, t, r);
  else {
    const s = OW(t);
    r == null || s && !aD(r) ? e.removeAttribute(t) : e.setAttribute(t, s ? "" : r);
  }
}
function hH(e, t, r, n, o, s, a) {
  if (t === "innerHTML" || t === "textContent") {
    n && a(n, o, s), e[t] = r ?? "";
    return;
  }
  const l = e.tagName;
  if (t === "value" && l !== "PROGRESS" && // custom elements may use _value internally
  !l.includes("-")) {
    e._value = r;
    const f = l === "OPTION" ? e.getAttribute("value") : e.value, c = r ?? "";
    f !== c && (e.value = c), r == null && e.removeAttribute(t);
    return;
  }
  let u = !1;
  if (r === "" || r == null) {
    const f = typeof e[t];
    f === "boolean" ? r = aD(r) : r == null && f === "string" ? (r = "", u = !0) : f === "number" && (r = 0, u = !0);
  }
  try {
    e[t] = r;
  } catch (f) {
    te.env.NODE_ENV !== "production" && !u && Re(
      `Failed setting prop "${t}" on <${l.toLowerCase()}>: value ${r} is invalid.`,
      f
    );
  }
  u && e.removeAttribute(t);
}
function pl(e, t, r, n) {
  e.addEventListener(t, r, n);
}
function pH(e, t, r, n) {
  e.removeEventListener(t, r, n);
}
function gH(e, t, r, n, o = null) {
  const s = e._vei || (e._vei = {}), a = s[t];
  if (n && a)
    a.value = n;
  else {
    const [l, u] = bH(t);
    if (n) {
      const f = s[t] = mH(n, o);
      pl(e, l, f, u);
    } else
      a && (pH(e, l, a, u), s[t] = void 0);
  }
}
const lT = /(?:Once|Passive|Capture)$/;
function bH(e) {
  let t;
  if (lT.test(e)) {
    t = {};
    let n;
    for (; n = e.match(lT); )
      e = e.slice(0, e.length - n[0].length), t[n[0].toLowerCase()] = !0;
  }
  return [e[2] === ":" ? e.slice(3) : is(e.slice(2)), t];
}
let _b = 0;
const yH = /* @__PURE__ */ Promise.resolve(), vH = () => _b || (yH.then(() => _b = 0), _b = Date.now());
function mH(e, t) {
  const r = (n) => {
    if (!n._vts)
      n._vts = Date.now();
    else if (n._vts <= r.attached)
      return;
    Sn(
      _H(n, r.value),
      t,
      5,
      [n]
    );
  };
  return r.value = e, r.attached = vH(), r;
}
function _H(e, t) {
  if (We(t)) {
    const r = e.stopImmediatePropagation;
    return e.stopImmediatePropagation = () => {
      r.call(e), e._stopped = !0;
    }, t.map((n) => (o) => !o._stopped && n && n(o));
  } else
    return t;
}
const uT = /^on[a-z]/, wH = (e, t, r, n, o = !1, s, a, l, u) => {
  t === "class" ? lH(e, n, o) : t === "style" ? uH(e, r, n) : pc(t) ? ih(t) || gH(e, t, r, n, a) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : SH(e, t, n, o)) ? hH(
    e,
    t,
    n,
    s,
    a,
    l,
    u
  ) : (t === "true-value" ? e._trueValue = n : t === "false-value" && (e._falseValue = n), dH(e, t, n, o));
};
function SH(e, t, r, n) {
  return n ? !!(t === "innerHTML" || t === "textContent" || t in e && uT.test(t) && Je(r)) : t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA" || uT.test(t) && Ot(r) ? !1 : t in e;
}
const Io = "transition", Cu = "animation", vp = (e, { slots: t }) => Ut(Q4, EH(e), t);
vp.displayName = "Transition";
const c3 = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
vp.props = /* @__PURE__ */ Ct(
  {},
  qD,
  c3
);
const Ns = (e, t = []) => {
  We(e) ? e.forEach((r) => r(...t)) : e && e(...t);
}, fT = (e) => e ? We(e) ? e.some((t) => t.length > 1) : e.length > 1 : !1;
function EH(e) {
  const t = {};
  for (const W in e)
    W in c3 || (t[W] = e[W]);
  if (e.css === !1)
    return t;
  const {
    name: r = "v",
    type: n,
    duration: o,
    enterFromClass: s = `${r}-enter-from`,
    enterActiveClass: a = `${r}-enter-active`,
    enterToClass: l = `${r}-enter-to`,
    appearFromClass: u = s,
    appearActiveClass: f = a,
    appearToClass: c = l,
    leaveFromClass: d = `${r}-leave-from`,
    leaveActiveClass: h = `${r}-leave-active`,
    leaveToClass: p = `${r}-leave-to`
  } = e, v = xH(o), y = v && v[0], w = v && v[1], {
    onBeforeEnter: S,
    onEnter: x,
    onEnterCancelled: E,
    onLeave: N,
    onLeaveCancelled: C,
    onBeforeAppear: j = S,
    onAppear: J = x,
    onAppearCancelled: z = E
  } = t, $ = (W, k, U) => {
    ks(W, k ? c : l), ks(W, k ? f : a), U && U();
  }, G = (W, k) => {
    W._isLeaving = !1, ks(W, d), ks(W, p), ks(W, h), k && k();
  }, I = (W) => (k, U) => {
    const Z = W ? J : x, Y = () => $(k, W, U);
    Ns(Z, [k, Y]), cT(() => {
      ks(k, W ? u : s), Mo(k, W ? c : l), fT(Z) || dT(k, n, y, Y);
    });
  };
  return Ct(t, {
    onBeforeEnter(W) {
      Ns(S, [W]), Mo(W, s), Mo(W, a);
    },
    onBeforeAppear(W) {
      Ns(j, [W]), Mo(W, u), Mo(W, f);
    },
    onEnter: I(!1),
    onAppear: I(!0),
    onLeave(W, k) {
      W._isLeaving = !0;
      const U = () => G(W, k);
      Mo(W, d), TH(), Mo(W, h), cT(() => {
        W._isLeaving && (ks(W, d), Mo(W, p), fT(N) || dT(W, n, w, U));
      }), Ns(N, [W, U]);
    },
    onEnterCancelled(W) {
      $(W, !1), Ns(E, [W]);
    },
    onAppearCancelled(W) {
      $(W, !0), Ns(z, [W]);
    },
    onLeaveCancelled(W) {
      G(W), Ns(C, [W]);
    }
  });
}
function xH(e) {
  if (e == null)
    return null;
  if (_t(e))
    return [wb(e.enter), wb(e.leave)];
  {
    const t = wb(e);
    return [t, t];
  }
}
function wb(e) {
  const t = xW(e);
  return te.env.NODE_ENV !== "production" && w4(t, "<transition> explicit duration"), t;
}
function Mo(e, t) {
  t.split(/\s+/).forEach((r) => r && e.classList.add(r)), (e._vtc || (e._vtc = /* @__PURE__ */ new Set())).add(t);
}
function ks(e, t) {
  t.split(/\s+/).forEach((n) => n && e.classList.remove(n));
  const { _vtc: r } = e;
  r && (r.delete(t), r.size || (e._vtc = void 0));
}
function cT(e) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e);
  });
}
let RH = 0;
function dT(e, t, r, n) {
  const o = e._endId = ++RH, s = () => {
    o === e._endId && n();
  };
  if (r)
    return setTimeout(s, r);
  const { type: a, timeout: l, propCount: u } = AH(e, t);
  if (!a)
    return n();
  const f = a + "end";
  let c = 0;
  const d = () => {
    e.removeEventListener(f, h), s();
  }, h = (p) => {
    p.target === e && ++c >= u && d();
  };
  setTimeout(() => {
    c < u && d();
  }, l + 1), e.addEventListener(f, h);
}
function AH(e, t) {
  const r = window.getComputedStyle(e), n = (v) => (r[v] || "").split(", "), o = n(`${Io}Delay`), s = n(`${Io}Duration`), a = hT(o, s), l = n(`${Cu}Delay`), u = n(`${Cu}Duration`), f = hT(l, u);
  let c = null, d = 0, h = 0;
  t === Io ? a > 0 && (c = Io, d = a, h = s.length) : t === Cu ? f > 0 && (c = Cu, d = f, h = u.length) : (d = Math.max(a, f), c = d > 0 ? a > f ? Io : Cu : null, h = c ? c === Io ? s.length : u.length : 0);
  const p = c === Io && /\b(transform|all)(,|$)/.test(
    n(`${Io}Property`).toString()
  );
  return {
    type: c,
    timeout: d,
    propCount: h,
    hasTransform: p
  };
}
function hT(e, t) {
  for (; e.length < t.length; )
    e = e.concat(e);
  return Math.max(...t.map((r, n) => pT(r) + pT(e[n])));
}
function pT(e) {
  return Number(e.slice(0, -1).replace(",", ".")) * 1e3;
}
function TH() {
  return document.body.offsetHeight;
}
const gT = (e) => {
  const t = e.props["onUpdate:modelValue"] || !1;
  return We(t) ? (r) => dl(t, r) : t;
};
function $H(e) {
  e.target.composing = !0;
}
function bT(e) {
  const t = e.target;
  t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")));
}
const Vo = {
  created(e, { modifiers: { lazy: t, trim: r, number: n } }, o) {
    e._assign = gT(o);
    const s = n || o.props && o.props.type === "number";
    pl(e, t ? "change" : "input", (a) => {
      if (a.target.composing)
        return;
      let l = e.value;
      r && (l = l.trim()), s && (l = p1(l)), e._assign(l);
    }), r && pl(e, "change", () => {
      e.value = e.value.trim();
    }), t || (pl(e, "compositionstart", $H), pl(e, "compositionend", bT), pl(e, "change", bT));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(e, { value: t }) {
    e.value = t ?? "";
  },
  beforeUpdate(e, { value: t, modifiers: { lazy: r, trim: n, number: o } }, s) {
    if (e._assign = gT(s), e.composing || document.activeElement === e && e.type !== "range" && (r || n && e.value.trim() === t || (o || e.type === "number") && p1(e.value) === t))
      return;
    const a = t ?? "";
    e.value !== a && (e.value = a);
  }
}, NH = ["ctrl", "shift", "alt", "meta"], kH = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, t) => NH.some((r) => e[`${r}Key`] && !t.includes(r))
}, CH = (e, t) => (r, ...n) => {
  for (let o = 0; o < t.length; o++) {
    const s = kH[t[o]];
    if (s && s(r, t))
      return;
  }
  return e(r, ...n);
}, Ea = {
  beforeMount(e, { value: t }, { transition: r }) {
    e._vod = e.style.display === "none" ? "" : e.style.display, r && t ? r.beforeEnter(e) : Iu(e, t);
  },
  mounted(e, { value: t }, { transition: r }) {
    r && t && r.enter(e);
  },
  updated(e, { value: t, oldValue: r }, { transition: n }) {
    !t != !r && (n ? t ? (n.beforeEnter(e), Iu(e, !0), n.enter(e)) : n.leave(e, () => {
      Iu(e, !1);
    }) : Iu(e, t));
  },
  beforeUnmount(e, { value: t }) {
    Iu(e, t);
  }
};
function Iu(e, t) {
  e.style.display = t ? e._vod : "none";
}
const IH = /* @__PURE__ */ Ct({ patchProp: wH }, aH);
let yT;
function MH() {
  return yT || (yT = OU(IH));
}
const OH = (...e) => {
  const t = MH().createApp(...e);
  te.env.NODE_ENV !== "production" && (LH(t), PH(t));
  const { mount: r } = t;
  return t.mount = (n) => {
    const o = DH(n);
    if (!o)
      return;
    const s = t._component;
    !Je(s) && !s.render && !s.template && (s.template = o.innerHTML), o.innerHTML = "";
    const a = r(o, !1, o instanceof SVGElement);
    return o instanceof Element && (o.removeAttribute("v-cloak"), o.setAttribute("data-v-app", "")), a;
  }, t;
};
function LH(e) {
  Object.defineProperty(e.config, "isNativeTag", {
    value: (t) => CW(t) || IW(t),
    writable: !1
  });
}
function PH(e) {
  {
    const t = e.config.isCustomElement;
    Object.defineProperty(e.config, "isCustomElement", {
      get() {
        return t;
      },
      set() {
        Re(
          "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
        );
      }
    });
    const r = e.config.compilerOptions, n = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
    Object.defineProperty(e.config, "compilerOptions", {
      get() {
        return Re(n), r;
      },
      set() {
        Re(n);
      }
    });
  }
}
function DH(e) {
  if (Ot(e)) {
    const t = document.querySelector(e);
    return te.env.NODE_ENV !== "production" && !t && Re(
      `Failed to mount app: mount target selector "${e}" returned null.`
    ), t;
  }
  return te.env.NODE_ENV !== "production" && window.ShadowRoot && e instanceof window.ShadowRoot && e.mode === "closed" && Re(
    'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
  ), e;
}
function FH() {
  oH();
}
te.env.NODE_ENV !== "production" && FH();
function jH(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", {
      "fill-rule": "evenodd",
      d: "M11.03 3.97a.75.75 0 010 1.06l-6.22 6.22H21a.75.75 0 010 1.5H4.81l6.22 6.22a.75.75 0 11-1.06 1.06l-7.5-7.5a.75.75 0 010-1.06l7.5-7.5a.75.75 0 011.06 0z",
      "clip-rule": "evenodd"
    })
  ]);
}
function BH(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", {
      "fill-rule": "evenodd",
      d: "M4.755 10.059a7.5 7.5 0 0112.548-3.364l1.903 1.903h-3.183a.75.75 0 100 1.5h4.992a.75.75 0 00.75-.75V4.356a.75.75 0 00-1.5 0v3.18l-1.9-1.9A9 9 0 003.306 9.67a.75.75 0 101.45.388zm15.408 3.352a.75.75 0 00-.919.53 7.5 7.5 0 01-12.548 3.364l-1.902-1.903h3.183a.75.75 0 000-1.5H2.984a.75.75 0 00-.75.75v4.992a.75.75 0 001.5 0v-3.18l1.9 1.9a9 9 0 0015.059-4.035.75.75 0 00-.53-.918z",
      "clip-rule": "evenodd"
    })
  ]);
}
function qH(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", {
      "fill-rule": "evenodd",
      d: "M15.75 2.25H21a.75.75 0 01.75.75v5.25a.75.75 0 01-1.5 0V4.81L8.03 17.03a.75.75 0 01-1.06-1.06L19.19 3.75h-3.44a.75.75 0 010-1.5zm-10.5 4.5a1.5 1.5 0 00-1.5 1.5v10.5a1.5 1.5 0 001.5 1.5h10.5a1.5 1.5 0 001.5-1.5V10.5a.75.75 0 011.5 0v8.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V8.25a3 3 0 013-3h8.25a.75.75 0 010 1.5H5.25z",
      "clip-rule": "evenodd"
    })
  ]);
}
function WH(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", {
      "fill-rule": "evenodd",
      d: "M11.47 2.47a.75.75 0 011.06 0l4.5 4.5a.75.75 0 01-1.06 1.06l-3.22-3.22V16.5a.75.75 0 01-1.5 0V4.81L8.03 8.03a.75.75 0 01-1.06-1.06l4.5-4.5zM3 15.75a.75.75 0 01.75.75v2.25a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5V16.5a.75.75 0 011.5 0v2.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V16.5a.75.75 0 01.75-.75z",
      "clip-rule": "evenodd"
    })
  ]);
}
function UH(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", {
      "fill-rule": "evenodd",
      d: "M3 6.75A.75.75 0 013.75 6h16.5a.75.75 0 010 1.5H3.75A.75.75 0 013 6.75zM3 12a.75.75 0 01.75-.75h16.5a.75.75 0 010 1.5H3.75A.75.75 0 013 12zm0 5.25a.75.75 0 01.75-.75h16.5a.75.75 0 010 1.5H3.75a.75.75 0 01-.75-.75z",
      "clip-rule": "evenodd"
    })
  ]);
}
function HH(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", {
      "fill-rule": "evenodd",
      d: "M19.916 4.626a.75.75 0 01.208 1.04l-9 13.5a.75.75 0 01-1.154.114l-6-6a.75.75 0 011.06-1.06l5.353 5.353 8.493-12.739a.75.75 0 011.04-.208z",
      "clip-rule": "evenodd"
    })
  ]);
}
function VH(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", {
      "fill-rule": "evenodd",
      d: "M7.72 12.53a.75.75 0 010-1.06l7.5-7.5a.75.75 0 111.06 1.06L9.31 12l6.97 6.97a.75.75 0 11-1.06 1.06l-7.5-7.5z",
      "clip-rule": "evenodd"
    })
  ]);
}
function zH(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", {
      "fill-rule": "evenodd",
      d: "M16.28 11.47a.75.75 0 010 1.06l-7.5 7.5a.75.75 0 01-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 011.06-1.06l7.5 7.5z",
      "clip-rule": "evenodd"
    })
  ]);
}
function d3(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", {
      "fill-rule": "evenodd",
      d: "M17.663 3.118c.225.015.45.032.673.05C19.876 3.298 21 4.604 21 6.109v9.642a3 3 0 01-3 3V16.5c0-5.922-4.576-10.775-10.384-11.217.324-1.132 1.3-2.01 2.548-2.114.224-.019.448-.036.673-.051A3 3 0 0113.5 1.5H15a3 3 0 012.663 1.618zM12 4.5A1.5 1.5 0 0113.5 3H15a1.5 1.5 0 011.5 1.5H12z",
      "clip-rule": "evenodd"
    }),
    oe("path", { d: "M3 8.625c0-1.036.84-1.875 1.875-1.875h.375A3.75 3.75 0 019 10.5v1.875c0 1.036.84 1.875 1.875 1.875h1.875A3.75 3.75 0 0116.5 18v2.625c0 1.035-.84 1.875-1.875 1.875h-9.75A1.875 1.875 0 013 20.625v-12z" }),
    oe("path", { d: "M10.5 10.5a5.23 5.23 0 00-1.279-3.434 9.768 9.768 0 016.963 6.963 5.23 5.23 0 00-3.434-1.279h-1.875a.375.375 0 01-.375-.375V10.5z" })
  ]);
}
function GH(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", { d: "M17.004 10.407c.138.435-.216.842-.672.842h-3.465a.75.75 0 01-.65-.375l-1.732-3c-.229-.396-.053-.907.393-1.004a5.252 5.252 0 016.126 3.537zM8.12 8.464c.307-.338.838-.235 1.066.16l1.732 3a.75.75 0 010 .75l-1.732 3.001c-.229.396-.76.498-1.067.16A5.231 5.231 0 016.75 12c0-1.362.519-2.603 1.37-3.536zM10.878 17.13c-.447-.097-.623-.608-.394-1.003l1.733-3.003a.75.75 0 01.65-.375h3.465c.457 0 .81.408.672.843a5.252 5.252 0 01-6.126 3.538z" }),
    oe("path", {
      "fill-rule": "evenodd",
      d: "M21 12.75a.75.75 0 000-1.5h-.783a8.22 8.22 0 00-.237-1.357l.734-.267a.75.75 0 10-.513-1.41l-.735.268a8.24 8.24 0 00-.689-1.191l.6-.504a.75.75 0 10-.964-1.149l-.6.504a8.3 8.3 0 00-1.054-.885l.391-.678a.75.75 0 10-1.299-.75l-.39.677a8.188 8.188 0 00-1.295-.471l.136-.77a.75.75 0 00-1.477-.26l-.136.77a8.364 8.364 0 00-1.377 0l-.136-.77a.75.75 0 10-1.477.26l.136.77c-.448.121-.88.28-1.294.47l-.39-.676a.75.75 0 00-1.3.75l.392.678a8.29 8.29 0 00-1.054.885l-.6-.504a.75.75 0 00-.965 1.149l.6.503a8.243 8.243 0 00-.689 1.192L3.8 8.217a.75.75 0 10-.513 1.41l.735.267a8.222 8.222 0 00-.238 1.355h-.783a.75.75 0 000 1.5h.783c.042.464.122.917.238 1.356l-.735.268a.75.75 0 10.513 1.41l.735-.268c.197.417.428.816.69 1.192l-.6.504a.75.75 0 10.963 1.149l.601-.505c.326.323.679.62 1.054.885l-.392.68a.75.75 0 101.3.75l.39-.679c.414.192.847.35 1.294.471l-.136.771a.75.75 0 101.477.26l.137-.772a8.376 8.376 0 001.376 0l.136.773a.75.75 0 101.477-.26l-.136-.772a8.19 8.19 0 001.294-.47l.391.677a.75.75 0 101.3-.75l-.393-.679a8.282 8.282 0 001.054-.885l.601.504a.75.75 0 10.964-1.15l-.6-.503a8.24 8.24 0 00.69-1.191l.735.268a.75.75 0 10.512-1.41l-.734-.268c.115-.438.195-.892.237-1.356h.784zm-2.657-3.06a6.744 6.744 0 00-1.19-2.053 6.784 6.784 0 00-1.82-1.51A6.704 6.704 0 0012 5.25a6.801 6.801 0 00-1.225.111 6.7 6.7 0 00-2.15.792 6.784 6.784 0 00-2.952 3.489.758.758 0 01-.036.099A6.74 6.74 0 005.251 12a6.739 6.739 0 003.355 5.835l.01.006.01.005a6.706 6.706 0 002.203.802c.007 0 .014.002.021.004a6.792 6.792 0 002.301 0l.022-.004a6.707 6.707 0 002.228-.816 6.781 6.781 0 001.762-1.483l.009-.01.009-.012a6.744 6.744 0 001.18-2.064c.253-.708.39-1.47.39-2.264a6.74 6.74 0 00-.408-2.308z",
      "clip-rule": "evenodd"
    })
  ]);
}
function KH(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", {
      "fill-rule": "evenodd",
      d: "M10.5 6a1.5 1.5 0 113 0 1.5 1.5 0 01-3 0zm0 6a1.5 1.5 0 113 0 1.5 1.5 0 01-3 0zm0 6a1.5 1.5 0 113 0 1.5 1.5 0 01-3 0z",
      "clip-rule": "evenodd"
    })
  ]);
}
function h3(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", { d: "M3.53 2.47a.75.75 0 00-1.06 1.06l18 18a.75.75 0 101.06-1.06l-18-18zM22.676 12.553a11.249 11.249 0 01-2.631 4.31l-3.099-3.099a5.25 5.25 0 00-6.71-6.71L7.759 4.577a11.217 11.217 0 014.242-.827c4.97 0 9.185 3.223 10.675 7.69.12.362.12.752 0 1.113z" }),
    oe("path", { d: "M15.75 12c0 .18-.013.357-.037.53l-4.244-4.243A3.75 3.75 0 0115.75 12zM12.53 15.713l-4.243-4.244a3.75 3.75 0 004.243 4.243z" }),
    oe("path", { d: "M6.75 12c0-.619.107-1.213.304-1.764l-3.1-3.1a11.25 11.25 0 00-2.63 4.31c-.12.362-.12.752 0 1.114 1.489 4.467 5.704 7.69 10.675 7.69 1.5 0 2.933-.294 4.242-.827l-2.477-2.477A5.25 5.25 0 016.75 12z" })
  ]);
}
function YH(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", { d: "M12 15a3 3 0 100-6 3 3 0 000 6z" }),
    oe("path", {
      "fill-rule": "evenodd",
      d: "M1.323 11.447C2.811 6.976 7.028 3.75 12.001 3.75c4.97 0 9.185 3.223 10.675 7.69.12.362.12.752 0 1.113-1.487 4.471-5.705 7.697-10.677 7.697-4.97 0-9.186-3.223-10.675-7.69a1.762 1.762 0 010-1.113zM17.25 12a5.25 5.25 0 11-10.5 0 5.25 5.25 0 0110.5 0z",
      "clip-rule": "evenodd"
    })
  ]);
}
function XH(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", {
      "fill-rule": "evenodd",
      d: "M5.25 12a.75.75 0 01.75-.75h12a.75.75 0 010 1.5H6a.75.75 0 01-.75-.75z",
      "clip-rule": "evenodd"
    })
  ]);
}
function JH(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", {
      "fill-rule": "evenodd",
      d: "M12 5.25a.75.75 0 01.75.75v5.25H18a.75.75 0 010 1.5h-5.25V18a.75.75 0 01-1.5 0v-5.25H6a.75.75 0 010-1.5h5.25V6a.75.75 0 01.75-.75z",
      "clip-rule": "evenodd"
    })
  ]);
}
function QH(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", {
      "fill-rule": "evenodd",
      d: "M1.5 5.625c0-1.036.84-1.875 1.875-1.875h17.25c1.035 0 1.875.84 1.875 1.875v12.75c0 1.035-.84 1.875-1.875 1.875H3.375A1.875 1.875 0 011.5 18.375V5.625zM21 9.375A.375.375 0 0020.625 9h-7.5a.375.375 0 00-.375.375v1.5c0 .207.168.375.375.375h7.5a.375.375 0 00.375-.375v-1.5zm0 3.75a.375.375 0 00-.375-.375h-7.5a.375.375 0 00-.375.375v1.5c0 .207.168.375.375.375h7.5a.375.375 0 00.375-.375v-1.5zm0 3.75a.375.375 0 00-.375-.375h-7.5a.375.375 0 00-.375.375v1.5c0 .207.168.375.375.375h7.5a.375.375 0 00.375-.375v-1.5zM10.875 18.75a.375.375 0 00.375-.375v-1.5a.375.375 0 00-.375-.375h-7.5a.375.375 0 00-.375.375v1.5c0 .207.168.375.375.375h7.5zM3.375 15h7.5a.375.375 0 00.375-.375v-1.5a.375.375 0 00-.375-.375h-7.5a.375.375 0 00-.375.375v1.5c0 .207.168.375.375.375zm0-3.75h7.5a.375.375 0 00.375-.375v-1.5A.375.375 0 0010.875 9h-7.5A.375.375 0 003 9.375v1.5c0 .207.168.375.375.375z",
      "clip-rule": "evenodd"
    })
  ]);
}
function as(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", {
      "fill-rule": "evenodd",
      d: "M5.47 5.47a.75.75 0 011.06 0L12 10.94l5.47-5.47a.75.75 0 111.06 1.06L13.06 12l5.47 5.47a.75.75 0 11-1.06 1.06L12 13.06l-5.47 5.47a.75.75 0 01-1.06-1.06L10.94 12 5.47 6.53a.75.75 0 010-1.06z",
      "clip-rule": "evenodd"
    })
  ]);
}
const Yc = {
  name: "splitpanes",
  emits: ["ready", "resize", "resized", "pane-click", "pane-maximize", "pane-add", "pane-remove", "splitter-click"],
  props: {
    horizontal: { type: Boolean },
    pushOtherPanes: { type: Boolean, default: !0 },
    dblClickSplitter: { type: Boolean, default: !0 },
    rtl: { type: Boolean, default: !1 },
    firstSplitter: { type: Boolean }
  },
  provide() {
    return {
      requestUpdate: this.requestUpdate,
      onPaneAdd: this.onPaneAdd,
      onPaneRemove: this.onPaneRemove,
      onPaneClick: this.onPaneClick
    };
  },
  data: () => ({
    container: null,
    ready: !1,
    panes: [],
    touch: {
      mouseDown: !1,
      dragging: !1,
      activeSplitter: null
    },
    splitterTaps: {
      splitter: null,
      timeoutId: null
    }
  }),
  computed: {
    panesCount() {
      return this.panes.length;
    },
    indexedPanes() {
      return this.panes.reduce((e, t) => (e[t.id] = t) && e, {});
    }
  },
  methods: {
    updatePaneComponents() {
      this.panes.forEach((e) => {
        e.update && e.update({
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[e.id].size}%`
        });
      });
    },
    bindEvents() {
      document.addEventListener("mousemove", this.onMouseMove, { passive: !1 }), document.addEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.addEventListener("touchmove", this.onMouseMove, { passive: !1 }), document.addEventListener("touchend", this.onMouseUp));
    },
    unbindEvents() {
      document.removeEventListener("mousemove", this.onMouseMove, { passive: !1 }), document.removeEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.removeEventListener("touchmove", this.onMouseMove, { passive: !1 }), document.removeEventListener("touchend", this.onMouseUp));
    },
    onMouseDown(e, t) {
      this.bindEvents(), this.touch.mouseDown = !0, this.touch.activeSplitter = t;
    },
    onMouseMove(e) {
      this.touch.mouseDown && (e.preventDefault(), this.touch.dragging = !0, this.calculatePanesSize(this.getCurrentMouseDrag(e)), this.$emit("resize", this.panes.map((t) => ({ min: t.min, max: t.max, size: t.size }))));
    },
    onMouseUp() {
      this.touch.dragging && this.$emit("resized", this.panes.map((e) => ({ min: e.min, max: e.max, size: e.size }))), this.touch.mouseDown = !1, setTimeout(() => {
        this.touch.dragging = !1, this.unbindEvents();
      }, 100);
    },
    onSplitterClick(e, t) {
      "ontouchstart" in window && (e.preventDefault(), this.dblClickSplitter && (this.splitterTaps.splitter === t ? (clearTimeout(this.splitterTaps.timeoutId), this.splitterTaps.timeoutId = null, this.onSplitterDblClick(e, t), this.splitterTaps.splitter = null) : (this.splitterTaps.splitter = t, this.splitterTaps.timeoutId = setTimeout(() => {
        this.splitterTaps.splitter = null;
      }, 500)))), this.touch.dragging || this.$emit("splitter-click", this.panes[t]);
    },
    onSplitterDblClick(e, t) {
      let r = 0;
      this.panes = this.panes.map((n, o) => (n.size = o === t ? n.max : n.min, o !== t && (r += n.min), n)), this.panes[t].size -= r, this.$emit("pane-maximize", this.panes[t]), this.$emit("resized", this.panes.map((n) => ({ min: n.min, max: n.max, size: n.size })));
    },
    onPaneClick(e, t) {
      this.$emit("pane-click", this.indexedPanes[t]);
    },
    getCurrentMouseDrag(e) {
      const t = this.container.getBoundingClientRect(), { clientX: r, clientY: n } = "ontouchstart" in window && e.touches ? e.touches[0] : e;
      return {
        x: r - t.left,
        y: n - t.top
      };
    },
    getCurrentDragPercentage(e) {
      e = e[this.horizontal ? "y" : "x"];
      const t = this.container[this.horizontal ? "clientHeight" : "clientWidth"];
      return this.rtl && !this.horizontal && (e = t - e), e * 100 / t;
    },
    calculatePanesSize(e) {
      const t = this.touch.activeSplitter;
      let r = {
        prevPanesSize: this.sumPrevPanesSize(t),
        nextPanesSize: this.sumNextPanesSize(t),
        prevReachedMinPanes: 0,
        nextReachedMinPanes: 0
      };
      const n = 0 + (this.pushOtherPanes ? 0 : r.prevPanesSize), o = 100 - (this.pushOtherPanes ? 0 : r.nextPanesSize), s = Math.max(Math.min(this.getCurrentDragPercentage(e), o), n);
      let a = [t, t + 1], l = this.panes[a[0]] || null, u = this.panes[a[1]] || null;
      const f = l.max < 100 && s >= l.max + r.prevPanesSize, c = u.max < 100 && s <= 100 - (u.max + this.sumNextPanesSize(t + 1));
      if (f || c) {
        f ? (l.size = l.max, u.size = Math.max(100 - l.max - r.prevPanesSize - r.nextPanesSize, 0)) : (l.size = Math.max(100 - u.max - r.prevPanesSize - this.sumNextPanesSize(t + 1), 0), u.size = u.max);
        return;
      }
      if (this.pushOtherPanes) {
        const d = this.doPushOtherPanes(r, s);
        if (!d)
          return;
        ({ sums: r, panesToResize: a } = d), l = this.panes[a[0]] || null, u = this.panes[a[1]] || null;
      }
      l !== null && (l.size = Math.min(Math.max(s - r.prevPanesSize - r.prevReachedMinPanes, l.min), l.max)), u !== null && (u.size = Math.min(Math.max(100 - s - r.nextPanesSize - r.nextReachedMinPanes, u.min), u.max));
    },
    doPushOtherPanes(e, t) {
      const r = this.touch.activeSplitter, n = [r, r + 1];
      return t < e.prevPanesSize + this.panes[n[0]].min && (n[0] = this.findPrevExpandedPane(r).index, e.prevReachedMinPanes = 0, n[0] < r && this.panes.forEach((o, s) => {
        s > n[0] && s <= r && (o.size = o.min, e.prevReachedMinPanes += o.min);
      }), e.prevPanesSize = this.sumPrevPanesSize(n[0]), n[0] === void 0) ? (e.prevReachedMinPanes = 0, this.panes[0].size = this.panes[0].min, this.panes.forEach((o, s) => {
        s > 0 && s <= r && (o.size = o.min, e.prevReachedMinPanes += o.min);
      }), this.panes[n[1]].size = 100 - e.prevReachedMinPanes - this.panes[0].min - e.prevPanesSize - e.nextPanesSize, null) : t > 100 - e.nextPanesSize - this.panes[n[1]].min && (n[1] = this.findNextExpandedPane(r).index, e.nextReachedMinPanes = 0, n[1] > r + 1 && this.panes.forEach((o, s) => {
        s > r && s < n[1] && (o.size = o.min, e.nextReachedMinPanes += o.min);
      }), e.nextPanesSize = this.sumNextPanesSize(n[1] - 1), n[1] === void 0) ? (e.nextReachedMinPanes = 0, this.panes[this.panesCount - 1].size = this.panes[this.panesCount - 1].min, this.panes.forEach((o, s) => {
        s < this.panesCount - 1 && s >= r + 1 && (o.size = o.min, e.nextReachedMinPanes += o.min);
      }), this.panes[n[0]].size = 100 - e.prevPanesSize - e.nextReachedMinPanes - this.panes[this.panesCount - 1].min - e.nextPanesSize, null) : { sums: e, panesToResize: n };
    },
    sumPrevPanesSize(e) {
      return this.panes.reduce((t, r, n) => t + (n < e ? r.size : 0), 0);
    },
    sumNextPanesSize(e) {
      return this.panes.reduce((t, r, n) => t + (n > e + 1 ? r.size : 0), 0);
    },
    findPrevExpandedPane(e) {
      return [...this.panes].reverse().find((t) => t.index < e && t.size > t.min) || {};
    },
    findNextExpandedPane(e) {
      return this.panes.find((t) => t.index > e + 1 && t.size > t.min) || {};
    },
    checkSplitpanesNodes() {
      Array.from(this.container.children).forEach((e) => {
        const t = e.classList.contains("splitpanes__pane"), r = e.classList.contains("splitpanes__splitter");
        !t && !r && (e.parentNode.removeChild(e), console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed."));
      });
    },
    addSplitter(e, t, r = !1) {
      const n = e - 1, o = document.createElement("div");
      o.classList.add("splitpanes__splitter"), r || (o.onmousedown = (s) => this.onMouseDown(s, n), typeof window < "u" && "ontouchstart" in window && (o.ontouchstart = (s) => this.onMouseDown(s, n)), o.onclick = (s) => this.onSplitterClick(s, n + 1)), this.dblClickSplitter && (o.ondblclick = (s) => this.onSplitterDblClick(s, n + 1)), t.parentNode.insertBefore(o, t);
    },
    removeSplitter(e) {
      e.onmousedown = void 0, e.onclick = void 0, e.ondblclick = void 0, e.parentNode.removeChild(e);
    },
    redoSplitters() {
      const e = Array.from(this.container.children);
      e.forEach((r) => {
        r.className.includes("splitpanes__splitter") && this.removeSplitter(r);
      });
      let t = 0;
      e.forEach((r) => {
        r.className.includes("splitpanes__pane") && (!t && this.firstSplitter ? this.addSplitter(t, r, !0) : t && this.addSplitter(t, r), t++);
      });
    },
    requestUpdate({ target: e, ...t }) {
      const r = this.indexedPanes[e._.uid];
      Object.entries(t).forEach(([n, o]) => r[n] = o);
    },
    onPaneAdd(e) {
      let t = -1;
      Array.from(e.$el.parentNode.children).some((o) => (o.className.includes("splitpanes__pane") && t++, o === e.$el));
      const r = parseFloat(e.minSize), n = parseFloat(e.maxSize);
      this.panes.splice(t, 0, {
        id: e._.uid,
        index: t,
        min: isNaN(r) ? 0 : r,
        max: isNaN(n) ? 100 : n,
        size: e.size === null ? null : parseFloat(e.size),
        givenSize: e.size,
        update: e.update
      }), this.panes.forEach((o, s) => o.index = s), this.ready && this.$nextTick(() => {
        this.redoSplitters(), this.resetPaneSizes({ addedPane: this.panes[t] }), this.$emit("pane-add", { index: t, panes: this.panes.map((o) => ({ min: o.min, max: o.max, size: o.size })) });
      });
    },
    onPaneRemove(e) {
      const t = this.panes.findIndex((n) => n.id === e._.uid), r = this.panes.splice(t, 1)[0];
      this.panes.forEach((n, o) => n.index = o), this.$nextTick(() => {
        this.redoSplitters(), this.resetPaneSizes({ removedPane: { ...r, index: t } }), this.$emit("pane-remove", { removed: r, panes: this.panes.map((n) => ({ min: n.min, max: n.max, size: n.size })) });
      });
    },
    resetPaneSizes(e = {}) {
      !e.addedPane && !e.removedPane ? this.initialPanesSizing() : this.panes.some((t) => t.givenSize !== null || t.min || t.max < 100) ? this.equalizeAfterAddOrRemove(e) : this.equalize(), this.ready && this.$emit("resized", this.panes.map((t) => ({ min: t.min, max: t.max, size: t.size })));
    },
    equalize() {
      const e = 100 / this.panesCount;
      let t = 0;
      const r = [], n = [];
      this.panes.forEach((o) => {
        o.size = Math.max(Math.min(e, o.max), o.min), t -= o.size, o.size >= o.max && r.push(o.id), o.size <= o.min && n.push(o.id);
      }), t > 0.1 && this.readjustSizes(t, r, n);
    },
    initialPanesSizing() {
      let e = 100;
      const t = [], r = [];
      let n = 0;
      this.panes.forEach((s) => {
        e -= s.size, s.size !== null && n++, s.size >= s.max && t.push(s.id), s.size <= s.min && r.push(s.id);
      });
      let o = 100;
      e > 0.1 && (this.panes.forEach((s) => {
        s.size === null && (s.size = Math.max(Math.min(e / (this.panesCount - n), s.max), s.min)), o -= s.size;
      }), o > 0.1 && this.readjustSizes(e, t, r));
    },
    equalizeAfterAddOrRemove({ addedPane: e, removedPane: t } = {}) {
      let r = 100 / this.panesCount, n = 0;
      const o = [], s = [];
      e && e.givenSize !== null && (r = (100 - e.givenSize) / (this.panesCount - 1)), this.panes.forEach((a) => {
        n -= a.size, a.size >= a.max && o.push(a.id), a.size <= a.min && s.push(a.id);
      }), !(Math.abs(n) < 0.1) && (this.panes.forEach((a) => {
        e && e.givenSize !== null && e.id === a.id || (a.size = Math.max(Math.min(r, a.max), a.min)), n -= a.size, a.size >= a.max && o.push(a.id), a.size <= a.min && s.push(a.id);
      }), n > 0.1 && this.readjustSizes(n, o, s));
    },
    readjustSizes(e, t, r) {
      let n;
      e > 0 ? n = e / (this.panesCount - t.length) : n = e / (this.panesCount - r.length), this.panes.forEach((o, s) => {
        if (e > 0 && !t.includes(o.id)) {
          const a = Math.max(Math.min(o.size + n, o.max), o.min), l = a - o.size;
          e -= l, o.size = a;
        } else if (!r.includes(o.id)) {
          const a = Math.max(Math.min(o.size + n, o.max), o.min), l = a - o.size;
          e -= l, o.size = a;
        }
        o.update({
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[o.id].size}%`
        });
      }), Math.abs(e) > 0.1 && this.$nextTick(() => {
        this.ready && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
      });
    }
  },
  watch: {
    panes: {
      deep: !0,
      immediate: !1,
      handler() {
        this.updatePaneComponents();
      }
    },
    horizontal() {
      this.updatePaneComponents();
    },
    firstSplitter() {
      this.redoSplitters();
    },
    dblClickSplitter(e) {
      [...this.container.querySelectorAll(".splitpanes__splitter")].forEach((t, r) => {
        t.ondblclick = e ? (n) => this.onSplitterDblClick(n, r) : void 0;
      });
    }
  },
  beforeUnmount() {
    this.ready = !1;
  },
  mounted() {
    this.container = this.$refs.container, this.checkSplitpanesNodes(), this.redoSplitters(), this.resetPaneSizes(), this.$emit("ready"), this.ready = !0;
  },
  render() {
    return Ut(
      "div",
      {
        ref: "container",
        class: [
          "splitpanes",
          `splitpanes--${this.horizontal ? "horizontal" : "vertical"}`,
          {
            "splitpanes--dragging": this.touch.dragging
          }
        ]
      },
      this.$slots.default()
    );
  }
}, ZH = (e, t) => {
  const r = e.__vccOpts || e;
  for (const [n, o] of t)
    r[n] = o;
  return r;
}, e9 = {
  name: "pane",
  inject: ["requestUpdate", "onPaneAdd", "onPaneRemove", "onPaneClick"],
  props: {
    size: { type: [Number, String], default: null },
    minSize: { type: [Number, String], default: 0 },
    maxSize: { type: [Number, String], default: 100 }
  },
  data: () => ({
    style: {}
  }),
  mounted() {
    this.onPaneAdd(this);
  },
  beforeUnmount() {
    this.onPaneRemove(this);
  },
  methods: {
    update(e) {
      this.style = e;
    }
  },
  computed: {
    sizeNumber() {
      return this.size || this.size === 0 ? parseFloat(this.size) : null;
    },
    minSizeNumber() {
      return parseFloat(this.minSize);
    },
    maxSizeNumber() {
      return parseFloat(this.maxSize);
    }
  },
  watch: {
    sizeNumber(e) {
      this.requestUpdate({ target: this, size: e });
    },
    minSizeNumber(e) {
      this.requestUpdate({ target: this, min: e });
    },
    maxSizeNumber(e) {
      this.requestUpdate({ target: this, max: e });
    }
  }
};
function t9(e, t, r, n, o, s) {
  return we(), $e("div", {
    class: "splitpanes__pane",
    onClick: t[0] || (t[0] = (a) => s.onPaneClick(a, e._.uid)),
    style: ip(e.style)
  }, [
    io(e.$slots, "default")
  ], 4);
}
const Hi = /* @__PURE__ */ ZH(e9, [["render", t9]]), r9 = {
  rif: "http://www.w3.org/2007/rif#",
  v: "http://rdf.data-vocabulary.org/#",
  wdr: "http://www.w3.org/2007/05/powder#",
  xml: "http://www.w3.org/XML/1998/namespace/"
}, n9 = {
  acl: "http://www.w3.org/ns/auth/acl#",
  as: "https://www.w3.org/ns/activitystreams#",
  bibo: "http://purl.org/ontology/bibo/",
  cc: "http://creativecommons.org/ns#",
  cert: "http://www.w3.org/ns/auth/cert#",
  cnt: "http://www.w3.org/2011/content#",
  constant: "http://qudt.org/vocab/constant/",
  crm: "http://www.cidoc-crm.org/cidoc-crm/",
  csvw: "http://www.w3.org/ns/csvw#",
  ctag: "http://commontag.org/ns#",
  "dash-sparql": "http://datashapes.org/sparql#",
  dash: "http://datashapes.org/dash#",
  dbo: "http://dbpedia.org/ontology/",
  dc11: "http://purl.org/dc/elements/1.1/",
  dcam: "http://purl.org/dc/dcam/",
  dcat: "http://www.w3.org/ns/dcat#",
  dcmitype: "http://purl.org/dc/dcmitype/",
  dcterms: "http://purl.org/dc/terms/",
  dig: "http://www.ics.forth.gr/isl/CRMdig/",
  discipline: "http://qudt.org/vocab/discipline/",
  doap: "http://usefulinc.com/ns/doap#",
  dpv: "http://www.w3.org/ns/dpv#",
  dqv: "http://www.w3.org/ns/dqv#",
  dtype: "http://www.linkedmodel.org/schema/dtype#",
  duv: "http://www.w3.org/ns/duv#",
  earl: "http://www.w3.org/ns/earl#",
  ebucore: "http://www.ebu.ch/metadata/ontologies/ebucore/ebucore#",
  exif: "http://www.w3.org/2003/12/exif/ns#",
  foaf: "http://xmlns.com/foaf/0.1/",
  frbr: "http://purl.org/vocab/frbr/core#",
  geo: "http://www.opengis.net/ont/geosparql#",
  geof: "http://www.opengis.net/def/function/geosparql/",
  geor: "http://www.opengis.net/def/rule/geosparql/",
  gml: "http://www.opengis.net/ont/gml#",
  gn: "http://www.geonames.org/ontology#",
  gr: "http://purl.org/goodrelations/v1#",
  grddl: "http://www.w3.org/2003/g/data-view#",
  gs1: "https://gs1.org/voc/",
  gtfs: "http://vocab.gtfs.org/terms#",
  http: "http://www.w3.org/2011/http#",
  hydra: "http://www.w3.org/ns/hydra/core#",
  ical: "http://www.w3.org/2002/12/cal/icaltzd#",
  la: "https://linked.art/ns/terms/",
  ldp: "http://www.w3.org/ns/ldp#",
  list: "http://www.w3.org/2000/10/swap/list#",
  locn: "http://www.w3.org/ns/locn#",
  log: "http://www.w3.org/2000/10/swap/log#",
  lvont: "http://lexvo.org/ontology#",
  m4i: "http://w3id.org/nfdi4ing/metadata4ing#",
  ma: "http://www.w3.org/ns/ma-ont#",
  mads: "http://www.loc.gov/mads/rdf/v1#",
  math: "http://www.w3.org/2000/10/swap/math#",
  oa: "http://www.w3.org/ns/oa#",
  og: "http://ogp.me/ns#",
  oidc: "http://www.w3.org/ns/solid/oidc#",
  org: "http://www.w3.org/ns/org#",
  owl: "http://www.w3.org/2002/07/owl#",
  pim: "http://www.w3.org/ns/pim/space#",
  prefix: "http://qudt.org/vocab/prefix/",
  prov: "http://www.w3.org/ns/prov#",
  qb: "http://purl.org/linked-data/cube#",
  qkdv: "http://qudt.org/vocab/dimensionvector/",
  quantitykind: "http://qudt.org/vocab/quantitykind/",
  qudt: "http://qudt.org/schema/qudt/",
  rdau: "http://rdaregistry.info/Elements/u/",
  rdf: "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
  rdfa: "http://www.w3.org/ns/rdfa#",
  rdfs: "http://www.w3.org/2000/01/rdf-schema#",
  rev: "http://purl.org/stuff/rev#",
  rico: "https://www.ica.org/standards/RiC/ontology#",
  rr: "http://www.w3.org/ns/r2rml#",
  rss: "http://purl.org/rss/1.0/",
  schema: "http://schema.org/",
  sd: "http://www.w3.org/ns/sparql-service-description#",
  sdmx: "http://purl.org/linked-data/sdmx#",
  sem: "http://semanticweb.cs.vu.nl/2009/11/sem/",
  set: "http://www.w3.org/2000/10/swap/set#",
  sf: "http://www.opengis.net/ont/sf#",
  sh: "http://www.w3.org/ns/shacl#",
  shex: "http://www.w3.org/ns/shex#",
  shsh: "http://www.w3.org/ns/shacl-shacl#",
  sioc: "http://rdfs.org/sioc/ns#",
  skos: "http://www.w3.org/2004/02/skos/core#",
  skosxl: "http://www.w3.org/2008/05/skos-xl#",
  solid: "http://www.w3.org/ns/solid/terms#",
  sosa: "http://www.w3.org/ns/sosa/",
  sou: "http://qudt.org/vocab/sou/",
  ssn: "http://www.w3.org/ns/ssn/",
  stat: "http://www.w3.org/ns/posix/stat#",
  string: "http://www.w3.org/2000/10/swap/string#",
  test: "http://www.w3.org/2006/03/test-description#",
  time: "http://www.w3.org/2006/time#",
  unit: "http://qudt.org/vocab/unit/",
  vaem: "http://www.linkedmodel.org/schema/vaem#",
  vann: "http://purl.org/vocab/vann/",
  vcard: "http://www.w3.org/2006/vcard/ns#",
  void: "http://rdfs.org/ns/void#",
  vs: "http://www.w3.org/2003/06/sw-vocab-status/ns#",
  vso: "http://purl.org/vso/ns#",
  wdrs: "http://www.w3.org/2007/05/powder-s#",
  wgs: "http://www.w3.org/2003/01/geo/wgs84_pos#",
  xhv: "http://www.w3.org/1999/xhtml/vocab#",
  xkos: "http://rdf-vocabulary.ddialliance.org/xkos#",
  xsd: "http://www.w3.org/2001/XMLSchema#"
}, vi = {
  ...n9,
  ...r9
};
function p3(e, t = {}) {
  const r = { ...vi, ...t }, n = Array.from(Object.entries(r)).filter(([, o]) => e.startsWith(o));
  if (n.length) {
    n.sort(([, s], [, a]) => a.length - s.length);
    const o = n[0];
    return e.replace(new RegExp(`^${o[1]}`), `${o[0]}:`);
  }
  return "";
}
const i9 = (e) => class {
  constructor() {
    As(this, "dataset");
  }
  init() {
    const r = e(this);
    this.dataset = (n = []) => new r([...n]), this.dataset.Class = r;
  }
};
let mp = class g3 {
  constructor(t, { bind: r = !1 } = {}) {
    this._factories = t.slice();
    for (const n of this._factories) {
      typeof n.prototype.init == "function" && n.prototype.init.call(this);
      for (const o of n.exports || [])
        r ? this[o] = n.prototype[o].bind(this) : this[o] = n.prototype[o];
    }
  }
  clone() {
    const t = new g3(this._factories);
    for (const r of t._factories)
      typeof r.prototype.clone == "function" && r.prototype.clone.call(t, this);
    return t;
  }
};
function vT({ parent: e, child: t }) {
  return new Proxy({}, {
    get(n, o) {
      return t[o] || e[o];
    },
    set(n, o, s) {
      return t[o] = s, !0;
    },
    has(n, o) {
      return o in t || o in e;
    },
    ownKeys() {
      const n = Object.getOwnPropertyNames(e), o = Object.getOwnPropertyNames(t);
      return [...(/* @__PURE__ */ new Set([...n, ...o])).values()];
    },
    getOwnPropertyDescriptor(n, o) {
      return {
        enumerable: !o.toString().startsWith("_"),
        configurable: !0
      };
    }
  });
}
class Uf {
  constructor(t, { parent: r, bind: n = !1 } = {}) {
    if (this._parent = r, t instanceof mp || t instanceof Uf)
      return vT({ parent: r, child: t });
    this._factories = t.slice();
    const o = r ? vT({ parent: r, child: this }) : this;
    for (const s of this._factories) {
      typeof s.prototype.init == "function" && s.prototype.init.call(o);
      for (const a of s.exports || [])
        n ? this[a] = s.prototype[a].bind(o) : this[a] = s.prototype[a];
    }
    return o;
  }
  clone() {
    const t = new Uf(this._factories, this._parent);
    for (const r of t._factories)
      typeof r.prototype.clone == "function" && r.prototype.clone.call(t, this);
    return t;
  }
}
let b3 = class {
  constructor(t) {
    this.value = t;
  }
  equals(t) {
    return !!t && t.termType === this.termType && t.value === this.value;
  }
};
b3.prototype.termType = "BlankNode";
let KE = class {
  equals(t) {
    return !!t && t.termType === this.termType;
  }
};
KE.prototype.termType = "DefaultGraph";
KE.prototype.value = "";
function mT(e, t) {
  if (!t)
    return null;
  if (t.termType === "BlankNode")
    return e.blankNode(t.value);
  if (t.termType === "DefaultGraph")
    return e.defaultGraph();
  if (t.termType === "Literal")
    return e.literal(t.value, t.language || e.namedNode(t.datatype.value));
  if (t.termType === "NamedNode")
    return e.namedNode(t.value);
  if (t.termType === "Quad") {
    const r = e.fromTerm(t.subject), n = e.fromTerm(t.predicate), o = e.fromTerm(t.object), s = e.fromTerm(t.graph);
    return e.quad(r, n, o, s);
  }
  if (t.termType === "Variable")
    return e.variable(t.value);
  throw new Error(`unknown termType ${t.termType}`);
}
let F1 = class {
  constructor(t, r, n) {
    this.value = t, this.language = r, this.datatype = n;
  }
  equals(t) {
    return !!t && t.termType === this.termType && t.value === this.value && t.language === this.language && t.datatype.equals(this.datatype);
  }
};
F1.prototype.termType = "Literal";
let _p = class {
  constructor(t) {
    this.value = t;
  }
  equals(t) {
    return !!t && t.termType === this.termType && t.value === this.value;
  }
};
_p.prototype.termType = "NamedNode";
let YE = class {
  constructor(t, r, n, o) {
    this.subject = t, this.predicate = r, this.object = n, this.graph = o;
  }
  equals(t) {
    return !!t && (t.termType === "Quad" || !t.termType) && t.subject.equals(this.subject) && t.predicate.equals(this.predicate) && t.object.equals(this.object) && t.graph.equals(this.graph);
  }
};
YE.prototype.termType = "Quad";
YE.prototype.value = "";
let y3 = class {
  constructor(t) {
    this.value = t;
  }
  equals(t) {
    return !!t && t.termType === this.termType && t.value === this.value;
  }
};
y3.prototype.termType = "Variable";
const o9 = new _p("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString"), s9 = new _p("http://www.w3.org/2001/XMLSchema#string");
let uu = class {
  constructor() {
    this.init();
  }
  init() {
    this._data = {
      blankNodeCounter: 0,
      defaultGraph: new KE()
    };
  }
  namedNode(t) {
    return new _p(t);
  }
  blankNode(t) {
    return t = t || "b" + ++this._data.blankNodeCounter, new b3(t);
  }
  literal(t, r) {
    return typeof r == "string" ? new F1(t, r, o9) : new F1(t, "", r || s9);
  }
  variable(t) {
    return new y3(t);
  }
  defaultGraph() {
    return this._data.defaultGraph;
  }
  quad(t, r, n, o = this.defaultGraph()) {
    return new YE(t, r, n, o);
  }
  fromTerm(t) {
    return mT(this, t);
  }
  fromQuad(t) {
    return mT(this, t);
  }
};
uu.exports = [
  "blankNode",
  "defaultGraph",
  "fromQuad",
  "fromTerm",
  "literal",
  "namedNode",
  "quad",
  "variable"
];
class hh extends Map {
  import(t, r, n) {
    const o = this.get(t);
    return o ? o.import(r, n) : null;
  }
}
class v3 {
  constructor({ factory: t }) {
    this.factory = t, this.parsers = new hh(), this.serializers = new hh();
  }
  import(t) {
    if (t.parsers)
      for (const [r, n] of t.parsers)
        this.parsers.set(r, new n.constructor({ factory: this.factory }));
    if (t.serializers)
      for (const [r, n] of t.serializers)
        this.serializers.set(r, new n.constructor({ factory: this.factory }));
    return this;
  }
}
let m3 = class {
  init() {
    this.formats = new v3({ factory: this });
  }
  clone(t) {
    this.formats.import(t.formats);
  }
};
const _3 = new uu(), a9 = {
  apply: (e, t, r) => e(r[0]),
  get: (e, t) => e(t)
};
function Se(e, { factory: t = _3 } = {}) {
  const r = (n = "") => t.namedNode(`${e}${n.raw || n}`);
  return typeof Proxy > "u" ? r : new Proxy(r, a9);
}
let XE = class {
  namespace(t) {
    return Se(t, { factory: this });
  }
};
XE.exports = ["namespace"];
class w3 {
  init() {
    this.ns = $E;
  }
}
const l9 = Se("http://www.w3.org/ns/auth/acl#"), u9 = l9, f9 = Se("https://www.w3.org/ns/activitystreams#"), c9 = f9, d9 = Se("http://purl.org/ontology/bibo/"), h9 = d9, p9 = Se("http://creativecommons.org/ns#"), g9 = p9, b9 = Se("http://www.w3.org/ns/auth/cert#"), y9 = b9, v9 = Se("http://www.w3.org/2011/content#"), m9 = v9, _9 = Se("http://qudt.org/vocab/constant/"), w9 = _9, S9 = Se("http://www.cidoc-crm.org/cidoc-crm/"), E9 = S9, x9 = Se("http://www.w3.org/ns/csvw#"), R9 = x9, A9 = Se("http://commontag.org/ns#"), T9 = A9, $9 = Se("http://datashapes.org/sparql#"), N9 = $9, k9 = Se("http://datashapes.org/dash#"), C9 = k9, I9 = Se("http://dbpedia.org/ontology/"), M9 = I9, O9 = Se("http://purl.org/dc/elements/1.1/"), L9 = O9, P9 = Se("http://purl.org/dc/dcam/"), D9 = P9, F9 = Se("http://www.w3.org/ns/dcat#"), j9 = F9, B9 = Se("http://purl.org/dc/dcmitype/"), q9 = B9, W9 = Se("http://purl.org/dc/terms/"), U9 = W9, H9 = Se("http://www.ics.forth.gr/isl/CRMdig/"), V9 = H9, z9 = Se("http://qudt.org/vocab/discipline/"), G9 = z9, K9 = Se("http://usefulinc.com/ns/doap#"), Y9 = K9, X9 = Se("http://www.w3.org/ns/dpv#"), J9 = X9, Q9 = Se("http://www.w3.org/ns/dqv#"), Z9 = Q9, eV = Se("http://www.linkedmodel.org/schema/dtype#"), tV = eV, rV = Se("http://www.w3.org/ns/duv#"), nV = rV, iV = Se("http://www.w3.org/ns/earl#"), oV = iV, sV = Se("http://www.ebu.ch/metadata/ontologies/ebucore/ebucore#"), aV = sV, lV = Se("http://www.w3.org/2003/12/exif/ns#"), uV = lV, fV = Se("http://xmlns.com/foaf/0.1/"), cV = fV, dV = Se("http://purl.org/vocab/frbr/core#"), hV = dV, pV = Se("http://www.opengis.net/ont/geosparql#"), gV = pV, bV = Se("http://www.opengis.net/def/function/geosparql/"), yV = bV, vV = Se("http://www.opengis.net/def/rule/geosparql/"), mV = vV, _V = Se("http://www.opengis.net/ont/gml#"), wV = _V, SV = Se("http://www.geonames.org/ontology#"), EV = SV, xV = Se("http://purl.org/goodrelations/v1#"), RV = xV, AV = Se("http://www.w3.org/2003/g/data-view#"), TV = AV, $V = Se("https://gs1.org/voc/"), NV = $V, kV = Se("http://vocab.gtfs.org/terms#"), CV = kV, IV = Se("http://www.w3.org/2011/http#"), MV = IV, OV = Se("http://www.w3.org/ns/hydra/core#"), LV = OV, PV = Se("http://www.w3.org/2002/12/cal/icaltzd#"), DV = PV, FV = Se("https://linked.art/ns/terms/"), jV = FV, BV = Se("http://www.w3.org/ns/ldp#"), qV = BV, WV = Se("http://www.w3.org/2000/10/swap/list#"), UV = WV, HV = Se("http://www.w3.org/ns/locn#"), VV = HV, zV = Se("http://www.w3.org/2000/10/swap/log#"), GV = zV, KV = Se("http://lexvo.org/ontology#"), YV = KV, XV = Se("http://w3id.org/nfdi4ing/metadata4ing#"), JV = XV, QV = Se("http://www.w3.org/ns/ma-ont#"), ZV = QV, ez = Se("http://www.loc.gov/mads/rdf/v1#"), tz = ez, rz = Se("http://www.w3.org/2000/10/swap/math#"), nz = rz, iz = Se("http://www.w3.org/ns/oa#"), oz = iz, sz = Se("http://ogp.me/ns#"), az = sz, lz = Se("http://www.w3.org/ns/solid/oidc#"), uz = lz, fz = Se("http://www.w3.org/ns/org#"), cz = fz, dz = Se("http://www.w3.org/2002/07/owl#"), hz = dz, pz = Se("http://www.w3.org/ns/pim/space#"), gz = pz, bz = Se("http://qudt.org/vocab/prefix/"), yz = bz, vz = Se("http://www.w3.org/ns/prov#"), mz = vz, _z = Se("http://purl.org/linked-data/cube#"), wz = _z, Sz = Se("http://qudt.org/vocab/dimensionvector/"), Ez = Sz, xz = Se("http://qudt.org/vocab/quantitykind/"), Rz = xz, Az = Se("http://qudt.org/schema/qudt/"), Tz = Az, $z = Se("http://rdaregistry.info/Elements/u/"), Nz = $z, kz = Se("http://www.w3.org/1999/02/22-rdf-syntax-ns#"), Bn = kz, Cz = Se("http://www.w3.org/ns/rdfa#"), Iz = Cz, Mz = Se("http://www.w3.org/2000/01/rdf-schema#"), Oz = Mz, Lz = Se("http://purl.org/stuff/rev#"), Pz = Lz, Dz = Se("https://www.ica.org/standards/RiC/ontology#"), Fz = Dz, jz = Se("http://www.w3.org/ns/r2rml#"), Bz = jz, qz = Se("http://purl.org/rss/1.0/"), Wz = qz, Uz = Se("http://schema.org/"), Hz = Uz, Vz = Se("http://www.w3.org/ns/sparql-service-description#"), zz = Vz, Gz = Se("http://purl.org/linked-data/sdmx#"), Kz = Gz, Yz = Se("http://semanticweb.cs.vu.nl/2009/11/sem/"), Xz = Yz, Jz = Se("http://www.w3.org/2000/10/swap/set#"), Qz = Jz, Zz = Se("http://www.opengis.net/ont/sf#"), eG = Zz, tG = Se("http://www.w3.org/ns/shacl#"), rG = tG, nG = Se("http://www.w3.org/ns/shex#"), iG = nG, oG = Se("https://www.w3.org/ns/shacl-shacl#"), sG = oG, aG = Se("http://rdfs.org/sioc/ns#"), lG = aG, uG = Se("http://www.w3.org/2004/02/skos/core#"), fG = uG, cG = Se("http://www.w3.org/2008/05/skos-xl#"), dG = cG, hG = Se("http://www.w3.org/ns/solid/terms#"), pG = hG, gG = Se("http://www.w3.org/ns/sosa/"), bG = gG, yG = Se("http://qudt.org/vocab/sou/"), vG = yG, mG = Se("http://www.w3.org/ns/ssn/"), _G = mG, wG = Se("http://www.w3.org/ns/posix/stat#"), SG = wG, EG = Se("http://www.w3.org/2000/10/swap/string#"), xG = EG, RG = Se("http://www.w3.org/2006/03/test-description#"), AG = RG, TG = Se("http://www.w3.org/2006/time#"), $G = TG, NG = Se("http://qudt.org/vocab/unit/"), kG = NG, CG = Se("http://www.linkedmodel.org/schema/vaem#"), IG = CG, MG = Se("http://purl.org/vocab/vann/"), OG = MG, LG = Se("http://www.w3.org/2006/vcard/ns#"), PG = LG, DG = Se("http://rdfs.org/ns/void#"), FG = DG, jG = Se("http://www.w3.org/2003/06/sw-vocab-status/ns#"), BG = jG, qG = Se("http://www.w3.org/2007/05/powder-s#"), WG = qG, UG = Se("http://www.w3.org/2003/01/geo/wgs84_pos#"), HG = UG, VG = Se("http://www.w3.org/1999/xhtml/vocab#"), zG = VG, GG = Se("http://rdf-vocabulary.ddialliance.org/xkos#"), KG = GG, YG = Se("http://www.w3.org/2001/XMLSchema#"), mf = YG, XG = Se("http://www.w3.org/2007/rif#"), JG = XG, QG = Se("http://rdf.data-vocabulary.org/#"), ZG = QG, eK = Se("http://www.w3.org/2007/05/powder#"), tK = eK, rK = Se("http://www.w3.org/XML/1998/namespace/"), nK = rK, JE = (e) => {
  const t = e.namespace("http://www.w3.org/2001/XMLSchema#"), r = e.namespace("http://www.w3.org/1999/02/22-rdf-syntax-ns#");
  return {
    first: r.first,
    nil: r.nil,
    rest: r.rest,
    langString: r.langString,
    xsd: t
  };
};
function Jr(e, t) {
  return typeof e > "u" || e === null ? t : Array.isArray(e) ? e : typeof e != "string" && e[Symbol.iterator] ? [...e] : [e];
}
const Fa = new mp([
  XE,
  uu
]), { xsd: j1 } = JE(Fa);
function iK(e, t = Fa) {
  return typeof e != "boolean" ? null : t.literal(e.toString(), j1("boolean"));
}
function oK(e, t = Fa) {
  return typeof e != "number" ? null : Number.isInteger(e) ? t.literal(e.toString(10), j1("integer")) : t.literal(e.toString(10), j1("double"));
}
function sK(e, t = Fa) {
  return typeof e != "string" ? null : t.literal(e);
}
function aK(e, t = Fa) {
  return iK(e, t) || oK(e, t) || sK(e, t);
}
function lK(e, t) {
  if (e && typeof e != "string")
    throw new Error("Blank node identifier must be a string");
  return t.blankNode(e);
}
function uK(e, t, r) {
  if (typeof e == "string")
    return t = t && (t.value || t.toString()), t && t.indexOf(":") !== -1 && (t = r.namedNode(t)), r.literal(e.toString(), t);
  const n = aK(e, r);
  if (!n)
    throw new Error("The value cannot be converted to a literal node");
  return n;
}
function _T(e, t) {
  if (typeof e != "string")
    throw new Error("Named node must be an IRI string");
  return t.namedNode(e);
}
function S3(e, t = "Literal", r, n) {
  if (e && typeof e == "object" && e.termType)
    return e;
  if (e && e.constructor.name === "URL")
    return _T(e.toString(), n);
  if (t === "BlankNode")
    return lK(e, n);
  if (!(e === null || typeof e > "u")) {
    if (t === "Literal")
      return uK(e, r, n);
    if (t === "NamedNode")
      return _T(e, n);
    throw new Error("unknown type");
  }
}
function fK(e, t, r, n) {
  return (typeof e > "u" || e === null) && !t ? e : (Jr(e) || [void 0]).reduce((o, s) => typeof s == "object" && s.terms ? o.concat(s.terms) : (o.push(S3(s, t, r, n)), o), []);
}
const wT = JE(Fa);
function cK(e, t) {
  const r = t.termType !== "Literal", n = wT.langString.equals(t.datatype) || wT.xsd.string.equals(t.datatype);
  if (r || !n)
    return e;
  const o = t.language.toLowerCase();
  return e.has(o) ? e.get(o).push(t) : e.set(o, [t]), e;
}
function dK(e) {
  const t = e.reduce(cK, /* @__PURE__ */ new Map()), r = [...t.entries()];
  return (n) => {
    const o = n.toLowerCase();
    if (o === "*")
      return r[0] && r[0][1];
    const s = t.get(o);
    if (s)
      return s;
    const a = r.find(([l]) => l.startsWith(o));
    return a && a[1];
  };
}
function hK(e, { language: t }) {
  const r = typeof t == "string" ? [t] : t, n = dK(e);
  return r.map(n).find(Boolean) || [];
}
let pK = class E3 {
  constructor({ dataset: t, graph: r, value: n, factory: o, namespace: s }) {
    this.dataset = t, this.graph = r, this.factory = o, this.namespace = s, this.term = S3(n, void 0, void 0, o);
  }
  clone({ dataset: t = this.dataset, graph: r = this.graph, value: n, factory: o = this.factory, namespace: s = this.namespace }) {
    return new E3({ dataset: t, graph: r, value: n, factory: o, namespace: s });
  }
  has(t, r) {
    return this.matchProperty(Jr(this.term), t, r, Jr(this.graph), "subject").map((n) => this.clone({ value: n }));
  }
  in(t) {
    return this.matchProperty(null, t, Jr(this.term), Jr(this.graph), "subject").map((r) => this.clone({ value: r }));
  }
  out(t, { language: r } = {}) {
    let n = this.matchProperty(Jr(this.term), t, null, Jr(this.graph), "object");
    return typeof r < "u" && (n = hK(n, { language: r })), n.map((o) => this.clone({ value: o }));
  }
  addIn(t, r) {
    const n = [];
    return this.term && r.forEach((o) => {
      t.forEach((s) => {
        this.dataset.add(this.factory.quad(o, s, this.term, this.graph));
      }), n.push(this.clone({ value: o }));
    }), n;
  }
  addOut(t, r) {
    const n = [];
    return this.term && r.forEach((o) => {
      t.forEach((s) => {
        this.dataset.add(this.factory.quad(this.term, s, o, this.graph));
      }), n.push(this.clone({ value: o }));
    }), n;
  }
  addList(t, r) {
    this.term && t.forEach((n) => {
      const o = r.map(() => this.factory.blankNode());
      this.dataset.add(this.factory.quad(this.term, n, o[0] || this.namespace.nil, this.graph));
      for (let s = 0; s < o.length; s++)
        this.dataset.add(this.factory.quad(o[s], this.namespace.first, r[s], this.graph)), this.dataset.add(this.factory.quad(o[s], this.namespace.rest, o[s + 1] || this.namespace.nil, this.graph));
    });
  }
  deleteIn(t, r) {
    this.deleteMatch(r, t, Jr(this.term), Jr(this.graph));
  }
  deleteOut(t, r) {
    this.deleteMatch(Jr(this.term), t, r, Jr(this.graph));
  }
  deleteList(t) {
    t.forEach((r) => {
      for (const n of this.dataset.match(this.term, r))
        this.deleteItems(n);
    });
  }
  deleteItems(t) {
    let r = [t];
    for (; !r[r.length - 1].object.equals(this.namespace.nil); ) {
      const n = r[r.length - 1].object;
      r = r.concat([...this.dataset.match(n)]);
    }
    r.forEach((n) => {
      this.dataset.delete(n);
    });
  }
  match(t, r, n, o) {
    if (!t && !r && !n && !o)
      return [...this.dataset];
    t = t || [null], r = r || [null], n = n || [null], o = o || [null];
    const s = [];
    for (const a of o)
      for (const l of t)
        for (const u of r)
          for (const f of n)
            for (const c of this.dataset.match(l, u, f, a))
              s.push(c);
    return s;
  }
  matchProperty(t, r, n, o, s) {
    return this.match(t, r, n, o).map((a) => a[s]);
  }
  deleteMatch(t, r, n, o) {
    this.match(t, r, n, o).forEach((s) => {
      this.dataset.delete(s);
    });
  }
};
class Yr {
  constructor({ dataset: t, graph: r, term: n, value: o, factory: s, _context: a }) {
    if (this.factory = s, this.namespace = JE(s), a) {
      this._context = a;
      return;
    }
    const l = n && Jr(n) || o && Jr(o) || [null];
    this._context = l.map((u) => new pK({ dataset: t, graph: r, value: u, factory: this.factory, namespace: this.namespace }));
  }
  /**
   * Gets the current RDF/JS term or undefined if pointer has no context
   *
   * @returns {undefined|Term}
   */
  get term() {
    const t = this.terms;
    if (t.length === 1)
      return t[0];
  }
  /**
   * Gets the current terms or an empty array if the pointer has no context
   *
   * @returns {Term[]}
   */
  get terms() {
    return this._context.map((t) => t.term).filter(Boolean);
  }
  /**
   * Gets the string representation of term
   *
   * @returns {undefined|string}
   */
  get value() {
    const t = this.term;
    return t && t.value;
  }
  /**
   * Gets the string representation of terms
   *
   * @returns {string[]}
   */
  get values() {
    return this.terms.map((t) => t.value);
  }
  /**
   * Gets the current context's dataset, or undefined if there are multiple
   *
   * @returns {undefined|DatasetCore}
   */
  get dataset() {
    const t = this.datasets;
    if (t.length === 1)
      return t[0];
  }
  /**
   * Gets the current context's datasets
   *
   * @returns {DatasetCore[]}
   */
  get datasets() {
    return this._context.map((t) => t.dataset).filter(Boolean);
  }
  /**
   * Removes current pointers from the context and return an "any pointer".
   * The returned object can be used to find any nodes in the dataset
   *
   * @returns {Clownface}
   */
  any() {
    return Yr.fromContext(this._context.map((t) => t.clone({})), this);
  }
  /**
   * Returns true if the current term is a rdf:List
   *
   * @returns {boolean}
   */
  isList() {
    return this.term ? !!(this.term.equals(this.namespace.nil) || this.out(this.namespace.first).term) : !1;
  }
  /**
   * Creates an iterator which iterates and rdf:List of the current term
   *
   * @returns {Iterable | null}
   */
  list() {
    if (this.terms.length > 1)
      throw new Error("iterator over multiple terms is not supported");
    if (this.term && (this.term.termType !== "NamedNode" && this.term.termType !== "BlankNode" || !this.term.equals(this.namespace.nil) && !this.out(this.namespace.first).term))
      return null;
    let t = this;
    return {
      [Symbol.iterator]: () => ({
        next: () => {
          if (!t.term || t.term.equals(this.namespace.nil))
            return { done: !0 };
          const r = t.out(this.namespace.first);
          if (r.terms.length > 1)
            throw new Error(`Invalid list: multiple values for rdf:first on ${t.value}`);
          const n = t.out(this.namespace.rest);
          if (n.terms.length > 1)
            throw new Error(`Invalid list: multiple values for rdf:rest on ${t.value}`);
          return t = n, { done: !1, value: r };
        }
      })
    };
  }
  /**
   * Returns an array of graph pointers where each one has a single _context
   *
   * @returns {Clownface[]}
   */
  toArray() {
    return this._context.map((t) => Yr.fromContext(t, this)).filter((t) => t.terms.some(Boolean));
  }
  /**
   * Returns graph pointers which meet the condition specified in a callback function
   * @param {FilterCallback} callback
   * @returns {Clownface}
   */
  filter(t) {
    const r = this._context.map((n) => Yr.fromContext(n, this));
    return Yr.fromContext(this._context.filter((n, o) => t(Yr.fromContext(n, this), o, r)), this);
  }
  /**
   * Performs the specified action on every graph pointer
   * @param {ForEachCallback} callback
   * @returns {Clownface}
   */
  forEach(t) {
    return this.toArray().forEach(t), this;
  }
  /**
   * Calls a defined callback function on each graph pointer, and returns an array that contains the results.
   * @template T
   * @param {MapCallback<T>} callback
   * @returns {T[]}
   */
  map(t) {
    return this.toArray().map(t);
  }
  toString() {
    return this.values.join();
  }
  /**
   * Creates graph pointer to one or more node(s)
   *
   * Depending on the value creates pointers to:
   *
   * - blank node context for null `values`
   * - literal for string `values` and no `options` paramter
   * - matching RDF/JS term
   * - term created according to `options.type` parameter
   *
   * @param {null|string|string[]|Term|Term[]|Clownface|Clownface[]} values
   * @param {Object} [options]
   * @param {"NamedNode"|"BlankNode"|"Literal"} [options.type] explicit type for nodes
   * @param {string} [options.language] language tag of literals
   * @param {string} [options.datatype] datatype of literals
   * @returns {Clownface}
   */
  node(t, { type: r, datatype: n, language: o } = {}) {
    t = this._toTermArray(t, r, n || o) || [null];
    const s = t.reduce((a, l) => a.concat(this._context.reduce((u, f) => u.concat([f.clone({ value: l })]), [])), []);
    return Yr.fromContext(s, { factory: this.factory });
  }
  /**
   * Creates graph pointer to one or more blank nodes
   * @param {null|string|string[]|BlankNode|BlankNode[]|Clownface|Clownface[]} [values] blank node identifiers (generates it when falsy) or existing RDF/JS blank node(s)
   * @returns {Clownface}
   */
  blankNode(t) {
    return this.node(t, { type: "BlankNode" });
  }
  /**
   * Creates graph pointer to one or more literal nodes
   * @param {string|string[]|boolean|boolean[]|number|number[]|Literal|Literal[]|Clownface|Clownface[]} values literal values as JS objects or RDF/JS Literal(s)
   * @param {string|Term} [languageOrDatatype] a language tag string or datatype term
   * @returns {Clownface}
   */
  literal(t, r) {
    return this.node(t, { type: "Literal", datatype: r });
  }
  /**
   * Creates graph pointer to one or more named nodes
   * @param {string|string[]|NamedNode|NamedNode[]|Clownface|Clownface[]} values URI(s) or RDF/JS NamedNode(s)
   * @returns {Clownface}
   */
  namedNode(t) {
    return this.node(t, { type: "NamedNode" });
  }
  /**
   * Creates a graph pointer to nodes which are linked to the current pointer by `predicates`
   * @param {Term|Term[]|Clownface|Clownface[]} [predicates] one or more RDF/JS term identifying a property
   * @returns {Clownface}
   */
  in(t) {
    t = this._toTermArray(t);
    const r = this._context.reduce((n, o) => n.concat(o.in(t)), []);
    return Yr.fromContext(r, this);
  }
  /**
   * Creates a graph pointer to the result nodes after following a predicate, or after
   * following any predicates in an array, starting from the subject(s) (current graph pointer) to the objects.
   * @param {Term|Term[]|Clownface|Clownface[]} [predicates] any predicates to follow
   * @param {object} [options]
   * @param {string | string[] | undefined} [options.language]
   * @returns {Clownface}
   */
  out(t, r = {}) {
    t = this._toTermArray(t);
    const n = this._context.reduce((o, s) => o.concat(s.out(t, r)), []);
    return Yr.fromContext(n, this);
  }
  /**
   * Creates a graph pointer to nodes which are subjects of predicates, optionally also with specific objects
   *
   * If the current context is empty, will check all potential subjects
   *
   * @param {Term|Term[]|Clownface|Clownface[]} predicates RDF property identifiers
   * @param {*} [objects] object values to match
   * @returns {Clownface}
   */
  has(t, r) {
    t = this._toTermArray(t), r = this._toTermArray(r);
    const n = this._context.reduce((o, s) => o.concat(s.has(t, r)), []);
    return Yr.fromContext(n, this);
  }
  /**
   * Creates a new quad(s) in the dataset where the current context is the object
   *
   * @param {Term|Term[]|Clownface|Clownface[]} predicates
   * @param {NamedNode|NamedNode[]|Clownface|Clownface[]} subjects one or more nodes to use as subjects
   * @param {GraphPointerCallback} [callback] called for each object, with subject pointer as parameter
   * @returns {Clownface} current graph pointer
   */
  addIn(t, r, n) {
    if (!t)
      throw new Error("predicate parameter is required");
    typeof r == "function" && (n = r, r = null), t = this._toTermArray(t), r = this._toTermArray(r) || [this.factory.blankNode()];
    const o = this._context.map((s) => s.addIn(t, r));
    return n && Yr.fromContext(o, this).forEach(n), this;
  }
  /**
   * Creates a new quad(s) in the dataset where the current context is the subject
   *
   * @param {Term|Term[]|Clownface|Clownface[]} predicates
   * @param {*} objects one or more values to use for objects
   * @param {GraphPointerCallback} [callback] called for each subject, with object pointer as parameter
   * @returns {Clownface} current graph pointer
   */
  addOut(t, r, n) {
    if (!t)
      throw new Error("predicate parameter is required");
    typeof r == "function" && (n = r, r = null), t = this._toTermArray(t), r = this._toTermArray(r) || [this.factory.blankNode()];
    const o = this._context.map((s) => s.addOut(t, r));
    return n && Yr.fromContext(o, this).forEach(n), this;
  }
  /**
   * Creates a new RDF list or lists containing the given items
   *
   * @param {Term|Term[]|Clownface|Clownface[]} predicates
   * @param {*} items one or more values to use for subjects
   * @returns {Clownface} current graph pointer
   */
  addList(t, r) {
    if (!t || !r)
      throw new Error("predicate and items parameter is required");
    return t = this._toTermArray(t), r = this._toTermArray(r), this._context.forEach((n) => n.addList(t, r)), this;
  }
  /**
   * Deletes all quads where the current graph pointer contexts are the objects
   *
   * @param {Term|Term[]|Clownface|Clownface[]} [predicates]
   * @param {Term|Term[]|Clownface|Clownface[]} [subjects]
   * @returns {Clownface} current graph pointer
   */
  deleteIn(t, r) {
    return t = this._toTermArray(t), r = this._toTermArray(r), this._context.forEach((n) => n.deleteIn(t, r)), this;
  }
  /**
   * Deletes all quads where the current graph pointer contexts are the subjects
   *
   * @param {Term|Term[]|Clownface|Clownface[]} [predicates]
   * @param {Term|Term[]|Clownface|Clownface[]} [objects]
   * @returns {Clownface} current graph pointer
   */
  deleteOut(t, r) {
    return t = this._toTermArray(t), r = this._toTermArray(r), this._context.forEach((n) => n.deleteOut(t, r)), this;
  }
  /**
   * Deletes entire RDF lists where the current graph pointer is the subject
   *
   * @param {Term|Term[]|Clownface|Clownface[]} predicates
   * @returns {Clownface} current graph pointer
   */
  deleteList(t) {
    if (!t)
      throw new Error("predicate parameter is required");
    return t = this._toTermArray(t), this._context.forEach((r) => r.deleteList(t)), this;
  }
  _toTermArray(t, r, n) {
    return fK(t, r, n, this.factory);
  }
  static fromContext(t, { factory: r }) {
    return new Yr({ _context: Jr(t), factory: r });
  }
}
function gK({ dataset: e, graph: t, term: r, value: n, factory: o = Fa, _context: s }) {
  return new Yr({ dataset: e, graph: t, term: r, value: n, factory: o, _context: s });
}
class x3 {
  clownface({ ...t } = {}) {
    return !t.dataset && typeof this.dataset == "function" && (t.dataset = this.dataset()), gK({ ...t, factory: this });
  }
}
x3.exports = ["clownface"];
function bK(e) {
  return "_:" + e.value;
}
var yK = bK;
function vK(e, t) {
  return [...e].map((r) => t(r)).join(`
`) + `
`;
}
var mK = vK;
function _K() {
  return "";
}
var wK = _K;
function SK(e) {
  return "<" + e.value + ">";
}
var R3 = SK;
const EK = R3, xK = /["\\\\\n\r]/, RK = /["\\\\\n\r]/g, AK = {
  '"': '\\"',
  "\\": "\\\\",
  "\n": "\\n",
  "\r": "\\r"
};
function TK(e) {
  return AK[e];
}
function $K(e) {
  return xK.test(e) ? e.replace(RK, TK) : e;
}
function NK(e) {
  const t = $K(e.value);
  return e.datatype.value === "http://www.w3.org/2001/XMLSchema#string" ? '"' + t + '"' : e.datatype.value === "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" ? '"' + t + '"@' + e.language : '"' + t + '"^^' + EK(e.datatype);
}
var kK = NK;
function CK(e, t) {
  const r = t(e.subject), n = t(e.predicate), o = t(e.object), s = t(e.graph);
  return `${r} ${n} ${o} ${s ? s + " " : ""}.`;
}
var IK = CK;
function MK(e) {
  return "?" + e.value;
}
var OK = MK;
const LK = yK, PK = mK, DK = wK, FK = kK, jK = R3, BK = IK, qK = OK;
function B1(e) {
  if (!e)
    return null;
  if (e.termType === "BlankNode")
    return LK(e);
  if (e.termType === "DefaultGraph")
    return DK();
  if (e.termType === "Literal")
    return FK(e);
  if (e.termType === "NamedNode")
    return jK(e);
  if (e.termType === "Quad" || e.subject && e.predicate && e.object && e.graph)
    return BK(e, B1);
  if (e.termType === "Variable")
    return qK(e);
  if (e[Symbol.iterator])
    return PK(e, B1);
  throw new Error(`unknown termType ${e.termType}`);
}
var WK = B1;
const Yo = /* @__PURE__ */ Tn(WK);
class Ku {
  constructor(t) {
    if (this.index = /* @__PURE__ */ new Map(), t)
      for (const [r, n] of t)
        this.set(r, n);
  }
  get size() {
    return this.index.size;
  }
  clear() {
    this.index.clear();
  }
  delete(t) {
    return this.index.delete(Yo(t));
  }
  *entries() {
    for (const [, { term: t, value: r }] of this.index)
      yield [t, r];
  }
  forEach(t, r) {
    for (const n of this.entries())
      t.call(r, n[1], n[0], this);
  }
  get(t) {
    const r = this.index.get(Yo(t));
    return r && r.value;
  }
  has(t) {
    return this.index.has(Yo(t));
  }
  *keys() {
    for (const [, { term: t }] of this.index)
      yield t;
  }
  set(t, r) {
    const n = Yo(t);
    return this.index.set(n, { term: t, value: r }), this;
  }
  *values() {
    for (const [, { value: t }] of this.index)
      yield t;
  }
  [Symbol.iterator]() {
    return this.entries()[Symbol.iterator]();
  }
}
let A3 = class {
  termMap(t) {
    return new Ku(t);
  }
};
A3.exports = ["termMap"];
function ST(e) {
  try {
    return Yo(e);
  } catch {
    return null;
  }
}
class UK {
  constructor(t) {
    if (this.index = /* @__PURE__ */ new Map(), t)
      for (const r of t)
        this.add(r);
  }
  get size() {
    return this.index.size;
  }
  add(t) {
    const r = Yo(t);
    return this.index.has(r) || this.index.set(r, t), this;
  }
  clear() {
    this.index.clear();
  }
  delete(t) {
    return t ? this.index.delete(ST(t)) : !1;
  }
  entries() {
    return this.values().entries();
  }
  forEach(t, r) {
    return this.values().forEach(t, r);
  }
  has(t) {
    return t ? this.index.has(ST(t)) : !1;
  }
  values() {
    return new Set(this.index.values());
  }
  keys() {
    return this.values();
  }
  [Symbol.iterator]() {
    return this.values()[Symbol.iterator]();
  }
}
let T3 = class {
  termSet(t) {
    return new UK(t);
  }
};
T3.exports = ["termSet"];
class HK {
  constructor() {
    this.quadLevel = /* @__PURE__ */ new Map();
  }
  add(t, r) {
    this.quadLevel.set(Yo(t), r);
  }
  has(t, r) {
    const n = this.quadLevel.get(Yo(t));
    return n === void 0 ? !1 : n <= r;
  }
}
function Sb({ backward: e, callback: t, dataset: r, filter: n, forward: o, term: s, visited: a = new HK() }) {
  const l = (u, f) => {
    const c = (d) => {
      for (const h of d) {
        if (a.has(h, f))
          continue;
        a.add(h, f);
        const p = { dataset: r, level: f, quad: h };
        n(p) && (t(p), o && l(h.object, f + 1), e && l(h.subject, f + 1));
      }
    };
    o && c(r.match(u)), e && c(r.match(null, null, u));
  };
  l(s, 0);
}
class VK {
  constructor(t, { backward: r = !1, factory: n, forward: o = !0 }) {
    this.backward = r, this.factory = n, this.filter = t, this.forward = o;
  }
  forEach({ term: t, dataset: r }, n) {
    Sb({
      backward: this.backward,
      callback: n,
      dataset: r,
      filter: this.filter,
      forward: this.forward,
      term: t
    });
  }
  match({ term: t, dataset: r }) {
    const n = this.factory.dataset();
    return Sb({
      backward: this.backward,
      callback: ({ quad: o }) => n.add(o),
      dataset: r,
      filter: this.filter,
      forward: this.forward,
      term: t
    }), n;
  }
  reduce({ term: t, dataset: r }, n, o) {
    let s = o;
    return Sb({
      backward: this.backward,
      callback: (a) => {
        s = n(a, s);
      },
      dataset: r,
      filter: this.filter,
      forward: this.forward,
      term: t
    }), s;
  }
}
let $3 = class {
  traverser(t, { backward: r = !1, forward: n = !0 } = {}) {
    return new VK(t, { backward: r, factory: this, forward: n });
  }
};
$3.exports = ["traverser"];
const zK = new Uf([
  uu,
  m3,
  XE,
  w3,
  x3,
  A3,
  T3,
  $3
]);
function Cs(e) {
  return typeof e == "string" || e instanceof String;
}
const GK = "http://www.w3.org/2001/XMLSchema#string";
function zt(e) {
  if (typeof e == "string")
    return e;
  if (!e)
    return "";
  if (typeof e.id < "u" && e.termType !== "Quad")
    return e.id;
  let t, r, n, o;
  switch (e.termType) {
    case "NamedNode":
      return e.value;
    case "BlankNode":
      return `_:${e.value}`;
    case "Variable":
      return `?${e.value}`;
    case "DefaultGraph":
      return "";
    case "Literal":
      return e.language ? `"${e.value}"@${e.language}` : `"${e.value}"${e.datatype && e.datatype.value !== GK ? `^^${e.datatype.value}` : ""}`;
    case "Quad":
      return t = Eb(zt(e.subject)), r = Eb(zt(e.predicate)), n = Eb(zt(e.object)), o = e.graph.termType === "DefaultGraph" ? "" : ` ${zt(e.graph)}`, `<<${t} ${r} ${n}${o}>>`;
    default:
      throw new Error(`Unexpected termType: ${e.termType}`);
  }
}
const KK = /^"(.*".*)(?="[^"]*$)/;
function Eb(e) {
  return e.replace(KK, (t, r) => `"${r.replace(/"/g, '""')}`);
}
class N3 {
  constructor(t) {
    if (this._size = 0, this._graphs = /* @__PURE__ */ Object.create(null), this._id = 0, this._ids = /* @__PURE__ */ Object.create(null), this._ids["><"] = 0, this._entities = /* @__PURE__ */ Object.create(null), this._quads = /* @__PURE__ */ new Map(), t)
      for (const r of t)
        this.add(r);
  }
  get size() {
    let t = this._size;
    if (t !== null)
      return t;
    t = 0;
    const r = this._graphs;
    let n, o;
    for (const s in r)
      for (const a in n = r[s].subjects)
        for (const l in o = n[a])
          t += Object.keys(o[l]).length;
    return this._size = t, this._size;
  }
  add(t) {
    let r = zt(t.subject), n = zt(t.predicate), o = zt(t.object);
    const s = zt(t.graph);
    let a = this._graphs[s];
    a || (a = this._graphs[s] = { subjects: {}, predicates: {}, objects: {} }, Object.freeze(a));
    const l = this._ids, u = this._entities;
    return r = l[r] || (l[u[++this._id] = r] = this._id), n = l[n] || (l[u[++this._id] = n] = this._id), o = l[o] || (l[u[++this._id] = o] = this._id), this._addToIndex(a.subjects, r, n, o), this._addToIndex(a.predicates, n, o, r), this._addToIndex(a.objects, o, r, n), this._setQuad(r, n, o, s, t), this._size = null, this;
  }
  delete(t) {
    let r = zt(t.subject), n = zt(t.predicate), o = zt(t.object);
    const s = zt(t.graph), a = this._ids, l = this._graphs;
    let u, f, c;
    if (!(r = a[r]) || !(n = a[n]) || !(o = a[o]) || !(u = l[s]) || !(f = u.subjects[r]) || !(c = f[n]) || !(o in c))
      return this;
    this._removeFromIndex(u.subjects, r, n, o), this._removeFromIndex(u.predicates, n, o, r), this._removeFromIndex(u.objects, o, r, n), this._size !== null && this._size--, this._deleteQuad(r, n, o, s);
    for (r in u.subjects)
      return this;
    return delete l[s], this;
  }
  has(t) {
    const r = zt(t.subject), n = zt(t.predicate), o = zt(t.object), s = zt(t.graph), a = this._graphs[s];
    if (!a)
      return !1;
    const l = this._ids;
    let u, f, c;
    return Cs(r) && !(u = l[r]) || Cs(n) && !(f = l[n]) || Cs(o) && !(c = l[o]) ? !1 : this._countInIndex(a.objects, c, u, f) === 1;
  }
  match(t, r, n, o) {
    return this._createDataset(this._match(t, r, n, o));
  }
  [Symbol.iterator]() {
    return this._match()[Symbol.iterator]();
  }
  // ## Private methods
  // ### `_addToIndex` adds a quad to a three-layered index.
  // Returns if the index has changed, if the entry did not already exist.
  _addToIndex(t, r, n, o) {
    const s = t[r] || (t[r] = {}), a = s[n] || (s[n] = {}), l = o in a;
    return l || (a[o] = null), !l;
  }
  // ### `_removeFromIndex` removes a quad from a three-layered index
  _removeFromIndex(t, r, n, o) {
    const s = t[r], a = s[n];
    delete a[o];
    for (const l in a)
      return;
    delete s[n];
    for (const l in s)
      return;
    delete t[r];
  }
  // ### `_findInIndex` finds a set of quads in a three-layered index.
  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.
  // Any of these keys can be undefined, which is interpreted as a wildcard.
  // `name0`, `name1`, and `name2` are the names of the keys at each level,
  // used when reconstructing the resulting quad
  // (for instance: _subject_, _predicate_, and _object_).
  // Finally, `graph` will be the graph of the created quads.
  // If `callback` is given, each result is passed through it
  // and iteration halts when it returns truthy for any quad.
  // If instead `array` is given, each result is added to the array.
  _findInIndex(t, r, n, o, s, a, l, u, f, c) {
    let d, h, p;
    r && ((d = t, t = {})[r] = d[r]);
    for (const v in t)
      if (h = t[v], h) {
        n && ((d = h, h = {})[n] = d[n]);
        for (const y in h)
          if (p = h[y], p) {
            const w = o ? o in p ? [o] : [] : Object.keys(p);
            for (let S = 0; S < w.length; S++) {
              const x = {
                [s]: v,
                [a]: y,
                [l]: w[S]
              }, E = this._getQuad(x.subject, x.predicate, x.object, u);
              if (c)
                c.push(E);
              else if (f(E))
                return !0;
            }
          }
      }
    return c;
  }
  // ### `_countInIndex` counts matching quads in a three-layered index.
  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.
  // Any of these keys can be undefined, which is interpreted as a wildcard.
  _countInIndex(t, r, n, o) {
    let s = 0, a, l, u;
    r && ((a = t, t = {})[r] = a[r]);
    for (const f in t)
      if (l = t[f], l) {
        n && ((a = l, l = {})[n] = a[n]);
        for (const c in l)
          u = l[c], u && (o ? o in u && s++ : s += Object.keys(u).length);
      }
    return s;
  }
  // ### `_getGraphs` returns an array with the given graph,
  // or all graphs if the argument is null or undefined.
  _getGraphs(t) {
    return Cs(t) ? {
      [t]: this._graphs[t]
    } : this._graphs;
  }
  _match(t, r, n, o) {
    t = t && zt(t), r = r && zt(r), n = n && zt(n), o = o && zt(o);
    const s = [], a = this._getGraphs(o), l = this._ids;
    let u, f, c, d;
    if (Cs(t) && !(f = l[t]) || Cs(r) && !(c = l[r]) || Cs(n) && !(d = l[n]))
      return s;
    for (const h in a)
      u = a[h], u && (f ? d ? this._findInIndex(u.objects, d, f, c, "object", "subject", "predicate", h, null, s) : this._findInIndex(u.subjects, f, c, null, "subject", "predicate", "object", h, null, s) : c ? this._findInIndex(u.predicates, c, d, null, "predicate", "object", "subject", h, null, s) : d ? this._findInIndex(u.objects, d, null, null, "object", "subject", "predicate", h, null, s) : this._findInIndex(u.subjects, null, null, null, "subject", "predicate", "object", h, null, s));
    return s;
  }
  _getQuad(t, r, n, o) {
    return this._quads.get(this._toId(t, r, n, o));
  }
  _setQuad(t, r, n, o, s) {
    this._quads.set(this._toId(t, r, n, o), s);
  }
  _deleteQuad(t, r, n, o) {
    this._quads.delete(this._toId(t, r, n, o));
  }
  _createDataset(t) {
    return new this.constructor(t);
  }
  _toId(t, r, n, o) {
    return `${t}:${r}:${n}:${o}`;
  }
}
function YK(e, t) {
  for (const r of t)
    e.add(r);
  return e;
}
var XK = YK;
const ET = /* @__PURE__ */ Tn(XK);
function JK(e, t, r, n, o) {
  const s = e.match(t, r, n, o);
  for (const a of s)
    e.delete(a);
  return e;
}
var QK = JK;
const ZK = /* @__PURE__ */ Tn(QK);
function eY(e, t) {
  if (e.size !== t.size)
    return !1;
  for (const r of e)
    if (!t.has(r))
      return !1;
  return !0;
}
var tY = eY;
const rY = /* @__PURE__ */ Tn(tY);
class _f extends N3 {
  addAll(...[t]) {
    return ET(this, t);
  }
  deleteMatches(...t) {
    return ZK(this, ...t);
  }
  equals(...[t]) {
    return rY(this, t);
  }
  forEach(t) {
    Array.from(this).forEach((r) => t(r, this));
  }
  filter(t) {
    return new _f([...this].filter((r) => t(r, this)));
  }
  map(t) {
    return new _f([...this].map((r) => t(r, this)));
  }
  match(...t) {
    return super.match(...t);
  }
  merge(...[t]) {
    return ET(new _f([...this]), t);
  }
}
const Gt = new Uf([i9(() => _f)], { parent: zK });
class k3 {
  dataset(t) {
    return new N3(t);
  }
}
k3.exports = ["dataset"];
function nY(e) {
  return !(!e || typeof e.dataset != "function");
}
async function q1(e) {
  const t = [];
  for await (const r of e)
    t.push(r);
  return t;
}
class iY {
  constructor(t, r) {
    this.Impl = t, this.options = r;
  }
  import(t, r) {
    const n = new this.Impl(t, { ...this.options, ...r });
    return t.on("end", () => {
      n.readable || n.emit("end");
    }), t.on("error", (o) => {
      n.emit("error", o);
    }), n;
  }
}
const xb = /* @__PURE__ */ new Set(["_write", "_writableState", "writable"]);
function C3(e) {
  return new Proxy(e, {
    has(t, r) {
      return xb.has(r) ? !1 : Reflect.has(...arguments);
    },
    get(t, r) {
      if (xb.has(r))
        return;
      const n = Reflect.get(...arguments);
      return n && typeof n.bind == "function" ? n.bind(t) : n;
    },
    set(t, r, n) {
      if (!xb.has(r))
        return Reflect.set(...arguments);
    }
  });
}
var ft = {}, wp = {};
wp.byteLength = aY;
wp.toByteArray = uY;
wp.fromByteArray = dY;
var bi = [], mn = [], oY = typeof Uint8Array < "u" ? Uint8Array : Array, Rb = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var fl = 0, sY = Rb.length; fl < sY; ++fl)
  bi[fl] = Rb[fl], mn[Rb.charCodeAt(fl)] = fl;
mn[45] = 62;
mn[95] = 63;
function I3(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var n = r === t ? 0 : 4 - r % 4;
  return [r, n];
}
function aY(e) {
  var t = I3(e), r = t[0], n = t[1];
  return (r + n) * 3 / 4 - n;
}
function lY(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function uY(e) {
  var t, r = I3(e), n = r[0], o = r[1], s = new oY(lY(e, n, o)), a = 0, l = o > 0 ? n - 4 : n, u;
  for (u = 0; u < l; u += 4)
    t = mn[e.charCodeAt(u)] << 18 | mn[e.charCodeAt(u + 1)] << 12 | mn[e.charCodeAt(u + 2)] << 6 | mn[e.charCodeAt(u + 3)], s[a++] = t >> 16 & 255, s[a++] = t >> 8 & 255, s[a++] = t & 255;
  return o === 2 && (t = mn[e.charCodeAt(u)] << 2 | mn[e.charCodeAt(u + 1)] >> 4, s[a++] = t & 255), o === 1 && (t = mn[e.charCodeAt(u)] << 10 | mn[e.charCodeAt(u + 1)] << 4 | mn[e.charCodeAt(u + 2)] >> 2, s[a++] = t >> 8 & 255, s[a++] = t & 255), s;
}
function fY(e) {
  return bi[e >> 18 & 63] + bi[e >> 12 & 63] + bi[e >> 6 & 63] + bi[e & 63];
}
function cY(e, t, r) {
  for (var n, o = [], s = t; s < r; s += 3)
    n = (e[s] << 16 & 16711680) + (e[s + 1] << 8 & 65280) + (e[s + 2] & 255), o.push(fY(n));
  return o.join("");
}
function dY(e) {
  for (var t, r = e.length, n = r % 3, o = [], s = 16383, a = 0, l = r - n; a < l; a += s)
    o.push(cY(e, a, a + s > l ? l : a + s));
  return n === 1 ? (t = e[r - 1], o.push(
    bi[t >> 2] + bi[t << 4 & 63] + "=="
  )) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], o.push(
    bi[t >> 10] + bi[t >> 4 & 63] + bi[t << 2 & 63] + "="
  )), o.join("");
}
var QE = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
QE.read = function(e, t, r, n, o) {
  var s, a, l = o * 8 - n - 1, u = (1 << l) - 1, f = u >> 1, c = -7, d = r ? o - 1 : 0, h = r ? -1 : 1, p = e[t + d];
  for (d += h, s = p & (1 << -c) - 1, p >>= -c, c += l; c > 0; s = s * 256 + e[t + d], d += h, c -= 8)
    ;
  for (a = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; a = a * 256 + e[t + d], d += h, c -= 8)
    ;
  if (s === 0)
    s = 1 - f;
  else {
    if (s === u)
      return a ? NaN : (p ? -1 : 1) * (1 / 0);
    a = a + Math.pow(2, n), s = s - f;
  }
  return (p ? -1 : 1) * a * Math.pow(2, s - n);
};
QE.write = function(e, t, r, n, o, s) {
  var a, l, u, f = s * 8 - o - 1, c = (1 << f) - 1, d = c >> 1, h = o === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = n ? 0 : s - 1, v = n ? 1 : -1, y = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (l = isNaN(t) ? 1 : 0, a = c) : (a = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -a)) < 1 && (a--, u *= 2), a + d >= 1 ? t += h / u : t += h * Math.pow(2, 1 - d), t * u >= 2 && (a++, u /= 2), a + d >= c ? (l = 0, a = c) : a + d >= 1 ? (l = (t * u - 1) * Math.pow(2, o), a = a + d) : (l = t * Math.pow(2, d - 1) * Math.pow(2, o), a = 0)); o >= 8; e[r + p] = l & 255, p += v, l /= 256, o -= 8)
    ;
  for (a = a << o | l, f += o; f > 0; e[r + p] = a & 255, p += v, a /= 256, f -= 8)
    ;
  e[r + p - v] |= y * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const t = wp, r = QE, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = l, e.SlowBuffer = x, e.INSPECT_MAX_BYTES = 50;
  const o = 2147483647;
  e.kMaxLength = o, l.TYPED_ARRAY_SUPPORT = s(), !l.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function s() {
    try {
      const M = new Uint8Array(1), R = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(R, Uint8Array.prototype), Object.setPrototypeOf(M, R), M.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(l.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (l.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(l.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (l.isBuffer(this))
        return this.byteOffset;
    }
  });
  function a(M) {
    if (M > o)
      throw new RangeError('The value "' + M + '" is invalid for option "size"');
    const R = new Uint8Array(M);
    return Object.setPrototypeOf(R, l.prototype), R;
  }
  function l(M, R, A) {
    if (typeof M == "number") {
      if (typeof R == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return d(M);
    }
    return u(M, R, A);
  }
  l.poolSize = 8192;
  function u(M, R, A) {
    if (typeof M == "string")
      return h(M, R);
    if (ArrayBuffer.isView(M))
      return v(M);
    if (M == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof M
      );
    if (B(M, ArrayBuffer) || M && B(M.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (B(M, SharedArrayBuffer) || M && B(M.buffer, SharedArrayBuffer)))
      return y(M, R, A);
    if (typeof M == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const q = M.valueOf && M.valueOf();
    if (q != null && q !== M)
      return l.from(q, R, A);
    const ne = w(M);
    if (ne)
      return ne;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof M[Symbol.toPrimitive] == "function")
      return l.from(M[Symbol.toPrimitive]("string"), R, A);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof M
    );
  }
  l.from = function(M, R, A) {
    return u(M, R, A);
  }, Object.setPrototypeOf(l.prototype, Uint8Array.prototype), Object.setPrototypeOf(l, Uint8Array);
  function f(M) {
    if (typeof M != "number")
      throw new TypeError('"size" argument must be of type number');
    if (M < 0)
      throw new RangeError('The value "' + M + '" is invalid for option "size"');
  }
  function c(M, R, A) {
    return f(M), M <= 0 ? a(M) : R !== void 0 ? typeof A == "string" ? a(M).fill(R, A) : a(M).fill(R) : a(M);
  }
  l.alloc = function(M, R, A) {
    return c(M, R, A);
  };
  function d(M) {
    return f(M), a(M < 0 ? 0 : S(M) | 0);
  }
  l.allocUnsafe = function(M) {
    return d(M);
  }, l.allocUnsafeSlow = function(M) {
    return d(M);
  };
  function h(M, R) {
    if ((typeof R != "string" || R === "") && (R = "utf8"), !l.isEncoding(R))
      throw new TypeError("Unknown encoding: " + R);
    const A = E(M, R) | 0;
    let q = a(A);
    const ne = q.write(M, R);
    return ne !== A && (q = q.slice(0, ne)), q;
  }
  function p(M) {
    const R = M.length < 0 ? 0 : S(M.length) | 0, A = a(R);
    for (let q = 0; q < R; q += 1)
      A[q] = M[q] & 255;
    return A;
  }
  function v(M) {
    if (B(M, Uint8Array)) {
      const R = new Uint8Array(M);
      return y(R.buffer, R.byteOffset, R.byteLength);
    }
    return p(M);
  }
  function y(M, R, A) {
    if (R < 0 || M.byteLength < R)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (M.byteLength < R + (A || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let q;
    return R === void 0 && A === void 0 ? q = new Uint8Array(M) : A === void 0 ? q = new Uint8Array(M, R) : q = new Uint8Array(M, R, A), Object.setPrototypeOf(q, l.prototype), q;
  }
  function w(M) {
    if (l.isBuffer(M)) {
      const R = S(M.length) | 0, A = a(R);
      return A.length === 0 || M.copy(A, 0, 0, R), A;
    }
    if (M.length !== void 0)
      return typeof M.length != "number" || me(M.length) ? a(0) : p(M);
    if (M.type === "Buffer" && Array.isArray(M.data))
      return p(M.data);
  }
  function S(M) {
    if (M >= o)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes");
    return M | 0;
  }
  function x(M) {
    return +M != M && (M = 0), l.alloc(+M);
  }
  l.isBuffer = function(R) {
    return R != null && R._isBuffer === !0 && R !== l.prototype;
  }, l.compare = function(R, A) {
    if (B(R, Uint8Array) && (R = l.from(R, R.offset, R.byteLength)), B(A, Uint8Array) && (A = l.from(A, A.offset, A.byteLength)), !l.isBuffer(R) || !l.isBuffer(A))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (R === A)
      return 0;
    let q = R.length, ne = A.length;
    for (let de = 0, he = Math.min(q, ne); de < he; ++de)
      if (R[de] !== A[de]) {
        q = R[de], ne = A[de];
        break;
      }
    return q < ne ? -1 : ne < q ? 1 : 0;
  }, l.isEncoding = function(R) {
    switch (String(R).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, l.concat = function(R, A) {
    if (!Array.isArray(R))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (R.length === 0)
      return l.alloc(0);
    let q;
    if (A === void 0)
      for (A = 0, q = 0; q < R.length; ++q)
        A += R[q].length;
    const ne = l.allocUnsafe(A);
    let de = 0;
    for (q = 0; q < R.length; ++q) {
      let he = R[q];
      if (B(he, Uint8Array))
        de + he.length > ne.length ? (l.isBuffer(he) || (he = l.from(he)), he.copy(ne, de)) : Uint8Array.prototype.set.call(
          ne,
          he,
          de
        );
      else if (l.isBuffer(he))
        he.copy(ne, de);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      de += he.length;
    }
    return ne;
  };
  function E(M, R) {
    if (l.isBuffer(M))
      return M.length;
    if (ArrayBuffer.isView(M) || B(M, ArrayBuffer))
      return M.byteLength;
    if (typeof M != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof M
      );
    const A = M.length, q = arguments.length > 2 && arguments[2] === !0;
    if (!q && A === 0)
      return 0;
    let ne = !1;
    for (; ; )
      switch (R) {
        case "ascii":
        case "latin1":
        case "binary":
          return A;
        case "utf8":
        case "utf-8":
          return O(M).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return A * 2;
        case "hex":
          return A >>> 1;
        case "base64":
          return se(M).length;
        default:
          if (ne)
            return q ? -1 : O(M).length;
          R = ("" + R).toLowerCase(), ne = !0;
      }
  }
  l.byteLength = E;
  function N(M, R, A) {
    let q = !1;
    if ((R === void 0 || R < 0) && (R = 0), R > this.length || ((A === void 0 || A > this.length) && (A = this.length), A <= 0) || (A >>>= 0, R >>>= 0, A <= R))
      return "";
    for (M || (M = "utf8"); ; )
      switch (M) {
        case "hex":
          return ce(this, R, A);
        case "utf8":
        case "utf-8":
          return U(this, R, A);
        case "ascii":
          return re(this, R, A);
        case "latin1":
        case "binary":
          return ae(this, R, A);
        case "base64":
          return k(this, R, A);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return pe(this, R, A);
        default:
          if (q)
            throw new TypeError("Unknown encoding: " + M);
          M = (M + "").toLowerCase(), q = !0;
      }
  }
  l.prototype._isBuffer = !0;
  function C(M, R, A) {
    const q = M[R];
    M[R] = M[A], M[A] = q;
  }
  l.prototype.swap16 = function() {
    const R = this.length;
    if (R % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let A = 0; A < R; A += 2)
      C(this, A, A + 1);
    return this;
  }, l.prototype.swap32 = function() {
    const R = this.length;
    if (R % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let A = 0; A < R; A += 4)
      C(this, A, A + 3), C(this, A + 1, A + 2);
    return this;
  }, l.prototype.swap64 = function() {
    const R = this.length;
    if (R % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let A = 0; A < R; A += 8)
      C(this, A, A + 7), C(this, A + 1, A + 6), C(this, A + 2, A + 5), C(this, A + 3, A + 4);
    return this;
  }, l.prototype.toString = function() {
    const R = this.length;
    return R === 0 ? "" : arguments.length === 0 ? U(this, 0, R) : N.apply(this, arguments);
  }, l.prototype.toLocaleString = l.prototype.toString, l.prototype.equals = function(R) {
    if (!l.isBuffer(R))
      throw new TypeError("Argument must be a Buffer");
    return this === R ? !0 : l.compare(this, R) === 0;
  }, l.prototype.inspect = function() {
    let R = "";
    const A = e.INSPECT_MAX_BYTES;
    return R = this.toString("hex", 0, A).replace(/(.{2})/g, "$1 ").trim(), this.length > A && (R += " ... "), "<Buffer " + R + ">";
  }, n && (l.prototype[n] = l.prototype.inspect), l.prototype.compare = function(R, A, q, ne, de) {
    if (B(R, Uint8Array) && (R = l.from(R, R.offset, R.byteLength)), !l.isBuffer(R))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof R
      );
    if (A === void 0 && (A = 0), q === void 0 && (q = R ? R.length : 0), ne === void 0 && (ne = 0), de === void 0 && (de = this.length), A < 0 || q > R.length || ne < 0 || de > this.length)
      throw new RangeError("out of range index");
    if (ne >= de && A >= q)
      return 0;
    if (ne >= de)
      return -1;
    if (A >= q)
      return 1;
    if (A >>>= 0, q >>>= 0, ne >>>= 0, de >>>= 0, this === R)
      return 0;
    let he = de - ne, Fe = q - A;
    const ot = Math.min(he, Fe), ze = this.slice(ne, de), Ke = R.slice(A, q);
    for (let et = 0; et < ot; ++et)
      if (ze[et] !== Ke[et]) {
        he = ze[et], Fe = Ke[et];
        break;
      }
    return he < Fe ? -1 : Fe < he ? 1 : 0;
  };
  function j(M, R, A, q, ne) {
    if (M.length === 0)
      return -1;
    if (typeof A == "string" ? (q = A, A = 0) : A > 2147483647 ? A = 2147483647 : A < -2147483648 && (A = -2147483648), A = +A, me(A) && (A = ne ? 0 : M.length - 1), A < 0 && (A = M.length + A), A >= M.length) {
      if (ne)
        return -1;
      A = M.length - 1;
    } else if (A < 0)
      if (ne)
        A = 0;
      else
        return -1;
    if (typeof R == "string" && (R = l.from(R, q)), l.isBuffer(R))
      return R.length === 0 ? -1 : J(M, R, A, q, ne);
    if (typeof R == "number")
      return R = R & 255, typeof Uint8Array.prototype.indexOf == "function" ? ne ? Uint8Array.prototype.indexOf.call(M, R, A) : Uint8Array.prototype.lastIndexOf.call(M, R, A) : J(M, [R], A, q, ne);
    throw new TypeError("val must be string, number or Buffer");
  }
  function J(M, R, A, q, ne) {
    let de = 1, he = M.length, Fe = R.length;
    if (q !== void 0 && (q = String(q).toLowerCase(), q === "ucs2" || q === "ucs-2" || q === "utf16le" || q === "utf-16le")) {
      if (M.length < 2 || R.length < 2)
        return -1;
      de = 2, he /= 2, Fe /= 2, A /= 2;
    }
    function ot(Ke, et) {
      return de === 1 ? Ke[et] : Ke.readUInt16BE(et * de);
    }
    let ze;
    if (ne) {
      let Ke = -1;
      for (ze = A; ze < he; ze++)
        if (ot(M, ze) === ot(R, Ke === -1 ? 0 : ze - Ke)) {
          if (Ke === -1 && (Ke = ze), ze - Ke + 1 === Fe)
            return Ke * de;
        } else
          Ke !== -1 && (ze -= ze - Ke), Ke = -1;
    } else
      for (A + Fe > he && (A = he - Fe), ze = A; ze >= 0; ze--) {
        let Ke = !0;
        for (let et = 0; et < Fe; et++)
          if (ot(M, ze + et) !== ot(R, et)) {
            Ke = !1;
            break;
          }
        if (Ke)
          return ze;
      }
    return -1;
  }
  l.prototype.includes = function(R, A, q) {
    return this.indexOf(R, A, q) !== -1;
  }, l.prototype.indexOf = function(R, A, q) {
    return j(this, R, A, q, !0);
  }, l.prototype.lastIndexOf = function(R, A, q) {
    return j(this, R, A, q, !1);
  };
  function z(M, R, A, q) {
    A = Number(A) || 0;
    const ne = M.length - A;
    q ? (q = Number(q), q > ne && (q = ne)) : q = ne;
    const de = R.length;
    q > de / 2 && (q = de / 2);
    let he;
    for (he = 0; he < q; ++he) {
      const Fe = parseInt(R.substr(he * 2, 2), 16);
      if (me(Fe))
        return he;
      M[A + he] = Fe;
    }
    return he;
  }
  function $(M, R, A, q) {
    return ve(O(R, M.length - A), M, A, q);
  }
  function G(M, R, A, q) {
    return ve(ie(R), M, A, q);
  }
  function I(M, R, A, q) {
    return ve(se(R), M, A, q);
  }
  function W(M, R, A, q) {
    return ve(fe(R, M.length - A), M, A, q);
  }
  l.prototype.write = function(R, A, q, ne) {
    if (A === void 0)
      ne = "utf8", q = this.length, A = 0;
    else if (q === void 0 && typeof A == "string")
      ne = A, q = this.length, A = 0;
    else if (isFinite(A))
      A = A >>> 0, isFinite(q) ? (q = q >>> 0, ne === void 0 && (ne = "utf8")) : (ne = q, q = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const de = this.length - A;
    if ((q === void 0 || q > de) && (q = de), R.length > 0 && (q < 0 || A < 0) || A > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    ne || (ne = "utf8");
    let he = !1;
    for (; ; )
      switch (ne) {
        case "hex":
          return z(this, R, A, q);
        case "utf8":
        case "utf-8":
          return $(this, R, A, q);
        case "ascii":
        case "latin1":
        case "binary":
          return G(this, R, A, q);
        case "base64":
          return I(this, R, A, q);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return W(this, R, A, q);
        default:
          if (he)
            throw new TypeError("Unknown encoding: " + ne);
          ne = ("" + ne).toLowerCase(), he = !0;
      }
  }, l.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function k(M, R, A) {
    return R === 0 && A === M.length ? t.fromByteArray(M) : t.fromByteArray(M.slice(R, A));
  }
  function U(M, R, A) {
    A = Math.min(M.length, A);
    const q = [];
    let ne = R;
    for (; ne < A; ) {
      const de = M[ne];
      let he = null, Fe = de > 239 ? 4 : de > 223 ? 3 : de > 191 ? 2 : 1;
      if (ne + Fe <= A) {
        let ot, ze, Ke, et;
        switch (Fe) {
          case 1:
            de < 128 && (he = de);
            break;
          case 2:
            ot = M[ne + 1], (ot & 192) === 128 && (et = (de & 31) << 6 | ot & 63, et > 127 && (he = et));
            break;
          case 3:
            ot = M[ne + 1], ze = M[ne + 2], (ot & 192) === 128 && (ze & 192) === 128 && (et = (de & 15) << 12 | (ot & 63) << 6 | ze & 63, et > 2047 && (et < 55296 || et > 57343) && (he = et));
            break;
          case 4:
            ot = M[ne + 1], ze = M[ne + 2], Ke = M[ne + 3], (ot & 192) === 128 && (ze & 192) === 128 && (Ke & 192) === 128 && (et = (de & 15) << 18 | (ot & 63) << 12 | (ze & 63) << 6 | Ke & 63, et > 65535 && et < 1114112 && (he = et));
        }
      }
      he === null ? (he = 65533, Fe = 1) : he > 65535 && (he -= 65536, q.push(he >>> 10 & 1023 | 55296), he = 56320 | he & 1023), q.push(he), ne += Fe;
    }
    return Y(q);
  }
  const Z = 4096;
  function Y(M) {
    const R = M.length;
    if (R <= Z)
      return String.fromCharCode.apply(String, M);
    let A = "", q = 0;
    for (; q < R; )
      A += String.fromCharCode.apply(
        String,
        M.slice(q, q += Z)
      );
    return A;
  }
  function re(M, R, A) {
    let q = "";
    A = Math.min(M.length, A);
    for (let ne = R; ne < A; ++ne)
      q += String.fromCharCode(M[ne] & 127);
    return q;
  }
  function ae(M, R, A) {
    let q = "";
    A = Math.min(M.length, A);
    for (let ne = R; ne < A; ++ne)
      q += String.fromCharCode(M[ne]);
    return q;
  }
  function ce(M, R, A) {
    const q = M.length;
    (!R || R < 0) && (R = 0), (!A || A < 0 || A > q) && (A = q);
    let ne = "";
    for (let de = R; de < A; ++de)
      ne += ke[M[de]];
    return ne;
  }
  function pe(M, R, A) {
    const q = M.slice(R, A);
    let ne = "";
    for (let de = 0; de < q.length - 1; de += 2)
      ne += String.fromCharCode(q[de] + q[de + 1] * 256);
    return ne;
  }
  l.prototype.slice = function(R, A) {
    const q = this.length;
    R = ~~R, A = A === void 0 ? q : ~~A, R < 0 ? (R += q, R < 0 && (R = 0)) : R > q && (R = q), A < 0 ? (A += q, A < 0 && (A = 0)) : A > q && (A = q), A < R && (A = R);
    const ne = this.subarray(R, A);
    return Object.setPrototypeOf(ne, l.prototype), ne;
  };
  function le(M, R, A) {
    if (M % 1 !== 0 || M < 0)
      throw new RangeError("offset is not uint");
    if (M + R > A)
      throw new RangeError("Trying to access beyond buffer length");
  }
  l.prototype.readUintLE = l.prototype.readUIntLE = function(R, A, q) {
    R = R >>> 0, A = A >>> 0, q || le(R, A, this.length);
    let ne = this[R], de = 1, he = 0;
    for (; ++he < A && (de *= 256); )
      ne += this[R + he] * de;
    return ne;
  }, l.prototype.readUintBE = l.prototype.readUIntBE = function(R, A, q) {
    R = R >>> 0, A = A >>> 0, q || le(R, A, this.length);
    let ne = this[R + --A], de = 1;
    for (; A > 0 && (de *= 256); )
      ne += this[R + --A] * de;
    return ne;
  }, l.prototype.readUint8 = l.prototype.readUInt8 = function(R, A) {
    return R = R >>> 0, A || le(R, 1, this.length), this[R];
  }, l.prototype.readUint16LE = l.prototype.readUInt16LE = function(R, A) {
    return R = R >>> 0, A || le(R, 2, this.length), this[R] | this[R + 1] << 8;
  }, l.prototype.readUint16BE = l.prototype.readUInt16BE = function(R, A) {
    return R = R >>> 0, A || le(R, 2, this.length), this[R] << 8 | this[R + 1];
  }, l.prototype.readUint32LE = l.prototype.readUInt32LE = function(R, A) {
    return R = R >>> 0, A || le(R, 4, this.length), (this[R] | this[R + 1] << 8 | this[R + 2] << 16) + this[R + 3] * 16777216;
  }, l.prototype.readUint32BE = l.prototype.readUInt32BE = function(R, A) {
    return R = R >>> 0, A || le(R, 4, this.length), this[R] * 16777216 + (this[R + 1] << 16 | this[R + 2] << 8 | this[R + 3]);
  }, l.prototype.readBigUInt64LE = Ie(function(R) {
    R = R >>> 0, b(R, "offset");
    const A = this[R], q = this[R + 7];
    (A === void 0 || q === void 0) && _(R, this.length - 8);
    const ne = A + this[++R] * 2 ** 8 + this[++R] * 2 ** 16 + this[++R] * 2 ** 24, de = this[++R] + this[++R] * 2 ** 8 + this[++R] * 2 ** 16 + q * 2 ** 24;
    return BigInt(ne) + (BigInt(de) << BigInt(32));
  }), l.prototype.readBigUInt64BE = Ie(function(R) {
    R = R >>> 0, b(R, "offset");
    const A = this[R], q = this[R + 7];
    (A === void 0 || q === void 0) && _(R, this.length - 8);
    const ne = A * 2 ** 24 + this[++R] * 2 ** 16 + this[++R] * 2 ** 8 + this[++R], de = this[++R] * 2 ** 24 + this[++R] * 2 ** 16 + this[++R] * 2 ** 8 + q;
    return (BigInt(ne) << BigInt(32)) + BigInt(de);
  }), l.prototype.readIntLE = function(R, A, q) {
    R = R >>> 0, A = A >>> 0, q || le(R, A, this.length);
    let ne = this[R], de = 1, he = 0;
    for (; ++he < A && (de *= 256); )
      ne += this[R + he] * de;
    return de *= 128, ne >= de && (ne -= Math.pow(2, 8 * A)), ne;
  }, l.prototype.readIntBE = function(R, A, q) {
    R = R >>> 0, A = A >>> 0, q || le(R, A, this.length);
    let ne = A, de = 1, he = this[R + --ne];
    for (; ne > 0 && (de *= 256); )
      he += this[R + --ne] * de;
    return de *= 128, he >= de && (he -= Math.pow(2, 8 * A)), he;
  }, l.prototype.readInt8 = function(R, A) {
    return R = R >>> 0, A || le(R, 1, this.length), this[R] & 128 ? (255 - this[R] + 1) * -1 : this[R];
  }, l.prototype.readInt16LE = function(R, A) {
    R = R >>> 0, A || le(R, 2, this.length);
    const q = this[R] | this[R + 1] << 8;
    return q & 32768 ? q | 4294901760 : q;
  }, l.prototype.readInt16BE = function(R, A) {
    R = R >>> 0, A || le(R, 2, this.length);
    const q = this[R + 1] | this[R] << 8;
    return q & 32768 ? q | 4294901760 : q;
  }, l.prototype.readInt32LE = function(R, A) {
    return R = R >>> 0, A || le(R, 4, this.length), this[R] | this[R + 1] << 8 | this[R + 2] << 16 | this[R + 3] << 24;
  }, l.prototype.readInt32BE = function(R, A) {
    return R = R >>> 0, A || le(R, 4, this.length), this[R] << 24 | this[R + 1] << 16 | this[R + 2] << 8 | this[R + 3];
  }, l.prototype.readBigInt64LE = Ie(function(R) {
    R = R >>> 0, b(R, "offset");
    const A = this[R], q = this[R + 7];
    (A === void 0 || q === void 0) && _(R, this.length - 8);
    const ne = this[R + 4] + this[R + 5] * 2 ** 8 + this[R + 6] * 2 ** 16 + (q << 24);
    return (BigInt(ne) << BigInt(32)) + BigInt(A + this[++R] * 2 ** 8 + this[++R] * 2 ** 16 + this[++R] * 2 ** 24);
  }), l.prototype.readBigInt64BE = Ie(function(R) {
    R = R >>> 0, b(R, "offset");
    const A = this[R], q = this[R + 7];
    (A === void 0 || q === void 0) && _(R, this.length - 8);
    const ne = (A << 24) + // Overflow
    this[++R] * 2 ** 16 + this[++R] * 2 ** 8 + this[++R];
    return (BigInt(ne) << BigInt(32)) + BigInt(this[++R] * 2 ** 24 + this[++R] * 2 ** 16 + this[++R] * 2 ** 8 + q);
  }), l.prototype.readFloatLE = function(R, A) {
    return R = R >>> 0, A || le(R, 4, this.length), r.read(this, R, !0, 23, 4);
  }, l.prototype.readFloatBE = function(R, A) {
    return R = R >>> 0, A || le(R, 4, this.length), r.read(this, R, !1, 23, 4);
  }, l.prototype.readDoubleLE = function(R, A) {
    return R = R >>> 0, A || le(R, 8, this.length), r.read(this, R, !0, 52, 8);
  }, l.prototype.readDoubleBE = function(R, A) {
    return R = R >>> 0, A || le(R, 8, this.length), r.read(this, R, !1, 52, 8);
  };
  function ye(M, R, A, q, ne, de) {
    if (!l.isBuffer(M))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (R > ne || R < de)
      throw new RangeError('"value" argument is out of bounds');
    if (A + q > M.length)
      throw new RangeError("Index out of range");
  }
  l.prototype.writeUintLE = l.prototype.writeUIntLE = function(R, A, q, ne) {
    if (R = +R, A = A >>> 0, q = q >>> 0, !ne) {
      const Fe = Math.pow(2, 8 * q) - 1;
      ye(this, R, A, q, Fe, 0);
    }
    let de = 1, he = 0;
    for (this[A] = R & 255; ++he < q && (de *= 256); )
      this[A + he] = R / de & 255;
    return A + q;
  }, l.prototype.writeUintBE = l.prototype.writeUIntBE = function(R, A, q, ne) {
    if (R = +R, A = A >>> 0, q = q >>> 0, !ne) {
      const Fe = Math.pow(2, 8 * q) - 1;
      ye(this, R, A, q, Fe, 0);
    }
    let de = q - 1, he = 1;
    for (this[A + de] = R & 255; --de >= 0 && (he *= 256); )
      this[A + de] = R / he & 255;
    return A + q;
  }, l.prototype.writeUint8 = l.prototype.writeUInt8 = function(R, A, q) {
    return R = +R, A = A >>> 0, q || ye(this, R, A, 1, 255, 0), this[A] = R & 255, A + 1;
  }, l.prototype.writeUint16LE = l.prototype.writeUInt16LE = function(R, A, q) {
    return R = +R, A = A >>> 0, q || ye(this, R, A, 2, 65535, 0), this[A] = R & 255, this[A + 1] = R >>> 8, A + 2;
  }, l.prototype.writeUint16BE = l.prototype.writeUInt16BE = function(R, A, q) {
    return R = +R, A = A >>> 0, q || ye(this, R, A, 2, 65535, 0), this[A] = R >>> 8, this[A + 1] = R & 255, A + 2;
  }, l.prototype.writeUint32LE = l.prototype.writeUInt32LE = function(R, A, q) {
    return R = +R, A = A >>> 0, q || ye(this, R, A, 4, 4294967295, 0), this[A + 3] = R >>> 24, this[A + 2] = R >>> 16, this[A + 1] = R >>> 8, this[A] = R & 255, A + 4;
  }, l.prototype.writeUint32BE = l.prototype.writeUInt32BE = function(R, A, q) {
    return R = +R, A = A >>> 0, q || ye(this, R, A, 4, 4294967295, 0), this[A] = R >>> 24, this[A + 1] = R >>> 16, this[A + 2] = R >>> 8, this[A + 3] = R & 255, A + 4;
  };
  function H(M, R, A, q, ne) {
    V(R, q, ne, M, A, 7);
    let de = Number(R & BigInt(4294967295));
    M[A++] = de, de = de >> 8, M[A++] = de, de = de >> 8, M[A++] = de, de = de >> 8, M[A++] = de;
    let he = Number(R >> BigInt(32) & BigInt(4294967295));
    return M[A++] = he, he = he >> 8, M[A++] = he, he = he >> 8, M[A++] = he, he = he >> 8, M[A++] = he, A;
  }
  function ge(M, R, A, q, ne) {
    V(R, q, ne, M, A, 7);
    let de = Number(R & BigInt(4294967295));
    M[A + 7] = de, de = de >> 8, M[A + 6] = de, de = de >> 8, M[A + 5] = de, de = de >> 8, M[A + 4] = de;
    let he = Number(R >> BigInt(32) & BigInt(4294967295));
    return M[A + 3] = he, he = he >> 8, M[A + 2] = he, he = he >> 8, M[A + 1] = he, he = he >> 8, M[A] = he, A + 8;
  }
  l.prototype.writeBigUInt64LE = Ie(function(R, A = 0) {
    return H(this, R, A, BigInt(0), BigInt("0xffffffffffffffff"));
  }), l.prototype.writeBigUInt64BE = Ie(function(R, A = 0) {
    return ge(this, R, A, BigInt(0), BigInt("0xffffffffffffffff"));
  }), l.prototype.writeIntLE = function(R, A, q, ne) {
    if (R = +R, A = A >>> 0, !ne) {
      const ot = Math.pow(2, 8 * q - 1);
      ye(this, R, A, q, ot - 1, -ot);
    }
    let de = 0, he = 1, Fe = 0;
    for (this[A] = R & 255; ++de < q && (he *= 256); )
      R < 0 && Fe === 0 && this[A + de - 1] !== 0 && (Fe = 1), this[A + de] = (R / he >> 0) - Fe & 255;
    return A + q;
  }, l.prototype.writeIntBE = function(R, A, q, ne) {
    if (R = +R, A = A >>> 0, !ne) {
      const ot = Math.pow(2, 8 * q - 1);
      ye(this, R, A, q, ot - 1, -ot);
    }
    let de = q - 1, he = 1, Fe = 0;
    for (this[A + de] = R & 255; --de >= 0 && (he *= 256); )
      R < 0 && Fe === 0 && this[A + de + 1] !== 0 && (Fe = 1), this[A + de] = (R / he >> 0) - Fe & 255;
    return A + q;
  }, l.prototype.writeInt8 = function(R, A, q) {
    return R = +R, A = A >>> 0, q || ye(this, R, A, 1, 127, -128), R < 0 && (R = 255 + R + 1), this[A] = R & 255, A + 1;
  }, l.prototype.writeInt16LE = function(R, A, q) {
    return R = +R, A = A >>> 0, q || ye(this, R, A, 2, 32767, -32768), this[A] = R & 255, this[A + 1] = R >>> 8, A + 2;
  }, l.prototype.writeInt16BE = function(R, A, q) {
    return R = +R, A = A >>> 0, q || ye(this, R, A, 2, 32767, -32768), this[A] = R >>> 8, this[A + 1] = R & 255, A + 2;
  }, l.prototype.writeInt32LE = function(R, A, q) {
    return R = +R, A = A >>> 0, q || ye(this, R, A, 4, 2147483647, -2147483648), this[A] = R & 255, this[A + 1] = R >>> 8, this[A + 2] = R >>> 16, this[A + 3] = R >>> 24, A + 4;
  }, l.prototype.writeInt32BE = function(R, A, q) {
    return R = +R, A = A >>> 0, q || ye(this, R, A, 4, 2147483647, -2147483648), R < 0 && (R = 4294967295 + R + 1), this[A] = R >>> 24, this[A + 1] = R >>> 16, this[A + 2] = R >>> 8, this[A + 3] = R & 255, A + 4;
  }, l.prototype.writeBigInt64LE = Ie(function(R, A = 0) {
    return H(this, R, A, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), l.prototype.writeBigInt64BE = Ie(function(R, A = 0) {
    return ge(this, R, A, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Ce(M, R, A, q, ne, de) {
    if (A + q > M.length)
      throw new RangeError("Index out of range");
    if (A < 0)
      throw new RangeError("Index out of range");
  }
  function ue(M, R, A, q, ne) {
    return R = +R, A = A >>> 0, ne || Ce(M, R, A, 4), r.write(M, R, A, q, 23, 4), A + 4;
  }
  l.prototype.writeFloatLE = function(R, A, q) {
    return ue(this, R, A, !0, q);
  }, l.prototype.writeFloatBE = function(R, A, q) {
    return ue(this, R, A, !1, q);
  };
  function ee(M, R, A, q, ne) {
    return R = +R, A = A >>> 0, ne || Ce(M, R, A, 8), r.write(M, R, A, q, 52, 8), A + 8;
  }
  l.prototype.writeDoubleLE = function(R, A, q) {
    return ee(this, R, A, !0, q);
  }, l.prototype.writeDoubleBE = function(R, A, q) {
    return ee(this, R, A, !1, q);
  }, l.prototype.copy = function(R, A, q, ne) {
    if (!l.isBuffer(R))
      throw new TypeError("argument should be a Buffer");
    if (q || (q = 0), !ne && ne !== 0 && (ne = this.length), A >= R.length && (A = R.length), A || (A = 0), ne > 0 && ne < q && (ne = q), ne === q || R.length === 0 || this.length === 0)
      return 0;
    if (A < 0)
      throw new RangeError("targetStart out of bounds");
    if (q < 0 || q >= this.length)
      throw new RangeError("Index out of range");
    if (ne < 0)
      throw new RangeError("sourceEnd out of bounds");
    ne > this.length && (ne = this.length), R.length - A < ne - q && (ne = R.length - A + q);
    const de = ne - q;
    return this === R && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(A, q, ne) : Uint8Array.prototype.set.call(
      R,
      this.subarray(q, ne),
      A
    ), de;
  }, l.prototype.fill = function(R, A, q, ne) {
    if (typeof R == "string") {
      if (typeof A == "string" ? (ne = A, A = 0, q = this.length) : typeof q == "string" && (ne = q, q = this.length), ne !== void 0 && typeof ne != "string")
        throw new TypeError("encoding must be a string");
      if (typeof ne == "string" && !l.isEncoding(ne))
        throw new TypeError("Unknown encoding: " + ne);
      if (R.length === 1) {
        const he = R.charCodeAt(0);
        (ne === "utf8" && he < 128 || ne === "latin1") && (R = he);
      }
    } else
      typeof R == "number" ? R = R & 255 : typeof R == "boolean" && (R = Number(R));
    if (A < 0 || this.length < A || this.length < q)
      throw new RangeError("Out of range index");
    if (q <= A)
      return this;
    A = A >>> 0, q = q === void 0 ? this.length : q >>> 0, R || (R = 0);
    let de;
    if (typeof R == "number")
      for (de = A; de < q; ++de)
        this[de] = R;
    else {
      const he = l.isBuffer(R) ? R : l.from(R, ne), Fe = he.length;
      if (Fe === 0)
        throw new TypeError('The value "' + R + '" is invalid for argument "value"');
      for (de = 0; de < q - A; ++de)
        this[de + A] = he[de % Fe];
    }
    return this;
  };
  const be = {};
  function Te(M, R, A) {
    be[M] = class extends A {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: R.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${M}]`, this.stack, delete this.name;
      }
      get code() {
        return M;
      }
      set code(ne) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: ne,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${M}]: ${this.message}`;
      }
    };
  }
  Te(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(M) {
      return M ? `${M} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Te(
    "ERR_INVALID_ARG_TYPE",
    function(M, R) {
      return `The "${M}" argument must be of type number. Received type ${typeof R}`;
    },
    TypeError
  ), Te(
    "ERR_OUT_OF_RANGE",
    function(M, R, A) {
      let q = `The value of "${M}" is out of range.`, ne = A;
      return Number.isInteger(A) && Math.abs(A) > 2 ** 32 ? ne = Pe(String(A)) : typeof A == "bigint" && (ne = String(A), (A > BigInt(2) ** BigInt(32) || A < -(BigInt(2) ** BigInt(32))) && (ne = Pe(ne)), ne += "n"), q += ` It must be ${R}. Received ${ne}`, q;
    },
    RangeError
  );
  function Pe(M) {
    let R = "", A = M.length;
    const q = M[0] === "-" ? 1 : 0;
    for (; A >= q + 4; A -= 3)
      R = `_${M.slice(A - 3, A)}${R}`;
    return `${M.slice(0, A)}${R}`;
  }
  function K(M, R, A) {
    b(R, "offset"), (M[R] === void 0 || M[R + A] === void 0) && _(R, M.length - (A + 1));
  }
  function V(M, R, A, q, ne, de) {
    if (M > A || M < R) {
      const he = typeof R == "bigint" ? "n" : "";
      let Fe;
      throw de > 3 ? R === 0 || R === BigInt(0) ? Fe = `>= 0${he} and < 2${he} ** ${(de + 1) * 8}${he}` : Fe = `>= -(2${he} ** ${(de + 1) * 8 - 1}${he}) and < 2 ** ${(de + 1) * 8 - 1}${he}` : Fe = `>= ${R}${he} and <= ${A}${he}`, new be.ERR_OUT_OF_RANGE("value", Fe, M);
    }
    K(q, ne, de);
  }
  function b(M, R) {
    if (typeof M != "number")
      throw new be.ERR_INVALID_ARG_TYPE(R, "number", M);
  }
  function _(M, R, A) {
    throw Math.floor(M) !== M ? (b(M, A), new be.ERR_OUT_OF_RANGE(A || "offset", "an integer", M)) : R < 0 ? new be.ERR_BUFFER_OUT_OF_BOUNDS() : new be.ERR_OUT_OF_RANGE(
      A || "offset",
      `>= ${A ? 1 : 0} and <= ${R}`,
      M
    );
  }
  const T = /[^+/0-9A-Za-z-_]/g;
  function L(M) {
    if (M = M.split("=")[0], M = M.trim().replace(T, ""), M.length < 2)
      return "";
    for (; M.length % 4 !== 0; )
      M = M + "=";
    return M;
  }
  function O(M, R) {
    R = R || 1 / 0;
    let A;
    const q = M.length;
    let ne = null;
    const de = [];
    for (let he = 0; he < q; ++he) {
      if (A = M.charCodeAt(he), A > 55295 && A < 57344) {
        if (!ne) {
          if (A > 56319) {
            (R -= 3) > -1 && de.push(239, 191, 189);
            continue;
          } else if (he + 1 === q) {
            (R -= 3) > -1 && de.push(239, 191, 189);
            continue;
          }
          ne = A;
          continue;
        }
        if (A < 56320) {
          (R -= 3) > -1 && de.push(239, 191, 189), ne = A;
          continue;
        }
        A = (ne - 55296 << 10 | A - 56320) + 65536;
      } else
        ne && (R -= 3) > -1 && de.push(239, 191, 189);
      if (ne = null, A < 128) {
        if ((R -= 1) < 0)
          break;
        de.push(A);
      } else if (A < 2048) {
        if ((R -= 2) < 0)
          break;
        de.push(
          A >> 6 | 192,
          A & 63 | 128
        );
      } else if (A < 65536) {
        if ((R -= 3) < 0)
          break;
        de.push(
          A >> 12 | 224,
          A >> 6 & 63 | 128,
          A & 63 | 128
        );
      } else if (A < 1114112) {
        if ((R -= 4) < 0)
          break;
        de.push(
          A >> 18 | 240,
          A >> 12 & 63 | 128,
          A >> 6 & 63 | 128,
          A & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return de;
  }
  function ie(M) {
    const R = [];
    for (let A = 0; A < M.length; ++A)
      R.push(M.charCodeAt(A) & 255);
    return R;
  }
  function fe(M, R) {
    let A, q, ne;
    const de = [];
    for (let he = 0; he < M.length && !((R -= 2) < 0); ++he)
      A = M.charCodeAt(he), q = A >> 8, ne = A % 256, de.push(ne), de.push(q);
    return de;
  }
  function se(M) {
    return t.toByteArray(L(M));
  }
  function ve(M, R, A, q) {
    let ne;
    for (ne = 0; ne < q && !(ne + A >= R.length || ne >= M.length); ++ne)
      R[ne + A] = M[ne];
    return ne;
  }
  function B(M, R) {
    return M instanceof R || M != null && M.constructor != null && M.constructor.name != null && M.constructor.name === R.name;
  }
  function me(M) {
    return M !== M;
  }
  const ke = function() {
    const M = "0123456789abcdef", R = new Array(256);
    for (let A = 0; A < 16; ++A) {
      const q = A * 16;
      for (let ne = 0; ne < 16; ++ne)
        R[q + ne] = M[A] + M[ne];
    }
    return R;
  }();
  function Ie(M) {
    return typeof BigInt > "u" ? Me : M;
  }
  function Me() {
    throw new Error("BigInt not supported");
  }
})(ft);
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let xT;
var hY = typeof queueMicrotask == "function" ? queueMicrotask.bind(window) : (e) => (xT || (xT = Promise.resolve())).then(e).catch((t) => setTimeout(() => {
  throw t;
}, 0));
const pY = /* @__PURE__ */ Tn(hY), Mu = "http://www.w3.org/1999/02/22-rdf-syntax-ns#", Ou = "http://www.w3.org/2001/XMLSchema#", Ab = "http://www.w3.org/2000/10/swap/", fi = {
  xsd: {
    decimal: `${Ou}decimal`,
    boolean: `${Ou}boolean`,
    double: `${Ou}double`,
    integer: `${Ou}integer`,
    string: `${Ou}string`
  },
  rdf: {
    type: `${Mu}type`,
    nil: `${Mu}nil`,
    first: `${Mu}first`,
    rest: `${Mu}rest`,
    langString: `${Mu}langString`
  },
  owl: {
    sameAs: "http://www.w3.org/2002/07/owl#sameAs"
  },
  r: {
    forSome: `${Ab}reify#forSome`,
    forAll: `${Ab}reify#forAll`
  },
  log: {
    implies: `${Ab}log#implies`
  }
}, { xsd: Xc } = fi, gY = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\([^])/g, RT = {
  "\\": "\\",
  "'": "'",
  '"': '"',
  n: `
`,
  r: "\r",
  t: "	",
  f: "\f",
  b: "\b",
  _: "_",
  "~": "~",
  ".": ".",
  "-": "-",
  "!": "!",
  $: "$",
  "&": "&",
  "(": "(",
  ")": ")",
  "*": "*",
  "+": "+",
  ",": ",",
  ";": ";",
  "=": "=",
  "/": "/",
  "?": "?",
  "#": "#",
  "@": "@",
  "%": "%"
}, bY = /[\x00-\x20<>\\"\{\}\|\^\`]/, yY = {
  _iri: !0,
  _unescapedIri: !0,
  _simpleQuotedString: !0,
  _langcode: !0,
  _blank: !0,
  _newline: !0,
  _comment: !0,
  _whitespace: !0,
  _endOfFile: !0
}, vY = /$0^/;
class mY {
  constructor(t) {
    if (this._iri = /^<((?:[^ <>{}\\]|\\[uU])+)>[ \t]*/, this._unescapedIri = /^<([^\x00-\x20<>\\"\{\}\|\^\`]*)>[ \t]*/, this._simpleQuotedString = /^"([^"\\\r\n]*)"(?=[^"])/, this._simpleApostropheString = /^'([^'\\\r\n]*)'(?=[^'])/, this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\-])/i, this._prefix = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:(?=[#\s<])/, this._prefixed = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:((?:(?:[0-:A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])(?:(?:[\.\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])*(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~]))?)?)(?:[ \t]+|(?=\.?[,;!\^\s#()\[\]\{\}"'<>]))/, this._variable = /^\?(?:(?:[A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?=[.,;!\^\s#()\[\]\{\}"'<>])/, this._blank = /^_:((?:[0-9A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?:[ \t]+|(?=\.?[,;:\s#()\[\]\{\}"'<>]))/, this._number = /^[\-+]?(?:(\d+\.\d*|\.?\d+)[eE][\-+]?|\d*(\.)?)\d+(?=\.?[,;:\s#()\[\]\{\}"'<>])/, this._boolean = /^(?:true|false)(?=[.,;\s#()\[\]\{\}"'<>])/, this._keyword = /^@[a-z]+(?=[\s#<:])/i, this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\s#<])/i, this._shortPredicates = /^a(?=[\s#()\[\]\{\}"'<>])/, this._newline = /^[ \t]*(?:#[^\n\r]*)?(?:\r\n|\n|\r)[ \t]*/, this._comment = /#([^\n\r]*)/, this._whitespace = /^[ \t]+/, this._endOfFile = /^(?:#[^\n\r]*)?$/, t = t || {}, this._lineMode = !!t.lineMode) {
      this._n3Mode = !1;
      for (const r in this)
        !(r in yY) && this[r] instanceof RegExp && (this[r] = vY);
    } else
      this._n3Mode = t.n3 !== !1;
    this._comments = !!t.comments, this._literalClosingPos = 0;
  }
  // ## Private methods
  // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback
  _tokenizeToEnd(t, r) {
    let n = this._input, o = n.length;
    for (; ; ) {
      let l, u;
      for (; l = this._newline.exec(n); )
        this._comments && (u = this._comment.exec(l[0])) && s("comment", u[1], "", this._line, l[0].length), n = n.substr(l[0].length, n.length), o = n.length, this._line++;
      if (!l && (l = this._whitespace.exec(n)) && (n = n.substr(l[0].length, n.length)), this._endOfFile.test(n))
        return r && (this._comments && (u = this._comment.exec(n)) && s("comment", u[1], "", this._line, n.length), n = null, s("eof", "", "", this._line, 0)), this._input = n;
      const f = this._line, c = n[0];
      let d = "", h = "", p = "", v = null, y = 0, w = !1;
      switch (c) {
        case "^":
          if (n.length < 3)
            break;
          if (n[1] === "^") {
            if (this._previousMarker = "^^", n = n.substr(2), n[0] !== "<") {
              w = !0;
              break;
            }
          } else {
            this._n3Mode && (y = 1, d = "^");
            break;
          }
        case "<":
          if (v = this._unescapedIri.exec(n))
            d = "IRI", h = v[1];
          else if (v = this._iri.exec(n)) {
            if (h = this._unescape(v[1]), h === null || bY.test(h))
              return a(this);
            d = "IRI";
          } else
            n.length > 1 && n[1] === "<" ? (d = "<<", y = 2) : this._n3Mode && n.length > 1 && n[1] === "=" && (d = "inverse", y = 2, h = ">");
          break;
        case ">":
          n.length > 1 && n[1] === ">" && (d = ">>", y = 2);
          break;
        case "_":
          ((v = this._blank.exec(n)) || r && (v = this._blank.exec(`${n} `))) && (d = "blank", p = "_", h = v[1]);
          break;
        case '"':
          if (v = this._simpleQuotedString.exec(n))
            h = v[1];
          else if ({ value: h, matchLength: y } = this._parseLiteral(n), h === null)
            return a(this);
          (v !== null || y !== 0) && (d = "literal", this._literalClosingPos = 0);
          break;
        case "'":
          if (!this._lineMode) {
            if (v = this._simpleApostropheString.exec(n))
              h = v[1];
            else if ({ value: h, matchLength: y } = this._parseLiteral(n), h === null)
              return a(this);
            (v !== null || y !== 0) && (d = "literal", this._literalClosingPos = 0);
          }
          break;
        case "?":
          this._n3Mode && (v = this._variable.exec(n)) && (d = "var", h = v[0]);
          break;
        case "@":
          this._previousMarker === "literal" && (v = this._langcode.exec(n)) ? (d = "langcode", h = v[1]) : (v = this._keyword.exec(n)) && (d = v[0]);
          break;
        case ".":
          if (n.length === 1 ? r : n[1] < "0" || n[1] > "9") {
            d = ".", y = 1;
            break;
          }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        case "+":
        case "-":
          (v = this._number.exec(n) || r && (v = this._number.exec(`${n} `))) && (d = "literal", h = v[0], p = typeof v[1] == "string" ? Xc.double : typeof v[2] == "string" ? Xc.decimal : Xc.integer);
          break;
        case "B":
        case "b":
        case "p":
        case "P":
        case "G":
        case "g":
          (v = this._sparqlKeyword.exec(n)) ? d = v[0].toUpperCase() : w = !0;
          break;
        case "f":
        case "t":
          (v = this._boolean.exec(n)) ? (d = "literal", h = v[0], p = Xc.boolean) : w = !0;
          break;
        case "a":
          (v = this._shortPredicates.exec(n)) ? (d = "abbreviation", h = "a") : w = !0;
          break;
        case "=":
          this._n3Mode && n.length > 1 && (d = "abbreviation", n[1] !== ">" ? (y = 1, h = "=") : (y = 2, h = ">"));
          break;
        case "!":
          if (!this._n3Mode)
            break;
        case ",":
        case ";":
        case "[":
        case "]":
        case "(":
        case ")":
        case "}":
          this._lineMode || (y = 1, d = c);
          break;
        case "{":
          !this._lineMode && n.length >= 2 && (n[1] === "|" ? (d = "{|", y = 2) : (d = c, y = 1));
          break;
        case "|":
          n.length >= 2 && n[1] === "}" && (d = "|}", y = 2);
          break;
        default:
          w = !0;
      }
      if (w && ((this._previousMarker === "@prefix" || this._previousMarker === "PREFIX") && (v = this._prefix.exec(n)) ? (d = "prefix", h = v[1] || "") : ((v = this._prefixed.exec(n)) || r && (v = this._prefixed.exec(`${n} `))) && (d = "prefixed", p = v[1] || "", h = this._unescape(v[2]))), this._previousMarker === "^^")
        switch (d) {
          case "prefixed":
            d = "type";
            break;
          case "IRI":
            d = "typeIRI";
            break;
          default:
            d = "";
        }
      if (!d)
        return r || !/^'''|^"""/.test(n) && /\n|\r/.test(n) ? a(this) : this._input = n;
      const S = y || v[0].length, x = s(d, h, p, f, S);
      this.previousToken = x, this._previousMarker = d, n = n.substr(S, n.length);
    }
    function s(l, u, f, c, d) {
      const h = n ? o - n.length : o, p = h + d, v = { type: l, value: u, prefix: f, line: c, start: h, end: p };
      return t(null, v), v;
    }
    function a(l) {
      t(l._syntaxError(/^\S*/.exec(n)[0]));
    }
  }
  // ### `_unescape` replaces N3 escape codes by their corresponding characters
  _unescape(t) {
    let r = !1;
    const n = t.replace(gY, (o, s, a, l) => {
      if (typeof s == "string")
        return String.fromCharCode(Number.parseInt(s, 16));
      if (typeof a == "string") {
        let u = Number.parseInt(a, 16);
        return u <= 65535 ? String.fromCharCode(Number.parseInt(a, 16)) : String.fromCharCode(55296 + ((u -= 65536) >> 10), 56320 + (u & 1023));
      }
      return l in RT ? RT[l] : (r = !0, "");
    });
    return r ? null : n;
  }
  // ### `_parseLiteral` parses a literal into an unescaped value
  _parseLiteral(t) {
    if (t.length >= 3) {
      const r = t.match(/^(?:"""|"|'''|'|)/)[0], n = r.length;
      let o = Math.max(this._literalClosingPos, n);
      for (; (o = t.indexOf(r, o)) > 0; ) {
        let s = 0;
        for (; t[o - s - 1] === "\\"; )
          s++;
        if (s % 2 === 0) {
          const a = t.substring(n, o), l = a.split(/\r\n|\r|\n/).length - 1, u = o + n;
          if (n === 1 && l !== 0 || n === 3 && this._lineMode)
            break;
          return this._line += l, { value: this._unescape(a), matchLength: u };
        }
        o++;
      }
      this._literalClosingPos = t.length - n + 1;
    }
    return { value: "", matchLength: 0 };
  }
  // ### `_syntaxError` creates a syntax error for the given issue
  _syntaxError(t) {
    this._input = null;
    const r = new Error(`Unexpected "${t}" on line ${this._line}.`);
    return r.context = {
      token: void 0,
      line: this._line,
      previousToken: this.previousToken
    }, r;
  }
  // ### Strips off any starting UTF BOM mark.
  _readStartingBom(t) {
    return t.startsWith("\uFEFF") ? t.substr(1) : t;
  }
  // ## Public methods
  // ### `tokenize` starts the transformation of an N3 document into an array of tokens.
  // The input can be a string or a stream.
  tokenize(t, r) {
    if (this._line = 1, typeof t == "string")
      if (this._input = this._readStartingBom(t), typeof r == "function")
        pY(() => this._tokenizeToEnd(r, !0));
      else {
        const n = [];
        let o;
        if (this._tokenizeToEnd((s, a) => s ? o = s : n.push(a), !0), o)
          throw o;
        return n;
      }
    else
      this._pendingBuffer = null, typeof t.setEncoding == "function" && t.setEncoding("utf8"), t.on("data", (n) => {
        this._input !== null && n.length !== 0 && (this._pendingBuffer && (n = ft.Buffer.concat([this._pendingBuffer, n]), this._pendingBuffer = null), n[n.length - 1] & 128 ? this._pendingBuffer = n : (typeof this._input > "u" ? this._input = this._readStartingBom(typeof n == "string" ? n : n.toString()) : this._input += n, this._tokenizeToEnd(r, !1)));
      }), t.on("end", () => {
        typeof this._input == "string" && this._tokenizeToEnd(r, !0);
      }), t.on("error", r);
  }
}
const { rdf: _Y, xsd: gl } = fi;
let Sp, wY = 0;
const SY = {
  namedNode: $Y,
  blankNode: NY,
  variable: CY,
  literal: kY,
  defaultGraph: IY,
  quad: AT,
  triple: AT
}, EY = SY;
class ys {
  constructor(t) {
    this.id = t;
  }
  // ### The value of this term
  get value() {
    return this.id;
  }
  // ### Returns whether this object represents the same term as the other
  equals(t) {
    return t instanceof ys ? this.id === t.id : !!t && this.termType === t.termType && this.value === t.value;
  }
  // ### Implement hashCode for Immutable.js, since we implement `equals`
  // https://immutable-js.com/docs/v4.0.0/ValueObject/#hashCode()
  hashCode() {
    return 0;
  }
  // ### Returns a plain object representation of this term
  toJSON() {
    return {
      termType: this.termType,
      value: this.value
    };
  }
}
let M3 = class extends ys {
  // ### The term type of this term
  get termType() {
    return "NamedNode";
  }
};
class wf extends ys {
  // ### The term type of this term
  get termType() {
    return "Literal";
  }
  // ### The text value of this literal
  get value() {
    return this.id.substring(1, this.id.lastIndexOf('"'));
  }
  // ### The language of this literal
  get language() {
    const t = this.id;
    let r = t.lastIndexOf('"') + 1;
    return r < t.length && t[r++] === "@" ? t.substr(r).toLowerCase() : "";
  }
  // ### The datatype IRI of this literal
  get datatype() {
    return new M3(this.datatypeString);
  }
  // ### The datatype string of this literal
  get datatypeString() {
    const t = this.id, r = t.lastIndexOf('"') + 1, n = r < t.length ? t[r] : "";
    return n === "^" ? t.substr(r + 2) : (
      // If "@" follows, return rdf:langString; xsd:string otherwise
      n !== "@" ? gl.string : _Y.langString
    );
  }
  // ### Returns whether this object represents the same term as the other
  equals(t) {
    return t instanceof wf ? this.id === t.id : !!t && !!t.datatype && this.termType === t.termType && this.value === t.value && this.language === t.language && this.datatype.value === t.datatype.value;
  }
  toJSON() {
    return {
      termType: this.termType,
      value: this.value,
      language: this.language,
      datatype: { termType: "NamedNode", value: this.datatypeString }
    };
  }
}
let xY = class extends ys {
  constructor(t) {
    super(`_:${t}`);
  }
  // ### The term type of this term
  get termType() {
    return "BlankNode";
  }
  // ### The name of this blank node
  get value() {
    return this.id.substr(2);
  }
}, RY = class extends ys {
  constructor(t) {
    super(`?${t}`);
  }
  // ### The term type of this term
  get termType() {
    return "Variable";
  }
  // ### The name of this variable
  get value() {
    return this.id.substr(1);
  }
}, AY = class extends ys {
  constructor() {
    return super(""), Sp || this;
  }
  // ### The term type of this term
  get termType() {
    return "DefaultGraph";
  }
  // ### Returns whether this object represents the same term as the other
  equals(t) {
    return this === t || !!t && this.termType === t.termType;
  }
};
Sp = new AY();
let TY = class extends ys {
  constructor(t, r, n, o) {
    super(""), this._subject = t, this._predicate = r, this._object = n, this._graph = o || Sp;
  }
  // ### The term type of this term
  get termType() {
    return "Quad";
  }
  get subject() {
    return this._subject;
  }
  get predicate() {
    return this._predicate;
  }
  get object() {
    return this._object;
  }
  get graph() {
    return this._graph;
  }
  // ### Returns a plain object representation of this quad
  toJSON() {
    return {
      termType: this.termType,
      subject: this._subject.toJSON(),
      predicate: this._predicate.toJSON(),
      object: this._object.toJSON(),
      graph: this._graph.toJSON()
    };
  }
  // ### Returns whether this object represents the same quad as the other
  equals(t) {
    return !!t && this._subject.equals(t.subject) && this._predicate.equals(t.predicate) && this._object.equals(t.object) && this._graph.equals(t.graph);
  }
};
function $Y(e) {
  return new M3(e);
}
function NY(e) {
  return new xY(e || `n3-${wY++}`);
}
function kY(e, t) {
  if (typeof t == "string")
    return new wf(`"${e}"@${t.toLowerCase()}`);
  let r = t ? t.value : "";
  return r === "" && (typeof e == "boolean" ? r = gl.boolean : typeof e == "number" && (Number.isFinite(e) ? r = Number.isInteger(e) ? gl.integer : gl.double : (r = gl.double, Number.isNaN(e) || (e = e > 0 ? "INF" : "-INF")))), r === "" || r === gl.string ? new wf(`"${e}"`) : new wf(`"${e}"^^${r}`);
}
function CY(e) {
  return new RY(e);
}
function IY() {
  return Sp;
}
function AT(e, t, r, n) {
  return new TY(e, t, r, n);
}
let TT = 0, O3 = class {
  constructor(t) {
    this._contextStack = [], this._graph = null, t = t || {}, this._setBase(t.baseIRI), t.factory && L3(this, t.factory);
    const r = typeof t.format == "string" ? t.format.match(/\w*$/)[0].toLowerCase() : "", n = /turtle/.test(r), o = /trig/.test(r), s = /triple/.test(r), a = /quad/.test(r), l = this._n3Mode = /n3/.test(r), u = s || a;
    (this._supportsNamedGraphs = !(n || l)) || (this._readPredicateOrNamedGraph = this._readPredicate), this._supportsQuads = !(n || o || s || l), this._supportsRDFStar = r === "" || /star|\*$/.test(r), u && (this._resolveRelativeIRI = (f) => null), this._blankNodePrefix = typeof t.blankNodePrefix != "string" ? "" : t.blankNodePrefix.replace(/^(?!_:)/, "_:"), this._lexer = t.lexer || new mY({ lineMode: u, n3: l }), this._explicitQuantifiers = !!t.explicitQuantifiers;
  }
  // ## Static class methods
  // ### `_resetBlankNodePrefix` restarts blank node prefix identification
  static _resetBlankNodePrefix() {
    TT = 0;
  }
  // ## Private methods
  // ### `_setBase` sets the base IRI to resolve relative IRIs
  _setBase(t) {
    if (!t)
      this._base = "", this._basePath = "";
    else {
      const r = t.indexOf("#");
      r >= 0 && (t = t.substr(0, r)), this._base = t, this._basePath = t.indexOf("/") < 0 ? t : t.replace(/[^\/?]*(?:\?.*)?$/, ""), t = t.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\/\/[^\/]*)?/i), this._baseRoot = t[0], this._baseScheme = t[1];
    }
  }
  // ### `_saveContext` stores the current parsing context
  // when entering a new scope (list, blank node, formula)
  _saveContext(t, r, n, o, s) {
    const a = this._n3Mode;
    this._contextStack.push({
      type: t,
      subject: n,
      predicate: o,
      object: s,
      graph: r,
      inverse: a ? this._inversePredicate : !1,
      blankPrefix: a ? this._prefixes._ : "",
      quantified: a ? this._quantified : null
    }), a && (this._inversePredicate = !1, this._prefixes._ = this._graph ? `${this._graph.value}.` : ".", this._quantified = Object.create(this._quantified));
  }
  // ### `_restoreContext` restores the parent context
  // when leaving a scope (list, blank node, formula)
  _restoreContext(t, r) {
    const n = this._contextStack.pop();
    if (!n || n.type !== t)
      return this._error(`Unexpected ${r.type}`, r);
    this._subject = n.subject, this._predicate = n.predicate, this._object = n.object, this._graph = n.graph, this._n3Mode && (this._inversePredicate = n.inverse, this._prefixes._ = n.blankPrefix, this._quantified = n.quantified);
  }
  // ### `_readInTopContext` reads a token when in the top context
  _readInTopContext(t) {
    switch (t.type) {
      case "eof":
        return this._graph !== null ? this._error("Unclosed graph", t) : (delete this._prefixes._, this._callback(null, null, this._prefixes));
      case "PREFIX":
        this._sparqlStyle = !0;
      case "@prefix":
        return this._readPrefix;
      case "BASE":
        this._sparqlStyle = !0;
      case "@base":
        return this._readBaseIRI;
      case "{":
        if (this._supportsNamedGraphs)
          return this._graph = "", this._subject = null, this._readSubject;
      case "GRAPH":
        if (this._supportsNamedGraphs)
          return this._readNamedGraphLabel;
      default:
        return this._readSubject(t);
    }
  }
  // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable
  _readEntity(t, r) {
    let n;
    switch (t.type) {
      case "IRI":
      case "typeIRI":
        const o = this._resolveIRI(t.value);
        if (o === null)
          return this._error("Invalid IRI", t);
        n = this._namedNode(o);
        break;
      case "type":
      case "prefixed":
        const s = this._prefixes[t.prefix];
        if (s === void 0)
          return this._error(`Undefined prefix "${t.prefix}:"`, t);
        n = this._namedNode(s + t.value);
        break;
      case "blank":
        n = this._blankNode(this._prefixes[t.prefix] + t.value);
        break;
      case "var":
        n = this._variable(t.value.substr(1));
        break;
      default:
        return this._error(`Expected entity but got ${t.type}`, t);
    }
    return !r && this._n3Mode && n.id in this._quantified && (n = this._quantified[n.id]), n;
  }
  // ### `_readSubject` reads a quad's subject
  _readSubject(t) {
    switch (this._predicate = null, t.type) {
      case "[":
        return this._saveContext(
          "blank",
          this._graph,
          this._subject = this._blankNode(),
          null,
          null
        ), this._readBlankNodeHead;
      case "(":
        return this._saveContext("list", this._graph, this.RDF_NIL, null, null), this._subject = null, this._readListItem;
      case "{":
        return this._n3Mode ? (this._saveContext(
          "formula",
          this._graph,
          this._graph = this._blankNode(),
          null,
          null
        ), this._readSubject) : this._error("Unexpected graph", t);
      case "}":
        return this._readPunctuation(t);
      case "@forSome":
        return this._n3Mode ? (this._subject = null, this._predicate = this.N3_FORSOME, this._quantifier = this._blankNode, this._readQuantifierList) : this._error('Unexpected "@forSome"', t);
      case "@forAll":
        return this._n3Mode ? (this._subject = null, this._predicate = this.N3_FORALL, this._quantifier = this._variable, this._readQuantifierList) : this._error('Unexpected "@forAll"', t);
      case "literal":
        if (!this._n3Mode)
          return this._error("Unexpected literal", t);
        if (t.prefix.length === 0)
          return this._literalValue = t.value, this._completeSubjectLiteral;
        this._subject = this._literal(t.value, this._namedNode(t.prefix));
        break;
      case "<<":
        return this._supportsRDFStar ? (this._saveContext("<<", this._graph, null, null, null), this._graph = null, this._readSubject) : this._error("Unexpected RDF* syntax", t);
      default:
        if ((this._subject = this._readEntity(t)) === void 0)
          return;
        if (this._n3Mode)
          return this._getPathReader(this._readPredicateOrNamedGraph);
    }
    return this._readPredicateOrNamedGraph;
  }
  // ### `_readPredicate` reads a quad's predicate
  _readPredicate(t) {
    const r = t.type;
    switch (r) {
      case "inverse":
        this._inversePredicate = !0;
      case "abbreviation":
        this._predicate = this.ABBREVIATIONS[t.value];
        break;
      case ".":
      case "]":
      case "}":
        return this._predicate === null ? this._error(`Unexpected ${r}`, t) : (this._subject = null, r === "]" ? this._readBlankNodeTail(t) : this._readPunctuation(t));
      case ";":
        return this._predicate !== null ? this._readPredicate : this._error("Expected predicate but got ;", t);
      case "[":
        if (this._n3Mode)
          return this._saveContext(
            "blank",
            this._graph,
            this._subject,
            this._subject = this._blankNode(),
            null
          ), this._readBlankNodeHead;
      case "blank":
        if (!this._n3Mode)
          return this._error("Disallowed blank node as predicate", t);
      default:
        if ((this._predicate = this._readEntity(t)) === void 0)
          return;
    }
    return this._readObject;
  }
  // ### `_readObject` reads a quad's object
  _readObject(t) {
    switch (t.type) {
      case "literal":
        if (t.prefix.length === 0)
          return this._literalValue = t.value, this._readDataTypeOrLang;
        this._object = this._literal(t.value, this._namedNode(t.prefix));
        break;
      case "[":
        return this._saveContext(
          "blank",
          this._graph,
          this._subject,
          this._predicate,
          this._subject = this._blankNode()
        ), this._readBlankNodeHead;
      case "(":
        return this._saveContext("list", this._graph, this._subject, this._predicate, this.RDF_NIL), this._subject = null, this._readListItem;
      case "{":
        return this._n3Mode ? (this._saveContext(
          "formula",
          this._graph,
          this._subject,
          this._predicate,
          this._graph = this._blankNode()
        ), this._readSubject) : this._error("Unexpected graph", t);
      case "<<":
        return this._supportsRDFStar ? (this._saveContext("<<", this._graph, this._subject, this._predicate, null), this._graph = null, this._readSubject) : this._error("Unexpected RDF* syntax", t);
      default:
        if ((this._object = this._readEntity(t)) === void 0)
          return;
        if (this._n3Mode)
          return this._getPathReader(this._getContextEndReader());
    }
    return this._getContextEndReader();
  }
  // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph
  _readPredicateOrNamedGraph(t) {
    return t.type === "{" ? this._readGraph(t) : this._readPredicate(t);
  }
  // ### `_readGraph` reads a graph
  _readGraph(t) {
    return t.type !== "{" ? this._error(`Expected graph but got ${t.type}`, t) : (this._graph = this._subject, this._subject = null, this._readSubject);
  }
  // ### `_readBlankNodeHead` reads the head of a blank node
  _readBlankNodeHead(t) {
    return t.type === "]" ? (this._subject = null, this._readBlankNodeTail(t)) : (this._predicate = null, this._readPredicate(t));
  }
  // ### `_readBlankNodeTail` reads the end of a blank node
  _readBlankNodeTail(t) {
    if (t.type !== "]")
      return this._readBlankNodePunctuation(t);
    this._subject !== null && this._emit(this._subject, this._predicate, this._object, this._graph);
    const r = this._predicate === null;
    return this._restoreContext("blank", t), this._object !== null ? this._getContextEndReader() : this._predicate !== null ? this._readObject : r ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank;
  }
  // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node
  _readPredicateAfterBlank(t) {
    switch (t.type) {
      case ".":
      case "}":
        return this._subject = null, this._readPunctuation(t);
      default:
        return this._readPredicate(t);
    }
  }
  // ### `_readListItem` reads items from a list
  _readListItem(t) {
    let r = null, n = null, o = this._readListItem;
    const s = this._subject, a = this._contextStack, l = a[a.length - 1];
    switch (t.type) {
      case "[":
        this._saveContext(
          "blank",
          this._graph,
          n = this._blankNode(),
          this.RDF_FIRST,
          this._subject = r = this._blankNode()
        ), o = this._readBlankNodeHead;
        break;
      case "(":
        this._saveContext(
          "list",
          this._graph,
          n = this._blankNode(),
          this.RDF_FIRST,
          this.RDF_NIL
        ), this._subject = null;
        break;
      case ")":
        if (this._restoreContext("list", t), a.length !== 0 && a[a.length - 1].type === "list" && this._emit(this._subject, this._predicate, this._object, this._graph), this._predicate === null) {
          if (o = this._readPredicate, this._subject === this.RDF_NIL)
            return o;
        } else if (o = this._getContextEndReader(), this._object === this.RDF_NIL)
          return o;
        n = this.RDF_NIL;
        break;
      case "literal":
        t.prefix.length === 0 ? (this._literalValue = t.value, o = this._readListItemDataTypeOrLang) : (r = this._literal(t.value, this._namedNode(t.prefix)), o = this._getContextEndReader());
        break;
      case "{":
        return this._n3Mode ? (this._saveContext(
          "formula",
          this._graph,
          this._subject,
          this._predicate,
          this._graph = this._blankNode()
        ), this._readSubject) : this._error("Unexpected graph", t);
      default:
        if ((r = this._readEntity(t)) === void 0)
          return;
    }
    if (n === null && (this._subject = n = this._blankNode()), s === null ? l.predicate === null ? l.subject = n : l.object = n : this._emit(s, this.RDF_REST, n, this._graph), r !== null) {
      if (this._n3Mode && (t.type === "IRI" || t.type === "prefixed"))
        return this._saveContext("item", this._graph, n, this.RDF_FIRST, r), this._subject = r, this._predicate = null, this._getPathReader(this._readListItem);
      this._emit(n, this.RDF_FIRST, r, this._graph);
    }
    return o;
  }
  // ### `_readDataTypeOrLang` reads an _optional_ datatype or language
  _readDataTypeOrLang(t) {
    return this._completeObjectLiteral(t, !1);
  }
  // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list
  _readListItemDataTypeOrLang(t) {
    return this._completeObjectLiteral(t, !0);
  }
  // ### `_completeLiteral` completes a literal with an optional datatype or language
  _completeLiteral(t) {
    let r = this._literal(this._literalValue);
    switch (t.type) {
      case "type":
      case "typeIRI":
        const n = this._readEntity(t);
        if (n === void 0)
          return;
        r = this._literal(this._literalValue, n), t = null;
        break;
      case "langcode":
        r = this._literal(this._literalValue, t.value), t = null;
        break;
    }
    return { token: t, literal: r };
  }
  // Completes a literal in subject position
  _completeSubjectLiteral(t) {
    return this._subject = this._completeLiteral(t).literal, this._readPredicateOrNamedGraph;
  }
  // Completes a literal in object position
  _completeObjectLiteral(t, r) {
    const n = this._completeLiteral(t);
    if (n)
      return this._object = n.literal, r && this._emit(this._subject, this.RDF_FIRST, this._object, this._graph), n.token === null ? this._getContextEndReader() : (this._readCallback = this._getContextEndReader(), this._readCallback(n.token));
  }
  // ### `_readFormulaTail` reads the end of a formula
  _readFormulaTail(t) {
    return t.type !== "}" ? this._readPunctuation(t) : (this._subject !== null && this._emit(this._subject, this._predicate, this._object, this._graph), this._restoreContext("formula", t), this._object === null ? this._readPredicate : this._getContextEndReader());
  }
  // ### `_readPunctuation` reads punctuation between quads or quad parts
  _readPunctuation(t) {
    let r, n = this._graph;
    const o = this._subject, s = this._inversePredicate;
    switch (t.type) {
      case "}":
        if (this._graph === null)
          return this._error("Unexpected graph closing", t);
        if (this._n3Mode)
          return this._readFormulaTail(t);
        this._graph = null;
      case ".":
        this._subject = null, r = this._contextStack.length ? this._readSubject : this._readInTopContext, s && (this._inversePredicate = !1);
        break;
      case ";":
        r = this._readPredicate;
        break;
      case ",":
        r = this._readObject;
        break;
      case "{|":
        if (!this._supportsRDFStar)
          return this._error("Unexpected RDF* syntax", t);
        const a = this._predicate, l = this._object;
        this._subject = this._quad(o, a, l, this.DEFAULTGRAPH), r = this._readPredicate;
        break;
      case "|}":
        if (this._subject.termType !== "Quad")
          return this._error("Unexpected asserted triple closing", t);
        this._subject = null, r = this._readPunctuation;
        break;
      default:
        if (this._supportsQuads && this._graph === null && (n = this._readEntity(t)) !== void 0) {
          r = this._readQuadPunctuation;
          break;
        }
        return this._error(`Expected punctuation to follow "${this._object.id}"`, t);
    }
    if (o !== null) {
      const a = this._predicate, l = this._object;
      s ? this._emit(l, a, o, n) : this._emit(o, a, l, n);
    }
    return r;
  }
  // ### `_readBlankNodePunctuation` reads punctuation in a blank node
  _readBlankNodePunctuation(t) {
    let r;
    switch (t.type) {
      case ";":
        r = this._readPredicate;
        break;
      case ",":
        r = this._readObject;
        break;
      default:
        return this._error(`Expected punctuation to follow "${this._object.id}"`, t);
    }
    return this._emit(this._subject, this._predicate, this._object, this._graph), r;
  }
  // ### `_readQuadPunctuation` reads punctuation after a quad
  _readQuadPunctuation(t) {
    return t.type !== "." ? this._error("Expected dot to follow quad", t) : this._readInTopContext;
  }
  // ### `_readPrefix` reads the prefix of a prefix declaration
  _readPrefix(t) {
    return t.type !== "prefix" ? this._error("Expected prefix to follow @prefix", t) : (this._prefix = t.value, this._readPrefixIRI);
  }
  // ### `_readPrefixIRI` reads the IRI of a prefix declaration
  _readPrefixIRI(t) {
    if (t.type !== "IRI")
      return this._error(`Expected IRI to follow prefix "${this._prefix}:"`, t);
    const r = this._readEntity(t);
    return this._prefixes[this._prefix] = r.value, this._prefixCallback(this._prefix, r), this._readDeclarationPunctuation;
  }
  // ### `_readBaseIRI` reads the IRI of a base declaration
  _readBaseIRI(t) {
    const r = t.type === "IRI" && this._resolveIRI(t.value);
    return r ? (this._setBase(r), this._readDeclarationPunctuation) : this._error("Expected valid IRI to follow base declaration", t);
  }
  // ### `_readNamedGraphLabel` reads the label of a named graph
  _readNamedGraphLabel(t) {
    switch (t.type) {
      case "IRI":
      case "blank":
      case "prefixed":
        return this._readSubject(t), this._readGraph;
      case "[":
        return this._readNamedGraphBlankLabel;
      default:
        return this._error("Invalid graph label", t);
    }
  }
  // ### `_readNamedGraphLabel` reads a blank node label of a named graph
  _readNamedGraphBlankLabel(t) {
    return t.type !== "]" ? this._error("Invalid graph label", t) : (this._subject = this._blankNode(), this._readGraph);
  }
  // ### `_readDeclarationPunctuation` reads the punctuation of a declaration
  _readDeclarationPunctuation(t) {
    return this._sparqlStyle ? (this._sparqlStyle = !1, this._readInTopContext(t)) : t.type !== "." ? this._error("Expected declaration to end with a dot", t) : this._readInTopContext;
  }
  // Reads a list of quantified symbols from a @forSome or @forAll statement
  _readQuantifierList(t) {
    let r;
    switch (t.type) {
      case "IRI":
      case "prefixed":
        if ((r = this._readEntity(t, !0)) !== void 0)
          break;
      default:
        return this._error(`Unexpected ${t.type}`, t);
    }
    return this._explicitQuantifiers ? (this._subject === null ? this._emit(
      this._graph || this.DEFAULTGRAPH,
      this._predicate,
      this._subject = this._blankNode(),
      this.QUANTIFIERS_GRAPH
    ) : this._emit(
      this._subject,
      this.RDF_REST,
      this._subject = this._blankNode(),
      this.QUANTIFIERS_GRAPH
    ), this._emit(this._subject, this.RDF_FIRST, r, this.QUANTIFIERS_GRAPH)) : this._quantified[r.id] = this._quantifier(this._blankNode().value), this._readQuantifierPunctuation;
  }
  // Reads punctuation from a @forSome or @forAll statement
  _readQuantifierPunctuation(t) {
    return t.type === "," ? this._readQuantifierList : (this._explicitQuantifiers && (this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH), this._subject = null), this._readCallback = this._getContextEndReader(), this._readCallback(t));
  }
  // ### `_getPathReader` reads a potential path and then resumes with the given function
  _getPathReader(t) {
    return this._afterPath = t, this._readPath;
  }
  // ### `_readPath` reads a potential path
  _readPath(t) {
    switch (t.type) {
      case "!":
        return this._readForwardPath;
      case "^":
        return this._readBackwardPath;
      default:
        const r = this._contextStack, n = r.length && r[r.length - 1];
        if (n && n.type === "item") {
          const o = this._subject;
          this._restoreContext("item", t), this._emit(this._subject, this.RDF_FIRST, o, this._graph);
        }
        return this._afterPath(t);
    }
  }
  // ### `_readForwardPath` reads a '!' path
  _readForwardPath(t) {
    let r, n;
    const o = this._blankNode();
    if ((n = this._readEntity(t)) !== void 0)
      return this._predicate === null ? (r = this._subject, this._subject = o) : (r = this._object, this._object = o), this._emit(r, n, o, this._graph), this._readPath;
  }
  // ### `_readBackwardPath` reads a '^' path
  _readBackwardPath(t) {
    const r = this._blankNode();
    let n, o;
    if ((n = this._readEntity(t)) !== void 0)
      return this._predicate === null ? (o = this._subject, this._subject = r) : (o = this._object, this._object = r), this._emit(r, n, o, this._graph), this._readPath;
  }
  // ### `_readRDFStarTailOrGraph` reads the graph of a nested RDF* quad or the end of a nested RDF* triple
  _readRDFStarTailOrGraph(t) {
    return t.type !== ">>" ? this._supportsQuads && this._graph === null && (this._graph = this._readEntity(t)) !== void 0 ? this._readRDFStarTail : this._error(`Expected >> to follow "${this._object.id}"`, t) : this._readRDFStarTail(t);
  }
  // ### `_readRDFStarTail` reads the end of a nested RDF* triple
  _readRDFStarTail(t) {
    if (t.type !== ">>")
      return this._error(`Expected >> but got ${t.type}`, t);
    const r = this._quad(
      this._subject,
      this._predicate,
      this._object,
      this._graph || this.DEFAULTGRAPH
    );
    return this._restoreContext("<<", t), this._subject === null ? (this._subject = r, this._readPredicate) : (this._object = r, this._getContextEndReader());
  }
  // ### `_getContextEndReader` gets the next reader function at the end of a context
  _getContextEndReader() {
    const t = this._contextStack;
    if (!t.length)
      return this._readPunctuation;
    switch (t[t.length - 1].type) {
      case "blank":
        return this._readBlankNodeTail;
      case "list":
        return this._readListItem;
      case "formula":
        return this._readFormulaTail;
      case "<<":
        return this._readRDFStarTailOrGraph;
    }
  }
  // ### `_emit` sends a quad through the callback
  _emit(t, r, n, o) {
    this._callback(null, this._quad(t, r, n, o || this.DEFAULTGRAPH));
  }
  // ### `_error` emits an error message through the callback
  _error(t, r) {
    const n = new Error(`${t} on line ${r.line}.`);
    n.context = {
      token: r,
      line: r.line,
      previousToken: this._lexer.previousToken
    }, this._callback(n), this._callback = Tb;
  }
  // ### `_resolveIRI` resolves an IRI against the base path
  _resolveIRI(t) {
    return /^[a-z][a-z0-9+.-]*:/i.test(t) ? t : this._resolveRelativeIRI(t);
  }
  // ### `_resolveRelativeIRI` resolves an IRI against the base path,
  // assuming that a base path has been set and that the IRI is indeed relative
  _resolveRelativeIRI(t) {
    if (!t.length)
      return this._base;
    switch (t[0]) {
      case "#":
        return this._base + t;
      case "?":
        return this._base.replace(/(?:\?.*)?$/, t);
      case "/":
        return (t[1] === "/" ? this._baseScheme : this._baseRoot) + this._removeDotSegments(t);
      default:
        return /^[^/:]*:/.test(t) ? null : this._removeDotSegments(this._basePath + t);
    }
  }
  // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986
  _removeDotSegments(t) {
    if (!/(^|\/)\.\.?($|[/#?])/.test(t))
      return t;
    const r = t.length;
    let n = "", o = -1, s = -1, a = 0, l = "/";
    for (; o < r; ) {
      switch (l) {
        case ":":
          if (s < 0 && t[++o] === "/" && t[++o] === "/")
            for (; (s = o + 1) < r && t[s] !== "/"; )
              o = s;
          break;
        case "?":
        case "#":
          o = r;
          break;
        case "/":
          if (t[o + 1] === ".")
            switch (l = t[++o + 1], l) {
              case "/":
                n += t.substring(a, o - 1), a = o + 1;
                break;
              case void 0:
              case "?":
              case "#":
                return n + t.substring(a, o) + t.substr(o + 1);
              case ".":
                if (l = t[++o + 1], l === void 0 || l === "/" || l === "?" || l === "#") {
                  if (n += t.substring(a, o - 2), (a = n.lastIndexOf("/")) >= s && (n = n.substr(0, a)), l !== "/")
                    return `${n}/${t.substr(o + 1)}`;
                  a = o + 1;
                }
            }
      }
      l = t[++o];
    }
    return n + t.substring(a);
  }
  // ## Public methods
  // ### `parse` parses the N3 input and emits each parsed quad through the callback
  parse(t, r, n) {
    if (this._readCallback = this._readInTopContext, this._sparqlStyle = !1, this._prefixes = /* @__PURE__ */ Object.create(null), this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2) : `b${TT++}_`, this._prefixCallback = n || Tb, this._inversePredicate = !1, this._quantified = /* @__PURE__ */ Object.create(null), !r) {
      const o = [];
      let s;
      if (this._callback = (a, l) => {
        a ? s = a : l && o.push(l);
      }, this._lexer.tokenize(t).every((a) => this._readCallback = this._readCallback(a)), s)
        throw s;
      return o;
    }
    this._callback = r, this._lexer.tokenize(t, (o, s) => {
      o !== null ? (this._callback(o), this._callback = Tb) : this._readCallback && (this._readCallback = this._readCallback(s));
    });
  }
};
function Tb() {
}
function L3(e, t) {
  const r = t.namedNode;
  e._namedNode = r, e._blankNode = t.blankNode, e._literal = t.literal, e._variable = t.variable, e._quad = t.quad, e.DEFAULTGRAPH = t.defaultGraph(), e.RDF_FIRST = r(fi.rdf.first), e.RDF_REST = r(fi.rdf.rest), e.RDF_NIL = r(fi.rdf.nil), e.N3_FORALL = r(fi.r.forAll), e.N3_FORSOME = r(fi.r.forSome), e.ABBREVIATIONS = {
    a: r(fi.rdf.type),
    "=": r(fi.owl.sameAs),
    ">": r(fi.log.implies)
  }, e.QUANTIFIERS_GRAPH = r("urn:n3:quantifiers");
}
L3(O3.prototype, EY);
var P3 = { exports: {} }, $b = { exports: {} }, Ft = {
  ArrayIsArray(e) {
    return Array.isArray(e);
  },
  ArrayPrototypeIncludes(e, t) {
    return e.includes(t);
  },
  ArrayPrototypeIndexOf(e, t) {
    return e.indexOf(t);
  },
  ArrayPrototypeJoin(e, t) {
    return e.join(t);
  },
  ArrayPrototypeMap(e, t) {
    return e.map(t);
  },
  ArrayPrototypePop(e, t) {
    return e.pop(t);
  },
  ArrayPrototypePush(e, t) {
    return e.push(t);
  },
  ArrayPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  Error,
  FunctionPrototypeCall(e, t, ...r) {
    return e.call(t, ...r);
  },
  FunctionPrototypeSymbolHasInstance(e, t) {
    return Function.prototype[Symbol.hasInstance].call(e, t);
  },
  MathFloor: Math.floor,
  Number,
  NumberIsInteger: Number.isInteger,
  NumberIsNaN: Number.isNaN,
  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
  NumberParseInt: Number.parseInt,
  ObjectDefineProperties(e, t) {
    return Object.defineProperties(e, t);
  },
  ObjectDefineProperty(e, t, r) {
    return Object.defineProperty(e, t, r);
  },
  ObjectGetOwnPropertyDescriptor(e, t) {
    return Object.getOwnPropertyDescriptor(e, t);
  },
  ObjectKeys(e) {
    return Object.keys(e);
  },
  ObjectSetPrototypeOf(e, t) {
    return Object.setPrototypeOf(e, t);
  },
  Promise,
  PromisePrototypeCatch(e, t) {
    return e.catch(t);
  },
  PromisePrototypeThen(e, t, r) {
    return e.then(t, r);
  },
  PromiseReject(e) {
    return Promise.reject(e);
  },
  PromiseResolve(e) {
    return Promise.resolve(e);
  },
  ReflectApply: Reflect.apply,
  RegExpPrototypeTest(e, t) {
    return e.test(t);
  },
  SafeSet: Set,
  String,
  StringPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  StringPrototypeToLowerCase(e) {
    return e.toLowerCase();
  },
  StringPrototypeToUpperCase(e) {
    return e.toUpperCase();
  },
  StringPrototypeTrim(e) {
    return e.trim();
  },
  Symbol,
  SymbolFor: Symbol.for,
  SymbolAsyncIterator: Symbol.asyncIterator,
  SymbolHasInstance: Symbol.hasInstance,
  SymbolIterator: Symbol.iterator,
  SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
  SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
  TypedArrayPrototypeSet(e, t, r) {
    return e.set(t, r);
  },
  Boolean,
  Uint8Array
}, D3 = { exports: {} }, Lu = { exports: {} }, $T;
function Kt() {
  if ($T)
    return Lu.exports;
  $T = 1;
  const { AbortController: e, AbortSignal: t } = typeof self < "u" ? self : typeof window < "u" ? window : (
    /* otherwise */
    void 0
  );
  return Lu.exports = e, Lu.exports.AbortSignal = t, Lu.exports.default = e, Lu.exports;
}
var ZE = { exports: {} }, Il = typeof Reflect == "object" ? Reflect : null, NT = Il && typeof Il.apply == "function" ? Il.apply : function(t, r, n) {
  return Function.prototype.apply.call(t, r, n);
}, jd;
Il && typeof Il.ownKeys == "function" ? jd = Il.ownKeys : Object.getOwnPropertySymbols ? jd = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : jd = function(t) {
  return Object.getOwnPropertyNames(t);
};
function MY(e) {
  console && console.warn && console.warn(e);
}
var F3 = Number.isNaN || function(t) {
  return t !== t;
};
function At() {
  At.init.call(this);
}
ZE.exports = At;
ZE.exports.once = DY;
At.EventEmitter = At;
At.prototype._events = void 0;
At.prototype._eventsCount = 0;
At.prototype._maxListeners = void 0;
var kT = 10;
function Ep(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(At, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return kT;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || F3(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    kT = e;
  }
});
At.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
At.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || F3(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function j3(e) {
  return e._maxListeners === void 0 ? At.defaultMaxListeners : e._maxListeners;
}
At.prototype.getMaxListeners = function() {
  return j3(this);
};
At.prototype.emit = function(t) {
  for (var r = [], n = 1; n < arguments.length; n++)
    r.push(arguments[n]);
  var o = t === "error", s = this._events;
  if (s !== void 0)
    o = o && s.error === void 0;
  else if (!o)
    return !1;
  if (o) {
    var a;
    if (r.length > 0 && (a = r[0]), a instanceof Error)
      throw a;
    var l = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
    throw l.context = a, l;
  }
  var u = s[t];
  if (u === void 0)
    return !1;
  if (typeof u == "function")
    NT(u, this, r);
  else
    for (var f = u.length, c = H3(u, f), n = 0; n < f; ++n)
      NT(c[n], this, r);
  return !0;
};
function B3(e, t, r, n) {
  var o, s, a;
  if (Ep(r), s = e._events, s === void 0 ? (s = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (s.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    r.listener ? r.listener : r
  ), s = e._events), a = s[t]), a === void 0)
    a = s[t] = r, ++e._eventsCount;
  else if (typeof a == "function" ? a = s[t] = n ? [r, a] : [a, r] : n ? a.unshift(r) : a.push(r), o = j3(e), o > 0 && a.length > o && !a.warned) {
    a.warned = !0;
    var l = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    l.name = "MaxListenersExceededWarning", l.emitter = e, l.type = t, l.count = a.length, MY(l);
  }
  return e;
}
At.prototype.addListener = function(t, r) {
  return B3(this, t, r, !1);
};
At.prototype.on = At.prototype.addListener;
At.prototype.prependListener = function(t, r) {
  return B3(this, t, r, !0);
};
function OY() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function q3(e, t, r) {
  var n = { fired: !1, wrapFn: void 0, target: e, type: t, listener: r }, o = OY.bind(n);
  return o.listener = r, n.wrapFn = o, o;
}
At.prototype.once = function(t, r) {
  return Ep(r), this.on(t, q3(this, t, r)), this;
};
At.prototype.prependOnceListener = function(t, r) {
  return Ep(r), this.prependListener(t, q3(this, t, r)), this;
};
At.prototype.removeListener = function(t, r) {
  var n, o, s, a, l;
  if (Ep(r), o = this._events, o === void 0)
    return this;
  if (n = o[t], n === void 0)
    return this;
  if (n === r || n.listener === r)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete o[t], o.removeListener && this.emit("removeListener", t, n.listener || r));
  else if (typeof n != "function") {
    for (s = -1, a = n.length - 1; a >= 0; a--)
      if (n[a] === r || n[a].listener === r) {
        l = n[a].listener, s = a;
        break;
      }
    if (s < 0)
      return this;
    s === 0 ? n.shift() : LY(n, s), n.length === 1 && (o[t] = n[0]), o.removeListener !== void 0 && this.emit("removeListener", t, l || r);
  }
  return this;
};
At.prototype.off = At.prototype.removeListener;
At.prototype.removeAllListeners = function(t) {
  var r, n, o;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[t]), this;
  if (arguments.length === 0) {
    var s = Object.keys(n), a;
    for (o = 0; o < s.length; ++o)
      a = s[o], a !== "removeListener" && this.removeAllListeners(a);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r = n[t], typeof r == "function")
    this.removeListener(t, r);
  else if (r !== void 0)
    for (o = r.length - 1; o >= 0; o--)
      this.removeListener(t, r[o]);
  return this;
};
function W3(e, t, r) {
  var n = e._events;
  if (n === void 0)
    return [];
  var o = n[t];
  return o === void 0 ? [] : typeof o == "function" ? r ? [o.listener || o] : [o] : r ? PY(o) : H3(o, o.length);
}
At.prototype.listeners = function(t) {
  return W3(this, t, !0);
};
At.prototype.rawListeners = function(t) {
  return W3(this, t, !1);
};
At.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : U3.call(e, t);
};
At.prototype.listenerCount = U3;
function U3(e) {
  var t = this._events;
  if (t !== void 0) {
    var r = t[e];
    if (typeof r == "function")
      return 1;
    if (r !== void 0)
      return r.length;
  }
  return 0;
}
At.prototype.eventNames = function() {
  return this._eventsCount > 0 ? jd(this._events) : [];
};
function H3(e, t) {
  for (var r = new Array(t), n = 0; n < t; ++n)
    r[n] = e[n];
  return r;
}
function LY(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function PY(e) {
  for (var t = new Array(e.length), r = 0; r < t.length; ++r)
    t[r] = e[r].listener || e[r];
  return t;
}
function DY(e, t) {
  return new Promise(function(r, n) {
    function o(a) {
      e.removeListener(t, s), n(a);
    }
    function s() {
      typeof e.removeListener == "function" && e.removeListener("error", o), r([].slice.call(arguments));
    }
    V3(e, t, s, { once: !0 }), t !== "error" && FY(e, o, { once: !0 });
  });
}
function FY(e, t, r) {
  typeof e.on == "function" && V3(e, "error", t, r);
}
function V3(e, t, r, n) {
  if (typeof e.on == "function")
    n.once ? e.once(t, r) : e.on(t, r);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function o(s) {
      n.once && e.removeEventListener(t, o), r(s);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var ur = ZE.exports;
(function(e) {
  const t = ft, { kResistStopPropagation: r, SymbolDispose: n } = Ft, o = globalThis.AbortSignal || Kt().AbortSignal, s = globalThis.AbortController || Kt().AbortController, a = Object.getPrototypeOf(async function() {
  }).constructor, l = globalThis.Blob || t.Blob, u = typeof l < "u" ? function(p) {
    return p instanceof l;
  } : function(p) {
    return !1;
  }, f = (h, p) => {
    if (h !== void 0 && (h === null || typeof h != "object" || !("aborted" in h)))
      throw new ERR_INVALID_ARG_TYPE(p, "AbortSignal", h);
  }, c = (h, p) => {
    if (typeof h != "function")
      throw new ERR_INVALID_ARG_TYPE(p, "Function", h);
  };
  class d extends Error {
    constructor(p) {
      if (!Array.isArray(p))
        throw new TypeError(`Expected input to be an Array, got ${typeof p}`);
      let v = "";
      for (let y = 0; y < p.length; y++)
        v += `    ${p[y].stack}
`;
      super(v), this.name = "AggregateError", this.errors = p;
    }
  }
  e.exports = {
    AggregateError: d,
    kEmptyObject: Object.freeze({}),
    once(h) {
      let p = !1;
      return function(...v) {
        p || (p = !0, h.apply(this, v));
      };
    },
    createDeferredPromise: function() {
      let h, p;
      return {
        promise: new Promise((y, w) => {
          h = y, p = w;
        }),
        resolve: h,
        reject: p
      };
    },
    promisify(h) {
      return new Promise((p, v) => {
        h((y, ...w) => y ? v(y) : p(...w));
      });
    },
    debuglog() {
      return function() {
      };
    },
    format(h, ...p) {
      return h.replace(/%([sdifj])/g, function(...[v, y]) {
        const w = p.shift();
        return y === "f" ? w.toFixed(6) : y === "j" ? JSON.stringify(w) : y === "s" && typeof w == "object" ? `${w.constructor !== Object ? w.constructor.name : ""} {}`.trim() : w.toString();
      });
    },
    inspect(h) {
      switch (typeof h) {
        case "string":
          if (h.includes("'"))
            if (h.includes('"')) {
              if (!h.includes("`") && !h.includes("${"))
                return `\`${h}\``;
            } else
              return `"${h}"`;
          return `'${h}'`;
        case "number":
          return isNaN(h) ? "NaN" : Object.is(h, -0) ? String(h) : h;
        case "bigint":
          return `${String(h)}n`;
        case "boolean":
        case "undefined":
          return String(h);
        case "object":
          return "{}";
      }
    },
    types: {
      isAsyncFunction(h) {
        return h instanceof a;
      },
      isArrayBufferView(h) {
        return ArrayBuffer.isView(h);
      }
    },
    isBlob: u,
    deprecate(h, p) {
      return h;
    },
    addAbortListener: ur.addAbortListener || function(p, v) {
      if (p === void 0)
        throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", p);
      f(p, "signal"), c(v, "listener");
      let y;
      return p.aborted ? queueMicrotask(() => v()) : (p.addEventListener("abort", v, {
        __proto__: null,
        once: !0,
        [r]: !0
      }), y = () => {
        p.removeEventListener("abort", v);
      }), {
        __proto__: null,
        [n]() {
          var w;
          (w = y) === null || w === void 0 || w();
        }
      };
    },
    AbortSignalAny: o.any || function(p) {
      if (p.length === 1)
        return p[0];
      const v = new s(), y = () => v.abort();
      return p.forEach((w) => {
        f(w, "signals"), w.addEventListener("abort", y, {
          once: !0
        });
      }), v.signal.addEventListener(
        "abort",
        () => {
          p.forEach((w) => w.removeEventListener("abort", y));
        },
        {
          once: !0
        }
      ), v.signal;
    }
  }, e.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
})(D3);
var Ur = D3.exports, ex = {};
const { format: jY, inspect: ph, AggregateError: BY } = Ur, qY = globalThis.AggregateError || BY, WY = Symbol("kIsNodeError"), UY = [
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
], HY = /^([A-Z][a-z0-9]*)+$/, VY = "__node_internal_", xp = {};
function ua(e, t) {
  if (!e)
    throw new xp.ERR_INTERNAL_ASSERTION(t);
}
function CT(e) {
  let t = "", r = e.length;
  const n = e[0] === "-" ? 1 : 0;
  for (; r >= n + 4; r -= 3)
    t = `_${e.slice(r - 3, r)}${t}`;
  return `${e.slice(0, r)}${t}`;
}
function zY(e, t, r) {
  if (typeof t == "function")
    return ua(
      t.length <= r.length,
      // Default options do not count.
      `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${t.length}).`
    ), t(...r);
  const n = (t.match(/%[dfijoOs]/g) || []).length;
  return ua(
    n === r.length,
    `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${n}).`
  ), r.length === 0 ? t : jY(t, ...r);
}
function wr(e, t, r) {
  r || (r = Error);
  class n extends r {
    constructor(...s) {
      super(zY(e, t, s));
    }
    toString() {
      return `${this.name} [${e}]: ${this.message}`;
    }
  }
  Object.defineProperties(n.prototype, {
    name: {
      value: r.name,
      writable: !0,
      enumerable: !1,
      configurable: !0
    },
    toString: {
      value() {
        return `${this.name} [${e}]: ${this.message}`;
      },
      writable: !0,
      enumerable: !1,
      configurable: !0
    }
  }), n.prototype.code = e, n.prototype[WY] = !0, xp[e] = n;
}
function IT(e) {
  const t = VY + e.name;
  return Object.defineProperty(e, "name", {
    value: t
  }), e;
}
function GY(e, t) {
  if (e && t && e !== t) {
    if (Array.isArray(t.errors))
      return t.errors.push(e), t;
    const r = new qY([t, e], t.message);
    return r.code = t.code, r;
  }
  return e || t;
}
let KY = class extends Error {
  constructor(t = "The operation was aborted", r = void 0) {
    if (r !== void 0 && typeof r != "object")
      throw new xp.ERR_INVALID_ARG_TYPE("options", "Object", r);
    super(t, r), this.code = "ABORT_ERR", this.name = "AbortError";
  }
};
wr("ERR_ASSERTION", "%s", Error);
wr(
  "ERR_INVALID_ARG_TYPE",
  (e, t, r) => {
    ua(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
    let n = "The ";
    e.endsWith(" argument") ? n += `${e} ` : n += `"${e}" ${e.includes(".") ? "property" : "argument"} `, n += "must be ";
    const o = [], s = [], a = [];
    for (const u of t)
      ua(typeof u == "string", "All expected entries have to be of type string"), UY.includes(u) ? o.push(u.toLowerCase()) : HY.test(u) ? s.push(u) : (ua(u !== "object", 'The value "object" should be written as "Object"'), a.push(u));
    if (s.length > 0) {
      const u = o.indexOf("object");
      u !== -1 && (o.splice(o, u, 1), s.push("Object"));
    }
    if (o.length > 0) {
      switch (o.length) {
        case 1:
          n += `of type ${o[0]}`;
          break;
        case 2:
          n += `one of type ${o[0]} or ${o[1]}`;
          break;
        default: {
          const u = o.pop();
          n += `one of type ${o.join(", ")}, or ${u}`;
        }
      }
      (s.length > 0 || a.length > 0) && (n += " or ");
    }
    if (s.length > 0) {
      switch (s.length) {
        case 1:
          n += `an instance of ${s[0]}`;
          break;
        case 2:
          n += `an instance of ${s[0]} or ${s[1]}`;
          break;
        default: {
          const u = s.pop();
          n += `an instance of ${s.join(", ")}, or ${u}`;
        }
      }
      a.length > 0 && (n += " or ");
    }
    switch (a.length) {
      case 0:
        break;
      case 1:
        a[0].toLowerCase() !== a[0] && (n += "an "), n += `${a[0]}`;
        break;
      case 2:
        n += `one of ${a[0]} or ${a[1]}`;
        break;
      default: {
        const u = a.pop();
        n += `one of ${a.join(", ")}, or ${u}`;
      }
    }
    if (r == null)
      n += `. Received ${r}`;
    else if (typeof r == "function" && r.name)
      n += `. Received function ${r.name}`;
    else if (typeof r == "object") {
      var l;
      if ((l = r.constructor) !== null && l !== void 0 && l.name)
        n += `. Received an instance of ${r.constructor.name}`;
      else {
        const u = ph(r, {
          depth: -1
        });
        n += `. Received ${u}`;
      }
    } else {
      let u = ph(r, {
        colors: !1
      });
      u.length > 25 && (u = `${u.slice(0, 25)}...`), n += `. Received type ${typeof r} (${u})`;
    }
    return n;
  },
  TypeError
);
wr(
  "ERR_INVALID_ARG_VALUE",
  (e, t, r = "is invalid") => {
    let n = ph(t);
    return n.length > 128 && (n = n.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${n}`;
  },
  TypeError
);
wr(
  "ERR_INVALID_RETURN_VALUE",
  (e, t, r) => {
    var n;
    const o = r != null && (n = r.constructor) !== null && n !== void 0 && n.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
    return `Expected ${e} to be returned from the "${t}" function but got ${o}.`;
  },
  TypeError
);
wr(
  "ERR_MISSING_ARGS",
  (...e) => {
    ua(e.length > 0, "At least one arg needs to be specified");
    let t;
    const r = e.length;
    switch (e = (Array.isArray(e) ? e : [e]).map((n) => `"${n}"`).join(" or "), r) {
      case 1:
        t += `The ${e[0]} argument`;
        break;
      case 2:
        t += `The ${e[0]} and ${e[1]} arguments`;
        break;
      default:
        {
          const n = e.pop();
          t += `The ${e.join(", ")}, and ${n} arguments`;
        }
        break;
    }
    return `${t} must be specified`;
  },
  TypeError
);
wr(
  "ERR_OUT_OF_RANGE",
  (e, t, r) => {
    ua(t, 'Missing "range" argument');
    let n;
    return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? n = CT(String(r)) : typeof r == "bigint" ? (n = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (n = CT(n)), n += "n") : n = ph(r), `The value of "${e}" is out of range. It must be ${t}. Received ${n}`;
  },
  RangeError
);
wr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
wr("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
wr("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
wr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
wr("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
wr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
wr("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
wr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
wr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
wr("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
wr("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
var nn = {
  AbortError: KY,
  aggregateTwoErrors: IT(GY),
  hideStackFrames: IT,
  codes: xp
};
const {
  ArrayIsArray: tx,
  ArrayPrototypeIncludes: z3,
  ArrayPrototypeJoin: G3,
  ArrayPrototypeMap: YY,
  NumberIsInteger: rx,
  NumberIsNaN: XY,
  NumberMAX_SAFE_INTEGER: JY,
  NumberMIN_SAFE_INTEGER: QY,
  NumberParseInt: ZY,
  ObjectPrototypeHasOwnProperty: eX,
  RegExpPrototypeExec: K3,
  String: tX,
  StringPrototypeToUpperCase: rX,
  StringPrototypeTrim: nX
} = Ft, {
  hideStackFrames: Nn,
  codes: { ERR_SOCKET_BAD_PORT: iX, ERR_INVALID_ARG_TYPE: Cr, ERR_INVALID_ARG_VALUE: fu, ERR_OUT_OF_RANGE: xa, ERR_UNKNOWN_SIGNAL: MT }
} = nn, { normalizeEncoding: oX } = Ur, { isAsyncFunction: sX, isArrayBufferView: aX } = Ur.types, OT = {};
function lX(e) {
  return e === (e | 0);
}
function uX(e) {
  return e === e >>> 0;
}
const fX = /^[0-7]+$/, cX = "must be a 32-bit unsigned integer or an octal string";
function dX(e, t, r) {
  if (typeof e > "u" && (e = r), typeof e == "string") {
    if (K3(fX, e) === null)
      throw new fu(t, e, cX);
    e = ZY(e, 8);
  }
  return Y3(e, t), e;
}
const hX = Nn((e, t, r = QY, n = JY) => {
  if (typeof e != "number")
    throw new Cr(t, "number", e);
  if (!rx(e))
    throw new xa(t, "an integer", e);
  if (e < r || e > n)
    throw new xa(t, `>= ${r} && <= ${n}`, e);
}), pX = Nn((e, t, r = -2147483648, n = 2147483647) => {
  if (typeof e != "number")
    throw new Cr(t, "number", e);
  if (!rx(e))
    throw new xa(t, "an integer", e);
  if (e < r || e > n)
    throw new xa(t, `>= ${r} && <= ${n}`, e);
}), Y3 = Nn((e, t, r = !1) => {
  if (typeof e != "number")
    throw new Cr(t, "number", e);
  if (!rx(e))
    throw new xa(t, "an integer", e);
  const n = r ? 1 : 0, o = 4294967295;
  if (e < n || e > o)
    throw new xa(t, `>= ${n} && <= ${o}`, e);
});
function nx(e, t) {
  if (typeof e != "string")
    throw new Cr(t, "string", e);
}
function gX(e, t, r = void 0, n) {
  if (typeof e != "number")
    throw new Cr(t, "number", e);
  if (r != null && e < r || n != null && e > n || (r != null || n != null) && XY(e))
    throw new xa(
      t,
      `${r != null ? `>= ${r}` : ""}${r != null && n != null ? " && " : ""}${n != null ? `<= ${n}` : ""}`,
      e
    );
}
const bX = Nn((e, t, r) => {
  if (!z3(r, e)) {
    const o = "must be one of: " + G3(
      YY(r, (s) => typeof s == "string" ? `'${s}'` : tX(s)),
      ", "
    );
    throw new fu(t, e, o);
  }
});
function X3(e, t) {
  if (typeof e != "boolean")
    throw new Cr(t, "boolean", e);
}
function Nb(e, t, r) {
  return e == null || !eX(e, t) ? r : e[t];
}
const yX = Nn((e, t, r = null) => {
  const n = Nb(r, "allowArray", !1), o = Nb(r, "allowFunction", !1);
  if (!Nb(r, "nullable", !1) && e === null || !n && tx(e) || typeof e != "object" && (!o || typeof e != "function"))
    throw new Cr(t, "Object", e);
}), vX = Nn((e, t) => {
  if (e != null && typeof e != "object" && typeof e != "function")
    throw new Cr(t, "a dictionary", e);
}), Rp = Nn((e, t, r = 0) => {
  if (!tx(e))
    throw new Cr(t, "Array", e);
  if (e.length < r) {
    const n = `must be longer than ${r}`;
    throw new fu(t, e, n);
  }
});
function mX(e, t) {
  Rp(e, t);
  for (let r = 0; r < e.length; r++)
    nx(e[r], `${t}[${r}]`);
}
function _X(e, t) {
  Rp(e, t);
  for (let r = 0; r < e.length; r++)
    X3(e[r], `${t}[${r}]`);
}
function wX(e, t) {
  Rp(e, t);
  for (let r = 0; r < e.length; r++) {
    const n = e[r], o = `${t}[${r}]`;
    if (n == null)
      throw new Cr(o, "AbortSignal", n);
    J3(n, o);
  }
}
function SX(e, t = "signal") {
  if (nx(e, t), OT[e] === void 0)
    throw OT[rX(e)] !== void 0 ? new MT(e + " (signals must use all capital letters)") : new MT(e);
}
const EX = Nn((e, t = "buffer") => {
  if (!aX(e))
    throw new Cr(t, ["Buffer", "TypedArray", "DataView"], e);
});
function xX(e, t) {
  const r = oX(t), n = e.length;
  if (r === "hex" && n % 2 !== 0)
    throw new fu("encoding", t, `is invalid for data of length ${n}`);
}
function RX(e, t = "Port", r = !0) {
  if (typeof e != "number" && typeof e != "string" || typeof e == "string" && nX(e).length === 0 || +e !== +e >>> 0 || e > 65535 || e === 0 && !r)
    throw new iX(t, e, r);
  return e | 0;
}
const J3 = Nn((e, t) => {
  if (e !== void 0 && (e === null || typeof e != "object" || !("aborted" in e)))
    throw new Cr(t, "AbortSignal", e);
}), AX = Nn((e, t) => {
  if (typeof e != "function")
    throw new Cr(t, "Function", e);
}), TX = Nn((e, t) => {
  if (typeof e != "function" || sX(e))
    throw new Cr(t, "Function", e);
}), $X = Nn((e, t) => {
  if (e !== void 0)
    throw new Cr(t, "undefined", e);
});
function NX(e, t, r) {
  if (!z3(r, e))
    throw new Cr(t, `('${G3(r, "|")}')`, e);
}
const kX = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
function LT(e, t) {
  if (typeof e > "u" || !K3(kX, e))
    throw new fu(
      t,
      e,
      'must be an array or string of format "</styles.css>; rel=preload; as=style"'
    );
}
function CX(e) {
  if (typeof e == "string")
    return LT(e, "hints"), e;
  if (tx(e)) {
    const t = e.length;
    let r = "";
    if (t === 0)
      return r;
    for (let n = 0; n < t; n++) {
      const o = e[n];
      LT(o, "hints"), r += o, n !== t - 1 && (r += ", ");
    }
    return r;
  }
  throw new fu(
    "hints",
    e,
    'must be an array or string of format "</styles.css>; rel=preload; as=style"'
  );
}
var vc = {
  isInt32: lX,
  isUint32: uX,
  parseFileMode: dX,
  validateArray: Rp,
  validateStringArray: mX,
  validateBooleanArray: _X,
  validateAbortSignalArray: wX,
  validateBoolean: X3,
  validateBuffer: EX,
  validateDictionary: vX,
  validateEncoding: xX,
  validateFunction: AX,
  validateInt32: pX,
  validateInteger: hX,
  validateNumber: gX,
  validateObject: yX,
  validateOneOf: bX,
  validatePlainFunction: TX,
  validatePort: RX,
  validateSignalName: SX,
  validateString: nx,
  validateUint32: Y3,
  validateUndefined: $X,
  validateUnion: NX,
  validateAbortSignal: J3,
  validateLinkHeaderValue: CX
}, ix = { exports: {} };
const { SymbolAsyncIterator: PT, SymbolIterator: DT, SymbolFor: ja } = Ft, Q3 = ja("nodejs.stream.destroyed"), Z3 = ja("nodejs.stream.errored"), W1 = ja("nodejs.stream.readable"), U1 = ja("nodejs.stream.writable"), e5 = ja("nodejs.stream.disturbed"), IX = ja("nodejs.webstream.isClosedPromise"), MX = ja("nodejs.webstream.controllerErrorFunction");
function Ap(e, t = !1) {
  var r;
  return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((r = e._readableState) === null || r === void 0 ? void 0 : r.readable) !== !1) && // Duplex
  (!e._writableState || e._readableState));
}
function Tp(e) {
  var t;
  return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === void 0 ? void 0 : t.writable) !== !1));
}
function OX(e) {
  return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
}
function Pi(e) {
  return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
}
function t5(e) {
  return !!(e && !Pi(e) && typeof e.pipeThrough == "function" && typeof e.getReader == "function" && typeof e.cancel == "function");
}
function r5(e) {
  return !!(e && !Pi(e) && typeof e.getWriter == "function" && typeof e.abort == "function");
}
function n5(e) {
  return !!(e && !Pi(e) && typeof e.readable == "object" && typeof e.writable == "object");
}
function LX(e) {
  return t5(e) || r5(e) || n5(e);
}
function PX(e, t) {
  return e == null ? !1 : t === !0 ? typeof e[PT] == "function" : t === !1 ? typeof e[DT] == "function" : typeof e[PT] == "function" || typeof e[DT] == "function";
}
function $p(e) {
  if (!Pi(e))
    return null;
  const t = e._writableState, r = e._readableState, n = t || r;
  return !!(e.destroyed || e[Q3] || n != null && n.destroyed);
}
function i5(e) {
  if (!Tp(e))
    return null;
  if (e.writableEnded === !0)
    return !0;
  const t = e._writableState;
  return t != null && t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function DX(e, t) {
  if (!Tp(e))
    return null;
  if (e.writableFinished === !0)
    return !0;
  const r = e._writableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.finished) != "boolean" ? null : !!(r.finished || t === !1 && r.ended === !0 && r.length === 0);
}
function FX(e) {
  if (!Ap(e))
    return null;
  if (e.readableEnded === !0)
    return !0;
  const t = e._readableState;
  return !t || t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function o5(e, t) {
  if (!Ap(e))
    return null;
  const r = e._readableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.endEmitted) != "boolean" ? null : !!(r.endEmitted || t === !1 && r.ended === !0 && r.length === 0);
}
function s5(e) {
  return e && e[W1] != null ? e[W1] : typeof (e == null ? void 0 : e.readable) != "boolean" ? null : $p(e) ? !1 : Ap(e) && e.readable && !o5(e);
}
function a5(e) {
  return e && e[U1] != null ? e[U1] : typeof (e == null ? void 0 : e.writable) != "boolean" ? null : $p(e) ? !1 : Tp(e) && e.writable && !i5(e);
}
function jX(e, t) {
  return Pi(e) ? $p(e) ? !0 : !((t == null ? void 0 : t.readable) !== !1 && s5(e) || (t == null ? void 0 : t.writable) !== !1 && a5(e)) : null;
}
function BX(e) {
  var t, r;
  return Pi(e) ? e.writableErrored ? e.writableErrored : (t = (r = e._writableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function qX(e) {
  var t, r;
  return Pi(e) ? e.readableErrored ? e.readableErrored : (t = (r = e._readableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function WX(e) {
  if (!Pi(e))
    return null;
  if (typeof e.closed == "boolean")
    return e.closed;
  const t = e._writableState, r = e._readableState;
  return typeof (t == null ? void 0 : t.closed) == "boolean" || typeof (r == null ? void 0 : r.closed) == "boolean" ? (t == null ? void 0 : t.closed) || (r == null ? void 0 : r.closed) : typeof e._closed == "boolean" && l5(e) ? e._closed : null;
}
function l5(e) {
  return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
}
function u5(e) {
  return typeof e._sent100 == "boolean" && l5(e);
}
function UX(e) {
  var t;
  return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === void 0 ? void 0 : t.upgradeOrConnect) === void 0;
}
function HX(e) {
  if (!Pi(e))
    return null;
  const t = e._writableState, r = e._readableState, n = t || r;
  return !n && u5(e) || !!(n && n.autoDestroy && n.emitClose && n.closed === !1);
}
function VX(e) {
  var t;
  return !!(e && ((t = e[e5]) !== null && t !== void 0 ? t : e.readableDidRead || e.readableAborted));
}
function zX(e) {
  var t, r, n, o, s, a, l, u, f, c;
  return !!(e && ((t = (r = (n = (o = (s = (a = e[Z3]) !== null && a !== void 0 ? a : e.readableErrored) !== null && s !== void 0 ? s : e.writableErrored) !== null && o !== void 0 ? o : (l = e._readableState) === null || l === void 0 ? void 0 : l.errorEmitted) !== null && n !== void 0 ? n : (u = e._writableState) === null || u === void 0 ? void 0 : u.errorEmitted) !== null && r !== void 0 ? r : (f = e._readableState) === null || f === void 0 ? void 0 : f.errored) !== null && t !== void 0 ? t : !((c = e._writableState) === null || c === void 0) && c.errored));
}
var xo = {
  isDestroyed: $p,
  kIsDestroyed: Q3,
  isDisturbed: VX,
  kIsDisturbed: e5,
  isErrored: zX,
  kIsErrored: Z3,
  isReadable: s5,
  kIsReadable: W1,
  kIsClosedPromise: IX,
  kControllerErrorFunction: MX,
  kIsWritable: U1,
  isClosed: WX,
  isDuplexNodeStream: OX,
  isFinished: jX,
  isIterable: PX,
  isReadableNodeStream: Ap,
  isReadableStream: t5,
  isReadableEnded: FX,
  isReadableFinished: o5,
  isReadableErrored: qX,
  isNodeStream: Pi,
  isWebStream: LX,
  isWritable: a5,
  isWritableNodeStream: Tp,
  isWritableStream: r5,
  isWritableEnded: i5,
  isWritableFinished: DX,
  isWritableErrored: BX,
  isServerRequest: UX,
  isServerResponse: u5,
  willEmitClose: HX,
  isTransformStream: n5
};
const Fo = St, { AbortError: f5, codes: GX } = nn, { ERR_INVALID_ARG_TYPE: KX, ERR_STREAM_PREMATURE_CLOSE: FT } = GX, { kEmptyObject: H1, once: V1 } = Ur, { validateAbortSignal: YX, validateFunction: XX, validateObject: JX, validateBoolean: QX } = vc, { Promise: ZX, PromisePrototypeThen: eJ, SymbolDispose: c5 } = Ft, {
  isClosed: tJ,
  isReadable: jT,
  isReadableNodeStream: kb,
  isReadableStream: rJ,
  isReadableFinished: BT,
  isReadableErrored: qT,
  isWritable: WT,
  isWritableNodeStream: UT,
  isWritableStream: nJ,
  isWritableFinished: HT,
  isWritableErrored: VT,
  isNodeStream: iJ,
  willEmitClose: oJ,
  kIsClosedPromise: sJ
} = xo;
let Ml;
function aJ(e) {
  return e.setHeader && typeof e.abort == "function";
}
const z1 = () => {
};
function d5(e, t, r) {
  var n, o;
  if (arguments.length === 2 ? (r = t, t = H1) : t == null ? t = H1 : JX(t, "options"), XX(r, "callback"), YX(t.signal, "options.signal"), r = V1(r), rJ(e) || nJ(e))
    return lJ(e, t, r);
  if (!iJ(e))
    throw new KX("stream", ["ReadableStream", "WritableStream", "Stream"], e);
  const s = (n = t.readable) !== null && n !== void 0 ? n : kb(e), a = (o = t.writable) !== null && o !== void 0 ? o : UT(e), l = e._writableState, u = e._readableState, f = () => {
    e.writable || h();
  };
  let c = oJ(e) && kb(e) === s && UT(e) === a, d = HT(e, !1);
  const h = () => {
    d = !0, e.destroyed && (c = !1), !(c && (!e.readable || s)) && (!s || p) && r.call(e);
  };
  let p = BT(e, !1);
  const v = () => {
    p = !0, e.destroyed && (c = !1), !(c && (!e.writable || a)) && (!a || d) && r.call(e);
  }, y = (C) => {
    r.call(e, C);
  };
  let w = tJ(e);
  const S = () => {
    w = !0;
    const C = VT(e) || qT(e);
    if (C && typeof C != "boolean")
      return r.call(e, C);
    if (s && !p && kb(e, !0) && !BT(e, !1))
      return r.call(e, new FT());
    if (a && !d && !HT(e, !1))
      return r.call(e, new FT());
    r.call(e);
  }, x = () => {
    w = !0;
    const C = VT(e) || qT(e);
    if (C && typeof C != "boolean")
      return r.call(e, C);
    r.call(e);
  }, E = () => {
    e.req.on("finish", h);
  };
  aJ(e) ? (e.on("complete", h), c || e.on("abort", S), e.req ? E() : e.on("request", E)) : a && !l && (e.on("end", f), e.on("close", f)), !c && typeof e.aborted == "boolean" && e.on("aborted", S), e.on("end", v), e.on("finish", h), t.error !== !1 && e.on("error", y), e.on("close", S), w ? Fo.nextTick(S) : l != null && l.errorEmitted || u != null && u.errorEmitted ? c || Fo.nextTick(x) : (!s && (!c || jT(e)) && (d || WT(e) === !1) || !a && (!c || WT(e)) && (p || jT(e) === !1) || u && e.req && e.aborted) && Fo.nextTick(x);
  const N = () => {
    r = z1, e.removeListener("aborted", S), e.removeListener("complete", h), e.removeListener("abort", S), e.removeListener("request", E), e.req && e.req.removeListener("finish", h), e.removeListener("end", f), e.removeListener("close", f), e.removeListener("finish", h), e.removeListener("end", v), e.removeListener("error", y), e.removeListener("close", S);
  };
  if (t.signal && !w) {
    const C = () => {
      const j = r;
      N(), j.call(
        e,
        new f5(void 0, {
          cause: t.signal.reason
        })
      );
    };
    if (t.signal.aborted)
      Fo.nextTick(C);
    else {
      Ml = Ml || Ur.addAbortListener;
      const j = Ml(t.signal, C), J = r;
      r = V1((...z) => {
        j[c5](), J.apply(e, z);
      });
    }
  }
  return N;
}
function lJ(e, t, r) {
  let n = !1, o = z1;
  if (t.signal)
    if (o = () => {
      n = !0, r.call(
        e,
        new f5(void 0, {
          cause: t.signal.reason
        })
      );
    }, t.signal.aborted)
      Fo.nextTick(o);
    else {
      Ml = Ml || Ur.addAbortListener;
      const a = Ml(t.signal, o), l = r;
      r = V1((...u) => {
        a[c5](), l.apply(e, u);
      });
    }
  const s = (...a) => {
    n || Fo.nextTick(() => r.apply(e, a));
  };
  return eJ(e[sJ].promise, s, s), z1;
}
function uJ(e, t) {
  var r;
  let n = !1;
  return t === null && (t = H1), (r = t) !== null && r !== void 0 && r.cleanup && (QX(t.cleanup, "cleanup"), n = t.cleanup), new ZX((o, s) => {
    const a = d5(e, t, (l) => {
      n && a(), l ? s(l) : o();
    });
  });
}
ix.exports = d5;
ix.exports.finished = uJ;
var vs = ix.exports;
const mi = St, {
  aggregateTwoErrors: fJ,
  codes: { ERR_MULTIPLE_CALLBACK: cJ },
  AbortError: dJ
} = nn, { Symbol: h5 } = Ft, { kIsDestroyed: hJ, isDestroyed: pJ, isFinished: gJ, isServerRequest: bJ } = xo, p5 = h5("kDestroy"), G1 = h5("kConstruct");
function g5(e, t, r) {
  e && (e.stack, t && !t.errored && (t.errored = e), r && !r.errored && (r.errored = e));
}
function yJ(e, t) {
  const r = this._readableState, n = this._writableState, o = n || r;
  return n != null && n.destroyed || r != null && r.destroyed ? (typeof t == "function" && t(), this) : (g5(e, n, r), n && (n.destroyed = !0), r && (r.destroyed = !0), o.constructed ? zT(this, e, t) : this.once(p5, function(s) {
    zT(this, fJ(s, e), t);
  }), this);
}
function zT(e, t, r) {
  let n = !1;
  function o(s) {
    if (n)
      return;
    n = !0;
    const a = e._readableState, l = e._writableState;
    g5(s, l, a), l && (l.closed = !0), a && (a.closed = !0), typeof r == "function" && r(s), s ? mi.nextTick(vJ, e, s) : mi.nextTick(b5, e);
  }
  try {
    e._destroy(t || null, o);
  } catch (s) {
    o(s);
  }
}
function vJ(e, t) {
  K1(e, t), b5(e);
}
function b5(e) {
  const t = e._readableState, r = e._writableState;
  r && (r.closeEmitted = !0), t && (t.closeEmitted = !0), (r != null && r.emitClose || t != null && t.emitClose) && e.emit("close");
}
function K1(e, t) {
  const r = e._readableState, n = e._writableState;
  n != null && n.errorEmitted || r != null && r.errorEmitted || (n && (n.errorEmitted = !0), r && (r.errorEmitted = !0), e.emit("error", t));
}
function mJ() {
  const e = this._readableState, t = this._writableState;
  e && (e.constructed = !0, e.closed = !1, e.closeEmitted = !1, e.destroyed = !1, e.errored = null, e.errorEmitted = !1, e.reading = !1, e.ended = e.readable === !1, e.endEmitted = e.readable === !1), t && (t.constructed = !0, t.destroyed = !1, t.closed = !1, t.closeEmitted = !1, t.errored = null, t.errorEmitted = !1, t.finalCalled = !1, t.prefinished = !1, t.ended = t.writable === !1, t.ending = t.writable === !1, t.finished = t.writable === !1);
}
function Y1(e, t, r) {
  const n = e._readableState, o = e._writableState;
  if (o != null && o.destroyed || n != null && n.destroyed)
    return this;
  n != null && n.autoDestroy || o != null && o.autoDestroy ? e.destroy(t) : t && (t.stack, o && !o.errored && (o.errored = t), n && !n.errored && (n.errored = t), r ? mi.nextTick(K1, e, t) : K1(e, t));
}
function _J(e, t) {
  if (typeof e._construct != "function")
    return;
  const r = e._readableState, n = e._writableState;
  r && (r.constructed = !1), n && (n.constructed = !1), e.once(G1, t), !(e.listenerCount(G1) > 1) && mi.nextTick(wJ, e);
}
function wJ(e) {
  let t = !1;
  function r(n) {
    if (t) {
      Y1(e, n ?? new cJ());
      return;
    }
    t = !0;
    const o = e._readableState, s = e._writableState, a = s || o;
    o && (o.constructed = !0), s && (s.constructed = !0), a.destroyed ? e.emit(p5, n) : n ? Y1(e, n, !0) : mi.nextTick(SJ, e);
  }
  try {
    e._construct((n) => {
      mi.nextTick(r, n);
    });
  } catch (n) {
    mi.nextTick(r, n);
  }
}
function SJ(e) {
  e.emit(G1);
}
function GT(e) {
  return (e == null ? void 0 : e.setHeader) && typeof e.abort == "function";
}
function y5(e) {
  e.emit("close");
}
function EJ(e, t) {
  e.emit("error", t), mi.nextTick(y5, e);
}
function xJ(e, t) {
  !e || pJ(e) || (!t && !gJ(e) && (t = new dJ()), bJ(e) ? (e.socket = null, e.destroy(t)) : GT(e) ? e.abort() : GT(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? mi.nextTick(EJ, e, t) : mi.nextTick(y5, e), e.destroyed || (e[hJ] = !0));
}
var cu = {
  construct: _J,
  destroyer: xJ,
  destroy: yJ,
  undestroy: mJ,
  errorOrDestroy: Y1
};
const { ArrayIsArray: RJ, ObjectSetPrototypeOf: v5 } = Ft, { EventEmitter: Np } = ur;
function kp(e) {
  Np.call(this, e);
}
v5(kp.prototype, Np.prototype);
v5(kp, Np);
kp.prototype.pipe = function(e, t) {
  const r = this;
  function n(c) {
    e.writable && e.write(c) === !1 && r.pause && r.pause();
  }
  r.on("data", n);
  function o() {
    r.readable && r.resume && r.resume();
  }
  e.on("drain", o), !e._isStdio && (!t || t.end !== !1) && (r.on("end", a), r.on("close", l));
  let s = !1;
  function a() {
    s || (s = !0, e.end());
  }
  function l() {
    s || (s = !0, typeof e.destroy == "function" && e.destroy());
  }
  function u(c) {
    f(), Np.listenerCount(this, "error") === 0 && this.emit("error", c);
  }
  X1(r, "error", u), X1(e, "error", u);
  function f() {
    r.removeListener("data", n), e.removeListener("drain", o), r.removeListener("end", a), r.removeListener("close", l), r.removeListener("error", u), e.removeListener("error", u), r.removeListener("end", f), r.removeListener("close", f), e.removeListener("close", f);
  }
  return r.on("end", f), r.on("close", f), e.on("close", f), e.emit("pipe", r), e;
};
function X1(e, t, r) {
  if (typeof e.prependListener == "function")
    return e.prependListener(t, r);
  !e._events || !e._events[t] ? e.on(t, r) : RJ(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
}
var ox = {
  Stream: kp,
  prependListener: X1
}, m5 = { exports: {} };
(function(e) {
  const { SymbolDispose: t } = Ft, { AbortError: r, codes: n } = nn, { isNodeStream: o, isWebStream: s, kControllerErrorFunction: a } = xo, l = vs, { ERR_INVALID_ARG_TYPE: u } = n;
  let f;
  const c = (d, h) => {
    if (typeof d != "object" || !("aborted" in d))
      throw new u(h, "AbortSignal", d);
  };
  e.exports.addAbortSignal = function(h, p) {
    if (c(h, "signal"), !o(p) && !s(p))
      throw new u("stream", ["ReadableStream", "WritableStream", "Stream"], p);
    return e.exports.addAbortSignalNoValidate(h, p);
  }, e.exports.addAbortSignalNoValidate = function(d, h) {
    if (typeof d != "object" || !("aborted" in d))
      return h;
    const p = o(h) ? () => {
      h.destroy(
        new r(void 0, {
          cause: d.reason
        })
      );
    } : () => {
      h[a](
        new r(void 0, {
          cause: d.reason
        })
      );
    };
    if (d.aborted)
      p();
    else {
      f = f || Ur.addAbortListener;
      const v = f(d, p);
      l(h, v[t]);
    }
    return h;
  };
})(m5);
var Cp = m5.exports;
const { StringPrototypeSlice: KT, SymbolIterator: AJ, TypedArrayPrototypeSet: Jc, Uint8Array: TJ } = Ft, { Buffer: Cb } = ft, { inspect: $J } = Ur;
var NJ = class {
  constructor() {
    this.head = null, this.tail = null, this.length = 0;
  }
  push(t) {
    const r = {
      data: t,
      next: null
    };
    this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
  }
  unshift(t) {
    const r = {
      data: t,
      next: this.head
    };
    this.length === 0 && (this.tail = r), this.head = r, ++this.length;
  }
  shift() {
    if (this.length === 0)
      return;
    const t = this.head.data;
    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
  }
  clear() {
    this.head = this.tail = null, this.length = 0;
  }
  join(t) {
    if (this.length === 0)
      return "";
    let r = this.head, n = "" + r.data;
    for (; (r = r.next) !== null; )
      n += t + r.data;
    return n;
  }
  concat(t) {
    if (this.length === 0)
      return Cb.alloc(0);
    const r = Cb.allocUnsafe(t >>> 0);
    let n = this.head, o = 0;
    for (; n; )
      Jc(r, n.data, o), o += n.data.length, n = n.next;
    return r;
  }
  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(t, r) {
    const n = this.head.data;
    if (t < n.length) {
      const o = n.slice(0, t);
      return this.head.data = n.slice(t), o;
    }
    return t === n.length ? this.shift() : r ? this._getString(t) : this._getBuffer(t);
  }
  first() {
    return this.head.data;
  }
  *[AJ]() {
    for (let t = this.head; t; t = t.next)
      yield t.data;
  }
  // Consumes a specified amount of characters from the buffered data.
  _getString(t) {
    let r = "", n = this.head, o = 0;
    do {
      const s = n.data;
      if (t > s.length)
        r += s, t -= s.length;
      else {
        t === s.length ? (r += s, ++o, n.next ? this.head = n.next : this.head = this.tail = null) : (r += KT(s, 0, t), this.head = n, n.data = KT(s, t));
        break;
      }
      ++o;
    } while ((n = n.next) !== null);
    return this.length -= o, r;
  }
  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(t) {
    const r = Cb.allocUnsafe(t), n = t;
    let o = this.head, s = 0;
    do {
      const a = o.data;
      if (t > a.length)
        Jc(r, a, n - t), t -= a.length;
      else {
        t === a.length ? (Jc(r, a, n - t), ++s, o.next ? this.head = o.next : this.head = this.tail = null) : (Jc(r, new TJ(a.buffer, a.byteOffset, t), n - t), this.head = o, o.data = a.slice(t));
        break;
      }
      ++s;
    } while ((o = o.next) !== null);
    return this.length -= s, r;
  }
  // Make sure the linked list only shows the minimal necessary information.
  [Symbol.for("nodejs.util.inspect.custom")](t, r) {
    return $J(this, {
      ...r,
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: !1
    });
  }
};
const { MathFloor: kJ, NumberIsInteger: CJ } = Ft, { validateInteger: IJ } = vc, { ERR_INVALID_ARG_VALUE: MJ } = nn.codes;
let _5 = 16 * 1024, w5 = 16;
function OJ(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function S5(e) {
  return e ? w5 : _5;
}
function LJ(e, t) {
  IJ(t, "value", 0), e ? w5 = t : _5 = t;
}
function PJ(e, t, r, n) {
  const o = OJ(t, n, r);
  if (o != null) {
    if (!CJ(o) || o < 0) {
      const s = n ? `options.${r}` : "options.highWaterMark";
      throw new MJ(s, o);
    }
    return kJ(o);
  }
  return S5(e.objectMode);
}
var Ip = {
  getHighWaterMark: PJ,
  getDefaultHighWaterMark: S5,
  setDefaultHighWaterMark: LJ
}, Ib = {}, Qc = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var YT;
function DJ() {
  return YT || (YT = 1, function(e, t) {
    var r = ft, n = r.Buffer;
    function o(a, l) {
      for (var u in a)
        l[u] = a[u];
    }
    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? e.exports = r : (o(r, t), t.Buffer = s);
    function s(a, l, u) {
      return n(a, l, u);
    }
    s.prototype = Object.create(n.prototype), o(n, s), s.from = function(a, l, u) {
      if (typeof a == "number")
        throw new TypeError("Argument must not be a number");
      return n(a, l, u);
    }, s.alloc = function(a, l, u) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      var f = n(a);
      return l !== void 0 ? typeof u == "string" ? f.fill(l, u) : f.fill(l) : f.fill(0), f;
    }, s.allocUnsafe = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return n(a);
    }, s.allocUnsafeSlow = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(a);
    };
  }(Qc, Qc.exports)), Qc.exports;
}
var XT;
function Vl() {
  if (XT)
    return Ib;
  XT = 1;
  var e = DJ().Buffer, t = e.isEncoding || function(S) {
    switch (S = "" + S, S && S.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function r(S) {
    if (!S)
      return "utf8";
    for (var x; ; )
      switch (S) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return S;
        default:
          if (x)
            return;
          S = ("" + S).toLowerCase(), x = !0;
      }
  }
  function n(S) {
    var x = r(S);
    if (typeof x != "string" && (e.isEncoding === t || !t(S)))
      throw new Error("Unknown encoding: " + S);
    return x || S;
  }
  Ib.StringDecoder = o;
  function o(S) {
    this.encoding = n(S);
    var x;
    switch (this.encoding) {
      case "utf16le":
        this.text = d, this.end = h, x = 4;
        break;
      case "utf8":
        this.fillLast = u, x = 4;
        break;
      case "base64":
        this.text = p, this.end = v, x = 3;
        break;
      default:
        this.write = y, this.end = w;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(x);
  }
  o.prototype.write = function(S) {
    if (S.length === 0)
      return "";
    var x, E;
    if (this.lastNeed) {
      if (x = this.fillLast(S), x === void 0)
        return "";
      E = this.lastNeed, this.lastNeed = 0;
    } else
      E = 0;
    return E < S.length ? x ? x + this.text(S, E) : this.text(S, E) : x || "";
  }, o.prototype.end = c, o.prototype.text = f, o.prototype.fillLast = function(S) {
    if (this.lastNeed <= S.length)
      return S.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    S.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, S.length), this.lastNeed -= S.length;
  };
  function s(S) {
    return S <= 127 ? 0 : S >> 5 === 6 ? 2 : S >> 4 === 14 ? 3 : S >> 3 === 30 ? 4 : S >> 6 === 2 ? -1 : -2;
  }
  function a(S, x, E) {
    var N = x.length - 1;
    if (N < E)
      return 0;
    var C = s(x[N]);
    return C >= 0 ? (C > 0 && (S.lastNeed = C - 1), C) : --N < E || C === -2 ? 0 : (C = s(x[N]), C >= 0 ? (C > 0 && (S.lastNeed = C - 2), C) : --N < E || C === -2 ? 0 : (C = s(x[N]), C >= 0 ? (C > 0 && (C === 2 ? C = 0 : S.lastNeed = C - 3), C) : 0));
  }
  function l(S, x, E) {
    if ((x[0] & 192) !== 128)
      return S.lastNeed = 0, "�";
    if (S.lastNeed > 1 && x.length > 1) {
      if ((x[1] & 192) !== 128)
        return S.lastNeed = 1, "�";
      if (S.lastNeed > 2 && x.length > 2 && (x[2] & 192) !== 128)
        return S.lastNeed = 2, "�";
    }
  }
  function u(S) {
    var x = this.lastTotal - this.lastNeed, E = l(this, S);
    if (E !== void 0)
      return E;
    if (this.lastNeed <= S.length)
      return S.copy(this.lastChar, x, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    S.copy(this.lastChar, x, 0, S.length), this.lastNeed -= S.length;
  }
  function f(S, x) {
    var E = a(this, S, x);
    if (!this.lastNeed)
      return S.toString("utf8", x);
    this.lastTotal = E;
    var N = S.length - (E - this.lastNeed);
    return S.copy(this.lastChar, 0, N), S.toString("utf8", x, N);
  }
  function c(S) {
    var x = S && S.length ? this.write(S) : "";
    return this.lastNeed ? x + "�" : x;
  }
  function d(S, x) {
    if ((S.length - x) % 2 === 0) {
      var E = S.toString("utf16le", x);
      if (E) {
        var N = E.charCodeAt(E.length - 1);
        if (N >= 55296 && N <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = S[S.length - 2], this.lastChar[1] = S[S.length - 1], E.slice(0, -1);
      }
      return E;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = S[S.length - 1], S.toString("utf16le", x, S.length - 1);
  }
  function h(S) {
    var x = S && S.length ? this.write(S) : "";
    if (this.lastNeed) {
      var E = this.lastTotal - this.lastNeed;
      return x + this.lastChar.toString("utf16le", 0, E);
    }
    return x;
  }
  function p(S, x) {
    var E = (S.length - x) % 3;
    return E === 0 ? S.toString("base64", x) : (this.lastNeed = 3 - E, this.lastTotal = 3, E === 1 ? this.lastChar[0] = S[S.length - 1] : (this.lastChar[0] = S[S.length - 2], this.lastChar[1] = S[S.length - 1]), S.toString("base64", x, S.length - E));
  }
  function v(S) {
    var x = S && S.length ? this.write(S) : "";
    return this.lastNeed ? x + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : x;
  }
  function y(S) {
    return S.toString(this.encoding);
  }
  function w(S) {
    return S && S.length ? this.write(S) : "";
  }
  return Ib;
}
const JT = St, { PromisePrototypeThen: FJ, SymbolAsyncIterator: QT, SymbolIterator: ZT } = Ft, { Buffer: jJ } = ft, { ERR_INVALID_ARG_TYPE: BJ, ERR_STREAM_NULL_VALUES: qJ } = nn.codes;
function WJ(e, t, r) {
  let n;
  if (typeof t == "string" || t instanceof jJ)
    return new e({
      objectMode: !0,
      ...r,
      read() {
        this.push(t), this.push(null);
      }
    });
  let o;
  if (t && t[QT])
    o = !0, n = t[QT]();
  else if (t && t[ZT])
    o = !1, n = t[ZT]();
  else
    throw new BJ("iterable", ["Iterable"], t);
  const s = new e({
    objectMode: !0,
    highWaterMark: 1,
    // TODO(ronag): What options should be allowed?
    ...r
  });
  let a = !1;
  s._read = function() {
    a || (a = !0, u());
  }, s._destroy = function(f, c) {
    FJ(
      l(f),
      () => JT.nextTick(c, f),
      // nextTick is here in case cb throws
      (d) => JT.nextTick(c, d || f)
    );
  };
  async function l(f) {
    const c = f != null, d = typeof n.throw == "function";
    if (c && d) {
      const { value: h, done: p } = await n.throw(f);
      if (await h, p)
        return;
    }
    if (typeof n.return == "function") {
      const { value: h } = await n.return();
      await h;
    }
  }
  async function u() {
    for (; ; ) {
      try {
        const { value: f, done: c } = o ? await n.next() : n.next();
        if (c)
          s.push(null);
        else {
          const d = f && typeof f.then == "function" ? await f : f;
          if (d === null)
            throw a = !1, new qJ();
          if (s.push(d))
            continue;
          a = !1;
        }
      } catch (f) {
        s.destroy(f);
      }
      break;
    }
  }
  return s;
}
var E5 = WJ, Mb, e$;
function Mp() {
  if (e$)
    return Mb;
  e$ = 1;
  const e = St, {
    ArrayPrototypeIndexOf: t,
    NumberIsInteger: r,
    NumberIsNaN: n,
    NumberParseInt: o,
    ObjectDefineProperties: s,
    ObjectKeys: a,
    ObjectSetPrototypeOf: l,
    Promise: u,
    SafeSet: f,
    SymbolAsyncDispose: c,
    SymbolAsyncIterator: d,
    Symbol: h
  } = Ft;
  Mb = B, B.ReadableState = ve;
  const { EventEmitter: p } = ur, { Stream: v, prependListener: y } = ox, { Buffer: w } = ft, { addAbortSignal: S } = Cp, x = vs;
  let E = Ur.debuglog("stream", (g) => {
    E = g;
  });
  const N = NJ, C = cu, { getHighWaterMark: j, getDefaultHighWaterMark: J } = Ip, {
    aggregateTwoErrors: z,
    codes: {
      ERR_INVALID_ARG_TYPE: $,
      ERR_METHOD_NOT_IMPLEMENTED: G,
      ERR_OUT_OF_RANGE: I,
      ERR_STREAM_PUSH_AFTER_EOF: W,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT: k
    },
    AbortError: U
  } = nn, { validateObject: Z } = vc, Y = h("kPaused"), { StringDecoder: re } = Vl(), ae = E5;
  l(B.prototype, v.prototype), l(B, v);
  const ce = () => {
  }, { errorOrDestroy: pe } = C, le = 1, ye = 2, H = 4, ge = 8, Ce = 16, ue = 32, ee = 64, be = 128, Te = 256, Pe = 512, K = 1024, V = 2048, b = 4096, _ = 8192, T = 16384, L = 32768, O = 65536, ie = 1 << 17, fe = 1 << 18;
  function se(g) {
    return {
      enumerable: !1,
      get() {
        return (this.state & g) !== 0;
      },
      set(m) {
        m ? this.state |= g : this.state &= ~g;
      }
    };
  }
  s(ve.prototype, {
    objectMode: se(le),
    ended: se(ye),
    endEmitted: se(H),
    reading: se(ge),
    // Stream is still being constructed and cannot be
    // destroyed until construction finished or failed.
    // Async construction is opt in, therefore we start as
    // constructed.
    constructed: se(Ce),
    // A flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    sync: se(ue),
    // Whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    needReadable: se(ee),
    emittedReadable: se(be),
    readableListening: se(Te),
    resumeScheduled: se(Pe),
    // True if the error was already emitted and should not be thrown again.
    errorEmitted: se(K),
    emitClose: se(V),
    autoDestroy: se(b),
    // Has it been destroyed.
    destroyed: se(_),
    // Indicates whether the stream has finished destroying.
    closed: se(T),
    // True if close has been emitted or would have been emitted
    // depending on emitClose.
    closeEmitted: se(L),
    multiAwaitDrain: se(O),
    // If true, a maybeReadMore has been scheduled.
    readingMore: se(ie),
    dataEmitted: se(fe)
  });
  function ve(g, m, F) {
    typeof F != "boolean" && (F = m instanceof oo()), this.state = V | b | Ce | ue, g && g.objectMode && (this.state |= le), F && g && g.readableObjectMode && (this.state |= le), this.highWaterMark = g ? j(this, g, "readableHighWaterMark", F) : J(!1), this.buffer = new N(), this.length = 0, this.pipes = [], this.flowing = null, this[Y] = null, g && g.emitClose === !1 && (this.state &= ~V), g && g.autoDestroy === !1 && (this.state &= ~b), this.errored = null, this.defaultEncoding = g && g.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, g && g.encoding && (this.decoder = new re(g.encoding), this.encoding = g.encoding);
  }
  function B(g) {
    if (!(this instanceof B))
      return new B(g);
    const m = this instanceof oo();
    this._readableState = new ve(g, this, m), g && (typeof g.read == "function" && (this._read = g.read), typeof g.destroy == "function" && (this._destroy = g.destroy), typeof g.construct == "function" && (this._construct = g.construct), g.signal && !m && S(g.signal, this)), v.call(this, g), C.construct(this, () => {
      this._readableState.needReadable && ne(this, this._readableState);
    });
  }
  B.prototype.destroy = C.destroy, B.prototype._undestroy = C.undestroy, B.prototype._destroy = function(g, m) {
    m(g);
  }, B.prototype[p.captureRejectionSymbol] = function(g) {
    this.destroy(g);
  }, B.prototype[c] = function() {
    let g;
    return this.destroyed || (g = this.readableEnded ? null : new U(), this.destroy(g)), new u((m, F) => x(this, (D) => D && D !== g ? F(D) : m(null)));
  }, B.prototype.push = function(g, m) {
    return me(this, g, m, !1);
  }, B.prototype.unshift = function(g, m) {
    return me(this, g, m, !0);
  };
  function me(g, m, F, D) {
    E("readableAddChunk", m);
    const X = g._readableState;
    let Le;
    if (X.state & le || (typeof m == "string" ? (F = F || X.defaultEncoding, X.encoding !== F && (D && X.encoding ? m = w.from(m, F).toString(X.encoding) : (m = w.from(m, F), F = ""))) : m instanceof w ? F = "" : v._isUint8Array(m) ? (m = v._uint8ArrayToBuffer(m), F = "") : m != null && (Le = new $("chunk", ["string", "Buffer", "Uint8Array"], m))), Le)
      pe(g, Le);
    else if (m === null)
      X.state &= ~ge, R(g, X);
    else if (X.state & le || m && m.length > 0)
      if (D)
        if (X.state & H)
          pe(g, new k());
        else {
          if (X.destroyed || X.errored)
            return !1;
          ke(g, X, m, !0);
        }
      else if (X.ended)
        pe(g, new W());
      else {
        if (X.destroyed || X.errored)
          return !1;
        X.state &= ~ge, X.decoder && !F ? (m = X.decoder.write(m), X.objectMode || m.length !== 0 ? ke(g, X, m, !1) : ne(g, X)) : ke(g, X, m, !1);
      }
    else
      D || (X.state &= ~ge, ne(g, X));
    return !X.ended && (X.length < X.highWaterMark || X.length === 0);
  }
  function ke(g, m, F, D) {
    m.flowing && m.length === 0 && !m.sync && g.listenerCount("data") > 0 ? (m.state & O ? m.awaitDrainWriters.clear() : m.awaitDrainWriters = null, m.dataEmitted = !0, g.emit("data", F)) : (m.length += m.objectMode ? 1 : F.length, D ? m.buffer.unshift(F) : m.buffer.push(F), m.state & ee && A(g)), ne(g, m);
  }
  B.prototype.isPaused = function() {
    const g = this._readableState;
    return g[Y] === !0 || g.flowing === !1;
  }, B.prototype.setEncoding = function(g) {
    const m = new re(g);
    this._readableState.decoder = m, this._readableState.encoding = this._readableState.decoder.encoding;
    const F = this._readableState.buffer;
    let D = "";
    for (const X of F)
      D += m.write(X);
    return F.clear(), D !== "" && F.push(D), this._readableState.length = D.length, this;
  };
  const Ie = 1073741824;
  function Me(g) {
    if (g > Ie)
      throw new I("size", "<= 1GiB", g);
    return g--, g |= g >>> 1, g |= g >>> 2, g |= g >>> 4, g |= g >>> 8, g |= g >>> 16, g++, g;
  }
  function M(g, m) {
    return g <= 0 || m.length === 0 && m.ended ? 0 : m.state & le ? 1 : n(g) ? m.flowing && m.length ? m.buffer.first().length : m.length : g <= m.length ? g : m.ended ? m.length : 0;
  }
  B.prototype.read = function(g) {
    E("read", g), g === void 0 ? g = NaN : r(g) || (g = o(g, 10));
    const m = this._readableState, F = g;
    if (g > m.highWaterMark && (m.highWaterMark = Me(g)), g !== 0 && (m.state &= ~be), g === 0 && m.needReadable && ((m.highWaterMark !== 0 ? m.length >= m.highWaterMark : m.length > 0) || m.ended))
      return E("read: emitReadable", m.length, m.ended), m.length === 0 && m.ended ? Tt(this) : A(this), null;
    if (g = M(g, m), g === 0 && m.ended)
      return m.length === 0 && Tt(this), null;
    let D = (m.state & ee) !== 0;
    if (E("need readable", D), (m.length === 0 || m.length - g < m.highWaterMark) && (D = !0, E("length less than watermark", D)), m.ended || m.reading || m.destroyed || m.errored || !m.constructed)
      D = !1, E("reading, ended or constructing", D);
    else if (D) {
      E("do read"), m.state |= ge | ue, m.length === 0 && (m.state |= ee);
      try {
        this._read(m.highWaterMark);
      } catch (Le) {
        pe(this, Le);
      }
      m.state &= ~ue, m.reading || (g = M(F, m));
    }
    let X;
    return g > 0 ? X = Lr(g, m) : X = null, X === null ? (m.needReadable = m.length <= m.highWaterMark, g = 0) : (m.length -= g, m.multiAwaitDrain ? m.awaitDrainWriters.clear() : m.awaitDrainWriters = null), m.length === 0 && (m.ended || (m.needReadable = !0), F !== g && m.ended && Tt(this)), X !== null && !m.errorEmitted && !m.closeEmitted && (m.dataEmitted = !0, this.emit("data", X)), X;
  };
  function R(g, m) {
    if (E("onEofChunk"), !m.ended) {
      if (m.decoder) {
        const F = m.decoder.end();
        F && F.length && (m.buffer.push(F), m.length += m.objectMode ? 1 : F.length);
      }
      m.ended = !0, m.sync ? A(g) : (m.needReadable = !1, m.emittedReadable = !0, q(g));
    }
  }
  function A(g) {
    const m = g._readableState;
    E("emitReadable", m.needReadable, m.emittedReadable), m.needReadable = !1, m.emittedReadable || (E("emitReadable", m.flowing), m.emittedReadable = !0, e.nextTick(q, g));
  }
  function q(g) {
    const m = g._readableState;
    E("emitReadable_", m.destroyed, m.length, m.ended), !m.destroyed && !m.errored && (m.length || m.ended) && (g.emit("readable"), m.emittedReadable = !1), m.needReadable = !m.flowing && !m.ended && m.length <= m.highWaterMark, et(g);
  }
  function ne(g, m) {
    !m.readingMore && m.constructed && (m.readingMore = !0, e.nextTick(de, g, m));
  }
  function de(g, m) {
    for (; !m.reading && !m.ended && (m.length < m.highWaterMark || m.flowing && m.length === 0); ) {
      const F = m.length;
      if (E("maybeReadMore read 0"), g.read(0), F === m.length)
        break;
    }
    m.readingMore = !1;
  }
  B.prototype._read = function(g) {
    throw new G("_read()");
  }, B.prototype.pipe = function(g, m) {
    const F = this, D = this._readableState;
    D.pipes.length === 1 && (D.multiAwaitDrain || (D.multiAwaitDrain = !0, D.awaitDrainWriters = new f(D.awaitDrainWriters ? [D.awaitDrainWriters] : []))), D.pipes.push(g), E("pipe count=%d opts=%j", D.pipes.length, m);
    const Le = (!m || m.end !== !1) && g !== e.stdout && g !== e.stderr ? Xt : Et;
    D.endEmitted ? e.nextTick(Le) : F.once("end", Le), g.on("unpipe", Ue);
    function Ue(ct, nt) {
      E("onunpipe"), ct === F && nt && nt.hasUnpiped === !1 && (nt.hasUnpiped = !0, yn());
    }
    function Xt() {
      E("onend"), g.end();
    }
    let ht, Kr = !1;
    function yn() {
      E("cleanup"), g.removeListener("close", or), g.removeListener("finish", dr), ht && g.removeListener("drain", ht), g.removeListener("error", cr), g.removeListener("unpipe", Ue), F.removeListener("end", Xt), F.removeListener("end", Et), F.removeListener("data", Ar), Kr = !0, ht && D.awaitDrainWriters && (!g._writableState || g._writableState.needDrain) && ht();
    }
    function Wt() {
      Kr || (D.pipes.length === 1 && D.pipes[0] === g ? (E("false write response, pause", 0), D.awaitDrainWriters = g, D.multiAwaitDrain = !1) : D.pipes.length > 1 && D.pipes.includes(g) && (E("false write response, pause", D.awaitDrainWriters.size), D.awaitDrainWriters.add(g)), F.pause()), ht || (ht = he(F, g), g.on("drain", ht));
    }
    F.on("data", Ar);
    function Ar(ct) {
      E("ondata");
      const nt = g.write(ct);
      E("dest.write", nt), nt === !1 && Wt();
    }
    function cr(ct) {
      if (E("onerror", ct), Et(), g.removeListener("error", cr), g.listenerCount("error") === 0) {
        const nt = g._writableState || g._readableState;
        nt && !nt.errorEmitted ? pe(g, ct) : g.emit("error", ct);
      }
    }
    y(g, "error", cr);
    function or() {
      g.removeListener("finish", dr), Et();
    }
    g.once("close", or);
    function dr() {
      E("onfinish"), g.removeListener("close", or), Et();
    }
    g.once("finish", dr);
    function Et() {
      E("unpipe"), F.unpipe(g);
    }
    return g.emit("pipe", F), g.writableNeedDrain === !0 ? Wt() : D.flowing || (E("pipe resume"), F.resume()), g;
  };
  function he(g, m) {
    return function() {
      const D = g._readableState;
      D.awaitDrainWriters === m ? (E("pipeOnDrain", 1), D.awaitDrainWriters = null) : D.multiAwaitDrain && (E("pipeOnDrain", D.awaitDrainWriters.size), D.awaitDrainWriters.delete(m)), (!D.awaitDrainWriters || D.awaitDrainWriters.size === 0) && g.listenerCount("data") && g.resume();
    };
  }
  B.prototype.unpipe = function(g) {
    const m = this._readableState, F = {
      hasUnpiped: !1
    };
    if (m.pipes.length === 0)
      return this;
    if (!g) {
      const X = m.pipes;
      m.pipes = [], this.pause();
      for (let Le = 0; Le < X.length; Le++)
        X[Le].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    const D = t(m.pipes, g);
    return D === -1 ? this : (m.pipes.splice(D, 1), m.pipes.length === 0 && this.pause(), g.emit("unpipe", this, F), this);
  }, B.prototype.on = function(g, m) {
    const F = v.prototype.on.call(this, g, m), D = this._readableState;
    return g === "data" ? (D.readableListening = this.listenerCount("readable") > 0, D.flowing !== !1 && this.resume()) : g === "readable" && !D.endEmitted && !D.readableListening && (D.readableListening = D.needReadable = !0, D.flowing = !1, D.emittedReadable = !1, E("on readable", D.length, D.reading), D.length ? A(this) : D.reading || e.nextTick(ot, this)), F;
  }, B.prototype.addListener = B.prototype.on, B.prototype.removeListener = function(g, m) {
    const F = v.prototype.removeListener.call(this, g, m);
    return g === "readable" && e.nextTick(Fe, this), F;
  }, B.prototype.off = B.prototype.removeListener, B.prototype.removeAllListeners = function(g) {
    const m = v.prototype.removeAllListeners.apply(this, arguments);
    return (g === "readable" || g === void 0) && e.nextTick(Fe, this), m;
  };
  function Fe(g) {
    const m = g._readableState;
    m.readableListening = g.listenerCount("readable") > 0, m.resumeScheduled && m[Y] === !1 ? m.flowing = !0 : g.listenerCount("data") > 0 ? g.resume() : m.readableListening || (m.flowing = null);
  }
  function ot(g) {
    E("readable nexttick read 0"), g.read(0);
  }
  B.prototype.resume = function() {
    const g = this._readableState;
    return g.flowing || (E("resume"), g.flowing = !g.readableListening, ze(this, g)), g[Y] = !1, this;
  };
  function ze(g, m) {
    m.resumeScheduled || (m.resumeScheduled = !0, e.nextTick(Ke, g, m));
  }
  function Ke(g, m) {
    E("resume", m.reading), m.reading || g.read(0), m.resumeScheduled = !1, g.emit("resume"), et(g), m.flowing && !m.reading && g.read(0);
  }
  B.prototype.pause = function() {
    return E("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (E("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState[Y] = !0, this;
  };
  function et(g) {
    const m = g._readableState;
    for (E("flow", m.flowing); m.flowing && g.read() !== null; )
      ;
  }
  B.prototype.wrap = function(g) {
    let m = !1;
    g.on("data", (D) => {
      !this.push(D) && g.pause && (m = !0, g.pause());
    }), g.on("end", () => {
      this.push(null);
    }), g.on("error", (D) => {
      pe(this, D);
    }), g.on("close", () => {
      this.destroy();
    }), g.on("destroy", () => {
      this.destroy();
    }), this._read = () => {
      m && g.resume && (m = !1, g.resume());
    };
    const F = a(g);
    for (let D = 1; D < F.length; D++) {
      const X = F[D];
      this[X] === void 0 && typeof g[X] == "function" && (this[X] = g[X].bind(g));
    }
    return this;
  }, B.prototype[d] = function() {
    return Rr(this);
  }, B.prototype.iterator = function(g) {
    return g !== void 0 && Z(g, "options"), Rr(this, g);
  };
  function Rr(g, m) {
    typeof g.read != "function" && (g = B.wrap(g, {
      objectMode: !0
    }));
    const F = Wi(g, m);
    return F.stream = g, F;
  }
  async function* Wi(g, m) {
    let F = ce;
    function D(Ue) {
      this === g ? (F(), F = ce) : F = Ue;
    }
    g.on("readable", D);
    let X;
    const Le = x(
      g,
      {
        writable: !1
      },
      (Ue) => {
        X = Ue ? z(X, Ue) : null, F(), F = ce;
      }
    );
    try {
      for (; ; ) {
        const Ue = g.destroyed ? null : g.read();
        if (Ue !== null)
          yield Ue;
        else {
          if (X)
            throw X;
          if (X === null)
            return;
          await new u(D);
        }
      }
    } catch (Ue) {
      throw X = z(X, Ue), X;
    } finally {
      (X || (m == null ? void 0 : m.destroyOnReturn) !== !1) && (X === void 0 || g._readableState.autoDestroy) ? C.destroyer(g, null) : (g.off("readable", D), Le());
    }
  }
  s(B.prototype, {
    readable: {
      __proto__: null,
      get() {
        const g = this._readableState;
        return !!g && g.readable !== !1 && !g.destroyed && !g.errorEmitted && !g.endEmitted;
      },
      set(g) {
        this._readableState && (this._readableState.readable = !!g);
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(g) {
        this._readableState && (this._readableState.flowing = g);
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.objectMode : !1;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.destroyed : !1;
      },
      set(g) {
        this._readableState && (this._readableState.destroyed = g);
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.endEmitted : !1;
      }
    }
  }), s(ve.prototype, {
    // Legacy getter for `pipesCount`.
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    // Legacy property for `paused`.
    paused: {
      __proto__: null,
      get() {
        return this[Y] !== !1;
      },
      set(g) {
        this[Y] = !!g;
      }
    }
  }), B._fromList = Lr;
  function Lr(g, m) {
    if (m.length === 0)
      return null;
    let F;
    return m.objectMode ? F = m.buffer.shift() : !g || g >= m.length ? (m.decoder ? F = m.buffer.join("") : m.buffer.length === 1 ? F = m.buffer.first() : F = m.buffer.concat(m.length), m.buffer.clear()) : F = m.buffer.consume(g, m.decoder), F;
  }
  function Tt(g) {
    const m = g._readableState;
    E("endReadable", m.endEmitted), m.endEmitted || (m.ended = !0, e.nextTick(si, m, g));
  }
  function si(g, m) {
    if (E("endReadableNT", g.endEmitted, g.length), !g.errored && !g.closeEmitted && !g.endEmitted && g.length === 0) {
      if (g.endEmitted = !0, m.emit("end"), m.writable && m.allowHalfOpen === !1)
        e.nextTick(Ui, m);
      else if (g.autoDestroy) {
        const F = m._writableState;
        (!F || F.autoDestroy && // We don't expect the writable to ever 'finish'
        // if writable is explicitly set to false.
        (F.finished || F.writable === !1)) && m.destroy();
      }
    }
  }
  function Ui(g) {
    g.writable && !g.writableEnded && !g.destroyed && g.end();
  }
  B.from = function(g, m) {
    return ae(B, g, m);
  };
  let Mt;
  function ln() {
    return Mt === void 0 && (Mt = {}), Mt;
  }
  return B.fromWeb = function(g, m) {
    return ln().newStreamReadableFromReadableStream(g, m);
  }, B.toWeb = function(g, m) {
    return ln().newReadableStreamFromStreamReadable(g, m);
  }, B.wrap = function(g, m) {
    var F, D;
    return new B({
      objectMode: (F = (D = g.readableObjectMode) !== null && D !== void 0 ? D : g.objectMode) !== null && F !== void 0 ? F : !0,
      ...m,
      destroy(X, Le) {
        C.destroyer(g, X), Le(X);
      }
    }).wrap(g);
  }, Mb;
}
var Ob, t$;
function sx() {
  if (t$)
    return Ob;
  t$ = 1;
  const e = St, {
    ArrayPrototypeSlice: t,
    Error: r,
    FunctionPrototypeSymbolHasInstance: n,
    ObjectDefineProperty: o,
    ObjectDefineProperties: s,
    ObjectSetPrototypeOf: a,
    StringPrototypeToLowerCase: l,
    Symbol: u,
    SymbolHasInstance: f
  } = Ft;
  Ob = Z, Z.WritableState = k;
  const { EventEmitter: c } = ur, d = ox.Stream, { Buffer: h } = ft, p = cu, { addAbortSignal: v } = Cp, { getHighWaterMark: y, getDefaultHighWaterMark: w } = Ip, {
    ERR_INVALID_ARG_TYPE: S,
    ERR_METHOD_NOT_IMPLEMENTED: x,
    ERR_MULTIPLE_CALLBACK: E,
    ERR_STREAM_CANNOT_PIPE: N,
    ERR_STREAM_DESTROYED: C,
    ERR_STREAM_ALREADY_FINISHED: j,
    ERR_STREAM_NULL_VALUES: J,
    ERR_STREAM_WRITE_AFTER_END: z,
    ERR_UNKNOWN_ENCODING: $
  } = nn.codes, { errorOrDestroy: G } = p;
  a(Z.prototype, d.prototype), a(Z, d);
  function I() {
  }
  const W = u("kOnFinished");
  function k(b, _, T) {
    typeof T != "boolean" && (T = _ instanceof oo()), this.objectMode = !!(b && b.objectMode), T && (this.objectMode = this.objectMode || !!(b && b.writableObjectMode)), this.highWaterMark = b ? y(this, b, "writableHighWaterMark", T) : w(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    const L = !!(b && b.decodeStrings === !1);
    this.decodeStrings = !L, this.defaultEncoding = b && b.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = pe.bind(void 0, _), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, U(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !b || b.emitClose !== !1, this.autoDestroy = !b || b.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[W] = [];
  }
  function U(b) {
    b.buffered = [], b.bufferedIndex = 0, b.allBuffers = !0, b.allNoop = !0;
  }
  k.prototype.getBuffer = function() {
    return t(this.buffered, this.bufferedIndex);
  }, o(k.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function Z(b) {
    const _ = this instanceof oo();
    if (!_ && !n(Z, this))
      return new Z(b);
    this._writableState = new k(b, this, _), b && (typeof b.write == "function" && (this._write = b.write), typeof b.writev == "function" && (this._writev = b.writev), typeof b.destroy == "function" && (this._destroy = b.destroy), typeof b.final == "function" && (this._final = b.final), typeof b.construct == "function" && (this._construct = b.construct), b.signal && v(b.signal, this)), d.call(this, b), p.construct(this, () => {
      const T = this._writableState;
      T.writing || ge(this, T), be(this, T);
    });
  }
  o(Z, f, {
    __proto__: null,
    value: function(b) {
      return n(this, b) ? !0 : this !== Z ? !1 : b && b._writableState instanceof k;
    }
  }), Z.prototype.pipe = function() {
    G(this, new N());
  };
  function Y(b, _, T, L) {
    const O = b._writableState;
    if (typeof T == "function")
      L = T, T = O.defaultEncoding;
    else {
      if (!T)
        T = O.defaultEncoding;
      else if (T !== "buffer" && !h.isEncoding(T))
        throw new $(T);
      typeof L != "function" && (L = I);
    }
    if (_ === null)
      throw new J();
    if (!O.objectMode)
      if (typeof _ == "string")
        O.decodeStrings !== !1 && (_ = h.from(_, T), T = "buffer");
      else if (_ instanceof h)
        T = "buffer";
      else if (d._isUint8Array(_))
        _ = d._uint8ArrayToBuffer(_), T = "buffer";
      else
        throw new S("chunk", ["string", "Buffer", "Uint8Array"], _);
    let ie;
    return O.ending ? ie = new z() : O.destroyed && (ie = new C("write")), ie ? (e.nextTick(L, ie), G(b, ie, !0), ie) : (O.pendingcb++, re(b, O, _, T, L));
  }
  Z.prototype.write = function(b, _, T) {
    return Y(this, b, _, T) === !0;
  }, Z.prototype.cork = function() {
    this._writableState.corked++;
  }, Z.prototype.uncork = function() {
    const b = this._writableState;
    b.corked && (b.corked--, b.writing || ge(this, b));
  }, Z.prototype.setDefaultEncoding = function(_) {
    if (typeof _ == "string" && (_ = l(_)), !h.isEncoding(_))
      throw new $(_);
    return this._writableState.defaultEncoding = _, this;
  };
  function re(b, _, T, L, O) {
    const ie = _.objectMode ? 1 : T.length;
    _.length += ie;
    const fe = _.length < _.highWaterMark;
    return fe || (_.needDrain = !0), _.writing || _.corked || _.errored || !_.constructed ? (_.buffered.push({
      chunk: T,
      encoding: L,
      callback: O
    }), _.allBuffers && L !== "buffer" && (_.allBuffers = !1), _.allNoop && O !== I && (_.allNoop = !1)) : (_.writelen = ie, _.writecb = O, _.writing = !0, _.sync = !0, b._write(T, L, _.onwrite), _.sync = !1), fe && !_.errored && !_.destroyed;
  }
  function ae(b, _, T, L, O, ie, fe) {
    _.writelen = L, _.writecb = fe, _.writing = !0, _.sync = !0, _.destroyed ? _.onwrite(new C("write")) : T ? b._writev(O, _.onwrite) : b._write(O, ie, _.onwrite), _.sync = !1;
  }
  function ce(b, _, T, L) {
    --_.pendingcb, L(T), H(_), G(b, T);
  }
  function pe(b, _) {
    const T = b._writableState, L = T.sync, O = T.writecb;
    if (typeof O != "function") {
      G(b, new E());
      return;
    }
    T.writing = !1, T.writecb = null, T.length -= T.writelen, T.writelen = 0, _ ? (_.stack, T.errored || (T.errored = _), b._readableState && !b._readableState.errored && (b._readableState.errored = _), L ? e.nextTick(ce, b, T, _, O) : ce(b, T, _, O)) : (T.buffered.length > T.bufferedIndex && ge(b, T), L ? T.afterWriteTickInfo !== null && T.afterWriteTickInfo.cb === O ? T.afterWriteTickInfo.count++ : (T.afterWriteTickInfo = {
      count: 1,
      cb: O,
      stream: b,
      state: T
    }, e.nextTick(le, T.afterWriteTickInfo)) : ye(b, T, 1, O));
  }
  function le({ stream: b, state: _, count: T, cb: L }) {
    return _.afterWriteTickInfo = null, ye(b, _, T, L);
  }
  function ye(b, _, T, L) {
    for (!_.ending && !b.destroyed && _.length === 0 && _.needDrain && (_.needDrain = !1, b.emit("drain")); T-- > 0; )
      _.pendingcb--, L();
    _.destroyed && H(_), be(b, _);
  }
  function H(b) {
    if (b.writing)
      return;
    for (let O = b.bufferedIndex; O < b.buffered.length; ++O) {
      var _;
      const { chunk: ie, callback: fe } = b.buffered[O], se = b.objectMode ? 1 : ie.length;
      b.length -= se, fe(
        (_ = b.errored) !== null && _ !== void 0 ? _ : new C("write")
      );
    }
    const T = b[W].splice(0);
    for (let O = 0; O < T.length; O++) {
      var L;
      T[O](
        (L = b.errored) !== null && L !== void 0 ? L : new C("end")
      );
    }
    U(b);
  }
  function ge(b, _) {
    if (_.corked || _.bufferProcessing || _.destroyed || !_.constructed)
      return;
    const { buffered: T, bufferedIndex: L, objectMode: O } = _, ie = T.length - L;
    if (!ie)
      return;
    let fe = L;
    if (_.bufferProcessing = !0, ie > 1 && b._writev) {
      _.pendingcb -= ie - 1;
      const se = _.allNoop ? I : (B) => {
        for (let me = fe; me < T.length; ++me)
          T[me].callback(B);
      }, ve = _.allNoop && fe === 0 ? T : t(T, fe);
      ve.allBuffers = _.allBuffers, ae(b, _, !0, _.length, ve, "", se), U(_);
    } else {
      do {
        const { chunk: se, encoding: ve, callback: B } = T[fe];
        T[fe++] = null;
        const me = O ? 1 : se.length;
        ae(b, _, !1, me, se, ve, B);
      } while (fe < T.length && !_.writing);
      fe === T.length ? U(_) : fe > 256 ? (T.splice(0, fe), _.bufferedIndex = 0) : _.bufferedIndex = fe;
    }
    _.bufferProcessing = !1;
  }
  Z.prototype._write = function(b, _, T) {
    if (this._writev)
      this._writev(
        [
          {
            chunk: b,
            encoding: _
          }
        ],
        T
      );
    else
      throw new x("_write()");
  }, Z.prototype._writev = null, Z.prototype.end = function(b, _, T) {
    const L = this._writableState;
    typeof b == "function" ? (T = b, b = null, _ = null) : typeof _ == "function" && (T = _, _ = null);
    let O;
    if (b != null) {
      const ie = Y(this, b, _);
      ie instanceof r && (O = ie);
    }
    return L.corked && (L.corked = 1, this.uncork()), O || (!L.errored && !L.ending ? (L.ending = !0, be(this, L, !0), L.ended = !0) : L.finished ? O = new j("end") : L.destroyed && (O = new C("end"))), typeof T == "function" && (O || L.finished ? e.nextTick(T, O) : L[W].push(T)), this;
  };
  function Ce(b) {
    return b.ending && !b.destroyed && b.constructed && b.length === 0 && !b.errored && b.buffered.length === 0 && !b.finished && !b.writing && !b.errorEmitted && !b.closeEmitted;
  }
  function ue(b, _) {
    let T = !1;
    function L(O) {
      if (T) {
        G(b, O ?? E());
        return;
      }
      if (T = !0, _.pendingcb--, O) {
        const ie = _[W].splice(0);
        for (let fe = 0; fe < ie.length; fe++)
          ie[fe](O);
        G(b, O, _.sync);
      } else
        Ce(_) && (_.prefinished = !0, b.emit("prefinish"), _.pendingcb++, e.nextTick(Te, b, _));
    }
    _.sync = !0, _.pendingcb++;
    try {
      b._final(L);
    } catch (O) {
      L(O);
    }
    _.sync = !1;
  }
  function ee(b, _) {
    !_.prefinished && !_.finalCalled && (typeof b._final == "function" && !_.destroyed ? (_.finalCalled = !0, ue(b, _)) : (_.prefinished = !0, b.emit("prefinish")));
  }
  function be(b, _, T) {
    Ce(_) && (ee(b, _), _.pendingcb === 0 && (T ? (_.pendingcb++, e.nextTick(
      (L, O) => {
        Ce(O) ? Te(L, O) : O.pendingcb--;
      },
      b,
      _
    )) : Ce(_) && (_.pendingcb++, Te(b, _))));
  }
  function Te(b, _) {
    _.pendingcb--, _.finished = !0;
    const T = _[W].splice(0);
    for (let L = 0; L < T.length; L++)
      T[L]();
    if (b.emit("finish"), _.autoDestroy) {
      const L = b._readableState;
      (!L || L.autoDestroy && // We don't expect the readable to ever 'end'
      // if readable is explicitly set to false.
      (L.endEmitted || L.readable === !1)) && b.destroy();
    }
  }
  s(Z.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : !1;
      },
      set(b) {
        this._writableState && (this._writableState.destroyed = b);
      }
    },
    writable: {
      __proto__: null,
      get() {
        const b = this._writableState;
        return !!b && b.writable !== !1 && !b.destroyed && !b.errored && !b.ending && !b.ended;
      },
      set(b) {
        this._writableState && (this._writableState.writable = !!b);
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : !1;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : !1;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : !1;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const b = this._writableState;
        return b ? !b.destroyed && !b.ending && b.needDrain : !1;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  const Pe = p.destroy;
  Z.prototype.destroy = function(b, _) {
    const T = this._writableState;
    return !T.destroyed && (T.bufferedIndex < T.buffered.length || T[W].length) && e.nextTick(H, T), Pe.call(this, b, _), this;
  }, Z.prototype._undestroy = p.undestroy, Z.prototype._destroy = function(b, _) {
    _(b);
  }, Z.prototype[c.captureRejectionSymbol] = function(b) {
    this.destroy(b);
  };
  let K;
  function V() {
    return K === void 0 && (K = {}), K;
  }
  return Z.fromWeb = function(b, _) {
    return V().newStreamWritableFromWritableStream(b, _);
  }, Z.toWeb = function(b) {
    return V().newWritableStreamFromStreamWritable(b);
  }, Ob;
}
var Lb, r$;
function UJ() {
  if (r$)
    return Lb;
  r$ = 1;
  const e = St, t = ft, {
    isReadable: r,
    isWritable: n,
    isIterable: o,
    isNodeStream: s,
    isReadableNodeStream: a,
    isWritableNodeStream: l,
    isDuplexNodeStream: u,
    isReadableStream: f,
    isWritableStream: c
  } = xo, d = vs, {
    AbortError: h,
    codes: { ERR_INVALID_ARG_TYPE: p, ERR_INVALID_RETURN_VALUE: v }
  } = nn, { destroyer: y } = cu, w = oo(), S = Mp(), x = sx(), { createDeferredPromise: E } = Ur, N = E5, C = globalThis.Blob || t.Blob, j = typeof C < "u" ? function(k) {
    return k instanceof C;
  } : function(k) {
    return !1;
  }, J = globalThis.AbortController || Kt().AbortController, { FunctionPrototypeCall: z } = Ft;
  class $ extends w {
    constructor(k) {
      super(k), (k == null ? void 0 : k.readable) === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), (k == null ? void 0 : k.writable) === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0);
    }
  }
  Lb = function W(k, U) {
    if (u(k))
      return k;
    if (a(k))
      return I({
        readable: k
      });
    if (l(k))
      return I({
        writable: k
      });
    if (s(k))
      return I({
        writable: !1,
        readable: !1
      });
    if (f(k))
      return I({
        readable: S.fromWeb(k)
      });
    if (c(k))
      return I({
        writable: x.fromWeb(k)
      });
    if (typeof k == "function") {
      const { value: Y, write: re, final: ae, destroy: ce } = G(k);
      if (o(Y))
        return N($, Y, {
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          write: re,
          final: ae,
          destroy: ce
        });
      const pe = Y == null ? void 0 : Y.then;
      if (typeof pe == "function") {
        let le;
        const ye = z(
          pe,
          Y,
          (H) => {
            if (H != null)
              throw new v("nully", "body", H);
          },
          (H) => {
            y(le, H);
          }
        );
        return le = new $({
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          readable: !1,
          write: re,
          final(H) {
            ae(async () => {
              try {
                await ye, e.nextTick(H, null);
              } catch (ge) {
                e.nextTick(H, ge);
              }
            });
          },
          destroy: ce
        });
      }
      throw new v("Iterable, AsyncIterable or AsyncFunction", U, Y);
    }
    if (j(k))
      return W(k.arrayBuffer());
    if (o(k))
      return N($, k, {
        // TODO (ronag): highWaterMark?
        objectMode: !0,
        writable: !1
      });
    if (f(k == null ? void 0 : k.readable) && c(k == null ? void 0 : k.writable))
      return $.fromWeb(k);
    if (typeof (k == null ? void 0 : k.writable) == "object" || typeof (k == null ? void 0 : k.readable) == "object") {
      const Y = k != null && k.readable ? a(k == null ? void 0 : k.readable) ? k == null ? void 0 : k.readable : W(k.readable) : void 0, re = k != null && k.writable ? l(k == null ? void 0 : k.writable) ? k == null ? void 0 : k.writable : W(k.writable) : void 0;
      return I({
        readable: Y,
        writable: re
      });
    }
    const Z = k == null ? void 0 : k.then;
    if (typeof Z == "function") {
      let Y;
      return z(
        Z,
        k,
        (re) => {
          re != null && Y.push(re), Y.push(null);
        },
        (re) => {
          y(Y, re);
        }
      ), Y = new $({
        objectMode: !0,
        writable: !1,
        read() {
        }
      });
    }
    throw new p(
      U,
      [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise"
      ],
      k
    );
  };
  function G(W) {
    let { promise: k, resolve: U } = E();
    const Z = new J(), Y = Z.signal;
    return {
      value: W(
        async function* () {
          for (; ; ) {
            const ae = k;
            k = null;
            const { chunk: ce, done: pe, cb: le } = await ae;
            if (e.nextTick(le), pe)
              return;
            if (Y.aborted)
              throw new h(void 0, {
                cause: Y.reason
              });
            ({ promise: k, resolve: U } = E()), yield ce;
          }
        }(),
        {
          signal: Y
        }
      ),
      write(ae, ce, pe) {
        const le = U;
        U = null, le({
          chunk: ae,
          done: !1,
          cb: pe
        });
      },
      final(ae) {
        const ce = U;
        U = null, ce({
          done: !0,
          cb: ae
        });
      },
      destroy(ae, ce) {
        Z.abort(), ce(ae);
      }
    };
  }
  function I(W) {
    const k = W.readable && typeof W.readable.read != "function" ? S.wrap(W.readable) : W.readable, U = W.writable;
    let Z = !!r(k), Y = !!n(U), re, ae, ce, pe, le;
    function ye(H) {
      const ge = pe;
      pe = null, ge ? ge(H) : H && le.destroy(H);
    }
    return le = new $({
      // TODO (ronag): highWaterMark?
      readableObjectMode: !!(k != null && k.readableObjectMode),
      writableObjectMode: !!(U != null && U.writableObjectMode),
      readable: Z,
      writable: Y
    }), Y && (d(U, (H) => {
      Y = !1, H && y(k, H), ye(H);
    }), le._write = function(H, ge, Ce) {
      U.write(H, ge) ? Ce() : re = Ce;
    }, le._final = function(H) {
      U.end(), ae = H;
    }, U.on("drain", function() {
      if (re) {
        const H = re;
        re = null, H();
      }
    }), U.on("finish", function() {
      if (ae) {
        const H = ae;
        ae = null, H();
      }
    })), Z && (d(k, (H) => {
      Z = !1, H && y(k, H), ye(H);
    }), k.on("readable", function() {
      if (ce) {
        const H = ce;
        ce = null, H();
      }
    }), k.on("end", function() {
      le.push(null);
    }), le._read = function() {
      for (; ; ) {
        const H = k.read();
        if (H === null) {
          ce = le._read;
          return;
        }
        if (!le.push(H))
          return;
      }
    }), le._destroy = function(H, ge) {
      !H && pe !== null && (H = new h()), ce = null, re = null, ae = null, pe === null ? ge(H) : (pe = ge, y(U, H), y(k, H));
    }, le;
  }
  return Lb;
}
var Pb, n$;
function oo() {
  if (n$)
    return Pb;
  n$ = 1;
  const {
    ObjectDefineProperties: e,
    ObjectGetOwnPropertyDescriptor: t,
    ObjectKeys: r,
    ObjectSetPrototypeOf: n
  } = Ft;
  Pb = a;
  const o = Mp(), s = sx();
  n(a.prototype, o.prototype), n(a, o);
  {
    const c = r(s.prototype);
    for (let d = 0; d < c.length; d++) {
      const h = c[d];
      a.prototype[h] || (a.prototype[h] = s.prototype[h]);
    }
  }
  function a(c) {
    if (!(this instanceof a))
      return new a(c);
    o.call(this, c), s.call(this, c), c ? (this.allowHalfOpen = c.allowHalfOpen !== !1, c.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), c.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0)) : this.allowHalfOpen = !0;
  }
  e(a.prototype, {
    writable: {
      __proto__: null,
      ...t(s.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...t(s.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...t(s.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...t(s.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...t(s.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...t(s.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...t(s.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...t(s.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...t(s.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
      },
      set(c) {
        this._readableState && this._writableState && (this._readableState.destroyed = c, this._writableState.destroyed = c);
      }
    }
  });
  let l;
  function u() {
    return l === void 0 && (l = {}), l;
  }
  a.fromWeb = function(c, d) {
    return u().newStreamDuplexFromReadableWritablePair(c, d);
  }, a.toWeb = function(c) {
    return u().newReadableWritablePairFromDuplex(c);
  };
  let f;
  return a.from = function(c) {
    return f || (f = UJ()), f(c, "body");
  }, Pb;
}
const { ObjectSetPrototypeOf: x5, Symbol: HJ } = Ft;
var R5 = so;
const { ERR_METHOD_NOT_IMPLEMENTED: VJ } = nn.codes, ax = oo(), { getHighWaterMark: zJ } = Ip;
x5(so.prototype, ax.prototype);
x5(so, ax);
const Sf = HJ("kCallback");
function so(e) {
  if (!(this instanceof so))
    return new so(e);
  const t = e ? zJ(this, e, "readableHighWaterMark", !0) : null;
  t === 0 && (e = {
    ...e,
    highWaterMark: null,
    readableHighWaterMark: t,
    // TODO (ronag): 0 is not optimal since we have
    // a "bug" where we check needDrain before calling _write and not after.
    // Refs: https://github.com/nodejs/node/pull/32887
    // Refs: https://github.com/nodejs/node/pull/35941
    writableHighWaterMark: e.writableHighWaterMark || 0
  }), ax.call(this, e), this._readableState.sync = !1, this[Sf] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", GJ);
}
function J1(e) {
  typeof this._flush == "function" && !this.destroyed ? this._flush((t, r) => {
    if (t) {
      e ? e(t) : this.destroy(t);
      return;
    }
    r != null && this.push(r), this.push(null), e && e();
  }) : (this.push(null), e && e());
}
function GJ() {
  this._final !== J1 && J1.call(this);
}
so.prototype._final = J1;
so.prototype._transform = function(e, t, r) {
  throw new VJ("_transform()");
};
so.prototype._write = function(e, t, r) {
  const n = this._readableState, o = this._writableState, s = n.length;
  this._transform(e, t, (a, l) => {
    if (a) {
      r(a);
      return;
    }
    l != null && this.push(l), o.ended || // Backwards compat.
    s === n.length || // Backwards compat.
    n.length < n.highWaterMark ? r() : this[Sf] = r;
  });
};
so.prototype._read = function() {
  if (this[Sf]) {
    const e = this[Sf];
    this[Sf] = null, e();
  }
};
const { ObjectSetPrototypeOf: A5 } = Ft;
var T5 = zl;
const lx = R5;
A5(zl.prototype, lx.prototype);
A5(zl, lx);
function zl(e) {
  if (!(this instanceof zl))
    return new zl(e);
  lx.call(this, e);
}
zl.prototype._transform = function(e, t, r) {
  r(null, e);
};
const Yu = St, { ArrayIsArray: KJ, Promise: YJ, SymbolAsyncIterator: XJ, SymbolDispose: JJ } = Ft, gh = vs, { once: QJ } = Ur, ZJ = cu, i$ = oo(), {
  aggregateTwoErrors: eQ,
  codes: {
    ERR_INVALID_ARG_TYPE: Q1,
    ERR_INVALID_RETURN_VALUE: Db,
    ERR_MISSING_ARGS: tQ,
    ERR_STREAM_DESTROYED: rQ,
    ERR_STREAM_PREMATURE_CLOSE: nQ
  },
  AbortError: iQ
} = nn, { validateFunction: oQ, validateAbortSignal: sQ } = vc, {
  isIterable: js,
  isReadable: Fb,
  isReadableNodeStream: Bd,
  isNodeStream: o$,
  isTransformStream: bl,
  isWebStream: aQ,
  isReadableStream: jb,
  isReadableFinished: lQ
} = xo, uQ = globalThis.AbortController || Kt().AbortController;
let Bb, qb, Wb;
function s$(e, t, r) {
  let n = !1;
  e.on("close", () => {
    n = !0;
  });
  const o = gh(
    e,
    {
      readable: t,
      writable: r
    },
    (s) => {
      n = !s;
    }
  );
  return {
    destroy: (s) => {
      n || (n = !0, ZJ.destroyer(e, s || new rQ("pipe")));
    },
    cleanup: o
  };
}
function fQ(e) {
  return oQ(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
}
function Ub(e) {
  if (js(e))
    return e;
  if (Bd(e))
    return cQ(e);
  throw new Q1("val", ["Readable", "Iterable", "AsyncIterable"], e);
}
async function* cQ(e) {
  qb || (qb = Mp()), yield* qb.prototype[XJ].call(e);
}
async function Zc(e, t, r, { end: n }) {
  let o, s = null;
  const a = (f) => {
    if (f && (o = f), s) {
      const c = s;
      s = null, c();
    }
  }, l = () => new YJ((f, c) => {
    o ? c(o) : s = () => {
      o ? c(o) : f();
    };
  });
  t.on("drain", a);
  const u = gh(
    t,
    {
      readable: !1
    },
    a
  );
  try {
    t.writableNeedDrain && await l();
    for await (const f of e)
      t.write(f) || await l();
    n && (t.end(), await l()), r();
  } catch (f) {
    r(o !== f ? eQ(o, f) : f);
  } finally {
    u(), t.off("drain", a);
  }
}
async function Hb(e, t, r, { end: n }) {
  bl(t) && (t = t.writable);
  const o = t.getWriter();
  try {
    for await (const s of e)
      await o.ready, o.write(s).catch(() => {
      });
    await o.ready, n && await o.close(), r();
  } catch (s) {
    try {
      await o.abort(s), r(s);
    } catch (a) {
      r(a);
    }
  }
}
function dQ(...e) {
  return $5(e, QJ(fQ(e)));
}
function $5(e, t, r) {
  if (e.length === 1 && KJ(e[0]) && (e = e[0]), e.length < 2)
    throw new tQ("streams");
  const n = new uQ(), o = n.signal, s = r == null ? void 0 : r.signal, a = [];
  sQ(s, "options.signal");
  function l() {
    v(new iQ());
  }
  Wb = Wb || Ur.addAbortListener;
  let u;
  s && (u = Wb(s, l));
  let f, c;
  const d = [];
  let h = 0;
  function p(x) {
    v(x, --h === 0);
  }
  function v(x, E) {
    var N;
    if (x && (!f || f.code === "ERR_STREAM_PREMATURE_CLOSE") && (f = x), !(!f && !E)) {
      for (; d.length; )
        d.shift()(f);
      (N = u) === null || N === void 0 || N[JJ](), n.abort(), E && (f || a.forEach((C) => C()), Yu.nextTick(t, f, c));
    }
  }
  let y;
  for (let x = 0; x < e.length; x++) {
    const E = e[x], N = x < e.length - 1, C = x > 0, j = N || (r == null ? void 0 : r.end) !== !1, J = x === e.length - 1;
    if (o$(E)) {
      let z = function($) {
        $ && $.name !== "AbortError" && $.code !== "ERR_STREAM_PREMATURE_CLOSE" && p($);
      };
      if (j) {
        const { destroy: $, cleanup: G } = s$(E, N, C);
        d.push($), Fb(E) && J && a.push(G);
      }
      E.on("error", z), Fb(E) && J && a.push(() => {
        E.removeListener("error", z);
      });
    }
    if (x === 0)
      if (typeof E == "function") {
        if (y = E({
          signal: o
        }), !js(y))
          throw new Db("Iterable, AsyncIterable or Stream", "source", y);
      } else
        js(E) || Bd(E) || bl(E) ? y = E : y = i$.from(E);
    else if (typeof E == "function") {
      if (bl(y)) {
        var w;
        y = Ub((w = y) === null || w === void 0 ? void 0 : w.readable);
      } else
        y = Ub(y);
      if (y = E(y, {
        signal: o
      }), N) {
        if (!js(y, !0))
          throw new Db("AsyncIterable", `transform[${x - 1}]`, y);
      } else {
        var S;
        Bb || (Bb = T5);
        const z = new Bb({
          objectMode: !0
        }), $ = (S = y) === null || S === void 0 ? void 0 : S.then;
        if (typeof $ == "function")
          h++, $.call(
            y,
            (W) => {
              c = W, W != null && z.write(W), j && z.end(), Yu.nextTick(p);
            },
            (W) => {
              z.destroy(W), Yu.nextTick(p, W);
            }
          );
        else if (js(y, !0))
          h++, Zc(y, z, p, {
            end: j
          });
        else if (jb(y) || bl(y)) {
          const W = y.readable || y;
          h++, Zc(W, z, p, {
            end: j
          });
        } else
          throw new Db("AsyncIterable or Promise", "destination", y);
        y = z;
        const { destroy: G, cleanup: I } = s$(y, !1, !0);
        d.push(G), J && a.push(I);
      }
    } else if (o$(E)) {
      if (Bd(y)) {
        h += 2;
        const z = hQ(y, E, p, {
          end: j
        });
        Fb(E) && J && a.push(z);
      } else if (bl(y) || jb(y)) {
        const z = y.readable || y;
        h++, Zc(z, E, p, {
          end: j
        });
      } else if (js(y))
        h++, Zc(y, E, p, {
          end: j
        });
      else
        throw new Q1(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          y
        );
      y = E;
    } else if (aQ(E)) {
      if (Bd(y))
        h++, Hb(Ub(y), E, p, {
          end: j
        });
      else if (jb(y) || js(y))
        h++, Hb(y, E, p, {
          end: j
        });
      else if (bl(y))
        h++, Hb(y.readable, E, p, {
          end: j
        });
      else
        throw new Q1(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          y
        );
      y = E;
    } else
      y = i$.from(E);
  }
  return (o != null && o.aborted || s != null && s.aborted) && Yu.nextTick(l), y;
}
function hQ(e, t, r, { end: n }) {
  let o = !1;
  if (t.on("close", () => {
    o || r(new nQ());
  }), e.pipe(t, {
    end: !1
  }), n) {
    let s = function() {
      o = !0, t.end();
    };
    lQ(e) ? Yu.nextTick(s) : e.once("end", s);
  } else
    r();
  return gh(
    e,
    {
      readable: !0,
      writable: !1
    },
    (s) => {
      const a = e._readableState;
      s && s.code === "ERR_STREAM_PREMATURE_CLOSE" && a && a.ended && !a.errored && !a.errorEmitted ? e.once("end", r).once("error", r) : r(s);
    }
  ), gh(
    t,
    {
      readable: !1,
      writable: !0
    },
    r
  );
}
var ux = {
  pipelineImpl: $5,
  pipeline: dQ
};
const { pipeline: pQ } = ux, ed = oo(), { destroyer: gQ } = cu, {
  isNodeStream: td,
  isReadable: a$,
  isWritable: l$,
  isWebStream: Vb,
  isTransformStream: Is,
  isWritableStream: u$,
  isReadableStream: f$
} = xo, {
  AbortError: bQ,
  codes: { ERR_INVALID_ARG_VALUE: c$, ERR_MISSING_ARGS: yQ }
} = nn, vQ = vs;
var N5 = function(...t) {
  if (t.length === 0)
    throw new yQ("streams");
  if (t.length === 1)
    return ed.from(t[0]);
  const r = [...t];
  if (typeof t[0] == "function" && (t[0] = ed.from(t[0])), typeof t[t.length - 1] == "function") {
    const p = t.length - 1;
    t[p] = ed.from(t[p]);
  }
  for (let p = 0; p < t.length; ++p)
    if (!(!td(t[p]) && !Vb(t[p]))) {
      if (p < t.length - 1 && !(a$(t[p]) || f$(t[p]) || Is(t[p])))
        throw new c$(`streams[${p}]`, r[p], "must be readable");
      if (p > 0 && !(l$(t[p]) || u$(t[p]) || Is(t[p])))
        throw new c$(`streams[${p}]`, r[p], "must be writable");
    }
  let n, o, s, a, l;
  function u(p) {
    const v = a;
    a = null, v ? v(p) : p ? l.destroy(p) : !h && !d && l.destroy();
  }
  const f = t[0], c = pQ(t, u), d = !!(l$(f) || u$(f) || Is(f)), h = !!(a$(c) || f$(c) || Is(c));
  if (l = new ed({
    // TODO (ronag): highWaterMark?
    writableObjectMode: !!(f != null && f.writableObjectMode),
    readableObjectMode: !!(c != null && c.readableObjectMode),
    writable: d,
    readable: h
  }), d) {
    if (td(f))
      l._write = function(v, y, w) {
        f.write(v, y) ? w() : n = w;
      }, l._final = function(v) {
        f.end(), o = v;
      }, f.on("drain", function() {
        if (n) {
          const v = n;
          n = null, v();
        }
      });
    else if (Vb(f)) {
      const y = (Is(f) ? f.writable : f).getWriter();
      l._write = async function(w, S, x) {
        try {
          await y.ready, y.write(w).catch(() => {
          }), x();
        } catch (E) {
          x(E);
        }
      }, l._final = async function(w) {
        try {
          await y.ready, y.close().catch(() => {
          }), o = w;
        } catch (S) {
          w(S);
        }
      };
    }
    const p = Is(c) ? c.readable : c;
    vQ(p, () => {
      if (o) {
        const v = o;
        o = null, v();
      }
    });
  }
  if (h) {
    if (td(c))
      c.on("readable", function() {
        if (s) {
          const p = s;
          s = null, p();
        }
      }), c.on("end", function() {
        l.push(null);
      }), l._read = function() {
        for (; ; ) {
          const p = c.read();
          if (p === null) {
            s = l._read;
            return;
          }
          if (!l.push(p))
            return;
        }
      };
    else if (Vb(c)) {
      const v = (Is(c) ? c.readable : c).getReader();
      l._read = async function() {
        for (; ; )
          try {
            const { value: y, done: w } = await v.read();
            if (!l.push(y))
              return;
            if (w) {
              l.push(null);
              return;
            }
          } catch {
            return;
          }
      };
    }
  }
  return l._destroy = function(p, v) {
    !p && a !== null && (p = new bQ()), s = null, n = null, o = null, a === null ? v(p) : (a = v, td(c) && gQ(c, p));
  }, l;
};
const mQ = globalThis.AbortController || Kt().AbortController, {
  codes: { ERR_INVALID_ARG_VALUE: _Q, ERR_INVALID_ARG_TYPE: mc, ERR_MISSING_ARGS: wQ, ERR_OUT_OF_RANGE: SQ },
  AbortError: Ti
} = nn, { validateAbortSignal: Ba, validateInteger: d$, validateObject: qa } = vc, EQ = Ft.Symbol("kWeak"), xQ = Ft.Symbol("kResistStopPropagation"), { finished: RQ } = vs, AQ = N5, { addAbortSignalNoValidate: TQ } = Cp, { isWritable: $Q, isNodeStream: NQ } = xo, { deprecate: kQ } = Ur, {
  ArrayPrototypePush: CQ,
  Boolean: IQ,
  MathFloor: h$,
  Number: MQ,
  NumberIsNaN: OQ,
  Promise: p$,
  PromiseReject: g$,
  PromiseResolve: LQ,
  PromisePrototypeThen: b$,
  Symbol: k5
} = Ft, bh = k5("kEmpty"), y$ = k5("kEof");
function PQ(e, t) {
  if (t != null && qa(t, "options"), (t == null ? void 0 : t.signal) != null && Ba(t.signal, "options.signal"), NQ(e) && !$Q(e))
    throw new _Q("stream", e, "must be writable");
  const r = AQ(this, e);
  return t != null && t.signal && TQ(t.signal, r), r;
}
function Op(e, t) {
  if (typeof e != "function")
    throw new mc("fn", ["Function", "AsyncFunction"], e);
  t != null && qa(t, "options"), (t == null ? void 0 : t.signal) != null && Ba(t.signal, "options.signal");
  let r = 1;
  (t == null ? void 0 : t.concurrency) != null && (r = h$(t.concurrency));
  let n = r - 1;
  return (t == null ? void 0 : t.highWaterMark) != null && (n = h$(t.highWaterMark)), d$(r, "options.concurrency", 1), d$(n, "options.highWaterMark", 0), n += r, (async function* () {
    const s = Ur.AbortSignalAny(
      [t == null ? void 0 : t.signal].filter(IQ)
    ), a = this, l = [], u = {
      signal: s
    };
    let f, c, d = !1, h = 0;
    function p() {
      d = !0, v();
    }
    function v() {
      h -= 1, y();
    }
    function y() {
      c && !d && h < r && l.length < n && (c(), c = null);
    }
    async function w() {
      try {
        for await (let S of a) {
          if (d)
            return;
          if (s.aborted)
            throw new Ti();
          try {
            if (S = e(S, u), S === bh)
              continue;
            S = LQ(S);
          } catch (x) {
            S = g$(x);
          }
          h += 1, b$(S, v, p), l.push(S), f && (f(), f = null), !d && (l.length >= n || h >= r) && await new p$((x) => {
            c = x;
          });
        }
        l.push(y$);
      } catch (S) {
        const x = g$(S);
        b$(x, v, p), l.push(x);
      } finally {
        d = !0, f && (f(), f = null);
      }
    }
    w();
    try {
      for (; ; ) {
        for (; l.length > 0; ) {
          const S = await l[0];
          if (S === y$)
            return;
          if (s.aborted)
            throw new Ti();
          S !== bh && (yield S), l.shift(), y();
        }
        await new p$((S) => {
          f = S;
        });
      }
    } finally {
      d = !0, c && (c(), c = null);
    }
  }).call(this);
}
function DQ(e = void 0) {
  return e != null && qa(e, "options"), (e == null ? void 0 : e.signal) != null && Ba(e.signal, "options.signal"), (async function* () {
    let r = 0;
    for await (const o of this) {
      var n;
      if (e != null && (n = e.signal) !== null && n !== void 0 && n.aborted)
        throw new Ti({
          cause: e.signal.reason
        });
      yield [r++, o];
    }
  }).call(this);
}
async function C5(e, t = void 0) {
  for await (const r of fx.call(this, e, t))
    return !0;
  return !1;
}
async function FQ(e, t = void 0) {
  if (typeof e != "function")
    throw new mc("fn", ["Function", "AsyncFunction"], e);
  return !await C5.call(
    this,
    async (...r) => !await e(...r),
    t
  );
}
async function jQ(e, t) {
  for await (const r of fx.call(this, e, t))
    return r;
}
async function BQ(e, t) {
  if (typeof e != "function")
    throw new mc("fn", ["Function", "AsyncFunction"], e);
  async function r(n, o) {
    return await e(n, o), bh;
  }
  for await (const n of Op.call(this, r, t))
    ;
}
function fx(e, t) {
  if (typeof e != "function")
    throw new mc("fn", ["Function", "AsyncFunction"], e);
  async function r(n, o) {
    return await e(n, o) ? n : bh;
  }
  return Op.call(this, r, t);
}
let qQ = class extends wQ {
  constructor() {
    super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
  }
};
async function WQ(e, t, r) {
  var n;
  if (typeof e != "function")
    throw new mc("reducer", ["Function", "AsyncFunction"], e);
  r != null && qa(r, "options"), (r == null ? void 0 : r.signal) != null && Ba(r.signal, "options.signal");
  let o = arguments.length > 1;
  if (r != null && (n = r.signal) !== null && n !== void 0 && n.aborted) {
    const f = new Ti(void 0, {
      cause: r.signal.reason
    });
    throw this.once("error", () => {
    }), await RQ(this.destroy(f)), f;
  }
  const s = new mQ(), a = s.signal;
  if (r != null && r.signal) {
    const f = {
      once: !0,
      [EQ]: this,
      [xQ]: !0
    };
    r.signal.addEventListener("abort", () => s.abort(), f);
  }
  let l = !1;
  try {
    for await (const f of this) {
      var u;
      if (l = !0, r != null && (u = r.signal) !== null && u !== void 0 && u.aborted)
        throw new Ti();
      o ? t = await e(t, f, {
        signal: a
      }) : (t = f, o = !0);
    }
    if (!l && !o)
      throw new qQ();
  } finally {
    s.abort();
  }
  return t;
}
async function UQ(e) {
  e != null && qa(e, "options"), (e == null ? void 0 : e.signal) != null && Ba(e.signal, "options.signal");
  const t = [];
  for await (const n of this) {
    var r;
    if (e != null && (r = e.signal) !== null && r !== void 0 && r.aborted)
      throw new Ti(void 0, {
        cause: e.signal.reason
      });
    CQ(t, n);
  }
  return t;
}
function HQ(e, t) {
  const r = Op.call(this, e, t);
  return (async function* () {
    for await (const o of r)
      yield* o;
  }).call(this);
}
function I5(e) {
  if (e = MQ(e), OQ(e))
    return 0;
  if (e < 0)
    throw new SQ("number", ">= 0", e);
  return e;
}
function VQ(e, t = void 0) {
  return t != null && qa(t, "options"), (t == null ? void 0 : t.signal) != null && Ba(t.signal, "options.signal"), e = I5(e), (async function* () {
    var n;
    if (t != null && (n = t.signal) !== null && n !== void 0 && n.aborted)
      throw new Ti();
    for await (const s of this) {
      var o;
      if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
        throw new Ti();
      e-- <= 0 && (yield s);
    }
  }).call(this);
}
function zQ(e, t = void 0) {
  return t != null && qa(t, "options"), (t == null ? void 0 : t.signal) != null && Ba(t.signal, "options.signal"), e = I5(e), (async function* () {
    var n;
    if (t != null && (n = t.signal) !== null && n !== void 0 && n.aborted)
      throw new Ti();
    for await (const s of this) {
      var o;
      if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
        throw new Ti();
      if (e-- > 0 && (yield s), e <= 0)
        return;
    }
  }).call(this);
}
ex.streamReturningOperators = {
  asIndexedPairs: kQ(DQ, "readable.asIndexedPairs will be removed in a future version."),
  drop: VQ,
  filter: fx,
  flatMap: HQ,
  map: Op,
  take: zQ,
  compose: PQ
};
ex.promiseReturningOperators = {
  every: FQ,
  forEach: BQ,
  reduce: WQ,
  toArray: UQ,
  some: C5,
  find: jQ
};
var zb, v$;
function M5() {
  if (v$)
    return zb;
  v$ = 1;
  const { ArrayPrototypePop: e, Promise: t } = Ft, { isIterable: r, isNodeStream: n, isWebStream: o } = xo, { pipelineImpl: s } = ux, { finished: a } = vs;
  O5();
  function l(...u) {
    return new t((f, c) => {
      let d, h;
      const p = u[u.length - 1];
      if (p && typeof p == "object" && !n(p) && !r(p) && !o(p)) {
        const v = e(u);
        d = v.signal, h = v.end;
      }
      s(
        u,
        (v, y) => {
          v ? c(v) : f(y);
        },
        {
          signal: d,
          end: h
        }
      );
    });
  }
  return zb = {
    finished: a,
    pipeline: l
  }, zb;
}
var m$;
function O5() {
  if (m$)
    return $b.exports;
  m$ = 1;
  const { Buffer: e } = ft, { ObjectDefineProperty: t, ObjectKeys: r, ReflectApply: n } = Ft, {
    promisify: { custom: o }
  } = Ur, { streamReturningOperators: s, promiseReturningOperators: a } = ex, {
    codes: { ERR_ILLEGAL_CONSTRUCTOR: l }
  } = nn, u = N5, { setDefaultHighWaterMark: f, getDefaultHighWaterMark: c } = Ip, { pipeline: d } = ux, { destroyer: h } = cu, p = vs, v = M5(), y = xo, w = $b.exports = ox.Stream;
  w.isDestroyed = y.isDestroyed, w.isDisturbed = y.isDisturbed, w.isErrored = y.isErrored, w.isReadable = y.isReadable, w.isWritable = y.isWritable, w.Readable = Mp();
  for (const x of r(s)) {
    let N = function(...C) {
      if (new.target)
        throw l();
      return w.Readable.from(n(E, this, C));
    };
    const E = s[x];
    t(N, "name", {
      __proto__: null,
      value: E.name
    }), t(N, "length", {
      __proto__: null,
      value: E.length
    }), t(w.Readable.prototype, x, {
      __proto__: null,
      value: N,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  for (const x of r(a)) {
    let N = function(...C) {
      if (new.target)
        throw l();
      return n(E, this, C);
    };
    const E = a[x];
    t(N, "name", {
      __proto__: null,
      value: E.name
    }), t(N, "length", {
      __proto__: null,
      value: E.length
    }), t(w.Readable.prototype, x, {
      __proto__: null,
      value: N,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  w.Writable = sx(), w.Duplex = oo(), w.Transform = R5, w.PassThrough = T5, w.pipeline = d;
  const { addAbortSignal: S } = Cp;
  return w.addAbortSignal = S, w.finished = p, w.destroy = h, w.compose = u, w.setDefaultHighWaterMark = f, w.getDefaultHighWaterMark = c, t(w, "promises", {
    __proto__: null,
    configurable: !0,
    enumerable: !0,
    get() {
      return v;
    }
  }), t(d, o, {
    __proto__: null,
    enumerable: !0,
    get() {
      return v.pipeline;
    }
  }), t(p, o, {
    __proto__: null,
    enumerable: !0,
    get() {
      return v.finished;
    }
  }), w.Stream = w, w._isUint8Array = function(E) {
    return E instanceof Uint8Array;
  }, w._uint8ArrayToBuffer = function(E) {
    return e.from(E.buffer, E.byteOffset, E.byteLength);
  }, $b.exports;
}
(function(e) {
  const t = O5(), r = M5(), n = t.Readable.destroy;
  e.exports = t.Readable, e.exports._uint8ArrayToBuffer = t._uint8ArrayToBuffer, e.exports._isUint8Array = t._isUint8Array, e.exports.isDisturbed = t.isDisturbed, e.exports.isErrored = t.isErrored, e.exports.isReadable = t.isReadable, e.exports.Readable = t.Readable, e.exports.Writable = t.Writable, e.exports.Duplex = t.Duplex, e.exports.Transform = t.Transform, e.exports.PassThrough = t.PassThrough, e.exports.addAbortSignal = t.addAbortSignal, e.exports.finished = t.finished, e.exports.destroy = t.destroy, e.exports.destroy = n, e.exports.pipeline = t.pipeline, e.exports.compose = t.compose, Object.defineProperty(t, "promises", {
    configurable: !0,
    enumerable: !0,
    get() {
      return r;
    }
  }), e.exports.Stream = t.Stream, e.exports.default = e.exports;
})(P3);
var GQ = P3.exports;
class KQ extends GQ.Transform {
  constructor(t) {
    super({ decodeStrings: !0 }), this._readableState.objectMode = !0;
    const r = new O3(t);
    let n, o;
    r.parse(
      {
        on: (s, a) => {
          switch (s) {
            case "data":
              n = a;
              break;
            case "end":
              o = a;
              break;
          }
        }
      },
      // Handle quads by pushing them down the pipeline
      (s, a) => {
        s && this.emit("error", s) || a && this.push(a);
      },
      // Emit prefixes through the `prefix` event
      (s, a) => {
        this.emit("prefix", s, a);
      }
    ), this._transform = (s, a, l) => {
      n(s), l();
    }, this._flush = (s) => {
      o(), s();
    };
  }
  // ### Parses a stream of strings
  import(t) {
    return t.on("data", (r) => {
      this.write(r);
    }), t.on("end", () => {
      this.end();
    }), t.on("error", (r) => {
      this.emit("error", r);
    }), this;
  }
}
class YQ {
  constructor(t, { baseIRI: r = "", factory: n = _3, ...o } = {}) {
    const s = {
      blankNode: n.blankNode.bind(n),
      defaultGraph: n.defaultGraph.bind(n),
      literal: n.literal.bind(n),
      namedNode: n.namedNode.bind(n),
      quad: n.quad.bind(n)
    }, a = new KQ({ baseIRI: r, factory: s, ...o });
    return t.pipe(a), C3(a);
  }
}
let L5 = class extends iY {
  constructor(t) {
    super(YQ, t);
  }
};
const XQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: L5
}, Symbol.toStringTag, { value: "Module" }));
var P5 = { exports: {} }, Gb = { exports: {} }, jt = {
  ArrayIsArray(e) {
    return Array.isArray(e);
  },
  ArrayPrototypeIncludes(e, t) {
    return e.includes(t);
  },
  ArrayPrototypeIndexOf(e, t) {
    return e.indexOf(t);
  },
  ArrayPrototypeJoin(e, t) {
    return e.join(t);
  },
  ArrayPrototypeMap(e, t) {
    return e.map(t);
  },
  ArrayPrototypePop(e, t) {
    return e.pop(t);
  },
  ArrayPrototypePush(e, t) {
    return e.push(t);
  },
  ArrayPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  Error,
  FunctionPrototypeCall(e, t, ...r) {
    return e.call(t, ...r);
  },
  FunctionPrototypeSymbolHasInstance(e, t) {
    return Function.prototype[Symbol.hasInstance].call(e, t);
  },
  MathFloor: Math.floor,
  Number,
  NumberIsInteger: Number.isInteger,
  NumberIsNaN: Number.isNaN,
  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
  NumberParseInt: Number.parseInt,
  ObjectDefineProperties(e, t) {
    return Object.defineProperties(e, t);
  },
  ObjectDefineProperty(e, t, r) {
    return Object.defineProperty(e, t, r);
  },
  ObjectGetOwnPropertyDescriptor(e, t) {
    return Object.getOwnPropertyDescriptor(e, t);
  },
  ObjectKeys(e) {
    return Object.keys(e);
  },
  ObjectSetPrototypeOf(e, t) {
    return Object.setPrototypeOf(e, t);
  },
  Promise,
  PromisePrototypeCatch(e, t) {
    return e.catch(t);
  },
  PromisePrototypeThen(e, t, r) {
    return e.then(t, r);
  },
  PromiseReject(e) {
    return Promise.reject(e);
  },
  PromiseResolve(e) {
    return Promise.resolve(e);
  },
  ReflectApply: Reflect.apply,
  RegExpPrototypeTest(e, t) {
    return e.test(t);
  },
  SafeSet: Set,
  String,
  StringPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  StringPrototypeToLowerCase(e) {
    return e.toLowerCase();
  },
  StringPrototypeToUpperCase(e) {
    return e.toUpperCase();
  },
  StringPrototypeTrim(e) {
    return e.trim();
  },
  Symbol,
  SymbolFor: Symbol.for,
  SymbolAsyncIterator: Symbol.asyncIterator,
  SymbolHasInstance: Symbol.hasInstance,
  SymbolIterator: Symbol.iterator,
  SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
  SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
  TypedArrayPrototypeSet(e, t, r) {
    return e.set(t, r);
  },
  Boolean,
  Uint8Array
}, D5 = { exports: {} };
(function(e) {
  const t = ft, { kResistStopPropagation: r, SymbolDispose: n } = jt, o = globalThis.AbortSignal || Kt().AbortSignal, s = globalThis.AbortController || Kt().AbortController, a = Object.getPrototypeOf(async function() {
  }).constructor, l = globalThis.Blob || t.Blob, u = typeof l < "u" ? function(p) {
    return p instanceof l;
  } : function(p) {
    return !1;
  }, f = (h, p) => {
    if (h !== void 0 && (h === null || typeof h != "object" || !("aborted" in h)))
      throw new ERR_INVALID_ARG_TYPE(p, "AbortSignal", h);
  }, c = (h, p) => {
    if (typeof h != "function")
      throw new ERR_INVALID_ARG_TYPE(p, "Function", h);
  };
  class d extends Error {
    constructor(p) {
      if (!Array.isArray(p))
        throw new TypeError(`Expected input to be an Array, got ${typeof p}`);
      let v = "";
      for (let y = 0; y < p.length; y++)
        v += `    ${p[y].stack}
`;
      super(v), this.name = "AggregateError", this.errors = p;
    }
  }
  e.exports = {
    AggregateError: d,
    kEmptyObject: Object.freeze({}),
    once(h) {
      let p = !1;
      return function(...v) {
        p || (p = !0, h.apply(this, v));
      };
    },
    createDeferredPromise: function() {
      let h, p;
      return {
        promise: new Promise((y, w) => {
          h = y, p = w;
        }),
        resolve: h,
        reject: p
      };
    },
    promisify(h) {
      return new Promise((p, v) => {
        h((y, ...w) => y ? v(y) : p(...w));
      });
    },
    debuglog() {
      return function() {
      };
    },
    format(h, ...p) {
      return h.replace(/%([sdifj])/g, function(...[v, y]) {
        const w = p.shift();
        return y === "f" ? w.toFixed(6) : y === "j" ? JSON.stringify(w) : y === "s" && typeof w == "object" ? `${w.constructor !== Object ? w.constructor.name : ""} {}`.trim() : w.toString();
      });
    },
    inspect(h) {
      switch (typeof h) {
        case "string":
          if (h.includes("'"))
            if (h.includes('"')) {
              if (!h.includes("`") && !h.includes("${"))
                return `\`${h}\``;
            } else
              return `"${h}"`;
          return `'${h}'`;
        case "number":
          return isNaN(h) ? "NaN" : Object.is(h, -0) ? String(h) : h;
        case "bigint":
          return `${String(h)}n`;
        case "boolean":
        case "undefined":
          return String(h);
        case "object":
          return "{}";
      }
    },
    types: {
      isAsyncFunction(h) {
        return h instanceof a;
      },
      isArrayBufferView(h) {
        return ArrayBuffer.isView(h);
      }
    },
    isBlob: u,
    deprecate(h, p) {
      return h;
    },
    addAbortListener: ur.addAbortListener || function(p, v) {
      if (p === void 0)
        throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", p);
      f(p, "signal"), c(v, "listener");
      let y;
      return p.aborted ? queueMicrotask(() => v()) : (p.addEventListener("abort", v, {
        __proto__: null,
        once: !0,
        [r]: !0
      }), y = () => {
        p.removeEventListener("abort", v);
      }), {
        __proto__: null,
        [n]() {
          var w;
          (w = y) === null || w === void 0 || w();
        }
      };
    },
    AbortSignalAny: o.any || function(p) {
      if (p.length === 1)
        return p[0];
      const v = new s(), y = () => v.abort();
      return p.forEach((w) => {
        f(w, "signals"), w.addEventListener("abort", y, {
          once: !0
        });
      }), v.signal.addEventListener(
        "abort",
        () => {
          p.forEach((w) => w.removeEventListener("abort", y));
        },
        {
          once: !0
        }
      ), v.signal;
    }
  }, e.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
})(D5);
var Hr = D5.exports, cx = {};
const { format: JQ, inspect: yh, AggregateError: QQ } = Hr, ZQ = globalThis.AggregateError || QQ, eZ = Symbol("kIsNodeError"), tZ = [
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
], rZ = /^([A-Z][a-z0-9]*)+$/, nZ = "__node_internal_", Lp = {};
function fa(e, t) {
  if (!e)
    throw new Lp.ERR_INTERNAL_ASSERTION(t);
}
function _$(e) {
  let t = "", r = e.length;
  const n = e[0] === "-" ? 1 : 0;
  for (; r >= n + 4; r -= 3)
    t = `_${e.slice(r - 3, r)}${t}`;
  return `${e.slice(0, r)}${t}`;
}
function iZ(e, t, r) {
  if (typeof t == "function")
    return fa(
      t.length <= r.length,
      // Default options do not count.
      `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${t.length}).`
    ), t(...r);
  const n = (t.match(/%[dfijoOs]/g) || []).length;
  return fa(
    n === r.length,
    `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${n}).`
  ), r.length === 0 ? t : JQ(t, ...r);
}
function Sr(e, t, r) {
  r || (r = Error);
  class n extends r {
    constructor(...s) {
      super(iZ(e, t, s));
    }
    toString() {
      return `${this.name} [${e}]: ${this.message}`;
    }
  }
  Object.defineProperties(n.prototype, {
    name: {
      value: r.name,
      writable: !0,
      enumerable: !1,
      configurable: !0
    },
    toString: {
      value() {
        return `${this.name} [${e}]: ${this.message}`;
      },
      writable: !0,
      enumerable: !1,
      configurable: !0
    }
  }), n.prototype.code = e, n.prototype[eZ] = !0, Lp[e] = n;
}
function w$(e) {
  const t = nZ + e.name;
  return Object.defineProperty(e, "name", {
    value: t
  }), e;
}
function oZ(e, t) {
  if (e && t && e !== t) {
    if (Array.isArray(t.errors))
      return t.errors.push(e), t;
    const r = new ZQ([t, e], t.message);
    return r.code = t.code, r;
  }
  return e || t;
}
let sZ = class extends Error {
  constructor(t = "The operation was aborted", r = void 0) {
    if (r !== void 0 && typeof r != "object")
      throw new Lp.ERR_INVALID_ARG_TYPE("options", "Object", r);
    super(t, r), this.code = "ABORT_ERR", this.name = "AbortError";
  }
};
Sr("ERR_ASSERTION", "%s", Error);
Sr(
  "ERR_INVALID_ARG_TYPE",
  (e, t, r) => {
    fa(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
    let n = "The ";
    e.endsWith(" argument") ? n += `${e} ` : n += `"${e}" ${e.includes(".") ? "property" : "argument"} `, n += "must be ";
    const o = [], s = [], a = [];
    for (const u of t)
      fa(typeof u == "string", "All expected entries have to be of type string"), tZ.includes(u) ? o.push(u.toLowerCase()) : rZ.test(u) ? s.push(u) : (fa(u !== "object", 'The value "object" should be written as "Object"'), a.push(u));
    if (s.length > 0) {
      const u = o.indexOf("object");
      u !== -1 && (o.splice(o, u, 1), s.push("Object"));
    }
    if (o.length > 0) {
      switch (o.length) {
        case 1:
          n += `of type ${o[0]}`;
          break;
        case 2:
          n += `one of type ${o[0]} or ${o[1]}`;
          break;
        default: {
          const u = o.pop();
          n += `one of type ${o.join(", ")}, or ${u}`;
        }
      }
      (s.length > 0 || a.length > 0) && (n += " or ");
    }
    if (s.length > 0) {
      switch (s.length) {
        case 1:
          n += `an instance of ${s[0]}`;
          break;
        case 2:
          n += `an instance of ${s[0]} or ${s[1]}`;
          break;
        default: {
          const u = s.pop();
          n += `an instance of ${s.join(", ")}, or ${u}`;
        }
      }
      a.length > 0 && (n += " or ");
    }
    switch (a.length) {
      case 0:
        break;
      case 1:
        a[0].toLowerCase() !== a[0] && (n += "an "), n += `${a[0]}`;
        break;
      case 2:
        n += `one of ${a[0]} or ${a[1]}`;
        break;
      default: {
        const u = a.pop();
        n += `one of ${a.join(", ")}, or ${u}`;
      }
    }
    if (r == null)
      n += `. Received ${r}`;
    else if (typeof r == "function" && r.name)
      n += `. Received function ${r.name}`;
    else if (typeof r == "object") {
      var l;
      if ((l = r.constructor) !== null && l !== void 0 && l.name)
        n += `. Received an instance of ${r.constructor.name}`;
      else {
        const u = yh(r, {
          depth: -1
        });
        n += `. Received ${u}`;
      }
    } else {
      let u = yh(r, {
        colors: !1
      });
      u.length > 25 && (u = `${u.slice(0, 25)}...`), n += `. Received type ${typeof r} (${u})`;
    }
    return n;
  },
  TypeError
);
Sr(
  "ERR_INVALID_ARG_VALUE",
  (e, t, r = "is invalid") => {
    let n = yh(t);
    return n.length > 128 && (n = n.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${n}`;
  },
  TypeError
);
Sr(
  "ERR_INVALID_RETURN_VALUE",
  (e, t, r) => {
    var n;
    const o = r != null && (n = r.constructor) !== null && n !== void 0 && n.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
    return `Expected ${e} to be returned from the "${t}" function but got ${o}.`;
  },
  TypeError
);
Sr(
  "ERR_MISSING_ARGS",
  (...e) => {
    fa(e.length > 0, "At least one arg needs to be specified");
    let t;
    const r = e.length;
    switch (e = (Array.isArray(e) ? e : [e]).map((n) => `"${n}"`).join(" or "), r) {
      case 1:
        t += `The ${e[0]} argument`;
        break;
      case 2:
        t += `The ${e[0]} and ${e[1]} arguments`;
        break;
      default:
        {
          const n = e.pop();
          t += `The ${e.join(", ")}, and ${n} arguments`;
        }
        break;
    }
    return `${t} must be specified`;
  },
  TypeError
);
Sr(
  "ERR_OUT_OF_RANGE",
  (e, t, r) => {
    fa(t, 'Missing "range" argument');
    let n;
    return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? n = _$(String(r)) : typeof r == "bigint" ? (n = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (n = _$(n)), n += "n") : n = yh(r), `The value of "${e}" is out of range. It must be ${t}. Received ${n}`;
  },
  RangeError
);
Sr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
Sr("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
Sr("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
Sr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
Sr("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
Sr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
Sr("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
Sr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
Sr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
Sr("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
Sr("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
var on = {
  AbortError: sZ,
  aggregateTwoErrors: w$(oZ),
  hideStackFrames: w$,
  codes: Lp
};
const {
  ArrayIsArray: dx,
  ArrayPrototypeIncludes: F5,
  ArrayPrototypeJoin: j5,
  ArrayPrototypeMap: aZ,
  NumberIsInteger: hx,
  NumberIsNaN: lZ,
  NumberMAX_SAFE_INTEGER: uZ,
  NumberMIN_SAFE_INTEGER: fZ,
  NumberParseInt: cZ,
  ObjectPrototypeHasOwnProperty: dZ,
  RegExpPrototypeExec: B5,
  String: hZ,
  StringPrototypeToUpperCase: pZ,
  StringPrototypeTrim: gZ
} = jt, {
  hideStackFrames: kn,
  codes: { ERR_SOCKET_BAD_PORT: bZ, ERR_INVALID_ARG_TYPE: Ir, ERR_INVALID_ARG_VALUE: du, ERR_OUT_OF_RANGE: Ra, ERR_UNKNOWN_SIGNAL: S$ }
} = on, { normalizeEncoding: yZ } = Hr, { isAsyncFunction: vZ, isArrayBufferView: mZ } = Hr.types, E$ = {};
function _Z(e) {
  return e === (e | 0);
}
function wZ(e) {
  return e === e >>> 0;
}
const SZ = /^[0-7]+$/, EZ = "must be a 32-bit unsigned integer or an octal string";
function xZ(e, t, r) {
  if (typeof e > "u" && (e = r), typeof e == "string") {
    if (B5(SZ, e) === null)
      throw new du(t, e, EZ);
    e = cZ(e, 8);
  }
  return q5(e, t), e;
}
const RZ = kn((e, t, r = fZ, n = uZ) => {
  if (typeof e != "number")
    throw new Ir(t, "number", e);
  if (!hx(e))
    throw new Ra(t, "an integer", e);
  if (e < r || e > n)
    throw new Ra(t, `>= ${r} && <= ${n}`, e);
}), AZ = kn((e, t, r = -2147483648, n = 2147483647) => {
  if (typeof e != "number")
    throw new Ir(t, "number", e);
  if (!hx(e))
    throw new Ra(t, "an integer", e);
  if (e < r || e > n)
    throw new Ra(t, `>= ${r} && <= ${n}`, e);
}), q5 = kn((e, t, r = !1) => {
  if (typeof e != "number")
    throw new Ir(t, "number", e);
  if (!hx(e))
    throw new Ra(t, "an integer", e);
  const n = r ? 1 : 0, o = 4294967295;
  if (e < n || e > o)
    throw new Ra(t, `>= ${n} && <= ${o}`, e);
});
function px(e, t) {
  if (typeof e != "string")
    throw new Ir(t, "string", e);
}
function TZ(e, t, r = void 0, n) {
  if (typeof e != "number")
    throw new Ir(t, "number", e);
  if (r != null && e < r || n != null && e > n || (r != null || n != null) && lZ(e))
    throw new Ra(
      t,
      `${r != null ? `>= ${r}` : ""}${r != null && n != null ? " && " : ""}${n != null ? `<= ${n}` : ""}`,
      e
    );
}
const $Z = kn((e, t, r) => {
  if (!F5(r, e)) {
    const o = "must be one of: " + j5(
      aZ(r, (s) => typeof s == "string" ? `'${s}'` : hZ(s)),
      ", "
    );
    throw new du(t, e, o);
  }
});
function W5(e, t) {
  if (typeof e != "boolean")
    throw new Ir(t, "boolean", e);
}
function Kb(e, t, r) {
  return e == null || !dZ(e, t) ? r : e[t];
}
const NZ = kn((e, t, r = null) => {
  const n = Kb(r, "allowArray", !1), o = Kb(r, "allowFunction", !1);
  if (!Kb(r, "nullable", !1) && e === null || !n && dx(e) || typeof e != "object" && (!o || typeof e != "function"))
    throw new Ir(t, "Object", e);
}), kZ = kn((e, t) => {
  if (e != null && typeof e != "object" && typeof e != "function")
    throw new Ir(t, "a dictionary", e);
}), Pp = kn((e, t, r = 0) => {
  if (!dx(e))
    throw new Ir(t, "Array", e);
  if (e.length < r) {
    const n = `must be longer than ${r}`;
    throw new du(t, e, n);
  }
});
function CZ(e, t) {
  Pp(e, t);
  for (let r = 0; r < e.length; r++)
    px(e[r], `${t}[${r}]`);
}
function IZ(e, t) {
  Pp(e, t);
  for (let r = 0; r < e.length; r++)
    W5(e[r], `${t}[${r}]`);
}
function MZ(e, t) {
  Pp(e, t);
  for (let r = 0; r < e.length; r++) {
    const n = e[r], o = `${t}[${r}]`;
    if (n == null)
      throw new Ir(o, "AbortSignal", n);
    U5(n, o);
  }
}
function OZ(e, t = "signal") {
  if (px(e, t), E$[e] === void 0)
    throw E$[pZ(e)] !== void 0 ? new S$(e + " (signals must use all capital letters)") : new S$(e);
}
const LZ = kn((e, t = "buffer") => {
  if (!mZ(e))
    throw new Ir(t, ["Buffer", "TypedArray", "DataView"], e);
});
function PZ(e, t) {
  const r = yZ(t), n = e.length;
  if (r === "hex" && n % 2 !== 0)
    throw new du("encoding", t, `is invalid for data of length ${n}`);
}
function DZ(e, t = "Port", r = !0) {
  if (typeof e != "number" && typeof e != "string" || typeof e == "string" && gZ(e).length === 0 || +e !== +e >>> 0 || e > 65535 || e === 0 && !r)
    throw new bZ(t, e, r);
  return e | 0;
}
const U5 = kn((e, t) => {
  if (e !== void 0 && (e === null || typeof e != "object" || !("aborted" in e)))
    throw new Ir(t, "AbortSignal", e);
}), FZ = kn((e, t) => {
  if (typeof e != "function")
    throw new Ir(t, "Function", e);
}), jZ = kn((e, t) => {
  if (typeof e != "function" || vZ(e))
    throw new Ir(t, "Function", e);
}), BZ = kn((e, t) => {
  if (e !== void 0)
    throw new Ir(t, "undefined", e);
});
function qZ(e, t, r) {
  if (!F5(r, e))
    throw new Ir(t, `('${j5(r, "|")}')`, e);
}
const WZ = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
function x$(e, t) {
  if (typeof e > "u" || !B5(WZ, e))
    throw new du(
      t,
      e,
      'must be an array or string of format "</styles.css>; rel=preload; as=style"'
    );
}
function UZ(e) {
  if (typeof e == "string")
    return x$(e, "hints"), e;
  if (dx(e)) {
    const t = e.length;
    let r = "";
    if (t === 0)
      return r;
    for (let n = 0; n < t; n++) {
      const o = e[n];
      x$(o, "hints"), r += o, n !== t - 1 && (r += ", ");
    }
    return r;
  }
  throw new du(
    "hints",
    e,
    'must be an array or string of format "</styles.css>; rel=preload; as=style"'
  );
}
var _c = {
  isInt32: _Z,
  isUint32: wZ,
  parseFileMode: xZ,
  validateArray: Pp,
  validateStringArray: CZ,
  validateBooleanArray: IZ,
  validateAbortSignalArray: MZ,
  validateBoolean: W5,
  validateBuffer: LZ,
  validateDictionary: kZ,
  validateEncoding: PZ,
  validateFunction: FZ,
  validateInt32: AZ,
  validateInteger: RZ,
  validateNumber: TZ,
  validateObject: NZ,
  validateOneOf: $Z,
  validatePlainFunction: jZ,
  validatePort: DZ,
  validateSignalName: OZ,
  validateString: px,
  validateUint32: q5,
  validateUndefined: BZ,
  validateUnion: qZ,
  validateAbortSignal: U5,
  validateLinkHeaderValue: UZ
}, gx = { exports: {} };
const { SymbolAsyncIterator: R$, SymbolIterator: A$, SymbolFor: Wa } = jt, H5 = Wa("nodejs.stream.destroyed"), V5 = Wa("nodejs.stream.errored"), Z1 = Wa("nodejs.stream.readable"), eS = Wa("nodejs.stream.writable"), z5 = Wa("nodejs.stream.disturbed"), HZ = Wa("nodejs.webstream.isClosedPromise"), VZ = Wa("nodejs.webstream.controllerErrorFunction");
function Dp(e, t = !1) {
  var r;
  return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((r = e._readableState) === null || r === void 0 ? void 0 : r.readable) !== !1) && // Duplex
  (!e._writableState || e._readableState));
}
function Fp(e) {
  var t;
  return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === void 0 ? void 0 : t.writable) !== !1));
}
function zZ(e) {
  return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
}
function Di(e) {
  return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
}
function G5(e) {
  return !!(e && !Di(e) && typeof e.pipeThrough == "function" && typeof e.getReader == "function" && typeof e.cancel == "function");
}
function K5(e) {
  return !!(e && !Di(e) && typeof e.getWriter == "function" && typeof e.abort == "function");
}
function Y5(e) {
  return !!(e && !Di(e) && typeof e.readable == "object" && typeof e.writable == "object");
}
function GZ(e) {
  return G5(e) || K5(e) || Y5(e);
}
function KZ(e, t) {
  return e == null ? !1 : t === !0 ? typeof e[R$] == "function" : t === !1 ? typeof e[A$] == "function" : typeof e[R$] == "function" || typeof e[A$] == "function";
}
function jp(e) {
  if (!Di(e))
    return null;
  const t = e._writableState, r = e._readableState, n = t || r;
  return !!(e.destroyed || e[H5] || n != null && n.destroyed);
}
function X5(e) {
  if (!Fp(e))
    return null;
  if (e.writableEnded === !0)
    return !0;
  const t = e._writableState;
  return t != null && t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function YZ(e, t) {
  if (!Fp(e))
    return null;
  if (e.writableFinished === !0)
    return !0;
  const r = e._writableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.finished) != "boolean" ? null : !!(r.finished || t === !1 && r.ended === !0 && r.length === 0);
}
function XZ(e) {
  if (!Dp(e))
    return null;
  if (e.readableEnded === !0)
    return !0;
  const t = e._readableState;
  return !t || t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function J5(e, t) {
  if (!Dp(e))
    return null;
  const r = e._readableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.endEmitted) != "boolean" ? null : !!(r.endEmitted || t === !1 && r.ended === !0 && r.length === 0);
}
function Q5(e) {
  return e && e[Z1] != null ? e[Z1] : typeof (e == null ? void 0 : e.readable) != "boolean" ? null : jp(e) ? !1 : Dp(e) && e.readable && !J5(e);
}
function Z5(e) {
  return e && e[eS] != null ? e[eS] : typeof (e == null ? void 0 : e.writable) != "boolean" ? null : jp(e) ? !1 : Fp(e) && e.writable && !X5(e);
}
function JZ(e, t) {
  return Di(e) ? jp(e) ? !0 : !((t == null ? void 0 : t.readable) !== !1 && Q5(e) || (t == null ? void 0 : t.writable) !== !1 && Z5(e)) : null;
}
function QZ(e) {
  var t, r;
  return Di(e) ? e.writableErrored ? e.writableErrored : (t = (r = e._writableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function ZZ(e) {
  var t, r;
  return Di(e) ? e.readableErrored ? e.readableErrored : (t = (r = e._readableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function eee(e) {
  if (!Di(e))
    return null;
  if (typeof e.closed == "boolean")
    return e.closed;
  const t = e._writableState, r = e._readableState;
  return typeof (t == null ? void 0 : t.closed) == "boolean" || typeof (r == null ? void 0 : r.closed) == "boolean" ? (t == null ? void 0 : t.closed) || (r == null ? void 0 : r.closed) : typeof e._closed == "boolean" && eF(e) ? e._closed : null;
}
function eF(e) {
  return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
}
function tF(e) {
  return typeof e._sent100 == "boolean" && eF(e);
}
function tee(e) {
  var t;
  return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === void 0 ? void 0 : t.upgradeOrConnect) === void 0;
}
function ree(e) {
  if (!Di(e))
    return null;
  const t = e._writableState, r = e._readableState, n = t || r;
  return !n && tF(e) || !!(n && n.autoDestroy && n.emitClose && n.closed === !1);
}
function nee(e) {
  var t;
  return !!(e && ((t = e[z5]) !== null && t !== void 0 ? t : e.readableDidRead || e.readableAborted));
}
function iee(e) {
  var t, r, n, o, s, a, l, u, f, c;
  return !!(e && ((t = (r = (n = (o = (s = (a = e[V5]) !== null && a !== void 0 ? a : e.readableErrored) !== null && s !== void 0 ? s : e.writableErrored) !== null && o !== void 0 ? o : (l = e._readableState) === null || l === void 0 ? void 0 : l.errorEmitted) !== null && n !== void 0 ? n : (u = e._writableState) === null || u === void 0 ? void 0 : u.errorEmitted) !== null && r !== void 0 ? r : (f = e._readableState) === null || f === void 0 ? void 0 : f.errored) !== null && t !== void 0 ? t : !((c = e._writableState) === null || c === void 0) && c.errored));
}
var Ro = {
  isDestroyed: jp,
  kIsDestroyed: H5,
  isDisturbed: nee,
  kIsDisturbed: z5,
  isErrored: iee,
  kIsErrored: V5,
  isReadable: Q5,
  kIsReadable: Z1,
  kIsClosedPromise: HZ,
  kControllerErrorFunction: VZ,
  kIsWritable: eS,
  isClosed: eee,
  isDuplexNodeStream: zZ,
  isFinished: JZ,
  isIterable: KZ,
  isReadableNodeStream: Dp,
  isReadableStream: G5,
  isReadableEnded: XZ,
  isReadableFinished: J5,
  isReadableErrored: ZZ,
  isNodeStream: Di,
  isWebStream: GZ,
  isWritable: Z5,
  isWritableNodeStream: Fp,
  isWritableStream: K5,
  isWritableEnded: X5,
  isWritableFinished: YZ,
  isWritableErrored: QZ,
  isServerRequest: tee,
  isServerResponse: tF,
  willEmitClose: ree,
  isTransformStream: Y5
};
const jo = St, { AbortError: rF, codes: oee } = on, { ERR_INVALID_ARG_TYPE: see, ERR_STREAM_PREMATURE_CLOSE: T$ } = oee, { kEmptyObject: tS, once: rS } = Hr, { validateAbortSignal: aee, validateFunction: lee, validateObject: uee, validateBoolean: fee } = _c, { Promise: cee, PromisePrototypeThen: dee, SymbolDispose: nF } = jt, {
  isClosed: hee,
  isReadable: $$,
  isReadableNodeStream: Yb,
  isReadableStream: pee,
  isReadableFinished: N$,
  isReadableErrored: k$,
  isWritable: C$,
  isWritableNodeStream: I$,
  isWritableStream: gee,
  isWritableFinished: M$,
  isWritableErrored: O$,
  isNodeStream: bee,
  willEmitClose: yee,
  kIsClosedPromise: vee
} = Ro;
let Ol;
function mee(e) {
  return e.setHeader && typeof e.abort == "function";
}
const nS = () => {
};
function iF(e, t, r) {
  var n, o;
  if (arguments.length === 2 ? (r = t, t = tS) : t == null ? t = tS : uee(t, "options"), lee(r, "callback"), aee(t.signal, "options.signal"), r = rS(r), pee(e) || gee(e))
    return _ee(e, t, r);
  if (!bee(e))
    throw new see("stream", ["ReadableStream", "WritableStream", "Stream"], e);
  const s = (n = t.readable) !== null && n !== void 0 ? n : Yb(e), a = (o = t.writable) !== null && o !== void 0 ? o : I$(e), l = e._writableState, u = e._readableState, f = () => {
    e.writable || h();
  };
  let c = yee(e) && Yb(e) === s && I$(e) === a, d = M$(e, !1);
  const h = () => {
    d = !0, e.destroyed && (c = !1), !(c && (!e.readable || s)) && (!s || p) && r.call(e);
  };
  let p = N$(e, !1);
  const v = () => {
    p = !0, e.destroyed && (c = !1), !(c && (!e.writable || a)) && (!a || d) && r.call(e);
  }, y = (C) => {
    r.call(e, C);
  };
  let w = hee(e);
  const S = () => {
    w = !0;
    const C = O$(e) || k$(e);
    if (C && typeof C != "boolean")
      return r.call(e, C);
    if (s && !p && Yb(e, !0) && !N$(e, !1))
      return r.call(e, new T$());
    if (a && !d && !M$(e, !1))
      return r.call(e, new T$());
    r.call(e);
  }, x = () => {
    w = !0;
    const C = O$(e) || k$(e);
    if (C && typeof C != "boolean")
      return r.call(e, C);
    r.call(e);
  }, E = () => {
    e.req.on("finish", h);
  };
  mee(e) ? (e.on("complete", h), c || e.on("abort", S), e.req ? E() : e.on("request", E)) : a && !l && (e.on("end", f), e.on("close", f)), !c && typeof e.aborted == "boolean" && e.on("aborted", S), e.on("end", v), e.on("finish", h), t.error !== !1 && e.on("error", y), e.on("close", S), w ? jo.nextTick(S) : l != null && l.errorEmitted || u != null && u.errorEmitted ? c || jo.nextTick(x) : (!s && (!c || $$(e)) && (d || C$(e) === !1) || !a && (!c || C$(e)) && (p || $$(e) === !1) || u && e.req && e.aborted) && jo.nextTick(x);
  const N = () => {
    r = nS, e.removeListener("aborted", S), e.removeListener("complete", h), e.removeListener("abort", S), e.removeListener("request", E), e.req && e.req.removeListener("finish", h), e.removeListener("end", f), e.removeListener("close", f), e.removeListener("finish", h), e.removeListener("end", v), e.removeListener("error", y), e.removeListener("close", S);
  };
  if (t.signal && !w) {
    const C = () => {
      const j = r;
      N(), j.call(
        e,
        new rF(void 0, {
          cause: t.signal.reason
        })
      );
    };
    if (t.signal.aborted)
      jo.nextTick(C);
    else {
      Ol = Ol || Hr.addAbortListener;
      const j = Ol(t.signal, C), J = r;
      r = rS((...z) => {
        j[nF](), J.apply(e, z);
      });
    }
  }
  return N;
}
function _ee(e, t, r) {
  let n = !1, o = nS;
  if (t.signal)
    if (o = () => {
      n = !0, r.call(
        e,
        new rF(void 0, {
          cause: t.signal.reason
        })
      );
    }, t.signal.aborted)
      jo.nextTick(o);
    else {
      Ol = Ol || Hr.addAbortListener;
      const a = Ol(t.signal, o), l = r;
      r = rS((...u) => {
        a[nF](), l.apply(e, u);
      });
    }
  const s = (...a) => {
    n || jo.nextTick(() => r.apply(e, a));
  };
  return dee(e[vee].promise, s, s), nS;
}
function wee(e, t) {
  var r;
  let n = !1;
  return t === null && (t = tS), (r = t) !== null && r !== void 0 && r.cleanup && (fee(t.cleanup, "cleanup"), n = t.cleanup), new cee((o, s) => {
    const a = iF(e, t, (l) => {
      n && a(), l ? s(l) : o();
    });
  });
}
gx.exports = iF;
gx.exports.finished = wee;
var ms = gx.exports;
const _i = St, {
  aggregateTwoErrors: See,
  codes: { ERR_MULTIPLE_CALLBACK: Eee },
  AbortError: xee
} = on, { Symbol: oF } = jt, { kIsDestroyed: Ree, isDestroyed: Aee, isFinished: Tee, isServerRequest: $ee } = Ro, sF = oF("kDestroy"), iS = oF("kConstruct");
function aF(e, t, r) {
  e && (e.stack, t && !t.errored && (t.errored = e), r && !r.errored && (r.errored = e));
}
function Nee(e, t) {
  const r = this._readableState, n = this._writableState, o = n || r;
  return n != null && n.destroyed || r != null && r.destroyed ? (typeof t == "function" && t(), this) : (aF(e, n, r), n && (n.destroyed = !0), r && (r.destroyed = !0), o.constructed ? L$(this, e, t) : this.once(sF, function(s) {
    L$(this, See(s, e), t);
  }), this);
}
function L$(e, t, r) {
  let n = !1;
  function o(s) {
    if (n)
      return;
    n = !0;
    const a = e._readableState, l = e._writableState;
    aF(s, l, a), l && (l.closed = !0), a && (a.closed = !0), typeof r == "function" && r(s), s ? _i.nextTick(kee, e, s) : _i.nextTick(lF, e);
  }
  try {
    e._destroy(t || null, o);
  } catch (s) {
    o(s);
  }
}
function kee(e, t) {
  oS(e, t), lF(e);
}
function lF(e) {
  const t = e._readableState, r = e._writableState;
  r && (r.closeEmitted = !0), t && (t.closeEmitted = !0), (r != null && r.emitClose || t != null && t.emitClose) && e.emit("close");
}
function oS(e, t) {
  const r = e._readableState, n = e._writableState;
  n != null && n.errorEmitted || r != null && r.errorEmitted || (n && (n.errorEmitted = !0), r && (r.errorEmitted = !0), e.emit("error", t));
}
function Cee() {
  const e = this._readableState, t = this._writableState;
  e && (e.constructed = !0, e.closed = !1, e.closeEmitted = !1, e.destroyed = !1, e.errored = null, e.errorEmitted = !1, e.reading = !1, e.ended = e.readable === !1, e.endEmitted = e.readable === !1), t && (t.constructed = !0, t.destroyed = !1, t.closed = !1, t.closeEmitted = !1, t.errored = null, t.errorEmitted = !1, t.finalCalled = !1, t.prefinished = !1, t.ended = t.writable === !1, t.ending = t.writable === !1, t.finished = t.writable === !1);
}
function sS(e, t, r) {
  const n = e._readableState, o = e._writableState;
  if (o != null && o.destroyed || n != null && n.destroyed)
    return this;
  n != null && n.autoDestroy || o != null && o.autoDestroy ? e.destroy(t) : t && (t.stack, o && !o.errored && (o.errored = t), n && !n.errored && (n.errored = t), r ? _i.nextTick(oS, e, t) : oS(e, t));
}
function Iee(e, t) {
  if (typeof e._construct != "function")
    return;
  const r = e._readableState, n = e._writableState;
  r && (r.constructed = !1), n && (n.constructed = !1), e.once(iS, t), !(e.listenerCount(iS) > 1) && _i.nextTick(Mee, e);
}
function Mee(e) {
  let t = !1;
  function r(n) {
    if (t) {
      sS(e, n ?? new Eee());
      return;
    }
    t = !0;
    const o = e._readableState, s = e._writableState, a = s || o;
    o && (o.constructed = !0), s && (s.constructed = !0), a.destroyed ? e.emit(sF, n) : n ? sS(e, n, !0) : _i.nextTick(Oee, e);
  }
  try {
    e._construct((n) => {
      _i.nextTick(r, n);
    });
  } catch (n) {
    _i.nextTick(r, n);
  }
}
function Oee(e) {
  e.emit(iS);
}
function P$(e) {
  return (e == null ? void 0 : e.setHeader) && typeof e.abort == "function";
}
function uF(e) {
  e.emit("close");
}
function Lee(e, t) {
  e.emit("error", t), _i.nextTick(uF, e);
}
function Pee(e, t) {
  !e || Aee(e) || (!t && !Tee(e) && (t = new xee()), $ee(e) ? (e.socket = null, e.destroy(t)) : P$(e) ? e.abort() : P$(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? _i.nextTick(Lee, e, t) : _i.nextTick(uF, e), e.destroyed || (e[Ree] = !0));
}
var hu = {
  construct: Iee,
  destroyer: Pee,
  destroy: Nee,
  undestroy: Cee,
  errorOrDestroy: sS
};
const { ArrayIsArray: Dee, ObjectSetPrototypeOf: fF } = jt, { EventEmitter: Bp } = ur;
function qp(e) {
  Bp.call(this, e);
}
fF(qp.prototype, Bp.prototype);
fF(qp, Bp);
qp.prototype.pipe = function(e, t) {
  const r = this;
  function n(c) {
    e.writable && e.write(c) === !1 && r.pause && r.pause();
  }
  r.on("data", n);
  function o() {
    r.readable && r.resume && r.resume();
  }
  e.on("drain", o), !e._isStdio && (!t || t.end !== !1) && (r.on("end", a), r.on("close", l));
  let s = !1;
  function a() {
    s || (s = !0, e.end());
  }
  function l() {
    s || (s = !0, typeof e.destroy == "function" && e.destroy());
  }
  function u(c) {
    f(), Bp.listenerCount(this, "error") === 0 && this.emit("error", c);
  }
  aS(r, "error", u), aS(e, "error", u);
  function f() {
    r.removeListener("data", n), e.removeListener("drain", o), r.removeListener("end", a), r.removeListener("close", l), r.removeListener("error", u), e.removeListener("error", u), r.removeListener("end", f), r.removeListener("close", f), e.removeListener("close", f);
  }
  return r.on("end", f), r.on("close", f), e.on("close", f), e.emit("pipe", r), e;
};
function aS(e, t, r) {
  if (typeof e.prependListener == "function")
    return e.prependListener(t, r);
  !e._events || !e._events[t] ? e.on(t, r) : Dee(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
}
var bx = {
  Stream: qp,
  prependListener: aS
}, cF = { exports: {} };
(function(e) {
  const { SymbolDispose: t } = jt, { AbortError: r, codes: n } = on, { isNodeStream: o, isWebStream: s, kControllerErrorFunction: a } = Ro, l = ms, { ERR_INVALID_ARG_TYPE: u } = n;
  let f;
  const c = (d, h) => {
    if (typeof d != "object" || !("aborted" in d))
      throw new u(h, "AbortSignal", d);
  };
  e.exports.addAbortSignal = function(h, p) {
    if (c(h, "signal"), !o(p) && !s(p))
      throw new u("stream", ["ReadableStream", "WritableStream", "Stream"], p);
    return e.exports.addAbortSignalNoValidate(h, p);
  }, e.exports.addAbortSignalNoValidate = function(d, h) {
    if (typeof d != "object" || !("aborted" in d))
      return h;
    const p = o(h) ? () => {
      h.destroy(
        new r(void 0, {
          cause: d.reason
        })
      );
    } : () => {
      h[a](
        new r(void 0, {
          cause: d.reason
        })
      );
    };
    if (d.aborted)
      p();
    else {
      f = f || Hr.addAbortListener;
      const v = f(d, p);
      l(h, v[t]);
    }
    return h;
  };
})(cF);
var Wp = cF.exports;
const { StringPrototypeSlice: D$, SymbolIterator: Fee, TypedArrayPrototypeSet: rd, Uint8Array: jee } = jt, { Buffer: Xb } = ft, { inspect: Bee } = Hr;
var qee = class {
  constructor() {
    this.head = null, this.tail = null, this.length = 0;
  }
  push(t) {
    const r = {
      data: t,
      next: null
    };
    this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
  }
  unshift(t) {
    const r = {
      data: t,
      next: this.head
    };
    this.length === 0 && (this.tail = r), this.head = r, ++this.length;
  }
  shift() {
    if (this.length === 0)
      return;
    const t = this.head.data;
    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
  }
  clear() {
    this.head = this.tail = null, this.length = 0;
  }
  join(t) {
    if (this.length === 0)
      return "";
    let r = this.head, n = "" + r.data;
    for (; (r = r.next) !== null; )
      n += t + r.data;
    return n;
  }
  concat(t) {
    if (this.length === 0)
      return Xb.alloc(0);
    const r = Xb.allocUnsafe(t >>> 0);
    let n = this.head, o = 0;
    for (; n; )
      rd(r, n.data, o), o += n.data.length, n = n.next;
    return r;
  }
  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(t, r) {
    const n = this.head.data;
    if (t < n.length) {
      const o = n.slice(0, t);
      return this.head.data = n.slice(t), o;
    }
    return t === n.length ? this.shift() : r ? this._getString(t) : this._getBuffer(t);
  }
  first() {
    return this.head.data;
  }
  *[Fee]() {
    for (let t = this.head; t; t = t.next)
      yield t.data;
  }
  // Consumes a specified amount of characters from the buffered data.
  _getString(t) {
    let r = "", n = this.head, o = 0;
    do {
      const s = n.data;
      if (t > s.length)
        r += s, t -= s.length;
      else {
        t === s.length ? (r += s, ++o, n.next ? this.head = n.next : this.head = this.tail = null) : (r += D$(s, 0, t), this.head = n, n.data = D$(s, t));
        break;
      }
      ++o;
    } while ((n = n.next) !== null);
    return this.length -= o, r;
  }
  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(t) {
    const r = Xb.allocUnsafe(t), n = t;
    let o = this.head, s = 0;
    do {
      const a = o.data;
      if (t > a.length)
        rd(r, a, n - t), t -= a.length;
      else {
        t === a.length ? (rd(r, a, n - t), ++s, o.next ? this.head = o.next : this.head = this.tail = null) : (rd(r, new jee(a.buffer, a.byteOffset, t), n - t), this.head = o, o.data = a.slice(t));
        break;
      }
      ++s;
    } while ((o = o.next) !== null);
    return this.length -= s, r;
  }
  // Make sure the linked list only shows the minimal necessary information.
  [Symbol.for("nodejs.util.inspect.custom")](t, r) {
    return Bee(this, {
      ...r,
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: !1
    });
  }
};
const { MathFloor: Wee, NumberIsInteger: Uee } = jt, { validateInteger: Hee } = _c, { ERR_INVALID_ARG_VALUE: Vee } = on.codes;
let dF = 16 * 1024, hF = 16;
function zee(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function pF(e) {
  return e ? hF : dF;
}
function Gee(e, t) {
  Hee(t, "value", 0), e ? hF = t : dF = t;
}
function Kee(e, t, r, n) {
  const o = zee(t, n, r);
  if (o != null) {
    if (!Uee(o) || o < 0) {
      const s = n ? `options.${r}` : "options.highWaterMark";
      throw new Vee(s, o);
    }
    return Wee(o);
  }
  return pF(e.objectMode);
}
var Up = {
  getHighWaterMark: Kee,
  getDefaultHighWaterMark: pF,
  setDefaultHighWaterMark: Gee
};
const F$ = St, { PromisePrototypeThen: Yee, SymbolAsyncIterator: j$, SymbolIterator: B$ } = jt, { Buffer: Xee } = ft, { ERR_INVALID_ARG_TYPE: Jee, ERR_STREAM_NULL_VALUES: Qee } = on.codes;
function Zee(e, t, r) {
  let n;
  if (typeof t == "string" || t instanceof Xee)
    return new e({
      objectMode: !0,
      ...r,
      read() {
        this.push(t), this.push(null);
      }
    });
  let o;
  if (t && t[j$])
    o = !0, n = t[j$]();
  else if (t && t[B$])
    o = !1, n = t[B$]();
  else
    throw new Jee("iterable", ["Iterable"], t);
  const s = new e({
    objectMode: !0,
    highWaterMark: 1,
    // TODO(ronag): What options should be allowed?
    ...r
  });
  let a = !1;
  s._read = function() {
    a || (a = !0, u());
  }, s._destroy = function(f, c) {
    Yee(
      l(f),
      () => F$.nextTick(c, f),
      // nextTick is here in case cb throws
      (d) => F$.nextTick(c, d || f)
    );
  };
  async function l(f) {
    const c = f != null, d = typeof n.throw == "function";
    if (c && d) {
      const { value: h, done: p } = await n.throw(f);
      if (await h, p)
        return;
    }
    if (typeof n.return == "function") {
      const { value: h } = await n.return();
      await h;
    }
  }
  async function u() {
    for (; ; ) {
      try {
        const { value: f, done: c } = o ? await n.next() : n.next();
        if (c)
          s.push(null);
        else {
          const d = f && typeof f.then == "function" ? await f : f;
          if (d === null)
            throw a = !1, new Qee();
          if (s.push(d))
            continue;
          a = !1;
        }
      } catch (f) {
        s.destroy(f);
      }
      break;
    }
  }
  return s;
}
var gF = Zee, Jb, q$;
function Hp() {
  if (q$)
    return Jb;
  q$ = 1;
  const e = St, {
    ArrayPrototypeIndexOf: t,
    NumberIsInteger: r,
    NumberIsNaN: n,
    NumberParseInt: o,
    ObjectDefineProperties: s,
    ObjectKeys: a,
    ObjectSetPrototypeOf: l,
    Promise: u,
    SafeSet: f,
    SymbolAsyncDispose: c,
    SymbolAsyncIterator: d,
    Symbol: h
  } = jt;
  Jb = B, B.ReadableState = ve;
  const { EventEmitter: p } = ur, { Stream: v, prependListener: y } = bx, { Buffer: w } = ft, { addAbortSignal: S } = Wp, x = ms;
  let E = Hr.debuglog("stream", (g) => {
    E = g;
  });
  const N = qee, C = hu, { getHighWaterMark: j, getDefaultHighWaterMark: J } = Up, {
    aggregateTwoErrors: z,
    codes: {
      ERR_INVALID_ARG_TYPE: $,
      ERR_METHOD_NOT_IMPLEMENTED: G,
      ERR_OUT_OF_RANGE: I,
      ERR_STREAM_PUSH_AFTER_EOF: W,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT: k
    },
    AbortError: U
  } = on, { validateObject: Z } = _c, Y = h("kPaused"), { StringDecoder: re } = Vl(), ae = gF;
  l(B.prototype, v.prototype), l(B, v);
  const ce = () => {
  }, { errorOrDestroy: pe } = C, le = 1, ye = 2, H = 4, ge = 8, Ce = 16, ue = 32, ee = 64, be = 128, Te = 256, Pe = 512, K = 1024, V = 2048, b = 4096, _ = 8192, T = 16384, L = 32768, O = 65536, ie = 1 << 17, fe = 1 << 18;
  function se(g) {
    return {
      enumerable: !1,
      get() {
        return (this.state & g) !== 0;
      },
      set(m) {
        m ? this.state |= g : this.state &= ~g;
      }
    };
  }
  s(ve.prototype, {
    objectMode: se(le),
    ended: se(ye),
    endEmitted: se(H),
    reading: se(ge),
    // Stream is still being constructed and cannot be
    // destroyed until construction finished or failed.
    // Async construction is opt in, therefore we start as
    // constructed.
    constructed: se(Ce),
    // A flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    sync: se(ue),
    // Whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    needReadable: se(ee),
    emittedReadable: se(be),
    readableListening: se(Te),
    resumeScheduled: se(Pe),
    // True if the error was already emitted and should not be thrown again.
    errorEmitted: se(K),
    emitClose: se(V),
    autoDestroy: se(b),
    // Has it been destroyed.
    destroyed: se(_),
    // Indicates whether the stream has finished destroying.
    closed: se(T),
    // True if close has been emitted or would have been emitted
    // depending on emitClose.
    closeEmitted: se(L),
    multiAwaitDrain: se(O),
    // If true, a maybeReadMore has been scheduled.
    readingMore: se(ie),
    dataEmitted: se(fe)
  });
  function ve(g, m, F) {
    typeof F != "boolean" && (F = m instanceof ao()), this.state = V | b | Ce | ue, g && g.objectMode && (this.state |= le), F && g && g.readableObjectMode && (this.state |= le), this.highWaterMark = g ? j(this, g, "readableHighWaterMark", F) : J(!1), this.buffer = new N(), this.length = 0, this.pipes = [], this.flowing = null, this[Y] = null, g && g.emitClose === !1 && (this.state &= ~V), g && g.autoDestroy === !1 && (this.state &= ~b), this.errored = null, this.defaultEncoding = g && g.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, g && g.encoding && (this.decoder = new re(g.encoding), this.encoding = g.encoding);
  }
  function B(g) {
    if (!(this instanceof B))
      return new B(g);
    const m = this instanceof ao();
    this._readableState = new ve(g, this, m), g && (typeof g.read == "function" && (this._read = g.read), typeof g.destroy == "function" && (this._destroy = g.destroy), typeof g.construct == "function" && (this._construct = g.construct), g.signal && !m && S(g.signal, this)), v.call(this, g), C.construct(this, () => {
      this._readableState.needReadable && ne(this, this._readableState);
    });
  }
  B.prototype.destroy = C.destroy, B.prototype._undestroy = C.undestroy, B.prototype._destroy = function(g, m) {
    m(g);
  }, B.prototype[p.captureRejectionSymbol] = function(g) {
    this.destroy(g);
  }, B.prototype[c] = function() {
    let g;
    return this.destroyed || (g = this.readableEnded ? null : new U(), this.destroy(g)), new u((m, F) => x(this, (D) => D && D !== g ? F(D) : m(null)));
  }, B.prototype.push = function(g, m) {
    return me(this, g, m, !1);
  }, B.prototype.unshift = function(g, m) {
    return me(this, g, m, !0);
  };
  function me(g, m, F, D) {
    E("readableAddChunk", m);
    const X = g._readableState;
    let Le;
    if (X.state & le || (typeof m == "string" ? (F = F || X.defaultEncoding, X.encoding !== F && (D && X.encoding ? m = w.from(m, F).toString(X.encoding) : (m = w.from(m, F), F = ""))) : m instanceof w ? F = "" : v._isUint8Array(m) ? (m = v._uint8ArrayToBuffer(m), F = "") : m != null && (Le = new $("chunk", ["string", "Buffer", "Uint8Array"], m))), Le)
      pe(g, Le);
    else if (m === null)
      X.state &= ~ge, R(g, X);
    else if (X.state & le || m && m.length > 0)
      if (D)
        if (X.state & H)
          pe(g, new k());
        else {
          if (X.destroyed || X.errored)
            return !1;
          ke(g, X, m, !0);
        }
      else if (X.ended)
        pe(g, new W());
      else {
        if (X.destroyed || X.errored)
          return !1;
        X.state &= ~ge, X.decoder && !F ? (m = X.decoder.write(m), X.objectMode || m.length !== 0 ? ke(g, X, m, !1) : ne(g, X)) : ke(g, X, m, !1);
      }
    else
      D || (X.state &= ~ge, ne(g, X));
    return !X.ended && (X.length < X.highWaterMark || X.length === 0);
  }
  function ke(g, m, F, D) {
    m.flowing && m.length === 0 && !m.sync && g.listenerCount("data") > 0 ? (m.state & O ? m.awaitDrainWriters.clear() : m.awaitDrainWriters = null, m.dataEmitted = !0, g.emit("data", F)) : (m.length += m.objectMode ? 1 : F.length, D ? m.buffer.unshift(F) : m.buffer.push(F), m.state & ee && A(g)), ne(g, m);
  }
  B.prototype.isPaused = function() {
    const g = this._readableState;
    return g[Y] === !0 || g.flowing === !1;
  }, B.prototype.setEncoding = function(g) {
    const m = new re(g);
    this._readableState.decoder = m, this._readableState.encoding = this._readableState.decoder.encoding;
    const F = this._readableState.buffer;
    let D = "";
    for (const X of F)
      D += m.write(X);
    return F.clear(), D !== "" && F.push(D), this._readableState.length = D.length, this;
  };
  const Ie = 1073741824;
  function Me(g) {
    if (g > Ie)
      throw new I("size", "<= 1GiB", g);
    return g--, g |= g >>> 1, g |= g >>> 2, g |= g >>> 4, g |= g >>> 8, g |= g >>> 16, g++, g;
  }
  function M(g, m) {
    return g <= 0 || m.length === 0 && m.ended ? 0 : m.state & le ? 1 : n(g) ? m.flowing && m.length ? m.buffer.first().length : m.length : g <= m.length ? g : m.ended ? m.length : 0;
  }
  B.prototype.read = function(g) {
    E("read", g), g === void 0 ? g = NaN : r(g) || (g = o(g, 10));
    const m = this._readableState, F = g;
    if (g > m.highWaterMark && (m.highWaterMark = Me(g)), g !== 0 && (m.state &= ~be), g === 0 && m.needReadable && ((m.highWaterMark !== 0 ? m.length >= m.highWaterMark : m.length > 0) || m.ended))
      return E("read: emitReadable", m.length, m.ended), m.length === 0 && m.ended ? Tt(this) : A(this), null;
    if (g = M(g, m), g === 0 && m.ended)
      return m.length === 0 && Tt(this), null;
    let D = (m.state & ee) !== 0;
    if (E("need readable", D), (m.length === 0 || m.length - g < m.highWaterMark) && (D = !0, E("length less than watermark", D)), m.ended || m.reading || m.destroyed || m.errored || !m.constructed)
      D = !1, E("reading, ended or constructing", D);
    else if (D) {
      E("do read"), m.state |= ge | ue, m.length === 0 && (m.state |= ee);
      try {
        this._read(m.highWaterMark);
      } catch (Le) {
        pe(this, Le);
      }
      m.state &= ~ue, m.reading || (g = M(F, m));
    }
    let X;
    return g > 0 ? X = Lr(g, m) : X = null, X === null ? (m.needReadable = m.length <= m.highWaterMark, g = 0) : (m.length -= g, m.multiAwaitDrain ? m.awaitDrainWriters.clear() : m.awaitDrainWriters = null), m.length === 0 && (m.ended || (m.needReadable = !0), F !== g && m.ended && Tt(this)), X !== null && !m.errorEmitted && !m.closeEmitted && (m.dataEmitted = !0, this.emit("data", X)), X;
  };
  function R(g, m) {
    if (E("onEofChunk"), !m.ended) {
      if (m.decoder) {
        const F = m.decoder.end();
        F && F.length && (m.buffer.push(F), m.length += m.objectMode ? 1 : F.length);
      }
      m.ended = !0, m.sync ? A(g) : (m.needReadable = !1, m.emittedReadable = !0, q(g));
    }
  }
  function A(g) {
    const m = g._readableState;
    E("emitReadable", m.needReadable, m.emittedReadable), m.needReadable = !1, m.emittedReadable || (E("emitReadable", m.flowing), m.emittedReadable = !0, e.nextTick(q, g));
  }
  function q(g) {
    const m = g._readableState;
    E("emitReadable_", m.destroyed, m.length, m.ended), !m.destroyed && !m.errored && (m.length || m.ended) && (g.emit("readable"), m.emittedReadable = !1), m.needReadable = !m.flowing && !m.ended && m.length <= m.highWaterMark, et(g);
  }
  function ne(g, m) {
    !m.readingMore && m.constructed && (m.readingMore = !0, e.nextTick(de, g, m));
  }
  function de(g, m) {
    for (; !m.reading && !m.ended && (m.length < m.highWaterMark || m.flowing && m.length === 0); ) {
      const F = m.length;
      if (E("maybeReadMore read 0"), g.read(0), F === m.length)
        break;
    }
    m.readingMore = !1;
  }
  B.prototype._read = function(g) {
    throw new G("_read()");
  }, B.prototype.pipe = function(g, m) {
    const F = this, D = this._readableState;
    D.pipes.length === 1 && (D.multiAwaitDrain || (D.multiAwaitDrain = !0, D.awaitDrainWriters = new f(D.awaitDrainWriters ? [D.awaitDrainWriters] : []))), D.pipes.push(g), E("pipe count=%d opts=%j", D.pipes.length, m);
    const Le = (!m || m.end !== !1) && g !== e.stdout && g !== e.stderr ? Xt : Et;
    D.endEmitted ? e.nextTick(Le) : F.once("end", Le), g.on("unpipe", Ue);
    function Ue(ct, nt) {
      E("onunpipe"), ct === F && nt && nt.hasUnpiped === !1 && (nt.hasUnpiped = !0, yn());
    }
    function Xt() {
      E("onend"), g.end();
    }
    let ht, Kr = !1;
    function yn() {
      E("cleanup"), g.removeListener("close", or), g.removeListener("finish", dr), ht && g.removeListener("drain", ht), g.removeListener("error", cr), g.removeListener("unpipe", Ue), F.removeListener("end", Xt), F.removeListener("end", Et), F.removeListener("data", Ar), Kr = !0, ht && D.awaitDrainWriters && (!g._writableState || g._writableState.needDrain) && ht();
    }
    function Wt() {
      Kr || (D.pipes.length === 1 && D.pipes[0] === g ? (E("false write response, pause", 0), D.awaitDrainWriters = g, D.multiAwaitDrain = !1) : D.pipes.length > 1 && D.pipes.includes(g) && (E("false write response, pause", D.awaitDrainWriters.size), D.awaitDrainWriters.add(g)), F.pause()), ht || (ht = he(F, g), g.on("drain", ht));
    }
    F.on("data", Ar);
    function Ar(ct) {
      E("ondata");
      const nt = g.write(ct);
      E("dest.write", nt), nt === !1 && Wt();
    }
    function cr(ct) {
      if (E("onerror", ct), Et(), g.removeListener("error", cr), g.listenerCount("error") === 0) {
        const nt = g._writableState || g._readableState;
        nt && !nt.errorEmitted ? pe(g, ct) : g.emit("error", ct);
      }
    }
    y(g, "error", cr);
    function or() {
      g.removeListener("finish", dr), Et();
    }
    g.once("close", or);
    function dr() {
      E("onfinish"), g.removeListener("close", or), Et();
    }
    g.once("finish", dr);
    function Et() {
      E("unpipe"), F.unpipe(g);
    }
    return g.emit("pipe", F), g.writableNeedDrain === !0 ? Wt() : D.flowing || (E("pipe resume"), F.resume()), g;
  };
  function he(g, m) {
    return function() {
      const D = g._readableState;
      D.awaitDrainWriters === m ? (E("pipeOnDrain", 1), D.awaitDrainWriters = null) : D.multiAwaitDrain && (E("pipeOnDrain", D.awaitDrainWriters.size), D.awaitDrainWriters.delete(m)), (!D.awaitDrainWriters || D.awaitDrainWriters.size === 0) && g.listenerCount("data") && g.resume();
    };
  }
  B.prototype.unpipe = function(g) {
    const m = this._readableState, F = {
      hasUnpiped: !1
    };
    if (m.pipes.length === 0)
      return this;
    if (!g) {
      const X = m.pipes;
      m.pipes = [], this.pause();
      for (let Le = 0; Le < X.length; Le++)
        X[Le].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    const D = t(m.pipes, g);
    return D === -1 ? this : (m.pipes.splice(D, 1), m.pipes.length === 0 && this.pause(), g.emit("unpipe", this, F), this);
  }, B.prototype.on = function(g, m) {
    const F = v.prototype.on.call(this, g, m), D = this._readableState;
    return g === "data" ? (D.readableListening = this.listenerCount("readable") > 0, D.flowing !== !1 && this.resume()) : g === "readable" && !D.endEmitted && !D.readableListening && (D.readableListening = D.needReadable = !0, D.flowing = !1, D.emittedReadable = !1, E("on readable", D.length, D.reading), D.length ? A(this) : D.reading || e.nextTick(ot, this)), F;
  }, B.prototype.addListener = B.prototype.on, B.prototype.removeListener = function(g, m) {
    const F = v.prototype.removeListener.call(this, g, m);
    return g === "readable" && e.nextTick(Fe, this), F;
  }, B.prototype.off = B.prototype.removeListener, B.prototype.removeAllListeners = function(g) {
    const m = v.prototype.removeAllListeners.apply(this, arguments);
    return (g === "readable" || g === void 0) && e.nextTick(Fe, this), m;
  };
  function Fe(g) {
    const m = g._readableState;
    m.readableListening = g.listenerCount("readable") > 0, m.resumeScheduled && m[Y] === !1 ? m.flowing = !0 : g.listenerCount("data") > 0 ? g.resume() : m.readableListening || (m.flowing = null);
  }
  function ot(g) {
    E("readable nexttick read 0"), g.read(0);
  }
  B.prototype.resume = function() {
    const g = this._readableState;
    return g.flowing || (E("resume"), g.flowing = !g.readableListening, ze(this, g)), g[Y] = !1, this;
  };
  function ze(g, m) {
    m.resumeScheduled || (m.resumeScheduled = !0, e.nextTick(Ke, g, m));
  }
  function Ke(g, m) {
    E("resume", m.reading), m.reading || g.read(0), m.resumeScheduled = !1, g.emit("resume"), et(g), m.flowing && !m.reading && g.read(0);
  }
  B.prototype.pause = function() {
    return E("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (E("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState[Y] = !0, this;
  };
  function et(g) {
    const m = g._readableState;
    for (E("flow", m.flowing); m.flowing && g.read() !== null; )
      ;
  }
  B.prototype.wrap = function(g) {
    let m = !1;
    g.on("data", (D) => {
      !this.push(D) && g.pause && (m = !0, g.pause());
    }), g.on("end", () => {
      this.push(null);
    }), g.on("error", (D) => {
      pe(this, D);
    }), g.on("close", () => {
      this.destroy();
    }), g.on("destroy", () => {
      this.destroy();
    }), this._read = () => {
      m && g.resume && (m = !1, g.resume());
    };
    const F = a(g);
    for (let D = 1; D < F.length; D++) {
      const X = F[D];
      this[X] === void 0 && typeof g[X] == "function" && (this[X] = g[X].bind(g));
    }
    return this;
  }, B.prototype[d] = function() {
    return Rr(this);
  }, B.prototype.iterator = function(g) {
    return g !== void 0 && Z(g, "options"), Rr(this, g);
  };
  function Rr(g, m) {
    typeof g.read != "function" && (g = B.wrap(g, {
      objectMode: !0
    }));
    const F = Wi(g, m);
    return F.stream = g, F;
  }
  async function* Wi(g, m) {
    let F = ce;
    function D(Ue) {
      this === g ? (F(), F = ce) : F = Ue;
    }
    g.on("readable", D);
    let X;
    const Le = x(
      g,
      {
        writable: !1
      },
      (Ue) => {
        X = Ue ? z(X, Ue) : null, F(), F = ce;
      }
    );
    try {
      for (; ; ) {
        const Ue = g.destroyed ? null : g.read();
        if (Ue !== null)
          yield Ue;
        else {
          if (X)
            throw X;
          if (X === null)
            return;
          await new u(D);
        }
      }
    } catch (Ue) {
      throw X = z(X, Ue), X;
    } finally {
      (X || (m == null ? void 0 : m.destroyOnReturn) !== !1) && (X === void 0 || g._readableState.autoDestroy) ? C.destroyer(g, null) : (g.off("readable", D), Le());
    }
  }
  s(B.prototype, {
    readable: {
      __proto__: null,
      get() {
        const g = this._readableState;
        return !!g && g.readable !== !1 && !g.destroyed && !g.errorEmitted && !g.endEmitted;
      },
      set(g) {
        this._readableState && (this._readableState.readable = !!g);
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(g) {
        this._readableState && (this._readableState.flowing = g);
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.objectMode : !1;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.destroyed : !1;
      },
      set(g) {
        this._readableState && (this._readableState.destroyed = g);
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.endEmitted : !1;
      }
    }
  }), s(ve.prototype, {
    // Legacy getter for `pipesCount`.
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    // Legacy property for `paused`.
    paused: {
      __proto__: null,
      get() {
        return this[Y] !== !1;
      },
      set(g) {
        this[Y] = !!g;
      }
    }
  }), B._fromList = Lr;
  function Lr(g, m) {
    if (m.length === 0)
      return null;
    let F;
    return m.objectMode ? F = m.buffer.shift() : !g || g >= m.length ? (m.decoder ? F = m.buffer.join("") : m.buffer.length === 1 ? F = m.buffer.first() : F = m.buffer.concat(m.length), m.buffer.clear()) : F = m.buffer.consume(g, m.decoder), F;
  }
  function Tt(g) {
    const m = g._readableState;
    E("endReadable", m.endEmitted), m.endEmitted || (m.ended = !0, e.nextTick(si, m, g));
  }
  function si(g, m) {
    if (E("endReadableNT", g.endEmitted, g.length), !g.errored && !g.closeEmitted && !g.endEmitted && g.length === 0) {
      if (g.endEmitted = !0, m.emit("end"), m.writable && m.allowHalfOpen === !1)
        e.nextTick(Ui, m);
      else if (g.autoDestroy) {
        const F = m._writableState;
        (!F || F.autoDestroy && // We don't expect the writable to ever 'finish'
        // if writable is explicitly set to false.
        (F.finished || F.writable === !1)) && m.destroy();
      }
    }
  }
  function Ui(g) {
    g.writable && !g.writableEnded && !g.destroyed && g.end();
  }
  B.from = function(g, m) {
    return ae(B, g, m);
  };
  let Mt;
  function ln() {
    return Mt === void 0 && (Mt = {}), Mt;
  }
  return B.fromWeb = function(g, m) {
    return ln().newStreamReadableFromReadableStream(g, m);
  }, B.toWeb = function(g, m) {
    return ln().newReadableStreamFromStreamReadable(g, m);
  }, B.wrap = function(g, m) {
    var F, D;
    return new B({
      objectMode: (F = (D = g.readableObjectMode) !== null && D !== void 0 ? D : g.objectMode) !== null && F !== void 0 ? F : !0,
      ...m,
      destroy(X, Le) {
        C.destroyer(g, X), Le(X);
      }
    }).wrap(g);
  }, Jb;
}
var Qb, W$;
function yx() {
  if (W$)
    return Qb;
  W$ = 1;
  const e = St, {
    ArrayPrototypeSlice: t,
    Error: r,
    FunctionPrototypeSymbolHasInstance: n,
    ObjectDefineProperty: o,
    ObjectDefineProperties: s,
    ObjectSetPrototypeOf: a,
    StringPrototypeToLowerCase: l,
    Symbol: u,
    SymbolHasInstance: f
  } = jt;
  Qb = Z, Z.WritableState = k;
  const { EventEmitter: c } = ur, d = bx.Stream, { Buffer: h } = ft, p = hu, { addAbortSignal: v } = Wp, { getHighWaterMark: y, getDefaultHighWaterMark: w } = Up, {
    ERR_INVALID_ARG_TYPE: S,
    ERR_METHOD_NOT_IMPLEMENTED: x,
    ERR_MULTIPLE_CALLBACK: E,
    ERR_STREAM_CANNOT_PIPE: N,
    ERR_STREAM_DESTROYED: C,
    ERR_STREAM_ALREADY_FINISHED: j,
    ERR_STREAM_NULL_VALUES: J,
    ERR_STREAM_WRITE_AFTER_END: z,
    ERR_UNKNOWN_ENCODING: $
  } = on.codes, { errorOrDestroy: G } = p;
  a(Z.prototype, d.prototype), a(Z, d);
  function I() {
  }
  const W = u("kOnFinished");
  function k(b, _, T) {
    typeof T != "boolean" && (T = _ instanceof ao()), this.objectMode = !!(b && b.objectMode), T && (this.objectMode = this.objectMode || !!(b && b.writableObjectMode)), this.highWaterMark = b ? y(this, b, "writableHighWaterMark", T) : w(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    const L = !!(b && b.decodeStrings === !1);
    this.decodeStrings = !L, this.defaultEncoding = b && b.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = pe.bind(void 0, _), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, U(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !b || b.emitClose !== !1, this.autoDestroy = !b || b.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[W] = [];
  }
  function U(b) {
    b.buffered = [], b.bufferedIndex = 0, b.allBuffers = !0, b.allNoop = !0;
  }
  k.prototype.getBuffer = function() {
    return t(this.buffered, this.bufferedIndex);
  }, o(k.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function Z(b) {
    const _ = this instanceof ao();
    if (!_ && !n(Z, this))
      return new Z(b);
    this._writableState = new k(b, this, _), b && (typeof b.write == "function" && (this._write = b.write), typeof b.writev == "function" && (this._writev = b.writev), typeof b.destroy == "function" && (this._destroy = b.destroy), typeof b.final == "function" && (this._final = b.final), typeof b.construct == "function" && (this._construct = b.construct), b.signal && v(b.signal, this)), d.call(this, b), p.construct(this, () => {
      const T = this._writableState;
      T.writing || ge(this, T), be(this, T);
    });
  }
  o(Z, f, {
    __proto__: null,
    value: function(b) {
      return n(this, b) ? !0 : this !== Z ? !1 : b && b._writableState instanceof k;
    }
  }), Z.prototype.pipe = function() {
    G(this, new N());
  };
  function Y(b, _, T, L) {
    const O = b._writableState;
    if (typeof T == "function")
      L = T, T = O.defaultEncoding;
    else {
      if (!T)
        T = O.defaultEncoding;
      else if (T !== "buffer" && !h.isEncoding(T))
        throw new $(T);
      typeof L != "function" && (L = I);
    }
    if (_ === null)
      throw new J();
    if (!O.objectMode)
      if (typeof _ == "string")
        O.decodeStrings !== !1 && (_ = h.from(_, T), T = "buffer");
      else if (_ instanceof h)
        T = "buffer";
      else if (d._isUint8Array(_))
        _ = d._uint8ArrayToBuffer(_), T = "buffer";
      else
        throw new S("chunk", ["string", "Buffer", "Uint8Array"], _);
    let ie;
    return O.ending ? ie = new z() : O.destroyed && (ie = new C("write")), ie ? (e.nextTick(L, ie), G(b, ie, !0), ie) : (O.pendingcb++, re(b, O, _, T, L));
  }
  Z.prototype.write = function(b, _, T) {
    return Y(this, b, _, T) === !0;
  }, Z.prototype.cork = function() {
    this._writableState.corked++;
  }, Z.prototype.uncork = function() {
    const b = this._writableState;
    b.corked && (b.corked--, b.writing || ge(this, b));
  }, Z.prototype.setDefaultEncoding = function(_) {
    if (typeof _ == "string" && (_ = l(_)), !h.isEncoding(_))
      throw new $(_);
    return this._writableState.defaultEncoding = _, this;
  };
  function re(b, _, T, L, O) {
    const ie = _.objectMode ? 1 : T.length;
    _.length += ie;
    const fe = _.length < _.highWaterMark;
    return fe || (_.needDrain = !0), _.writing || _.corked || _.errored || !_.constructed ? (_.buffered.push({
      chunk: T,
      encoding: L,
      callback: O
    }), _.allBuffers && L !== "buffer" && (_.allBuffers = !1), _.allNoop && O !== I && (_.allNoop = !1)) : (_.writelen = ie, _.writecb = O, _.writing = !0, _.sync = !0, b._write(T, L, _.onwrite), _.sync = !1), fe && !_.errored && !_.destroyed;
  }
  function ae(b, _, T, L, O, ie, fe) {
    _.writelen = L, _.writecb = fe, _.writing = !0, _.sync = !0, _.destroyed ? _.onwrite(new C("write")) : T ? b._writev(O, _.onwrite) : b._write(O, ie, _.onwrite), _.sync = !1;
  }
  function ce(b, _, T, L) {
    --_.pendingcb, L(T), H(_), G(b, T);
  }
  function pe(b, _) {
    const T = b._writableState, L = T.sync, O = T.writecb;
    if (typeof O != "function") {
      G(b, new E());
      return;
    }
    T.writing = !1, T.writecb = null, T.length -= T.writelen, T.writelen = 0, _ ? (_.stack, T.errored || (T.errored = _), b._readableState && !b._readableState.errored && (b._readableState.errored = _), L ? e.nextTick(ce, b, T, _, O) : ce(b, T, _, O)) : (T.buffered.length > T.bufferedIndex && ge(b, T), L ? T.afterWriteTickInfo !== null && T.afterWriteTickInfo.cb === O ? T.afterWriteTickInfo.count++ : (T.afterWriteTickInfo = {
      count: 1,
      cb: O,
      stream: b,
      state: T
    }, e.nextTick(le, T.afterWriteTickInfo)) : ye(b, T, 1, O));
  }
  function le({ stream: b, state: _, count: T, cb: L }) {
    return _.afterWriteTickInfo = null, ye(b, _, T, L);
  }
  function ye(b, _, T, L) {
    for (!_.ending && !b.destroyed && _.length === 0 && _.needDrain && (_.needDrain = !1, b.emit("drain")); T-- > 0; )
      _.pendingcb--, L();
    _.destroyed && H(_), be(b, _);
  }
  function H(b) {
    if (b.writing)
      return;
    for (let O = b.bufferedIndex; O < b.buffered.length; ++O) {
      var _;
      const { chunk: ie, callback: fe } = b.buffered[O], se = b.objectMode ? 1 : ie.length;
      b.length -= se, fe(
        (_ = b.errored) !== null && _ !== void 0 ? _ : new C("write")
      );
    }
    const T = b[W].splice(0);
    for (let O = 0; O < T.length; O++) {
      var L;
      T[O](
        (L = b.errored) !== null && L !== void 0 ? L : new C("end")
      );
    }
    U(b);
  }
  function ge(b, _) {
    if (_.corked || _.bufferProcessing || _.destroyed || !_.constructed)
      return;
    const { buffered: T, bufferedIndex: L, objectMode: O } = _, ie = T.length - L;
    if (!ie)
      return;
    let fe = L;
    if (_.bufferProcessing = !0, ie > 1 && b._writev) {
      _.pendingcb -= ie - 1;
      const se = _.allNoop ? I : (B) => {
        for (let me = fe; me < T.length; ++me)
          T[me].callback(B);
      }, ve = _.allNoop && fe === 0 ? T : t(T, fe);
      ve.allBuffers = _.allBuffers, ae(b, _, !0, _.length, ve, "", se), U(_);
    } else {
      do {
        const { chunk: se, encoding: ve, callback: B } = T[fe];
        T[fe++] = null;
        const me = O ? 1 : se.length;
        ae(b, _, !1, me, se, ve, B);
      } while (fe < T.length && !_.writing);
      fe === T.length ? U(_) : fe > 256 ? (T.splice(0, fe), _.bufferedIndex = 0) : _.bufferedIndex = fe;
    }
    _.bufferProcessing = !1;
  }
  Z.prototype._write = function(b, _, T) {
    if (this._writev)
      this._writev(
        [
          {
            chunk: b,
            encoding: _
          }
        ],
        T
      );
    else
      throw new x("_write()");
  }, Z.prototype._writev = null, Z.prototype.end = function(b, _, T) {
    const L = this._writableState;
    typeof b == "function" ? (T = b, b = null, _ = null) : typeof _ == "function" && (T = _, _ = null);
    let O;
    if (b != null) {
      const ie = Y(this, b, _);
      ie instanceof r && (O = ie);
    }
    return L.corked && (L.corked = 1, this.uncork()), O || (!L.errored && !L.ending ? (L.ending = !0, be(this, L, !0), L.ended = !0) : L.finished ? O = new j("end") : L.destroyed && (O = new C("end"))), typeof T == "function" && (O || L.finished ? e.nextTick(T, O) : L[W].push(T)), this;
  };
  function Ce(b) {
    return b.ending && !b.destroyed && b.constructed && b.length === 0 && !b.errored && b.buffered.length === 0 && !b.finished && !b.writing && !b.errorEmitted && !b.closeEmitted;
  }
  function ue(b, _) {
    let T = !1;
    function L(O) {
      if (T) {
        G(b, O ?? E());
        return;
      }
      if (T = !0, _.pendingcb--, O) {
        const ie = _[W].splice(0);
        for (let fe = 0; fe < ie.length; fe++)
          ie[fe](O);
        G(b, O, _.sync);
      } else
        Ce(_) && (_.prefinished = !0, b.emit("prefinish"), _.pendingcb++, e.nextTick(Te, b, _));
    }
    _.sync = !0, _.pendingcb++;
    try {
      b._final(L);
    } catch (O) {
      L(O);
    }
    _.sync = !1;
  }
  function ee(b, _) {
    !_.prefinished && !_.finalCalled && (typeof b._final == "function" && !_.destroyed ? (_.finalCalled = !0, ue(b, _)) : (_.prefinished = !0, b.emit("prefinish")));
  }
  function be(b, _, T) {
    Ce(_) && (ee(b, _), _.pendingcb === 0 && (T ? (_.pendingcb++, e.nextTick(
      (L, O) => {
        Ce(O) ? Te(L, O) : O.pendingcb--;
      },
      b,
      _
    )) : Ce(_) && (_.pendingcb++, Te(b, _))));
  }
  function Te(b, _) {
    _.pendingcb--, _.finished = !0;
    const T = _[W].splice(0);
    for (let L = 0; L < T.length; L++)
      T[L]();
    if (b.emit("finish"), _.autoDestroy) {
      const L = b._readableState;
      (!L || L.autoDestroy && // We don't expect the readable to ever 'end'
      // if readable is explicitly set to false.
      (L.endEmitted || L.readable === !1)) && b.destroy();
    }
  }
  s(Z.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : !1;
      },
      set(b) {
        this._writableState && (this._writableState.destroyed = b);
      }
    },
    writable: {
      __proto__: null,
      get() {
        const b = this._writableState;
        return !!b && b.writable !== !1 && !b.destroyed && !b.errored && !b.ending && !b.ended;
      },
      set(b) {
        this._writableState && (this._writableState.writable = !!b);
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : !1;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : !1;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : !1;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const b = this._writableState;
        return b ? !b.destroyed && !b.ending && b.needDrain : !1;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  const Pe = p.destroy;
  Z.prototype.destroy = function(b, _) {
    const T = this._writableState;
    return !T.destroyed && (T.bufferedIndex < T.buffered.length || T[W].length) && e.nextTick(H, T), Pe.call(this, b, _), this;
  }, Z.prototype._undestroy = p.undestroy, Z.prototype._destroy = function(b, _) {
    _(b);
  }, Z.prototype[c.captureRejectionSymbol] = function(b) {
    this.destroy(b);
  };
  let K;
  function V() {
    return K === void 0 && (K = {}), K;
  }
  return Z.fromWeb = function(b, _) {
    return V().newStreamWritableFromWritableStream(b, _);
  }, Z.toWeb = function(b) {
    return V().newWritableStreamFromStreamWritable(b);
  }, Qb;
}
var Zb, U$;
function ete() {
  if (U$)
    return Zb;
  U$ = 1;
  const e = St, t = ft, {
    isReadable: r,
    isWritable: n,
    isIterable: o,
    isNodeStream: s,
    isReadableNodeStream: a,
    isWritableNodeStream: l,
    isDuplexNodeStream: u,
    isReadableStream: f,
    isWritableStream: c
  } = Ro, d = ms, {
    AbortError: h,
    codes: { ERR_INVALID_ARG_TYPE: p, ERR_INVALID_RETURN_VALUE: v }
  } = on, { destroyer: y } = hu, w = ao(), S = Hp(), x = yx(), { createDeferredPromise: E } = Hr, N = gF, C = globalThis.Blob || t.Blob, j = typeof C < "u" ? function(k) {
    return k instanceof C;
  } : function(k) {
    return !1;
  }, J = globalThis.AbortController || Kt().AbortController, { FunctionPrototypeCall: z } = jt;
  class $ extends w {
    constructor(k) {
      super(k), (k == null ? void 0 : k.readable) === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), (k == null ? void 0 : k.writable) === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0);
    }
  }
  Zb = function W(k, U) {
    if (u(k))
      return k;
    if (a(k))
      return I({
        readable: k
      });
    if (l(k))
      return I({
        writable: k
      });
    if (s(k))
      return I({
        writable: !1,
        readable: !1
      });
    if (f(k))
      return I({
        readable: S.fromWeb(k)
      });
    if (c(k))
      return I({
        writable: x.fromWeb(k)
      });
    if (typeof k == "function") {
      const { value: Y, write: re, final: ae, destroy: ce } = G(k);
      if (o(Y))
        return N($, Y, {
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          write: re,
          final: ae,
          destroy: ce
        });
      const pe = Y == null ? void 0 : Y.then;
      if (typeof pe == "function") {
        let le;
        const ye = z(
          pe,
          Y,
          (H) => {
            if (H != null)
              throw new v("nully", "body", H);
          },
          (H) => {
            y(le, H);
          }
        );
        return le = new $({
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          readable: !1,
          write: re,
          final(H) {
            ae(async () => {
              try {
                await ye, e.nextTick(H, null);
              } catch (ge) {
                e.nextTick(H, ge);
              }
            });
          },
          destroy: ce
        });
      }
      throw new v("Iterable, AsyncIterable or AsyncFunction", U, Y);
    }
    if (j(k))
      return W(k.arrayBuffer());
    if (o(k))
      return N($, k, {
        // TODO (ronag): highWaterMark?
        objectMode: !0,
        writable: !1
      });
    if (f(k == null ? void 0 : k.readable) && c(k == null ? void 0 : k.writable))
      return $.fromWeb(k);
    if (typeof (k == null ? void 0 : k.writable) == "object" || typeof (k == null ? void 0 : k.readable) == "object") {
      const Y = k != null && k.readable ? a(k == null ? void 0 : k.readable) ? k == null ? void 0 : k.readable : W(k.readable) : void 0, re = k != null && k.writable ? l(k == null ? void 0 : k.writable) ? k == null ? void 0 : k.writable : W(k.writable) : void 0;
      return I({
        readable: Y,
        writable: re
      });
    }
    const Z = k == null ? void 0 : k.then;
    if (typeof Z == "function") {
      let Y;
      return z(
        Z,
        k,
        (re) => {
          re != null && Y.push(re), Y.push(null);
        },
        (re) => {
          y(Y, re);
        }
      ), Y = new $({
        objectMode: !0,
        writable: !1,
        read() {
        }
      });
    }
    throw new p(
      U,
      [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise"
      ],
      k
    );
  };
  function G(W) {
    let { promise: k, resolve: U } = E();
    const Z = new J(), Y = Z.signal;
    return {
      value: W(
        async function* () {
          for (; ; ) {
            const ae = k;
            k = null;
            const { chunk: ce, done: pe, cb: le } = await ae;
            if (e.nextTick(le), pe)
              return;
            if (Y.aborted)
              throw new h(void 0, {
                cause: Y.reason
              });
            ({ promise: k, resolve: U } = E()), yield ce;
          }
        }(),
        {
          signal: Y
        }
      ),
      write(ae, ce, pe) {
        const le = U;
        U = null, le({
          chunk: ae,
          done: !1,
          cb: pe
        });
      },
      final(ae) {
        const ce = U;
        U = null, ce({
          done: !0,
          cb: ae
        });
      },
      destroy(ae, ce) {
        Z.abort(), ce(ae);
      }
    };
  }
  function I(W) {
    const k = W.readable && typeof W.readable.read != "function" ? S.wrap(W.readable) : W.readable, U = W.writable;
    let Z = !!r(k), Y = !!n(U), re, ae, ce, pe, le;
    function ye(H) {
      const ge = pe;
      pe = null, ge ? ge(H) : H && le.destroy(H);
    }
    return le = new $({
      // TODO (ronag): highWaterMark?
      readableObjectMode: !!(k != null && k.readableObjectMode),
      writableObjectMode: !!(U != null && U.writableObjectMode),
      readable: Z,
      writable: Y
    }), Y && (d(U, (H) => {
      Y = !1, H && y(k, H), ye(H);
    }), le._write = function(H, ge, Ce) {
      U.write(H, ge) ? Ce() : re = Ce;
    }, le._final = function(H) {
      U.end(), ae = H;
    }, U.on("drain", function() {
      if (re) {
        const H = re;
        re = null, H();
      }
    }), U.on("finish", function() {
      if (ae) {
        const H = ae;
        ae = null, H();
      }
    })), Z && (d(k, (H) => {
      Z = !1, H && y(k, H), ye(H);
    }), k.on("readable", function() {
      if (ce) {
        const H = ce;
        ce = null, H();
      }
    }), k.on("end", function() {
      le.push(null);
    }), le._read = function() {
      for (; ; ) {
        const H = k.read();
        if (H === null) {
          ce = le._read;
          return;
        }
        if (!le.push(H))
          return;
      }
    }), le._destroy = function(H, ge) {
      !H && pe !== null && (H = new h()), ce = null, re = null, ae = null, pe === null ? ge(H) : (pe = ge, y(U, H), y(k, H));
    }, le;
  }
  return Zb;
}
var ey, H$;
function ao() {
  if (H$)
    return ey;
  H$ = 1;
  const {
    ObjectDefineProperties: e,
    ObjectGetOwnPropertyDescriptor: t,
    ObjectKeys: r,
    ObjectSetPrototypeOf: n
  } = jt;
  ey = a;
  const o = Hp(), s = yx();
  n(a.prototype, o.prototype), n(a, o);
  {
    const c = r(s.prototype);
    for (let d = 0; d < c.length; d++) {
      const h = c[d];
      a.prototype[h] || (a.prototype[h] = s.prototype[h]);
    }
  }
  function a(c) {
    if (!(this instanceof a))
      return new a(c);
    o.call(this, c), s.call(this, c), c ? (this.allowHalfOpen = c.allowHalfOpen !== !1, c.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), c.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0)) : this.allowHalfOpen = !0;
  }
  e(a.prototype, {
    writable: {
      __proto__: null,
      ...t(s.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...t(s.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...t(s.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...t(s.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...t(s.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...t(s.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...t(s.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...t(s.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...t(s.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
      },
      set(c) {
        this._readableState && this._writableState && (this._readableState.destroyed = c, this._writableState.destroyed = c);
      }
    }
  });
  let l;
  function u() {
    return l === void 0 && (l = {}), l;
  }
  a.fromWeb = function(c, d) {
    return u().newStreamDuplexFromReadableWritablePair(c, d);
  }, a.toWeb = function(c) {
    return u().newReadableWritablePairFromDuplex(c);
  };
  let f;
  return a.from = function(c) {
    return f || (f = ete()), f(c, "body");
  }, ey;
}
const { ObjectSetPrototypeOf: bF, Symbol: tte } = jt;
var yF = lo;
const { ERR_METHOD_NOT_IMPLEMENTED: rte } = on.codes, vx = ao(), { getHighWaterMark: nte } = Up;
bF(lo.prototype, vx.prototype);
bF(lo, vx);
const Ef = tte("kCallback");
function lo(e) {
  if (!(this instanceof lo))
    return new lo(e);
  const t = e ? nte(this, e, "readableHighWaterMark", !0) : null;
  t === 0 && (e = {
    ...e,
    highWaterMark: null,
    readableHighWaterMark: t,
    // TODO (ronag): 0 is not optimal since we have
    // a "bug" where we check needDrain before calling _write and not after.
    // Refs: https://github.com/nodejs/node/pull/32887
    // Refs: https://github.com/nodejs/node/pull/35941
    writableHighWaterMark: e.writableHighWaterMark || 0
  }), vx.call(this, e), this._readableState.sync = !1, this[Ef] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", ite);
}
function lS(e) {
  typeof this._flush == "function" && !this.destroyed ? this._flush((t, r) => {
    if (t) {
      e ? e(t) : this.destroy(t);
      return;
    }
    r != null && this.push(r), this.push(null), e && e();
  }) : (this.push(null), e && e());
}
function ite() {
  this._final !== lS && lS.call(this);
}
lo.prototype._final = lS;
lo.prototype._transform = function(e, t, r) {
  throw new rte("_transform()");
};
lo.prototype._write = function(e, t, r) {
  const n = this._readableState, o = this._writableState, s = n.length;
  this._transform(e, t, (a, l) => {
    if (a) {
      r(a);
      return;
    }
    l != null && this.push(l), o.ended || // Backwards compat.
    s === n.length || // Backwards compat.
    n.length < n.highWaterMark ? r() : this[Ef] = r;
  });
};
lo.prototype._read = function() {
  if (this[Ef]) {
    const e = this[Ef];
    this[Ef] = null, e();
  }
};
const { ObjectSetPrototypeOf: vF } = jt;
var mF = Gl;
const mx = yF;
vF(Gl.prototype, mx.prototype);
vF(Gl, mx);
function Gl(e) {
  if (!(this instanceof Gl))
    return new Gl(e);
  mx.call(this, e);
}
Gl.prototype._transform = function(e, t, r) {
  r(null, e);
};
const Xu = St, { ArrayIsArray: ote, Promise: ste, SymbolAsyncIterator: ate, SymbolDispose: lte } = jt, vh = ms, { once: ute } = Hr, fte = hu, V$ = ao(), {
  aggregateTwoErrors: cte,
  codes: {
    ERR_INVALID_ARG_TYPE: uS,
    ERR_INVALID_RETURN_VALUE: ty,
    ERR_MISSING_ARGS: dte,
    ERR_STREAM_DESTROYED: hte,
    ERR_STREAM_PREMATURE_CLOSE: pte
  },
  AbortError: gte
} = on, { validateFunction: bte, validateAbortSignal: yte } = _c, {
  isIterable: Bs,
  isReadable: ry,
  isReadableNodeStream: qd,
  isNodeStream: z$,
  isTransformStream: yl,
  isWebStream: vte,
  isReadableStream: ny,
  isReadableFinished: mte
} = Ro, _te = globalThis.AbortController || Kt().AbortController;
let iy, oy, sy;
function G$(e, t, r) {
  let n = !1;
  e.on("close", () => {
    n = !0;
  });
  const o = vh(
    e,
    {
      readable: t,
      writable: r
    },
    (s) => {
      n = !s;
    }
  );
  return {
    destroy: (s) => {
      n || (n = !0, fte.destroyer(e, s || new hte("pipe")));
    },
    cleanup: o
  };
}
function wte(e) {
  return bte(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
}
function ay(e) {
  if (Bs(e))
    return e;
  if (qd(e))
    return Ste(e);
  throw new uS("val", ["Readable", "Iterable", "AsyncIterable"], e);
}
async function* Ste(e) {
  oy || (oy = Hp()), yield* oy.prototype[ate].call(e);
}
async function nd(e, t, r, { end: n }) {
  let o, s = null;
  const a = (f) => {
    if (f && (o = f), s) {
      const c = s;
      s = null, c();
    }
  }, l = () => new ste((f, c) => {
    o ? c(o) : s = () => {
      o ? c(o) : f();
    };
  });
  t.on("drain", a);
  const u = vh(
    t,
    {
      readable: !1
    },
    a
  );
  try {
    t.writableNeedDrain && await l();
    for await (const f of e)
      t.write(f) || await l();
    n && (t.end(), await l()), r();
  } catch (f) {
    r(o !== f ? cte(o, f) : f);
  } finally {
    u(), t.off("drain", a);
  }
}
async function ly(e, t, r, { end: n }) {
  yl(t) && (t = t.writable);
  const o = t.getWriter();
  try {
    for await (const s of e)
      await o.ready, o.write(s).catch(() => {
      });
    await o.ready, n && await o.close(), r();
  } catch (s) {
    try {
      await o.abort(s), r(s);
    } catch (a) {
      r(a);
    }
  }
}
function Ete(...e) {
  return _F(e, ute(wte(e)));
}
function _F(e, t, r) {
  if (e.length === 1 && ote(e[0]) && (e = e[0]), e.length < 2)
    throw new dte("streams");
  const n = new _te(), o = n.signal, s = r == null ? void 0 : r.signal, a = [];
  yte(s, "options.signal");
  function l() {
    v(new gte());
  }
  sy = sy || Hr.addAbortListener;
  let u;
  s && (u = sy(s, l));
  let f, c;
  const d = [];
  let h = 0;
  function p(x) {
    v(x, --h === 0);
  }
  function v(x, E) {
    var N;
    if (x && (!f || f.code === "ERR_STREAM_PREMATURE_CLOSE") && (f = x), !(!f && !E)) {
      for (; d.length; )
        d.shift()(f);
      (N = u) === null || N === void 0 || N[lte](), n.abort(), E && (f || a.forEach((C) => C()), Xu.nextTick(t, f, c));
    }
  }
  let y;
  for (let x = 0; x < e.length; x++) {
    const E = e[x], N = x < e.length - 1, C = x > 0, j = N || (r == null ? void 0 : r.end) !== !1, J = x === e.length - 1;
    if (z$(E)) {
      let z = function($) {
        $ && $.name !== "AbortError" && $.code !== "ERR_STREAM_PREMATURE_CLOSE" && p($);
      };
      if (j) {
        const { destroy: $, cleanup: G } = G$(E, N, C);
        d.push($), ry(E) && J && a.push(G);
      }
      E.on("error", z), ry(E) && J && a.push(() => {
        E.removeListener("error", z);
      });
    }
    if (x === 0)
      if (typeof E == "function") {
        if (y = E({
          signal: o
        }), !Bs(y))
          throw new ty("Iterable, AsyncIterable or Stream", "source", y);
      } else
        Bs(E) || qd(E) || yl(E) ? y = E : y = V$.from(E);
    else if (typeof E == "function") {
      if (yl(y)) {
        var w;
        y = ay((w = y) === null || w === void 0 ? void 0 : w.readable);
      } else
        y = ay(y);
      if (y = E(y, {
        signal: o
      }), N) {
        if (!Bs(y, !0))
          throw new ty("AsyncIterable", `transform[${x - 1}]`, y);
      } else {
        var S;
        iy || (iy = mF);
        const z = new iy({
          objectMode: !0
        }), $ = (S = y) === null || S === void 0 ? void 0 : S.then;
        if (typeof $ == "function")
          h++, $.call(
            y,
            (W) => {
              c = W, W != null && z.write(W), j && z.end(), Xu.nextTick(p);
            },
            (W) => {
              z.destroy(W), Xu.nextTick(p, W);
            }
          );
        else if (Bs(y, !0))
          h++, nd(y, z, p, {
            end: j
          });
        else if (ny(y) || yl(y)) {
          const W = y.readable || y;
          h++, nd(W, z, p, {
            end: j
          });
        } else
          throw new ty("AsyncIterable or Promise", "destination", y);
        y = z;
        const { destroy: G, cleanup: I } = G$(y, !1, !0);
        d.push(G), J && a.push(I);
      }
    } else if (z$(E)) {
      if (qd(y)) {
        h += 2;
        const z = xte(y, E, p, {
          end: j
        });
        ry(E) && J && a.push(z);
      } else if (yl(y) || ny(y)) {
        const z = y.readable || y;
        h++, nd(z, E, p, {
          end: j
        });
      } else if (Bs(y))
        h++, nd(y, E, p, {
          end: j
        });
      else
        throw new uS(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          y
        );
      y = E;
    } else if (vte(E)) {
      if (qd(y))
        h++, ly(ay(y), E, p, {
          end: j
        });
      else if (ny(y) || Bs(y))
        h++, ly(y, E, p, {
          end: j
        });
      else if (yl(y))
        h++, ly(y.readable, E, p, {
          end: j
        });
      else
        throw new uS(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          y
        );
      y = E;
    } else
      y = V$.from(E);
  }
  return (o != null && o.aborted || s != null && s.aborted) && Xu.nextTick(l), y;
}
function xte(e, t, r, { end: n }) {
  let o = !1;
  if (t.on("close", () => {
    o || r(new pte());
  }), e.pipe(t, {
    end: !1
  }), n) {
    let s = function() {
      o = !0, t.end();
    };
    mte(e) ? Xu.nextTick(s) : e.once("end", s);
  } else
    r();
  return vh(
    e,
    {
      readable: !0,
      writable: !1
    },
    (s) => {
      const a = e._readableState;
      s && s.code === "ERR_STREAM_PREMATURE_CLOSE" && a && a.ended && !a.errored && !a.errorEmitted ? e.once("end", r).once("error", r) : r(s);
    }
  ), vh(
    t,
    {
      readable: !1,
      writable: !0
    },
    r
  );
}
var _x = {
  pipelineImpl: _F,
  pipeline: Ete
};
const { pipeline: Rte } = _x, id = ao(), { destroyer: Ate } = hu, {
  isNodeStream: od,
  isReadable: K$,
  isWritable: Y$,
  isWebStream: uy,
  isTransformStream: Ms,
  isWritableStream: X$,
  isReadableStream: J$
} = Ro, {
  AbortError: Tte,
  codes: { ERR_INVALID_ARG_VALUE: Q$, ERR_MISSING_ARGS: $te }
} = on, Nte = ms;
var wF = function(...t) {
  if (t.length === 0)
    throw new $te("streams");
  if (t.length === 1)
    return id.from(t[0]);
  const r = [...t];
  if (typeof t[0] == "function" && (t[0] = id.from(t[0])), typeof t[t.length - 1] == "function") {
    const p = t.length - 1;
    t[p] = id.from(t[p]);
  }
  for (let p = 0; p < t.length; ++p)
    if (!(!od(t[p]) && !uy(t[p]))) {
      if (p < t.length - 1 && !(K$(t[p]) || J$(t[p]) || Ms(t[p])))
        throw new Q$(`streams[${p}]`, r[p], "must be readable");
      if (p > 0 && !(Y$(t[p]) || X$(t[p]) || Ms(t[p])))
        throw new Q$(`streams[${p}]`, r[p], "must be writable");
    }
  let n, o, s, a, l;
  function u(p) {
    const v = a;
    a = null, v ? v(p) : p ? l.destroy(p) : !h && !d && l.destroy();
  }
  const f = t[0], c = Rte(t, u), d = !!(Y$(f) || X$(f) || Ms(f)), h = !!(K$(c) || J$(c) || Ms(c));
  if (l = new id({
    // TODO (ronag): highWaterMark?
    writableObjectMode: !!(f != null && f.writableObjectMode),
    readableObjectMode: !!(c != null && c.readableObjectMode),
    writable: d,
    readable: h
  }), d) {
    if (od(f))
      l._write = function(v, y, w) {
        f.write(v, y) ? w() : n = w;
      }, l._final = function(v) {
        f.end(), o = v;
      }, f.on("drain", function() {
        if (n) {
          const v = n;
          n = null, v();
        }
      });
    else if (uy(f)) {
      const y = (Ms(f) ? f.writable : f).getWriter();
      l._write = async function(w, S, x) {
        try {
          await y.ready, y.write(w).catch(() => {
          }), x();
        } catch (E) {
          x(E);
        }
      }, l._final = async function(w) {
        try {
          await y.ready, y.close().catch(() => {
          }), o = w;
        } catch (S) {
          w(S);
        }
      };
    }
    const p = Ms(c) ? c.readable : c;
    Nte(p, () => {
      if (o) {
        const v = o;
        o = null, v();
      }
    });
  }
  if (h) {
    if (od(c))
      c.on("readable", function() {
        if (s) {
          const p = s;
          s = null, p();
        }
      }), c.on("end", function() {
        l.push(null);
      }), l._read = function() {
        for (; ; ) {
          const p = c.read();
          if (p === null) {
            s = l._read;
            return;
          }
          if (!l.push(p))
            return;
        }
      };
    else if (uy(c)) {
      const v = (Ms(c) ? c.readable : c).getReader();
      l._read = async function() {
        for (; ; )
          try {
            const { value: y, done: w } = await v.read();
            if (!l.push(y))
              return;
            if (w) {
              l.push(null);
              return;
            }
          } catch {
            return;
          }
      };
    }
  }
  return l._destroy = function(p, v) {
    !p && a !== null && (p = new Tte()), s = null, n = null, o = null, a === null ? v(p) : (a = v, od(c) && Ate(c, p));
  }, l;
};
const kte = globalThis.AbortController || Kt().AbortController, {
  codes: { ERR_INVALID_ARG_VALUE: Cte, ERR_INVALID_ARG_TYPE: wc, ERR_MISSING_ARGS: Ite, ERR_OUT_OF_RANGE: Mte },
  AbortError: $i
} = on, { validateAbortSignal: Ua, validateInteger: Z$, validateObject: Ha } = _c, Ote = jt.Symbol("kWeak"), Lte = jt.Symbol("kResistStopPropagation"), { finished: Pte } = ms, Dte = wF, { addAbortSignalNoValidate: Fte } = Wp, { isWritable: jte, isNodeStream: Bte } = Ro, { deprecate: qte } = Hr, {
  ArrayPrototypePush: Wte,
  Boolean: Ute,
  MathFloor: eN,
  Number: Hte,
  NumberIsNaN: Vte,
  Promise: tN,
  PromiseReject: rN,
  PromiseResolve: zte,
  PromisePrototypeThen: nN,
  Symbol: SF
} = jt, mh = SF("kEmpty"), iN = SF("kEof");
function Gte(e, t) {
  if (t != null && Ha(t, "options"), (t == null ? void 0 : t.signal) != null && Ua(t.signal, "options.signal"), Bte(e) && !jte(e))
    throw new Cte("stream", e, "must be writable");
  const r = Dte(this, e);
  return t != null && t.signal && Fte(t.signal, r), r;
}
function Vp(e, t) {
  if (typeof e != "function")
    throw new wc("fn", ["Function", "AsyncFunction"], e);
  t != null && Ha(t, "options"), (t == null ? void 0 : t.signal) != null && Ua(t.signal, "options.signal");
  let r = 1;
  (t == null ? void 0 : t.concurrency) != null && (r = eN(t.concurrency));
  let n = r - 1;
  return (t == null ? void 0 : t.highWaterMark) != null && (n = eN(t.highWaterMark)), Z$(r, "options.concurrency", 1), Z$(n, "options.highWaterMark", 0), n += r, (async function* () {
    const s = Hr.AbortSignalAny(
      [t == null ? void 0 : t.signal].filter(Ute)
    ), a = this, l = [], u = {
      signal: s
    };
    let f, c, d = !1, h = 0;
    function p() {
      d = !0, v();
    }
    function v() {
      h -= 1, y();
    }
    function y() {
      c && !d && h < r && l.length < n && (c(), c = null);
    }
    async function w() {
      try {
        for await (let S of a) {
          if (d)
            return;
          if (s.aborted)
            throw new $i();
          try {
            if (S = e(S, u), S === mh)
              continue;
            S = zte(S);
          } catch (x) {
            S = rN(x);
          }
          h += 1, nN(S, v, p), l.push(S), f && (f(), f = null), !d && (l.length >= n || h >= r) && await new tN((x) => {
            c = x;
          });
        }
        l.push(iN);
      } catch (S) {
        const x = rN(S);
        nN(x, v, p), l.push(x);
      } finally {
        d = !0, f && (f(), f = null);
      }
    }
    w();
    try {
      for (; ; ) {
        for (; l.length > 0; ) {
          const S = await l[0];
          if (S === iN)
            return;
          if (s.aborted)
            throw new $i();
          S !== mh && (yield S), l.shift(), y();
        }
        await new tN((S) => {
          f = S;
        });
      }
    } finally {
      d = !0, c && (c(), c = null);
    }
  }).call(this);
}
function Kte(e = void 0) {
  return e != null && Ha(e, "options"), (e == null ? void 0 : e.signal) != null && Ua(e.signal, "options.signal"), (async function* () {
    let r = 0;
    for await (const o of this) {
      var n;
      if (e != null && (n = e.signal) !== null && n !== void 0 && n.aborted)
        throw new $i({
          cause: e.signal.reason
        });
      yield [r++, o];
    }
  }).call(this);
}
async function EF(e, t = void 0) {
  for await (const r of wx.call(this, e, t))
    return !0;
  return !1;
}
async function Yte(e, t = void 0) {
  if (typeof e != "function")
    throw new wc("fn", ["Function", "AsyncFunction"], e);
  return !await EF.call(
    this,
    async (...r) => !await e(...r),
    t
  );
}
async function Xte(e, t) {
  for await (const r of wx.call(this, e, t))
    return r;
}
async function Jte(e, t) {
  if (typeof e != "function")
    throw new wc("fn", ["Function", "AsyncFunction"], e);
  async function r(n, o) {
    return await e(n, o), mh;
  }
  for await (const n of Vp.call(this, r, t))
    ;
}
function wx(e, t) {
  if (typeof e != "function")
    throw new wc("fn", ["Function", "AsyncFunction"], e);
  async function r(n, o) {
    return await e(n, o) ? n : mh;
  }
  return Vp.call(this, r, t);
}
let Qte = class extends Ite {
  constructor() {
    super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
  }
};
async function Zte(e, t, r) {
  var n;
  if (typeof e != "function")
    throw new wc("reducer", ["Function", "AsyncFunction"], e);
  r != null && Ha(r, "options"), (r == null ? void 0 : r.signal) != null && Ua(r.signal, "options.signal");
  let o = arguments.length > 1;
  if (r != null && (n = r.signal) !== null && n !== void 0 && n.aborted) {
    const f = new $i(void 0, {
      cause: r.signal.reason
    });
    throw this.once("error", () => {
    }), await Pte(this.destroy(f)), f;
  }
  const s = new kte(), a = s.signal;
  if (r != null && r.signal) {
    const f = {
      once: !0,
      [Ote]: this,
      [Lte]: !0
    };
    r.signal.addEventListener("abort", () => s.abort(), f);
  }
  let l = !1;
  try {
    for await (const f of this) {
      var u;
      if (l = !0, r != null && (u = r.signal) !== null && u !== void 0 && u.aborted)
        throw new $i();
      o ? t = await e(t, f, {
        signal: a
      }) : (t = f, o = !0);
    }
    if (!l && !o)
      throw new Qte();
  } finally {
    s.abort();
  }
  return t;
}
async function ere(e) {
  e != null && Ha(e, "options"), (e == null ? void 0 : e.signal) != null && Ua(e.signal, "options.signal");
  const t = [];
  for await (const n of this) {
    var r;
    if (e != null && (r = e.signal) !== null && r !== void 0 && r.aborted)
      throw new $i(void 0, {
        cause: e.signal.reason
      });
    Wte(t, n);
  }
  return t;
}
function tre(e, t) {
  const r = Vp.call(this, e, t);
  return (async function* () {
    for await (const o of r)
      yield* o;
  }).call(this);
}
function xF(e) {
  if (e = Hte(e), Vte(e))
    return 0;
  if (e < 0)
    throw new Mte("number", ">= 0", e);
  return e;
}
function rre(e, t = void 0) {
  return t != null && Ha(t, "options"), (t == null ? void 0 : t.signal) != null && Ua(t.signal, "options.signal"), e = xF(e), (async function* () {
    var n;
    if (t != null && (n = t.signal) !== null && n !== void 0 && n.aborted)
      throw new $i();
    for await (const s of this) {
      var o;
      if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
        throw new $i();
      e-- <= 0 && (yield s);
    }
  }).call(this);
}
function nre(e, t = void 0) {
  return t != null && Ha(t, "options"), (t == null ? void 0 : t.signal) != null && Ua(t.signal, "options.signal"), e = xF(e), (async function* () {
    var n;
    if (t != null && (n = t.signal) !== null && n !== void 0 && n.aborted)
      throw new $i();
    for await (const s of this) {
      var o;
      if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
        throw new $i();
      if (e-- > 0 && (yield s), e <= 0)
        return;
    }
  }).call(this);
}
cx.streamReturningOperators = {
  asIndexedPairs: qte(Kte, "readable.asIndexedPairs will be removed in a future version."),
  drop: rre,
  filter: wx,
  flatMap: tre,
  map: Vp,
  take: nre,
  compose: Gte
};
cx.promiseReturningOperators = {
  every: Yte,
  forEach: Jte,
  reduce: Zte,
  toArray: ere,
  some: EF,
  find: Xte
};
var fy, oN;
function RF() {
  if (oN)
    return fy;
  oN = 1;
  const { ArrayPrototypePop: e, Promise: t } = jt, { isIterable: r, isNodeStream: n, isWebStream: o } = Ro, { pipelineImpl: s } = _x, { finished: a } = ms;
  AF();
  function l(...u) {
    return new t((f, c) => {
      let d, h;
      const p = u[u.length - 1];
      if (p && typeof p == "object" && !n(p) && !r(p) && !o(p)) {
        const v = e(u);
        d = v.signal, h = v.end;
      }
      s(
        u,
        (v, y) => {
          v ? c(v) : f(y);
        },
        {
          signal: d,
          end: h
        }
      );
    });
  }
  return fy = {
    finished: a,
    pipeline: l
  }, fy;
}
var sN;
function AF() {
  if (sN)
    return Gb.exports;
  sN = 1;
  const { Buffer: e } = ft, { ObjectDefineProperty: t, ObjectKeys: r, ReflectApply: n } = jt, {
    promisify: { custom: o }
  } = Hr, { streamReturningOperators: s, promiseReturningOperators: a } = cx, {
    codes: { ERR_ILLEGAL_CONSTRUCTOR: l }
  } = on, u = wF, { setDefaultHighWaterMark: f, getDefaultHighWaterMark: c } = Up, { pipeline: d } = _x, { destroyer: h } = hu, p = ms, v = RF(), y = Ro, w = Gb.exports = bx.Stream;
  w.isDestroyed = y.isDestroyed, w.isDisturbed = y.isDisturbed, w.isErrored = y.isErrored, w.isReadable = y.isReadable, w.isWritable = y.isWritable, w.Readable = Hp();
  for (const x of r(s)) {
    let N = function(...C) {
      if (new.target)
        throw l();
      return w.Readable.from(n(E, this, C));
    };
    const E = s[x];
    t(N, "name", {
      __proto__: null,
      value: E.name
    }), t(N, "length", {
      __proto__: null,
      value: E.length
    }), t(w.Readable.prototype, x, {
      __proto__: null,
      value: N,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  for (const x of r(a)) {
    let N = function(...C) {
      if (new.target)
        throw l();
      return n(E, this, C);
    };
    const E = a[x];
    t(N, "name", {
      __proto__: null,
      value: E.name
    }), t(N, "length", {
      __proto__: null,
      value: E.length
    }), t(w.Readable.prototype, x, {
      __proto__: null,
      value: N,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  w.Writable = yx(), w.Duplex = ao(), w.Transform = yF, w.PassThrough = mF, w.pipeline = d;
  const { addAbortSignal: S } = Wp;
  return w.addAbortSignal = S, w.finished = p, w.destroy = h, w.compose = u, w.setDefaultHighWaterMark = f, w.getDefaultHighWaterMark = c, t(w, "promises", {
    __proto__: null,
    configurable: !0,
    enumerable: !0,
    get() {
      return v;
    }
  }), t(d, o, {
    __proto__: null,
    enumerable: !0,
    get() {
      return v.pipeline;
    }
  }), t(p, o, {
    __proto__: null,
    enumerable: !0,
    get() {
      return v.finished;
    }
  }), w.Stream = w, w._isUint8Array = function(E) {
    return E instanceof Uint8Array;
  }, w._uint8ArrayToBuffer = function(E) {
    return e.from(E.buffer, E.byteOffset, E.byteLength);
  }, Gb.exports;
}
(function(e) {
  const t = AF(), r = RF(), n = t.Readable.destroy;
  e.exports = t.Readable, e.exports._uint8ArrayToBuffer = t._uint8ArrayToBuffer, e.exports._isUint8Array = t._isUint8Array, e.exports.isDisturbed = t.isDisturbed, e.exports.isErrored = t.isErrored, e.exports.isReadable = t.isReadable, e.exports.Readable = t.Readable, e.exports.Writable = t.Writable, e.exports.Duplex = t.Duplex, e.exports.Transform = t.Transform, e.exports.PassThrough = t.PassThrough, e.exports.addAbortSignal = t.addAbortSignal, e.exports.finished = t.finished, e.exports.destroy = t.destroy, e.exports.destroy = n, e.exports.pipeline = t.pipeline, e.exports.compose = t.compose, Object.defineProperty(t, "promises", {
    configurable: !0,
    enumerable: !0,
    get() {
      return r;
    }
  }), e.exports.Stream = t.Stream, e.exports.default = e.exports;
})(P5);
var TF = P5.exports;
function aN(e) {
  const t = new TF.PassThrough({ objectMode: !0 });
  return setTimeout(async () => {
    try {
      (await e()).pipe(t);
    } catch (r) {
      t.destroy(r);
    }
  }, 0), C3(t);
}
async function sd(e) {
  if (e.ok)
    return;
  const t = await e.text(), r = new Error(`${e.statusText} (${e.status}): ${t}`);
  throw r.status = e.status, r;
}
function Xo(...e) {
  const t = new Headers();
  for (const r of e) {
    if (!r)
      continue;
    const n = r.entries ? r.entries() : Object.entries(r);
    for (const [o, s] of n)
      t.set(o, s);
  }
  return t;
}
class $F {
  /**
   * @param {Object} options
   * @param {SimpleClient} options.client client that provides the HTTP I/O
   */
  constructor({ client: t }) {
    this.client = t;
  }
  /**
   * Sends a request for a ASK query
   *
   * @param {string} query ASK query
   * @param {Object} [options]
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='get'] SPARQL Protocol operation
   * @return {Promise<Response>}
   */
  async ask(t, { headers: r, operation: n = "get" } = {}) {
    return r = Xo(r), r.has("accept") || r.set("accept", "application/sparql-results+json"), this.client[n](t, { headers: r });
  }
  /**
   * Sends a request for a CONSTRUCT or DESCRIBE query
   *
   * @param {string} query CONSTRUCT or DESCRIBE query
   * @param {Object} [options]
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='get'] SPARQL Protocol operation
   * @return {Promise<Response>}
   */
  async construct(t, { headers: r, operation: n = "get" } = {}) {
    return r = Xo(r), r.has("accept") || r.set("accept", "application/n-triples"), this.client[n](t, { headers: r });
  }
  /**
   * Sends a request for a SELECT query
   *
   * @param {string} query SELECT query
   * @param {Object} [options]
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='get'] SPARQL Protocol operation
   * @return {Promise<Response>}
   */
  async select(t, { headers: r, operation: n = "get" } = {}) {
    return r = Xo(r), r.has("accept") || r.set("accept", "application/sparql-results+json"), this.client[n](t, { headers: r });
  }
  /**
   * Sends a request for an update query
   *
   * @param {string} query update query
   * @param {Object} [options]
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='postUrlencoded'] SPARQL Protocol operation
   * @return {Promise<Response>}
   */
  async update(t, { headers: r, operation: n = "postUrlencoded" } = {}) {
    return r = Xo(r), r.has("accept") || r.set("accept", "*/*"), this.client[n](t, { headers: r, update: !0 });
  }
}
var { Buffer: zo } = ft, at = {}, NF = at.LEFT_BRACE = 1, Wd = at.RIGHT_BRACE = 2, kF = at.LEFT_BRACKET = 3, fS = at.RIGHT_BRACKET = 4, Ud = at.COLON = 5, _h = at.COMMA = 6, CF = at.TRUE = 7, IF = at.FALSE = 8, MF = at.NULL = 9, wh = at.STRING = 10, OF = at.NUMBER = 11, qs = at.START = 17, LF = at.STOP = 18, lN = at.TRUE1 = 33, uN = at.TRUE2 = 34, fN = at.TRUE3 = 35, cN = at.FALSE1 = 49, dN = at.FALSE2 = 50, hN = at.FALSE3 = 51, pN = at.FALSE4 = 52, gN = at.NULL1 = 65, bN = at.NULL2 = 66, yN = at.NULL3 = 67, vN = at.NUMBER1 = 81, cy = at.NUMBER3 = 83, Dn = at.STRING1 = 97, mN = at.STRING2 = 98, _N = at.STRING3 = 99, ire = at.STRING4 = 100, ore = at.STRING5 = 101, wN = at.STRING6 = 102, xl = at.VALUE = 113, dy = at.KEY = 114, ad = at.OBJECT = 129, ld = at.ARRAY = 130, sre = 92, are = 47, lre = 8, ure = 12, fre = 10, cre = 13, dre = 9, Sx = 64 * 1024;
function ud(e) {
  return zo.alloc ? zo.alloc(e) : new zo(e);
}
function ls() {
  this.tState = qs, this.value = void 0, this.string = void 0, this.stringBuffer = ud(Sx), this.stringBufferOffset = 0, this.unicode = void 0, this.highSurrogate = void 0, this.key = void 0, this.mode = void 0, this.stack = [], this.state = xl, this.bytes_remaining = 0, this.bytes_in_sequence = 0, this.temp_buffs = { 2: ud(2), 3: ud(3), 4: ud(4) }, this.offset = -1;
}
ls.toknam = function(e) {
  for (var t = Object.keys(at), r = 0, n = t.length; r < n; r++) {
    var o = t[r];
    if (at[o] === e)
      return o;
  }
  return e && "0x" + e.toString(16);
};
var gn = ls.prototype;
gn.onError = function(e) {
  throw e;
};
gn.charError = function(e, t) {
  this.tState = LF, this.onError(new Error("Unexpected " + JSON.stringify(String.fromCharCode(e[t])) + " at position " + t + " in state " + ls.toknam(this.tState)));
};
gn.appendStringChar = function(e) {
  this.stringBufferOffset >= Sx && (this.string += this.stringBuffer.toString("utf8"), this.stringBufferOffset = 0), this.stringBuffer[this.stringBufferOffset++] = e;
};
gn.appendStringBuf = function(e, t, r) {
  var n = e.length;
  typeof t == "number" && (typeof r == "number" ? r < 0 ? n = e.length - t + r : n = r - t : n = e.length - t), n < 0 && (n = 0), this.stringBufferOffset + n > Sx && (this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset), this.stringBufferOffset = 0), e.copy(this.stringBuffer, this.stringBufferOffset, t, r), this.stringBufferOffset += n;
};
gn.write = function(e) {
  typeof e == "string" && (e = new zo(e));
  for (var t, r = 0, n = e.length; r < n; r++)
    if (this.tState === qs) {
      if (t = e[r], this.offset++, t === 123)
        this.onToken(NF, "{");
      else if (t === 125)
        this.onToken(Wd, "}");
      else if (t === 91)
        this.onToken(kF, "[");
      else if (t === 93)
        this.onToken(fS, "]");
      else if (t === 58)
        this.onToken(Ud, ":");
      else if (t === 44)
        this.onToken(_h, ",");
      else if (t === 116)
        this.tState = lN;
      else if (t === 102)
        this.tState = cN;
      else if (t === 110)
        this.tState = gN;
      else if (t === 34)
        this.string = "", this.stringBufferOffset = 0, this.tState = Dn;
      else if (t === 45)
        this.string = "-", this.tState = vN;
      else if (t >= 48 && t < 64)
        this.string = String.fromCharCode(t), this.tState = cy;
      else if (!(t === 32 || t === 9 || t === 10 || t === 13))
        return this.charError(e, r);
    } else if (this.tState === Dn)
      if (t = e[r], this.bytes_remaining > 0) {
        for (var o = 0; o < this.bytes_remaining; o++)
          this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + o] = e[o];
        this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]), this.bytes_in_sequence = this.bytes_remaining = 0, r = r + o - 1;
      } else if (this.bytes_remaining === 0 && t >= 128) {
        if (t <= 193 || t > 244)
          return this.onError(new Error("Invalid UTF-8 character at position " + r + " in state " + ls.toknam(this.tState)));
        if (t >= 194 && t <= 223 && (this.bytes_in_sequence = 2), t >= 224 && t <= 239 && (this.bytes_in_sequence = 3), t >= 240 && t <= 244 && (this.bytes_in_sequence = 4), this.bytes_in_sequence + r > e.length) {
          for (var s = 0; s <= e.length - 1 - r; s++)
            this.temp_buffs[this.bytes_in_sequence][s] = e[r + s];
          this.bytes_remaining = r + this.bytes_in_sequence - e.length, r = e.length - 1;
        } else
          this.appendStringBuf(e, r, r + this.bytes_in_sequence), r = r + this.bytes_in_sequence - 1;
      } else if (t === 34)
        this.tState = qs, this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset), this.stringBufferOffset = 0, this.onToken(wh, this.string), this.offset += zo.byteLength(this.string, "utf8") + 1, this.string = void 0;
      else if (t === 92)
        this.tState = mN;
      else if (t >= 32)
        this.appendStringChar(t);
      else
        return this.charError(e, r);
    else if (this.tState === mN)
      if (t = e[r], t === 34)
        this.appendStringChar(t), this.tState = Dn;
      else if (t === 92)
        this.appendStringChar(sre), this.tState = Dn;
      else if (t === 47)
        this.appendStringChar(are), this.tState = Dn;
      else if (t === 98)
        this.appendStringChar(lre), this.tState = Dn;
      else if (t === 102)
        this.appendStringChar(ure), this.tState = Dn;
      else if (t === 110)
        this.appendStringChar(fre), this.tState = Dn;
      else if (t === 114)
        this.appendStringChar(cre), this.tState = Dn;
      else if (t === 116)
        this.appendStringChar(dre), this.tState = Dn;
      else if (t === 117)
        this.unicode = "", this.tState = _N;
      else
        return this.charError(e, r);
    else if (this.tState === _N || this.tState === ire || this.tState === ore || this.tState === wN)
      if (t = e[r], t >= 48 && t < 64 || t > 64 && t <= 70 || t > 96 && t <= 102) {
        if (this.unicode += String.fromCharCode(t), this.tState++ === wN) {
          var a = parseInt(this.unicode, 16);
          this.unicode = void 0, this.highSurrogate !== void 0 && a >= 56320 && a < 57344 ? (this.appendStringBuf(new zo(String.fromCharCode(this.highSurrogate, a))), this.highSurrogate = void 0) : this.highSurrogate === void 0 && a >= 55296 && a < 56320 ? this.highSurrogate = a : (this.highSurrogate !== void 0 && (this.appendStringBuf(new zo(String.fromCharCode(this.highSurrogate))), this.highSurrogate = void 0), this.appendStringBuf(new zo(String.fromCharCode(a)))), this.tState = Dn;
        }
      } else
        return this.charError(e, r);
    else if (this.tState === vN || this.tState === cy)
      switch (t = e[r], t) {
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 46:
        case 101:
        case 69:
        case 43:
        case 45:
          this.string += String.fromCharCode(t), this.tState = cy;
          break;
        default:
          this.tState = qs;
          var l = this.numberReviver(this.string);
          if (l)
            return l;
          this.offset += this.string.length - 1, this.string = void 0, r--;
          break;
      }
    else if (this.tState === lN)
      if (e[r] === 114)
        this.tState = uN;
      else
        return this.charError(e, r);
    else if (this.tState === uN)
      if (e[r] === 117)
        this.tState = fN;
      else
        return this.charError(e, r);
    else if (this.tState === fN)
      if (e[r] === 101)
        this.tState = qs, this.onToken(CF, !0), this.offset += 3;
      else
        return this.charError(e, r);
    else if (this.tState === cN)
      if (e[r] === 97)
        this.tState = dN;
      else
        return this.charError(e, r);
    else if (this.tState === dN)
      if (e[r] === 108)
        this.tState = hN;
      else
        return this.charError(e, r);
    else if (this.tState === hN)
      if (e[r] === 115)
        this.tState = pN;
      else
        return this.charError(e, r);
    else if (this.tState === pN)
      if (e[r] === 101)
        this.tState = qs, this.onToken(IF, !1), this.offset += 4;
      else
        return this.charError(e, r);
    else if (this.tState === gN)
      if (e[r] === 117)
        this.tState = bN;
      else
        return this.charError(e, r);
    else if (this.tState === bN)
      if (e[r] === 108)
        this.tState = yN;
      else
        return this.charError(e, r);
    else if (this.tState === yN)
      if (e[r] === 108)
        this.tState = qs, this.onToken(MF, null), this.offset += 3;
      else
        return this.charError(e, r);
};
gn.onToken = function(e, t) {
};
gn.parseError = function(e, t) {
  this.tState = LF, this.onError(new Error("Unexpected " + ls.toknam(e) + (t ? "(" + JSON.stringify(t) + ")" : "") + " in state " + ls.toknam(this.state)));
};
gn.push = function() {
  this.stack.push({ value: this.value, key: this.key, mode: this.mode });
};
gn.pop = function() {
  var e = this.value, t = this.stack.pop();
  this.value = t.value, this.key = t.key, this.mode = t.mode, this.emit(e), this.mode || (this.state = xl);
};
gn.emit = function(e) {
  this.mode && (this.state = _h), this.onValue(e);
};
gn.onValue = function(e) {
};
gn.onToken = function(e, t) {
  if (this.state === xl)
    if (e === wh || e === OF || e === CF || e === IF || e === MF)
      this.value && (this.value[this.key] = t), this.emit(t);
    else if (e === NF)
      this.push(), this.value ? this.value = this.value[this.key] = {} : this.value = {}, this.key = void 0, this.state = dy, this.mode = ad;
    else if (e === kF)
      this.push(), this.value ? this.value = this.value[this.key] = [] : this.value = [], this.key = 0, this.mode = ld, this.state = xl;
    else if (e === Wd)
      if (this.mode === ad)
        this.pop();
      else
        return this.parseError(e, t);
    else if (e === fS)
      if (this.mode === ld)
        this.pop();
      else
        return this.parseError(e, t);
    else
      return this.parseError(e, t);
  else if (this.state === dy)
    if (e === wh)
      this.key = t, this.state = Ud;
    else if (e === Wd)
      this.pop();
    else
      return this.parseError(e, t);
  else if (this.state === Ud)
    if (e === Ud)
      this.state = xl;
    else
      return this.parseError(e, t);
  else if (this.state === _h)
    if (e === _h)
      this.mode === ld ? (this.key++, this.state = xl) : this.mode === ad && (this.state = dy);
    else if (e === fS && this.mode === ld || e === Wd && this.mode === ad)
      this.pop();
    else
      return this.parseError(e, t);
  else
    return this.parseError(e, t);
};
gn.numberReviver = function(e) {
  var t = Number(e);
  if (isNaN(t))
    return this.charError(buffer, i);
  e.match(/[0-9]+/) == e && t.toString() != e ? this.onToken(wh, e) : this.onToken(OF, t);
};
ls.C = at;
var hre = ls;
const pre = /* @__PURE__ */ Tn(hre);
class gre extends TF.Transform {
  /**
   * @param {Object} options
   * @param {DataFactory} options.factory RDF/JS DataFactory used to create the quads and terms
   */
  constructor({ factory: t }) {
    super({
      readableObjectMode: !0
    }), this.factory = t, this.jsonParser = new pre(), this.jsonParser.onError = (r) => this.destroy(r), this.jsonParser.onValue = (r) => this.onValue(r);
  }
  _write(t, r, n) {
    this.jsonParser.write(t), n();
  }
  onValue(t) {
    if (this.jsonParser.stack.length !== 3 || this.jsonParser.stack[1].key !== "results" || this.jsonParser.stack[2].key !== "bindings" || Object.keys(t).length === 0)
      return;
    const r = {};
    for (const [n, o] of Object.entries(t))
      r[n] = this.valueToTerm(o);
    this.push(r);
  }
  valueToTerm(t) {
    if (t.type === "uri")
      return this.factory.namedNode(t.value);
    if (t.type === "bnode")
      return this.factory.blankNode(t.value);
    if (t.type === "literal" || t.type === "typed-literal") {
      const r = t.datatype && this.factory.namedNode(t.datatype);
      return this.factory.literal(t.value, r || t["xml:lang"]);
    }
    return null;
  }
}
class bre extends $F {
  /**
   * Sends a request for a ASK query
   *
   * @param {string} query ASK query
   * @param {Object} [options]
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='get'] SPARQL Protocol operation
   * @return {Promise<boolean>}
   */
  async ask(t, { headers: r, operation: n } = {}) {
    const o = await super.ask(t, { headers: r, operation: n });
    return await sd(o), (await o.json()).boolean;
  }
  /**
   * Sends a request for a CONSTRUCT or DESCRIBE query
   *
   * @param {string} query CONSTRUCT or DESCRIBE query
   * @param {Object} [options]
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='get'] SPARQL Protocol operation
   * @return {Readable}
   */
  construct(t, { headers: r, operation: n } = {}) {
    return aN(async () => {
      r = Xo(r), r.has("accept") || r.set("accept", "application/n-triples, text/turtle");
      const o = await super.construct(t, { headers: r, operation: n });
      return await sd(o), new L5({ factory: this.client.factory }).import(o.body);
    });
  }
  /**
   * Sends a request for a SELECT query
   *
   * @param {string} query SELECT query
   * @param {Object} [options]
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='get'] SPARQL Protocol operation
   * @return {Readable}
   */
  select(t, { headers: r, operation: n } = {}) {
    return aN(async () => {
      const o = await super.select(t, { headers: r, operation: n });
      await sd(o);
      const s = new gre({ factory: this.client.factory });
      return o.body.pipe(s);
    });
  }
  /**
   * Sends a request for an update query
   *
   * @param {string} query update query
   * @param {Object} [options]
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='postUrlencoded'] SPARQL Protocol operation
   * @return {Promise<void>}
   */
  async update(t, { headers: r, operation: n } = {}) {
    const o = await super.update(t, { headers: r, operation: n });
    await sd(o);
  }
}
class yre extends bre {
  /**
   * Sends a request for a CONSTRUCT or DESCRIBE query
   *
   * @param {string} query CONSTRUCT or DESCRIBE query
   * @param {Object} options
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='get'] SPARQL Protocol operation
   * @return {Promise<DatasetCore>}
   */
  async construct(t, { headers: r, operation: n } = {}) {
    const o = await q1(await super.construct(t, { headers: r, operation: n }));
    return this.client.factory.dataset(o);
  }
  /**
   * Sends a request for a SELECT query
   *
   * @param {string} query SELECT query
   * @param {Object} [options]
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='get'] SPARQL Protocol operation
   * @return {Promise<Array<Object.<string, Term>>>}
   */
  async select(t, { headers: r, operation: n } = {}) {
    return q1(await super.select(t, { headers: r, operation: n }));
  }
}
function vre(e) {
  const t = e.reduce((o, s) => o + s.length, 0), r = new Uint8Array(t);
  let n = 0;
  for (const o of e)
    r.set(o, n), n += o.length;
  return r;
}
async function mre(e = {}) {
  if (!e.body || !e.body.readable)
    return e;
  const t = await q1(e.body);
  return t.length > 0 ? t[0].BYTES_PER_ELEMENT === 1 ? e.body = vre(t) : e.body = t.join("") : e.body = "", e;
}
var PF = { exports: {} }, hy = { exports: {} }, Bt = {
  ArrayIsArray(e) {
    return Array.isArray(e);
  },
  ArrayPrototypeIncludes(e, t) {
    return e.includes(t);
  },
  ArrayPrototypeIndexOf(e, t) {
    return e.indexOf(t);
  },
  ArrayPrototypeJoin(e, t) {
    return e.join(t);
  },
  ArrayPrototypeMap(e, t) {
    return e.map(t);
  },
  ArrayPrototypePop(e, t) {
    return e.pop(t);
  },
  ArrayPrototypePush(e, t) {
    return e.push(t);
  },
  ArrayPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  Error,
  FunctionPrototypeCall(e, t, ...r) {
    return e.call(t, ...r);
  },
  FunctionPrototypeSymbolHasInstance(e, t) {
    return Function.prototype[Symbol.hasInstance].call(e, t);
  },
  MathFloor: Math.floor,
  Number,
  NumberIsInteger: Number.isInteger,
  NumberIsNaN: Number.isNaN,
  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
  NumberParseInt: Number.parseInt,
  ObjectDefineProperties(e, t) {
    return Object.defineProperties(e, t);
  },
  ObjectDefineProperty(e, t, r) {
    return Object.defineProperty(e, t, r);
  },
  ObjectGetOwnPropertyDescriptor(e, t) {
    return Object.getOwnPropertyDescriptor(e, t);
  },
  ObjectKeys(e) {
    return Object.keys(e);
  },
  ObjectSetPrototypeOf(e, t) {
    return Object.setPrototypeOf(e, t);
  },
  Promise,
  PromisePrototypeCatch(e, t) {
    return e.catch(t);
  },
  PromisePrototypeThen(e, t, r) {
    return e.then(t, r);
  },
  PromiseReject(e) {
    return Promise.reject(e);
  },
  PromiseResolve(e) {
    return Promise.resolve(e);
  },
  ReflectApply: Reflect.apply,
  RegExpPrototypeTest(e, t) {
    return e.test(t);
  },
  SafeSet: Set,
  String,
  StringPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  StringPrototypeToLowerCase(e) {
    return e.toLowerCase();
  },
  StringPrototypeToUpperCase(e) {
    return e.toUpperCase();
  },
  StringPrototypeTrim(e) {
    return e.trim();
  },
  Symbol,
  SymbolFor: Symbol.for,
  SymbolAsyncIterator: Symbol.asyncIterator,
  SymbolHasInstance: Symbol.hasInstance,
  SymbolIterator: Symbol.iterator,
  SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
  SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
  TypedArrayPrototypeSet(e, t, r) {
    return e.set(t, r);
  },
  Boolean,
  Uint8Array
}, DF = { exports: {} };
(function(e) {
  const t = ft, { kResistStopPropagation: r, SymbolDispose: n } = Bt, o = globalThis.AbortSignal || Kt().AbortSignal, s = globalThis.AbortController || Kt().AbortController, a = Object.getPrototypeOf(async function() {
  }).constructor, l = globalThis.Blob || t.Blob, u = typeof l < "u" ? function(p) {
    return p instanceof l;
  } : function(p) {
    return !1;
  }, f = (h, p) => {
    if (h !== void 0 && (h === null || typeof h != "object" || !("aborted" in h)))
      throw new ERR_INVALID_ARG_TYPE(p, "AbortSignal", h);
  }, c = (h, p) => {
    if (typeof h != "function")
      throw new ERR_INVALID_ARG_TYPE(p, "Function", h);
  };
  class d extends Error {
    constructor(p) {
      if (!Array.isArray(p))
        throw new TypeError(`Expected input to be an Array, got ${typeof p}`);
      let v = "";
      for (let y = 0; y < p.length; y++)
        v += `    ${p[y].stack}
`;
      super(v), this.name = "AggregateError", this.errors = p;
    }
  }
  e.exports = {
    AggregateError: d,
    kEmptyObject: Object.freeze({}),
    once(h) {
      let p = !1;
      return function(...v) {
        p || (p = !0, h.apply(this, v));
      };
    },
    createDeferredPromise: function() {
      let h, p;
      return {
        promise: new Promise((y, w) => {
          h = y, p = w;
        }),
        resolve: h,
        reject: p
      };
    },
    promisify(h) {
      return new Promise((p, v) => {
        h((y, ...w) => y ? v(y) : p(...w));
      });
    },
    debuglog() {
      return function() {
      };
    },
    format(h, ...p) {
      return h.replace(/%([sdifj])/g, function(...[v, y]) {
        const w = p.shift();
        return y === "f" ? w.toFixed(6) : y === "j" ? JSON.stringify(w) : y === "s" && typeof w == "object" ? `${w.constructor !== Object ? w.constructor.name : ""} {}`.trim() : w.toString();
      });
    },
    inspect(h) {
      switch (typeof h) {
        case "string":
          if (h.includes("'"))
            if (h.includes('"')) {
              if (!h.includes("`") && !h.includes("${"))
                return `\`${h}\``;
            } else
              return `"${h}"`;
          return `'${h}'`;
        case "number":
          return isNaN(h) ? "NaN" : Object.is(h, -0) ? String(h) : h;
        case "bigint":
          return `${String(h)}n`;
        case "boolean":
        case "undefined":
          return String(h);
        case "object":
          return "{}";
      }
    },
    types: {
      isAsyncFunction(h) {
        return h instanceof a;
      },
      isArrayBufferView(h) {
        return ArrayBuffer.isView(h);
      }
    },
    isBlob: u,
    deprecate(h, p) {
      return h;
    },
    addAbortListener: ur.addAbortListener || function(p, v) {
      if (p === void 0)
        throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", p);
      f(p, "signal"), c(v, "listener");
      let y;
      return p.aborted ? queueMicrotask(() => v()) : (p.addEventListener("abort", v, {
        __proto__: null,
        once: !0,
        [r]: !0
      }), y = () => {
        p.removeEventListener("abort", v);
      }), {
        __proto__: null,
        [n]() {
          var w;
          (w = y) === null || w === void 0 || w();
        }
      };
    },
    AbortSignalAny: o.any || function(p) {
      if (p.length === 1)
        return p[0];
      const v = new s(), y = () => v.abort();
      return p.forEach((w) => {
        f(w, "signals"), w.addEventListener("abort", y, {
          once: !0
        });
      }), v.signal.addEventListener(
        "abort",
        () => {
          p.forEach((w) => w.removeEventListener("abort", y));
        },
        {
          once: !0
        }
      ), v.signal;
    }
  }, e.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
})(DF);
var Vr = DF.exports, Ex = {};
const { format: _re, inspect: Sh, AggregateError: wre } = Vr, Sre = globalThis.AggregateError || wre, Ere = Symbol("kIsNodeError"), xre = [
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
], Rre = /^([A-Z][a-z0-9]*)+$/, Are = "__node_internal_", zp = {};
function ca(e, t) {
  if (!e)
    throw new zp.ERR_INTERNAL_ASSERTION(t);
}
function SN(e) {
  let t = "", r = e.length;
  const n = e[0] === "-" ? 1 : 0;
  for (; r >= n + 4; r -= 3)
    t = `_${e.slice(r - 3, r)}${t}`;
  return `${e.slice(0, r)}${t}`;
}
function Tre(e, t, r) {
  if (typeof t == "function")
    return ca(
      t.length <= r.length,
      // Default options do not count.
      `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${t.length}).`
    ), t(...r);
  const n = (t.match(/%[dfijoOs]/g) || []).length;
  return ca(
    n === r.length,
    `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${n}).`
  ), r.length === 0 ? t : _re(t, ...r);
}
function Er(e, t, r) {
  r || (r = Error);
  class n extends r {
    constructor(...s) {
      super(Tre(e, t, s));
    }
    toString() {
      return `${this.name} [${e}]: ${this.message}`;
    }
  }
  Object.defineProperties(n.prototype, {
    name: {
      value: r.name,
      writable: !0,
      enumerable: !1,
      configurable: !0
    },
    toString: {
      value() {
        return `${this.name} [${e}]: ${this.message}`;
      },
      writable: !0,
      enumerable: !1,
      configurable: !0
    }
  }), n.prototype.code = e, n.prototype[Ere] = !0, zp[e] = n;
}
function EN(e) {
  const t = Are + e.name;
  return Object.defineProperty(e, "name", {
    value: t
  }), e;
}
function $re(e, t) {
  if (e && t && e !== t) {
    if (Array.isArray(t.errors))
      return t.errors.push(e), t;
    const r = new Sre([t, e], t.message);
    return r.code = t.code, r;
  }
  return e || t;
}
let Nre = class extends Error {
  constructor(t = "The operation was aborted", r = void 0) {
    if (r !== void 0 && typeof r != "object")
      throw new zp.ERR_INVALID_ARG_TYPE("options", "Object", r);
    super(t, r), this.code = "ABORT_ERR", this.name = "AbortError";
  }
};
Er("ERR_ASSERTION", "%s", Error);
Er(
  "ERR_INVALID_ARG_TYPE",
  (e, t, r) => {
    ca(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
    let n = "The ";
    e.endsWith(" argument") ? n += `${e} ` : n += `"${e}" ${e.includes(".") ? "property" : "argument"} `, n += "must be ";
    const o = [], s = [], a = [];
    for (const u of t)
      ca(typeof u == "string", "All expected entries have to be of type string"), xre.includes(u) ? o.push(u.toLowerCase()) : Rre.test(u) ? s.push(u) : (ca(u !== "object", 'The value "object" should be written as "Object"'), a.push(u));
    if (s.length > 0) {
      const u = o.indexOf("object");
      u !== -1 && (o.splice(o, u, 1), s.push("Object"));
    }
    if (o.length > 0) {
      switch (o.length) {
        case 1:
          n += `of type ${o[0]}`;
          break;
        case 2:
          n += `one of type ${o[0]} or ${o[1]}`;
          break;
        default: {
          const u = o.pop();
          n += `one of type ${o.join(", ")}, or ${u}`;
        }
      }
      (s.length > 0 || a.length > 0) && (n += " or ");
    }
    if (s.length > 0) {
      switch (s.length) {
        case 1:
          n += `an instance of ${s[0]}`;
          break;
        case 2:
          n += `an instance of ${s[0]} or ${s[1]}`;
          break;
        default: {
          const u = s.pop();
          n += `an instance of ${s.join(", ")}, or ${u}`;
        }
      }
      a.length > 0 && (n += " or ");
    }
    switch (a.length) {
      case 0:
        break;
      case 1:
        a[0].toLowerCase() !== a[0] && (n += "an "), n += `${a[0]}`;
        break;
      case 2:
        n += `one of ${a[0]} or ${a[1]}`;
        break;
      default: {
        const u = a.pop();
        n += `one of ${a.join(", ")}, or ${u}`;
      }
    }
    if (r == null)
      n += `. Received ${r}`;
    else if (typeof r == "function" && r.name)
      n += `. Received function ${r.name}`;
    else if (typeof r == "object") {
      var l;
      if ((l = r.constructor) !== null && l !== void 0 && l.name)
        n += `. Received an instance of ${r.constructor.name}`;
      else {
        const u = Sh(r, {
          depth: -1
        });
        n += `. Received ${u}`;
      }
    } else {
      let u = Sh(r, {
        colors: !1
      });
      u.length > 25 && (u = `${u.slice(0, 25)}...`), n += `. Received type ${typeof r} (${u})`;
    }
    return n;
  },
  TypeError
);
Er(
  "ERR_INVALID_ARG_VALUE",
  (e, t, r = "is invalid") => {
    let n = Sh(t);
    return n.length > 128 && (n = n.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${n}`;
  },
  TypeError
);
Er(
  "ERR_INVALID_RETURN_VALUE",
  (e, t, r) => {
    var n;
    const o = r != null && (n = r.constructor) !== null && n !== void 0 && n.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
    return `Expected ${e} to be returned from the "${t}" function but got ${o}.`;
  },
  TypeError
);
Er(
  "ERR_MISSING_ARGS",
  (...e) => {
    ca(e.length > 0, "At least one arg needs to be specified");
    let t;
    const r = e.length;
    switch (e = (Array.isArray(e) ? e : [e]).map((n) => `"${n}"`).join(" or "), r) {
      case 1:
        t += `The ${e[0]} argument`;
        break;
      case 2:
        t += `The ${e[0]} and ${e[1]} arguments`;
        break;
      default:
        {
          const n = e.pop();
          t += `The ${e.join(", ")}, and ${n} arguments`;
        }
        break;
    }
    return `${t} must be specified`;
  },
  TypeError
);
Er(
  "ERR_OUT_OF_RANGE",
  (e, t, r) => {
    ca(t, 'Missing "range" argument');
    let n;
    return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? n = SN(String(r)) : typeof r == "bigint" ? (n = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (n = SN(n)), n += "n") : n = Sh(r), `The value of "${e}" is out of range. It must be ${t}. Received ${n}`;
  },
  RangeError
);
Er("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
Er("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
Er("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
Er("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
Er("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
Er("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
Er("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
Er("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
Er("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
Er("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
Er("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
var sn = {
  AbortError: Nre,
  aggregateTwoErrors: EN($re),
  hideStackFrames: EN,
  codes: zp
};
const {
  ArrayIsArray: xx,
  ArrayPrototypeIncludes: FF,
  ArrayPrototypeJoin: jF,
  ArrayPrototypeMap: kre,
  NumberIsInteger: Rx,
  NumberIsNaN: Cre,
  NumberMAX_SAFE_INTEGER: Ire,
  NumberMIN_SAFE_INTEGER: Mre,
  NumberParseInt: Ore,
  ObjectPrototypeHasOwnProperty: Lre,
  RegExpPrototypeExec: BF,
  String: Pre,
  StringPrototypeToUpperCase: Dre,
  StringPrototypeTrim: Fre
} = Bt, {
  hideStackFrames: Cn,
  codes: { ERR_SOCKET_BAD_PORT: jre, ERR_INVALID_ARG_TYPE: Mr, ERR_INVALID_ARG_VALUE: pu, ERR_OUT_OF_RANGE: Aa, ERR_UNKNOWN_SIGNAL: xN }
} = sn, { normalizeEncoding: Bre } = Vr, { isAsyncFunction: qre, isArrayBufferView: Wre } = Vr.types, RN = {};
function Ure(e) {
  return e === (e | 0);
}
function Hre(e) {
  return e === e >>> 0;
}
const Vre = /^[0-7]+$/, zre = "must be a 32-bit unsigned integer or an octal string";
function Gre(e, t, r) {
  if (typeof e > "u" && (e = r), typeof e == "string") {
    if (BF(Vre, e) === null)
      throw new pu(t, e, zre);
    e = Ore(e, 8);
  }
  return qF(e, t), e;
}
const Kre = Cn((e, t, r = Mre, n = Ire) => {
  if (typeof e != "number")
    throw new Mr(t, "number", e);
  if (!Rx(e))
    throw new Aa(t, "an integer", e);
  if (e < r || e > n)
    throw new Aa(t, `>= ${r} && <= ${n}`, e);
}), Yre = Cn((e, t, r = -2147483648, n = 2147483647) => {
  if (typeof e != "number")
    throw new Mr(t, "number", e);
  if (!Rx(e))
    throw new Aa(t, "an integer", e);
  if (e < r || e > n)
    throw new Aa(t, `>= ${r} && <= ${n}`, e);
}), qF = Cn((e, t, r = !1) => {
  if (typeof e != "number")
    throw new Mr(t, "number", e);
  if (!Rx(e))
    throw new Aa(t, "an integer", e);
  const n = r ? 1 : 0, o = 4294967295;
  if (e < n || e > o)
    throw new Aa(t, `>= ${n} && <= ${o}`, e);
});
function Ax(e, t) {
  if (typeof e != "string")
    throw new Mr(t, "string", e);
}
function Xre(e, t, r = void 0, n) {
  if (typeof e != "number")
    throw new Mr(t, "number", e);
  if (r != null && e < r || n != null && e > n || (r != null || n != null) && Cre(e))
    throw new Aa(
      t,
      `${r != null ? `>= ${r}` : ""}${r != null && n != null ? " && " : ""}${n != null ? `<= ${n}` : ""}`,
      e
    );
}
const Jre = Cn((e, t, r) => {
  if (!FF(r, e)) {
    const o = "must be one of: " + jF(
      kre(r, (s) => typeof s == "string" ? `'${s}'` : Pre(s)),
      ", "
    );
    throw new pu(t, e, o);
  }
});
function WF(e, t) {
  if (typeof e != "boolean")
    throw new Mr(t, "boolean", e);
}
function py(e, t, r) {
  return e == null || !Lre(e, t) ? r : e[t];
}
const Qre = Cn((e, t, r = null) => {
  const n = py(r, "allowArray", !1), o = py(r, "allowFunction", !1);
  if (!py(r, "nullable", !1) && e === null || !n && xx(e) || typeof e != "object" && (!o || typeof e != "function"))
    throw new Mr(t, "Object", e);
}), Zre = Cn((e, t) => {
  if (e != null && typeof e != "object" && typeof e != "function")
    throw new Mr(t, "a dictionary", e);
}), Gp = Cn((e, t, r = 0) => {
  if (!xx(e))
    throw new Mr(t, "Array", e);
  if (e.length < r) {
    const n = `must be longer than ${r}`;
    throw new pu(t, e, n);
  }
});
function ene(e, t) {
  Gp(e, t);
  for (let r = 0; r < e.length; r++)
    Ax(e[r], `${t}[${r}]`);
}
function tne(e, t) {
  Gp(e, t);
  for (let r = 0; r < e.length; r++)
    WF(e[r], `${t}[${r}]`);
}
function rne(e, t) {
  Gp(e, t);
  for (let r = 0; r < e.length; r++) {
    const n = e[r], o = `${t}[${r}]`;
    if (n == null)
      throw new Mr(o, "AbortSignal", n);
    UF(n, o);
  }
}
function nne(e, t = "signal") {
  if (Ax(e, t), RN[e] === void 0)
    throw RN[Dre(e)] !== void 0 ? new xN(e + " (signals must use all capital letters)") : new xN(e);
}
const ine = Cn((e, t = "buffer") => {
  if (!Wre(e))
    throw new Mr(t, ["Buffer", "TypedArray", "DataView"], e);
});
function one(e, t) {
  const r = Bre(t), n = e.length;
  if (r === "hex" && n % 2 !== 0)
    throw new pu("encoding", t, `is invalid for data of length ${n}`);
}
function sne(e, t = "Port", r = !0) {
  if (typeof e != "number" && typeof e != "string" || typeof e == "string" && Fre(e).length === 0 || +e !== +e >>> 0 || e > 65535 || e === 0 && !r)
    throw new jre(t, e, r);
  return e | 0;
}
const UF = Cn((e, t) => {
  if (e !== void 0 && (e === null || typeof e != "object" || !("aborted" in e)))
    throw new Mr(t, "AbortSignal", e);
}), ane = Cn((e, t) => {
  if (typeof e != "function")
    throw new Mr(t, "Function", e);
}), lne = Cn((e, t) => {
  if (typeof e != "function" || qre(e))
    throw new Mr(t, "Function", e);
}), une = Cn((e, t) => {
  if (e !== void 0)
    throw new Mr(t, "undefined", e);
});
function fne(e, t, r) {
  if (!FF(r, e))
    throw new Mr(t, `('${jF(r, "|")}')`, e);
}
const cne = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
function AN(e, t) {
  if (typeof e > "u" || !BF(cne, e))
    throw new pu(
      t,
      e,
      'must be an array or string of format "</styles.css>; rel=preload; as=style"'
    );
}
function dne(e) {
  if (typeof e == "string")
    return AN(e, "hints"), e;
  if (xx(e)) {
    const t = e.length;
    let r = "";
    if (t === 0)
      return r;
    for (let n = 0; n < t; n++) {
      const o = e[n];
      AN(o, "hints"), r += o, n !== t - 1 && (r += ", ");
    }
    return r;
  }
  throw new pu(
    "hints",
    e,
    'must be an array or string of format "</styles.css>; rel=preload; as=style"'
  );
}
var Sc = {
  isInt32: Ure,
  isUint32: Hre,
  parseFileMode: Gre,
  validateArray: Gp,
  validateStringArray: ene,
  validateBooleanArray: tne,
  validateAbortSignalArray: rne,
  validateBoolean: WF,
  validateBuffer: ine,
  validateDictionary: Zre,
  validateEncoding: one,
  validateFunction: ane,
  validateInt32: Yre,
  validateInteger: Kre,
  validateNumber: Xre,
  validateObject: Qre,
  validateOneOf: Jre,
  validatePlainFunction: lne,
  validatePort: sne,
  validateSignalName: nne,
  validateString: Ax,
  validateUint32: qF,
  validateUndefined: une,
  validateUnion: fne,
  validateAbortSignal: UF,
  validateLinkHeaderValue: dne
}, Tx = { exports: {} };
const { SymbolAsyncIterator: TN, SymbolIterator: $N, SymbolFor: Va } = Bt, HF = Va("nodejs.stream.destroyed"), VF = Va("nodejs.stream.errored"), cS = Va("nodejs.stream.readable"), dS = Va("nodejs.stream.writable"), zF = Va("nodejs.stream.disturbed"), hne = Va("nodejs.webstream.isClosedPromise"), pne = Va("nodejs.webstream.controllerErrorFunction");
function Kp(e, t = !1) {
  var r;
  return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((r = e._readableState) === null || r === void 0 ? void 0 : r.readable) !== !1) && // Duplex
  (!e._writableState || e._readableState));
}
function Yp(e) {
  var t;
  return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === void 0 ? void 0 : t.writable) !== !1));
}
function gne(e) {
  return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
}
function Fi(e) {
  return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
}
function GF(e) {
  return !!(e && !Fi(e) && typeof e.pipeThrough == "function" && typeof e.getReader == "function" && typeof e.cancel == "function");
}
function KF(e) {
  return !!(e && !Fi(e) && typeof e.getWriter == "function" && typeof e.abort == "function");
}
function YF(e) {
  return !!(e && !Fi(e) && typeof e.readable == "object" && typeof e.writable == "object");
}
function bne(e) {
  return GF(e) || KF(e) || YF(e);
}
function yne(e, t) {
  return e == null ? !1 : t === !0 ? typeof e[TN] == "function" : t === !1 ? typeof e[$N] == "function" : typeof e[TN] == "function" || typeof e[$N] == "function";
}
function Xp(e) {
  if (!Fi(e))
    return null;
  const t = e._writableState, r = e._readableState, n = t || r;
  return !!(e.destroyed || e[HF] || n != null && n.destroyed);
}
function XF(e) {
  if (!Yp(e))
    return null;
  if (e.writableEnded === !0)
    return !0;
  const t = e._writableState;
  return t != null && t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function vne(e, t) {
  if (!Yp(e))
    return null;
  if (e.writableFinished === !0)
    return !0;
  const r = e._writableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.finished) != "boolean" ? null : !!(r.finished || t === !1 && r.ended === !0 && r.length === 0);
}
function mne(e) {
  if (!Kp(e))
    return null;
  if (e.readableEnded === !0)
    return !0;
  const t = e._readableState;
  return !t || t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function JF(e, t) {
  if (!Kp(e))
    return null;
  const r = e._readableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.endEmitted) != "boolean" ? null : !!(r.endEmitted || t === !1 && r.ended === !0 && r.length === 0);
}
function QF(e) {
  return e && e[cS] != null ? e[cS] : typeof (e == null ? void 0 : e.readable) != "boolean" ? null : Xp(e) ? !1 : Kp(e) && e.readable && !JF(e);
}
function ZF(e) {
  return e && e[dS] != null ? e[dS] : typeof (e == null ? void 0 : e.writable) != "boolean" ? null : Xp(e) ? !1 : Yp(e) && e.writable && !XF(e);
}
function _ne(e, t) {
  return Fi(e) ? Xp(e) ? !0 : !((t == null ? void 0 : t.readable) !== !1 && QF(e) || (t == null ? void 0 : t.writable) !== !1 && ZF(e)) : null;
}
function wne(e) {
  var t, r;
  return Fi(e) ? e.writableErrored ? e.writableErrored : (t = (r = e._writableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function Sne(e) {
  var t, r;
  return Fi(e) ? e.readableErrored ? e.readableErrored : (t = (r = e._readableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function Ene(e) {
  if (!Fi(e))
    return null;
  if (typeof e.closed == "boolean")
    return e.closed;
  const t = e._writableState, r = e._readableState;
  return typeof (t == null ? void 0 : t.closed) == "boolean" || typeof (r == null ? void 0 : r.closed) == "boolean" ? (t == null ? void 0 : t.closed) || (r == null ? void 0 : r.closed) : typeof e._closed == "boolean" && e7(e) ? e._closed : null;
}
function e7(e) {
  return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
}
function t7(e) {
  return typeof e._sent100 == "boolean" && e7(e);
}
function xne(e) {
  var t;
  return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === void 0 ? void 0 : t.upgradeOrConnect) === void 0;
}
function Rne(e) {
  if (!Fi(e))
    return null;
  const t = e._writableState, r = e._readableState, n = t || r;
  return !n && t7(e) || !!(n && n.autoDestroy && n.emitClose && n.closed === !1);
}
function Ane(e) {
  var t;
  return !!(e && ((t = e[zF]) !== null && t !== void 0 ? t : e.readableDidRead || e.readableAborted));
}
function Tne(e) {
  var t, r, n, o, s, a, l, u, f, c;
  return !!(e && ((t = (r = (n = (o = (s = (a = e[VF]) !== null && a !== void 0 ? a : e.readableErrored) !== null && s !== void 0 ? s : e.writableErrored) !== null && o !== void 0 ? o : (l = e._readableState) === null || l === void 0 ? void 0 : l.errorEmitted) !== null && n !== void 0 ? n : (u = e._writableState) === null || u === void 0 ? void 0 : u.errorEmitted) !== null && r !== void 0 ? r : (f = e._readableState) === null || f === void 0 ? void 0 : f.errored) !== null && t !== void 0 ? t : !((c = e._writableState) === null || c === void 0) && c.errored));
}
var Ao = {
  isDestroyed: Xp,
  kIsDestroyed: HF,
  isDisturbed: Ane,
  kIsDisturbed: zF,
  isErrored: Tne,
  kIsErrored: VF,
  isReadable: QF,
  kIsReadable: cS,
  kIsClosedPromise: hne,
  kControllerErrorFunction: pne,
  kIsWritable: dS,
  isClosed: Ene,
  isDuplexNodeStream: gne,
  isFinished: _ne,
  isIterable: yne,
  isReadableNodeStream: Kp,
  isReadableStream: GF,
  isReadableEnded: mne,
  isReadableFinished: JF,
  isReadableErrored: Sne,
  isNodeStream: Fi,
  isWebStream: bne,
  isWritable: ZF,
  isWritableNodeStream: Yp,
  isWritableStream: KF,
  isWritableEnded: XF,
  isWritableFinished: vne,
  isWritableErrored: wne,
  isServerRequest: xne,
  isServerResponse: t7,
  willEmitClose: Rne,
  isTransformStream: YF
};
const Bo = St, { AbortError: r7, codes: $ne } = sn, { ERR_INVALID_ARG_TYPE: Nne, ERR_STREAM_PREMATURE_CLOSE: NN } = $ne, { kEmptyObject: hS, once: pS } = Vr, { validateAbortSignal: kne, validateFunction: Cne, validateObject: Ine, validateBoolean: Mne } = Sc, { Promise: One, PromisePrototypeThen: Lne, SymbolDispose: n7 } = Bt, {
  isClosed: Pne,
  isReadable: kN,
  isReadableNodeStream: gy,
  isReadableStream: Dne,
  isReadableFinished: CN,
  isReadableErrored: IN,
  isWritable: MN,
  isWritableNodeStream: ON,
  isWritableStream: Fne,
  isWritableFinished: LN,
  isWritableErrored: PN,
  isNodeStream: jne,
  willEmitClose: Bne,
  kIsClosedPromise: qne
} = Ao;
let Ll;
function Wne(e) {
  return e.setHeader && typeof e.abort == "function";
}
const gS = () => {
};
function i7(e, t, r) {
  var n, o;
  if (arguments.length === 2 ? (r = t, t = hS) : t == null ? t = hS : Ine(t, "options"), Cne(r, "callback"), kne(t.signal, "options.signal"), r = pS(r), Dne(e) || Fne(e))
    return Une(e, t, r);
  if (!jne(e))
    throw new Nne("stream", ["ReadableStream", "WritableStream", "Stream"], e);
  const s = (n = t.readable) !== null && n !== void 0 ? n : gy(e), a = (o = t.writable) !== null && o !== void 0 ? o : ON(e), l = e._writableState, u = e._readableState, f = () => {
    e.writable || h();
  };
  let c = Bne(e) && gy(e) === s && ON(e) === a, d = LN(e, !1);
  const h = () => {
    d = !0, e.destroyed && (c = !1), !(c && (!e.readable || s)) && (!s || p) && r.call(e);
  };
  let p = CN(e, !1);
  const v = () => {
    p = !0, e.destroyed && (c = !1), !(c && (!e.writable || a)) && (!a || d) && r.call(e);
  }, y = (C) => {
    r.call(e, C);
  };
  let w = Pne(e);
  const S = () => {
    w = !0;
    const C = PN(e) || IN(e);
    if (C && typeof C != "boolean")
      return r.call(e, C);
    if (s && !p && gy(e, !0) && !CN(e, !1))
      return r.call(e, new NN());
    if (a && !d && !LN(e, !1))
      return r.call(e, new NN());
    r.call(e);
  }, x = () => {
    w = !0;
    const C = PN(e) || IN(e);
    if (C && typeof C != "boolean")
      return r.call(e, C);
    r.call(e);
  }, E = () => {
    e.req.on("finish", h);
  };
  Wne(e) ? (e.on("complete", h), c || e.on("abort", S), e.req ? E() : e.on("request", E)) : a && !l && (e.on("end", f), e.on("close", f)), !c && typeof e.aborted == "boolean" && e.on("aborted", S), e.on("end", v), e.on("finish", h), t.error !== !1 && e.on("error", y), e.on("close", S), w ? Bo.nextTick(S) : l != null && l.errorEmitted || u != null && u.errorEmitted ? c || Bo.nextTick(x) : (!s && (!c || kN(e)) && (d || MN(e) === !1) || !a && (!c || MN(e)) && (p || kN(e) === !1) || u && e.req && e.aborted) && Bo.nextTick(x);
  const N = () => {
    r = gS, e.removeListener("aborted", S), e.removeListener("complete", h), e.removeListener("abort", S), e.removeListener("request", E), e.req && e.req.removeListener("finish", h), e.removeListener("end", f), e.removeListener("close", f), e.removeListener("finish", h), e.removeListener("end", v), e.removeListener("error", y), e.removeListener("close", S);
  };
  if (t.signal && !w) {
    const C = () => {
      const j = r;
      N(), j.call(
        e,
        new r7(void 0, {
          cause: t.signal.reason
        })
      );
    };
    if (t.signal.aborted)
      Bo.nextTick(C);
    else {
      Ll = Ll || Vr.addAbortListener;
      const j = Ll(t.signal, C), J = r;
      r = pS((...z) => {
        j[n7](), J.apply(e, z);
      });
    }
  }
  return N;
}
function Une(e, t, r) {
  let n = !1, o = gS;
  if (t.signal)
    if (o = () => {
      n = !0, r.call(
        e,
        new r7(void 0, {
          cause: t.signal.reason
        })
      );
    }, t.signal.aborted)
      Bo.nextTick(o);
    else {
      Ll = Ll || Vr.addAbortListener;
      const a = Ll(t.signal, o), l = r;
      r = pS((...u) => {
        a[n7](), l.apply(e, u);
      });
    }
  const s = (...a) => {
    n || Bo.nextTick(() => r.apply(e, a));
  };
  return Lne(e[qne].promise, s, s), gS;
}
function Hne(e, t) {
  var r;
  let n = !1;
  return t === null && (t = hS), (r = t) !== null && r !== void 0 && r.cleanup && (Mne(t.cleanup, "cleanup"), n = t.cleanup), new One((o, s) => {
    const a = i7(e, t, (l) => {
      n && a(), l ? s(l) : o();
    });
  });
}
Tx.exports = i7;
Tx.exports.finished = Hne;
var _s = Tx.exports;
const wi = St, {
  aggregateTwoErrors: Vne,
  codes: { ERR_MULTIPLE_CALLBACK: zne },
  AbortError: Gne
} = sn, { Symbol: o7 } = Bt, { kIsDestroyed: Kne, isDestroyed: Yne, isFinished: Xne, isServerRequest: Jne } = Ao, s7 = o7("kDestroy"), bS = o7("kConstruct");
function a7(e, t, r) {
  e && (e.stack, t && !t.errored && (t.errored = e), r && !r.errored && (r.errored = e));
}
function Qne(e, t) {
  const r = this._readableState, n = this._writableState, o = n || r;
  return n != null && n.destroyed || r != null && r.destroyed ? (typeof t == "function" && t(), this) : (a7(e, n, r), n && (n.destroyed = !0), r && (r.destroyed = !0), o.constructed ? DN(this, e, t) : this.once(s7, function(s) {
    DN(this, Vne(s, e), t);
  }), this);
}
function DN(e, t, r) {
  let n = !1;
  function o(s) {
    if (n)
      return;
    n = !0;
    const a = e._readableState, l = e._writableState;
    a7(s, l, a), l && (l.closed = !0), a && (a.closed = !0), typeof r == "function" && r(s), s ? wi.nextTick(Zne, e, s) : wi.nextTick(l7, e);
  }
  try {
    e._destroy(t || null, o);
  } catch (s) {
    o(s);
  }
}
function Zne(e, t) {
  yS(e, t), l7(e);
}
function l7(e) {
  const t = e._readableState, r = e._writableState;
  r && (r.closeEmitted = !0), t && (t.closeEmitted = !0), (r != null && r.emitClose || t != null && t.emitClose) && e.emit("close");
}
function yS(e, t) {
  const r = e._readableState, n = e._writableState;
  n != null && n.errorEmitted || r != null && r.errorEmitted || (n && (n.errorEmitted = !0), r && (r.errorEmitted = !0), e.emit("error", t));
}
function eie() {
  const e = this._readableState, t = this._writableState;
  e && (e.constructed = !0, e.closed = !1, e.closeEmitted = !1, e.destroyed = !1, e.errored = null, e.errorEmitted = !1, e.reading = !1, e.ended = e.readable === !1, e.endEmitted = e.readable === !1), t && (t.constructed = !0, t.destroyed = !1, t.closed = !1, t.closeEmitted = !1, t.errored = null, t.errorEmitted = !1, t.finalCalled = !1, t.prefinished = !1, t.ended = t.writable === !1, t.ending = t.writable === !1, t.finished = t.writable === !1);
}
function vS(e, t, r) {
  const n = e._readableState, o = e._writableState;
  if (o != null && o.destroyed || n != null && n.destroyed)
    return this;
  n != null && n.autoDestroy || o != null && o.autoDestroy ? e.destroy(t) : t && (t.stack, o && !o.errored && (o.errored = t), n && !n.errored && (n.errored = t), r ? wi.nextTick(yS, e, t) : yS(e, t));
}
function tie(e, t) {
  if (typeof e._construct != "function")
    return;
  const r = e._readableState, n = e._writableState;
  r && (r.constructed = !1), n && (n.constructed = !1), e.once(bS, t), !(e.listenerCount(bS) > 1) && wi.nextTick(rie, e);
}
function rie(e) {
  let t = !1;
  function r(n) {
    if (t) {
      vS(e, n ?? new zne());
      return;
    }
    t = !0;
    const o = e._readableState, s = e._writableState, a = s || o;
    o && (o.constructed = !0), s && (s.constructed = !0), a.destroyed ? e.emit(s7, n) : n ? vS(e, n, !0) : wi.nextTick(nie, e);
  }
  try {
    e._construct((n) => {
      wi.nextTick(r, n);
    });
  } catch (n) {
    wi.nextTick(r, n);
  }
}
function nie(e) {
  e.emit(bS);
}
function FN(e) {
  return (e == null ? void 0 : e.setHeader) && typeof e.abort == "function";
}
function u7(e) {
  e.emit("close");
}
function iie(e, t) {
  e.emit("error", t), wi.nextTick(u7, e);
}
function oie(e, t) {
  !e || Yne(e) || (!t && !Xne(e) && (t = new Gne()), Jne(e) ? (e.socket = null, e.destroy(t)) : FN(e) ? e.abort() : FN(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? wi.nextTick(iie, e, t) : wi.nextTick(u7, e), e.destroyed || (e[Kne] = !0));
}
var gu = {
  construct: tie,
  destroyer: oie,
  destroy: Qne,
  undestroy: eie,
  errorOrDestroy: vS
};
const { ArrayIsArray: sie, ObjectSetPrototypeOf: f7 } = Bt, { EventEmitter: Jp } = ur;
function Qp(e) {
  Jp.call(this, e);
}
f7(Qp.prototype, Jp.prototype);
f7(Qp, Jp);
Qp.prototype.pipe = function(e, t) {
  const r = this;
  function n(c) {
    e.writable && e.write(c) === !1 && r.pause && r.pause();
  }
  r.on("data", n);
  function o() {
    r.readable && r.resume && r.resume();
  }
  e.on("drain", o), !e._isStdio && (!t || t.end !== !1) && (r.on("end", a), r.on("close", l));
  let s = !1;
  function a() {
    s || (s = !0, e.end());
  }
  function l() {
    s || (s = !0, typeof e.destroy == "function" && e.destroy());
  }
  function u(c) {
    f(), Jp.listenerCount(this, "error") === 0 && this.emit("error", c);
  }
  mS(r, "error", u), mS(e, "error", u);
  function f() {
    r.removeListener("data", n), e.removeListener("drain", o), r.removeListener("end", a), r.removeListener("close", l), r.removeListener("error", u), e.removeListener("error", u), r.removeListener("end", f), r.removeListener("close", f), e.removeListener("close", f);
  }
  return r.on("end", f), r.on("close", f), e.on("close", f), e.emit("pipe", r), e;
};
function mS(e, t, r) {
  if (typeof e.prependListener == "function")
    return e.prependListener(t, r);
  !e._events || !e._events[t] ? e.on(t, r) : sie(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
}
var $x = {
  Stream: Qp,
  prependListener: mS
}, c7 = { exports: {} };
(function(e) {
  const { SymbolDispose: t } = Bt, { AbortError: r, codes: n } = sn, { isNodeStream: o, isWebStream: s, kControllerErrorFunction: a } = Ao, l = _s, { ERR_INVALID_ARG_TYPE: u } = n;
  let f;
  const c = (d, h) => {
    if (typeof d != "object" || !("aborted" in d))
      throw new u(h, "AbortSignal", d);
  };
  e.exports.addAbortSignal = function(h, p) {
    if (c(h, "signal"), !o(p) && !s(p))
      throw new u("stream", ["ReadableStream", "WritableStream", "Stream"], p);
    return e.exports.addAbortSignalNoValidate(h, p);
  }, e.exports.addAbortSignalNoValidate = function(d, h) {
    if (typeof d != "object" || !("aborted" in d))
      return h;
    const p = o(h) ? () => {
      h.destroy(
        new r(void 0, {
          cause: d.reason
        })
      );
    } : () => {
      h[a](
        new r(void 0, {
          cause: d.reason
        })
      );
    };
    if (d.aborted)
      p();
    else {
      f = f || Vr.addAbortListener;
      const v = f(d, p);
      l(h, v[t]);
    }
    return h;
  };
})(c7);
var Zp = c7.exports;
const { StringPrototypeSlice: jN, SymbolIterator: aie, TypedArrayPrototypeSet: fd, Uint8Array: lie } = Bt, { Buffer: by } = ft, { inspect: uie } = Vr;
var fie = class {
  constructor() {
    this.head = null, this.tail = null, this.length = 0;
  }
  push(t) {
    const r = {
      data: t,
      next: null
    };
    this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
  }
  unshift(t) {
    const r = {
      data: t,
      next: this.head
    };
    this.length === 0 && (this.tail = r), this.head = r, ++this.length;
  }
  shift() {
    if (this.length === 0)
      return;
    const t = this.head.data;
    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
  }
  clear() {
    this.head = this.tail = null, this.length = 0;
  }
  join(t) {
    if (this.length === 0)
      return "";
    let r = this.head, n = "" + r.data;
    for (; (r = r.next) !== null; )
      n += t + r.data;
    return n;
  }
  concat(t) {
    if (this.length === 0)
      return by.alloc(0);
    const r = by.allocUnsafe(t >>> 0);
    let n = this.head, o = 0;
    for (; n; )
      fd(r, n.data, o), o += n.data.length, n = n.next;
    return r;
  }
  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(t, r) {
    const n = this.head.data;
    if (t < n.length) {
      const o = n.slice(0, t);
      return this.head.data = n.slice(t), o;
    }
    return t === n.length ? this.shift() : r ? this._getString(t) : this._getBuffer(t);
  }
  first() {
    return this.head.data;
  }
  *[aie]() {
    for (let t = this.head; t; t = t.next)
      yield t.data;
  }
  // Consumes a specified amount of characters from the buffered data.
  _getString(t) {
    let r = "", n = this.head, o = 0;
    do {
      const s = n.data;
      if (t > s.length)
        r += s, t -= s.length;
      else {
        t === s.length ? (r += s, ++o, n.next ? this.head = n.next : this.head = this.tail = null) : (r += jN(s, 0, t), this.head = n, n.data = jN(s, t));
        break;
      }
      ++o;
    } while ((n = n.next) !== null);
    return this.length -= o, r;
  }
  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(t) {
    const r = by.allocUnsafe(t), n = t;
    let o = this.head, s = 0;
    do {
      const a = o.data;
      if (t > a.length)
        fd(r, a, n - t), t -= a.length;
      else {
        t === a.length ? (fd(r, a, n - t), ++s, o.next ? this.head = o.next : this.head = this.tail = null) : (fd(r, new lie(a.buffer, a.byteOffset, t), n - t), this.head = o, o.data = a.slice(t));
        break;
      }
      ++s;
    } while ((o = o.next) !== null);
    return this.length -= s, r;
  }
  // Make sure the linked list only shows the minimal necessary information.
  [Symbol.for("nodejs.util.inspect.custom")](t, r) {
    return uie(this, {
      ...r,
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: !1
    });
  }
};
const { MathFloor: cie, NumberIsInteger: die } = Bt, { validateInteger: hie } = Sc, { ERR_INVALID_ARG_VALUE: pie } = sn.codes;
let d7 = 16 * 1024, h7 = 16;
function gie(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function p7(e) {
  return e ? h7 : d7;
}
function bie(e, t) {
  hie(t, "value", 0), e ? h7 = t : d7 = t;
}
function yie(e, t, r, n) {
  const o = gie(t, n, r);
  if (o != null) {
    if (!die(o) || o < 0) {
      const s = n ? `options.${r}` : "options.highWaterMark";
      throw new pie(s, o);
    }
    return cie(o);
  }
  return p7(e.objectMode);
}
var eg = {
  getHighWaterMark: yie,
  getDefaultHighWaterMark: p7,
  setDefaultHighWaterMark: bie
};
const BN = St, { PromisePrototypeThen: vie, SymbolAsyncIterator: qN, SymbolIterator: WN } = Bt, { Buffer: mie } = ft, { ERR_INVALID_ARG_TYPE: _ie, ERR_STREAM_NULL_VALUES: wie } = sn.codes;
function Sie(e, t, r) {
  let n;
  if (typeof t == "string" || t instanceof mie)
    return new e({
      objectMode: !0,
      ...r,
      read() {
        this.push(t), this.push(null);
      }
    });
  let o;
  if (t && t[qN])
    o = !0, n = t[qN]();
  else if (t && t[WN])
    o = !1, n = t[WN]();
  else
    throw new _ie("iterable", ["Iterable"], t);
  const s = new e({
    objectMode: !0,
    highWaterMark: 1,
    // TODO(ronag): What options should be allowed?
    ...r
  });
  let a = !1;
  s._read = function() {
    a || (a = !0, u());
  }, s._destroy = function(f, c) {
    vie(
      l(f),
      () => BN.nextTick(c, f),
      // nextTick is here in case cb throws
      (d) => BN.nextTick(c, d || f)
    );
  };
  async function l(f) {
    const c = f != null, d = typeof n.throw == "function";
    if (c && d) {
      const { value: h, done: p } = await n.throw(f);
      if (await h, p)
        return;
    }
    if (typeof n.return == "function") {
      const { value: h } = await n.return();
      await h;
    }
  }
  async function u() {
    for (; ; ) {
      try {
        const { value: f, done: c } = o ? await n.next() : n.next();
        if (c)
          s.push(null);
        else {
          const d = f && typeof f.then == "function" ? await f : f;
          if (d === null)
            throw a = !1, new wie();
          if (s.push(d))
            continue;
          a = !1;
        }
      } catch (f) {
        s.destroy(f);
      }
      break;
    }
  }
  return s;
}
var g7 = Sie, yy, UN;
function tg() {
  if (UN)
    return yy;
  UN = 1;
  const e = St, {
    ArrayPrototypeIndexOf: t,
    NumberIsInteger: r,
    NumberIsNaN: n,
    NumberParseInt: o,
    ObjectDefineProperties: s,
    ObjectKeys: a,
    ObjectSetPrototypeOf: l,
    Promise: u,
    SafeSet: f,
    SymbolAsyncDispose: c,
    SymbolAsyncIterator: d,
    Symbol: h
  } = Bt;
  yy = B, B.ReadableState = ve;
  const { EventEmitter: p } = ur, { Stream: v, prependListener: y } = $x, { Buffer: w } = ft, { addAbortSignal: S } = Zp, x = _s;
  let E = Vr.debuglog("stream", (g) => {
    E = g;
  });
  const N = fie, C = gu, { getHighWaterMark: j, getDefaultHighWaterMark: J } = eg, {
    aggregateTwoErrors: z,
    codes: {
      ERR_INVALID_ARG_TYPE: $,
      ERR_METHOD_NOT_IMPLEMENTED: G,
      ERR_OUT_OF_RANGE: I,
      ERR_STREAM_PUSH_AFTER_EOF: W,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT: k
    },
    AbortError: U
  } = sn, { validateObject: Z } = Sc, Y = h("kPaused"), { StringDecoder: re } = Vl(), ae = g7;
  l(B.prototype, v.prototype), l(B, v);
  const ce = () => {
  }, { errorOrDestroy: pe } = C, le = 1, ye = 2, H = 4, ge = 8, Ce = 16, ue = 32, ee = 64, be = 128, Te = 256, Pe = 512, K = 1024, V = 2048, b = 4096, _ = 8192, T = 16384, L = 32768, O = 65536, ie = 1 << 17, fe = 1 << 18;
  function se(g) {
    return {
      enumerable: !1,
      get() {
        return (this.state & g) !== 0;
      },
      set(m) {
        m ? this.state |= g : this.state &= ~g;
      }
    };
  }
  s(ve.prototype, {
    objectMode: se(le),
    ended: se(ye),
    endEmitted: se(H),
    reading: se(ge),
    // Stream is still being constructed and cannot be
    // destroyed until construction finished or failed.
    // Async construction is opt in, therefore we start as
    // constructed.
    constructed: se(Ce),
    // A flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    sync: se(ue),
    // Whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    needReadable: se(ee),
    emittedReadable: se(be),
    readableListening: se(Te),
    resumeScheduled: se(Pe),
    // True if the error was already emitted and should not be thrown again.
    errorEmitted: se(K),
    emitClose: se(V),
    autoDestroy: se(b),
    // Has it been destroyed.
    destroyed: se(_),
    // Indicates whether the stream has finished destroying.
    closed: se(T),
    // True if close has been emitted or would have been emitted
    // depending on emitClose.
    closeEmitted: se(L),
    multiAwaitDrain: se(O),
    // If true, a maybeReadMore has been scheduled.
    readingMore: se(ie),
    dataEmitted: se(fe)
  });
  function ve(g, m, F) {
    typeof F != "boolean" && (F = m instanceof uo()), this.state = V | b | Ce | ue, g && g.objectMode && (this.state |= le), F && g && g.readableObjectMode && (this.state |= le), this.highWaterMark = g ? j(this, g, "readableHighWaterMark", F) : J(!1), this.buffer = new N(), this.length = 0, this.pipes = [], this.flowing = null, this[Y] = null, g && g.emitClose === !1 && (this.state &= ~V), g && g.autoDestroy === !1 && (this.state &= ~b), this.errored = null, this.defaultEncoding = g && g.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, g && g.encoding && (this.decoder = new re(g.encoding), this.encoding = g.encoding);
  }
  function B(g) {
    if (!(this instanceof B))
      return new B(g);
    const m = this instanceof uo();
    this._readableState = new ve(g, this, m), g && (typeof g.read == "function" && (this._read = g.read), typeof g.destroy == "function" && (this._destroy = g.destroy), typeof g.construct == "function" && (this._construct = g.construct), g.signal && !m && S(g.signal, this)), v.call(this, g), C.construct(this, () => {
      this._readableState.needReadable && ne(this, this._readableState);
    });
  }
  B.prototype.destroy = C.destroy, B.prototype._undestroy = C.undestroy, B.prototype._destroy = function(g, m) {
    m(g);
  }, B.prototype[p.captureRejectionSymbol] = function(g) {
    this.destroy(g);
  }, B.prototype[c] = function() {
    let g;
    return this.destroyed || (g = this.readableEnded ? null : new U(), this.destroy(g)), new u((m, F) => x(this, (D) => D && D !== g ? F(D) : m(null)));
  }, B.prototype.push = function(g, m) {
    return me(this, g, m, !1);
  }, B.prototype.unshift = function(g, m) {
    return me(this, g, m, !0);
  };
  function me(g, m, F, D) {
    E("readableAddChunk", m);
    const X = g._readableState;
    let Le;
    if (X.state & le || (typeof m == "string" ? (F = F || X.defaultEncoding, X.encoding !== F && (D && X.encoding ? m = w.from(m, F).toString(X.encoding) : (m = w.from(m, F), F = ""))) : m instanceof w ? F = "" : v._isUint8Array(m) ? (m = v._uint8ArrayToBuffer(m), F = "") : m != null && (Le = new $("chunk", ["string", "Buffer", "Uint8Array"], m))), Le)
      pe(g, Le);
    else if (m === null)
      X.state &= ~ge, R(g, X);
    else if (X.state & le || m && m.length > 0)
      if (D)
        if (X.state & H)
          pe(g, new k());
        else {
          if (X.destroyed || X.errored)
            return !1;
          ke(g, X, m, !0);
        }
      else if (X.ended)
        pe(g, new W());
      else {
        if (X.destroyed || X.errored)
          return !1;
        X.state &= ~ge, X.decoder && !F ? (m = X.decoder.write(m), X.objectMode || m.length !== 0 ? ke(g, X, m, !1) : ne(g, X)) : ke(g, X, m, !1);
      }
    else
      D || (X.state &= ~ge, ne(g, X));
    return !X.ended && (X.length < X.highWaterMark || X.length === 0);
  }
  function ke(g, m, F, D) {
    m.flowing && m.length === 0 && !m.sync && g.listenerCount("data") > 0 ? (m.state & O ? m.awaitDrainWriters.clear() : m.awaitDrainWriters = null, m.dataEmitted = !0, g.emit("data", F)) : (m.length += m.objectMode ? 1 : F.length, D ? m.buffer.unshift(F) : m.buffer.push(F), m.state & ee && A(g)), ne(g, m);
  }
  B.prototype.isPaused = function() {
    const g = this._readableState;
    return g[Y] === !0 || g.flowing === !1;
  }, B.prototype.setEncoding = function(g) {
    const m = new re(g);
    this._readableState.decoder = m, this._readableState.encoding = this._readableState.decoder.encoding;
    const F = this._readableState.buffer;
    let D = "";
    for (const X of F)
      D += m.write(X);
    return F.clear(), D !== "" && F.push(D), this._readableState.length = D.length, this;
  };
  const Ie = 1073741824;
  function Me(g) {
    if (g > Ie)
      throw new I("size", "<= 1GiB", g);
    return g--, g |= g >>> 1, g |= g >>> 2, g |= g >>> 4, g |= g >>> 8, g |= g >>> 16, g++, g;
  }
  function M(g, m) {
    return g <= 0 || m.length === 0 && m.ended ? 0 : m.state & le ? 1 : n(g) ? m.flowing && m.length ? m.buffer.first().length : m.length : g <= m.length ? g : m.ended ? m.length : 0;
  }
  B.prototype.read = function(g) {
    E("read", g), g === void 0 ? g = NaN : r(g) || (g = o(g, 10));
    const m = this._readableState, F = g;
    if (g > m.highWaterMark && (m.highWaterMark = Me(g)), g !== 0 && (m.state &= ~be), g === 0 && m.needReadable && ((m.highWaterMark !== 0 ? m.length >= m.highWaterMark : m.length > 0) || m.ended))
      return E("read: emitReadable", m.length, m.ended), m.length === 0 && m.ended ? Tt(this) : A(this), null;
    if (g = M(g, m), g === 0 && m.ended)
      return m.length === 0 && Tt(this), null;
    let D = (m.state & ee) !== 0;
    if (E("need readable", D), (m.length === 0 || m.length - g < m.highWaterMark) && (D = !0, E("length less than watermark", D)), m.ended || m.reading || m.destroyed || m.errored || !m.constructed)
      D = !1, E("reading, ended or constructing", D);
    else if (D) {
      E("do read"), m.state |= ge | ue, m.length === 0 && (m.state |= ee);
      try {
        this._read(m.highWaterMark);
      } catch (Le) {
        pe(this, Le);
      }
      m.state &= ~ue, m.reading || (g = M(F, m));
    }
    let X;
    return g > 0 ? X = Lr(g, m) : X = null, X === null ? (m.needReadable = m.length <= m.highWaterMark, g = 0) : (m.length -= g, m.multiAwaitDrain ? m.awaitDrainWriters.clear() : m.awaitDrainWriters = null), m.length === 0 && (m.ended || (m.needReadable = !0), F !== g && m.ended && Tt(this)), X !== null && !m.errorEmitted && !m.closeEmitted && (m.dataEmitted = !0, this.emit("data", X)), X;
  };
  function R(g, m) {
    if (E("onEofChunk"), !m.ended) {
      if (m.decoder) {
        const F = m.decoder.end();
        F && F.length && (m.buffer.push(F), m.length += m.objectMode ? 1 : F.length);
      }
      m.ended = !0, m.sync ? A(g) : (m.needReadable = !1, m.emittedReadable = !0, q(g));
    }
  }
  function A(g) {
    const m = g._readableState;
    E("emitReadable", m.needReadable, m.emittedReadable), m.needReadable = !1, m.emittedReadable || (E("emitReadable", m.flowing), m.emittedReadable = !0, e.nextTick(q, g));
  }
  function q(g) {
    const m = g._readableState;
    E("emitReadable_", m.destroyed, m.length, m.ended), !m.destroyed && !m.errored && (m.length || m.ended) && (g.emit("readable"), m.emittedReadable = !1), m.needReadable = !m.flowing && !m.ended && m.length <= m.highWaterMark, et(g);
  }
  function ne(g, m) {
    !m.readingMore && m.constructed && (m.readingMore = !0, e.nextTick(de, g, m));
  }
  function de(g, m) {
    for (; !m.reading && !m.ended && (m.length < m.highWaterMark || m.flowing && m.length === 0); ) {
      const F = m.length;
      if (E("maybeReadMore read 0"), g.read(0), F === m.length)
        break;
    }
    m.readingMore = !1;
  }
  B.prototype._read = function(g) {
    throw new G("_read()");
  }, B.prototype.pipe = function(g, m) {
    const F = this, D = this._readableState;
    D.pipes.length === 1 && (D.multiAwaitDrain || (D.multiAwaitDrain = !0, D.awaitDrainWriters = new f(D.awaitDrainWriters ? [D.awaitDrainWriters] : []))), D.pipes.push(g), E("pipe count=%d opts=%j", D.pipes.length, m);
    const Le = (!m || m.end !== !1) && g !== e.stdout && g !== e.stderr ? Xt : Et;
    D.endEmitted ? e.nextTick(Le) : F.once("end", Le), g.on("unpipe", Ue);
    function Ue(ct, nt) {
      E("onunpipe"), ct === F && nt && nt.hasUnpiped === !1 && (nt.hasUnpiped = !0, yn());
    }
    function Xt() {
      E("onend"), g.end();
    }
    let ht, Kr = !1;
    function yn() {
      E("cleanup"), g.removeListener("close", or), g.removeListener("finish", dr), ht && g.removeListener("drain", ht), g.removeListener("error", cr), g.removeListener("unpipe", Ue), F.removeListener("end", Xt), F.removeListener("end", Et), F.removeListener("data", Ar), Kr = !0, ht && D.awaitDrainWriters && (!g._writableState || g._writableState.needDrain) && ht();
    }
    function Wt() {
      Kr || (D.pipes.length === 1 && D.pipes[0] === g ? (E("false write response, pause", 0), D.awaitDrainWriters = g, D.multiAwaitDrain = !1) : D.pipes.length > 1 && D.pipes.includes(g) && (E("false write response, pause", D.awaitDrainWriters.size), D.awaitDrainWriters.add(g)), F.pause()), ht || (ht = he(F, g), g.on("drain", ht));
    }
    F.on("data", Ar);
    function Ar(ct) {
      E("ondata");
      const nt = g.write(ct);
      E("dest.write", nt), nt === !1 && Wt();
    }
    function cr(ct) {
      if (E("onerror", ct), Et(), g.removeListener("error", cr), g.listenerCount("error") === 0) {
        const nt = g._writableState || g._readableState;
        nt && !nt.errorEmitted ? pe(g, ct) : g.emit("error", ct);
      }
    }
    y(g, "error", cr);
    function or() {
      g.removeListener("finish", dr), Et();
    }
    g.once("close", or);
    function dr() {
      E("onfinish"), g.removeListener("close", or), Et();
    }
    g.once("finish", dr);
    function Et() {
      E("unpipe"), F.unpipe(g);
    }
    return g.emit("pipe", F), g.writableNeedDrain === !0 ? Wt() : D.flowing || (E("pipe resume"), F.resume()), g;
  };
  function he(g, m) {
    return function() {
      const D = g._readableState;
      D.awaitDrainWriters === m ? (E("pipeOnDrain", 1), D.awaitDrainWriters = null) : D.multiAwaitDrain && (E("pipeOnDrain", D.awaitDrainWriters.size), D.awaitDrainWriters.delete(m)), (!D.awaitDrainWriters || D.awaitDrainWriters.size === 0) && g.listenerCount("data") && g.resume();
    };
  }
  B.prototype.unpipe = function(g) {
    const m = this._readableState, F = {
      hasUnpiped: !1
    };
    if (m.pipes.length === 0)
      return this;
    if (!g) {
      const X = m.pipes;
      m.pipes = [], this.pause();
      for (let Le = 0; Le < X.length; Le++)
        X[Le].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    const D = t(m.pipes, g);
    return D === -1 ? this : (m.pipes.splice(D, 1), m.pipes.length === 0 && this.pause(), g.emit("unpipe", this, F), this);
  }, B.prototype.on = function(g, m) {
    const F = v.prototype.on.call(this, g, m), D = this._readableState;
    return g === "data" ? (D.readableListening = this.listenerCount("readable") > 0, D.flowing !== !1 && this.resume()) : g === "readable" && !D.endEmitted && !D.readableListening && (D.readableListening = D.needReadable = !0, D.flowing = !1, D.emittedReadable = !1, E("on readable", D.length, D.reading), D.length ? A(this) : D.reading || e.nextTick(ot, this)), F;
  }, B.prototype.addListener = B.prototype.on, B.prototype.removeListener = function(g, m) {
    const F = v.prototype.removeListener.call(this, g, m);
    return g === "readable" && e.nextTick(Fe, this), F;
  }, B.prototype.off = B.prototype.removeListener, B.prototype.removeAllListeners = function(g) {
    const m = v.prototype.removeAllListeners.apply(this, arguments);
    return (g === "readable" || g === void 0) && e.nextTick(Fe, this), m;
  };
  function Fe(g) {
    const m = g._readableState;
    m.readableListening = g.listenerCount("readable") > 0, m.resumeScheduled && m[Y] === !1 ? m.flowing = !0 : g.listenerCount("data") > 0 ? g.resume() : m.readableListening || (m.flowing = null);
  }
  function ot(g) {
    E("readable nexttick read 0"), g.read(0);
  }
  B.prototype.resume = function() {
    const g = this._readableState;
    return g.flowing || (E("resume"), g.flowing = !g.readableListening, ze(this, g)), g[Y] = !1, this;
  };
  function ze(g, m) {
    m.resumeScheduled || (m.resumeScheduled = !0, e.nextTick(Ke, g, m));
  }
  function Ke(g, m) {
    E("resume", m.reading), m.reading || g.read(0), m.resumeScheduled = !1, g.emit("resume"), et(g), m.flowing && !m.reading && g.read(0);
  }
  B.prototype.pause = function() {
    return E("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (E("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState[Y] = !0, this;
  };
  function et(g) {
    const m = g._readableState;
    for (E("flow", m.flowing); m.flowing && g.read() !== null; )
      ;
  }
  B.prototype.wrap = function(g) {
    let m = !1;
    g.on("data", (D) => {
      !this.push(D) && g.pause && (m = !0, g.pause());
    }), g.on("end", () => {
      this.push(null);
    }), g.on("error", (D) => {
      pe(this, D);
    }), g.on("close", () => {
      this.destroy();
    }), g.on("destroy", () => {
      this.destroy();
    }), this._read = () => {
      m && g.resume && (m = !1, g.resume());
    };
    const F = a(g);
    for (let D = 1; D < F.length; D++) {
      const X = F[D];
      this[X] === void 0 && typeof g[X] == "function" && (this[X] = g[X].bind(g));
    }
    return this;
  }, B.prototype[d] = function() {
    return Rr(this);
  }, B.prototype.iterator = function(g) {
    return g !== void 0 && Z(g, "options"), Rr(this, g);
  };
  function Rr(g, m) {
    typeof g.read != "function" && (g = B.wrap(g, {
      objectMode: !0
    }));
    const F = Wi(g, m);
    return F.stream = g, F;
  }
  async function* Wi(g, m) {
    let F = ce;
    function D(Ue) {
      this === g ? (F(), F = ce) : F = Ue;
    }
    g.on("readable", D);
    let X;
    const Le = x(
      g,
      {
        writable: !1
      },
      (Ue) => {
        X = Ue ? z(X, Ue) : null, F(), F = ce;
      }
    );
    try {
      for (; ; ) {
        const Ue = g.destroyed ? null : g.read();
        if (Ue !== null)
          yield Ue;
        else {
          if (X)
            throw X;
          if (X === null)
            return;
          await new u(D);
        }
      }
    } catch (Ue) {
      throw X = z(X, Ue), X;
    } finally {
      (X || (m == null ? void 0 : m.destroyOnReturn) !== !1) && (X === void 0 || g._readableState.autoDestroy) ? C.destroyer(g, null) : (g.off("readable", D), Le());
    }
  }
  s(B.prototype, {
    readable: {
      __proto__: null,
      get() {
        const g = this._readableState;
        return !!g && g.readable !== !1 && !g.destroyed && !g.errorEmitted && !g.endEmitted;
      },
      set(g) {
        this._readableState && (this._readableState.readable = !!g);
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(g) {
        this._readableState && (this._readableState.flowing = g);
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.objectMode : !1;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.destroyed : !1;
      },
      set(g) {
        this._readableState && (this._readableState.destroyed = g);
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.endEmitted : !1;
      }
    }
  }), s(ve.prototype, {
    // Legacy getter for `pipesCount`.
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    // Legacy property for `paused`.
    paused: {
      __proto__: null,
      get() {
        return this[Y] !== !1;
      },
      set(g) {
        this[Y] = !!g;
      }
    }
  }), B._fromList = Lr;
  function Lr(g, m) {
    if (m.length === 0)
      return null;
    let F;
    return m.objectMode ? F = m.buffer.shift() : !g || g >= m.length ? (m.decoder ? F = m.buffer.join("") : m.buffer.length === 1 ? F = m.buffer.first() : F = m.buffer.concat(m.length), m.buffer.clear()) : F = m.buffer.consume(g, m.decoder), F;
  }
  function Tt(g) {
    const m = g._readableState;
    E("endReadable", m.endEmitted), m.endEmitted || (m.ended = !0, e.nextTick(si, m, g));
  }
  function si(g, m) {
    if (E("endReadableNT", g.endEmitted, g.length), !g.errored && !g.closeEmitted && !g.endEmitted && g.length === 0) {
      if (g.endEmitted = !0, m.emit("end"), m.writable && m.allowHalfOpen === !1)
        e.nextTick(Ui, m);
      else if (g.autoDestroy) {
        const F = m._writableState;
        (!F || F.autoDestroy && // We don't expect the writable to ever 'finish'
        // if writable is explicitly set to false.
        (F.finished || F.writable === !1)) && m.destroy();
      }
    }
  }
  function Ui(g) {
    g.writable && !g.writableEnded && !g.destroyed && g.end();
  }
  B.from = function(g, m) {
    return ae(B, g, m);
  };
  let Mt;
  function ln() {
    return Mt === void 0 && (Mt = {}), Mt;
  }
  return B.fromWeb = function(g, m) {
    return ln().newStreamReadableFromReadableStream(g, m);
  }, B.toWeb = function(g, m) {
    return ln().newReadableStreamFromStreamReadable(g, m);
  }, B.wrap = function(g, m) {
    var F, D;
    return new B({
      objectMode: (F = (D = g.readableObjectMode) !== null && D !== void 0 ? D : g.objectMode) !== null && F !== void 0 ? F : !0,
      ...m,
      destroy(X, Le) {
        C.destroyer(g, X), Le(X);
      }
    }).wrap(g);
  }, yy;
}
var vy, HN;
function Nx() {
  if (HN)
    return vy;
  HN = 1;
  const e = St, {
    ArrayPrototypeSlice: t,
    Error: r,
    FunctionPrototypeSymbolHasInstance: n,
    ObjectDefineProperty: o,
    ObjectDefineProperties: s,
    ObjectSetPrototypeOf: a,
    StringPrototypeToLowerCase: l,
    Symbol: u,
    SymbolHasInstance: f
  } = Bt;
  vy = Z, Z.WritableState = k;
  const { EventEmitter: c } = ur, d = $x.Stream, { Buffer: h } = ft, p = gu, { addAbortSignal: v } = Zp, { getHighWaterMark: y, getDefaultHighWaterMark: w } = eg, {
    ERR_INVALID_ARG_TYPE: S,
    ERR_METHOD_NOT_IMPLEMENTED: x,
    ERR_MULTIPLE_CALLBACK: E,
    ERR_STREAM_CANNOT_PIPE: N,
    ERR_STREAM_DESTROYED: C,
    ERR_STREAM_ALREADY_FINISHED: j,
    ERR_STREAM_NULL_VALUES: J,
    ERR_STREAM_WRITE_AFTER_END: z,
    ERR_UNKNOWN_ENCODING: $
  } = sn.codes, { errorOrDestroy: G } = p;
  a(Z.prototype, d.prototype), a(Z, d);
  function I() {
  }
  const W = u("kOnFinished");
  function k(b, _, T) {
    typeof T != "boolean" && (T = _ instanceof uo()), this.objectMode = !!(b && b.objectMode), T && (this.objectMode = this.objectMode || !!(b && b.writableObjectMode)), this.highWaterMark = b ? y(this, b, "writableHighWaterMark", T) : w(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    const L = !!(b && b.decodeStrings === !1);
    this.decodeStrings = !L, this.defaultEncoding = b && b.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = pe.bind(void 0, _), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, U(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !b || b.emitClose !== !1, this.autoDestroy = !b || b.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[W] = [];
  }
  function U(b) {
    b.buffered = [], b.bufferedIndex = 0, b.allBuffers = !0, b.allNoop = !0;
  }
  k.prototype.getBuffer = function() {
    return t(this.buffered, this.bufferedIndex);
  }, o(k.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function Z(b) {
    const _ = this instanceof uo();
    if (!_ && !n(Z, this))
      return new Z(b);
    this._writableState = new k(b, this, _), b && (typeof b.write == "function" && (this._write = b.write), typeof b.writev == "function" && (this._writev = b.writev), typeof b.destroy == "function" && (this._destroy = b.destroy), typeof b.final == "function" && (this._final = b.final), typeof b.construct == "function" && (this._construct = b.construct), b.signal && v(b.signal, this)), d.call(this, b), p.construct(this, () => {
      const T = this._writableState;
      T.writing || ge(this, T), be(this, T);
    });
  }
  o(Z, f, {
    __proto__: null,
    value: function(b) {
      return n(this, b) ? !0 : this !== Z ? !1 : b && b._writableState instanceof k;
    }
  }), Z.prototype.pipe = function() {
    G(this, new N());
  };
  function Y(b, _, T, L) {
    const O = b._writableState;
    if (typeof T == "function")
      L = T, T = O.defaultEncoding;
    else {
      if (!T)
        T = O.defaultEncoding;
      else if (T !== "buffer" && !h.isEncoding(T))
        throw new $(T);
      typeof L != "function" && (L = I);
    }
    if (_ === null)
      throw new J();
    if (!O.objectMode)
      if (typeof _ == "string")
        O.decodeStrings !== !1 && (_ = h.from(_, T), T = "buffer");
      else if (_ instanceof h)
        T = "buffer";
      else if (d._isUint8Array(_))
        _ = d._uint8ArrayToBuffer(_), T = "buffer";
      else
        throw new S("chunk", ["string", "Buffer", "Uint8Array"], _);
    let ie;
    return O.ending ? ie = new z() : O.destroyed && (ie = new C("write")), ie ? (e.nextTick(L, ie), G(b, ie, !0), ie) : (O.pendingcb++, re(b, O, _, T, L));
  }
  Z.prototype.write = function(b, _, T) {
    return Y(this, b, _, T) === !0;
  }, Z.prototype.cork = function() {
    this._writableState.corked++;
  }, Z.prototype.uncork = function() {
    const b = this._writableState;
    b.corked && (b.corked--, b.writing || ge(this, b));
  }, Z.prototype.setDefaultEncoding = function(_) {
    if (typeof _ == "string" && (_ = l(_)), !h.isEncoding(_))
      throw new $(_);
    return this._writableState.defaultEncoding = _, this;
  };
  function re(b, _, T, L, O) {
    const ie = _.objectMode ? 1 : T.length;
    _.length += ie;
    const fe = _.length < _.highWaterMark;
    return fe || (_.needDrain = !0), _.writing || _.corked || _.errored || !_.constructed ? (_.buffered.push({
      chunk: T,
      encoding: L,
      callback: O
    }), _.allBuffers && L !== "buffer" && (_.allBuffers = !1), _.allNoop && O !== I && (_.allNoop = !1)) : (_.writelen = ie, _.writecb = O, _.writing = !0, _.sync = !0, b._write(T, L, _.onwrite), _.sync = !1), fe && !_.errored && !_.destroyed;
  }
  function ae(b, _, T, L, O, ie, fe) {
    _.writelen = L, _.writecb = fe, _.writing = !0, _.sync = !0, _.destroyed ? _.onwrite(new C("write")) : T ? b._writev(O, _.onwrite) : b._write(O, ie, _.onwrite), _.sync = !1;
  }
  function ce(b, _, T, L) {
    --_.pendingcb, L(T), H(_), G(b, T);
  }
  function pe(b, _) {
    const T = b._writableState, L = T.sync, O = T.writecb;
    if (typeof O != "function") {
      G(b, new E());
      return;
    }
    T.writing = !1, T.writecb = null, T.length -= T.writelen, T.writelen = 0, _ ? (_.stack, T.errored || (T.errored = _), b._readableState && !b._readableState.errored && (b._readableState.errored = _), L ? e.nextTick(ce, b, T, _, O) : ce(b, T, _, O)) : (T.buffered.length > T.bufferedIndex && ge(b, T), L ? T.afterWriteTickInfo !== null && T.afterWriteTickInfo.cb === O ? T.afterWriteTickInfo.count++ : (T.afterWriteTickInfo = {
      count: 1,
      cb: O,
      stream: b,
      state: T
    }, e.nextTick(le, T.afterWriteTickInfo)) : ye(b, T, 1, O));
  }
  function le({ stream: b, state: _, count: T, cb: L }) {
    return _.afterWriteTickInfo = null, ye(b, _, T, L);
  }
  function ye(b, _, T, L) {
    for (!_.ending && !b.destroyed && _.length === 0 && _.needDrain && (_.needDrain = !1, b.emit("drain")); T-- > 0; )
      _.pendingcb--, L();
    _.destroyed && H(_), be(b, _);
  }
  function H(b) {
    if (b.writing)
      return;
    for (let O = b.bufferedIndex; O < b.buffered.length; ++O) {
      var _;
      const { chunk: ie, callback: fe } = b.buffered[O], se = b.objectMode ? 1 : ie.length;
      b.length -= se, fe(
        (_ = b.errored) !== null && _ !== void 0 ? _ : new C("write")
      );
    }
    const T = b[W].splice(0);
    for (let O = 0; O < T.length; O++) {
      var L;
      T[O](
        (L = b.errored) !== null && L !== void 0 ? L : new C("end")
      );
    }
    U(b);
  }
  function ge(b, _) {
    if (_.corked || _.bufferProcessing || _.destroyed || !_.constructed)
      return;
    const { buffered: T, bufferedIndex: L, objectMode: O } = _, ie = T.length - L;
    if (!ie)
      return;
    let fe = L;
    if (_.bufferProcessing = !0, ie > 1 && b._writev) {
      _.pendingcb -= ie - 1;
      const se = _.allNoop ? I : (B) => {
        for (let me = fe; me < T.length; ++me)
          T[me].callback(B);
      }, ve = _.allNoop && fe === 0 ? T : t(T, fe);
      ve.allBuffers = _.allBuffers, ae(b, _, !0, _.length, ve, "", se), U(_);
    } else {
      do {
        const { chunk: se, encoding: ve, callback: B } = T[fe];
        T[fe++] = null;
        const me = O ? 1 : se.length;
        ae(b, _, !1, me, se, ve, B);
      } while (fe < T.length && !_.writing);
      fe === T.length ? U(_) : fe > 256 ? (T.splice(0, fe), _.bufferedIndex = 0) : _.bufferedIndex = fe;
    }
    _.bufferProcessing = !1;
  }
  Z.prototype._write = function(b, _, T) {
    if (this._writev)
      this._writev(
        [
          {
            chunk: b,
            encoding: _
          }
        ],
        T
      );
    else
      throw new x("_write()");
  }, Z.prototype._writev = null, Z.prototype.end = function(b, _, T) {
    const L = this._writableState;
    typeof b == "function" ? (T = b, b = null, _ = null) : typeof _ == "function" && (T = _, _ = null);
    let O;
    if (b != null) {
      const ie = Y(this, b, _);
      ie instanceof r && (O = ie);
    }
    return L.corked && (L.corked = 1, this.uncork()), O || (!L.errored && !L.ending ? (L.ending = !0, be(this, L, !0), L.ended = !0) : L.finished ? O = new j("end") : L.destroyed && (O = new C("end"))), typeof T == "function" && (O || L.finished ? e.nextTick(T, O) : L[W].push(T)), this;
  };
  function Ce(b) {
    return b.ending && !b.destroyed && b.constructed && b.length === 0 && !b.errored && b.buffered.length === 0 && !b.finished && !b.writing && !b.errorEmitted && !b.closeEmitted;
  }
  function ue(b, _) {
    let T = !1;
    function L(O) {
      if (T) {
        G(b, O ?? E());
        return;
      }
      if (T = !0, _.pendingcb--, O) {
        const ie = _[W].splice(0);
        for (let fe = 0; fe < ie.length; fe++)
          ie[fe](O);
        G(b, O, _.sync);
      } else
        Ce(_) && (_.prefinished = !0, b.emit("prefinish"), _.pendingcb++, e.nextTick(Te, b, _));
    }
    _.sync = !0, _.pendingcb++;
    try {
      b._final(L);
    } catch (O) {
      L(O);
    }
    _.sync = !1;
  }
  function ee(b, _) {
    !_.prefinished && !_.finalCalled && (typeof b._final == "function" && !_.destroyed ? (_.finalCalled = !0, ue(b, _)) : (_.prefinished = !0, b.emit("prefinish")));
  }
  function be(b, _, T) {
    Ce(_) && (ee(b, _), _.pendingcb === 0 && (T ? (_.pendingcb++, e.nextTick(
      (L, O) => {
        Ce(O) ? Te(L, O) : O.pendingcb--;
      },
      b,
      _
    )) : Ce(_) && (_.pendingcb++, Te(b, _))));
  }
  function Te(b, _) {
    _.pendingcb--, _.finished = !0;
    const T = _[W].splice(0);
    for (let L = 0; L < T.length; L++)
      T[L]();
    if (b.emit("finish"), _.autoDestroy) {
      const L = b._readableState;
      (!L || L.autoDestroy && // We don't expect the readable to ever 'end'
      // if readable is explicitly set to false.
      (L.endEmitted || L.readable === !1)) && b.destroy();
    }
  }
  s(Z.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : !1;
      },
      set(b) {
        this._writableState && (this._writableState.destroyed = b);
      }
    },
    writable: {
      __proto__: null,
      get() {
        const b = this._writableState;
        return !!b && b.writable !== !1 && !b.destroyed && !b.errored && !b.ending && !b.ended;
      },
      set(b) {
        this._writableState && (this._writableState.writable = !!b);
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : !1;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : !1;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : !1;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const b = this._writableState;
        return b ? !b.destroyed && !b.ending && b.needDrain : !1;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  const Pe = p.destroy;
  Z.prototype.destroy = function(b, _) {
    const T = this._writableState;
    return !T.destroyed && (T.bufferedIndex < T.buffered.length || T[W].length) && e.nextTick(H, T), Pe.call(this, b, _), this;
  }, Z.prototype._undestroy = p.undestroy, Z.prototype._destroy = function(b, _) {
    _(b);
  }, Z.prototype[c.captureRejectionSymbol] = function(b) {
    this.destroy(b);
  };
  let K;
  function V() {
    return K === void 0 && (K = {}), K;
  }
  return Z.fromWeb = function(b, _) {
    return V().newStreamWritableFromWritableStream(b, _);
  }, Z.toWeb = function(b) {
    return V().newWritableStreamFromStreamWritable(b);
  }, vy;
}
var my, VN;
function Eie() {
  if (VN)
    return my;
  VN = 1;
  const e = St, t = ft, {
    isReadable: r,
    isWritable: n,
    isIterable: o,
    isNodeStream: s,
    isReadableNodeStream: a,
    isWritableNodeStream: l,
    isDuplexNodeStream: u,
    isReadableStream: f,
    isWritableStream: c
  } = Ao, d = _s, {
    AbortError: h,
    codes: { ERR_INVALID_ARG_TYPE: p, ERR_INVALID_RETURN_VALUE: v }
  } = sn, { destroyer: y } = gu, w = uo(), S = tg(), x = Nx(), { createDeferredPromise: E } = Vr, N = g7, C = globalThis.Blob || t.Blob, j = typeof C < "u" ? function(k) {
    return k instanceof C;
  } : function(k) {
    return !1;
  }, J = globalThis.AbortController || Kt().AbortController, { FunctionPrototypeCall: z } = Bt;
  class $ extends w {
    constructor(k) {
      super(k), (k == null ? void 0 : k.readable) === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), (k == null ? void 0 : k.writable) === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0);
    }
  }
  my = function W(k, U) {
    if (u(k))
      return k;
    if (a(k))
      return I({
        readable: k
      });
    if (l(k))
      return I({
        writable: k
      });
    if (s(k))
      return I({
        writable: !1,
        readable: !1
      });
    if (f(k))
      return I({
        readable: S.fromWeb(k)
      });
    if (c(k))
      return I({
        writable: x.fromWeb(k)
      });
    if (typeof k == "function") {
      const { value: Y, write: re, final: ae, destroy: ce } = G(k);
      if (o(Y))
        return N($, Y, {
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          write: re,
          final: ae,
          destroy: ce
        });
      const pe = Y == null ? void 0 : Y.then;
      if (typeof pe == "function") {
        let le;
        const ye = z(
          pe,
          Y,
          (H) => {
            if (H != null)
              throw new v("nully", "body", H);
          },
          (H) => {
            y(le, H);
          }
        );
        return le = new $({
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          readable: !1,
          write: re,
          final(H) {
            ae(async () => {
              try {
                await ye, e.nextTick(H, null);
              } catch (ge) {
                e.nextTick(H, ge);
              }
            });
          },
          destroy: ce
        });
      }
      throw new v("Iterable, AsyncIterable or AsyncFunction", U, Y);
    }
    if (j(k))
      return W(k.arrayBuffer());
    if (o(k))
      return N($, k, {
        // TODO (ronag): highWaterMark?
        objectMode: !0,
        writable: !1
      });
    if (f(k == null ? void 0 : k.readable) && c(k == null ? void 0 : k.writable))
      return $.fromWeb(k);
    if (typeof (k == null ? void 0 : k.writable) == "object" || typeof (k == null ? void 0 : k.readable) == "object") {
      const Y = k != null && k.readable ? a(k == null ? void 0 : k.readable) ? k == null ? void 0 : k.readable : W(k.readable) : void 0, re = k != null && k.writable ? l(k == null ? void 0 : k.writable) ? k == null ? void 0 : k.writable : W(k.writable) : void 0;
      return I({
        readable: Y,
        writable: re
      });
    }
    const Z = k == null ? void 0 : k.then;
    if (typeof Z == "function") {
      let Y;
      return z(
        Z,
        k,
        (re) => {
          re != null && Y.push(re), Y.push(null);
        },
        (re) => {
          y(Y, re);
        }
      ), Y = new $({
        objectMode: !0,
        writable: !1,
        read() {
        }
      });
    }
    throw new p(
      U,
      [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise"
      ],
      k
    );
  };
  function G(W) {
    let { promise: k, resolve: U } = E();
    const Z = new J(), Y = Z.signal;
    return {
      value: W(
        async function* () {
          for (; ; ) {
            const ae = k;
            k = null;
            const { chunk: ce, done: pe, cb: le } = await ae;
            if (e.nextTick(le), pe)
              return;
            if (Y.aborted)
              throw new h(void 0, {
                cause: Y.reason
              });
            ({ promise: k, resolve: U } = E()), yield ce;
          }
        }(),
        {
          signal: Y
        }
      ),
      write(ae, ce, pe) {
        const le = U;
        U = null, le({
          chunk: ae,
          done: !1,
          cb: pe
        });
      },
      final(ae) {
        const ce = U;
        U = null, ce({
          done: !0,
          cb: ae
        });
      },
      destroy(ae, ce) {
        Z.abort(), ce(ae);
      }
    };
  }
  function I(W) {
    const k = W.readable && typeof W.readable.read != "function" ? S.wrap(W.readable) : W.readable, U = W.writable;
    let Z = !!r(k), Y = !!n(U), re, ae, ce, pe, le;
    function ye(H) {
      const ge = pe;
      pe = null, ge ? ge(H) : H && le.destroy(H);
    }
    return le = new $({
      // TODO (ronag): highWaterMark?
      readableObjectMode: !!(k != null && k.readableObjectMode),
      writableObjectMode: !!(U != null && U.writableObjectMode),
      readable: Z,
      writable: Y
    }), Y && (d(U, (H) => {
      Y = !1, H && y(k, H), ye(H);
    }), le._write = function(H, ge, Ce) {
      U.write(H, ge) ? Ce() : re = Ce;
    }, le._final = function(H) {
      U.end(), ae = H;
    }, U.on("drain", function() {
      if (re) {
        const H = re;
        re = null, H();
      }
    }), U.on("finish", function() {
      if (ae) {
        const H = ae;
        ae = null, H();
      }
    })), Z && (d(k, (H) => {
      Z = !1, H && y(k, H), ye(H);
    }), k.on("readable", function() {
      if (ce) {
        const H = ce;
        ce = null, H();
      }
    }), k.on("end", function() {
      le.push(null);
    }), le._read = function() {
      for (; ; ) {
        const H = k.read();
        if (H === null) {
          ce = le._read;
          return;
        }
        if (!le.push(H))
          return;
      }
    }), le._destroy = function(H, ge) {
      !H && pe !== null && (H = new h()), ce = null, re = null, ae = null, pe === null ? ge(H) : (pe = ge, y(U, H), y(k, H));
    }, le;
  }
  return my;
}
var _y, zN;
function uo() {
  if (zN)
    return _y;
  zN = 1;
  const {
    ObjectDefineProperties: e,
    ObjectGetOwnPropertyDescriptor: t,
    ObjectKeys: r,
    ObjectSetPrototypeOf: n
  } = Bt;
  _y = a;
  const o = tg(), s = Nx();
  n(a.prototype, o.prototype), n(a, o);
  {
    const c = r(s.prototype);
    for (let d = 0; d < c.length; d++) {
      const h = c[d];
      a.prototype[h] || (a.prototype[h] = s.prototype[h]);
    }
  }
  function a(c) {
    if (!(this instanceof a))
      return new a(c);
    o.call(this, c), s.call(this, c), c ? (this.allowHalfOpen = c.allowHalfOpen !== !1, c.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), c.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0)) : this.allowHalfOpen = !0;
  }
  e(a.prototype, {
    writable: {
      __proto__: null,
      ...t(s.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...t(s.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...t(s.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...t(s.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...t(s.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...t(s.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...t(s.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...t(s.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...t(s.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
      },
      set(c) {
        this._readableState && this._writableState && (this._readableState.destroyed = c, this._writableState.destroyed = c);
      }
    }
  });
  let l;
  function u() {
    return l === void 0 && (l = {}), l;
  }
  a.fromWeb = function(c, d) {
    return u().newStreamDuplexFromReadableWritablePair(c, d);
  }, a.toWeb = function(c) {
    return u().newReadableWritablePairFromDuplex(c);
  };
  let f;
  return a.from = function(c) {
    return f || (f = Eie()), f(c, "body");
  }, _y;
}
const { ObjectSetPrototypeOf: b7, Symbol: xie } = Bt;
var y7 = fo;
const { ERR_METHOD_NOT_IMPLEMENTED: Rie } = sn.codes, kx = uo(), { getHighWaterMark: Aie } = eg;
b7(fo.prototype, kx.prototype);
b7(fo, kx);
const xf = xie("kCallback");
function fo(e) {
  if (!(this instanceof fo))
    return new fo(e);
  const t = e ? Aie(this, e, "readableHighWaterMark", !0) : null;
  t === 0 && (e = {
    ...e,
    highWaterMark: null,
    readableHighWaterMark: t,
    // TODO (ronag): 0 is not optimal since we have
    // a "bug" where we check needDrain before calling _write and not after.
    // Refs: https://github.com/nodejs/node/pull/32887
    // Refs: https://github.com/nodejs/node/pull/35941
    writableHighWaterMark: e.writableHighWaterMark || 0
  }), kx.call(this, e), this._readableState.sync = !1, this[xf] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", Tie);
}
function _S(e) {
  typeof this._flush == "function" && !this.destroyed ? this._flush((t, r) => {
    if (t) {
      e ? e(t) : this.destroy(t);
      return;
    }
    r != null && this.push(r), this.push(null), e && e();
  }) : (this.push(null), e && e());
}
function Tie() {
  this._final !== _S && _S.call(this);
}
fo.prototype._final = _S;
fo.prototype._transform = function(e, t, r) {
  throw new Rie("_transform()");
};
fo.prototype._write = function(e, t, r) {
  const n = this._readableState, o = this._writableState, s = n.length;
  this._transform(e, t, (a, l) => {
    if (a) {
      r(a);
      return;
    }
    l != null && this.push(l), o.ended || // Backwards compat.
    s === n.length || // Backwards compat.
    n.length < n.highWaterMark ? r() : this[xf] = r;
  });
};
fo.prototype._read = function() {
  if (this[xf]) {
    const e = this[xf];
    this[xf] = null, e();
  }
};
const { ObjectSetPrototypeOf: v7 } = Bt;
var m7 = Kl;
const Cx = y7;
v7(Kl.prototype, Cx.prototype);
v7(Kl, Cx);
function Kl(e) {
  if (!(this instanceof Kl))
    return new Kl(e);
  Cx.call(this, e);
}
Kl.prototype._transform = function(e, t, r) {
  r(null, e);
};
const Ju = St, { ArrayIsArray: $ie, Promise: Nie, SymbolAsyncIterator: kie, SymbolDispose: Cie } = Bt, Eh = _s, { once: Iie } = Vr, Mie = gu, GN = uo(), {
  aggregateTwoErrors: Oie,
  codes: {
    ERR_INVALID_ARG_TYPE: wS,
    ERR_INVALID_RETURN_VALUE: wy,
    ERR_MISSING_ARGS: Lie,
    ERR_STREAM_DESTROYED: Pie,
    ERR_STREAM_PREMATURE_CLOSE: Die
  },
  AbortError: Fie
} = sn, { validateFunction: jie, validateAbortSignal: Bie } = Sc, {
  isIterable: Ws,
  isReadable: Sy,
  isReadableNodeStream: Hd,
  isNodeStream: KN,
  isTransformStream: vl,
  isWebStream: qie,
  isReadableStream: Ey,
  isReadableFinished: Wie
} = Ao, Uie = globalThis.AbortController || Kt().AbortController;
let xy, Ry, Ay;
function YN(e, t, r) {
  let n = !1;
  e.on("close", () => {
    n = !0;
  });
  const o = Eh(
    e,
    {
      readable: t,
      writable: r
    },
    (s) => {
      n = !s;
    }
  );
  return {
    destroy: (s) => {
      n || (n = !0, Mie.destroyer(e, s || new Pie("pipe")));
    },
    cleanup: o
  };
}
function Hie(e) {
  return jie(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
}
function Ty(e) {
  if (Ws(e))
    return e;
  if (Hd(e))
    return Vie(e);
  throw new wS("val", ["Readable", "Iterable", "AsyncIterable"], e);
}
async function* Vie(e) {
  Ry || (Ry = tg()), yield* Ry.prototype[kie].call(e);
}
async function cd(e, t, r, { end: n }) {
  let o, s = null;
  const a = (f) => {
    if (f && (o = f), s) {
      const c = s;
      s = null, c();
    }
  }, l = () => new Nie((f, c) => {
    o ? c(o) : s = () => {
      o ? c(o) : f();
    };
  });
  t.on("drain", a);
  const u = Eh(
    t,
    {
      readable: !1
    },
    a
  );
  try {
    t.writableNeedDrain && await l();
    for await (const f of e)
      t.write(f) || await l();
    n && (t.end(), await l()), r();
  } catch (f) {
    r(o !== f ? Oie(o, f) : f);
  } finally {
    u(), t.off("drain", a);
  }
}
async function $y(e, t, r, { end: n }) {
  vl(t) && (t = t.writable);
  const o = t.getWriter();
  try {
    for await (const s of e)
      await o.ready, o.write(s).catch(() => {
      });
    await o.ready, n && await o.close(), r();
  } catch (s) {
    try {
      await o.abort(s), r(s);
    } catch (a) {
      r(a);
    }
  }
}
function zie(...e) {
  return _7(e, Iie(Hie(e)));
}
function _7(e, t, r) {
  if (e.length === 1 && $ie(e[0]) && (e = e[0]), e.length < 2)
    throw new Lie("streams");
  const n = new Uie(), o = n.signal, s = r == null ? void 0 : r.signal, a = [];
  Bie(s, "options.signal");
  function l() {
    v(new Fie());
  }
  Ay = Ay || Vr.addAbortListener;
  let u;
  s && (u = Ay(s, l));
  let f, c;
  const d = [];
  let h = 0;
  function p(x) {
    v(x, --h === 0);
  }
  function v(x, E) {
    var N;
    if (x && (!f || f.code === "ERR_STREAM_PREMATURE_CLOSE") && (f = x), !(!f && !E)) {
      for (; d.length; )
        d.shift()(f);
      (N = u) === null || N === void 0 || N[Cie](), n.abort(), E && (f || a.forEach((C) => C()), Ju.nextTick(t, f, c));
    }
  }
  let y;
  for (let x = 0; x < e.length; x++) {
    const E = e[x], N = x < e.length - 1, C = x > 0, j = N || (r == null ? void 0 : r.end) !== !1, J = x === e.length - 1;
    if (KN(E)) {
      let z = function($) {
        $ && $.name !== "AbortError" && $.code !== "ERR_STREAM_PREMATURE_CLOSE" && p($);
      };
      if (j) {
        const { destroy: $, cleanup: G } = YN(E, N, C);
        d.push($), Sy(E) && J && a.push(G);
      }
      E.on("error", z), Sy(E) && J && a.push(() => {
        E.removeListener("error", z);
      });
    }
    if (x === 0)
      if (typeof E == "function") {
        if (y = E({
          signal: o
        }), !Ws(y))
          throw new wy("Iterable, AsyncIterable or Stream", "source", y);
      } else
        Ws(E) || Hd(E) || vl(E) ? y = E : y = GN.from(E);
    else if (typeof E == "function") {
      if (vl(y)) {
        var w;
        y = Ty((w = y) === null || w === void 0 ? void 0 : w.readable);
      } else
        y = Ty(y);
      if (y = E(y, {
        signal: o
      }), N) {
        if (!Ws(y, !0))
          throw new wy("AsyncIterable", `transform[${x - 1}]`, y);
      } else {
        var S;
        xy || (xy = m7);
        const z = new xy({
          objectMode: !0
        }), $ = (S = y) === null || S === void 0 ? void 0 : S.then;
        if (typeof $ == "function")
          h++, $.call(
            y,
            (W) => {
              c = W, W != null && z.write(W), j && z.end(), Ju.nextTick(p);
            },
            (W) => {
              z.destroy(W), Ju.nextTick(p, W);
            }
          );
        else if (Ws(y, !0))
          h++, cd(y, z, p, {
            end: j
          });
        else if (Ey(y) || vl(y)) {
          const W = y.readable || y;
          h++, cd(W, z, p, {
            end: j
          });
        } else
          throw new wy("AsyncIterable or Promise", "destination", y);
        y = z;
        const { destroy: G, cleanup: I } = YN(y, !1, !0);
        d.push(G), J && a.push(I);
      }
    } else if (KN(E)) {
      if (Hd(y)) {
        h += 2;
        const z = Gie(y, E, p, {
          end: j
        });
        Sy(E) && J && a.push(z);
      } else if (vl(y) || Ey(y)) {
        const z = y.readable || y;
        h++, cd(z, E, p, {
          end: j
        });
      } else if (Ws(y))
        h++, cd(y, E, p, {
          end: j
        });
      else
        throw new wS(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          y
        );
      y = E;
    } else if (qie(E)) {
      if (Hd(y))
        h++, $y(Ty(y), E, p, {
          end: j
        });
      else if (Ey(y) || Ws(y))
        h++, $y(y, E, p, {
          end: j
        });
      else if (vl(y))
        h++, $y(y.readable, E, p, {
          end: j
        });
      else
        throw new wS(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          y
        );
      y = E;
    } else
      y = GN.from(E);
  }
  return (o != null && o.aborted || s != null && s.aborted) && Ju.nextTick(l), y;
}
function Gie(e, t, r, { end: n }) {
  let o = !1;
  if (t.on("close", () => {
    o || r(new Die());
  }), e.pipe(t, {
    end: !1
  }), n) {
    let s = function() {
      o = !0, t.end();
    };
    Wie(e) ? Ju.nextTick(s) : e.once("end", s);
  } else
    r();
  return Eh(
    e,
    {
      readable: !0,
      writable: !1
    },
    (s) => {
      const a = e._readableState;
      s && s.code === "ERR_STREAM_PREMATURE_CLOSE" && a && a.ended && !a.errored && !a.errorEmitted ? e.once("end", r).once("error", r) : r(s);
    }
  ), Eh(
    t,
    {
      readable: !1,
      writable: !0
    },
    r
  );
}
var Ix = {
  pipelineImpl: _7,
  pipeline: zie
};
const { pipeline: Kie } = Ix, dd = uo(), { destroyer: Yie } = gu, {
  isNodeStream: hd,
  isReadable: XN,
  isWritable: JN,
  isWebStream: Ny,
  isTransformStream: Os,
  isWritableStream: QN,
  isReadableStream: ZN
} = Ao, {
  AbortError: Xie,
  codes: { ERR_INVALID_ARG_VALUE: ek, ERR_MISSING_ARGS: Jie }
} = sn, Qie = _s;
var w7 = function(...t) {
  if (t.length === 0)
    throw new Jie("streams");
  if (t.length === 1)
    return dd.from(t[0]);
  const r = [...t];
  if (typeof t[0] == "function" && (t[0] = dd.from(t[0])), typeof t[t.length - 1] == "function") {
    const p = t.length - 1;
    t[p] = dd.from(t[p]);
  }
  for (let p = 0; p < t.length; ++p)
    if (!(!hd(t[p]) && !Ny(t[p]))) {
      if (p < t.length - 1 && !(XN(t[p]) || ZN(t[p]) || Os(t[p])))
        throw new ek(`streams[${p}]`, r[p], "must be readable");
      if (p > 0 && !(JN(t[p]) || QN(t[p]) || Os(t[p])))
        throw new ek(`streams[${p}]`, r[p], "must be writable");
    }
  let n, o, s, a, l;
  function u(p) {
    const v = a;
    a = null, v ? v(p) : p ? l.destroy(p) : !h && !d && l.destroy();
  }
  const f = t[0], c = Kie(t, u), d = !!(JN(f) || QN(f) || Os(f)), h = !!(XN(c) || ZN(c) || Os(c));
  if (l = new dd({
    // TODO (ronag): highWaterMark?
    writableObjectMode: !!(f != null && f.writableObjectMode),
    readableObjectMode: !!(c != null && c.readableObjectMode),
    writable: d,
    readable: h
  }), d) {
    if (hd(f))
      l._write = function(v, y, w) {
        f.write(v, y) ? w() : n = w;
      }, l._final = function(v) {
        f.end(), o = v;
      }, f.on("drain", function() {
        if (n) {
          const v = n;
          n = null, v();
        }
      });
    else if (Ny(f)) {
      const y = (Os(f) ? f.writable : f).getWriter();
      l._write = async function(w, S, x) {
        try {
          await y.ready, y.write(w).catch(() => {
          }), x();
        } catch (E) {
          x(E);
        }
      }, l._final = async function(w) {
        try {
          await y.ready, y.close().catch(() => {
          }), o = w;
        } catch (S) {
          w(S);
        }
      };
    }
    const p = Os(c) ? c.readable : c;
    Qie(p, () => {
      if (o) {
        const v = o;
        o = null, v();
      }
    });
  }
  if (h) {
    if (hd(c))
      c.on("readable", function() {
        if (s) {
          const p = s;
          s = null, p();
        }
      }), c.on("end", function() {
        l.push(null);
      }), l._read = function() {
        for (; ; ) {
          const p = c.read();
          if (p === null) {
            s = l._read;
            return;
          }
          if (!l.push(p))
            return;
        }
      };
    else if (Ny(c)) {
      const v = (Os(c) ? c.readable : c).getReader();
      l._read = async function() {
        for (; ; )
          try {
            const { value: y, done: w } = await v.read();
            if (!l.push(y))
              return;
            if (w) {
              l.push(null);
              return;
            }
          } catch {
            return;
          }
      };
    }
  }
  return l._destroy = function(p, v) {
    !p && a !== null && (p = new Xie()), s = null, n = null, o = null, a === null ? v(p) : (a = v, hd(c) && Yie(c, p));
  }, l;
};
const Zie = globalThis.AbortController || Kt().AbortController, {
  codes: { ERR_INVALID_ARG_VALUE: eoe, ERR_INVALID_ARG_TYPE: Ec, ERR_MISSING_ARGS: toe, ERR_OUT_OF_RANGE: roe },
  AbortError: Ni
} = sn, { validateAbortSignal: za, validateInteger: tk, validateObject: Ga } = Sc, noe = Bt.Symbol("kWeak"), ioe = Bt.Symbol("kResistStopPropagation"), { finished: ooe } = _s, soe = w7, { addAbortSignalNoValidate: aoe } = Zp, { isWritable: loe, isNodeStream: uoe } = Ao, { deprecate: foe } = Vr, {
  ArrayPrototypePush: coe,
  Boolean: doe,
  MathFloor: rk,
  Number: hoe,
  NumberIsNaN: poe,
  Promise: nk,
  PromiseReject: ik,
  PromiseResolve: goe,
  PromisePrototypeThen: ok,
  Symbol: S7
} = Bt, xh = S7("kEmpty"), sk = S7("kEof");
function boe(e, t) {
  if (t != null && Ga(t, "options"), (t == null ? void 0 : t.signal) != null && za(t.signal, "options.signal"), uoe(e) && !loe(e))
    throw new eoe("stream", e, "must be writable");
  const r = soe(this, e);
  return t != null && t.signal && aoe(t.signal, r), r;
}
function rg(e, t) {
  if (typeof e != "function")
    throw new Ec("fn", ["Function", "AsyncFunction"], e);
  t != null && Ga(t, "options"), (t == null ? void 0 : t.signal) != null && za(t.signal, "options.signal");
  let r = 1;
  (t == null ? void 0 : t.concurrency) != null && (r = rk(t.concurrency));
  let n = r - 1;
  return (t == null ? void 0 : t.highWaterMark) != null && (n = rk(t.highWaterMark)), tk(r, "options.concurrency", 1), tk(n, "options.highWaterMark", 0), n += r, (async function* () {
    const s = Vr.AbortSignalAny(
      [t == null ? void 0 : t.signal].filter(doe)
    ), a = this, l = [], u = {
      signal: s
    };
    let f, c, d = !1, h = 0;
    function p() {
      d = !0, v();
    }
    function v() {
      h -= 1, y();
    }
    function y() {
      c && !d && h < r && l.length < n && (c(), c = null);
    }
    async function w() {
      try {
        for await (let S of a) {
          if (d)
            return;
          if (s.aborted)
            throw new Ni();
          try {
            if (S = e(S, u), S === xh)
              continue;
            S = goe(S);
          } catch (x) {
            S = ik(x);
          }
          h += 1, ok(S, v, p), l.push(S), f && (f(), f = null), !d && (l.length >= n || h >= r) && await new nk((x) => {
            c = x;
          });
        }
        l.push(sk);
      } catch (S) {
        const x = ik(S);
        ok(x, v, p), l.push(x);
      } finally {
        d = !0, f && (f(), f = null);
      }
    }
    w();
    try {
      for (; ; ) {
        for (; l.length > 0; ) {
          const S = await l[0];
          if (S === sk)
            return;
          if (s.aborted)
            throw new Ni();
          S !== xh && (yield S), l.shift(), y();
        }
        await new nk((S) => {
          f = S;
        });
      }
    } finally {
      d = !0, c && (c(), c = null);
    }
  }).call(this);
}
function yoe(e = void 0) {
  return e != null && Ga(e, "options"), (e == null ? void 0 : e.signal) != null && za(e.signal, "options.signal"), (async function* () {
    let r = 0;
    for await (const o of this) {
      var n;
      if (e != null && (n = e.signal) !== null && n !== void 0 && n.aborted)
        throw new Ni({
          cause: e.signal.reason
        });
      yield [r++, o];
    }
  }).call(this);
}
async function E7(e, t = void 0) {
  for await (const r of Mx.call(this, e, t))
    return !0;
  return !1;
}
async function voe(e, t = void 0) {
  if (typeof e != "function")
    throw new Ec("fn", ["Function", "AsyncFunction"], e);
  return !await E7.call(
    this,
    async (...r) => !await e(...r),
    t
  );
}
async function moe(e, t) {
  for await (const r of Mx.call(this, e, t))
    return r;
}
async function _oe(e, t) {
  if (typeof e != "function")
    throw new Ec("fn", ["Function", "AsyncFunction"], e);
  async function r(n, o) {
    return await e(n, o), xh;
  }
  for await (const n of rg.call(this, r, t))
    ;
}
function Mx(e, t) {
  if (typeof e != "function")
    throw new Ec("fn", ["Function", "AsyncFunction"], e);
  async function r(n, o) {
    return await e(n, o) ? n : xh;
  }
  return rg.call(this, r, t);
}
let woe = class extends toe {
  constructor() {
    super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
  }
};
async function Soe(e, t, r) {
  var n;
  if (typeof e != "function")
    throw new Ec("reducer", ["Function", "AsyncFunction"], e);
  r != null && Ga(r, "options"), (r == null ? void 0 : r.signal) != null && za(r.signal, "options.signal");
  let o = arguments.length > 1;
  if (r != null && (n = r.signal) !== null && n !== void 0 && n.aborted) {
    const f = new Ni(void 0, {
      cause: r.signal.reason
    });
    throw this.once("error", () => {
    }), await ooe(this.destroy(f)), f;
  }
  const s = new Zie(), a = s.signal;
  if (r != null && r.signal) {
    const f = {
      once: !0,
      [noe]: this,
      [ioe]: !0
    };
    r.signal.addEventListener("abort", () => s.abort(), f);
  }
  let l = !1;
  try {
    for await (const f of this) {
      var u;
      if (l = !0, r != null && (u = r.signal) !== null && u !== void 0 && u.aborted)
        throw new Ni();
      o ? t = await e(t, f, {
        signal: a
      }) : (t = f, o = !0);
    }
    if (!l && !o)
      throw new woe();
  } finally {
    s.abort();
  }
  return t;
}
async function Eoe(e) {
  e != null && Ga(e, "options"), (e == null ? void 0 : e.signal) != null && za(e.signal, "options.signal");
  const t = [];
  for await (const n of this) {
    var r;
    if (e != null && (r = e.signal) !== null && r !== void 0 && r.aborted)
      throw new Ni(void 0, {
        cause: e.signal.reason
      });
    coe(t, n);
  }
  return t;
}
function xoe(e, t) {
  const r = rg.call(this, e, t);
  return (async function* () {
    for await (const o of r)
      yield* o;
  }).call(this);
}
function x7(e) {
  if (e = hoe(e), poe(e))
    return 0;
  if (e < 0)
    throw new roe("number", ">= 0", e);
  return e;
}
function Roe(e, t = void 0) {
  return t != null && Ga(t, "options"), (t == null ? void 0 : t.signal) != null && za(t.signal, "options.signal"), e = x7(e), (async function* () {
    var n;
    if (t != null && (n = t.signal) !== null && n !== void 0 && n.aborted)
      throw new Ni();
    for await (const s of this) {
      var o;
      if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
        throw new Ni();
      e-- <= 0 && (yield s);
    }
  }).call(this);
}
function Aoe(e, t = void 0) {
  return t != null && Ga(t, "options"), (t == null ? void 0 : t.signal) != null && za(t.signal, "options.signal"), e = x7(e), (async function* () {
    var n;
    if (t != null && (n = t.signal) !== null && n !== void 0 && n.aborted)
      throw new Ni();
    for await (const s of this) {
      var o;
      if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
        throw new Ni();
      if (e-- > 0 && (yield s), e <= 0)
        return;
    }
  }).call(this);
}
Ex.streamReturningOperators = {
  asIndexedPairs: foe(yoe, "readable.asIndexedPairs will be removed in a future version."),
  drop: Roe,
  filter: Mx,
  flatMap: xoe,
  map: rg,
  take: Aoe,
  compose: boe
};
Ex.promiseReturningOperators = {
  every: voe,
  forEach: _oe,
  reduce: Soe,
  toArray: Eoe,
  some: E7,
  find: moe
};
var ky, ak;
function R7() {
  if (ak)
    return ky;
  ak = 1;
  const { ArrayPrototypePop: e, Promise: t } = Bt, { isIterable: r, isNodeStream: n, isWebStream: o } = Ao, { pipelineImpl: s } = Ix, { finished: a } = _s;
  A7();
  function l(...u) {
    return new t((f, c) => {
      let d, h;
      const p = u[u.length - 1];
      if (p && typeof p == "object" && !n(p) && !r(p) && !o(p)) {
        const v = e(u);
        d = v.signal, h = v.end;
      }
      s(
        u,
        (v, y) => {
          v ? c(v) : f(y);
        },
        {
          signal: d,
          end: h
        }
      );
    });
  }
  return ky = {
    finished: a,
    pipeline: l
  }, ky;
}
var lk;
function A7() {
  if (lk)
    return hy.exports;
  lk = 1;
  const { Buffer: e } = ft, { ObjectDefineProperty: t, ObjectKeys: r, ReflectApply: n } = Bt, {
    promisify: { custom: o }
  } = Vr, { streamReturningOperators: s, promiseReturningOperators: a } = Ex, {
    codes: { ERR_ILLEGAL_CONSTRUCTOR: l }
  } = sn, u = w7, { setDefaultHighWaterMark: f, getDefaultHighWaterMark: c } = eg, { pipeline: d } = Ix, { destroyer: h } = gu, p = _s, v = R7(), y = Ao, w = hy.exports = $x.Stream;
  w.isDestroyed = y.isDestroyed, w.isDisturbed = y.isDisturbed, w.isErrored = y.isErrored, w.isReadable = y.isReadable, w.isWritable = y.isWritable, w.Readable = tg();
  for (const x of r(s)) {
    let N = function(...C) {
      if (new.target)
        throw l();
      return w.Readable.from(n(E, this, C));
    };
    const E = s[x];
    t(N, "name", {
      __proto__: null,
      value: E.name
    }), t(N, "length", {
      __proto__: null,
      value: E.length
    }), t(w.Readable.prototype, x, {
      __proto__: null,
      value: N,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  for (const x of r(a)) {
    let N = function(...C) {
      if (new.target)
        throw l();
      return n(E, this, C);
    };
    const E = a[x];
    t(N, "name", {
      __proto__: null,
      value: E.name
    }), t(N, "length", {
      __proto__: null,
      value: E.length
    }), t(w.Readable.prototype, x, {
      __proto__: null,
      value: N,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  w.Writable = Nx(), w.Duplex = uo(), w.Transform = y7, w.PassThrough = m7, w.pipeline = d;
  const { addAbortSignal: S } = Zp;
  return w.addAbortSignal = S, w.finished = p, w.destroy = h, w.compose = u, w.setDefaultHighWaterMark = f, w.getDefaultHighWaterMark = c, t(w, "promises", {
    __proto__: null,
    configurable: !0,
    enumerable: !0,
    get() {
      return v;
    }
  }), t(d, o, {
    __proto__: null,
    enumerable: !0,
    get() {
      return v.pipeline;
    }
  }), t(p, o, {
    __proto__: null,
    enumerable: !0,
    get() {
      return v.finished;
    }
  }), w.Stream = w, w._isUint8Array = function(E) {
    return E instanceof Uint8Array;
  }, w._uint8ArrayToBuffer = function(E) {
    return e.from(E.buffer, E.byteOffset, E.byteLength);
  }, hy.exports;
}
(function(e) {
  const t = A7(), r = R7(), n = t.Readable.destroy;
  e.exports = t.Readable, e.exports._uint8ArrayToBuffer = t._uint8ArrayToBuffer, e.exports._isUint8Array = t._isUint8Array, e.exports.isDisturbed = t.isDisturbed, e.exports.isErrored = t.isErrored, e.exports.isReadable = t.isReadable, e.exports.Readable = t.Readable, e.exports.Writable = t.Writable, e.exports.Duplex = t.Duplex, e.exports.Transform = t.Transform, e.exports.PassThrough = t.PassThrough, e.exports.addAbortSignal = t.addAbortSignal, e.exports.finished = t.finished, e.exports.destroy = t.destroy, e.exports.destroy = n, e.exports.pipeline = t.pipeline, e.exports.compose = t.compose, Object.defineProperty(t, "promises", {
    configurable: !0,
    enumerable: !0,
    get() {
      return r;
    }
  }), e.exports.Stream = t.Stream, e.exports.default = e.exports;
})(PF);
var Ox = PF.exports, Toe = /\s/;
function $oe(e) {
  for (var t = e.length; t-- && Toe.test(e.charAt(t)); )
    ;
  return t;
}
var Noe = $oe, koe = Noe, Coe = /^\s+/;
function Ioe(e) {
  return e && e.slice(0, koe(e) + 1).replace(Coe, "");
}
var Moe = Ioe, Cy, uk;
function In() {
  if (uk)
    return Cy;
  uk = 1;
  function e(t) {
    var r = typeof t;
    return t != null && (r == "object" || r == "function");
  }
  return Cy = e, Cy;
}
var Iy, fk;
function T7() {
  if (fk)
    return Iy;
  fk = 1;
  var e = typeof window == "object" && window && window.Object === Object && window;
  return Iy = e, Iy;
}
var My, ck;
function Zn() {
  if (ck)
    return My;
  ck = 1;
  var e = T7(), t = typeof self == "object" && self && self.Object === Object && self, r = e || t || Function("return this")();
  return My = r, My;
}
var Oy, dk;
function bu() {
  if (dk)
    return Oy;
  dk = 1;
  var e = Zn(), t = e.Symbol;
  return Oy = t, Oy;
}
var Ly, hk;
function Ooe() {
  if (hk)
    return Ly;
  hk = 1;
  var e = bu(), t = Object.prototype, r = t.hasOwnProperty, n = t.toString, o = e ? e.toStringTag : void 0;
  function s(a) {
    var l = r.call(a, o), u = a[o];
    try {
      a[o] = void 0;
      var f = !0;
    } catch {
    }
    var c = n.call(a);
    return f && (l ? a[o] = u : delete a[o]), c;
  }
  return Ly = s, Ly;
}
var Py, pk;
function Loe() {
  if (pk)
    return Py;
  pk = 1;
  var e = Object.prototype, t = e.toString;
  function r(n) {
    return t.call(n);
  }
  return Py = r, Py;
}
var Dy, gk;
function Ka() {
  if (gk)
    return Dy;
  gk = 1;
  var e = bu(), t = Ooe(), r = Loe(), n = "[object Null]", o = "[object Undefined]", s = e ? e.toStringTag : void 0;
  function a(l) {
    return l == null ? l === void 0 ? o : n : s && s in Object(l) ? t(l) : r(l);
  }
  return Dy = a, Dy;
}
var Fy, bk;
function ji() {
  if (bk)
    return Fy;
  bk = 1;
  function e(t) {
    return t != null && typeof t == "object";
  }
  return Fy = e, Fy;
}
var jy, yk;
function yu() {
  if (yk)
    return jy;
  yk = 1;
  var e = Ka(), t = ji(), r = "[object Symbol]";
  function n(o) {
    return typeof o == "symbol" || t(o) && e(o) == r;
  }
  return jy = n, jy;
}
var Poe = Moe, vk = In(), Doe = yu(), mk = NaN, Foe = /^[-+]0x[0-9a-f]+$/i, joe = /^0b[01]+$/i, Boe = /^0o[0-7]+$/i, qoe = parseInt;
function Woe(e) {
  if (typeof e == "number")
    return e;
  if (Doe(e))
    return mk;
  if (vk(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = vk(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = Poe(e);
  var r = joe.test(e);
  return r || Boe.test(e) ? qoe(e.slice(2), r ? 2 : 8) : Foe.test(e) ? mk : +e;
}
var Uoe = Woe, Hoe = Uoe, _k = 1 / 0, Voe = 17976931348623157e292;
function zoe(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = Hoe(e), e === _k || e === -_k) {
    var t = e < 0 ? -1 : 1;
    return t * Voe;
  }
  return e === e ? e : 0;
}
var $7 = zoe, Goe = $7;
function Koe(e) {
  var t = Goe(e), r = t % 1;
  return t === t ? r ? t - r : t : 0;
}
var N7 = Koe, Yoe = N7, Xoe = "Expected a function";
function Joe(e, t) {
  var r;
  if (typeof t != "function")
    throw new TypeError(Xoe);
  return e = Yoe(e), function() {
    return --e > 0 && (r = t.apply(this, arguments)), e <= 1 && (t = void 0), r;
  };
}
var Qoe = Joe, Zoe = Qoe;
function ese(e) {
  return Zoe(2, e);
}
var tse = ese;
const rse = /* @__PURE__ */ Tn(tse);
function nse(e) {
  return new Ox.Readable({
    read: rse(async function() {
      try {
        this.push(new Uint8Array(await e())), this.push(null);
      } catch (t) {
        this.destroy(t);
      }
    })
  });
}
class Lx {
  constructor(t, r) {
    this.obj = t;
    for (const [n, o] of Object.entries(r))
      this[n] = o;
    for (const n of Lx.properties(t))
      n in this || (typeof this.obj[n] == "function" ? this[n] = (...o) => this.obj[n].call(t, o) : Object.defineProperty(this, n, {
        get: () => this.obj[n],
        set: (o) => {
          this.obj[n] = o;
        },
        enumerable: !0,
        configurable: !0
      }));
  }
  static properties(t) {
    return Object.getOwnPropertyNames(Object.getPrototypeOf(t));
  }
}
function ise(e) {
  return new Ox.Readable({
    read: async function() {
      try {
        let t, r;
        do
          t = await e.read(), t.done ? this.push(null) : r = !this.push(t.value);
        while (!t.done && !r);
      } catch (t) {
        this.destroy(t);
      }
    }
  });
}
function ose(e) {
  if (e.bodyUsed) {
    const t = new Ox.Readable({
      read: () => t.destroy(new Error("body already in use"))
    });
    return e.body = t, e;
  }
  return e.body && e.body.readable ? e : e.body && typeof e.body.getReader == "function" ? new Lx(e, {
    // ...and replace the body with a readable stream
    body: ise(e.body.getReader())
  }) : (e.body = nse(() => e.arrayBuffer()), e);
}
function sse(e, t) {
  return mre(t).then((r) => fetch(e, r).then((n) => ose(n)));
}
class ase {
  /**
   * @param {Object} options
   * @param {string} [options.endpointUrl] SPARQL query endpoint URL
   * @param {factory} [options.factory] RDF/JS factory
   * @param {fetch} [options.fetch=nodeify-fetch] fetch implementation
   * @param {Headers} [options.headers] headers sent with every request
   * @param {string} [options.password] password used for basic authentication
   * @param {string} [options.storeUrl] SPARQL Graph Store URL
   * @param {string} [options.updateUrl] SPARQL update endpoint URL
   * @param {string} [options.user] user used for basic authentication
   * @param {Query} [options.Query] Constructor of a query implementation
   * @param {Store} [options.Store] Constructor of a store implementation
   */
  constructor({
    endpointUrl: t,
    factory: r,
    fetch: n = sse,
    headers: o,
    password: s,
    storeUrl: a,
    updateUrl: l,
    user: u,
    Query: f = $F,
    Store: c
  }) {
    if (!t && !a && !l)
      throw new Error("no endpointUrl, storeUrl, or updateUrl given");
    this.endpointUrl = t, this.factory = r, this.fetch = n, this.headers = new Headers(o), this.password = s, this.storeUrl = a, this.updateUrl = l, this.user = u, this.query = f ? new f({ client: this }) : null, this.store = c ? new c({ client: this }) : null, typeof u == "string" && typeof s == "string" && this.headers.set("authorization", `Basic ${btoa(`${u}:${s}`)}`);
  }
  /**
   * Sends a GET request as defined in the
   * {@link https://www.w3.org/TR/2013/REC-sparql11-protocol-20130321/#query-via-get SPARQL Protocol specification}.
   *
   * @param {string} query SPARQL query
   * @param {Object} options
   * @param {Headers} [options.headers] additional request headers
   * @param {boolean} [options.update=false] send the request to the updateUrl
   * @return {Promise<Response>}
   */
  async get(t, { headers: r, update: n = !1 } = {}) {
    let o = null;
    return n ? (o = new URL(this.updateUrl), o.searchParams.append("update", t)) : (o = new URL(this.endpointUrl), o.searchParams.append("query", t)), this.fetch(o.toString().replace(/\+/g, "%20"), {
      method: "GET",
      headers: Xo(this.headers, r)
    });
  }
  /**
   * Sends a POST directly request as defined in the
   * {@link https://www.w3.org/TR/2013/REC-sparql11-protocol-20130321/#query-via-post-direct SPARQL Protocol specification}.
   *
   *
   * @param {string} query SPARQL query
   * @param {Object} options
   * @param {Headers} [options.headers] additional request headers
   * @param {boolean} [options.update=false] send the request to the updateUrl
   * @return {Promise<Response>}
   */
  async postDirect(t, { headers: r, update: n = !1 } = {}) {
    let o = null;
    return n ? o = new URL(this.updateUrl) : o = new URL(this.endpointUrl), r = Xo(this.headers, r), r.has("content-type") || r.set("content-type", "application/sparql-query; charset=utf-8"), this.fetch(o, {
      method: "POST",
      headers: r,
      body: t
    });
  }
  /**
   * Sends a POST URL-encoded request as defined in the
   * {@link https://www.w3.org/TR/2013/REC-sparql11-protocol-20130321/#query-via-post-urlencoded SPARQL Protocol specification}.
   *
   * @param {string} query SPARQL query
   * @param {Object} options
   * @param {Headers} [options.headers] additional request headers
   * @param {boolean} [options.update=false] send the request to the updateUrl
   * @return {Promise<Response>}
   */
  async postUrlencoded(t, { headers: r, update: n = !1 } = {}) {
    let o = null, s = null;
    return n ? (o = new URL(this.updateUrl), s = `update=${encodeURIComponent(t)}`) : (o = new URL(this.endpointUrl), s = `query=${encodeURIComponent(t)}`), r = Xo(this.headers, r), r.has("content-type") || r.set("content-type", "application/x-www-form-urlencoded"), this.fetch(o, {
      method: "POST",
      headers: r,
      body: s
    });
  }
}
const lse = new mp([uu, k3]);
class use extends ase {
  /**
   * @param {Object} options
   * @param {string} [options.endpointUrl] SPARQL query endpoint URL
   * @param {factory} [options.factory] RDF/JS factory
   * @param {fetch} [options.fetch=nodeify-fetch] fetch implementation
   * @param {Headers} [options.headers] headers sent with every request
   * @param {string} [options.password] password used for basic authentication
   * @param {string} [options.storeUrl] SPARQL Graph Store URL
   * @param {string} [options.updateUrl] SPARQL update endpoint URL
   * @param {string} [options.user] user used for basic authentication
   */
  constructor({
    endpointUrl: t,
    factory: r = lse,
    fetch: n,
    headers: o,
    password: s,
    storeUrl: a,
    updateUrl: l,
    user: u
  }) {
    if (super({
      endpointUrl: t,
      factory: r,
      fetch: n,
      headers: o,
      password: s,
      storeUrl: a,
      updateUrl: l,
      user: u,
      Query: yre
    }), !nY(this.factory))
      throw new Error("the given factory doesn't implement the DatasetCoreFactory interface");
  }
}
vi.spex = "https://described.at/spex/";
const Un = Gt.namespace(vi.rdf), SS = Gt.namespace(vi.schema), Pt = Gt.namespace(vi.sh), Jo = Gt.namespace(vi.spex);
function fse(e, t, r) {
  const n = e.out(Jo.shape).has(Un.type, Jo.DefaultShapes), o = n.term ? cse(n.out(SS.hasPart), r) : [], s = e.out(Jo.viewport).map((a) => ({
    id: a.term.value,
    term: a.term,
    name: a.out(SS`name`, { language: t }).value,
    tables: new Set(a.out(Jo.includes).terms.map(({ value: l }) => l))
  }));
  return {
    tables: o,
    viewports: s,
    isIntrospected: !1
  };
}
function cse(e, t) {
  return e.toArray().flatMap((r) => {
    const n = r.out(Pt.targetClass).term;
    if (!n)
      return [];
    const o = n.value, s = r.out(Pt.property).toArray().flatMap((a) => {
      const l = a.out(Pt.path).term;
      if (!l)
        return [];
      const u = l.value, f = k7(a, t);
      return {
        id: u,
        name: t(u),
        values: f
      };
    });
    return {
      id: o,
      name: t(o),
      properties: s,
      isShown: !0
    };
  });
}
function k7(e, t) {
  const r = e.out(Pt.datatype).terms.map((a) => wk(a, t)), n = e.out(Pt.class).terms.map((a) => wk(a, t));
  let o = [];
  const s = e.out(Pt.or).list();
  return s !== null && (o = [...s].flatMap((a) => k7(a, t))), [
    ...r,
    ...n,
    ...o
  ];
}
function wk(e, t) {
  return {
    id: e.value,
    name: t(e.value),
    termType: e.termType
  };
}
function dse(e, t) {
  const r = Gt.clownface({
    dataset: Gt.dataset(),
    term: Gt.namedNode(t)
  });
  return r.addOut(Jo.shape, (n) => {
    n.addOut(Un.type, Jo.DefaultShapes), e.tables.forEach((o) => {
      n.addOut(SS.hasPart, (s) => {
        s.addOut(Un.type, Pt.NodeShape).addOut(Pt.targetClass, Gt.namedNode(o.id)), o.properties.forEach((a) => {
          s.addOut(Pt.property, (l) => {
            l.addOut(Un.type, Pt.PropertyShape).addOut(Pt.path, Gt.namedNode(a.id));
            const u = (f) => f.termType === "NamedNode" ? [Pt.class, Gt.namedNode(f.id)] : [Pt.datatype, Gt.namedNode(f.id)];
            if (a.values.length === 1) {
              const f = u(a.values[0]);
              l.addOut(f[0], f[1]);
            } else
              a.values.length > 1 && l.addList(Pt.or, a.values.map((f) => {
                const c = u(f);
                return l.blankNode().addOut(c[0], c[1]);
              }));
          });
        });
      });
    });
  }), r;
}
const hse = ".well-known/void", pse = [...Object.keys(vi)], gse = ["en", "*"], tp = class tp {
  constructor(t) {
    As(this, "_client");
    this._settings = t, this.applySettings(t);
  }
  /**
   * Get the instance of this class.
   * @param settings configuration for the endpoint
   * @returns The Endpoint instance (singleton)
   */
  static getInstance(t) {
    if (this._endpointInstance === null && t)
      return this._endpointInstance = new tp(t), this._endpointInstance;
    if (t && this._endpointInstance && this._endpointInstance.applySettings(t), this._endpointInstance === null)
      throw new Error("Endpoint Not Configured");
    return this._endpointInstance;
  }
  /**
  * Use new setting for SPARQL endpoint
  * @param _settings new Settings for SPARQL Endpoint
  */
  applySettings(t) {
    this._settings = t, this._settings.sparqlEndpoint && (this._client = new use(
      {
        endpointUrl: this._settings.sparqlEndpoint,
        user: this._settings.username ?? void 0,
        password: this._settings.password ?? void 0
      }
    )), Object.keys(vi).forEach((r) => {
      pse.includes(r) || delete vi[r];
    }), this._settings.prefixes.forEach(({ prefix: r, namespace: n }) => {
      vi[r] = n;
    });
  }
  shrink(t) {
    return p3(t) || t;
  }
  /**
   * Fetch a list of graphs in the endpoint
   */
  async fetchGraphs(t) {
    const r = (t == null ? void 0 : t.offset) ?? 0, n = (t == null ? void 0 : t.limit) ?? null, o = `
      PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

      SELECT DISTINCT ?g
      WHERE {
        GRAPH ?g { ?s ?p ?o }
      }
      ORDER BY ?g
      OFFSET ${r}
      LIMIT ${n}
    `;
    return (await this._client.query.select(o)).map(({ g: { value: a } }) => a);
  }
  /**
   * Fetch data model, either by introspecting it or by querying the
   * pre-defined SHACL definition
   */
  async fetchDataModel() {
    if (this._settings.forceIntrospection)
      return this.fetchIntrospectDataModel();
    const t = await this.fetchPredefinedDataModel();
    return t !== null ? t : this.fetchIntrospectDataModel();
  }
  get datasetURI() {
    var t;
    return ((t = this._settings.sparqlEndpoint) == null ? void 0 : t.replace(/query\/?$/, hse)) ?? "";
  }
  get sparqlEndpoint() {
    return this._settings.sparqlEndpoint ?? "";
  }
  get prefixes() {
    return this._settings.prefixes;
  }
  /**
   * Fetch data model from pre-defined SHACL definition
   */
  async fetchPredefinedDataModel() {
    const t = this._settings.namedGraph ? `FROM <${this._settings.namedGraph}>` : "", r = `
      #pragma describe.strategy cbd
      DESCRIBE <${this.datasetURI}>
      ${t}
    `, n = await this._client.query.construct(r);
    if (n.size === 0)
      return null;
    const o = Gt.clownface({
      dataset: n,
      term: Gt.namedNode(this.datasetURI)
    });
    return this.dataModelFromSHACL(o);
  }
  dataModelFromSHACL(t) {
    return fse(t, gse, this.shrink);
  }
  dataModelToSHACL(t) {
    return dse(t, this.datasetURI);
  }
  /**
   * Fetch data model by introspecting the endpoint
   */
  async fetchIntrospectDataModel() {
    const n = [...(await this._fetchStructure()).reduce((s, { cls: a, property: l, linktype: u, datatype: f }) => {
      const c = s.get(a.value) ?? {
        id: a.value,
        name: this.shrink(a.value),
        properties: /* @__PURE__ */ new Map(),
        isShown: a.value !== "http://www.w3.org/2000/01/rdf-schema#Class"
      }, d = u && u.value || f && f.value || null, h = u ? "NamedNode" : f ? "Literal" : null, p = d && {
        id: d,
        name: this.shrink(d),
        termType: h
      };
      return c.properties.has(l.value) ? p && c.properties.get(l.value).values.push(p) : c.properties.set(l.value, {
        id: l.value,
        name: this.shrink(l.value),
        values: p ? [p] : []
      }), s.set(a.value, c), s;
    }, /* @__PURE__ */ new Map()).values()].map((s) => ({ ...s, properties: [...s.properties.values()] })), o = await this.countClasses();
    return n.forEach((s) => {
      s.count = o.get(s.id);
    }), {
      tables: n,
      viewports: [],
      isIntrospected: !0
    };
  }
  async _fetchStructure() {
    const r = `
      PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

      SELECT DISTINCT ?cls ?property ?linktype ?datatype
      ${this._settings.namedGraph ? `FROM <${this._settings.namedGraph}>` : ""}
      WHERE {
        ?subject a ?cls .
        ?subject ?property ?object .

        FILTER(?property != rdf:type)
        OPTIONAL {
          ?object a ?linktype .
        }

        BIND(DATATYPE(?object) AS ?datatype)
      }
    `;
    return this._client.query.select(r);
  }
  /**
   * Fetch a sample of the data of a given table
   */
  async fetchTableData(t, r) {
    const n = Gt.namedNode(t.id), o = (r == null ? void 0 : r.limit) ?? 10, s = (r == null ? void 0 : r.offset) ?? 0, l = `
      DESCRIBE ?subject {
        {
          SELECT ?subject
          WHERE {
            ${this._settings.namedGraph ? `GRAPH <${this._settings.namedGraph}>` : ""} {
              ?subject a <${t.id}>
            }
          }
          LIMIT ${o}
          OFFSET ${s}
        }
      }
    `, u = await this._client.query.construct(l), f = [...u.match(null, Un.type, n)], c = Gt.termMap(f.map(({ subject: d }) => [d, { id: d.value, term: d }]));
    return [...u].forEach(({ subject: d, predicate: { value: h }, object: p }) => {
      const v = c.get(d);
      v && (v[h] || (v[h] = Gt.termSet()), v[h].add(p), c.set(d, v));
    }), [...c.values()];
  }
  /**
   * Fetch triples related to a given resource.
   */
  async fetchResource(t) {
    const r = `
      DESCRIBE <${t}> {}
    `, o = [...await this._client.query.construct(r)].reduce((a, { predicate: l, object: u }) => {
      if (!a.has(l.value)) {
        const f = {
          id: l.value,
          term: l,
          name: this.shrink(l.value),
          values: Gt.termSet()
        };
        a.set(l.value, f);
      }
      return a.get(l.value).values.add(u), a;
    }, /* @__PURE__ */ new Map()), s = { value: t, termType: "NamedNode" };
    return {
      id: t,
      term: s,
      name: this.shrink(s.value),
      properties: [...o.values()]
    };
  }
  /**
   * You can use this function to the the connection.
   *
   * @returns Promise<boolean> true if the SPARQL endpoint returns a triple
   */
  async canFetchOne() {
    const t = `
      SELECT ?s WHERE {
        ?s ?p ?o
      } LIMIT 1
    `;
    try {
      return (await this._client.query.select(t)).length === 1;
    } catch {
      return !1;
    }
  }
  async countClasses() {
    const t = /* @__PURE__ */ new Map(), r = bse(this._settings.namedGraph);
    return (await this._client.query.select(r)).forEach((o) => {
      t.set(o.class.value, Number(o.count.value));
    }), t;
  }
};
// eslint-disable-next-line no-use-before-define
As(tp, "_endpointInstance", null);
let co = tp;
function bse(e) {
  return `
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

SELECT ?class (count(?x) as ?count) ${e ? `FROM <${e}>` : ""} WHERE {
  ?x a ?class .
} group by ?class
`;
}
function yse(e, t) {
  return class extends e {
    constructor() {
      super(), this.$rdf = t;
    }
  };
}
const vse = (e, t, r, n) => {
  if (r === "length" || r === "prototype" || r === "arguments" || r === "caller")
    return;
  const o = Object.getOwnPropertyDescriptor(e, r), s = Object.getOwnPropertyDescriptor(t, r);
  !mse(o, s) && n || Object.defineProperty(e, r, s);
}, mse = function(e, t) {
  return e === void 0 || e.configurable || e.writable === t.writable && e.enumerable === t.enumerable && e.configurable === t.configurable && (e.writable || e.value === t.value);
}, _se = (e, t) => {
  const r = Object.getPrototypeOf(t);
  r !== Object.getPrototypeOf(e) && Object.setPrototypeOf(e, r);
}, wse = (e, t) => `/* Wrapped ${e}*/
${t}`, Sse = Object.getOwnPropertyDescriptor(Function.prototype, "toString"), Ese = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name"), xse = (e, t, r) => {
  const n = r === "" ? "" : `with ${r.trim()}() `, o = wse.bind(null, n, t.toString());
  Object.defineProperty(o, "name", Ese), Object.defineProperty(e, "toString", { ...Sse, value: o });
};
function Rse(e, t, { ignoreNonConfigurable: r = !1 } = {}) {
  const { name: n } = e;
  for (const o of Reflect.ownKeys(t))
    vse(e, t, o, r);
  return _se(e, t), xse(e, t, n), e;
}
const Rh = /* @__PURE__ */ new WeakMap(), C7 = (e, t = {}) => {
  if (typeof e != "function")
    throw new TypeError("Expected a function");
  let r, n = 0;
  const o = e.displayName || e.name || "<anonymous>", s = function(...a) {
    if (Rh.set(s, ++n), n === 1)
      r = e.apply(this, a), e = null;
    else if (t.throw === !0)
      throw new Error(`Function \`${o}\` can only be called once`);
    return r;
  };
  return Rse(s, e), Rh.set(s, n), s;
};
C7.callCount = (e) => {
  if (!Rh.has(e))
    throw new Error(`The given function \`${e.name}\` is not wrapped by the \`onetime\` package`);
  return Rh.get(e);
};
var I7 = { exports: {} }, By = { exports: {} }, qt = {
  ArrayIsArray(e) {
    return Array.isArray(e);
  },
  ArrayPrototypeIncludes(e, t) {
    return e.includes(t);
  },
  ArrayPrototypeIndexOf(e, t) {
    return e.indexOf(t);
  },
  ArrayPrototypeJoin(e, t) {
    return e.join(t);
  },
  ArrayPrototypeMap(e, t) {
    return e.map(t);
  },
  ArrayPrototypePop(e, t) {
    return e.pop(t);
  },
  ArrayPrototypePush(e, t) {
    return e.push(t);
  },
  ArrayPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  Error,
  FunctionPrototypeCall(e, t, ...r) {
    return e.call(t, ...r);
  },
  FunctionPrototypeSymbolHasInstance(e, t) {
    return Function.prototype[Symbol.hasInstance].call(e, t);
  },
  MathFloor: Math.floor,
  Number,
  NumberIsInteger: Number.isInteger,
  NumberIsNaN: Number.isNaN,
  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
  NumberParseInt: Number.parseInt,
  ObjectDefineProperties(e, t) {
    return Object.defineProperties(e, t);
  },
  ObjectDefineProperty(e, t, r) {
    return Object.defineProperty(e, t, r);
  },
  ObjectGetOwnPropertyDescriptor(e, t) {
    return Object.getOwnPropertyDescriptor(e, t);
  },
  ObjectKeys(e) {
    return Object.keys(e);
  },
  ObjectSetPrototypeOf(e, t) {
    return Object.setPrototypeOf(e, t);
  },
  Promise,
  PromisePrototypeCatch(e, t) {
    return e.catch(t);
  },
  PromisePrototypeThen(e, t, r) {
    return e.then(t, r);
  },
  PromiseReject(e) {
    return Promise.reject(e);
  },
  PromiseResolve(e) {
    return Promise.resolve(e);
  },
  ReflectApply: Reflect.apply,
  RegExpPrototypeTest(e, t) {
    return e.test(t);
  },
  SafeSet: Set,
  String,
  StringPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  StringPrototypeToLowerCase(e) {
    return e.toLowerCase();
  },
  StringPrototypeToUpperCase(e) {
    return e.toUpperCase();
  },
  StringPrototypeTrim(e) {
    return e.trim();
  },
  Symbol,
  SymbolFor: Symbol.for,
  SymbolAsyncIterator: Symbol.asyncIterator,
  SymbolHasInstance: Symbol.hasInstance,
  SymbolIterator: Symbol.iterator,
  SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
  SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
  TypedArrayPrototypeSet(e, t, r) {
    return e.set(t, r);
  },
  Boolean,
  Uint8Array
}, M7 = { exports: {} };
(function(e) {
  const t = ft, { kResistStopPropagation: r, SymbolDispose: n } = qt, o = globalThis.AbortSignal || Kt().AbortSignal, s = globalThis.AbortController || Kt().AbortController, a = Object.getPrototypeOf(async function() {
  }).constructor, l = globalThis.Blob || t.Blob, u = typeof l < "u" ? function(p) {
    return p instanceof l;
  } : function(p) {
    return !1;
  }, f = (h, p) => {
    if (h !== void 0 && (h === null || typeof h != "object" || !("aborted" in h)))
      throw new ERR_INVALID_ARG_TYPE(p, "AbortSignal", h);
  }, c = (h, p) => {
    if (typeof h != "function")
      throw new ERR_INVALID_ARG_TYPE(p, "Function", h);
  };
  class d extends Error {
    constructor(p) {
      if (!Array.isArray(p))
        throw new TypeError(`Expected input to be an Array, got ${typeof p}`);
      let v = "";
      for (let y = 0; y < p.length; y++)
        v += `    ${p[y].stack}
`;
      super(v), this.name = "AggregateError", this.errors = p;
    }
  }
  e.exports = {
    AggregateError: d,
    kEmptyObject: Object.freeze({}),
    once(h) {
      let p = !1;
      return function(...v) {
        p || (p = !0, h.apply(this, v));
      };
    },
    createDeferredPromise: function() {
      let h, p;
      return {
        promise: new Promise((y, w) => {
          h = y, p = w;
        }),
        resolve: h,
        reject: p
      };
    },
    promisify(h) {
      return new Promise((p, v) => {
        h((y, ...w) => y ? v(y) : p(...w));
      });
    },
    debuglog() {
      return function() {
      };
    },
    format(h, ...p) {
      return h.replace(/%([sdifj])/g, function(...[v, y]) {
        const w = p.shift();
        return y === "f" ? w.toFixed(6) : y === "j" ? JSON.stringify(w) : y === "s" && typeof w == "object" ? `${w.constructor !== Object ? w.constructor.name : ""} {}`.trim() : w.toString();
      });
    },
    inspect(h) {
      switch (typeof h) {
        case "string":
          if (h.includes("'"))
            if (h.includes('"')) {
              if (!h.includes("`") && !h.includes("${"))
                return `\`${h}\``;
            } else
              return `"${h}"`;
          return `'${h}'`;
        case "number":
          return isNaN(h) ? "NaN" : Object.is(h, -0) ? String(h) : h;
        case "bigint":
          return `${String(h)}n`;
        case "boolean":
        case "undefined":
          return String(h);
        case "object":
          return "{}";
      }
    },
    types: {
      isAsyncFunction(h) {
        return h instanceof a;
      },
      isArrayBufferView(h) {
        return ArrayBuffer.isView(h);
      }
    },
    isBlob: u,
    deprecate(h, p) {
      return h;
    },
    addAbortListener: ur.addAbortListener || function(p, v) {
      if (p === void 0)
        throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", p);
      f(p, "signal"), c(v, "listener");
      let y;
      return p.aborted ? queueMicrotask(() => v()) : (p.addEventListener("abort", v, {
        __proto__: null,
        once: !0,
        [r]: !0
      }), y = () => {
        p.removeEventListener("abort", v);
      }), {
        __proto__: null,
        [n]() {
          var w;
          (w = y) === null || w === void 0 || w();
        }
      };
    },
    AbortSignalAny: o.any || function(p) {
      if (p.length === 1)
        return p[0];
      const v = new s(), y = () => v.abort();
      return p.forEach((w) => {
        f(w, "signals"), w.addEventListener("abort", y, {
          once: !0
        });
      }), v.signal.addEventListener(
        "abort",
        () => {
          p.forEach((w) => w.removeEventListener("abort", y));
        },
        {
          once: !0
        }
      ), v.signal;
    }
  }, e.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
})(M7);
var zr = M7.exports, Px = {};
const { format: Ase, inspect: Ah, AggregateError: Tse } = zr, $se = globalThis.AggregateError || Tse, Nse = Symbol("kIsNodeError"), kse = [
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
], Cse = /^([A-Z][a-z0-9]*)+$/, Ise = "__node_internal_", ng = {};
function da(e, t) {
  if (!e)
    throw new ng.ERR_INTERNAL_ASSERTION(t);
}
function Sk(e) {
  let t = "", r = e.length;
  const n = e[0] === "-" ? 1 : 0;
  for (; r >= n + 4; r -= 3)
    t = `_${e.slice(r - 3, r)}${t}`;
  return `${e.slice(0, r)}${t}`;
}
function Mse(e, t, r) {
  if (typeof t == "function")
    return da(
      t.length <= r.length,
      // Default options do not count.
      `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${t.length}).`
    ), t(...r);
  const n = (t.match(/%[dfijoOs]/g) || []).length;
  return da(
    n === r.length,
    `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${n}).`
  ), r.length === 0 ? t : Ase(t, ...r);
}
function xr(e, t, r) {
  r || (r = Error);
  class n extends r {
    constructor(...s) {
      super(Mse(e, t, s));
    }
    toString() {
      return `${this.name} [${e}]: ${this.message}`;
    }
  }
  Object.defineProperties(n.prototype, {
    name: {
      value: r.name,
      writable: !0,
      enumerable: !1,
      configurable: !0
    },
    toString: {
      value() {
        return `${this.name} [${e}]: ${this.message}`;
      },
      writable: !0,
      enumerable: !1,
      configurable: !0
    }
  }), n.prototype.code = e, n.prototype[Nse] = !0, ng[e] = n;
}
function Ek(e) {
  const t = Ise + e.name;
  return Object.defineProperty(e, "name", {
    value: t
  }), e;
}
function Ose(e, t) {
  if (e && t && e !== t) {
    if (Array.isArray(t.errors))
      return t.errors.push(e), t;
    const r = new $se([t, e], t.message);
    return r.code = t.code, r;
  }
  return e || t;
}
let Lse = class extends Error {
  constructor(t = "The operation was aborted", r = void 0) {
    if (r !== void 0 && typeof r != "object")
      throw new ng.ERR_INVALID_ARG_TYPE("options", "Object", r);
    super(t, r), this.code = "ABORT_ERR", this.name = "AbortError";
  }
};
xr("ERR_ASSERTION", "%s", Error);
xr(
  "ERR_INVALID_ARG_TYPE",
  (e, t, r) => {
    da(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
    let n = "The ";
    e.endsWith(" argument") ? n += `${e} ` : n += `"${e}" ${e.includes(".") ? "property" : "argument"} `, n += "must be ";
    const o = [], s = [], a = [];
    for (const u of t)
      da(typeof u == "string", "All expected entries have to be of type string"), kse.includes(u) ? o.push(u.toLowerCase()) : Cse.test(u) ? s.push(u) : (da(u !== "object", 'The value "object" should be written as "Object"'), a.push(u));
    if (s.length > 0) {
      const u = o.indexOf("object");
      u !== -1 && (o.splice(o, u, 1), s.push("Object"));
    }
    if (o.length > 0) {
      switch (o.length) {
        case 1:
          n += `of type ${o[0]}`;
          break;
        case 2:
          n += `one of type ${o[0]} or ${o[1]}`;
          break;
        default: {
          const u = o.pop();
          n += `one of type ${o.join(", ")}, or ${u}`;
        }
      }
      (s.length > 0 || a.length > 0) && (n += " or ");
    }
    if (s.length > 0) {
      switch (s.length) {
        case 1:
          n += `an instance of ${s[0]}`;
          break;
        case 2:
          n += `an instance of ${s[0]} or ${s[1]}`;
          break;
        default: {
          const u = s.pop();
          n += `an instance of ${s.join(", ")}, or ${u}`;
        }
      }
      a.length > 0 && (n += " or ");
    }
    switch (a.length) {
      case 0:
        break;
      case 1:
        a[0].toLowerCase() !== a[0] && (n += "an "), n += `${a[0]}`;
        break;
      case 2:
        n += `one of ${a[0]} or ${a[1]}`;
        break;
      default: {
        const u = a.pop();
        n += `one of ${a.join(", ")}, or ${u}`;
      }
    }
    if (r == null)
      n += `. Received ${r}`;
    else if (typeof r == "function" && r.name)
      n += `. Received function ${r.name}`;
    else if (typeof r == "object") {
      var l;
      if ((l = r.constructor) !== null && l !== void 0 && l.name)
        n += `. Received an instance of ${r.constructor.name}`;
      else {
        const u = Ah(r, {
          depth: -1
        });
        n += `. Received ${u}`;
      }
    } else {
      let u = Ah(r, {
        colors: !1
      });
      u.length > 25 && (u = `${u.slice(0, 25)}...`), n += `. Received type ${typeof r} (${u})`;
    }
    return n;
  },
  TypeError
);
xr(
  "ERR_INVALID_ARG_VALUE",
  (e, t, r = "is invalid") => {
    let n = Ah(t);
    return n.length > 128 && (n = n.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${n}`;
  },
  TypeError
);
xr(
  "ERR_INVALID_RETURN_VALUE",
  (e, t, r) => {
    var n;
    const o = r != null && (n = r.constructor) !== null && n !== void 0 && n.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
    return `Expected ${e} to be returned from the "${t}" function but got ${o}.`;
  },
  TypeError
);
xr(
  "ERR_MISSING_ARGS",
  (...e) => {
    da(e.length > 0, "At least one arg needs to be specified");
    let t;
    const r = e.length;
    switch (e = (Array.isArray(e) ? e : [e]).map((n) => `"${n}"`).join(" or "), r) {
      case 1:
        t += `The ${e[0]} argument`;
        break;
      case 2:
        t += `The ${e[0]} and ${e[1]} arguments`;
        break;
      default:
        {
          const n = e.pop();
          t += `The ${e.join(", ")}, and ${n} arguments`;
        }
        break;
    }
    return `${t} must be specified`;
  },
  TypeError
);
xr(
  "ERR_OUT_OF_RANGE",
  (e, t, r) => {
    da(t, 'Missing "range" argument');
    let n;
    return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? n = Sk(String(r)) : typeof r == "bigint" ? (n = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (n = Sk(n)), n += "n") : n = Ah(r), `The value of "${e}" is out of range. It must be ${t}. Received ${n}`;
  },
  RangeError
);
xr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
xr("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
xr("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
xr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
xr("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
xr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
xr("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
xr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
xr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
xr("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
xr("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
var an = {
  AbortError: Lse,
  aggregateTwoErrors: Ek(Ose),
  hideStackFrames: Ek,
  codes: ng
};
const {
  ArrayIsArray: Dx,
  ArrayPrototypeIncludes: O7,
  ArrayPrototypeJoin: L7,
  ArrayPrototypeMap: Pse,
  NumberIsInteger: Fx,
  NumberIsNaN: Dse,
  NumberMAX_SAFE_INTEGER: Fse,
  NumberMIN_SAFE_INTEGER: jse,
  NumberParseInt: Bse,
  ObjectPrototypeHasOwnProperty: qse,
  RegExpPrototypeExec: P7,
  String: Wse,
  StringPrototypeToUpperCase: Use,
  StringPrototypeTrim: Hse
} = qt, {
  hideStackFrames: Mn,
  codes: { ERR_SOCKET_BAD_PORT: Vse, ERR_INVALID_ARG_TYPE: Or, ERR_INVALID_ARG_VALUE: vu, ERR_OUT_OF_RANGE: Ta, ERR_UNKNOWN_SIGNAL: xk }
} = an, { normalizeEncoding: zse } = zr, { isAsyncFunction: Gse, isArrayBufferView: Kse } = zr.types, Rk = {};
function Yse(e) {
  return e === (e | 0);
}
function Xse(e) {
  return e === e >>> 0;
}
const Jse = /^[0-7]+$/, Qse = "must be a 32-bit unsigned integer or an octal string";
function Zse(e, t, r) {
  if (typeof e > "u" && (e = r), typeof e == "string") {
    if (P7(Jse, e) === null)
      throw new vu(t, e, Qse);
    e = Bse(e, 8);
  }
  return D7(e, t), e;
}
const eae = Mn((e, t, r = jse, n = Fse) => {
  if (typeof e != "number")
    throw new Or(t, "number", e);
  if (!Fx(e))
    throw new Ta(t, "an integer", e);
  if (e < r || e > n)
    throw new Ta(t, `>= ${r} && <= ${n}`, e);
}), tae = Mn((e, t, r = -2147483648, n = 2147483647) => {
  if (typeof e != "number")
    throw new Or(t, "number", e);
  if (!Fx(e))
    throw new Ta(t, "an integer", e);
  if (e < r || e > n)
    throw new Ta(t, `>= ${r} && <= ${n}`, e);
}), D7 = Mn((e, t, r = !1) => {
  if (typeof e != "number")
    throw new Or(t, "number", e);
  if (!Fx(e))
    throw new Ta(t, "an integer", e);
  const n = r ? 1 : 0, o = 4294967295;
  if (e < n || e > o)
    throw new Ta(t, `>= ${n} && <= ${o}`, e);
});
function jx(e, t) {
  if (typeof e != "string")
    throw new Or(t, "string", e);
}
function rae(e, t, r = void 0, n) {
  if (typeof e != "number")
    throw new Or(t, "number", e);
  if (r != null && e < r || n != null && e > n || (r != null || n != null) && Dse(e))
    throw new Ta(
      t,
      `${r != null ? `>= ${r}` : ""}${r != null && n != null ? " && " : ""}${n != null ? `<= ${n}` : ""}`,
      e
    );
}
const nae = Mn((e, t, r) => {
  if (!O7(r, e)) {
    const o = "must be one of: " + L7(
      Pse(r, (s) => typeof s == "string" ? `'${s}'` : Wse(s)),
      ", "
    );
    throw new vu(t, e, o);
  }
});
function F7(e, t) {
  if (typeof e != "boolean")
    throw new Or(t, "boolean", e);
}
function qy(e, t, r) {
  return e == null || !qse(e, t) ? r : e[t];
}
const iae = Mn((e, t, r = null) => {
  const n = qy(r, "allowArray", !1), o = qy(r, "allowFunction", !1);
  if (!qy(r, "nullable", !1) && e === null || !n && Dx(e) || typeof e != "object" && (!o || typeof e != "function"))
    throw new Or(t, "Object", e);
}), oae = Mn((e, t) => {
  if (e != null && typeof e != "object" && typeof e != "function")
    throw new Or(t, "a dictionary", e);
}), ig = Mn((e, t, r = 0) => {
  if (!Dx(e))
    throw new Or(t, "Array", e);
  if (e.length < r) {
    const n = `must be longer than ${r}`;
    throw new vu(t, e, n);
  }
});
function sae(e, t) {
  ig(e, t);
  for (let r = 0; r < e.length; r++)
    jx(e[r], `${t}[${r}]`);
}
function aae(e, t) {
  ig(e, t);
  for (let r = 0; r < e.length; r++)
    F7(e[r], `${t}[${r}]`);
}
function lae(e, t) {
  ig(e, t);
  for (let r = 0; r < e.length; r++) {
    const n = e[r], o = `${t}[${r}]`;
    if (n == null)
      throw new Or(o, "AbortSignal", n);
    j7(n, o);
  }
}
function uae(e, t = "signal") {
  if (jx(e, t), Rk[e] === void 0)
    throw Rk[Use(e)] !== void 0 ? new xk(e + " (signals must use all capital letters)") : new xk(e);
}
const fae = Mn((e, t = "buffer") => {
  if (!Kse(e))
    throw new Or(t, ["Buffer", "TypedArray", "DataView"], e);
});
function cae(e, t) {
  const r = zse(t), n = e.length;
  if (r === "hex" && n % 2 !== 0)
    throw new vu("encoding", t, `is invalid for data of length ${n}`);
}
function dae(e, t = "Port", r = !0) {
  if (typeof e != "number" && typeof e != "string" || typeof e == "string" && Hse(e).length === 0 || +e !== +e >>> 0 || e > 65535 || e === 0 && !r)
    throw new Vse(t, e, r);
  return e | 0;
}
const j7 = Mn((e, t) => {
  if (e !== void 0 && (e === null || typeof e != "object" || !("aborted" in e)))
    throw new Or(t, "AbortSignal", e);
}), hae = Mn((e, t) => {
  if (typeof e != "function")
    throw new Or(t, "Function", e);
}), pae = Mn((e, t) => {
  if (typeof e != "function" || Gse(e))
    throw new Or(t, "Function", e);
}), gae = Mn((e, t) => {
  if (e !== void 0)
    throw new Or(t, "undefined", e);
});
function bae(e, t, r) {
  if (!O7(r, e))
    throw new Or(t, `('${L7(r, "|")}')`, e);
}
const yae = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
function Ak(e, t) {
  if (typeof e > "u" || !P7(yae, e))
    throw new vu(
      t,
      e,
      'must be an array or string of format "</styles.css>; rel=preload; as=style"'
    );
}
function vae(e) {
  if (typeof e == "string")
    return Ak(e, "hints"), e;
  if (Dx(e)) {
    const t = e.length;
    let r = "";
    if (t === 0)
      return r;
    for (let n = 0; n < t; n++) {
      const o = e[n];
      Ak(o, "hints"), r += o, n !== t - 1 && (r += ", ");
    }
    return r;
  }
  throw new vu(
    "hints",
    e,
    'must be an array or string of format "</styles.css>; rel=preload; as=style"'
  );
}
var xc = {
  isInt32: Yse,
  isUint32: Xse,
  parseFileMode: Zse,
  validateArray: ig,
  validateStringArray: sae,
  validateBooleanArray: aae,
  validateAbortSignalArray: lae,
  validateBoolean: F7,
  validateBuffer: fae,
  validateDictionary: oae,
  validateEncoding: cae,
  validateFunction: hae,
  validateInt32: tae,
  validateInteger: eae,
  validateNumber: rae,
  validateObject: iae,
  validateOneOf: nae,
  validatePlainFunction: pae,
  validatePort: dae,
  validateSignalName: uae,
  validateString: jx,
  validateUint32: D7,
  validateUndefined: gae,
  validateUnion: bae,
  validateAbortSignal: j7,
  validateLinkHeaderValue: vae
}, Bx = { exports: {} };
const { SymbolAsyncIterator: Tk, SymbolIterator: $k, SymbolFor: Ya } = qt, B7 = Ya("nodejs.stream.destroyed"), q7 = Ya("nodejs.stream.errored"), ES = Ya("nodejs.stream.readable"), xS = Ya("nodejs.stream.writable"), W7 = Ya("nodejs.stream.disturbed"), mae = Ya("nodejs.webstream.isClosedPromise"), _ae = Ya("nodejs.webstream.controllerErrorFunction");
function og(e, t = !1) {
  var r;
  return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((r = e._readableState) === null || r === void 0 ? void 0 : r.readable) !== !1) && // Duplex
  (!e._writableState || e._readableState));
}
function sg(e) {
  var t;
  return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === void 0 ? void 0 : t.writable) !== !1));
}
function wae(e) {
  return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
}
function Bi(e) {
  return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
}
function U7(e) {
  return !!(e && !Bi(e) && typeof e.pipeThrough == "function" && typeof e.getReader == "function" && typeof e.cancel == "function");
}
function H7(e) {
  return !!(e && !Bi(e) && typeof e.getWriter == "function" && typeof e.abort == "function");
}
function V7(e) {
  return !!(e && !Bi(e) && typeof e.readable == "object" && typeof e.writable == "object");
}
function Sae(e) {
  return U7(e) || H7(e) || V7(e);
}
function Eae(e, t) {
  return e == null ? !1 : t === !0 ? typeof e[Tk] == "function" : t === !1 ? typeof e[$k] == "function" : typeof e[Tk] == "function" || typeof e[$k] == "function";
}
function ag(e) {
  if (!Bi(e))
    return null;
  const t = e._writableState, r = e._readableState, n = t || r;
  return !!(e.destroyed || e[B7] || n != null && n.destroyed);
}
function z7(e) {
  if (!sg(e))
    return null;
  if (e.writableEnded === !0)
    return !0;
  const t = e._writableState;
  return t != null && t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function xae(e, t) {
  if (!sg(e))
    return null;
  if (e.writableFinished === !0)
    return !0;
  const r = e._writableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.finished) != "boolean" ? null : !!(r.finished || t === !1 && r.ended === !0 && r.length === 0);
}
function Rae(e) {
  if (!og(e))
    return null;
  if (e.readableEnded === !0)
    return !0;
  const t = e._readableState;
  return !t || t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function G7(e, t) {
  if (!og(e))
    return null;
  const r = e._readableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.endEmitted) != "boolean" ? null : !!(r.endEmitted || t === !1 && r.ended === !0 && r.length === 0);
}
function K7(e) {
  return e && e[ES] != null ? e[ES] : typeof (e == null ? void 0 : e.readable) != "boolean" ? null : ag(e) ? !1 : og(e) && e.readable && !G7(e);
}
function Y7(e) {
  return e && e[xS] != null ? e[xS] : typeof (e == null ? void 0 : e.writable) != "boolean" ? null : ag(e) ? !1 : sg(e) && e.writable && !z7(e);
}
function Aae(e, t) {
  return Bi(e) ? ag(e) ? !0 : !((t == null ? void 0 : t.readable) !== !1 && K7(e) || (t == null ? void 0 : t.writable) !== !1 && Y7(e)) : null;
}
function Tae(e) {
  var t, r;
  return Bi(e) ? e.writableErrored ? e.writableErrored : (t = (r = e._writableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function $ae(e) {
  var t, r;
  return Bi(e) ? e.readableErrored ? e.readableErrored : (t = (r = e._readableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function Nae(e) {
  if (!Bi(e))
    return null;
  if (typeof e.closed == "boolean")
    return e.closed;
  const t = e._writableState, r = e._readableState;
  return typeof (t == null ? void 0 : t.closed) == "boolean" || typeof (r == null ? void 0 : r.closed) == "boolean" ? (t == null ? void 0 : t.closed) || (r == null ? void 0 : r.closed) : typeof e._closed == "boolean" && X7(e) ? e._closed : null;
}
function X7(e) {
  return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
}
function J7(e) {
  return typeof e._sent100 == "boolean" && X7(e);
}
function kae(e) {
  var t;
  return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === void 0 ? void 0 : t.upgradeOrConnect) === void 0;
}
function Cae(e) {
  if (!Bi(e))
    return null;
  const t = e._writableState, r = e._readableState, n = t || r;
  return !n && J7(e) || !!(n && n.autoDestroy && n.emitClose && n.closed === !1);
}
function Iae(e) {
  var t;
  return !!(e && ((t = e[W7]) !== null && t !== void 0 ? t : e.readableDidRead || e.readableAborted));
}
function Mae(e) {
  var t, r, n, o, s, a, l, u, f, c;
  return !!(e && ((t = (r = (n = (o = (s = (a = e[q7]) !== null && a !== void 0 ? a : e.readableErrored) !== null && s !== void 0 ? s : e.writableErrored) !== null && o !== void 0 ? o : (l = e._readableState) === null || l === void 0 ? void 0 : l.errorEmitted) !== null && n !== void 0 ? n : (u = e._writableState) === null || u === void 0 ? void 0 : u.errorEmitted) !== null && r !== void 0 ? r : (f = e._readableState) === null || f === void 0 ? void 0 : f.errored) !== null && t !== void 0 ? t : !((c = e._writableState) === null || c === void 0) && c.errored));
}
var To = {
  isDestroyed: ag,
  kIsDestroyed: B7,
  isDisturbed: Iae,
  kIsDisturbed: W7,
  isErrored: Mae,
  kIsErrored: q7,
  isReadable: K7,
  kIsReadable: ES,
  kIsClosedPromise: mae,
  kControllerErrorFunction: _ae,
  kIsWritable: xS,
  isClosed: Nae,
  isDuplexNodeStream: wae,
  isFinished: Aae,
  isIterable: Eae,
  isReadableNodeStream: og,
  isReadableStream: U7,
  isReadableEnded: Rae,
  isReadableFinished: G7,
  isReadableErrored: $ae,
  isNodeStream: Bi,
  isWebStream: Sae,
  isWritable: Y7,
  isWritableNodeStream: sg,
  isWritableStream: H7,
  isWritableEnded: z7,
  isWritableFinished: xae,
  isWritableErrored: Tae,
  isServerRequest: kae,
  isServerResponse: J7,
  willEmitClose: Cae,
  isTransformStream: V7
};
const qo = St, { AbortError: Q7, codes: Oae } = an, { ERR_INVALID_ARG_TYPE: Lae, ERR_STREAM_PREMATURE_CLOSE: Nk } = Oae, { kEmptyObject: RS, once: AS } = zr, { validateAbortSignal: Pae, validateFunction: Dae, validateObject: Fae, validateBoolean: jae } = xc, { Promise: Bae, PromisePrototypeThen: qae, SymbolDispose: Z7 } = qt, {
  isClosed: Wae,
  isReadable: kk,
  isReadableNodeStream: Wy,
  isReadableStream: Uae,
  isReadableFinished: Ck,
  isReadableErrored: Ik,
  isWritable: Mk,
  isWritableNodeStream: Ok,
  isWritableStream: Hae,
  isWritableFinished: Lk,
  isWritableErrored: Pk,
  isNodeStream: Vae,
  willEmitClose: zae,
  kIsClosedPromise: Gae
} = To;
let Pl;
function Kae(e) {
  return e.setHeader && typeof e.abort == "function";
}
const TS = () => {
};
function e8(e, t, r) {
  var n, o;
  if (arguments.length === 2 ? (r = t, t = RS) : t == null ? t = RS : Fae(t, "options"), Dae(r, "callback"), Pae(t.signal, "options.signal"), r = AS(r), Uae(e) || Hae(e))
    return Yae(e, t, r);
  if (!Vae(e))
    throw new Lae("stream", ["ReadableStream", "WritableStream", "Stream"], e);
  const s = (n = t.readable) !== null && n !== void 0 ? n : Wy(e), a = (o = t.writable) !== null && o !== void 0 ? o : Ok(e), l = e._writableState, u = e._readableState, f = () => {
    e.writable || h();
  };
  let c = zae(e) && Wy(e) === s && Ok(e) === a, d = Lk(e, !1);
  const h = () => {
    d = !0, e.destroyed && (c = !1), !(c && (!e.readable || s)) && (!s || p) && r.call(e);
  };
  let p = Ck(e, !1);
  const v = () => {
    p = !0, e.destroyed && (c = !1), !(c && (!e.writable || a)) && (!a || d) && r.call(e);
  }, y = (C) => {
    r.call(e, C);
  };
  let w = Wae(e);
  const S = () => {
    w = !0;
    const C = Pk(e) || Ik(e);
    if (C && typeof C != "boolean")
      return r.call(e, C);
    if (s && !p && Wy(e, !0) && !Ck(e, !1))
      return r.call(e, new Nk());
    if (a && !d && !Lk(e, !1))
      return r.call(e, new Nk());
    r.call(e);
  }, x = () => {
    w = !0;
    const C = Pk(e) || Ik(e);
    if (C && typeof C != "boolean")
      return r.call(e, C);
    r.call(e);
  }, E = () => {
    e.req.on("finish", h);
  };
  Kae(e) ? (e.on("complete", h), c || e.on("abort", S), e.req ? E() : e.on("request", E)) : a && !l && (e.on("end", f), e.on("close", f)), !c && typeof e.aborted == "boolean" && e.on("aborted", S), e.on("end", v), e.on("finish", h), t.error !== !1 && e.on("error", y), e.on("close", S), w ? qo.nextTick(S) : l != null && l.errorEmitted || u != null && u.errorEmitted ? c || qo.nextTick(x) : (!s && (!c || kk(e)) && (d || Mk(e) === !1) || !a && (!c || Mk(e)) && (p || kk(e) === !1) || u && e.req && e.aborted) && qo.nextTick(x);
  const N = () => {
    r = TS, e.removeListener("aborted", S), e.removeListener("complete", h), e.removeListener("abort", S), e.removeListener("request", E), e.req && e.req.removeListener("finish", h), e.removeListener("end", f), e.removeListener("close", f), e.removeListener("finish", h), e.removeListener("end", v), e.removeListener("error", y), e.removeListener("close", S);
  };
  if (t.signal && !w) {
    const C = () => {
      const j = r;
      N(), j.call(
        e,
        new Q7(void 0, {
          cause: t.signal.reason
        })
      );
    };
    if (t.signal.aborted)
      qo.nextTick(C);
    else {
      Pl = Pl || zr.addAbortListener;
      const j = Pl(t.signal, C), J = r;
      r = AS((...z) => {
        j[Z7](), J.apply(e, z);
      });
    }
  }
  return N;
}
function Yae(e, t, r) {
  let n = !1, o = TS;
  if (t.signal)
    if (o = () => {
      n = !0, r.call(
        e,
        new Q7(void 0, {
          cause: t.signal.reason
        })
      );
    }, t.signal.aborted)
      qo.nextTick(o);
    else {
      Pl = Pl || zr.addAbortListener;
      const a = Pl(t.signal, o), l = r;
      r = AS((...u) => {
        a[Z7](), l.apply(e, u);
      });
    }
  const s = (...a) => {
    n || qo.nextTick(() => r.apply(e, a));
  };
  return qae(e[Gae].promise, s, s), TS;
}
function Xae(e, t) {
  var r;
  let n = !1;
  return t === null && (t = RS), (r = t) !== null && r !== void 0 && r.cleanup && (jae(t.cleanup, "cleanup"), n = t.cleanup), new Bae((o, s) => {
    const a = e8(e, t, (l) => {
      n && a(), l ? s(l) : o();
    });
  });
}
Bx.exports = e8;
Bx.exports.finished = Xae;
var ws = Bx.exports;
const Si = St, {
  aggregateTwoErrors: Jae,
  codes: { ERR_MULTIPLE_CALLBACK: Qae },
  AbortError: Zae
} = an, { Symbol: t8 } = qt, { kIsDestroyed: ele, isDestroyed: tle, isFinished: rle, isServerRequest: nle } = To, r8 = t8("kDestroy"), $S = t8("kConstruct");
function n8(e, t, r) {
  e && (e.stack, t && !t.errored && (t.errored = e), r && !r.errored && (r.errored = e));
}
function ile(e, t) {
  const r = this._readableState, n = this._writableState, o = n || r;
  return n != null && n.destroyed || r != null && r.destroyed ? (typeof t == "function" && t(), this) : (n8(e, n, r), n && (n.destroyed = !0), r && (r.destroyed = !0), o.constructed ? Dk(this, e, t) : this.once(r8, function(s) {
    Dk(this, Jae(s, e), t);
  }), this);
}
function Dk(e, t, r) {
  let n = !1;
  function o(s) {
    if (n)
      return;
    n = !0;
    const a = e._readableState, l = e._writableState;
    n8(s, l, a), l && (l.closed = !0), a && (a.closed = !0), typeof r == "function" && r(s), s ? Si.nextTick(ole, e, s) : Si.nextTick(i8, e);
  }
  try {
    e._destroy(t || null, o);
  } catch (s) {
    o(s);
  }
}
function ole(e, t) {
  NS(e, t), i8(e);
}
function i8(e) {
  const t = e._readableState, r = e._writableState;
  r && (r.closeEmitted = !0), t && (t.closeEmitted = !0), (r != null && r.emitClose || t != null && t.emitClose) && e.emit("close");
}
function NS(e, t) {
  const r = e._readableState, n = e._writableState;
  n != null && n.errorEmitted || r != null && r.errorEmitted || (n && (n.errorEmitted = !0), r && (r.errorEmitted = !0), e.emit("error", t));
}
function sle() {
  const e = this._readableState, t = this._writableState;
  e && (e.constructed = !0, e.closed = !1, e.closeEmitted = !1, e.destroyed = !1, e.errored = null, e.errorEmitted = !1, e.reading = !1, e.ended = e.readable === !1, e.endEmitted = e.readable === !1), t && (t.constructed = !0, t.destroyed = !1, t.closed = !1, t.closeEmitted = !1, t.errored = null, t.errorEmitted = !1, t.finalCalled = !1, t.prefinished = !1, t.ended = t.writable === !1, t.ending = t.writable === !1, t.finished = t.writable === !1);
}
function kS(e, t, r) {
  const n = e._readableState, o = e._writableState;
  if (o != null && o.destroyed || n != null && n.destroyed)
    return this;
  n != null && n.autoDestroy || o != null && o.autoDestroy ? e.destroy(t) : t && (t.stack, o && !o.errored && (o.errored = t), n && !n.errored && (n.errored = t), r ? Si.nextTick(NS, e, t) : NS(e, t));
}
function ale(e, t) {
  if (typeof e._construct != "function")
    return;
  const r = e._readableState, n = e._writableState;
  r && (r.constructed = !1), n && (n.constructed = !1), e.once($S, t), !(e.listenerCount($S) > 1) && Si.nextTick(lle, e);
}
function lle(e) {
  let t = !1;
  function r(n) {
    if (t) {
      kS(e, n ?? new Qae());
      return;
    }
    t = !0;
    const o = e._readableState, s = e._writableState, a = s || o;
    o && (o.constructed = !0), s && (s.constructed = !0), a.destroyed ? e.emit(r8, n) : n ? kS(e, n, !0) : Si.nextTick(ule, e);
  }
  try {
    e._construct((n) => {
      Si.nextTick(r, n);
    });
  } catch (n) {
    Si.nextTick(r, n);
  }
}
function ule(e) {
  e.emit($S);
}
function Fk(e) {
  return (e == null ? void 0 : e.setHeader) && typeof e.abort == "function";
}
function o8(e) {
  e.emit("close");
}
function fle(e, t) {
  e.emit("error", t), Si.nextTick(o8, e);
}
function cle(e, t) {
  !e || tle(e) || (!t && !rle(e) && (t = new Zae()), nle(e) ? (e.socket = null, e.destroy(t)) : Fk(e) ? e.abort() : Fk(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? Si.nextTick(fle, e, t) : Si.nextTick(o8, e), e.destroyed || (e[ele] = !0));
}
var mu = {
  construct: ale,
  destroyer: cle,
  destroy: ile,
  undestroy: sle,
  errorOrDestroy: kS
};
const { ArrayIsArray: dle, ObjectSetPrototypeOf: s8 } = qt, { EventEmitter: lg } = ur;
function ug(e) {
  lg.call(this, e);
}
s8(ug.prototype, lg.prototype);
s8(ug, lg);
ug.prototype.pipe = function(e, t) {
  const r = this;
  function n(c) {
    e.writable && e.write(c) === !1 && r.pause && r.pause();
  }
  r.on("data", n);
  function o() {
    r.readable && r.resume && r.resume();
  }
  e.on("drain", o), !e._isStdio && (!t || t.end !== !1) && (r.on("end", a), r.on("close", l));
  let s = !1;
  function a() {
    s || (s = !0, e.end());
  }
  function l() {
    s || (s = !0, typeof e.destroy == "function" && e.destroy());
  }
  function u(c) {
    f(), lg.listenerCount(this, "error") === 0 && this.emit("error", c);
  }
  CS(r, "error", u), CS(e, "error", u);
  function f() {
    r.removeListener("data", n), e.removeListener("drain", o), r.removeListener("end", a), r.removeListener("close", l), r.removeListener("error", u), e.removeListener("error", u), r.removeListener("end", f), r.removeListener("close", f), e.removeListener("close", f);
  }
  return r.on("end", f), r.on("close", f), e.on("close", f), e.emit("pipe", r), e;
};
function CS(e, t, r) {
  if (typeof e.prependListener == "function")
    return e.prependListener(t, r);
  !e._events || !e._events[t] ? e.on(t, r) : dle(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
}
var qx = {
  Stream: ug,
  prependListener: CS
}, a8 = { exports: {} };
(function(e) {
  const { SymbolDispose: t } = qt, { AbortError: r, codes: n } = an, { isNodeStream: o, isWebStream: s, kControllerErrorFunction: a } = To, l = ws, { ERR_INVALID_ARG_TYPE: u } = n;
  let f;
  const c = (d, h) => {
    if (typeof d != "object" || !("aborted" in d))
      throw new u(h, "AbortSignal", d);
  };
  e.exports.addAbortSignal = function(h, p) {
    if (c(h, "signal"), !o(p) && !s(p))
      throw new u("stream", ["ReadableStream", "WritableStream", "Stream"], p);
    return e.exports.addAbortSignalNoValidate(h, p);
  }, e.exports.addAbortSignalNoValidate = function(d, h) {
    if (typeof d != "object" || !("aborted" in d))
      return h;
    const p = o(h) ? () => {
      h.destroy(
        new r(void 0, {
          cause: d.reason
        })
      );
    } : () => {
      h[a](
        new r(void 0, {
          cause: d.reason
        })
      );
    };
    if (d.aborted)
      p();
    else {
      f = f || zr.addAbortListener;
      const v = f(d, p);
      l(h, v[t]);
    }
    return h;
  };
})(a8);
var fg = a8.exports;
const { StringPrototypeSlice: jk, SymbolIterator: hle, TypedArrayPrototypeSet: pd, Uint8Array: ple } = qt, { Buffer: Uy } = ft, { inspect: gle } = zr;
var ble = class {
  constructor() {
    this.head = null, this.tail = null, this.length = 0;
  }
  push(t) {
    const r = {
      data: t,
      next: null
    };
    this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
  }
  unshift(t) {
    const r = {
      data: t,
      next: this.head
    };
    this.length === 0 && (this.tail = r), this.head = r, ++this.length;
  }
  shift() {
    if (this.length === 0)
      return;
    const t = this.head.data;
    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
  }
  clear() {
    this.head = this.tail = null, this.length = 0;
  }
  join(t) {
    if (this.length === 0)
      return "";
    let r = this.head, n = "" + r.data;
    for (; (r = r.next) !== null; )
      n += t + r.data;
    return n;
  }
  concat(t) {
    if (this.length === 0)
      return Uy.alloc(0);
    const r = Uy.allocUnsafe(t >>> 0);
    let n = this.head, o = 0;
    for (; n; )
      pd(r, n.data, o), o += n.data.length, n = n.next;
    return r;
  }
  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(t, r) {
    const n = this.head.data;
    if (t < n.length) {
      const o = n.slice(0, t);
      return this.head.data = n.slice(t), o;
    }
    return t === n.length ? this.shift() : r ? this._getString(t) : this._getBuffer(t);
  }
  first() {
    return this.head.data;
  }
  *[hle]() {
    for (let t = this.head; t; t = t.next)
      yield t.data;
  }
  // Consumes a specified amount of characters from the buffered data.
  _getString(t) {
    let r = "", n = this.head, o = 0;
    do {
      const s = n.data;
      if (t > s.length)
        r += s, t -= s.length;
      else {
        t === s.length ? (r += s, ++o, n.next ? this.head = n.next : this.head = this.tail = null) : (r += jk(s, 0, t), this.head = n, n.data = jk(s, t));
        break;
      }
      ++o;
    } while ((n = n.next) !== null);
    return this.length -= o, r;
  }
  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(t) {
    const r = Uy.allocUnsafe(t), n = t;
    let o = this.head, s = 0;
    do {
      const a = o.data;
      if (t > a.length)
        pd(r, a, n - t), t -= a.length;
      else {
        t === a.length ? (pd(r, a, n - t), ++s, o.next ? this.head = o.next : this.head = this.tail = null) : (pd(r, new ple(a.buffer, a.byteOffset, t), n - t), this.head = o, o.data = a.slice(t));
        break;
      }
      ++s;
    } while ((o = o.next) !== null);
    return this.length -= s, r;
  }
  // Make sure the linked list only shows the minimal necessary information.
  [Symbol.for("nodejs.util.inspect.custom")](t, r) {
    return gle(this, {
      ...r,
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: !1
    });
  }
};
const { MathFloor: yle, NumberIsInteger: vle } = qt, { validateInteger: mle } = xc, { ERR_INVALID_ARG_VALUE: _le } = an.codes;
let l8 = 16 * 1024, u8 = 16;
function wle(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function f8(e) {
  return e ? u8 : l8;
}
function Sle(e, t) {
  mle(t, "value", 0), e ? u8 = t : l8 = t;
}
function Ele(e, t, r, n) {
  const o = wle(t, n, r);
  if (o != null) {
    if (!vle(o) || o < 0) {
      const s = n ? `options.${r}` : "options.highWaterMark";
      throw new _le(s, o);
    }
    return yle(o);
  }
  return f8(e.objectMode);
}
var cg = {
  getHighWaterMark: Ele,
  getDefaultHighWaterMark: f8,
  setDefaultHighWaterMark: Sle
};
const Bk = St, { PromisePrototypeThen: xle, SymbolAsyncIterator: qk, SymbolIterator: Wk } = qt, { Buffer: Rle } = ft, { ERR_INVALID_ARG_TYPE: Ale, ERR_STREAM_NULL_VALUES: Tle } = an.codes;
function $le(e, t, r) {
  let n;
  if (typeof t == "string" || t instanceof Rle)
    return new e({
      objectMode: !0,
      ...r,
      read() {
        this.push(t), this.push(null);
      }
    });
  let o;
  if (t && t[qk])
    o = !0, n = t[qk]();
  else if (t && t[Wk])
    o = !1, n = t[Wk]();
  else
    throw new Ale("iterable", ["Iterable"], t);
  const s = new e({
    objectMode: !0,
    highWaterMark: 1,
    // TODO(ronag): What options should be allowed?
    ...r
  });
  let a = !1;
  s._read = function() {
    a || (a = !0, u());
  }, s._destroy = function(f, c) {
    xle(
      l(f),
      () => Bk.nextTick(c, f),
      // nextTick is here in case cb throws
      (d) => Bk.nextTick(c, d || f)
    );
  };
  async function l(f) {
    const c = f != null, d = typeof n.throw == "function";
    if (c && d) {
      const { value: h, done: p } = await n.throw(f);
      if (await h, p)
        return;
    }
    if (typeof n.return == "function") {
      const { value: h } = await n.return();
      await h;
    }
  }
  async function u() {
    for (; ; ) {
      try {
        const { value: f, done: c } = o ? await n.next() : n.next();
        if (c)
          s.push(null);
        else {
          const d = f && typeof f.then == "function" ? await f : f;
          if (d === null)
            throw a = !1, new Tle();
          if (s.push(d))
            continue;
          a = !1;
        }
      } catch (f) {
        s.destroy(f);
      }
      break;
    }
  }
  return s;
}
var c8 = $le, Hy, Uk;
function dg() {
  if (Uk)
    return Hy;
  Uk = 1;
  const e = St, {
    ArrayPrototypeIndexOf: t,
    NumberIsInteger: r,
    NumberIsNaN: n,
    NumberParseInt: o,
    ObjectDefineProperties: s,
    ObjectKeys: a,
    ObjectSetPrototypeOf: l,
    Promise: u,
    SafeSet: f,
    SymbolAsyncDispose: c,
    SymbolAsyncIterator: d,
    Symbol: h
  } = qt;
  Hy = B, B.ReadableState = ve;
  const { EventEmitter: p } = ur, { Stream: v, prependListener: y } = qx, { Buffer: w } = ft, { addAbortSignal: S } = fg, x = ws;
  let E = zr.debuglog("stream", (g) => {
    E = g;
  });
  const N = ble, C = mu, { getHighWaterMark: j, getDefaultHighWaterMark: J } = cg, {
    aggregateTwoErrors: z,
    codes: {
      ERR_INVALID_ARG_TYPE: $,
      ERR_METHOD_NOT_IMPLEMENTED: G,
      ERR_OUT_OF_RANGE: I,
      ERR_STREAM_PUSH_AFTER_EOF: W,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT: k
    },
    AbortError: U
  } = an, { validateObject: Z } = xc, Y = h("kPaused"), { StringDecoder: re } = Vl(), ae = c8;
  l(B.prototype, v.prototype), l(B, v);
  const ce = () => {
  }, { errorOrDestroy: pe } = C, le = 1, ye = 2, H = 4, ge = 8, Ce = 16, ue = 32, ee = 64, be = 128, Te = 256, Pe = 512, K = 1024, V = 2048, b = 4096, _ = 8192, T = 16384, L = 32768, O = 65536, ie = 1 << 17, fe = 1 << 18;
  function se(g) {
    return {
      enumerable: !1,
      get() {
        return (this.state & g) !== 0;
      },
      set(m) {
        m ? this.state |= g : this.state &= ~g;
      }
    };
  }
  s(ve.prototype, {
    objectMode: se(le),
    ended: se(ye),
    endEmitted: se(H),
    reading: se(ge),
    // Stream is still being constructed and cannot be
    // destroyed until construction finished or failed.
    // Async construction is opt in, therefore we start as
    // constructed.
    constructed: se(Ce),
    // A flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    sync: se(ue),
    // Whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    needReadable: se(ee),
    emittedReadable: se(be),
    readableListening: se(Te),
    resumeScheduled: se(Pe),
    // True if the error was already emitted and should not be thrown again.
    errorEmitted: se(K),
    emitClose: se(V),
    autoDestroy: se(b),
    // Has it been destroyed.
    destroyed: se(_),
    // Indicates whether the stream has finished destroying.
    closed: se(T),
    // True if close has been emitted or would have been emitted
    // depending on emitClose.
    closeEmitted: se(L),
    multiAwaitDrain: se(O),
    // If true, a maybeReadMore has been scheduled.
    readingMore: se(ie),
    dataEmitted: se(fe)
  });
  function ve(g, m, F) {
    typeof F != "boolean" && (F = m instanceof ho()), this.state = V | b | Ce | ue, g && g.objectMode && (this.state |= le), F && g && g.readableObjectMode && (this.state |= le), this.highWaterMark = g ? j(this, g, "readableHighWaterMark", F) : J(!1), this.buffer = new N(), this.length = 0, this.pipes = [], this.flowing = null, this[Y] = null, g && g.emitClose === !1 && (this.state &= ~V), g && g.autoDestroy === !1 && (this.state &= ~b), this.errored = null, this.defaultEncoding = g && g.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, g && g.encoding && (this.decoder = new re(g.encoding), this.encoding = g.encoding);
  }
  function B(g) {
    if (!(this instanceof B))
      return new B(g);
    const m = this instanceof ho();
    this._readableState = new ve(g, this, m), g && (typeof g.read == "function" && (this._read = g.read), typeof g.destroy == "function" && (this._destroy = g.destroy), typeof g.construct == "function" && (this._construct = g.construct), g.signal && !m && S(g.signal, this)), v.call(this, g), C.construct(this, () => {
      this._readableState.needReadable && ne(this, this._readableState);
    });
  }
  B.prototype.destroy = C.destroy, B.prototype._undestroy = C.undestroy, B.prototype._destroy = function(g, m) {
    m(g);
  }, B.prototype[p.captureRejectionSymbol] = function(g) {
    this.destroy(g);
  }, B.prototype[c] = function() {
    let g;
    return this.destroyed || (g = this.readableEnded ? null : new U(), this.destroy(g)), new u((m, F) => x(this, (D) => D && D !== g ? F(D) : m(null)));
  }, B.prototype.push = function(g, m) {
    return me(this, g, m, !1);
  }, B.prototype.unshift = function(g, m) {
    return me(this, g, m, !0);
  };
  function me(g, m, F, D) {
    E("readableAddChunk", m);
    const X = g._readableState;
    let Le;
    if (X.state & le || (typeof m == "string" ? (F = F || X.defaultEncoding, X.encoding !== F && (D && X.encoding ? m = w.from(m, F).toString(X.encoding) : (m = w.from(m, F), F = ""))) : m instanceof w ? F = "" : v._isUint8Array(m) ? (m = v._uint8ArrayToBuffer(m), F = "") : m != null && (Le = new $("chunk", ["string", "Buffer", "Uint8Array"], m))), Le)
      pe(g, Le);
    else if (m === null)
      X.state &= ~ge, R(g, X);
    else if (X.state & le || m && m.length > 0)
      if (D)
        if (X.state & H)
          pe(g, new k());
        else {
          if (X.destroyed || X.errored)
            return !1;
          ke(g, X, m, !0);
        }
      else if (X.ended)
        pe(g, new W());
      else {
        if (X.destroyed || X.errored)
          return !1;
        X.state &= ~ge, X.decoder && !F ? (m = X.decoder.write(m), X.objectMode || m.length !== 0 ? ke(g, X, m, !1) : ne(g, X)) : ke(g, X, m, !1);
      }
    else
      D || (X.state &= ~ge, ne(g, X));
    return !X.ended && (X.length < X.highWaterMark || X.length === 0);
  }
  function ke(g, m, F, D) {
    m.flowing && m.length === 0 && !m.sync && g.listenerCount("data") > 0 ? (m.state & O ? m.awaitDrainWriters.clear() : m.awaitDrainWriters = null, m.dataEmitted = !0, g.emit("data", F)) : (m.length += m.objectMode ? 1 : F.length, D ? m.buffer.unshift(F) : m.buffer.push(F), m.state & ee && A(g)), ne(g, m);
  }
  B.prototype.isPaused = function() {
    const g = this._readableState;
    return g[Y] === !0 || g.flowing === !1;
  }, B.prototype.setEncoding = function(g) {
    const m = new re(g);
    this._readableState.decoder = m, this._readableState.encoding = this._readableState.decoder.encoding;
    const F = this._readableState.buffer;
    let D = "";
    for (const X of F)
      D += m.write(X);
    return F.clear(), D !== "" && F.push(D), this._readableState.length = D.length, this;
  };
  const Ie = 1073741824;
  function Me(g) {
    if (g > Ie)
      throw new I("size", "<= 1GiB", g);
    return g--, g |= g >>> 1, g |= g >>> 2, g |= g >>> 4, g |= g >>> 8, g |= g >>> 16, g++, g;
  }
  function M(g, m) {
    return g <= 0 || m.length === 0 && m.ended ? 0 : m.state & le ? 1 : n(g) ? m.flowing && m.length ? m.buffer.first().length : m.length : g <= m.length ? g : m.ended ? m.length : 0;
  }
  B.prototype.read = function(g) {
    E("read", g), g === void 0 ? g = NaN : r(g) || (g = o(g, 10));
    const m = this._readableState, F = g;
    if (g > m.highWaterMark && (m.highWaterMark = Me(g)), g !== 0 && (m.state &= ~be), g === 0 && m.needReadable && ((m.highWaterMark !== 0 ? m.length >= m.highWaterMark : m.length > 0) || m.ended))
      return E("read: emitReadable", m.length, m.ended), m.length === 0 && m.ended ? Tt(this) : A(this), null;
    if (g = M(g, m), g === 0 && m.ended)
      return m.length === 0 && Tt(this), null;
    let D = (m.state & ee) !== 0;
    if (E("need readable", D), (m.length === 0 || m.length - g < m.highWaterMark) && (D = !0, E("length less than watermark", D)), m.ended || m.reading || m.destroyed || m.errored || !m.constructed)
      D = !1, E("reading, ended or constructing", D);
    else if (D) {
      E("do read"), m.state |= ge | ue, m.length === 0 && (m.state |= ee);
      try {
        this._read(m.highWaterMark);
      } catch (Le) {
        pe(this, Le);
      }
      m.state &= ~ue, m.reading || (g = M(F, m));
    }
    let X;
    return g > 0 ? X = Lr(g, m) : X = null, X === null ? (m.needReadable = m.length <= m.highWaterMark, g = 0) : (m.length -= g, m.multiAwaitDrain ? m.awaitDrainWriters.clear() : m.awaitDrainWriters = null), m.length === 0 && (m.ended || (m.needReadable = !0), F !== g && m.ended && Tt(this)), X !== null && !m.errorEmitted && !m.closeEmitted && (m.dataEmitted = !0, this.emit("data", X)), X;
  };
  function R(g, m) {
    if (E("onEofChunk"), !m.ended) {
      if (m.decoder) {
        const F = m.decoder.end();
        F && F.length && (m.buffer.push(F), m.length += m.objectMode ? 1 : F.length);
      }
      m.ended = !0, m.sync ? A(g) : (m.needReadable = !1, m.emittedReadable = !0, q(g));
    }
  }
  function A(g) {
    const m = g._readableState;
    E("emitReadable", m.needReadable, m.emittedReadable), m.needReadable = !1, m.emittedReadable || (E("emitReadable", m.flowing), m.emittedReadable = !0, e.nextTick(q, g));
  }
  function q(g) {
    const m = g._readableState;
    E("emitReadable_", m.destroyed, m.length, m.ended), !m.destroyed && !m.errored && (m.length || m.ended) && (g.emit("readable"), m.emittedReadable = !1), m.needReadable = !m.flowing && !m.ended && m.length <= m.highWaterMark, et(g);
  }
  function ne(g, m) {
    !m.readingMore && m.constructed && (m.readingMore = !0, e.nextTick(de, g, m));
  }
  function de(g, m) {
    for (; !m.reading && !m.ended && (m.length < m.highWaterMark || m.flowing && m.length === 0); ) {
      const F = m.length;
      if (E("maybeReadMore read 0"), g.read(0), F === m.length)
        break;
    }
    m.readingMore = !1;
  }
  B.prototype._read = function(g) {
    throw new G("_read()");
  }, B.prototype.pipe = function(g, m) {
    const F = this, D = this._readableState;
    D.pipes.length === 1 && (D.multiAwaitDrain || (D.multiAwaitDrain = !0, D.awaitDrainWriters = new f(D.awaitDrainWriters ? [D.awaitDrainWriters] : []))), D.pipes.push(g), E("pipe count=%d opts=%j", D.pipes.length, m);
    const Le = (!m || m.end !== !1) && g !== e.stdout && g !== e.stderr ? Xt : Et;
    D.endEmitted ? e.nextTick(Le) : F.once("end", Le), g.on("unpipe", Ue);
    function Ue(ct, nt) {
      E("onunpipe"), ct === F && nt && nt.hasUnpiped === !1 && (nt.hasUnpiped = !0, yn());
    }
    function Xt() {
      E("onend"), g.end();
    }
    let ht, Kr = !1;
    function yn() {
      E("cleanup"), g.removeListener("close", or), g.removeListener("finish", dr), ht && g.removeListener("drain", ht), g.removeListener("error", cr), g.removeListener("unpipe", Ue), F.removeListener("end", Xt), F.removeListener("end", Et), F.removeListener("data", Ar), Kr = !0, ht && D.awaitDrainWriters && (!g._writableState || g._writableState.needDrain) && ht();
    }
    function Wt() {
      Kr || (D.pipes.length === 1 && D.pipes[0] === g ? (E("false write response, pause", 0), D.awaitDrainWriters = g, D.multiAwaitDrain = !1) : D.pipes.length > 1 && D.pipes.includes(g) && (E("false write response, pause", D.awaitDrainWriters.size), D.awaitDrainWriters.add(g)), F.pause()), ht || (ht = he(F, g), g.on("drain", ht));
    }
    F.on("data", Ar);
    function Ar(ct) {
      E("ondata");
      const nt = g.write(ct);
      E("dest.write", nt), nt === !1 && Wt();
    }
    function cr(ct) {
      if (E("onerror", ct), Et(), g.removeListener("error", cr), g.listenerCount("error") === 0) {
        const nt = g._writableState || g._readableState;
        nt && !nt.errorEmitted ? pe(g, ct) : g.emit("error", ct);
      }
    }
    y(g, "error", cr);
    function or() {
      g.removeListener("finish", dr), Et();
    }
    g.once("close", or);
    function dr() {
      E("onfinish"), g.removeListener("close", or), Et();
    }
    g.once("finish", dr);
    function Et() {
      E("unpipe"), F.unpipe(g);
    }
    return g.emit("pipe", F), g.writableNeedDrain === !0 ? Wt() : D.flowing || (E("pipe resume"), F.resume()), g;
  };
  function he(g, m) {
    return function() {
      const D = g._readableState;
      D.awaitDrainWriters === m ? (E("pipeOnDrain", 1), D.awaitDrainWriters = null) : D.multiAwaitDrain && (E("pipeOnDrain", D.awaitDrainWriters.size), D.awaitDrainWriters.delete(m)), (!D.awaitDrainWriters || D.awaitDrainWriters.size === 0) && g.listenerCount("data") && g.resume();
    };
  }
  B.prototype.unpipe = function(g) {
    const m = this._readableState, F = {
      hasUnpiped: !1
    };
    if (m.pipes.length === 0)
      return this;
    if (!g) {
      const X = m.pipes;
      m.pipes = [], this.pause();
      for (let Le = 0; Le < X.length; Le++)
        X[Le].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    const D = t(m.pipes, g);
    return D === -1 ? this : (m.pipes.splice(D, 1), m.pipes.length === 0 && this.pause(), g.emit("unpipe", this, F), this);
  }, B.prototype.on = function(g, m) {
    const F = v.prototype.on.call(this, g, m), D = this._readableState;
    return g === "data" ? (D.readableListening = this.listenerCount("readable") > 0, D.flowing !== !1 && this.resume()) : g === "readable" && !D.endEmitted && !D.readableListening && (D.readableListening = D.needReadable = !0, D.flowing = !1, D.emittedReadable = !1, E("on readable", D.length, D.reading), D.length ? A(this) : D.reading || e.nextTick(ot, this)), F;
  }, B.prototype.addListener = B.prototype.on, B.prototype.removeListener = function(g, m) {
    const F = v.prototype.removeListener.call(this, g, m);
    return g === "readable" && e.nextTick(Fe, this), F;
  }, B.prototype.off = B.prototype.removeListener, B.prototype.removeAllListeners = function(g) {
    const m = v.prototype.removeAllListeners.apply(this, arguments);
    return (g === "readable" || g === void 0) && e.nextTick(Fe, this), m;
  };
  function Fe(g) {
    const m = g._readableState;
    m.readableListening = g.listenerCount("readable") > 0, m.resumeScheduled && m[Y] === !1 ? m.flowing = !0 : g.listenerCount("data") > 0 ? g.resume() : m.readableListening || (m.flowing = null);
  }
  function ot(g) {
    E("readable nexttick read 0"), g.read(0);
  }
  B.prototype.resume = function() {
    const g = this._readableState;
    return g.flowing || (E("resume"), g.flowing = !g.readableListening, ze(this, g)), g[Y] = !1, this;
  };
  function ze(g, m) {
    m.resumeScheduled || (m.resumeScheduled = !0, e.nextTick(Ke, g, m));
  }
  function Ke(g, m) {
    E("resume", m.reading), m.reading || g.read(0), m.resumeScheduled = !1, g.emit("resume"), et(g), m.flowing && !m.reading && g.read(0);
  }
  B.prototype.pause = function() {
    return E("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (E("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState[Y] = !0, this;
  };
  function et(g) {
    const m = g._readableState;
    for (E("flow", m.flowing); m.flowing && g.read() !== null; )
      ;
  }
  B.prototype.wrap = function(g) {
    let m = !1;
    g.on("data", (D) => {
      !this.push(D) && g.pause && (m = !0, g.pause());
    }), g.on("end", () => {
      this.push(null);
    }), g.on("error", (D) => {
      pe(this, D);
    }), g.on("close", () => {
      this.destroy();
    }), g.on("destroy", () => {
      this.destroy();
    }), this._read = () => {
      m && g.resume && (m = !1, g.resume());
    };
    const F = a(g);
    for (let D = 1; D < F.length; D++) {
      const X = F[D];
      this[X] === void 0 && typeof g[X] == "function" && (this[X] = g[X].bind(g));
    }
    return this;
  }, B.prototype[d] = function() {
    return Rr(this);
  }, B.prototype.iterator = function(g) {
    return g !== void 0 && Z(g, "options"), Rr(this, g);
  };
  function Rr(g, m) {
    typeof g.read != "function" && (g = B.wrap(g, {
      objectMode: !0
    }));
    const F = Wi(g, m);
    return F.stream = g, F;
  }
  async function* Wi(g, m) {
    let F = ce;
    function D(Ue) {
      this === g ? (F(), F = ce) : F = Ue;
    }
    g.on("readable", D);
    let X;
    const Le = x(
      g,
      {
        writable: !1
      },
      (Ue) => {
        X = Ue ? z(X, Ue) : null, F(), F = ce;
      }
    );
    try {
      for (; ; ) {
        const Ue = g.destroyed ? null : g.read();
        if (Ue !== null)
          yield Ue;
        else {
          if (X)
            throw X;
          if (X === null)
            return;
          await new u(D);
        }
      }
    } catch (Ue) {
      throw X = z(X, Ue), X;
    } finally {
      (X || (m == null ? void 0 : m.destroyOnReturn) !== !1) && (X === void 0 || g._readableState.autoDestroy) ? C.destroyer(g, null) : (g.off("readable", D), Le());
    }
  }
  s(B.prototype, {
    readable: {
      __proto__: null,
      get() {
        const g = this._readableState;
        return !!g && g.readable !== !1 && !g.destroyed && !g.errorEmitted && !g.endEmitted;
      },
      set(g) {
        this._readableState && (this._readableState.readable = !!g);
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(g) {
        this._readableState && (this._readableState.flowing = g);
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.objectMode : !1;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.destroyed : !1;
      },
      set(g) {
        this._readableState && (this._readableState.destroyed = g);
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.endEmitted : !1;
      }
    }
  }), s(ve.prototype, {
    // Legacy getter for `pipesCount`.
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    // Legacy property for `paused`.
    paused: {
      __proto__: null,
      get() {
        return this[Y] !== !1;
      },
      set(g) {
        this[Y] = !!g;
      }
    }
  }), B._fromList = Lr;
  function Lr(g, m) {
    if (m.length === 0)
      return null;
    let F;
    return m.objectMode ? F = m.buffer.shift() : !g || g >= m.length ? (m.decoder ? F = m.buffer.join("") : m.buffer.length === 1 ? F = m.buffer.first() : F = m.buffer.concat(m.length), m.buffer.clear()) : F = m.buffer.consume(g, m.decoder), F;
  }
  function Tt(g) {
    const m = g._readableState;
    E("endReadable", m.endEmitted), m.endEmitted || (m.ended = !0, e.nextTick(si, m, g));
  }
  function si(g, m) {
    if (E("endReadableNT", g.endEmitted, g.length), !g.errored && !g.closeEmitted && !g.endEmitted && g.length === 0) {
      if (g.endEmitted = !0, m.emit("end"), m.writable && m.allowHalfOpen === !1)
        e.nextTick(Ui, m);
      else if (g.autoDestroy) {
        const F = m._writableState;
        (!F || F.autoDestroy && // We don't expect the writable to ever 'finish'
        // if writable is explicitly set to false.
        (F.finished || F.writable === !1)) && m.destroy();
      }
    }
  }
  function Ui(g) {
    g.writable && !g.writableEnded && !g.destroyed && g.end();
  }
  B.from = function(g, m) {
    return ae(B, g, m);
  };
  let Mt;
  function ln() {
    return Mt === void 0 && (Mt = {}), Mt;
  }
  return B.fromWeb = function(g, m) {
    return ln().newStreamReadableFromReadableStream(g, m);
  }, B.toWeb = function(g, m) {
    return ln().newReadableStreamFromStreamReadable(g, m);
  }, B.wrap = function(g, m) {
    var F, D;
    return new B({
      objectMode: (F = (D = g.readableObjectMode) !== null && D !== void 0 ? D : g.objectMode) !== null && F !== void 0 ? F : !0,
      ...m,
      destroy(X, Le) {
        C.destroyer(g, X), Le(X);
      }
    }).wrap(g);
  }, Hy;
}
var Vy, Hk;
function Wx() {
  if (Hk)
    return Vy;
  Hk = 1;
  const e = St, {
    ArrayPrototypeSlice: t,
    Error: r,
    FunctionPrototypeSymbolHasInstance: n,
    ObjectDefineProperty: o,
    ObjectDefineProperties: s,
    ObjectSetPrototypeOf: a,
    StringPrototypeToLowerCase: l,
    Symbol: u,
    SymbolHasInstance: f
  } = qt;
  Vy = Z, Z.WritableState = k;
  const { EventEmitter: c } = ur, d = qx.Stream, { Buffer: h } = ft, p = mu, { addAbortSignal: v } = fg, { getHighWaterMark: y, getDefaultHighWaterMark: w } = cg, {
    ERR_INVALID_ARG_TYPE: S,
    ERR_METHOD_NOT_IMPLEMENTED: x,
    ERR_MULTIPLE_CALLBACK: E,
    ERR_STREAM_CANNOT_PIPE: N,
    ERR_STREAM_DESTROYED: C,
    ERR_STREAM_ALREADY_FINISHED: j,
    ERR_STREAM_NULL_VALUES: J,
    ERR_STREAM_WRITE_AFTER_END: z,
    ERR_UNKNOWN_ENCODING: $
  } = an.codes, { errorOrDestroy: G } = p;
  a(Z.prototype, d.prototype), a(Z, d);
  function I() {
  }
  const W = u("kOnFinished");
  function k(b, _, T) {
    typeof T != "boolean" && (T = _ instanceof ho()), this.objectMode = !!(b && b.objectMode), T && (this.objectMode = this.objectMode || !!(b && b.writableObjectMode)), this.highWaterMark = b ? y(this, b, "writableHighWaterMark", T) : w(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    const L = !!(b && b.decodeStrings === !1);
    this.decodeStrings = !L, this.defaultEncoding = b && b.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = pe.bind(void 0, _), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, U(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !b || b.emitClose !== !1, this.autoDestroy = !b || b.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[W] = [];
  }
  function U(b) {
    b.buffered = [], b.bufferedIndex = 0, b.allBuffers = !0, b.allNoop = !0;
  }
  k.prototype.getBuffer = function() {
    return t(this.buffered, this.bufferedIndex);
  }, o(k.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function Z(b) {
    const _ = this instanceof ho();
    if (!_ && !n(Z, this))
      return new Z(b);
    this._writableState = new k(b, this, _), b && (typeof b.write == "function" && (this._write = b.write), typeof b.writev == "function" && (this._writev = b.writev), typeof b.destroy == "function" && (this._destroy = b.destroy), typeof b.final == "function" && (this._final = b.final), typeof b.construct == "function" && (this._construct = b.construct), b.signal && v(b.signal, this)), d.call(this, b), p.construct(this, () => {
      const T = this._writableState;
      T.writing || ge(this, T), be(this, T);
    });
  }
  o(Z, f, {
    __proto__: null,
    value: function(b) {
      return n(this, b) ? !0 : this !== Z ? !1 : b && b._writableState instanceof k;
    }
  }), Z.prototype.pipe = function() {
    G(this, new N());
  };
  function Y(b, _, T, L) {
    const O = b._writableState;
    if (typeof T == "function")
      L = T, T = O.defaultEncoding;
    else {
      if (!T)
        T = O.defaultEncoding;
      else if (T !== "buffer" && !h.isEncoding(T))
        throw new $(T);
      typeof L != "function" && (L = I);
    }
    if (_ === null)
      throw new J();
    if (!O.objectMode)
      if (typeof _ == "string")
        O.decodeStrings !== !1 && (_ = h.from(_, T), T = "buffer");
      else if (_ instanceof h)
        T = "buffer";
      else if (d._isUint8Array(_))
        _ = d._uint8ArrayToBuffer(_), T = "buffer";
      else
        throw new S("chunk", ["string", "Buffer", "Uint8Array"], _);
    let ie;
    return O.ending ? ie = new z() : O.destroyed && (ie = new C("write")), ie ? (e.nextTick(L, ie), G(b, ie, !0), ie) : (O.pendingcb++, re(b, O, _, T, L));
  }
  Z.prototype.write = function(b, _, T) {
    return Y(this, b, _, T) === !0;
  }, Z.prototype.cork = function() {
    this._writableState.corked++;
  }, Z.prototype.uncork = function() {
    const b = this._writableState;
    b.corked && (b.corked--, b.writing || ge(this, b));
  }, Z.prototype.setDefaultEncoding = function(_) {
    if (typeof _ == "string" && (_ = l(_)), !h.isEncoding(_))
      throw new $(_);
    return this._writableState.defaultEncoding = _, this;
  };
  function re(b, _, T, L, O) {
    const ie = _.objectMode ? 1 : T.length;
    _.length += ie;
    const fe = _.length < _.highWaterMark;
    return fe || (_.needDrain = !0), _.writing || _.corked || _.errored || !_.constructed ? (_.buffered.push({
      chunk: T,
      encoding: L,
      callback: O
    }), _.allBuffers && L !== "buffer" && (_.allBuffers = !1), _.allNoop && O !== I && (_.allNoop = !1)) : (_.writelen = ie, _.writecb = O, _.writing = !0, _.sync = !0, b._write(T, L, _.onwrite), _.sync = !1), fe && !_.errored && !_.destroyed;
  }
  function ae(b, _, T, L, O, ie, fe) {
    _.writelen = L, _.writecb = fe, _.writing = !0, _.sync = !0, _.destroyed ? _.onwrite(new C("write")) : T ? b._writev(O, _.onwrite) : b._write(O, ie, _.onwrite), _.sync = !1;
  }
  function ce(b, _, T, L) {
    --_.pendingcb, L(T), H(_), G(b, T);
  }
  function pe(b, _) {
    const T = b._writableState, L = T.sync, O = T.writecb;
    if (typeof O != "function") {
      G(b, new E());
      return;
    }
    T.writing = !1, T.writecb = null, T.length -= T.writelen, T.writelen = 0, _ ? (_.stack, T.errored || (T.errored = _), b._readableState && !b._readableState.errored && (b._readableState.errored = _), L ? e.nextTick(ce, b, T, _, O) : ce(b, T, _, O)) : (T.buffered.length > T.bufferedIndex && ge(b, T), L ? T.afterWriteTickInfo !== null && T.afterWriteTickInfo.cb === O ? T.afterWriteTickInfo.count++ : (T.afterWriteTickInfo = {
      count: 1,
      cb: O,
      stream: b,
      state: T
    }, e.nextTick(le, T.afterWriteTickInfo)) : ye(b, T, 1, O));
  }
  function le({ stream: b, state: _, count: T, cb: L }) {
    return _.afterWriteTickInfo = null, ye(b, _, T, L);
  }
  function ye(b, _, T, L) {
    for (!_.ending && !b.destroyed && _.length === 0 && _.needDrain && (_.needDrain = !1, b.emit("drain")); T-- > 0; )
      _.pendingcb--, L();
    _.destroyed && H(_), be(b, _);
  }
  function H(b) {
    if (b.writing)
      return;
    for (let O = b.bufferedIndex; O < b.buffered.length; ++O) {
      var _;
      const { chunk: ie, callback: fe } = b.buffered[O], se = b.objectMode ? 1 : ie.length;
      b.length -= se, fe(
        (_ = b.errored) !== null && _ !== void 0 ? _ : new C("write")
      );
    }
    const T = b[W].splice(0);
    for (let O = 0; O < T.length; O++) {
      var L;
      T[O](
        (L = b.errored) !== null && L !== void 0 ? L : new C("end")
      );
    }
    U(b);
  }
  function ge(b, _) {
    if (_.corked || _.bufferProcessing || _.destroyed || !_.constructed)
      return;
    const { buffered: T, bufferedIndex: L, objectMode: O } = _, ie = T.length - L;
    if (!ie)
      return;
    let fe = L;
    if (_.bufferProcessing = !0, ie > 1 && b._writev) {
      _.pendingcb -= ie - 1;
      const se = _.allNoop ? I : (B) => {
        for (let me = fe; me < T.length; ++me)
          T[me].callback(B);
      }, ve = _.allNoop && fe === 0 ? T : t(T, fe);
      ve.allBuffers = _.allBuffers, ae(b, _, !0, _.length, ve, "", se), U(_);
    } else {
      do {
        const { chunk: se, encoding: ve, callback: B } = T[fe];
        T[fe++] = null;
        const me = O ? 1 : se.length;
        ae(b, _, !1, me, se, ve, B);
      } while (fe < T.length && !_.writing);
      fe === T.length ? U(_) : fe > 256 ? (T.splice(0, fe), _.bufferedIndex = 0) : _.bufferedIndex = fe;
    }
    _.bufferProcessing = !1;
  }
  Z.prototype._write = function(b, _, T) {
    if (this._writev)
      this._writev(
        [
          {
            chunk: b,
            encoding: _
          }
        ],
        T
      );
    else
      throw new x("_write()");
  }, Z.prototype._writev = null, Z.prototype.end = function(b, _, T) {
    const L = this._writableState;
    typeof b == "function" ? (T = b, b = null, _ = null) : typeof _ == "function" && (T = _, _ = null);
    let O;
    if (b != null) {
      const ie = Y(this, b, _);
      ie instanceof r && (O = ie);
    }
    return L.corked && (L.corked = 1, this.uncork()), O || (!L.errored && !L.ending ? (L.ending = !0, be(this, L, !0), L.ended = !0) : L.finished ? O = new j("end") : L.destroyed && (O = new C("end"))), typeof T == "function" && (O || L.finished ? e.nextTick(T, O) : L[W].push(T)), this;
  };
  function Ce(b) {
    return b.ending && !b.destroyed && b.constructed && b.length === 0 && !b.errored && b.buffered.length === 0 && !b.finished && !b.writing && !b.errorEmitted && !b.closeEmitted;
  }
  function ue(b, _) {
    let T = !1;
    function L(O) {
      if (T) {
        G(b, O ?? E());
        return;
      }
      if (T = !0, _.pendingcb--, O) {
        const ie = _[W].splice(0);
        for (let fe = 0; fe < ie.length; fe++)
          ie[fe](O);
        G(b, O, _.sync);
      } else
        Ce(_) && (_.prefinished = !0, b.emit("prefinish"), _.pendingcb++, e.nextTick(Te, b, _));
    }
    _.sync = !0, _.pendingcb++;
    try {
      b._final(L);
    } catch (O) {
      L(O);
    }
    _.sync = !1;
  }
  function ee(b, _) {
    !_.prefinished && !_.finalCalled && (typeof b._final == "function" && !_.destroyed ? (_.finalCalled = !0, ue(b, _)) : (_.prefinished = !0, b.emit("prefinish")));
  }
  function be(b, _, T) {
    Ce(_) && (ee(b, _), _.pendingcb === 0 && (T ? (_.pendingcb++, e.nextTick(
      (L, O) => {
        Ce(O) ? Te(L, O) : O.pendingcb--;
      },
      b,
      _
    )) : Ce(_) && (_.pendingcb++, Te(b, _))));
  }
  function Te(b, _) {
    _.pendingcb--, _.finished = !0;
    const T = _[W].splice(0);
    for (let L = 0; L < T.length; L++)
      T[L]();
    if (b.emit("finish"), _.autoDestroy) {
      const L = b._readableState;
      (!L || L.autoDestroy && // We don't expect the readable to ever 'end'
      // if readable is explicitly set to false.
      (L.endEmitted || L.readable === !1)) && b.destroy();
    }
  }
  s(Z.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : !1;
      },
      set(b) {
        this._writableState && (this._writableState.destroyed = b);
      }
    },
    writable: {
      __proto__: null,
      get() {
        const b = this._writableState;
        return !!b && b.writable !== !1 && !b.destroyed && !b.errored && !b.ending && !b.ended;
      },
      set(b) {
        this._writableState && (this._writableState.writable = !!b);
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : !1;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : !1;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : !1;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const b = this._writableState;
        return b ? !b.destroyed && !b.ending && b.needDrain : !1;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  const Pe = p.destroy;
  Z.prototype.destroy = function(b, _) {
    const T = this._writableState;
    return !T.destroyed && (T.bufferedIndex < T.buffered.length || T[W].length) && e.nextTick(H, T), Pe.call(this, b, _), this;
  }, Z.prototype._undestroy = p.undestroy, Z.prototype._destroy = function(b, _) {
    _(b);
  }, Z.prototype[c.captureRejectionSymbol] = function(b) {
    this.destroy(b);
  };
  let K;
  function V() {
    return K === void 0 && (K = {}), K;
  }
  return Z.fromWeb = function(b, _) {
    return V().newStreamWritableFromWritableStream(b, _);
  }, Z.toWeb = function(b) {
    return V().newWritableStreamFromStreamWritable(b);
  }, Vy;
}
var zy, Vk;
function Nle() {
  if (Vk)
    return zy;
  Vk = 1;
  const e = St, t = ft, {
    isReadable: r,
    isWritable: n,
    isIterable: o,
    isNodeStream: s,
    isReadableNodeStream: a,
    isWritableNodeStream: l,
    isDuplexNodeStream: u,
    isReadableStream: f,
    isWritableStream: c
  } = To, d = ws, {
    AbortError: h,
    codes: { ERR_INVALID_ARG_TYPE: p, ERR_INVALID_RETURN_VALUE: v }
  } = an, { destroyer: y } = mu, w = ho(), S = dg(), x = Wx(), { createDeferredPromise: E } = zr, N = c8, C = globalThis.Blob || t.Blob, j = typeof C < "u" ? function(k) {
    return k instanceof C;
  } : function(k) {
    return !1;
  }, J = globalThis.AbortController || Kt().AbortController, { FunctionPrototypeCall: z } = qt;
  class $ extends w {
    constructor(k) {
      super(k), (k == null ? void 0 : k.readable) === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), (k == null ? void 0 : k.writable) === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0);
    }
  }
  zy = function W(k, U) {
    if (u(k))
      return k;
    if (a(k))
      return I({
        readable: k
      });
    if (l(k))
      return I({
        writable: k
      });
    if (s(k))
      return I({
        writable: !1,
        readable: !1
      });
    if (f(k))
      return I({
        readable: S.fromWeb(k)
      });
    if (c(k))
      return I({
        writable: x.fromWeb(k)
      });
    if (typeof k == "function") {
      const { value: Y, write: re, final: ae, destroy: ce } = G(k);
      if (o(Y))
        return N($, Y, {
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          write: re,
          final: ae,
          destroy: ce
        });
      const pe = Y == null ? void 0 : Y.then;
      if (typeof pe == "function") {
        let le;
        const ye = z(
          pe,
          Y,
          (H) => {
            if (H != null)
              throw new v("nully", "body", H);
          },
          (H) => {
            y(le, H);
          }
        );
        return le = new $({
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          readable: !1,
          write: re,
          final(H) {
            ae(async () => {
              try {
                await ye, e.nextTick(H, null);
              } catch (ge) {
                e.nextTick(H, ge);
              }
            });
          },
          destroy: ce
        });
      }
      throw new v("Iterable, AsyncIterable or AsyncFunction", U, Y);
    }
    if (j(k))
      return W(k.arrayBuffer());
    if (o(k))
      return N($, k, {
        // TODO (ronag): highWaterMark?
        objectMode: !0,
        writable: !1
      });
    if (f(k == null ? void 0 : k.readable) && c(k == null ? void 0 : k.writable))
      return $.fromWeb(k);
    if (typeof (k == null ? void 0 : k.writable) == "object" || typeof (k == null ? void 0 : k.readable) == "object") {
      const Y = k != null && k.readable ? a(k == null ? void 0 : k.readable) ? k == null ? void 0 : k.readable : W(k.readable) : void 0, re = k != null && k.writable ? l(k == null ? void 0 : k.writable) ? k == null ? void 0 : k.writable : W(k.writable) : void 0;
      return I({
        readable: Y,
        writable: re
      });
    }
    const Z = k == null ? void 0 : k.then;
    if (typeof Z == "function") {
      let Y;
      return z(
        Z,
        k,
        (re) => {
          re != null && Y.push(re), Y.push(null);
        },
        (re) => {
          y(Y, re);
        }
      ), Y = new $({
        objectMode: !0,
        writable: !1,
        read() {
        }
      });
    }
    throw new p(
      U,
      [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise"
      ],
      k
    );
  };
  function G(W) {
    let { promise: k, resolve: U } = E();
    const Z = new J(), Y = Z.signal;
    return {
      value: W(
        async function* () {
          for (; ; ) {
            const ae = k;
            k = null;
            const { chunk: ce, done: pe, cb: le } = await ae;
            if (e.nextTick(le), pe)
              return;
            if (Y.aborted)
              throw new h(void 0, {
                cause: Y.reason
              });
            ({ promise: k, resolve: U } = E()), yield ce;
          }
        }(),
        {
          signal: Y
        }
      ),
      write(ae, ce, pe) {
        const le = U;
        U = null, le({
          chunk: ae,
          done: !1,
          cb: pe
        });
      },
      final(ae) {
        const ce = U;
        U = null, ce({
          done: !0,
          cb: ae
        });
      },
      destroy(ae, ce) {
        Z.abort(), ce(ae);
      }
    };
  }
  function I(W) {
    const k = W.readable && typeof W.readable.read != "function" ? S.wrap(W.readable) : W.readable, U = W.writable;
    let Z = !!r(k), Y = !!n(U), re, ae, ce, pe, le;
    function ye(H) {
      const ge = pe;
      pe = null, ge ? ge(H) : H && le.destroy(H);
    }
    return le = new $({
      // TODO (ronag): highWaterMark?
      readableObjectMode: !!(k != null && k.readableObjectMode),
      writableObjectMode: !!(U != null && U.writableObjectMode),
      readable: Z,
      writable: Y
    }), Y && (d(U, (H) => {
      Y = !1, H && y(k, H), ye(H);
    }), le._write = function(H, ge, Ce) {
      U.write(H, ge) ? Ce() : re = Ce;
    }, le._final = function(H) {
      U.end(), ae = H;
    }, U.on("drain", function() {
      if (re) {
        const H = re;
        re = null, H();
      }
    }), U.on("finish", function() {
      if (ae) {
        const H = ae;
        ae = null, H();
      }
    })), Z && (d(k, (H) => {
      Z = !1, H && y(k, H), ye(H);
    }), k.on("readable", function() {
      if (ce) {
        const H = ce;
        ce = null, H();
      }
    }), k.on("end", function() {
      le.push(null);
    }), le._read = function() {
      for (; ; ) {
        const H = k.read();
        if (H === null) {
          ce = le._read;
          return;
        }
        if (!le.push(H))
          return;
      }
    }), le._destroy = function(H, ge) {
      !H && pe !== null && (H = new h()), ce = null, re = null, ae = null, pe === null ? ge(H) : (pe = ge, y(U, H), y(k, H));
    }, le;
  }
  return zy;
}
var Gy, zk;
function ho() {
  if (zk)
    return Gy;
  zk = 1;
  const {
    ObjectDefineProperties: e,
    ObjectGetOwnPropertyDescriptor: t,
    ObjectKeys: r,
    ObjectSetPrototypeOf: n
  } = qt;
  Gy = a;
  const o = dg(), s = Wx();
  n(a.prototype, o.prototype), n(a, o);
  {
    const c = r(s.prototype);
    for (let d = 0; d < c.length; d++) {
      const h = c[d];
      a.prototype[h] || (a.prototype[h] = s.prototype[h]);
    }
  }
  function a(c) {
    if (!(this instanceof a))
      return new a(c);
    o.call(this, c), s.call(this, c), c ? (this.allowHalfOpen = c.allowHalfOpen !== !1, c.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), c.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0)) : this.allowHalfOpen = !0;
  }
  e(a.prototype, {
    writable: {
      __proto__: null,
      ...t(s.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...t(s.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...t(s.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...t(s.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...t(s.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...t(s.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...t(s.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...t(s.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...t(s.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
      },
      set(c) {
        this._readableState && this._writableState && (this._readableState.destroyed = c, this._writableState.destroyed = c);
      }
    }
  });
  let l;
  function u() {
    return l === void 0 && (l = {}), l;
  }
  a.fromWeb = function(c, d) {
    return u().newStreamDuplexFromReadableWritablePair(c, d);
  }, a.toWeb = function(c) {
    return u().newReadableWritablePairFromDuplex(c);
  };
  let f;
  return a.from = function(c) {
    return f || (f = Nle()), f(c, "body");
  }, Gy;
}
const { ObjectSetPrototypeOf: d8, Symbol: kle } = qt;
var h8 = po;
const { ERR_METHOD_NOT_IMPLEMENTED: Cle } = an.codes, Ux = ho(), { getHighWaterMark: Ile } = cg;
d8(po.prototype, Ux.prototype);
d8(po, Ux);
const Rf = kle("kCallback");
function po(e) {
  if (!(this instanceof po))
    return new po(e);
  const t = e ? Ile(this, e, "readableHighWaterMark", !0) : null;
  t === 0 && (e = {
    ...e,
    highWaterMark: null,
    readableHighWaterMark: t,
    // TODO (ronag): 0 is not optimal since we have
    // a "bug" where we check needDrain before calling _write and not after.
    // Refs: https://github.com/nodejs/node/pull/32887
    // Refs: https://github.com/nodejs/node/pull/35941
    writableHighWaterMark: e.writableHighWaterMark || 0
  }), Ux.call(this, e), this._readableState.sync = !1, this[Rf] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", Mle);
}
function IS(e) {
  typeof this._flush == "function" && !this.destroyed ? this._flush((t, r) => {
    if (t) {
      e ? e(t) : this.destroy(t);
      return;
    }
    r != null && this.push(r), this.push(null), e && e();
  }) : (this.push(null), e && e());
}
function Mle() {
  this._final !== IS && IS.call(this);
}
po.prototype._final = IS;
po.prototype._transform = function(e, t, r) {
  throw new Cle("_transform()");
};
po.prototype._write = function(e, t, r) {
  const n = this._readableState, o = this._writableState, s = n.length;
  this._transform(e, t, (a, l) => {
    if (a) {
      r(a);
      return;
    }
    l != null && this.push(l), o.ended || // Backwards compat.
    s === n.length || // Backwards compat.
    n.length < n.highWaterMark ? r() : this[Rf] = r;
  });
};
po.prototype._read = function() {
  if (this[Rf]) {
    const e = this[Rf];
    this[Rf] = null, e();
  }
};
const { ObjectSetPrototypeOf: p8 } = qt;
var g8 = Yl;
const Hx = h8;
p8(Yl.prototype, Hx.prototype);
p8(Yl, Hx);
function Yl(e) {
  if (!(this instanceof Yl))
    return new Yl(e);
  Hx.call(this, e);
}
Yl.prototype._transform = function(e, t, r) {
  r(null, e);
};
const Qu = St, { ArrayIsArray: Ole, Promise: Lle, SymbolAsyncIterator: Ple, SymbolDispose: Dle } = qt, Th = ws, { once: Fle } = zr, jle = mu, Gk = ho(), {
  aggregateTwoErrors: Ble,
  codes: {
    ERR_INVALID_ARG_TYPE: MS,
    ERR_INVALID_RETURN_VALUE: Ky,
    ERR_MISSING_ARGS: qle,
    ERR_STREAM_DESTROYED: Wle,
    ERR_STREAM_PREMATURE_CLOSE: Ule
  },
  AbortError: Hle
} = an, { validateFunction: Vle, validateAbortSignal: zle } = xc, {
  isIterable: Us,
  isReadable: Yy,
  isReadableNodeStream: Vd,
  isNodeStream: Kk,
  isTransformStream: ml,
  isWebStream: Gle,
  isReadableStream: Xy,
  isReadableFinished: Kle
} = To, Yle = globalThis.AbortController || Kt().AbortController;
let Jy, Qy, Zy;
function Yk(e, t, r) {
  let n = !1;
  e.on("close", () => {
    n = !0;
  });
  const o = Th(
    e,
    {
      readable: t,
      writable: r
    },
    (s) => {
      n = !s;
    }
  );
  return {
    destroy: (s) => {
      n || (n = !0, jle.destroyer(e, s || new Wle("pipe")));
    },
    cleanup: o
  };
}
function Xle(e) {
  return Vle(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
}
function e0(e) {
  if (Us(e))
    return e;
  if (Vd(e))
    return Jle(e);
  throw new MS("val", ["Readable", "Iterable", "AsyncIterable"], e);
}
async function* Jle(e) {
  Qy || (Qy = dg()), yield* Qy.prototype[Ple].call(e);
}
async function gd(e, t, r, { end: n }) {
  let o, s = null;
  const a = (f) => {
    if (f && (o = f), s) {
      const c = s;
      s = null, c();
    }
  }, l = () => new Lle((f, c) => {
    o ? c(o) : s = () => {
      o ? c(o) : f();
    };
  });
  t.on("drain", a);
  const u = Th(
    t,
    {
      readable: !1
    },
    a
  );
  try {
    t.writableNeedDrain && await l();
    for await (const f of e)
      t.write(f) || await l();
    n && (t.end(), await l()), r();
  } catch (f) {
    r(o !== f ? Ble(o, f) : f);
  } finally {
    u(), t.off("drain", a);
  }
}
async function t0(e, t, r, { end: n }) {
  ml(t) && (t = t.writable);
  const o = t.getWriter();
  try {
    for await (const s of e)
      await o.ready, o.write(s).catch(() => {
      });
    await o.ready, n && await o.close(), r();
  } catch (s) {
    try {
      await o.abort(s), r(s);
    } catch (a) {
      r(a);
    }
  }
}
function Qle(...e) {
  return b8(e, Fle(Xle(e)));
}
function b8(e, t, r) {
  if (e.length === 1 && Ole(e[0]) && (e = e[0]), e.length < 2)
    throw new qle("streams");
  const n = new Yle(), o = n.signal, s = r == null ? void 0 : r.signal, a = [];
  zle(s, "options.signal");
  function l() {
    v(new Hle());
  }
  Zy = Zy || zr.addAbortListener;
  let u;
  s && (u = Zy(s, l));
  let f, c;
  const d = [];
  let h = 0;
  function p(x) {
    v(x, --h === 0);
  }
  function v(x, E) {
    var N;
    if (x && (!f || f.code === "ERR_STREAM_PREMATURE_CLOSE") && (f = x), !(!f && !E)) {
      for (; d.length; )
        d.shift()(f);
      (N = u) === null || N === void 0 || N[Dle](), n.abort(), E && (f || a.forEach((C) => C()), Qu.nextTick(t, f, c));
    }
  }
  let y;
  for (let x = 0; x < e.length; x++) {
    const E = e[x], N = x < e.length - 1, C = x > 0, j = N || (r == null ? void 0 : r.end) !== !1, J = x === e.length - 1;
    if (Kk(E)) {
      let z = function($) {
        $ && $.name !== "AbortError" && $.code !== "ERR_STREAM_PREMATURE_CLOSE" && p($);
      };
      if (j) {
        const { destroy: $, cleanup: G } = Yk(E, N, C);
        d.push($), Yy(E) && J && a.push(G);
      }
      E.on("error", z), Yy(E) && J && a.push(() => {
        E.removeListener("error", z);
      });
    }
    if (x === 0)
      if (typeof E == "function") {
        if (y = E({
          signal: o
        }), !Us(y))
          throw new Ky("Iterable, AsyncIterable or Stream", "source", y);
      } else
        Us(E) || Vd(E) || ml(E) ? y = E : y = Gk.from(E);
    else if (typeof E == "function") {
      if (ml(y)) {
        var w;
        y = e0((w = y) === null || w === void 0 ? void 0 : w.readable);
      } else
        y = e0(y);
      if (y = E(y, {
        signal: o
      }), N) {
        if (!Us(y, !0))
          throw new Ky("AsyncIterable", `transform[${x - 1}]`, y);
      } else {
        var S;
        Jy || (Jy = g8);
        const z = new Jy({
          objectMode: !0
        }), $ = (S = y) === null || S === void 0 ? void 0 : S.then;
        if (typeof $ == "function")
          h++, $.call(
            y,
            (W) => {
              c = W, W != null && z.write(W), j && z.end(), Qu.nextTick(p);
            },
            (W) => {
              z.destroy(W), Qu.nextTick(p, W);
            }
          );
        else if (Us(y, !0))
          h++, gd(y, z, p, {
            end: j
          });
        else if (Xy(y) || ml(y)) {
          const W = y.readable || y;
          h++, gd(W, z, p, {
            end: j
          });
        } else
          throw new Ky("AsyncIterable or Promise", "destination", y);
        y = z;
        const { destroy: G, cleanup: I } = Yk(y, !1, !0);
        d.push(G), J && a.push(I);
      }
    } else if (Kk(E)) {
      if (Vd(y)) {
        h += 2;
        const z = Zle(y, E, p, {
          end: j
        });
        Yy(E) && J && a.push(z);
      } else if (ml(y) || Xy(y)) {
        const z = y.readable || y;
        h++, gd(z, E, p, {
          end: j
        });
      } else if (Us(y))
        h++, gd(y, E, p, {
          end: j
        });
      else
        throw new MS(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          y
        );
      y = E;
    } else if (Gle(E)) {
      if (Vd(y))
        h++, t0(e0(y), E, p, {
          end: j
        });
      else if (Xy(y) || Us(y))
        h++, t0(y, E, p, {
          end: j
        });
      else if (ml(y))
        h++, t0(y.readable, E, p, {
          end: j
        });
      else
        throw new MS(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          y
        );
      y = E;
    } else
      y = Gk.from(E);
  }
  return (o != null && o.aborted || s != null && s.aborted) && Qu.nextTick(l), y;
}
function Zle(e, t, r, { end: n }) {
  let o = !1;
  if (t.on("close", () => {
    o || r(new Ule());
  }), e.pipe(t, {
    end: !1
  }), n) {
    let s = function() {
      o = !0, t.end();
    };
    Kle(e) ? Qu.nextTick(s) : e.once("end", s);
  } else
    r();
  return Th(
    e,
    {
      readable: !0,
      writable: !1
    },
    (s) => {
      const a = e._readableState;
      s && s.code === "ERR_STREAM_PREMATURE_CLOSE" && a && a.ended && !a.errored && !a.errorEmitted ? e.once("end", r).once("error", r) : r(s);
    }
  ), Th(
    t,
    {
      readable: !1,
      writable: !0
    },
    r
  );
}
var Vx = {
  pipelineImpl: b8,
  pipeline: Qle
};
const { pipeline: eue } = Vx, bd = ho(), { destroyer: tue } = mu, {
  isNodeStream: yd,
  isReadable: Xk,
  isWritable: Jk,
  isWebStream: r0,
  isTransformStream: Ls,
  isWritableStream: Qk,
  isReadableStream: Zk
} = To, {
  AbortError: rue,
  codes: { ERR_INVALID_ARG_VALUE: eC, ERR_MISSING_ARGS: nue }
} = an, iue = ws;
var y8 = function(...t) {
  if (t.length === 0)
    throw new nue("streams");
  if (t.length === 1)
    return bd.from(t[0]);
  const r = [...t];
  if (typeof t[0] == "function" && (t[0] = bd.from(t[0])), typeof t[t.length - 1] == "function") {
    const p = t.length - 1;
    t[p] = bd.from(t[p]);
  }
  for (let p = 0; p < t.length; ++p)
    if (!(!yd(t[p]) && !r0(t[p]))) {
      if (p < t.length - 1 && !(Xk(t[p]) || Zk(t[p]) || Ls(t[p])))
        throw new eC(`streams[${p}]`, r[p], "must be readable");
      if (p > 0 && !(Jk(t[p]) || Qk(t[p]) || Ls(t[p])))
        throw new eC(`streams[${p}]`, r[p], "must be writable");
    }
  let n, o, s, a, l;
  function u(p) {
    const v = a;
    a = null, v ? v(p) : p ? l.destroy(p) : !h && !d && l.destroy();
  }
  const f = t[0], c = eue(t, u), d = !!(Jk(f) || Qk(f) || Ls(f)), h = !!(Xk(c) || Zk(c) || Ls(c));
  if (l = new bd({
    // TODO (ronag): highWaterMark?
    writableObjectMode: !!(f != null && f.writableObjectMode),
    readableObjectMode: !!(c != null && c.readableObjectMode),
    writable: d,
    readable: h
  }), d) {
    if (yd(f))
      l._write = function(v, y, w) {
        f.write(v, y) ? w() : n = w;
      }, l._final = function(v) {
        f.end(), o = v;
      }, f.on("drain", function() {
        if (n) {
          const v = n;
          n = null, v();
        }
      });
    else if (r0(f)) {
      const y = (Ls(f) ? f.writable : f).getWriter();
      l._write = async function(w, S, x) {
        try {
          await y.ready, y.write(w).catch(() => {
          }), x();
        } catch (E) {
          x(E);
        }
      }, l._final = async function(w) {
        try {
          await y.ready, y.close().catch(() => {
          }), o = w;
        } catch (S) {
          w(S);
        }
      };
    }
    const p = Ls(c) ? c.readable : c;
    iue(p, () => {
      if (o) {
        const v = o;
        o = null, v();
      }
    });
  }
  if (h) {
    if (yd(c))
      c.on("readable", function() {
        if (s) {
          const p = s;
          s = null, p();
        }
      }), c.on("end", function() {
        l.push(null);
      }), l._read = function() {
        for (; ; ) {
          const p = c.read();
          if (p === null) {
            s = l._read;
            return;
          }
          if (!l.push(p))
            return;
        }
      };
    else if (r0(c)) {
      const v = (Ls(c) ? c.readable : c).getReader();
      l._read = async function() {
        for (; ; )
          try {
            const { value: y, done: w } = await v.read();
            if (!l.push(y))
              return;
            if (w) {
              l.push(null);
              return;
            }
          } catch {
            return;
          }
      };
    }
  }
  return l._destroy = function(p, v) {
    !p && a !== null && (p = new rue()), s = null, n = null, o = null, a === null ? v(p) : (a = v, yd(c) && tue(c, p));
  }, l;
};
const oue = globalThis.AbortController || Kt().AbortController, {
  codes: { ERR_INVALID_ARG_VALUE: sue, ERR_INVALID_ARG_TYPE: Rc, ERR_MISSING_ARGS: aue, ERR_OUT_OF_RANGE: lue },
  AbortError: ki
} = an, { validateAbortSignal: Xa, validateInteger: tC, validateObject: Ja } = xc, uue = qt.Symbol("kWeak"), fue = qt.Symbol("kResistStopPropagation"), { finished: cue } = ws, due = y8, { addAbortSignalNoValidate: hue } = fg, { isWritable: pue, isNodeStream: gue } = To, { deprecate: bue } = zr, {
  ArrayPrototypePush: yue,
  Boolean: vue,
  MathFloor: rC,
  Number: mue,
  NumberIsNaN: _ue,
  Promise: nC,
  PromiseReject: iC,
  PromiseResolve: wue,
  PromisePrototypeThen: oC,
  Symbol: v8
} = qt, $h = v8("kEmpty"), sC = v8("kEof");
function Sue(e, t) {
  if (t != null && Ja(t, "options"), (t == null ? void 0 : t.signal) != null && Xa(t.signal, "options.signal"), gue(e) && !pue(e))
    throw new sue("stream", e, "must be writable");
  const r = due(this, e);
  return t != null && t.signal && hue(t.signal, r), r;
}
function hg(e, t) {
  if (typeof e != "function")
    throw new Rc("fn", ["Function", "AsyncFunction"], e);
  t != null && Ja(t, "options"), (t == null ? void 0 : t.signal) != null && Xa(t.signal, "options.signal");
  let r = 1;
  (t == null ? void 0 : t.concurrency) != null && (r = rC(t.concurrency));
  let n = r - 1;
  return (t == null ? void 0 : t.highWaterMark) != null && (n = rC(t.highWaterMark)), tC(r, "options.concurrency", 1), tC(n, "options.highWaterMark", 0), n += r, (async function* () {
    const s = zr.AbortSignalAny(
      [t == null ? void 0 : t.signal].filter(vue)
    ), a = this, l = [], u = {
      signal: s
    };
    let f, c, d = !1, h = 0;
    function p() {
      d = !0, v();
    }
    function v() {
      h -= 1, y();
    }
    function y() {
      c && !d && h < r && l.length < n && (c(), c = null);
    }
    async function w() {
      try {
        for await (let S of a) {
          if (d)
            return;
          if (s.aborted)
            throw new ki();
          try {
            if (S = e(S, u), S === $h)
              continue;
            S = wue(S);
          } catch (x) {
            S = iC(x);
          }
          h += 1, oC(S, v, p), l.push(S), f && (f(), f = null), !d && (l.length >= n || h >= r) && await new nC((x) => {
            c = x;
          });
        }
        l.push(sC);
      } catch (S) {
        const x = iC(S);
        oC(x, v, p), l.push(x);
      } finally {
        d = !0, f && (f(), f = null);
      }
    }
    w();
    try {
      for (; ; ) {
        for (; l.length > 0; ) {
          const S = await l[0];
          if (S === sC)
            return;
          if (s.aborted)
            throw new ki();
          S !== $h && (yield S), l.shift(), y();
        }
        await new nC((S) => {
          f = S;
        });
      }
    } finally {
      d = !0, c && (c(), c = null);
    }
  }).call(this);
}
function Eue(e = void 0) {
  return e != null && Ja(e, "options"), (e == null ? void 0 : e.signal) != null && Xa(e.signal, "options.signal"), (async function* () {
    let r = 0;
    for await (const o of this) {
      var n;
      if (e != null && (n = e.signal) !== null && n !== void 0 && n.aborted)
        throw new ki({
          cause: e.signal.reason
        });
      yield [r++, o];
    }
  }).call(this);
}
async function m8(e, t = void 0) {
  for await (const r of zx.call(this, e, t))
    return !0;
  return !1;
}
async function xue(e, t = void 0) {
  if (typeof e != "function")
    throw new Rc("fn", ["Function", "AsyncFunction"], e);
  return !await m8.call(
    this,
    async (...r) => !await e(...r),
    t
  );
}
async function Rue(e, t) {
  for await (const r of zx.call(this, e, t))
    return r;
}
async function Aue(e, t) {
  if (typeof e != "function")
    throw new Rc("fn", ["Function", "AsyncFunction"], e);
  async function r(n, o) {
    return await e(n, o), $h;
  }
  for await (const n of hg.call(this, r, t))
    ;
}
function zx(e, t) {
  if (typeof e != "function")
    throw new Rc("fn", ["Function", "AsyncFunction"], e);
  async function r(n, o) {
    return await e(n, o) ? n : $h;
  }
  return hg.call(this, r, t);
}
class Tue extends aue {
  constructor() {
    super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
  }
}
async function $ue(e, t, r) {
  var n;
  if (typeof e != "function")
    throw new Rc("reducer", ["Function", "AsyncFunction"], e);
  r != null && Ja(r, "options"), (r == null ? void 0 : r.signal) != null && Xa(r.signal, "options.signal");
  let o = arguments.length > 1;
  if (r != null && (n = r.signal) !== null && n !== void 0 && n.aborted) {
    const f = new ki(void 0, {
      cause: r.signal.reason
    });
    throw this.once("error", () => {
    }), await cue(this.destroy(f)), f;
  }
  const s = new oue(), a = s.signal;
  if (r != null && r.signal) {
    const f = {
      once: !0,
      [uue]: this,
      [fue]: !0
    };
    r.signal.addEventListener("abort", () => s.abort(), f);
  }
  let l = !1;
  try {
    for await (const f of this) {
      var u;
      if (l = !0, r != null && (u = r.signal) !== null && u !== void 0 && u.aborted)
        throw new ki();
      o ? t = await e(t, f, {
        signal: a
      }) : (t = f, o = !0);
    }
    if (!l && !o)
      throw new Tue();
  } finally {
    s.abort();
  }
  return t;
}
async function Nue(e) {
  e != null && Ja(e, "options"), (e == null ? void 0 : e.signal) != null && Xa(e.signal, "options.signal");
  const t = [];
  for await (const n of this) {
    var r;
    if (e != null && (r = e.signal) !== null && r !== void 0 && r.aborted)
      throw new ki(void 0, {
        cause: e.signal.reason
      });
    yue(t, n);
  }
  return t;
}
function kue(e, t) {
  const r = hg.call(this, e, t);
  return (async function* () {
    for await (const o of r)
      yield* o;
  }).call(this);
}
function _8(e) {
  if (e = mue(e), _ue(e))
    return 0;
  if (e < 0)
    throw new lue("number", ">= 0", e);
  return e;
}
function Cue(e, t = void 0) {
  return t != null && Ja(t, "options"), (t == null ? void 0 : t.signal) != null && Xa(t.signal, "options.signal"), e = _8(e), (async function* () {
    var n;
    if (t != null && (n = t.signal) !== null && n !== void 0 && n.aborted)
      throw new ki();
    for await (const s of this) {
      var o;
      if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
        throw new ki();
      e-- <= 0 && (yield s);
    }
  }).call(this);
}
function Iue(e, t = void 0) {
  return t != null && Ja(t, "options"), (t == null ? void 0 : t.signal) != null && Xa(t.signal, "options.signal"), e = _8(e), (async function* () {
    var n;
    if (t != null && (n = t.signal) !== null && n !== void 0 && n.aborted)
      throw new ki();
    for await (const s of this) {
      var o;
      if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
        throw new ki();
      if (e-- > 0 && (yield s), e <= 0)
        return;
    }
  }).call(this);
}
Px.streamReturningOperators = {
  asIndexedPairs: bue(Eue, "readable.asIndexedPairs will be removed in a future version."),
  drop: Cue,
  filter: zx,
  flatMap: kue,
  map: hg,
  take: Iue,
  compose: Sue
};
Px.promiseReturningOperators = {
  every: xue,
  forEach: Aue,
  reduce: $ue,
  toArray: Nue,
  some: m8,
  find: Rue
};
var n0, aC;
function w8() {
  if (aC)
    return n0;
  aC = 1;
  const { ArrayPrototypePop: e, Promise: t } = qt, { isIterable: r, isNodeStream: n, isWebStream: o } = To, { pipelineImpl: s } = Vx, { finished: a } = ws;
  S8();
  function l(...u) {
    return new t((f, c) => {
      let d, h;
      const p = u[u.length - 1];
      if (p && typeof p == "object" && !n(p) && !r(p) && !o(p)) {
        const v = e(u);
        d = v.signal, h = v.end;
      }
      s(
        u,
        (v, y) => {
          v ? c(v) : f(y);
        },
        {
          signal: d,
          end: h
        }
      );
    });
  }
  return n0 = {
    finished: a,
    pipeline: l
  }, n0;
}
var lC;
function S8() {
  if (lC)
    return By.exports;
  lC = 1;
  const { Buffer: e } = ft, { ObjectDefineProperty: t, ObjectKeys: r, ReflectApply: n } = qt, {
    promisify: { custom: o }
  } = zr, { streamReturningOperators: s, promiseReturningOperators: a } = Px, {
    codes: { ERR_ILLEGAL_CONSTRUCTOR: l }
  } = an, u = y8, { setDefaultHighWaterMark: f, getDefaultHighWaterMark: c } = cg, { pipeline: d } = Vx, { destroyer: h } = mu, p = ws, v = w8(), y = To, w = By.exports = qx.Stream;
  w.isDestroyed = y.isDestroyed, w.isDisturbed = y.isDisturbed, w.isErrored = y.isErrored, w.isReadable = y.isReadable, w.isWritable = y.isWritable, w.Readable = dg();
  for (const x of r(s)) {
    let N = function(...C) {
      if (new.target)
        throw l();
      return w.Readable.from(n(E, this, C));
    };
    const E = s[x];
    t(N, "name", {
      __proto__: null,
      value: E.name
    }), t(N, "length", {
      __proto__: null,
      value: E.length
    }), t(w.Readable.prototype, x, {
      __proto__: null,
      value: N,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  for (const x of r(a)) {
    let N = function(...C) {
      if (new.target)
        throw l();
      return n(E, this, C);
    };
    const E = a[x];
    t(N, "name", {
      __proto__: null,
      value: E.name
    }), t(N, "length", {
      __proto__: null,
      value: E.length
    }), t(w.Readable.prototype, x, {
      __proto__: null,
      value: N,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  w.Writable = Wx(), w.Duplex = ho(), w.Transform = h8, w.PassThrough = g8, w.pipeline = d;
  const { addAbortSignal: S } = fg;
  return w.addAbortSignal = S, w.finished = p, w.destroy = h, w.compose = u, w.setDefaultHighWaterMark = f, w.getDefaultHighWaterMark = c, t(w, "promises", {
    __proto__: null,
    configurable: !0,
    enumerable: !0,
    get() {
      return v;
    }
  }), t(d, o, {
    __proto__: null,
    enumerable: !0,
    get() {
      return v.pipeline;
    }
  }), t(p, o, {
    __proto__: null,
    enumerable: !0,
    get() {
      return v.finished;
    }
  }), w.Stream = w, w._isUint8Array = function(E) {
    return E instanceof Uint8Array;
  }, w._uint8ArrayToBuffer = function(E) {
    return e.from(E.buffer, E.byteOffset, E.byteLength);
  }, By.exports;
}
(function(e) {
  const t = S8(), r = w8(), n = t.Readable.destroy;
  e.exports = t.Readable, e.exports._uint8ArrayToBuffer = t._uint8ArrayToBuffer, e.exports._isUint8Array = t._isUint8Array, e.exports.isDisturbed = t.isDisturbed, e.exports.isErrored = t.isErrored, e.exports.isReadable = t.isReadable, e.exports.Readable = t.Readable, e.exports.Writable = t.Writable, e.exports.Duplex = t.Duplex, e.exports.Transform = t.Transform, e.exports.PassThrough = t.PassThrough, e.exports.addAbortSignal = t.addAbortSignal, e.exports.finished = t.finished, e.exports.destroy = t.destroy, e.exports.destroy = n, e.exports.pipeline = t.pipeline, e.exports.compose = t.compose, Object.defineProperty(t, "promises", {
    configurable: !0,
    enumerable: !0,
    get() {
      return r;
    }
  }), e.exports.Stream = t.Stream, e.exports.default = e.exports;
})(I7);
var Mue = I7.exports;
class Oue {
  constructor(t, ...r) {
    this.load = C7(async () => {
      const n = await t();
      return new n(...r);
    });
  }
  import(t, r) {
    const n = new Mue.PassThrough({ objectMode: !0 });
    return Promise.resolve().then(async () => {
      const s = (await this.load()).import(t, r);
      s.on("prefix", (a, l) => {
        n.emit("prefix", a, l);
      }), s.on("error", (a) => {
        n.emit("error", a), n.emit("end");
      }), s.pipe(n);
    }), n;
  }
}
function ei(e) {
  return class extends Oue {
    constructor(...t) {
      super(e, ...t);
    }
  };
}
const Lue = new hh(), Pue = new hh(), bn = {
  parsers: Lue,
  serializers: Pue
}, Due = ei(async () => (await import("./index-CeD6y882.js")).default), Ac = ei(async () => (await Promise.resolve().then(() => XQ)).default), Fue = ei(async () => (await import("./CustomRdfXmlParser-DFszYljk.js")).default), pg = ei(async () => (await import("./index-DIo3jSo7.js")).default), jue = ei(async () => (await import("./CustomJsonLdSerializer-DebgH90h.js")).default);
bn.parsers.set("application/ld+json", new Due());
bn.parsers.set("application/trig", new Ac());
bn.parsers.set("application/n-quads", new Ac());
bn.parsers.set("application/n-triples", new Ac());
bn.parsers.set("text/n3", new Ac());
bn.parsers.set("text/turtle", new Ac());
bn.parsers.set("application/rdf+xml", new Fue());
bn.serializers.set("application/ld+json", new jue());
bn.serializers.set("application/n-quads", new pg());
bn.serializers.set("application/n-triples", new pg());
bn.serializers.set("text/n3", new pg());
bn.serializers.set("text/turtle", new pg());
var OS = { exports: {} }, E8 = ur.EventEmitter;
const Bue = {}, que = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Bue
}, Symbol.toStringTag, { value: "Module" })), Gx = /* @__PURE__ */ bW(que);
var i0, uC;
function Wue() {
  if (uC)
    return i0;
  uC = 1;
  function e(v, y) {
    var w = Object.keys(v);
    if (Object.getOwnPropertySymbols) {
      var S = Object.getOwnPropertySymbols(v);
      y && (S = S.filter(function(x) {
        return Object.getOwnPropertyDescriptor(v, x).enumerable;
      })), w.push.apply(w, S);
    }
    return w;
  }
  function t(v) {
    for (var y = 1; y < arguments.length; y++) {
      var w = arguments[y] != null ? arguments[y] : {};
      y % 2 ? e(Object(w), !0).forEach(function(S) {
        r(v, S, w[S]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(v, Object.getOwnPropertyDescriptors(w)) : e(Object(w)).forEach(function(S) {
        Object.defineProperty(v, S, Object.getOwnPropertyDescriptor(w, S));
      });
    }
    return v;
  }
  function r(v, y, w) {
    return y = a(y), y in v ? Object.defineProperty(v, y, { value: w, enumerable: !0, configurable: !0, writable: !0 }) : v[y] = w, v;
  }
  function n(v, y) {
    if (!(v instanceof y))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(v, y) {
    for (var w = 0; w < y.length; w++) {
      var S = y[w];
      S.enumerable = S.enumerable || !1, S.configurable = !0, "value" in S && (S.writable = !0), Object.defineProperty(v, a(S.key), S);
    }
  }
  function s(v, y, w) {
    return y && o(v.prototype, y), w && o(v, w), Object.defineProperty(v, "prototype", { writable: !1 }), v;
  }
  function a(v) {
    var y = l(v, "string");
    return typeof y == "symbol" ? y : String(y);
  }
  function l(v, y) {
    if (typeof v != "object" || v === null)
      return v;
    var w = v[Symbol.toPrimitive];
    if (w !== void 0) {
      var S = w.call(v, y || "default");
      if (typeof S != "object")
        return S;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (y === "string" ? String : Number)(v);
  }
  var u = ft, f = u.Buffer, c = Gx, d = c.inspect, h = d && d.custom || "inspect";
  function p(v, y, w) {
    f.prototype.copy.call(v, y, w);
  }
  return i0 = /* @__PURE__ */ function() {
    function v() {
      n(this, v), this.head = null, this.tail = null, this.length = 0;
    }
    return s(v, [{
      key: "push",
      value: function(w) {
        var S = {
          data: w,
          next: null
        };
        this.length > 0 ? this.tail.next = S : this.head = S, this.tail = S, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(w) {
        var S = {
          data: w,
          next: this.head
        };
        this.length === 0 && (this.tail = S), this.head = S, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var w = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, w;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(w) {
        if (this.length === 0)
          return "";
        for (var S = this.head, x = "" + S.data; S = S.next; )
          x += w + S.data;
        return x;
      }
    }, {
      key: "concat",
      value: function(w) {
        if (this.length === 0)
          return f.alloc(0);
        for (var S = f.allocUnsafe(w >>> 0), x = this.head, E = 0; x; )
          p(x.data, S, E), E += x.data.length, x = x.next;
        return S;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(w, S) {
        var x;
        return w < this.head.data.length ? (x = this.head.data.slice(0, w), this.head.data = this.head.data.slice(w)) : w === this.head.data.length ? x = this.shift() : x = S ? this._getString(w) : this._getBuffer(w), x;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(w) {
        var S = this.head, x = 1, E = S.data;
        for (w -= E.length; S = S.next; ) {
          var N = S.data, C = w > N.length ? N.length : w;
          if (C === N.length ? E += N : E += N.slice(0, w), w -= C, w === 0) {
            C === N.length ? (++x, S.next ? this.head = S.next : this.head = this.tail = null) : (this.head = S, S.data = N.slice(C));
            break;
          }
          ++x;
        }
        return this.length -= x, E;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(w) {
        var S = f.allocUnsafe(w), x = this.head, E = 1;
        for (x.data.copy(S), w -= x.data.length; x = x.next; ) {
          var N = x.data, C = w > N.length ? N.length : w;
          if (N.copy(S, S.length - w, 0, C), w -= C, w === 0) {
            C === N.length ? (++E, x.next ? this.head = x.next : this.head = this.tail = null) : (this.head = x, x.data = N.slice(C));
            break;
          }
          ++E;
        }
        return this.length -= E, S;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: h,
      value: function(w, S) {
        return d(this, t(t({}, S), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), v;
  }(), i0;
}
function Uue(e, t) {
  var r = this, n = this._readableState && this._readableState.destroyed, o = this._writableState && this._writableState.destroyed;
  return n || o ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, te.nextTick(LS, this, e)) : te.nextTick(LS, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(s) {
    !t && s ? r._writableState ? r._writableState.errorEmitted ? te.nextTick(zd, r) : (r._writableState.errorEmitted = !0, te.nextTick(fC, r, s)) : te.nextTick(fC, r, s) : t ? (te.nextTick(zd, r), t(s)) : te.nextTick(zd, r);
  }), this);
}
function fC(e, t) {
  LS(e, t), zd(e);
}
function zd(e) {
  e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
}
function Hue() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function LS(e, t) {
  e.emit("error", t);
}
function Vue(e, t) {
  var r = e._readableState, n = e._writableState;
  r && r.autoDestroy || n && n.autoDestroy ? e.destroy(t) : e.emit("error", t);
}
var x8 = {
  destroy: Uue,
  undestroy: Hue,
  errorOrDestroy: Vue
}, Qa = {};
function zue(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
}
var R8 = {};
function On(e, t, r) {
  r || (r = Error);
  function n(s, a, l) {
    return typeof t == "string" ? t : t(s, a, l);
  }
  var o = /* @__PURE__ */ function(s) {
    zue(a, s);
    function a(l, u, f) {
      return s.call(this, n(l, u, f)) || this;
    }
    return a;
  }(r);
  o.prototype.name = r.name, o.prototype.code = e, R8[e] = o;
}
function cC(e, t) {
  if (Array.isArray(e)) {
    var r = e.length;
    return e = e.map(function(n) {
      return String(n);
    }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
  } else
    return "of ".concat(t, " ").concat(String(e));
}
function Gue(e, t, r) {
  return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
}
function Kue(e, t, r) {
  return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
}
function Yue(e, t, r) {
  return typeof r != "number" && (r = 0), r + t.length > e.length ? !1 : e.indexOf(t, r) !== -1;
}
On("ERR_INVALID_OPT_VALUE", function(e, t) {
  return 'The value "' + t + '" is invalid for option "' + e + '"';
}, TypeError);
On("ERR_INVALID_ARG_TYPE", function(e, t, r) {
  var n;
  typeof t == "string" && Gue(t, "not ") ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be";
  var o;
  if (Kue(e, " argument"))
    o = "The ".concat(e, " ").concat(n, " ").concat(cC(t, "type"));
  else {
    var s = Yue(e, ".") ? "property" : "argument";
    o = 'The "'.concat(e, '" ').concat(s, " ").concat(n, " ").concat(cC(t, "type"));
  }
  return o += ". Received type ".concat(typeof r), o;
}, TypeError);
On("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
On("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
  return "The " + e + " method is not implemented";
});
On("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
On("ERR_STREAM_DESTROYED", function(e) {
  return "Cannot call " + e + " after a stream was destroyed";
});
On("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
On("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
On("ERR_STREAM_WRITE_AFTER_END", "write after end");
On("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
On("ERR_UNKNOWN_ENCODING", function(e) {
  return "Unknown encoding: " + e;
}, TypeError);
On("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
Qa.codes = R8;
var Xue = Qa.codes.ERR_INVALID_OPT_VALUE;
function Jue(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function Que(e, t, r, n) {
  var o = Jue(t, n, r);
  if (o != null) {
    if (!(isFinite(o) && Math.floor(o) === o) || o < 0) {
      var s = n ? r : "highWaterMark";
      throw new Xue(s, o);
    }
    return Math.floor(o);
  }
  return e.objectMode ? 16 : 16 * 1024;
}
var A8 = {
  getHighWaterMark: Que
}, PS = { exports: {} };
typeof Object.create == "function" ? PS.exports = function(t, r) {
  r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : PS.exports = function(t, r) {
  if (r) {
    t.super_ = r;
    var n = function() {
    };
    n.prototype = r.prototype, t.prototype = new n(), t.prototype.constructor = t;
  }
};
var Tc = PS.exports, Zue = efe;
function efe(e, t) {
  if (o0("noDeprecation"))
    return e;
  var r = !1;
  function n() {
    if (!r) {
      if (o0("throwDeprecation"))
        throw new Error(t);
      o0("traceDeprecation") ? console.trace(t) : console.warn(t), r = !0;
    }
    return e.apply(this, arguments);
  }
  return n;
}
function o0(e) {
  try {
    if (!window.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var t = window.localStorage[e];
  return t == null ? !1 : String(t).toLowerCase() === "true";
}
var s0, dC;
function T8() {
  if (dC)
    return s0;
  dC = 1, s0 = z;
  function e(ue) {
    var ee = this;
    this.next = null, this.entry = null, this.finish = function() {
      Ce(ee, ue);
    };
  }
  var t;
  z.WritableState = j;
  var r = {
    deprecate: Zue
  }, n = E8, o = ft.Buffer, s = (typeof window < "u" || typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function a(ue) {
    return o.from(ue);
  }
  function l(ue) {
    return o.isBuffer(ue) || ue instanceof s;
  }
  var u = x8, f = A8, c = f.getHighWaterMark, d = Qa.codes, h = d.ERR_INVALID_ARG_TYPE, p = d.ERR_METHOD_NOT_IMPLEMENTED, v = d.ERR_MULTIPLE_CALLBACK, y = d.ERR_STREAM_CANNOT_PIPE, w = d.ERR_STREAM_DESTROYED, S = d.ERR_STREAM_NULL_VALUES, x = d.ERR_STREAM_WRITE_AFTER_END, E = d.ERR_UNKNOWN_ENCODING, N = u.errorOrDestroy;
  Tc(z, n);
  function C() {
  }
  function j(ue, ee, be) {
    t = t || Xl(), ue = ue || {}, typeof be != "boolean" && (be = ee instanceof t), this.objectMode = !!ue.objectMode, be && (this.objectMode = this.objectMode || !!ue.writableObjectMode), this.highWaterMark = c(this, ue, "writableHighWaterMark", be), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Te = ue.decodeStrings === !1;
    this.decodeStrings = !Te, this.defaultEncoding = ue.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Pe) {
      Y(ee, Pe);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = ue.emitClose !== !1, this.autoDestroy = !!ue.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  j.prototype.getBuffer = function() {
    for (var ee = this.bufferedRequest, be = []; ee; )
      be.push(ee), ee = ee.next;
    return be;
  }, function() {
    try {
      Object.defineProperty(j.prototype, "buffer", {
        get: r.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var J;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (J = Function.prototype[Symbol.hasInstance], Object.defineProperty(z, Symbol.hasInstance, {
    value: function(ee) {
      return J.call(this, ee) ? !0 : this !== z ? !1 : ee && ee._writableState instanceof j;
    }
  })) : J = function(ee) {
    return ee instanceof this;
  };
  function z(ue) {
    t = t || Xl();
    var ee = this instanceof t;
    if (!ee && !J.call(z, this))
      return new z(ue);
    this._writableState = new j(ue, this, ee), this.writable = !0, ue && (typeof ue.write == "function" && (this._write = ue.write), typeof ue.writev == "function" && (this._writev = ue.writev), typeof ue.destroy == "function" && (this._destroy = ue.destroy), typeof ue.final == "function" && (this._final = ue.final)), n.call(this);
  }
  z.prototype.pipe = function() {
    N(this, new y());
  };
  function $(ue, ee) {
    var be = new x();
    N(ue, be), te.nextTick(ee, be);
  }
  function G(ue, ee, be, Te) {
    var Pe;
    return be === null ? Pe = new S() : typeof be != "string" && !ee.objectMode && (Pe = new h("chunk", ["string", "Buffer"], be)), Pe ? (N(ue, Pe), te.nextTick(Te, Pe), !1) : !0;
  }
  z.prototype.write = function(ue, ee, be) {
    var Te = this._writableState, Pe = !1, K = !Te.objectMode && l(ue);
    return K && !o.isBuffer(ue) && (ue = a(ue)), typeof ee == "function" && (be = ee, ee = null), K ? ee = "buffer" : ee || (ee = Te.defaultEncoding), typeof be != "function" && (be = C), Te.ending ? $(this, be) : (K || G(this, Te, ue, be)) && (Te.pendingcb++, Pe = W(this, Te, K, ue, ee, be)), Pe;
  }, z.prototype.cork = function() {
    this._writableState.corked++;
  }, z.prototype.uncork = function() {
    var ue = this._writableState;
    ue.corked && (ue.corked--, !ue.writing && !ue.corked && !ue.bufferProcessing && ue.bufferedRequest && ce(this, ue));
  }, z.prototype.setDefaultEncoding = function(ee) {
    if (typeof ee == "string" && (ee = ee.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((ee + "").toLowerCase()) > -1))
      throw new E(ee);
    return this._writableState.defaultEncoding = ee, this;
  }, Object.defineProperty(z.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function I(ue, ee, be) {
    return !ue.objectMode && ue.decodeStrings !== !1 && typeof ee == "string" && (ee = o.from(ee, be)), ee;
  }
  Object.defineProperty(z.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function W(ue, ee, be, Te, Pe, K) {
    if (!be) {
      var V = I(ee, Te, Pe);
      Te !== V && (be = !0, Pe = "buffer", Te = V);
    }
    var b = ee.objectMode ? 1 : Te.length;
    ee.length += b;
    var _ = ee.length < ee.highWaterMark;
    if (_ || (ee.needDrain = !0), ee.writing || ee.corked) {
      var T = ee.lastBufferedRequest;
      ee.lastBufferedRequest = {
        chunk: Te,
        encoding: Pe,
        isBuf: be,
        callback: K,
        next: null
      }, T ? T.next = ee.lastBufferedRequest : ee.bufferedRequest = ee.lastBufferedRequest, ee.bufferedRequestCount += 1;
    } else
      k(ue, ee, !1, b, Te, Pe, K);
    return _;
  }
  function k(ue, ee, be, Te, Pe, K, V) {
    ee.writelen = Te, ee.writecb = V, ee.writing = !0, ee.sync = !0, ee.destroyed ? ee.onwrite(new w("write")) : be ? ue._writev(Pe, ee.onwrite) : ue._write(Pe, K, ee.onwrite), ee.sync = !1;
  }
  function U(ue, ee, be, Te, Pe) {
    --ee.pendingcb, be ? (te.nextTick(Pe, Te), te.nextTick(H, ue, ee), ue._writableState.errorEmitted = !0, N(ue, Te)) : (Pe(Te), ue._writableState.errorEmitted = !0, N(ue, Te), H(ue, ee));
  }
  function Z(ue) {
    ue.writing = !1, ue.writecb = null, ue.length -= ue.writelen, ue.writelen = 0;
  }
  function Y(ue, ee) {
    var be = ue._writableState, Te = be.sync, Pe = be.writecb;
    if (typeof Pe != "function")
      throw new v();
    if (Z(be), ee)
      U(ue, be, Te, ee, Pe);
    else {
      var K = pe(be) || ue.destroyed;
      !K && !be.corked && !be.bufferProcessing && be.bufferedRequest && ce(ue, be), Te ? te.nextTick(re, ue, be, K, Pe) : re(ue, be, K, Pe);
    }
  }
  function re(ue, ee, be, Te) {
    be || ae(ue, ee), ee.pendingcb--, Te(), H(ue, ee);
  }
  function ae(ue, ee) {
    ee.length === 0 && ee.needDrain && (ee.needDrain = !1, ue.emit("drain"));
  }
  function ce(ue, ee) {
    ee.bufferProcessing = !0;
    var be = ee.bufferedRequest;
    if (ue._writev && be && be.next) {
      var Te = ee.bufferedRequestCount, Pe = new Array(Te), K = ee.corkedRequestsFree;
      K.entry = be;
      for (var V = 0, b = !0; be; )
        Pe[V] = be, be.isBuf || (b = !1), be = be.next, V += 1;
      Pe.allBuffers = b, k(ue, ee, !0, ee.length, Pe, "", K.finish), ee.pendingcb++, ee.lastBufferedRequest = null, K.next ? (ee.corkedRequestsFree = K.next, K.next = null) : ee.corkedRequestsFree = new e(ee), ee.bufferedRequestCount = 0;
    } else {
      for (; be; ) {
        var _ = be.chunk, T = be.encoding, L = be.callback, O = ee.objectMode ? 1 : _.length;
        if (k(ue, ee, !1, O, _, T, L), be = be.next, ee.bufferedRequestCount--, ee.writing)
          break;
      }
      be === null && (ee.lastBufferedRequest = null);
    }
    ee.bufferedRequest = be, ee.bufferProcessing = !1;
  }
  z.prototype._write = function(ue, ee, be) {
    be(new p("_write()"));
  }, z.prototype._writev = null, z.prototype.end = function(ue, ee, be) {
    var Te = this._writableState;
    return typeof ue == "function" ? (be = ue, ue = null, ee = null) : typeof ee == "function" && (be = ee, ee = null), ue != null && this.write(ue, ee), Te.corked && (Te.corked = 1, this.uncork()), Te.ending || ge(this, Te, be), this;
  }, Object.defineProperty(z.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function pe(ue) {
    return ue.ending && ue.length === 0 && ue.bufferedRequest === null && !ue.finished && !ue.writing;
  }
  function le(ue, ee) {
    ue._final(function(be) {
      ee.pendingcb--, be && N(ue, be), ee.prefinished = !0, ue.emit("prefinish"), H(ue, ee);
    });
  }
  function ye(ue, ee) {
    !ee.prefinished && !ee.finalCalled && (typeof ue._final == "function" && !ee.destroyed ? (ee.pendingcb++, ee.finalCalled = !0, te.nextTick(le, ue, ee)) : (ee.prefinished = !0, ue.emit("prefinish")));
  }
  function H(ue, ee) {
    var be = pe(ee);
    if (be && (ye(ue, ee), ee.pendingcb === 0 && (ee.finished = !0, ue.emit("finish"), ee.autoDestroy))) {
      var Te = ue._readableState;
      (!Te || Te.autoDestroy && Te.endEmitted) && ue.destroy();
    }
    return be;
  }
  function ge(ue, ee, be) {
    ee.ending = !0, H(ue, ee), be && (ee.finished ? te.nextTick(be) : ue.once("finish", be)), ee.ended = !0, ue.writable = !1;
  }
  function Ce(ue, ee, be) {
    var Te = ue.entry;
    for (ue.entry = null; Te; ) {
      var Pe = Te.callback;
      ee.pendingcb--, Pe(be), Te = Te.next;
    }
    ee.corkedRequestsFree.next = ue;
  }
  return Object.defineProperty(z.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(ee) {
      this._writableState && (this._writableState.destroyed = ee);
    }
  }), z.prototype.destroy = u.destroy, z.prototype._undestroy = u.undestroy, z.prototype._destroy = function(ue, ee) {
    ee(ue);
  }, s0;
}
var a0, hC;
function Xl() {
  if (hC)
    return a0;
  hC = 1;
  var e = Object.keys || function(f) {
    var c = [];
    for (var d in f)
      c.push(d);
    return c;
  };
  a0 = a;
  var t = N8(), r = T8();
  Tc(a, t);
  for (var n = e(r.prototype), o = 0; o < n.length; o++) {
    var s = n[o];
    a.prototype[s] || (a.prototype[s] = r.prototype[s]);
  }
  function a(f) {
    if (!(this instanceof a))
      return new a(f);
    t.call(this, f), r.call(this, f), this.allowHalfOpen = !0, f && (f.readable === !1 && (this.readable = !1), f.writable === !1 && (this.writable = !1), f.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", l)));
  }
  Object.defineProperty(a.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(a.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(a.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function l() {
    this._writableState.ended || te.nextTick(u, this);
  }
  function u(f) {
    f.end();
  }
  return Object.defineProperty(a.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(c) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = c, this._writableState.destroyed = c);
    }
  }), a0;
}
var pC = Qa.codes.ERR_STREAM_PREMATURE_CLOSE;
function tfe(e) {
  var t = !1;
  return function() {
    if (!t) {
      t = !0;
      for (var r = arguments.length, n = new Array(r), o = 0; o < r; o++)
        n[o] = arguments[o];
      e.apply(this, n);
    }
  };
}
function rfe() {
}
function nfe(e) {
  return e.setHeader && typeof e.abort == "function";
}
function $8(e, t, r) {
  if (typeof t == "function")
    return $8(e, null, t);
  t || (t = {}), r = tfe(r || rfe);
  var n = t.readable || t.readable !== !1 && e.readable, o = t.writable || t.writable !== !1 && e.writable, s = function() {
    e.writable || l();
  }, a = e._writableState && e._writableState.finished, l = function() {
    o = !1, a = !0, n || r.call(e);
  }, u = e._readableState && e._readableState.endEmitted, f = function() {
    n = !1, u = !0, o || r.call(e);
  }, c = function(v) {
    r.call(e, v);
  }, d = function() {
    var v;
    if (n && !u)
      return (!e._readableState || !e._readableState.ended) && (v = new pC()), r.call(e, v);
    if (o && !a)
      return (!e._writableState || !e._writableState.ended) && (v = new pC()), r.call(e, v);
  }, h = function() {
    e.req.on("finish", l);
  };
  return nfe(e) ? (e.on("complete", l), e.on("abort", d), e.req ? h() : e.on("request", h)) : o && !e._writableState && (e.on("end", s), e.on("close", s)), e.on("end", f), e.on("finish", l), t.error !== !1 && e.on("error", c), e.on("close", d), function() {
    e.removeListener("complete", l), e.removeListener("abort", d), e.removeListener("request", h), e.req && e.req.removeListener("finish", l), e.removeListener("end", s), e.removeListener("close", s), e.removeListener("finish", l), e.removeListener("end", f), e.removeListener("error", c), e.removeListener("close", d);
  };
}
var Kx = $8, l0, gC;
function ife() {
  if (gC)
    return l0;
  gC = 1;
  var e;
  function t(E, N, C) {
    return N = r(N), N in E ? Object.defineProperty(E, N, { value: C, enumerable: !0, configurable: !0, writable: !0 }) : E[N] = C, E;
  }
  function r(E) {
    var N = n(E, "string");
    return typeof N == "symbol" ? N : String(N);
  }
  function n(E, N) {
    if (typeof E != "object" || E === null)
      return E;
    var C = E[Symbol.toPrimitive];
    if (C !== void 0) {
      var j = C.call(E, N || "default");
      if (typeof j != "object")
        return j;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (N === "string" ? String : Number)(E);
  }
  var o = Kx, s = Symbol("lastResolve"), a = Symbol("lastReject"), l = Symbol("error"), u = Symbol("ended"), f = Symbol("lastPromise"), c = Symbol("handlePromise"), d = Symbol("stream");
  function h(E, N) {
    return {
      value: E,
      done: N
    };
  }
  function p(E) {
    var N = E[s];
    if (N !== null) {
      var C = E[d].read();
      C !== null && (E[f] = null, E[s] = null, E[a] = null, N(h(C, !1)));
    }
  }
  function v(E) {
    te.nextTick(p, E);
  }
  function y(E, N) {
    return function(C, j) {
      E.then(function() {
        if (N[u]) {
          C(h(void 0, !0));
          return;
        }
        N[c](C, j);
      }, j);
    };
  }
  var w = Object.getPrototypeOf(function() {
  }), S = Object.setPrototypeOf((e = {
    get stream() {
      return this[d];
    },
    next: function() {
      var N = this, C = this[l];
      if (C !== null)
        return Promise.reject(C);
      if (this[u])
        return Promise.resolve(h(void 0, !0));
      if (this[d].destroyed)
        return new Promise(function($, G) {
          te.nextTick(function() {
            N[l] ? G(N[l]) : $(h(void 0, !0));
          });
        });
      var j = this[f], J;
      if (j)
        J = new Promise(y(j, this));
      else {
        var z = this[d].read();
        if (z !== null)
          return Promise.resolve(h(z, !1));
        J = new Promise(this[c]);
      }
      return this[f] = J, J;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var N = this;
    return new Promise(function(C, j) {
      N[d].destroy(null, function(J) {
        if (J) {
          j(J);
          return;
        }
        C(h(void 0, !0));
      });
    });
  }), e), w), x = function(N) {
    var C, j = Object.create(S, (C = {}, t(C, d, {
      value: N,
      writable: !0
    }), t(C, s, {
      value: null,
      writable: !0
    }), t(C, a, {
      value: null,
      writable: !0
    }), t(C, l, {
      value: null,
      writable: !0
    }), t(C, u, {
      value: N._readableState.endEmitted,
      writable: !0
    }), t(C, c, {
      value: function(z, $) {
        var G = j[d].read();
        G ? (j[f] = null, j[s] = null, j[a] = null, z(h(G, !1))) : (j[s] = z, j[a] = $);
      },
      writable: !0
    }), C));
    return j[f] = null, o(N, function(J) {
      if (J && J.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var z = j[a];
        z !== null && (j[f] = null, j[s] = null, j[a] = null, z(J)), j[l] = J;
        return;
      }
      var $ = j[s];
      $ !== null && (j[f] = null, j[s] = null, j[a] = null, $(h(void 0, !0))), j[u] = !0;
    }), N.on("readable", v.bind(null, j)), j;
  };
  return l0 = x, l0;
}
var u0, bC;
function ofe() {
  return bC || (bC = 1, u0 = function() {
    throw new Error("Readable.from is not available in the browser");
  }), u0;
}
var f0, yC;
function N8() {
  if (yC)
    return f0;
  yC = 1, f0 = $;
  var e;
  $.ReadableState = z, ur.EventEmitter;
  var t = function(V, b) {
    return V.listeners(b).length;
  }, r = E8, n = ft.Buffer, o = (typeof window < "u" || typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function s(K) {
    return n.from(K);
  }
  function a(K) {
    return n.isBuffer(K) || K instanceof o;
  }
  var l = Gx, u;
  l && l.debuglog ? u = l.debuglog("stream") : u = function() {
  };
  var f = Wue(), c = x8, d = A8, h = d.getHighWaterMark, p = Qa.codes, v = p.ERR_INVALID_ARG_TYPE, y = p.ERR_STREAM_PUSH_AFTER_EOF, w = p.ERR_METHOD_NOT_IMPLEMENTED, S = p.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, x, E, N;
  Tc($, r);
  var C = c.errorOrDestroy, j = ["error", "close", "destroy", "pause", "resume"];
  function J(K, V, b) {
    if (typeof K.prependListener == "function")
      return K.prependListener(V, b);
    !K._events || !K._events[V] ? K.on(V, b) : Array.isArray(K._events[V]) ? K._events[V].unshift(b) : K._events[V] = [b, K._events[V]];
  }
  function z(K, V, b) {
    e = e || Xl(), K = K || {}, typeof b != "boolean" && (b = V instanceof e), this.objectMode = !!K.objectMode, b && (this.objectMode = this.objectMode || !!K.readableObjectMode), this.highWaterMark = h(this, K, "readableHighWaterMark", b), this.buffer = new f(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = K.emitClose !== !1, this.autoDestroy = !!K.autoDestroy, this.destroyed = !1, this.defaultEncoding = K.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, K.encoding && (x || (x = Vl().StringDecoder), this.decoder = new x(K.encoding), this.encoding = K.encoding);
  }
  function $(K) {
    if (e = e || Xl(), !(this instanceof $))
      return new $(K);
    var V = this instanceof e;
    this._readableState = new z(K, this, V), this.readable = !0, K && (typeof K.read == "function" && (this._read = K.read), typeof K.destroy == "function" && (this._destroy = K.destroy)), r.call(this);
  }
  Object.defineProperty($.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(V) {
      this._readableState && (this._readableState.destroyed = V);
    }
  }), $.prototype.destroy = c.destroy, $.prototype._undestroy = c.undestroy, $.prototype._destroy = function(K, V) {
    V(K);
  }, $.prototype.push = function(K, V) {
    var b = this._readableState, _;
    return b.objectMode ? _ = !0 : typeof K == "string" && (V = V || b.defaultEncoding, V !== b.encoding && (K = n.from(K, V), V = ""), _ = !0), G(this, K, V, !1, _);
  }, $.prototype.unshift = function(K) {
    return G(this, K, null, !0, !1);
  };
  function G(K, V, b, _, T) {
    u("readableAddChunk", V);
    var L = K._readableState;
    if (V === null)
      L.reading = !1, Y(K, L);
    else {
      var O;
      if (T || (O = W(L, V)), O)
        C(K, O);
      else if (L.objectMode || V && V.length > 0)
        if (typeof V != "string" && !L.objectMode && Object.getPrototypeOf(V) !== n.prototype && (V = s(V)), _)
          L.endEmitted ? C(K, new S()) : I(K, L, V, !0);
        else if (L.ended)
          C(K, new y());
        else {
          if (L.destroyed)
            return !1;
          L.reading = !1, L.decoder && !b ? (V = L.decoder.write(V), L.objectMode || V.length !== 0 ? I(K, L, V, !1) : ce(K, L)) : I(K, L, V, !1);
        }
      else
        _ || (L.reading = !1, ce(K, L));
    }
    return !L.ended && (L.length < L.highWaterMark || L.length === 0);
  }
  function I(K, V, b, _) {
    V.flowing && V.length === 0 && !V.sync ? (V.awaitDrain = 0, K.emit("data", b)) : (V.length += V.objectMode ? 1 : b.length, _ ? V.buffer.unshift(b) : V.buffer.push(b), V.needReadable && re(K)), ce(K, V);
  }
  function W(K, V) {
    var b;
    return !a(V) && typeof V != "string" && V !== void 0 && !K.objectMode && (b = new v("chunk", ["string", "Buffer", "Uint8Array"], V)), b;
  }
  $.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, $.prototype.setEncoding = function(K) {
    x || (x = Vl().StringDecoder);
    var V = new x(K);
    this._readableState.decoder = V, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var b = this._readableState.buffer.head, _ = ""; b !== null; )
      _ += V.write(b.data), b = b.next;
    return this._readableState.buffer.clear(), _ !== "" && this._readableState.buffer.push(_), this._readableState.length = _.length, this;
  };
  var k = 1073741824;
  function U(K) {
    return K >= k ? K = k : (K--, K |= K >>> 1, K |= K >>> 2, K |= K >>> 4, K |= K >>> 8, K |= K >>> 16, K++), K;
  }
  function Z(K, V) {
    return K <= 0 || V.length === 0 && V.ended ? 0 : V.objectMode ? 1 : K !== K ? V.flowing && V.length ? V.buffer.head.data.length : V.length : (K > V.highWaterMark && (V.highWaterMark = U(K)), K <= V.length ? K : V.ended ? V.length : (V.needReadable = !0, 0));
  }
  $.prototype.read = function(K) {
    u("read", K), K = parseInt(K, 10);
    var V = this._readableState, b = K;
    if (K !== 0 && (V.emittedReadable = !1), K === 0 && V.needReadable && ((V.highWaterMark !== 0 ? V.length >= V.highWaterMark : V.length > 0) || V.ended))
      return u("read: emitReadable", V.length, V.ended), V.length === 0 && V.ended ? be(this) : re(this), null;
    if (K = Z(K, V), K === 0 && V.ended)
      return V.length === 0 && be(this), null;
    var _ = V.needReadable;
    u("need readable", _), (V.length === 0 || V.length - K < V.highWaterMark) && (_ = !0, u("length less than watermark", _)), V.ended || V.reading ? (_ = !1, u("reading or ended", _)) : _ && (u("do read"), V.reading = !0, V.sync = !0, V.length === 0 && (V.needReadable = !0), this._read(V.highWaterMark), V.sync = !1, V.reading || (K = Z(b, V)));
    var T;
    return K > 0 ? T = ee(K, V) : T = null, T === null ? (V.needReadable = V.length <= V.highWaterMark, K = 0) : (V.length -= K, V.awaitDrain = 0), V.length === 0 && (V.ended || (V.needReadable = !0), b !== K && V.ended && be(this)), T !== null && this.emit("data", T), T;
  };
  function Y(K, V) {
    if (u("onEofChunk"), !V.ended) {
      if (V.decoder) {
        var b = V.decoder.end();
        b && b.length && (V.buffer.push(b), V.length += V.objectMode ? 1 : b.length);
      }
      V.ended = !0, V.sync ? re(K) : (V.needReadable = !1, V.emittedReadable || (V.emittedReadable = !0, ae(K)));
    }
  }
  function re(K) {
    var V = K._readableState;
    u("emitReadable", V.needReadable, V.emittedReadable), V.needReadable = !1, V.emittedReadable || (u("emitReadable", V.flowing), V.emittedReadable = !0, te.nextTick(ae, K));
  }
  function ae(K) {
    var V = K._readableState;
    u("emitReadable_", V.destroyed, V.length, V.ended), !V.destroyed && (V.length || V.ended) && (K.emit("readable"), V.emittedReadable = !1), V.needReadable = !V.flowing && !V.ended && V.length <= V.highWaterMark, ue(K);
  }
  function ce(K, V) {
    V.readingMore || (V.readingMore = !0, te.nextTick(pe, K, V));
  }
  function pe(K, V) {
    for (; !V.reading && !V.ended && (V.length < V.highWaterMark || V.flowing && V.length === 0); ) {
      var b = V.length;
      if (u("maybeReadMore read 0"), K.read(0), b === V.length)
        break;
    }
    V.readingMore = !1;
  }
  $.prototype._read = function(K) {
    C(this, new w("_read()"));
  }, $.prototype.pipe = function(K, V) {
    var b = this, _ = this._readableState;
    switch (_.pipesCount) {
      case 0:
        _.pipes = K;
        break;
      case 1:
        _.pipes = [_.pipes, K];
        break;
      default:
        _.pipes.push(K);
        break;
    }
    _.pipesCount += 1, u("pipe count=%d opts=%j", _.pipesCount, V);
    var T = (!V || V.end !== !1) && K !== te.stdout && K !== te.stderr, L = T ? ie : Me;
    _.endEmitted ? te.nextTick(L) : b.once("end", L), K.on("unpipe", O);
    function O(M, R) {
      u("onunpipe"), M === b && R && R.hasUnpiped === !1 && (R.hasUnpiped = !0, ve());
    }
    function ie() {
      u("onend"), K.end();
    }
    var fe = le(b);
    K.on("drain", fe);
    var se = !1;
    function ve() {
      u("cleanup"), K.removeListener("close", ke), K.removeListener("finish", Ie), K.removeListener("drain", fe), K.removeListener("error", me), K.removeListener("unpipe", O), b.removeListener("end", ie), b.removeListener("end", Me), b.removeListener("data", B), se = !0, _.awaitDrain && (!K._writableState || K._writableState.needDrain) && fe();
    }
    b.on("data", B);
    function B(M) {
      u("ondata");
      var R = K.write(M);
      u("dest.write", R), R === !1 && ((_.pipesCount === 1 && _.pipes === K || _.pipesCount > 1 && Pe(_.pipes, K) !== -1) && !se && (u("false write response, pause", _.awaitDrain), _.awaitDrain++), b.pause());
    }
    function me(M) {
      u("onerror", M), Me(), K.removeListener("error", me), t(K, "error") === 0 && C(K, M);
    }
    J(K, "error", me);
    function ke() {
      K.removeListener("finish", Ie), Me();
    }
    K.once("close", ke);
    function Ie() {
      u("onfinish"), K.removeListener("close", ke), Me();
    }
    K.once("finish", Ie);
    function Me() {
      u("unpipe"), b.unpipe(K);
    }
    return K.emit("pipe", b), _.flowing || (u("pipe resume"), b.resume()), K;
  };
  function le(K) {
    return function() {
      var b = K._readableState;
      u("pipeOnDrain", b.awaitDrain), b.awaitDrain && b.awaitDrain--, b.awaitDrain === 0 && t(K, "data") && (b.flowing = !0, ue(K));
    };
  }
  $.prototype.unpipe = function(K) {
    var V = this._readableState, b = {
      hasUnpiped: !1
    };
    if (V.pipesCount === 0)
      return this;
    if (V.pipesCount === 1)
      return K && K !== V.pipes ? this : (K || (K = V.pipes), V.pipes = null, V.pipesCount = 0, V.flowing = !1, K && K.emit("unpipe", this, b), this);
    if (!K) {
      var _ = V.pipes, T = V.pipesCount;
      V.pipes = null, V.pipesCount = 0, V.flowing = !1;
      for (var L = 0; L < T; L++)
        _[L].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var O = Pe(V.pipes, K);
    return O === -1 ? this : (V.pipes.splice(O, 1), V.pipesCount -= 1, V.pipesCount === 1 && (V.pipes = V.pipes[0]), K.emit("unpipe", this, b), this);
  }, $.prototype.on = function(K, V) {
    var b = r.prototype.on.call(this, K, V), _ = this._readableState;
    return K === "data" ? (_.readableListening = this.listenerCount("readable") > 0, _.flowing !== !1 && this.resume()) : K === "readable" && !_.endEmitted && !_.readableListening && (_.readableListening = _.needReadable = !0, _.flowing = !1, _.emittedReadable = !1, u("on readable", _.length, _.reading), _.length ? re(this) : _.reading || te.nextTick(H, this)), b;
  }, $.prototype.addListener = $.prototype.on, $.prototype.removeListener = function(K, V) {
    var b = r.prototype.removeListener.call(this, K, V);
    return K === "readable" && te.nextTick(ye, this), b;
  }, $.prototype.removeAllListeners = function(K) {
    var V = r.prototype.removeAllListeners.apply(this, arguments);
    return (K === "readable" || K === void 0) && te.nextTick(ye, this), V;
  };
  function ye(K) {
    var V = K._readableState;
    V.readableListening = K.listenerCount("readable") > 0, V.resumeScheduled && !V.paused ? V.flowing = !0 : K.listenerCount("data") > 0 && K.resume();
  }
  function H(K) {
    u("readable nexttick read 0"), K.read(0);
  }
  $.prototype.resume = function() {
    var K = this._readableState;
    return K.flowing || (u("resume"), K.flowing = !K.readableListening, ge(this, K)), K.paused = !1, this;
  };
  function ge(K, V) {
    V.resumeScheduled || (V.resumeScheduled = !0, te.nextTick(Ce, K, V));
  }
  function Ce(K, V) {
    u("resume", V.reading), V.reading || K.read(0), V.resumeScheduled = !1, K.emit("resume"), ue(K), V.flowing && !V.reading && K.read(0);
  }
  $.prototype.pause = function() {
    return u("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (u("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function ue(K) {
    var V = K._readableState;
    for (u("flow", V.flowing); V.flowing && K.read() !== null; )
      ;
  }
  $.prototype.wrap = function(K) {
    var V = this, b = this._readableState, _ = !1;
    K.on("end", function() {
      if (u("wrapped end"), b.decoder && !b.ended) {
        var O = b.decoder.end();
        O && O.length && V.push(O);
      }
      V.push(null);
    }), K.on("data", function(O) {
      if (u("wrapped data"), b.decoder && (O = b.decoder.write(O)), !(b.objectMode && O == null) && !(!b.objectMode && (!O || !O.length))) {
        var ie = V.push(O);
        ie || (_ = !0, K.pause());
      }
    });
    for (var T in K)
      this[T] === void 0 && typeof K[T] == "function" && (this[T] = /* @__PURE__ */ function(ie) {
        return function() {
          return K[ie].apply(K, arguments);
        };
      }(T));
    for (var L = 0; L < j.length; L++)
      K.on(j[L], this.emit.bind(this, j[L]));
    return this._read = function(O) {
      u("wrapped _read", O), _ && (_ = !1, K.resume());
    }, this;
  }, typeof Symbol == "function" && ($.prototype[Symbol.asyncIterator] = function() {
    return E === void 0 && (E = ife()), E(this);
  }), Object.defineProperty($.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty($.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty($.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(V) {
      this._readableState && (this._readableState.flowing = V);
    }
  }), $._fromList = ee, Object.defineProperty($.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function ee(K, V) {
    if (V.length === 0)
      return null;
    var b;
    return V.objectMode ? b = V.buffer.shift() : !K || K >= V.length ? (V.decoder ? b = V.buffer.join("") : V.buffer.length === 1 ? b = V.buffer.first() : b = V.buffer.concat(V.length), V.buffer.clear()) : b = V.buffer.consume(K, V.decoder), b;
  }
  function be(K) {
    var V = K._readableState;
    u("endReadable", V.endEmitted), V.endEmitted || (V.ended = !0, te.nextTick(Te, V, K));
  }
  function Te(K, V) {
    if (u("endReadableNT", K.endEmitted, K.length), !K.endEmitted && K.length === 0 && (K.endEmitted = !0, V.readable = !1, V.emit("end"), K.autoDestroy)) {
      var b = V._writableState;
      (!b || b.autoDestroy && b.finished) && V.destroy();
    }
  }
  typeof Symbol == "function" && ($.from = function(K, V) {
    return N === void 0 && (N = ofe()), N($, K, V);
  });
  function Pe(K, V) {
    for (var b = 0, _ = K.length; b < _; b++)
      if (K[b] === V)
        return b;
    return -1;
  }
  return f0;
}
var k8 = go, gg = Qa.codes, sfe = gg.ERR_METHOD_NOT_IMPLEMENTED, afe = gg.ERR_MULTIPLE_CALLBACK, lfe = gg.ERR_TRANSFORM_ALREADY_TRANSFORMING, ufe = gg.ERR_TRANSFORM_WITH_LENGTH_0, bg = Xl();
Tc(go, bg);
function ffe(e, t) {
  var r = this._transformState;
  r.transforming = !1;
  var n = r.writecb;
  if (n === null)
    return this.emit("error", new afe());
  r.writechunk = null, r.writecb = null, t != null && this.push(t), n(e);
  var o = this._readableState;
  o.reading = !1, (o.needReadable || o.length < o.highWaterMark) && this._read(o.highWaterMark);
}
function go(e) {
  if (!(this instanceof go))
    return new go(e);
  bg.call(this, e), this._transformState = {
    afterTransform: ffe.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", cfe);
}
function cfe() {
  var e = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
    vC(e, t, r);
  }) : vC(this, null, null);
}
go.prototype.push = function(e, t) {
  return this._transformState.needTransform = !1, bg.prototype.push.call(this, e, t);
};
go.prototype._transform = function(e, t, r) {
  r(new sfe("_transform()"));
};
go.prototype._write = function(e, t, r) {
  var n = this._transformState;
  if (n.writecb = r, n.writechunk = e, n.writeencoding = t, !n.transforming) {
    var o = this._readableState;
    (n.needTransform || o.needReadable || o.length < o.highWaterMark) && this._read(o.highWaterMark);
  }
};
go.prototype._read = function(e) {
  var t = this._transformState;
  t.writechunk !== null && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
};
go.prototype._destroy = function(e, t) {
  bg.prototype._destroy.call(this, e, function(r) {
    t(r);
  });
};
function vC(e, t, r) {
  if (t)
    return e.emit("error", t);
  if (r != null && e.push(r), e._writableState.length)
    throw new ufe();
  if (e._transformState.transforming)
    throw new lfe();
  return e.push(null);
}
var dfe = Hf, C8 = k8;
Tc(Hf, C8);
function Hf(e) {
  if (!(this instanceof Hf))
    return new Hf(e);
  C8.call(this, e);
}
Hf.prototype._transform = function(e, t, r) {
  r(null, e);
};
var c0;
function hfe(e) {
  var t = !1;
  return function() {
    t || (t = !0, e.apply(void 0, arguments));
  };
}
var I8 = Qa.codes, pfe = I8.ERR_MISSING_ARGS, gfe = I8.ERR_STREAM_DESTROYED;
function mC(e) {
  if (e)
    throw e;
}
function bfe(e) {
  return e.setHeader && typeof e.abort == "function";
}
function yfe(e, t, r, n) {
  n = hfe(n);
  var o = !1;
  e.on("close", function() {
    o = !0;
  }), c0 === void 0 && (c0 = Kx), c0(e, {
    readable: t,
    writable: r
  }, function(a) {
    if (a)
      return n(a);
    o = !0, n();
  });
  var s = !1;
  return function(a) {
    if (!o && !s) {
      if (s = !0, bfe(e))
        return e.abort();
      if (typeof e.destroy == "function")
        return e.destroy();
      n(a || new gfe("pipe"));
    }
  };
}
function _C(e) {
  e();
}
function vfe(e, t) {
  return e.pipe(t);
}
function mfe(e) {
  return !e.length || typeof e[e.length - 1] != "function" ? mC : e.pop();
}
function _fe() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var n = mfe(t);
  if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
    throw new pfe("streams");
  var o, s = t.map(function(a, l) {
    var u = l < t.length - 1, f = l > 0;
    return yfe(a, u, f, function(c) {
      o || (o = c), c && s.forEach(_C), !u && (s.forEach(_C), n(o));
    });
  });
  return t.reduce(vfe);
}
var wfe = _fe;
(function(e, t) {
  t = e.exports = N8(), t.Stream = t, t.Readable = t, t.Writable = T8(), t.Duplex = Xl(), t.Transform = k8, t.PassThrough = dfe, t.finished = Kx, t.pipeline = wfe;
})(OS, OS.exports);
var M8 = OS.exports;
const Sfe = /* @__PURE__ */ Tn(M8);
var O8 = { exports: {} };
const Efe = Gx, xfe = /([\x00-\x20<>"{}|^`\\]|%(?![0-9A-F][0-9A-F]))/g, Rfe = (e, t) => {
  let r = t.codePointAt(0).toString(16) + "";
  return r.length > 4 ? "\\U" + r.padStart(8, "0") : "\\u" + r.padStart(4, "0");
}, Nh = (e) => e.replace(xfe, Rfe), Yx = /^(?:[\u0000-@[-`{-\u00bf\u00d7\u00f7\u0300-\u306f\u037e\u2000-\u200b\u200e-\u206f\u2190-\u2bff\u2ff0-\u3000\ud800-\uf8ff\ufdd0-\ufddf\ufffe\uffff].+|(?:.+?[\u0000-,\/:-@[-^`{-\u00b6\u00b8-\u00bf\u00d7\u00f7\u037e\u2000-\u200b\u200e-\u203e\u2041-\u206f\u2190-\u2bff\u2ff0-\u3000\ud800-\uf8ff\ufdd0-\ufddf\ufffe\uffff].*)|.+\.)$/, L8 = /^(?:\\|[\u0000-\/;-@[-^`{-\u00bf\u00d7\u00f7\u0300-\u306f\u037e\u2000-\u200b\u200e-\u206f\u2190-\u2bff\u2ff0-\u3000\ud800-\uf8ff\ufdd0-\ufddf\ufffe\uffff].+|(?:.+?(?:\\|[\u0000-,\/;-@[-^`{-\u00b6\u00b8-\u00bf\u00d7\u00f7\u037e\u2000-\u200b\u200e-\u203e\u2041-\u206f\u2190-\u2bff\u2ff0-\u3000\ud800-\uf8ff\ufdd0-\ufddf\ufffe\uffff]).+)|(?:.+?(?:\\|[\u0000-,.\/;-@[-^`{-\u00b6\u00b8-\u00bf\u00d7\u00f7\u037e\u2000-\u200b\u200e-\u203e\u2041-\u206f\u2190-\u2bff\u2ff0-\u3000\ud800-\uf8ff\ufdd0-\ufddf\ufffe\uffff])))$/, Afe = /^([Tt](rue)?|TRUE)$/, Tfe = /^([Ff](alse)?|FALSE)$/, $fe = "xxxxxxxx_xxxx_4xxx_yxxx_xxxxxxxxxxxx", Nfe = /[xy]/g, Zu = () => {
  let e = Date.now();
  return typeof performance < "u" && (e += performance.now()), $fe.replace(Nfe, (t) => {
    let r = (e + Math.random() * 16) % 16 | 0;
    return e = Math.floor(e / 16), (t === "x" ? r : r & 3 | 8).toString(16);
  });
}, yg = Symbol("prefix-cache"), kfe = /[$^*()+[\\{}|.?]/g, Cfe = "((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_:0-9]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&'()*+,;=/?#@%])(?:(?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}.:]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&'()*+,;=/?#@%])*(?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}:]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&'()*+,;=/?#@%]))?)$";
function wC(e, t = !1) {
  let r = [], n = {};
  for (let o in e) {
    let s = e[o];
    t && Yx.test(o) || (n[s] = o, r.push(s.replace(kfe, "\\$&")));
  }
  return r.length ? (e[yg] = {
    _r_iris: new RegExp(`^(${r.join("|")})${Cfe}`, "u"),
    _h_inverse: n
  }, Object.freeze(e)) : e;
}
const P8 = (e, t) => {
  let r = t[yg];
  if (r) {
    let n = r._r_iris.exec(e);
    if (n)
      return r._h_inverse[n[1]] + ":" + n[2];
  } else {
    let n = "", o = "", s = -1;
    for (let a in t) {
      let l = t[a];
      if (e.indexOf(l) === 0 && l.length > s && !Yx.test(a)) {
        let u = e.slice(l.length);
        L8.test(u) || (o = u, n = a, s = l.length);
      }
    }
    if (s !== -1)
      return n + ":" + o;
  }
  return "<" + e + ">";
}, $c = (e, t = {}) => {
  let r = t[yg];
  if (r) {
    let n = r._r_iris.exec(e);
    if (n)
      return r._h_inverse[n[1]] + ":" + n[2];
  } else {
    let n = "", o = -1;
    for (let s in t) {
      let a = t[s];
      e.startsWith(a) && a.length > o && (n = s, o = a.length);
    }
    if (o !== -1)
      return n + ":" + e.slice(o);
  }
  return ">" + e;
}, Ife = /^([^:]*):(.*)$/;
function D8(e, t = {}, r = !1) {
  switch (e[0]) {
    case ">":
      return "<" + e.slice(1) + ">";
    case "_":
      return e.length <= 2 || e[2] === "#" ? new Vf()[r ? "verbose" : "terse"]() : e;
    case '"':
      return JSON.stringify(e.slice(1));
    case "@": {
      let n = e.indexOf('"');
      return JSON.stringify(e.slice(n + 1)) + e.slice(0, n);
    }
    case "^": {
      let n = e.indexOf('"');
      return JSON.stringify(e.slice(n + 1)) + "^^" + D8(e.slice(1, n), t, r);
    }
    case "*":
      return "";
    case "<":
    case "`":
      return Ze.c1(e).terse(t);
    default: {
      if (e === "a")
        return r ? "<http://www.w3.org/1999/02/22-rdf-syntax-ns#type>" : "a";
      let [, n, o] = Ife.exec(e);
      return r || L8.test(o) || Yx.test(n) ? "<" + t[n] + o + ">" : e;
    }
  }
}
class Ss {
  valueOf() {
    return this.concise();
  }
  toString() {
    return this.concise();
  }
  equals(t) {
    return t ? this === t || t.termType === this.termType && t.value === this.value : !1;
  }
}
Object.assign(Ss.prototype, {
  isGraphyTerm: !0
});
class er extends Ss {
  constructor(t) {
    super(), this.value = t;
  }
  concise(t = {}) {
    return $c(this.value, t);
  }
  terse(t = {}, r = !1) {
    return P8(Nh(this.value), t);
  }
  verbose() {
    return "<" + Nh(this.value) + ">";
  }
  isolate() {
    return {
      termType: "NamedNode",
      value: this.value
    };
  }
}
Object.assign(er.prototype, {
  termType: "NamedNode",
  isNamedNode: !0
});
const DS = new er("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
DS.isRdfTypeAlias = !0;
const F8 = new er("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString"), Mfe = F8.isolate(), Ofe = new er("http://www.w3.org/1999/02/22-rdf-syntax-ns#first"), SC = new er("http://www.w3.org/1999/02/22-rdf-syntax-ns#rest"), Lfe = new er("http://www.w3.org/1999/02/22-rdf-syntax-ns#nil"), Pfe = new er("http://www.w3.org/2001/XMLSchema#date"), Dfe = new er("http://www.w3.org/2001/XMLSchema#dateTime"), Qo = new er("http://www.w3.org/2001/XMLSchema#string");
class vg extends Ss {
  equals(t) {
    return t ? this === t || t.termType === "Literal" && t.value === this.value && this.datatype.equals(t.datatype) && t.language === this.language : !1;
  }
  verbose() {
    return JSON.stringify(this.value) + (this.language ? "@" + this.language : "^^" + this.datatype.verbose());
  }
  concise(t) {
    return this.language ? "@" + this.language + '"' + this.value : "^" + $c(this.datatype.value, t) + '"' + this.value;
  }
  terse(t = {}) {
    let r = this.datatype.terse(t);
    return JSON.stringify(this.value) + (this.language ? "@" + this.language : "^^" + r);
  }
  isolate() {
    return {
      termType: "Literal",
      value: this.value,
      language: this.language,
      datatype: this.datatype.isolate()
    };
  }
}
Object.assign(vg.prototype, {
  datatype: Qo,
  language: "",
  termType: "Literal",
  isLiteral: !0,
  isSimple: !1
});
class ef extends vg {
  constructor(t, r) {
    super(), this.value = t, this.language = (r[0] === "@" ? r.slice(1) : r).toLowerCase();
  }
  verbose() {
    return JSON.stringify(this.value) + "@" + this.language;
  }
  concise() {
    return "@" + this.language + '"' + this.value;
  }
  terse() {
    return JSON.stringify(this.value) + "@" + this.language;
  }
  isolate() {
    return {
      termType: "Literal",
      value: this.value,
      language: this.language,
      datatype: Mfe
    };
  }
}
Object.assign(ef.prototype, {
  datatype: F8,
  isLanguaged: !0
});
class _u extends vg {
  verbose() {
    return JSON.stringify(this.value) + "^^" + this.datatype.verbose();
  }
  concise(t) {
    return "^" + $c(this.datatype.value, t) + '"' + this.value;
  }
  terse(t = {}) {
    let r = this.datatype.terse(t);
    return JSON.stringify(this.value) + "^^" + r;
  }
  isolate() {
    return {
      termType: "Literal",
      value: this.value,
      language: this.language,
      datatype: this.datatype.isolate()
    };
  }
}
Object.assign(_u.prototype, {
  isDatatyped: !0
});
class vd extends _u {
  constructor(t, r) {
    super(), this.value = t, this.datatype = r;
  }
}
class j8 extends Ss {
  constructor(t) {
    super(), this.value = t;
  }
  get isSimple() {
    return !this.language && !this.datatype.equals(Qo);
  }
  get isLanguaged() {
    return !!this.language;
  }
  get isDatatyped() {
    return Qo.equals(this.datatype);
  }
  equals(t) {
    return t ? this === t || t.termType === "Literal" && t.value === this.value && this.datatype.equals(t.datatype) && t.language === this.language : !1;
  }
  verbose() {
    return JSON.stringify(this.value) + (this.language ? "@" + this.language : "^^" + this.datatype.verbose());
  }
  concise(t) {
    return this.language ? "@" + this.language + '"' + this.value : "^" + $c(this.datatype.value, t) + '"' + this.value;
  }
  terse(t = {}) {
    let r = this.datatype.terse(t);
    return JSON.stringify(this.value) + (this.language ? "@" + this.language : "^^" + r);
  }
  isolate() {
    return {
      termType: "Literal",
      value: this.value,
      language: this.language,
      datatype: this.datatype.isolate()
    };
  }
}
Object.assign(j8.prototype, {
  datatype: Qo,
  language: "",
  termType: "Literal",
  isLiteral: !0
});
class Hs extends vg {
  constructor(t) {
    super(), this.value = t;
  }
  verbose() {
    return JSON.stringify(this.value);
  }
  concise() {
    return '"' + this.value;
  }
  terse() {
    return JSON.stringify(this.value);
  }
}
Object.assign(Hs.prototype, {
  isSimple: !0
});
const B8 = new er("http://www.w3.org/2001/XMLSchema#integer");
class ha extends _u {
  static from(t) {
    let r = new ha(+t);
    return r.value = t, r;
  }
  constructor(t) {
    super(), this.value = t + "", this.number = t;
  }
  concise(t = {}) {
    return "^" + B8.concise(t) + '"' + this.value;
  }
  terse() {
    return this.value.includes("e") ? `"${this.value}"^^<http://www.w3.org/2001/XMLSchema#integer>` : this.value;
  }
}
Object.assign(ha.prototype, {
  datatype: B8,
  isNumeric: !0,
  isInteger: !0
});
const Nc = new er("http://www.w3.org/2001/XMLSchema#double");
class Ei extends _u {
  static from(t) {
    let r = new Ei(+t);
    return r.value = t, r;
  }
  constructor(t) {
    super(), this.value = t + "", this.number = t;
  }
  concise(t = {}) {
    return "^" + Nc.concise(t) + '"' + this.value;
  }
  terse() {
    return this.number.toExponential();
  }
}
Object.assign(Ei.prototype, {
  datatype: Nc,
  isNumeric: !0,
  isDouble: !0
});
const q8 = new er("http://www.w3.org/2001/XMLSchema#decimal");
class pa extends _u {
  static from(t) {
    let r = new pa(+t);
    return r.value = t, r;
  }
  constructor(t) {
    super(), this.value = t + "", this.number = t;
  }
  concise(t = {}) {
    return "^" + q8.concise(t) + '"' + this.value;
  }
  terse() {
    return this.value.includes("e") ? `"${this.value}"^^<http://www.w3.org/2001/XMLSchema#decimal>` : this.value + (this.value.includes(".") ? "" : ".0");
  }
}
Object.assign(pa.prototype, {
  datatype: q8,
  isNumeric: !0,
  isDecimal: !0
});
const W8 = new er("http://www.w3.org/2001/XMLSchema#boolean");
class hi extends _u {
  static from(t) {
    let r = new hi(+t);
    return r.value = t, r;
  }
  constructor(t) {
    super(), this.value = t + "", this.boolean = t;
  }
  concise(t = {}) {
    return "^" + W8.concise(t) + '"' + this.value;
  }
  terse() {
    return this.value + "";
  }
}
Object.assign(hi.prototype, {
  datatype: W8,
  isBoolean: !0
});
class U8 extends Ei {
  constructor() {
    super(1 / 0), this.value = "INF";
  }
  terse(t) {
    return '"INF"^^' + Nc.terse(t);
  }
}
Object.assign(U8.prototype, {
  isInfinite: !0
});
class H8 extends Ei {
  constructor() {
    super(-1 / 0), this.value = "-INF";
  }
  terse(t) {
    return '"-INF"^^' + Nc.terse(t);
  }
}
Object.assign(H8.prototype, {
  isInfinite: !0
});
class V8 extends Ei {
  constructor() {
    super(NaN), this.value = "NaN";
  }
  terse(t) {
    return '"NaN"^^' + Nc.terse(t);
  }
}
Object.assign(V8.prototype, {
  isNaN: !0
});
function Js(e, t = !1) {
  this.value = e, this.isAnonymous = t;
}
Js.prototype = Object.assign(
  Object.create(Ss.prototype),
  {
    termType: "BlankNode",
    isBlankNode: !0,
    concise() {
      return "_:" + this.value;
    },
    terse() {
      return "_:" + this.value;
    },
    verbose() {
      return "_:" + this.value;
    },
    isolate() {
      return {
        termType: "BlankNode",
        value: this.value
      };
    }
  }
);
function Vf() {
}
Vf.prototype = Object.assign(
  Object.create(Js.prototype),
  {
    isAnonymous: !0,
    isEphemeral: !0,
    concise() {
      return "_:#" + this.value;
    },
    terse() {
      return "[]";
    },
    verbose() {
      return "_:" + this.value;
    },
    isolate() {
      return {
        termType: "BlankNode",
        value: this.value
      };
    },
    equals() {
      return !1;
    }
  }
);
Object.defineProperty(Vf.prototype, "value", {
  get() {
    return "_" + Zu();
  }
});
class z8 extends Ss {
  constructor(t) {
    super(), this.value = t;
  }
  concise() {
    return "?" + this.value;
  }
  terse() {
    throw new Error("Cannot call .terse() on 'Variable' term type");
  }
  verbose() {
    throw new Error("Cannot call .verbose() on 'Variable' term type");
  }
  isolate() {
    return {
      termType: "Variable",
      value: this.value
    };
  }
}
Object.assign(z8.prototype, {
  termType: "Variable",
  isVariable: !0
});
function zf() {
}
zf.prototype = Object.assign(
  Object.create(Ss.prototype),
  {
    value: "",
    termType: "DefaultGraph",
    isDefaultGraph: !0,
    concise() {
      return "*";
    },
    terse() {
      return "";
    },
    verbose() {
      return "";
    },
    isolate() {
      return {
        termType: "DefaultGraph",
        value: ""
      };
    }
  }
);
Object.assign(
  Object.create(Ss.prototype),
  {
    value: "",
    termType: "NoGraph",
    concise() {
      return "";
    },
    terse() {
      return "";
    },
    verbose() {
      return "";
    },
    isolate() {
      return {
        termType: "NoGraph",
        value: ""
      };
    }
  }
);
const kh = new zf();
function jn(e, t, r, n = kh) {
  this.subject = e, this.predicate = t, this.object = r, this.graph = n;
}
Object.assign(jn.prototype, {
  isGraphyQuad: !0,
  equals(e) {
    return e ? this === e || this.object.equals(e.object) && this.subject.equals(e.subject) && this.predicate.equals(e.predicate) && this.graph.equals(e.graph) : !1;
  },
  valueOf() {
    return this.verbose();
  },
  concise(e = {}) {
    return [
      this.subject.concise(e),
      this.predicate.concise(e),
      this.object.concise(e),
      this.graph.concise(e)
    ];
  },
  terse(e) {
    let t = this.graph.isDefaultGraph;
    return (t ? "" : this.graph.terse(e) + " { ") + this.subject.terse(e) + " " + this.predicate.terse(e) + " " + this.object.terse(e) + " ." + (t ? "" : " }");
  },
  verbose() {
    return this.subject.verbose() + " " + this.predicate.verbose() + " " + this.object.verbose() + " " + (this.graph.isDefaultGraph ? "" : this.graph.verbose() + " ") + ".";
  },
  isolate() {
    return {
      subject: this.subject.isolate(),
      predicate: this.predicate.isolate(),
      object: this.object.isolate(),
      graph: this.graph.isolate()
    };
  }
});
let EC = {
  namedNode(e) {
    return new er(e);
  },
  blankNode(e, t) {
    return new Js(e, t);
  },
  literal(e) {
    return new j8(e);
  },
  defaultGraph() {
    return new zf();
  },
  quad(e, t, r, n) {
    return new jn(e, t, r, n || kh);
  },
  integer(e) {
    return ha.from(e);
  },
  double(e) {
    return Ei.from(e);
  },
  decimal(e) {
    return pa.from(e);
  },
  boolean(e) {
    return new hi(e);
  }
};
const Ze = O8.exports = {
  concise: $c,
  adopt(e) {
    let t = Object.create(e), r = !1;
    if (typeof e.boolean != "function") {
      let n = e.namedNode("http://www.w3.org/2001/XMLSchema#boolean");
      t.boolean = (o) => e.literal(o + "", n), r = !0;
    }
    if (typeof e.double != "function") {
      let n = e.namedNode("http://www.w3.org/2001/XMLSchema#double");
      t.double = (o) => e.literal(o + "", n), r = !0;
    }
    if (typeof e.decimal != "function") {
      let n = e.namedNode("http://www.w3.org/2001/XMLSchema#decimal");
      t.decimal = (o) => e.literal(o + "", n), r = !0;
    }
    if (typeof e.integer != "function") {
      let n = e.namedNode("http://www.w3.org/2001/XMLSchema#integer");
      t.integer = (o) => e.literal(o + "", n), r = !0;
    }
    return typeof e.simpleLiteral != "function" && (t.simpleLiteral = (n) => e.literal(n), r = !0), typeof e.languagedLiteral != "function" && (t.languagedLiteral = (n, o) => e.literal(n, o), r = !0), typeof e.datatypedLiteral != "function" && (t.datatypedLiteral = (n, o) => e.literal(n, o), r = !0), r ? t : e;
  },
  raw: EC,
  unfiltered: {
    ...EC,
    literal(e, t) {
      return !t || Qo.equals(t) ? new Hs(e) : typeof t == "string" ? new ef(e, t) : Qo.equals(t) ? new Hs(e) : new vd(e, t);
    },
    simpleLiteral(e) {
      return new Hs(e);
    },
    languagedLiteral(e, t) {
      return new ef(e, t);
    },
    datatypedLiteral(e, t) {
      return Qo.equals(t) ? new Hs(e) : new vd(e, t);
    }
  },
  number(e) {
    return typeof e == "number" && (!Number.isFinite(e) || Number.isNaN(e)) ? Ze.double(e) : Number.isInteger(e) || typeof e == "bigint" ? Ze.integer(e) : Ze.decimal(e);
  },
  date(e) {
    return Ze.literal(e.toISOString().replace(/T.+$/, "Z"), Pfe);
  },
  dateTime(e) {
    return Ze.literal(e.toISOString(), Dfe);
  },
  namedNode(e) {
    return new er(e);
  },
  ephemeral() {
    return new Vf();
  },
  // @deprecated
  anonymous() {
    return new Vf();
  },
  blankNode(e) {
    if (e) {
      if (typeof e == "string")
        return new Js(e);
    } else
      return new Js("_" + Zu(), !0);
    throw new TypeError(`factory.blankNode(label) expects 'label' parameter to be falsy or a string; instead found: ${e}`);
  },
  literal(e, t) {
    return !t || Qo.equals(t) ? new Hs(e) : typeof t == "string" ? new ef(e, t) : new vd(e, t);
  },
  integer(e) {
    let t = typeof e;
    if (t === "number") {
      if (Number.isFinite(e)) {
        if (!Number.isInteger(e))
          throw new Error("Number is not an integer: " + e);
      } else
        throw Number.isNaN(e) ? new Error("XSD integer cannot encode NaN. Try using double") : new Error("XSD integer cannot encode +/-infinity. Try using double");
      return new ha(e);
    } else if (t === "string") {
      if (e === "")
        throw new Error("Refusing to serialize empty string as xsd:integer");
      let r = +e;
      if (Number.isNaN(r) || !Number.isInteger(r))
        throw new Error("Invalid integer string: " + e);
      return new ha(r);
    } else
      throw t === "undefined" ? new Error("Refusing to serialize undefined value as xsd:integer") : e === null ? new Error("Refusing to serialize null value as xsd:integer") : new Error("XSD integer expects a number type or integer string");
  },
  double(e) {
    let t = typeof e;
    if (t === "number")
      return Number.isFinite(e) ? new Ei(e) : Number.isNaN(e) ? new V8() : e > 0 ? new U8() : new H8();
    if (t === "string") {
      if (e === "")
        throw new Error("Refusing to serialize empty string as xsd:double");
      let r = +e;
      if (Number.isNaN(r))
        throw new Error("Invalid decimal string: " + e);
      return new Ei(r);
    } else
      throw t === "undefined" ? new Error("Refusing to serialize undefined value as xsd:double") : e === null ? new Error("Refusing to serialize null value as xsd:double") : new Error("XSD double expects a number type or double string");
  },
  decimal(e) {
    let t = typeof e;
    if (t === "number") {
      if (!Number.isFinite(e))
        throw Number.isNaN(e) ? new Error("XSD decimal cannot encode NaN. Try using double") : new Error("XSD decimal cannot encode +/-infinity. Try using double");
      return new pa(e);
    } else if (t === "string") {
      if (e === "")
        throw new Error("Refusing to serialize empty string as xsd:decimal");
      let r = +e;
      if (Number.isNaN(r))
        throw new Error("Invalid decimal string: " + e);
      return new pa(r);
    } else
      throw t === "undefined" ? new Error("Refusing to serialize undefined value as xsd:decimal") : e === null ? new Error("Refusing to serialize null value as xsd:decimal") : new Error("XSD decimal expects a number type or decimal string");
  },
  boolean(e) {
    let t = typeof e;
    if (t === "boolean")
      return new hi(e);
    if (t === "number") {
      if (e === 1)
        return new hi(!0);
      if (e === 0)
        return new hi(!1);
      throw new Error("Boolean value 'w_value' must be either a '1' or '0' if using numbers");
    } else if (t === "string") {
      if (Afe.test(e))
        return new hi(!0);
      if (Tfe.test(e))
        return new hi(!1);
      throw e === "" ? new Error("Refusing to serialize empty string as xsd:boolean") : new Error("Invalid boolean string: " + e);
    } else
      throw t === "undefined" ? new Error("Refusing to serialize undefined value as xsd:boolean") : e === null ? new Error("Refusing to serialize null value as xsd:boolean") : new Error("XSD boolean expects a boolean type or boolean string");
  },
  defaultGraph() {
    return new zf();
  },
  variable(e) {
    return new z8(e);
  },
  // warn
  triple(e, t, r) {
    let n = new Error("It is strongly encouraged to use .quad() instead of .triple()");
    return console.warn(n.stack.replace(/^(\s*)Error:/, "$1Warning:")), new jn(e, t, r);
  },
  quad(e, t, r, n) {
    return new jn(e, t, r, n || kh);
  },
  term(e, t) {
    return typeof e == "string" ? Ze.c1(e, t) : Ze.from.rdfjs_term(e);
  },
  /**
   * construct a term object from a concise term string
   * @param  {c1_string} sc1_term - a representation of the term object to create
   * @param  {Object} h_prefixes - mappings for prefixes
   * @return {Term} - an RDFJS-compatible term object
   */
  c1(e, t = {}) {
    switch (e[0]) {
      case "^": {
        let r = e.indexOf('"');
        if (r === -1)
          throw new Error(`Invalid concise-term string, no content literal delimiter found: '${e}'`);
        let n = e.slice(1, r);
        return Ze.literal(e.slice(r + 1), Ze.c1_node_explicit(n, t));
      }
      case "@": {
        let r = e.indexOf('"');
        if (r === -1)
          throw new Error(`Invalid concise-term string, no content literal delimiter found: '${e}'`);
        let n = e.slice(1, r);
        return Ze.literal(e.slice(r + 1), n);
      }
      case '"':
        return Ze.literal(e.slice(1));
      default:
        return Ze.c1_node(e, t);
    }
  },
  // construct a term object from a concise term string for nodes
  c1_node(e, t = {}) {
    if (e === "a")
      return DS;
    if (e === "*")
      return Ze.defaultGraph();
    if (e[0] === "_") {
      if (e[1] !== ":")
        throw new Error(`Invliad concise-term string, prefixes are not allowed to start with an underscore: '${e}'`);
      return e[2] === "#" || e.length === 2 ? Ze.ephemeral() : Ze.blankNode(e.slice(2));
    }
    return Ze.c1_node_explicit(e, t);
  },
  // construct a named node
  c1_named_node(e, t = {}) {
    return e === "a" ? DS : Ze.c1_node_explicit(e, t);
  },
  // construct a term object from a concise term string for nodes (no shortcuts)
  c1_node_explicit(e, t = {}) {
    switch (e[0]) {
      case ">":
        return Ze.namedNode(e.slice(1));
      case "<":
        throw new Error(`Whoops! It looks like this concise-term string starts with a '<' character. Remember to use '>' if you are trying to make an absolute IRI reference.
Invalid concise-term string '${e}'`);
      case "`":
        throw new Error(`The backtick character '\`' is reserved for concise-struct key directives and should not be used in the object position.
Invalid concise-term string '${e}'`);
      default:
        return this.c1_prefixed_node(e, t);
    }
  },
  // construct a term object from a concise term string for prefixed nodes
  c1_prefixed_node(e, t = {}) {
    let r = e.indexOf(":");
    if (r === -1)
      throw new Error(`A relative or prefixed node must include a ':' character. 
Invalid concise-term string for node: '${e}'`);
    let n = e.slice(0, r), o = e.slice(r + 1);
    if (n in t)
      return Ze.namedNode(t[n] + o);
    throw new Error(`Prefix not defined: '${n}'`);
  },
  c1_to_nt: D8,
  *quads(e, t = {}) {
    for (let r in e)
      yield* Ze.triples(e[r], t, r);
  },
  *triples(e, t = {}, r = "*") {
    let n = Ze.c1(r, t);
    for (let o in e) {
      let s = Ze.c1(o, t), a = e[o];
      yield* Ze.pairs(n, s, a, t);
    }
  },
  *pairs(e, t, r, n = {}) {
    for (let o in r) {
      let s = Ze.c1(o, n), a = r[o];
      yield* Ze.objects(e, t, s, a, n);
    }
  },
  *collection(e, t, r, n = {}) {
    yield* Ze.objects(e, t, Ofe, r[0], n);
    let o = r.slice(1);
    if (!o.length)
      yield new jn(t, SC, Lfe, e);
    else {
      let s = Ze.blankNode();
      yield new jn(t, SC, s, e), yield* Ze.collection(e, s, o, n);
    }
  },
  *objects(e, t, r, n, o, s = !1) {
    switch (typeof n) {
      case "string": {
        yield new jn(t, r, Ze.c1(n, o), e);
        break;
      }
      case "number": {
        yield new jn(t, r, Ze.number(n), e);
        break;
      }
      case "object": {
        if (Array.isArray(n))
          if (s) {
            let l = Ze.blankNode();
            yield new jn(t, r, l, e), yield* Ze.collection(e, l, n, o);
          } else
            for (let l of n)
              yield* Ze.objects(e, t, r, l, o, !0);
        else {
          let l = Ze.blankNode();
          yield new jn(t, r, l, e), yield* Ze.pairs(e, l, n, o);
        }
        break;
      }
      default:
        throw new Error(`invalid object type: ${typeof n}`);
    }
  },
  from: {
    term(e) {
      return e === null || e.isGraphyTerm ? e : Ze.from.rdfjs_term(e);
    },
    quad(e) {
      if (e === null || e.isGraphyQuad)
        return e;
      let t = Ze.from;
      return new jn(
        t.rdfjs_term(e.subject),
        t.rdfjs_term(e.predicate),
        t.rdfjs_term(e.object),
        e.graph ? t.rdfjs_term(e.graph) : kh
      );
    },
    rdfjs_term(e) {
      switch (e.termType) {
        case "NamedNode":
          return new er(e.value);
        case "BlankNode":
          return new Js(e.value);
        case "Literal":
          return Ze.literal(e.value, e.language ? e.language : e.datatype ? new er(e.datatype.value) : null);
        case "DefaultGraph":
          return new zf();
        default:
          throw new TypeError(`invalid termType: ${e.termType}`);
      }
    },
    sparql_result(e) {
      switch (e.type) {
        case "uri":
          return new er(e.value);
        case "literal":
        case "typed-literal":
          return "xml:lang" in e ? new ef(e.value, e["xml:lang"]) : "datatype" in e && e.datatype !== "http://www.w3.org/2001/XMLSchema#string" ? new vd(e.value, new er(e.datatype)) : new Hs(e.value);
        case "bnode":
          return new Js(e.value);
        default:
          throw new Error(`unexpected SPARQL Result JSON Format Term type: ${e.type}`);
      }
    }
  },
  to: {
    boolean: (e) => hi.from(e),
    integer: (e) => ha.from(e),
    decimal: (e) => pa.from(e),
    double: (e) => Ei.from(e)
  },
  /**
   * @param  {Object} gc_comment -
   * @return {string} a `concise-term string` directive to be used as a key in `concise-term structs`
   * 	in order to write a comment to the document (only works with supporting serializers)
   */
  comment(e = {}) {
    return `\`[${Zu()}]${JSON.stringify({ ...e, type: "comment" })}`;
  },
  /**
   * @param  {integer} [line_count=1] - number of newlines to insert
   * @return {string} a `concise-term string` directive to be used as a key in `concise-term structs`
   * 	in order to write the given number of newlines to the document (only works with supporting serializers)
   */
  newlines() {
    return `\`[${Zu()}]{"type":"newlines"}`;
  },
  /**
   * @param {string} s_key - key that identifies which aspect to configure. e.g., 'lists'
   * @return {string} a `concise-term string` directive to be used as a key in `concise-term structs`
   * 	in order to write the given number of newlines to the document (only works with supporting serializers)
   */
  config(e) {
    if (typeof e != "string")
      throw new TypeError(`Expected 'key' argument to be a string, instead found ${typeof e}`);
    return `\`[${Zu()}]{"type":"config","value":${JSON.stringify(e)}}`;
  },
  /**
   * @param {AnyQuad} g_quad - quad to hash
   * @return {string} a sha256 hash of the quad
   */
  hash(e) {
    let t = Ze.from.quad(e), r = Efe.createHash("sha256");
    return r.update(t.verbose()), r.digest("hex");
  },
  cache_prefixes: wC,
  cachePrefixes: wC,
  terse: P8,
  clean_iri: Nh,
  cleanIri: Nh,
  $_PREFIX_CACHE: yg
};
Object.assign(Ze, {
  c3: Ze.triples,
  c4: Ze.quads,
  fromTerm: Ze.from.term,
  fromQuad: Ze.from.quad
});
var Ffe = O8.exports;
const xC = /* @__PURE__ */ Tn(Ffe);
class G8 {
  constructor(t) {
    this.term = t;
  }
  toTerm() {
    const t = `"""${this.term.value.replace(/"$/, '\\"')}"""`;
    return {
      terse: (r) => t + this.langOrDatatype(r),
      verbose: (r) => t + this.langOrDatatype(r)
    };
  }
  langOrDatatype(t) {
    if (this.term.language)
      return `@${this.term.language}`;
    if (this.term.datatype.equals(mf.string))
      return "";
    const r = p3(this.term.datatype.value, t);
    return r ? `^^${r}` : `^^<${this.term.datatype.value}>`;
  }
}
const K8 = /* @__PURE__ */ new Map([[G8, (e) => e.toTerm()]]);
function jfe(e) {
  return e.has(Bn.first) && e.has(Bn.rest);
}
class Bfe extends Sfe.Transform {
  constructor({
    prefixes: t = {},
    strict: r = !1,
    preserveListNodeProperties: n = !1
  } = {}) {
    super({ objectMode: !0 }), this.prefixes = t, this.graphs = new Ku(), this.blankNodes = new Ku(), this.strict = r, this.preserveListNodeProperties = n;
  }
  _transform({ subject: t, predicate: r, object: n, graph: o }, s, a) {
    const l = this.getGraph(o), u = l.get(t) || { predicates: new Ku() }, f = u.predicates.get(r) || [];
    if (u.predicates.set(r, [...f, n]), n.termType === "BlankNode") {
      const c = this.blankNodes.get(n) || 0;
      this.blankNodes.set(n, c + 1);
    }
    l.set(t, u), a();
  }
  _flush() {
    const t = [...this.graphs].reduce((r, [n, o]) => {
      const s = this.toHashKey(n);
      let a = r[s] || {};
      return a = [...o].reduce(
        this.toConciseHash(n).bind(this),
        a
      ), {
        ...r,
        [s]: a
      };
    }, {});
    this.push({
      type: this.strict ? "c4r" : "c4",
      value: t
    }), this.push(null);
  }
  toConciseHash(t) {
    return (r, [n, { predicates: o }]) => {
      if (!this.strict && this.blankNodes.get(n) === 1)
        return r;
      const s = this.toHashKey(n);
      return {
        ...r,
        [s]: this.createPropertyMap(t, o)
      };
    };
  }
  createPropertyMap(t, r, n = 0) {
    const o = (s) => {
      if (!this.strict && this.blankNodes.get(s) === 1) {
        const a = this.graphs.get(t).get(s);
        if (a)
          return this.createPropertyMap(t, a.predicates, n + 1);
      }
      return this.toHashKey(s);
    };
    if (!this.strict && jfe(r) && !this.preserveListNodeProperties) {
      const [s] = r.get(Bn.first), [a] = r.get(Bn.rest);
      if (n === 0) {
        let u;
        if (a.equals(Bn.nil))
          u = this.toHashKey(Bn.nil);
        else {
          const f = o(a);
          u = Array.isArray(f) ? [...f] : [f];
        }
        return {
          [this.toHashKey(Bn.first)]: [o(s)],
          [this.toHashKey(Bn.rest)]: [u]
        };
      }
      if (a.equals(Bn.nil))
        return [o(s)];
      const l = o(a);
      return [o(s), ...l];
    }
    return [...r].reduce((s, [a, l]) => {
      const u = this.toHashKey(a), f = l.map(o.bind(this));
      return {
        ...s,
        [u]: f
      };
    }, {});
  }
  getGraph(t) {
    const r = this.graphs.get(t) || new Ku();
    return this.graphs.set(t, r), r;
  }
  literalHash(t) {
    if (t.datatype && !this.strict)
      switch (t.datatype.value) {
        case mf.integer.value: {
          const r = +t.value;
          if (Number.isInteger(r))
            return r;
          break;
        }
        case mf.decimal.value: {
          const r = +t.value;
          if (!Number.isNaN(r) && !Number.isInteger(r))
            return r;
          break;
        }
        case mf.boolean.value: {
          if (t.value === "true")
            return !0;
          if (t.value === "false")
            return !1;
          break;
        }
      }
    return t.value.includes(`
`) ? new G8(t) : xC.fromTerm(t).concise(this.prefixes);
  }
  toHashKey(t) {
    return t.termType === "Literal" ? this.literalHash(t) : t.equals(Bn.type) ? "a" : xC.fromTerm(t).concise(this.prefixes);
  }
}
async function Xx(e, t = {}) {
  const r = (await e).default;
  return class {
    constructor(n = {}) {
      this.defaults = n;
    }
    // eslint-disable-next-line class-methods-use-this
    import(n, { preserveListNodeProperties: o, ...s } = {}) {
      const a = {
        ...this.defaults.prefixes || {},
        ...s.prefixes || {}
      }, l = r({
        prefixes: a,
        coercions: t.coercions
      });
      return n.pipe(
        new Bfe({
          prefixes: a,
          strict: t.strict,
          preserveListNodeProperties: o
        })
      ).pipe(l), l;
    }
  };
}
const Y8 = ei(
  () => Xx(import("./main-ngY7U5J3.js").then((e) => e.m), { coercions: K8 })
), qfe = ei(
  () => Xx(import("./main-DlkBenDy.js").then((e) => e.m), { strict: !0 })
), Wfe = ei(
  () => Xx(import("./main-DZwUoMgb.js").then((e) => e.m), { strict: !0, coercions: K8 })
);
async function X8(e) {
  const t = (await e).default;
  return class {
    // eslint-disable-next-line class-methods-use-this
    import(r, n) {
      return r.pipe(n ? t(n) : t());
    }
  };
}
const Jx = ei(
  () => X8(import("./main-BuhF8QYf.js").then((e) => e.m))
), J8 = ei(
  () => X8(import("./main-DWr02UHk.js").then((e) => e.m))
), Ufe = ei(async () => {
  const e = (await import("./index-CDRO8qms.js")).default;
  return class extends e {
    constructor({ prefixes: r = {}, ...n } = {}) {
      super({
        compact: !0,
        skipGraphProperty: !0,
        encoding: "string",
        ...n
      }), this.prefixes = r;
    }
    import(r, { prefixes: n = {} } = {}) {
      const o = { ...this.prefixes, ...n };
      return super.import(r, { context: o });
    }
  };
}), Ln = new v3({});
Ln.import(bn);
const ti = {
  jsonLd: "application/ld+json",
  ntriples: "application/n-triples",
  nquads: "application/n-quads",
  notation3: "text/n3",
  rdfXml: "application/rdf+xml",
  trig: "application/trig",
  turtle: "text/turtle"
};
Ln.serializers.set(ti.jsonLd, new Ufe());
Ln.serializers.set(ti.notation3, new Y8());
Ln.serializers.set(ti.turtle, new Y8());
Ln.serializers.set(ti.trig, new Wfe());
Ln.serializers.set(ti.rdfXml, new qfe());
Ln.parsers.set(ti.notation3, new Jx());
Ln.parsers.set(ti.turtle, new Jx());
Ln.parsers.set(ti.trig, new Jx());
Ln.parsers.set(ti.ntriples, new J8());
Ln.parsers.set(ti.nquads, new J8());
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Gd = window, Qx = Gd.ShadowRoot && (Gd.ShadyCSS === void 0 || Gd.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, Zx = Symbol(), RC = /* @__PURE__ */ new WeakMap();
let Q8 = class {
  constructor(t, r, n) {
    if (this._$cssResult$ = !0, n !== Zx)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = r;
  }
  get styleSheet() {
    let t = this.o;
    const r = this.t;
    if (Qx && t === void 0) {
      const n = r !== void 0 && r.length === 1;
      n && (t = RC.get(r)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), n && RC.set(r, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const Hfe = (e) => new Q8(typeof e == "string" ? e : e + "", void 0, Zx), Vfe = (e, ...t) => {
  const r = e.length === 1 ? e[0] : t.reduce((n, o, s) => n + ((a) => {
    if (a._$cssResult$ === !0)
      return a.cssText;
    if (typeof a == "number")
      return a;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + a + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(o) + e[s + 1], e[0]);
  return new Q8(r, e, Zx);
}, zfe = (e, t) => {
  Qx ? e.adoptedStyleSheets = t.map((r) => r instanceof CSSStyleSheet ? r : r.styleSheet) : t.forEach((r) => {
    const n = document.createElement("style"), o = Gd.litNonce;
    o !== void 0 && n.setAttribute("nonce", o), n.textContent = r.cssText, e.appendChild(n);
  });
}, AC = Qx ? (e) => e : (e) => e instanceof CSSStyleSheet ? ((t) => {
  let r = "";
  for (const n of t.cssRules)
    r += n.cssText;
  return Hfe(r);
})(e) : e;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var d0;
const Ch = window, TC = Ch.trustedTypes, Gfe = TC ? TC.emptyScript : "", $C = Ch.reactiveElementPolyfillSupport, FS = { toAttribute(e, t) {
  switch (t) {
    case Boolean:
      e = e ? Gfe : null;
      break;
    case Object:
    case Array:
      e = e == null ? e : JSON.stringify(e);
  }
  return e;
}, fromAttribute(e, t) {
  let r = e;
  switch (t) {
    case Boolean:
      r = e !== null;
      break;
    case Number:
      r = e === null ? null : Number(e);
      break;
    case Object:
    case Array:
      try {
        r = JSON.parse(e);
      } catch {
        r = null;
      }
  }
  return r;
} }, Z8 = (e, t) => t !== e && (t == t || e == e), h0 = { attribute: !0, type: String, converter: FS, reflect: !1, hasChanged: Z8 }, jS = "finalized";
let _l = class extends HTMLElement {
  constructor() {
    super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this.u();
  }
  static addInitializer(t) {
    var r;
    this.finalize(), ((r = this.h) !== null && r !== void 0 ? r : this.h = []).push(t);
  }
  static get observedAttributes() {
    this.finalize();
    const t = [];
    return this.elementProperties.forEach((r, n) => {
      const o = this._$Ep(n, r);
      o !== void 0 && (this._$Ev.set(o, n), t.push(o));
    }), t;
  }
  static createProperty(t, r = h0) {
    if (r.state && (r.attribute = !1), this.finalize(), this.elementProperties.set(t, r), !r.noAccessor && !this.prototype.hasOwnProperty(t)) {
      const n = typeof t == "symbol" ? Symbol() : "__" + t, o = this.getPropertyDescriptor(t, n, r);
      o !== void 0 && Object.defineProperty(this.prototype, t, o);
    }
  }
  static getPropertyDescriptor(t, r, n) {
    return { get() {
      return this[r];
    }, set(o) {
      const s = this[t];
      this[r] = o, this.requestUpdate(t, s, n);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) || h0;
  }
  static finalize() {
    if (this.hasOwnProperty(jS))
      return !1;
    this[jS] = !0;
    const t = Object.getPrototypeOf(this);
    if (t.finalize(), t.h !== void 0 && (this.h = [...t.h]), this.elementProperties = new Map(t.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
      const r = this.properties, n = [...Object.getOwnPropertyNames(r), ...Object.getOwnPropertySymbols(r)];
      for (const o of n)
        this.createProperty(o, r[o]);
    }
    return this.elementStyles = this.finalizeStyles(this.styles), !0;
  }
  static finalizeStyles(t) {
    const r = [];
    if (Array.isArray(t)) {
      const n = new Set(t.flat(1 / 0).reverse());
      for (const o of n)
        r.unshift(AC(o));
    } else
      t !== void 0 && r.push(AC(t));
    return r;
  }
  static _$Ep(t, r) {
    const n = r.attribute;
    return n === !1 ? void 0 : typeof n == "string" ? n : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  u() {
    var t;
    this._$E_ = new Promise((r) => this.enableUpdating = r), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), (t = this.constructor.h) === null || t === void 0 || t.forEach((r) => r(this));
  }
  addController(t) {
    var r, n;
    ((r = this._$ES) !== null && r !== void 0 ? r : this._$ES = []).push(t), this.renderRoot !== void 0 && this.isConnected && ((n = t.hostConnected) === null || n === void 0 || n.call(t));
  }
  removeController(t) {
    var r;
    (r = this._$ES) === null || r === void 0 || r.splice(this._$ES.indexOf(t) >>> 0, 1);
  }
  _$Eg() {
    this.constructor.elementProperties.forEach((t, r) => {
      this.hasOwnProperty(r) && (this._$Ei.set(r, this[r]), delete this[r]);
    });
  }
  createRenderRoot() {
    var t;
    const r = (t = this.shadowRoot) !== null && t !== void 0 ? t : this.attachShadow(this.constructor.shadowRootOptions);
    return zfe(r, this.constructor.elementStyles), r;
  }
  connectedCallback() {
    var t;
    this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$ES) === null || t === void 0 || t.forEach((r) => {
      var n;
      return (n = r.hostConnected) === null || n === void 0 ? void 0 : n.call(r);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$ES) === null || t === void 0 || t.forEach((r) => {
      var n;
      return (n = r.hostDisconnected) === null || n === void 0 ? void 0 : n.call(r);
    });
  }
  attributeChangedCallback(t, r, n) {
    this._$AK(t, n);
  }
  _$EO(t, r, n = h0) {
    var o;
    const s = this.constructor._$Ep(t, n);
    if (s !== void 0 && n.reflect === !0) {
      const a = (((o = n.converter) === null || o === void 0 ? void 0 : o.toAttribute) !== void 0 ? n.converter : FS).toAttribute(r, n.type);
      this._$El = t, a == null ? this.removeAttribute(s) : this.setAttribute(s, a), this._$El = null;
    }
  }
  _$AK(t, r) {
    var n;
    const o = this.constructor, s = o._$Ev.get(t);
    if (s !== void 0 && this._$El !== s) {
      const a = o.getPropertyOptions(s), l = typeof a.converter == "function" ? { fromAttribute: a.converter } : ((n = a.converter) === null || n === void 0 ? void 0 : n.fromAttribute) !== void 0 ? a.converter : FS;
      this._$El = s, this[s] = l.fromAttribute(r, a.type), this._$El = null;
    }
  }
  requestUpdate(t, r, n) {
    let o = !0;
    t !== void 0 && (((n = n || this.constructor.getPropertyOptions(t)).hasChanged || Z8)(this[t], r) ? (this._$AL.has(t) || this._$AL.set(t, r), n.reflect === !0 && this._$El !== t && (this._$EC === void 0 && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t, n))) : o = !1), !this.isUpdatePending && o && (this._$E_ = this._$Ej());
  }
  async _$Ej() {
    this.isUpdatePending = !0;
    try {
      await this._$E_;
    } catch (r) {
      Promise.reject(r);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t;
    if (!this.isUpdatePending)
      return;
    this.hasUpdated, this._$Ei && (this._$Ei.forEach((o, s) => this[s] = o), this._$Ei = void 0);
    let r = !1;
    const n = this._$AL;
    try {
      r = this.shouldUpdate(n), r ? (this.willUpdate(n), (t = this._$ES) === null || t === void 0 || t.forEach((o) => {
        var s;
        return (s = o.hostUpdate) === null || s === void 0 ? void 0 : s.call(o);
      }), this.update(n)) : this._$Ek();
    } catch (o) {
      throw r = !1, this._$Ek(), o;
    }
    r && this._$AE(n);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var r;
    (r = this._$ES) === null || r === void 0 || r.forEach((n) => {
      var o;
      return (o = n.hostUpdated) === null || o === void 0 ? void 0 : o.call(n);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$Ek() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$E_;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$EC !== void 0 && (this._$EC.forEach((r, n) => this._$EO(n, this[n], r)), this._$EC = void 0), this._$Ek();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
};
_l[jS] = !0, _l.elementProperties = /* @__PURE__ */ new Map(), _l.elementStyles = [], _l.shadowRootOptions = { mode: "open" }, $C == null || $C({ ReactiveElement: _l }), ((d0 = Ch.reactiveElementVersions) !== null && d0 !== void 0 ? d0 : Ch.reactiveElementVersions = []).push("1.6.2");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var p0;
const Ih = window, Jl = Ih.trustedTypes, NC = Jl ? Jl.createPolicy("lit-html", { createHTML: (e) => e }) : void 0, BS = "$lit$", Go = `lit$${(Math.random() + "").slice(9)}$`, ej = "?" + Go, Kfe = `<${ej}>`, $a = document, Gf = () => $a.createComment(""), Kf = (e) => e === null || typeof e != "object" && typeof e != "function", tj = Array.isArray, Yfe = (e) => tj(e) || typeof (e == null ? void 0 : e[Symbol.iterator]) == "function", g0 = `[ 	
\f\r]`, Pu = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, kC = /-->/g, CC = />/g, Ps = RegExp(`>|${g0}(?:([^\\s"'>=/]+)(${g0}*=${g0}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), IC = /'/g, MC = /"/g, rj = /^(?:script|style|textarea|title)$/i, Xfe = (e) => (t, ...r) => ({ _$litType$: e, strings: t, values: r }), Jfe = Xfe(1), Ql = Symbol.for("lit-noChange"), sr = Symbol.for("lit-nothing"), OC = /* @__PURE__ */ new WeakMap(), Qs = $a.createTreeWalker($a, 129, null, !1), Qfe = (e, t) => {
  const r = e.length - 1, n = [];
  let o, s = t === 2 ? "<svg>" : "", a = Pu;
  for (let u = 0; u < r; u++) {
    const f = e[u];
    let c, d, h = -1, p = 0;
    for (; p < f.length && (a.lastIndex = p, d = a.exec(f), d !== null); )
      p = a.lastIndex, a === Pu ? d[1] === "!--" ? a = kC : d[1] !== void 0 ? a = CC : d[2] !== void 0 ? (rj.test(d[2]) && (o = RegExp("</" + d[2], "g")), a = Ps) : d[3] !== void 0 && (a = Ps) : a === Ps ? d[0] === ">" ? (a = o ?? Pu, h = -1) : d[1] === void 0 ? h = -2 : (h = a.lastIndex - d[2].length, c = d[1], a = d[3] === void 0 ? Ps : d[3] === '"' ? MC : IC) : a === MC || a === IC ? a = Ps : a === kC || a === CC ? a = Pu : (a = Ps, o = void 0);
    const v = a === Ps && e[u + 1].startsWith("/>") ? " " : "";
    s += a === Pu ? f + Kfe : h >= 0 ? (n.push(c), f.slice(0, h) + BS + f.slice(h) + Go + v) : f + Go + (h === -2 ? (n.push(void 0), u) : v);
  }
  const l = s + (e[r] || "<?>") + (t === 2 ? "</svg>" : "");
  if (!Array.isArray(e) || !e.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return [NC !== void 0 ? NC.createHTML(l) : l, n];
};
let qS = class nj {
  constructor({ strings: t, _$litType$: r }, n) {
    let o;
    this.parts = [];
    let s = 0, a = 0;
    const l = t.length - 1, u = this.parts, [f, c] = Qfe(t, r);
    if (this.el = nj.createElement(f, n), Qs.currentNode = this.el.content, r === 2) {
      const d = this.el.content, h = d.firstChild;
      h.remove(), d.append(...h.childNodes);
    }
    for (; (o = Qs.nextNode()) !== null && u.length < l; ) {
      if (o.nodeType === 1) {
        if (o.hasAttributes()) {
          const d = [];
          for (const h of o.getAttributeNames())
            if (h.endsWith(BS) || h.startsWith(Go)) {
              const p = c[a++];
              if (d.push(h), p !== void 0) {
                const v = o.getAttribute(p.toLowerCase() + BS).split(Go), y = /([.?@])?(.*)/.exec(p);
                u.push({ type: 1, index: s, name: y[2], strings: v, ctor: y[1] === "." ? ece : y[1] === "?" ? rce : y[1] === "@" ? nce : mg });
              } else
                u.push({ type: 6, index: s });
            }
          for (const h of d)
            o.removeAttribute(h);
        }
        if (rj.test(o.tagName)) {
          const d = o.textContent.split(Go), h = d.length - 1;
          if (h > 0) {
            o.textContent = Jl ? Jl.emptyScript : "";
            for (let p = 0; p < h; p++)
              o.append(d[p], Gf()), Qs.nextNode(), u.push({ type: 2, index: ++s });
            o.append(d[h], Gf());
          }
        }
      } else if (o.nodeType === 8)
        if (o.data === ej)
          u.push({ type: 2, index: s });
        else {
          let d = -1;
          for (; (d = o.data.indexOf(Go, d + 1)) !== -1; )
            u.push({ type: 7, index: s }), d += Go.length - 1;
        }
      s++;
    }
  }
  static createElement(t, r) {
    const n = $a.createElement("template");
    return n.innerHTML = t, n;
  }
};
function Zl(e, t, r = e, n) {
  var o, s, a, l;
  if (t === Ql)
    return t;
  let u = n !== void 0 ? (o = r._$Co) === null || o === void 0 ? void 0 : o[n] : r._$Cl;
  const f = Kf(t) ? void 0 : t._$litDirective$;
  return (u == null ? void 0 : u.constructor) !== f && ((s = u == null ? void 0 : u._$AO) === null || s === void 0 || s.call(u, !1), f === void 0 ? u = void 0 : (u = new f(e), u._$AT(e, r, n)), n !== void 0 ? ((a = (l = r)._$Co) !== null && a !== void 0 ? a : l._$Co = [])[n] = u : r._$Cl = u), u !== void 0 && (t = Zl(e, u._$AS(e, t.values), u, n)), t;
}
let Zfe = class {
  constructor(t, r) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = r;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    var r;
    const { el: { content: n }, parts: o } = this._$AD, s = ((r = t == null ? void 0 : t.creationScope) !== null && r !== void 0 ? r : $a).importNode(n, !0);
    Qs.currentNode = s;
    let a = Qs.nextNode(), l = 0, u = 0, f = o[0];
    for (; f !== void 0; ) {
      if (l === f.index) {
        let c;
        f.type === 2 ? c = new eR(a, a.nextSibling, this, t) : f.type === 1 ? c = new f.ctor(a, f.name, f.strings, this, t) : f.type === 6 && (c = new ice(a, this, t)), this._$AV.push(c), f = o[++u];
      }
      l !== (f == null ? void 0 : f.index) && (a = Qs.nextNode(), l++);
    }
    return Qs.currentNode = $a, s;
  }
  v(t) {
    let r = 0;
    for (const n of this._$AV)
      n !== void 0 && (n.strings !== void 0 ? (n._$AI(t, n, r), r += n.strings.length - 2) : n._$AI(t[r])), r++;
  }
}, eR = class ij {
  constructor(t, r, n, o) {
    var s;
    this.type = 2, this._$AH = sr, this._$AN = void 0, this._$AA = t, this._$AB = r, this._$AM = n, this.options = o, this._$Cp = (s = o == null ? void 0 : o.isConnected) === null || s === void 0 || s;
  }
  get _$AU() {
    var t, r;
    return (r = (t = this._$AM) === null || t === void 0 ? void 0 : t._$AU) !== null && r !== void 0 ? r : this._$Cp;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const r = this._$AM;
    return r !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = r.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, r = this) {
    t = Zl(this, t, r), Kf(t) ? t === sr || t == null || t === "" ? (this._$AH !== sr && this._$AR(), this._$AH = sr) : t !== this._$AH && t !== Ql && this._(t) : t._$litType$ !== void 0 ? this.g(t) : t.nodeType !== void 0 ? this.$(t) : Yfe(t) ? this.T(t) : this._(t);
  }
  k(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  $(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.k(t));
  }
  _(t) {
    this._$AH !== sr && Kf(this._$AH) ? this._$AA.nextSibling.data = t : this.$($a.createTextNode(t)), this._$AH = t;
  }
  g(t) {
    var r;
    const { values: n, _$litType$: o } = t, s = typeof o == "number" ? this._$AC(t) : (o.el === void 0 && (o.el = qS.createElement(o.h, this.options)), o);
    if (((r = this._$AH) === null || r === void 0 ? void 0 : r._$AD) === s)
      this._$AH.v(n);
    else {
      const a = new Zfe(s, this), l = a.u(this.options);
      a.v(n), this.$(l), this._$AH = a;
    }
  }
  _$AC(t) {
    let r = OC.get(t.strings);
    return r === void 0 && OC.set(t.strings, r = new qS(t)), r;
  }
  T(t) {
    tj(this._$AH) || (this._$AH = [], this._$AR());
    const r = this._$AH;
    let n, o = 0;
    for (const s of t)
      o === r.length ? r.push(n = new ij(this.k(Gf()), this.k(Gf()), this, this.options)) : n = r[o], n._$AI(s), o++;
    o < r.length && (this._$AR(n && n._$AB.nextSibling, o), r.length = o);
  }
  _$AR(t = this._$AA.nextSibling, r) {
    var n;
    for ((n = this._$AP) === null || n === void 0 || n.call(this, !1, !0, r); t && t !== this._$AB; ) {
      const o = t.nextSibling;
      t.remove(), t = o;
    }
  }
  setConnected(t) {
    var r;
    this._$AM === void 0 && (this._$Cp = t, (r = this._$AP) === null || r === void 0 || r.call(this, t));
  }
};
class mg {
  constructor(t, r, n, o, s) {
    this.type = 1, this._$AH = sr, this._$AN = void 0, this.element = t, this.name = r, this._$AM = o, this.options = s, n.length > 2 || n[0] !== "" || n[1] !== "" ? (this._$AH = Array(n.length - 1).fill(new String()), this.strings = n) : this._$AH = sr;
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t, r = this, n, o) {
    const s = this.strings;
    let a = !1;
    if (s === void 0)
      t = Zl(this, t, r, 0), a = !Kf(t) || t !== this._$AH && t !== Ql, a && (this._$AH = t);
    else {
      const l = t;
      let u, f;
      for (t = s[0], u = 0; u < s.length - 1; u++)
        f = Zl(this, l[n + u], r, u), f === Ql && (f = this._$AH[u]), a || (a = !Kf(f) || f !== this._$AH[u]), f === sr ? t = sr : t !== sr && (t += (f ?? "") + s[u + 1]), this._$AH[u] = f;
    }
    a && !o && this.j(t);
  }
  j(t) {
    t === sr ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}
class ece extends mg {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === sr ? void 0 : t;
  }
}
const tce = Jl ? Jl.emptyScript : "";
let rce = class extends mg {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    t && t !== sr ? this.element.setAttribute(this.name, tce) : this.element.removeAttribute(this.name);
  }
}, nce = class extends mg {
  constructor(t, r, n, o, s) {
    super(t, r, n, o, s), this.type = 5;
  }
  _$AI(t, r = this) {
    var n;
    if ((t = (n = Zl(this, t, r, 0)) !== null && n !== void 0 ? n : sr) === Ql)
      return;
    const o = this._$AH, s = t === sr && o !== sr || t.capture !== o.capture || t.once !== o.once || t.passive !== o.passive, a = t !== sr && (o === sr || s);
    s && this.element.removeEventListener(this.name, this, o), a && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var r, n;
    typeof this._$AH == "function" ? this._$AH.call((n = (r = this.options) === null || r === void 0 ? void 0 : r.host) !== null && n !== void 0 ? n : this.element, t) : this._$AH.handleEvent(t);
  }
}, ice = class {
  constructor(t, r, n) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = r, this.options = n;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    Zl(this, t);
  }
};
const LC = Ih.litHtmlPolyfillSupport;
LC == null || LC(qS, eR), ((p0 = Ih.litHtmlVersions) !== null && p0 !== void 0 ? p0 : Ih.litHtmlVersions = []).push("2.7.4");
const oce = (e, t, r) => {
  var n, o;
  const s = (n = r == null ? void 0 : r.renderBefore) !== null && n !== void 0 ? n : t;
  let a = s._$litPart$;
  if (a === void 0) {
    const l = (o = r == null ? void 0 : r.renderBefore) !== null && o !== void 0 ? o : null;
    s._$litPart$ = a = new eR(t.insertBefore(Gf(), l), l, void 0, r ?? {});
  }
  return a._$AI(e), a;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var b0, y0;
let Af = class extends _l {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t, r;
    const n = super.createRenderRoot();
    return (t = (r = this.renderOptions).renderBefore) !== null && t !== void 0 || (r.renderBefore = n.firstChild), n;
  }
  update(t) {
    const r = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = oce(r, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) === null || t === void 0 || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) === null || t === void 0 || t.setConnected(!1);
  }
  render() {
    return Ql;
  }
};
Af.finalized = !0, Af._$litElement$ = !0, (b0 = globalThis.litElementHydrateSupport) === null || b0 === void 0 || b0.call(globalThis, { LitElement: Af });
const PC = globalThis.litElementPolyfillSupport;
PC == null || PC({ LitElement: Af });
((y0 = globalThis.litElementVersions) !== null && y0 !== void 0 ? y0 : globalThis.litElementVersions = []).push("3.3.2");
var Gr = navigator.userAgent, oj = navigator.platform, bo = /gecko\/\d/i.test(Gr), sj = /MSIE \d/.test(Gr), aj = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Gr), _g = /Edge\/(\d+)/.exec(Gr), dt = sj || aj || _g, kt = dt && (sj ? document.documentMode || 6 : +(_g || aj)[1]), Nr = !_g && /WebKit\//.test(Gr), sce = Nr && /Qt\/\d+\.\d+/.test(Gr), wg = !_g && /Chrome\//.test(Gr), Jn = /Opera\//.test(Gr), Sg = /Apple Computer/.test(navigator.vendor), ace = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(Gr), lce = /PhantomJS/.test(Gr), kc = Sg && (/Mobile\/\w+/.test(Gr) || navigator.maxTouchPoints > 2), Eg = /Android/.test(Gr), Yf = kc || Eg || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(Gr), Rn = kc || /Mac/.test(oj), uce = /\bCrOS\b/.test(Gr), fce = /win/i.test(oj), ga = Jn && Gr.match(/Version\/(\d*\.\d*)/);
ga && (ga = Number(ga[1]));
ga && ga >= 15 && (Jn = !1, Nr = !0);
var DC = Rn && (sce || Jn && (ga == null || ga < 12.11)), tR = bo || dt && kt >= 9;
function eu(e) {
  return new RegExp("(^|\\s)" + e + "(?:$|\\s)\\s*");
}
var Za = function(e, t) {
  let r = e.className, n = eu(t).exec(r);
  if (n) {
    let o = r.slice(n.index + n[0].length);
    e.className = r.slice(0, n.index) + (o ? n[1] + o : "");
  }
};
function us(e) {
  for (let t = e.childNodes.length; t > 0; --t)
    e.removeChild(e.firstChild);
  return e;
}
function hn(e, t) {
  return us(e).appendChild(t);
}
function He(e, t, r, n) {
  let o = document.createElement(e);
  if (r && (o.className = r), n && (o.style.cssText = n), typeof t == "string")
    o.appendChild(document.createTextNode(t));
  else if (t)
    for (let s = 0; s < t.length; ++s)
      o.appendChild(t[s]);
  return o;
}
function Dl(e, t, r, n) {
  let o = He(e, t, r, n);
  return o.setAttribute("role", "presentation"), o;
}
var Na;
document.createRange ? Na = function(e, t, r, n) {
  let o = document.createRange();
  return o.setEnd(n || e, r), o.setStart(e, t), o;
} : Na = function(e, t, r) {
  let n = document.body.createTextRange();
  try {
    n.moveToElementText(e.parentNode);
  } catch {
    return n;
  }
  return n.collapse(!0), n.moveEnd("character", r), n.moveStart("character", t), n;
};
function fs(e, t) {
  if (t.nodeType == 3 && (t = t.parentNode), e.contains)
    return e.contains(t);
  do
    if (t.nodeType == 11 && (t = t.host), t == e)
      return !0;
  while (t = t.parentNode);
}
function En() {
  let e;
  try {
    e = document.activeElement;
  } catch {
    e = document.body || null;
  }
  for (; e && e.shadowRoot && e.shadowRoot.activeElement; )
    e = e.shadowRoot.activeElement;
  return e;
}
function el(e, t) {
  let r = e.className;
  eu(t).test(r) || (e.className += (r ? " " : "") + t);
}
function v0(e, t) {
  let r = e.split(" ");
  for (let n = 0; n < r.length; n++)
    r[n] && !eu(r[n]).test(t) && (t += " " + r[n]);
  return t;
}
var Xf = function(e) {
  e.select();
};
kc ? Xf = function(e) {
  e.selectionStart = 0, e.selectionEnd = e.value.length;
} : dt && (Xf = function(e) {
  try {
    e.select();
  } catch {
  }
});
function rR(e) {
  let t = Array.prototype.slice.call(arguments, 1);
  return function() {
    return e.apply(null, t);
  };
}
function ka(e, t, r) {
  t || (t = {});
  for (let n in e)
    e.hasOwnProperty(n) && (r !== !1 || !t.hasOwnProperty(n)) && (t[n] = e[n]);
  return t;
}
function wn(e, t, r, n, o) {
  t == null && (t = e.search(/[^\s\u00a0]/), t == -1 && (t = e.length));
  for (let s = n || 0, a = o || 0; ; ) {
    let l = e.indexOf("	", s);
    if (l < 0 || l >= t)
      return a + (t - s);
    a += l - s, a += r - a % r, s = l + 1;
  }
}
var tu = class {
  constructor() {
    this.id = null, this.f = null, this.time = 0, this.handler = rR(this.onTimeout, this);
  }
  onTimeout(e) {
    e.id = 0, e.time <= +/* @__PURE__ */ new Date() ? e.f() : setTimeout(e.handler, e.time - +/* @__PURE__ */ new Date());
  }
  set(e, t) {
    this.f = t;
    const r = +/* @__PURE__ */ new Date() + e;
    (!this.id || r < this.time) && (clearTimeout(this.id), this.id = setTimeout(this.handler, e), this.time = r);
  }
};
function _r(e, t) {
  for (let r = 0; r < e.length; ++r)
    if (e[r] == t)
      return r;
  return -1;
}
var lj = 50, xg = { toString: function() {
  return "CodeMirror.Pass";
} }, Ci = { scroll: !1 }, m0 = { origin: "*mouse" }, Tf = { origin: "+move" };
function WS(e, t, r) {
  for (let n = 0, o = 0; ; ) {
    let s = e.indexOf("	", n);
    s == -1 && (s = e.length);
    let a = s - n;
    if (s == e.length || o + a >= t)
      return n + Math.min(a, t - o);
    if (o += s - n, o += r - o % r, n = s + 1, o >= t)
      return n;
  }
}
var md = [""];
function nR(e) {
  for (; md.length <= e; )
    md.push(vt(md) + " ");
  return md[e];
}
function vt(e) {
  return e[e.length - 1];
}
function Rg(e, t) {
  let r = [];
  for (let n = 0; n < e.length; n++)
    r[n] = t(e[n], n);
  return r;
}
function cce(e, t, r) {
  let n = 0, o = r(t);
  for (; n < e.length && r(e[n]) <= o; )
    n++;
  e.splice(n, 0, t);
}
function FC() {
}
function uj(e, t) {
  let r;
  return Object.create ? r = Object.create(e) : (FC.prototype = e, r = new FC()), t && ka(t, r), r;
}
var dce = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
function US(e) {
  return /\w/.test(e) || e > "" && (e.toUpperCase() != e.toLowerCase() || dce.test(e));
}
function Kd(e, t) {
  return t ? t.source.indexOf("\\w") > -1 && US(e) ? !0 : t.test(e) : US(e);
}
function jC(e) {
  for (let t in e)
    if (e.hasOwnProperty(t) && e[t])
      return !1;
  return !0;
}
var hce = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
function HS(e) {
  return e.charCodeAt(0) >= 768 && hce.test(e);
}
function fj(e, t, r) {
  for (; (r < 0 ? t > 0 : t < e.length) && HS(e.charAt(t)); )
    t += r;
  return t;
}
function Jf(e, t, r) {
  let n = t > r ? -1 : 1;
  for (; ; ) {
    if (t == r)
      return t;
    let o = (t + r) / 2, s = n < 0 ? Math.ceil(o) : Math.floor(o);
    if (s == t)
      return e(s) ? t : r;
    e(s) ? r = s : t = s + n;
  }
}
function pce(e, t, r, n) {
  if (!e)
    return n(t, r, "ltr", 0);
  let o = !1;
  for (let s = 0; s < e.length; ++s) {
    let a = e[s];
    (a.from < r && a.to > t || t == r && a.to == t) && (n(Math.max(a.from, t), Math.min(a.to, r), a.level == 1 ? "rtl" : "ltr", s), o = !0);
  }
  o || n(t, r, "ltr");
}
var tf = null;
function Qf(e, t, r) {
  let n;
  tf = null;
  for (let o = 0; o < e.length; ++o) {
    let s = e[o];
    if (s.from < t && s.to > t)
      return o;
    s.to == t && (s.from != s.to && r == "before" ? n = o : tf = o), s.from == t && (s.from != s.to && r != "before" ? n = o : tf = o);
  }
  return n ?? tf;
}
var gce = /* @__PURE__ */ function() {
  let e = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN", t = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
  function r(f) {
    return f <= 247 ? e.charAt(f) : 1424 <= f && f <= 1524 ? "R" : 1536 <= f && f <= 1785 ? t.charAt(f - 1536) : 1774 <= f && f <= 2220 ? "r" : 8192 <= f && f <= 8203 ? "w" : f == 8204 ? "b" : "L";
  }
  let n = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, o = /[stwN]/, s = /[LRr]/, a = /[Lb1n]/, l = /[1n]/;
  function u(f, c, d) {
    this.level = f, this.from = c, this.to = d;
  }
  return function(f, c) {
    let d = c == "ltr" ? "L" : "R";
    if (f.length == 0 || c == "ltr" && !n.test(f))
      return !1;
    let h = f.length, p = [];
    for (let w = 0; w < h; ++w)
      p.push(r(f.charCodeAt(w)));
    for (let w = 0, S = d; w < h; ++w) {
      let x = p[w];
      x == "m" ? p[w] = S : S = x;
    }
    for (let w = 0, S = d; w < h; ++w) {
      let x = p[w];
      x == "1" && S == "r" ? p[w] = "n" : s.test(x) && (S = x, x == "r" && (p[w] = "R"));
    }
    for (let w = 1, S = p[0]; w < h - 1; ++w) {
      let x = p[w];
      x == "+" && S == "1" && p[w + 1] == "1" ? p[w] = "1" : x == "," && S == p[w + 1] && (S == "1" || S == "n") && (p[w] = S), S = x;
    }
    for (let w = 0; w < h; ++w) {
      let S = p[w];
      if (S == ",")
        p[w] = "N";
      else if (S == "%") {
        let x;
        for (x = w + 1; x < h && p[x] == "%"; ++x)
          ;
        let E = w && p[w - 1] == "!" || x < h && p[x] == "1" ? "1" : "N";
        for (let N = w; N < x; ++N)
          p[N] = E;
        w = x - 1;
      }
    }
    for (let w = 0, S = d; w < h; ++w) {
      let x = p[w];
      S == "L" && x == "1" ? p[w] = "L" : s.test(x) && (S = x);
    }
    for (let w = 0; w < h; ++w)
      if (o.test(p[w])) {
        let S;
        for (S = w + 1; S < h && o.test(p[S]); ++S)
          ;
        let x = (w ? p[w - 1] : d) == "L", E = (S < h ? p[S] : d) == "L", N = x == E ? x ? "L" : "R" : d;
        for (let C = w; C < S; ++C)
          p[C] = N;
        w = S - 1;
      }
    let v = [], y;
    for (let w = 0; w < h; )
      if (a.test(p[w])) {
        let S = w;
        for (++w; w < h && a.test(p[w]); ++w)
          ;
        v.push(new u(0, S, w));
      } else {
        let S = w, x = v.length, E = c == "rtl" ? 1 : 0;
        for (++w; w < h && p[w] != "L"; ++w)
          ;
        for (let N = S; N < w; )
          if (l.test(p[N])) {
            S < N && (v.splice(x, 0, new u(1, S, N)), x += E);
            let C = N;
            for (++N; N < w && l.test(p[N]); ++N)
              ;
            v.splice(x, 0, new u(2, C, N)), x += E, S = N;
          } else
            ++N;
        S < w && v.splice(x, 0, new u(1, S, w));
      }
    return c == "ltr" && (v[0].level == 1 && (y = f.match(/^\s+/)) && (v[0].from = y[0].length, v.unshift(new u(0, 0, y[0].length))), vt(v).level == 1 && (y = f.match(/\s+$/)) && (vt(v).to -= y[0].length, v.push(new u(0, h - y[0].length, h)))), c == "rtl" ? v.reverse() : v;
  };
}();
function $o(e, t) {
  let r = e.order;
  return r == null && (r = e.order = gce(e.text, t)), r;
}
var cj = [], Ve = function(e, t, r) {
  if (e.addEventListener)
    e.addEventListener(t, r, !1);
  else if (e.attachEvent)
    e.attachEvent("on" + t, r);
  else {
    let n = e._handlers || (e._handlers = {});
    n[t] = (n[t] || cj).concat(r);
  }
};
function iR(e, t) {
  return e._handlers && e._handlers[t] || cj;
}
function cn(e, t, r) {
  if (e.removeEventListener)
    e.removeEventListener(t, r, !1);
  else if (e.detachEvent)
    e.detachEvent("on" + t, r);
  else {
    let n = e._handlers, o = n && n[t];
    if (o) {
      let s = _r(o, r);
      s > -1 && (n[t] = o.slice(0, s).concat(o.slice(s + 1)));
    }
  }
}
function Ht(e, t) {
  let r = iR(e, t);
  if (!r.length)
    return;
  let n = Array.prototype.slice.call(arguments, 2);
  for (let o = 0; o < r.length; ++o)
    r[o].apply(null, n);
}
function Qt(e, t, r) {
  return typeof t == "string" && (t = { type: t, preventDefault: function() {
    this.defaultPrevented = !0;
  } }), Ht(e, r || t.type, e, t), VS(t) || t.codemirrorIgnore;
}
function dj(e) {
  let t = e._handlers && e._handlers.cursorActivity;
  if (!t)
    return;
  let r = e.curOp.cursorActivityHandlers || (e.curOp.cursorActivityHandlers = []);
  for (let n = 0; n < t.length; ++n)
    _r(r, t[n]) == -1 && r.push(t[n]);
}
function An(e, t) {
  return iR(e, t).length > 0;
}
function wu(e) {
  e.prototype.on = function(t, r) {
    Ve(this, t, r);
  }, e.prototype.off = function(t, r) {
    cn(this, t, r);
  };
}
function Br(e) {
  e.preventDefault ? e.preventDefault() : e.returnValue = !1;
}
function hj(e) {
  e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0;
}
function VS(e) {
  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == !1;
}
function Zf(e) {
  Br(e), hj(e);
}
function oR(e) {
  return e.target || e.srcElement;
}
function pj(e) {
  let t = e.which;
  return t == null && (e.button & 1 ? t = 1 : e.button & 2 ? t = 3 : e.button & 4 && (t = 2)), Rn && e.ctrlKey && t == 1 && (t = 3), t;
}
var bce = function() {
  if (dt && kt < 9)
    return !1;
  let e = He("div");
  return "draggable" in e || "dragDrop" in e;
}(), _0;
function yce(e) {
  if (_0 == null) {
    let r = He("span", "​");
    hn(e, He("span", [r, document.createTextNode("x")])), e.firstChild.offsetHeight != 0 && (_0 = r.offsetWidth <= 1 && r.offsetHeight > 2 && !(dt && kt < 8));
  }
  let t = _0 ? He("span", "​") : He("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px");
  return t.setAttribute("cm-text", ""), t;
}
var w0;
function vce(e) {
  if (w0 != null)
    return w0;
  let t = hn(e, document.createTextNode("AخA")), r = Na(t, 0, 1).getBoundingClientRect(), n = Na(t, 1, 2).getBoundingClientRect();
  return us(e), !r || r.left == r.right ? !1 : w0 = n.right - r.right < 3;
}
var sR = `

b`.split(/\n/).length != 3 ? (e) => {
  let t = 0, r = [], n = e.length;
  for (; t <= n; ) {
    let o = e.indexOf(`
`, t);
    o == -1 && (o = e.length);
    let s = e.slice(t, e.charAt(o - 1) == "\r" ? o - 1 : o), a = s.indexOf("\r");
    a != -1 ? (r.push(s.slice(0, a)), t += a + 1) : (r.push(s), t = o + 1);
  }
  return r;
} : (e) => e.split(/\r\n?|\n/), mce = window.getSelection ? (e) => {
  try {
    return e.selectionStart != e.selectionEnd;
  } catch {
    return !1;
  }
} : (e) => {
  let t;
  try {
    t = e.ownerDocument.selection.createRange();
  } catch {
  }
  return !t || t.parentElement() != e ? !1 : t.compareEndPoints("StartToEnd", t) != 0;
}, _ce = (() => {
  let e = He("div");
  return "oncopy" in e ? !0 : (e.setAttribute("oncopy", "return;"), typeof e.oncopy == "function");
})(), S0 = null;
function wce(e) {
  if (S0 != null)
    return S0;
  let t = hn(e, He("span", "x")), r = t.getBoundingClientRect(), n = Na(t, 0, 1).getBoundingClientRect();
  return S0 = Math.abs(r.left - n.left) > 1;
}
var aR = {}, Rl = {};
function Sce(e, t) {
  arguments.length > 2 && (t.dependencies = Array.prototype.slice.call(arguments, 2)), aR[e] = t;
}
function Ece(e, t) {
  Rl[e] = t;
}
function Mh(e) {
  if (typeof e == "string" && Rl.hasOwnProperty(e))
    e = Rl[e];
  else if (e && typeof e.name == "string" && Rl.hasOwnProperty(e.name)) {
    let t = Rl[e.name];
    typeof t == "string" && (t = { name: t }), e = uj(t, e), e.name = t.name;
  } else {
    if (typeof e == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(e))
      return Mh("application/xml");
    if (typeof e == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(e))
      return Mh("application/json");
  }
  return typeof e == "string" ? { name: e } : e || { name: "null" };
}
function lR(e, t) {
  t = Mh(t);
  let r = aR[t.name];
  if (!r)
    return lR(e, "text/plain");
  let n = r(e, t);
  if (Fl.hasOwnProperty(t.name)) {
    let o = Fl[t.name];
    for (let s in o)
      o.hasOwnProperty(s) && (n.hasOwnProperty(s) && (n["_" + s] = n[s]), n[s] = o[s]);
  }
  if (n.name = t.name, t.helperType && (n.helperType = t.helperType), t.modeProps)
    for (let o in t.modeProps)
      n[o] = t.modeProps[o];
  return n;
}
var Fl = {};
function xce(e, t) {
  let r = Fl.hasOwnProperty(e) ? Fl[e] : Fl[e] = {};
  ka(t, r);
}
function ba(e, t) {
  if (t === !0)
    return t;
  if (e.copyState)
    return e.copyState(t);
  let r = {};
  for (let n in t) {
    let o = t[n];
    o instanceof Array && (o = o.concat([])), r[n] = o;
  }
  return r;
}
function uR(e, t) {
  let r;
  for (; e.innerMode && (r = e.innerMode(t), !(!r || r.mode == e)); )
    t = r.state, e = r.mode;
  return r || { mode: e, state: t };
}
function gj(e, t, r) {
  return e.startState ? e.startState(t, r) : !0;
}
var Rce = class {
  constructor(e, t, r) {
    this.pos = this.start = 0, this.string = e, this.tabSize = t || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0, this.lineOracle = r;
  }
  eol() {
    return this.pos >= this.string.length;
  }
  sol() {
    return this.pos == this.lineStart;
  }
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  eat(e) {
    let t = this.string.charAt(this.pos), r;
    if (typeof e == "string" ? r = t == e : r = t && (e.test ? e.test(t) : e(t)), r)
      return ++this.pos, t;
  }
  eatWhile(e) {
    let t = this.pos;
    for (; this.eat(e); )
      ;
    return this.pos > t;
  }
  eatSpace() {
    let e = this.pos;
    for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
      ++this.pos;
    return this.pos > e;
  }
  skipToEnd() {
    this.pos = this.string.length;
  }
  skipTo(e) {
    let t = this.string.indexOf(e, this.pos);
    if (t > -1)
      return this.pos = t, !0;
  }
  backUp(e) {
    this.pos -= e;
  }
  column() {
    return this.lastColumnPos < this.start && (this.lastColumnValue = wn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? wn(this.string, this.lineStart, this.tabSize) : 0);
  }
  indentation() {
    return wn(this.string, null, this.tabSize) - (this.lineStart ? wn(this.string, this.lineStart, this.tabSize) : 0);
  }
  match(e, t, r) {
    if (typeof e == "string") {
      let n = (s) => r ? s.toLowerCase() : s, o = this.string.substr(this.pos, e.length);
      if (n(o) == n(e))
        return t !== !1 && (this.pos += e.length), !0;
    } else {
      let n = this.string.slice(this.pos).match(e);
      return n && n.index > 0 ? null : (n && t !== !1 && (this.pos += n[0].length), n);
    }
  }
  current() {
    return this.string.slice(this.start, this.pos);
  }
  hideFirstChars(e, t) {
    this.lineStart += e;
    try {
      return t();
    } finally {
      this.lineStart -= e;
    }
  }
  lookAhead(e) {
    let t = this.lineOracle;
    return t && t.lookAhead(e);
  }
  baseToken() {
    let e = this.lineOracle;
    return e && e.baseToken(this.pos);
  }
}, Ag = Rce;
function Be(e, t) {
  if (t -= e.first, t < 0 || t >= e.size)
    throw new Error("There is no line " + (t + e.first) + " in the document.");
  let r = e;
  for (; !r.lines; )
    for (let n = 0; ; ++n) {
      let o = r.children[n], s = o.chunkSize();
      if (t < s) {
        r = o;
        break;
      }
      t -= s;
    }
  return r.lines[t];
}
function ya(e, t, r) {
  let n = [], o = t.line;
  return e.iter(t.line, r.line + 1, (s) => {
    let a = s.text;
    o == r.line && (a = a.slice(0, r.ch)), o == t.line && (a = a.slice(t.ch)), n.push(a), ++o;
  }), n;
}
function E0(e, t, r) {
  let n = [];
  return e.iter(t, r, (o) => {
    n.push(o.text);
  }), n;
}
function Ii(e, t) {
  let r = t - e.height;
  if (r)
    for (let n = e; n; n = n.parent)
      n.height += r;
}
function mt(e) {
  if (e.parent == null)
    return null;
  let t = e.parent, r = _r(t.lines, e);
  for (let n = t.parent; n; t = n, n = n.parent)
    for (let o = 0; n.children[o] != t; ++o)
      r += n.children[o].chunkSize();
  return r + t.first;
}
function Zs(e, t) {
  let r = e.first;
  e:
    do {
      for (let o = 0; o < e.children.length; ++o) {
        let s = e.children[o], a = s.height;
        if (t < a) {
          e = s;
          continue e;
        }
        t -= a, r += s.chunkSize();
      }
      return r;
    } while (!e.lines);
  let n = 0;
  for (; n < e.lines.length; ++n) {
    let o = e.lines[n], s = o.height;
    if (t < s)
      break;
    t -= s;
  }
  return r + n;
}
function ec(e, t) {
  return t >= e.first && t < e.first + e.size;
}
function fR(e, t) {
  return String(e.lineNumberFormatter(t + e.firstLineNumber));
}
function Ee(e, t, r = null) {
  if (!(this instanceof Ee))
    return new Ee(e, t, r);
  this.line = e, this.ch = t, this.sticky = r;
}
function Xe(e, t) {
  return e.line - t.line || e.ch - t.ch;
}
function zS(e, t) {
  return e.sticky == t.sticky && Xe(e, t) == 0;
}
function GS(e) {
  return Ee(e.line, e.ch);
}
function Tg(e, t) {
  return Xe(e, t) < 0 ? t : e;
}
function $g(e, t) {
  return Xe(e, t) < 0 ? e : t;
}
function bj(e, t) {
  return Math.max(e.first, Math.min(t, e.first + e.size - 1));
}
function Ye(e, t) {
  if (t.line < e.first)
    return Ee(e.first, 0);
  let r = e.first + e.size - 1;
  return t.line > r ? Ee(r, Be(e, r).text.length) : Ace(t, Be(e, t.line).text.length);
}
function Ace(e, t) {
  let r = e.ch;
  return r == null || r > t ? Ee(e.line, t) : r < 0 ? Ee(e.line, 0) : e;
}
function BC(e, t) {
  let r = [];
  for (let n = 0; n < t.length; n++)
    r[n] = Ye(e, t[n]);
  return r;
}
var Oh = class {
  constructor(e, t) {
    this.state = e, this.lookAhead = t;
  }
}, $f = class {
  constructor(e, t, r, n) {
    this.state = t, this.doc = e, this.line = r, this.maxLookAhead = n || 0, this.baseTokens = null, this.baseTokenPos = 1;
  }
  lookAhead(e) {
    let t = this.doc.getLine(this.line + e);
    return t != null && e > this.maxLookAhead && (this.maxLookAhead = e), t;
  }
  baseToken(e) {
    if (!this.baseTokens)
      return null;
    for (; this.baseTokens[this.baseTokenPos] <= e; )
      this.baseTokenPos += 2;
    let t = this.baseTokens[this.baseTokenPos + 1];
    return {
      type: t && t.replace(/( |^)overlay .*/, ""),
      size: this.baseTokens[this.baseTokenPos] - e
    };
  }
  nextLine() {
    this.line++, this.maxLookAhead > 0 && this.maxLookAhead--;
  }
  static fromSaved(e, t, r) {
    return t instanceof Oh ? new $f(e, ba(e.mode, t.state), r, t.lookAhead) : new $f(e, ba(e.mode, t), r);
  }
  save(e) {
    let t = e !== !1 ? ba(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new Oh(t, this.maxLookAhead) : t;
  }
};
function yj(e, t, r, n) {
  let o = [e.state.modeGen], s = {};
  HC(e, t.text, e.doc.mode, r, (l, u) => o.push(l, u), s, n);
  let a = r.state;
  for (let l = 0; l < e.state.overlays.length; ++l) {
    r.baseTokens = o;
    let u = e.state.overlays[l], f = 1, c = 0;
    r.state = !0, HC(e, t.text, u.mode, r, (d, h) => {
      let p = f;
      for (; c < d; ) {
        let v = o[f];
        v > d && o.splice(f, 1, d, o[f + 1], v), f += 2, c = Math.min(d, v);
      }
      if (h)
        if (u.opaque)
          o.splice(p, f - p, d, "overlay " + h), f = p + 2;
        else
          for (; p < f; p += 2) {
            let v = o[p + 1];
            o[p + 1] = (v ? v + " " : "") + "overlay " + h;
          }
    }, s), r.state = a, r.baseTokens = null, r.baseTokenPos = 1;
  }
  return { styles: o, classes: s.bgClass || s.textClass ? s : null };
}
function vj(e, t, r) {
  if (!t.styles || t.styles[0] != e.state.modeGen) {
    let n = Cc(e, mt(t)), o = t.text.length > e.options.maxHighlightLength && ba(e.doc.mode, n.state), s = yj(e, t, n);
    o && (n.state = o), t.stateAfter = n.save(!o), t.styles = s.styles, s.classes ? t.styleClasses = s.classes : t.styleClasses && (t.styleClasses = null), r === e.doc.highlightFrontier && (e.doc.modeFrontier = Math.max(e.doc.modeFrontier, ++e.doc.highlightFrontier));
  }
  return t.styles;
}
function Cc(e, t, r) {
  let n = e.doc, o = e.display;
  if (!n.mode.startState)
    return new $f(n, !0, t);
  let s = Tce(e, t, r), a = s > n.first && Be(n, s - 1).stateAfter, l = a ? $f.fromSaved(n, a, s) : new $f(n, gj(n.mode), s);
  return n.iter(s, t, (u) => {
    cR(e, u.text, l);
    let f = l.line;
    u.stateAfter = f == t - 1 || f % 5 == 0 || f >= o.viewFrom && f < o.viewTo ? l.save() : null, l.nextLine();
  }), r && (n.modeFrontier = l.line), l;
}
function cR(e, t, r, n) {
  let o = e.doc.mode, s = new Ag(t, e.options.tabSize, r);
  for (s.start = s.pos = n || 0, t == "" && mj(o, r.state); !s.eol(); )
    dR(o, s, r.state), s.start = s.pos;
}
function mj(e, t) {
  if (e.blankLine)
    return e.blankLine(t);
  if (!e.innerMode)
    return;
  let r = uR(e, t);
  if (r.mode.blankLine)
    return r.mode.blankLine(r.state);
}
function dR(e, t, r, n) {
  for (let o = 0; o < 10; o++) {
    n && (n[0] = uR(e, r).mode);
    let s = e.token(t, r);
    if (t.pos > t.start)
      return s;
  }
  throw new Error("Mode " + e.name + " failed to advance stream.");
}
var qC = class {
  constructor(e, t, r) {
    this.start = e.start, this.end = e.pos, this.string = e.current(), this.type = t || null, this.state = r;
  }
};
function WC(e, t, r, n) {
  let o = e.doc, s = o.mode, a;
  t = Ye(o, t);
  let l = Be(o, t.line), u = Cc(e, t.line, r), f = new Ag(l.text, e.options.tabSize, u), c;
  for (n && (c = []); (n || f.pos < t.ch) && !f.eol(); )
    f.start = f.pos, a = dR(s, f, u.state), n && c.push(new qC(f, a, ba(o.mode, u.state)));
  return n ? c : new qC(f, a, u.state);
}
function UC(e, t) {
  if (e)
    for (; ; ) {
      let r = e.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!r)
        break;
      e = e.slice(0, r.index) + e.slice(r.index + r[0].length);
      let n = r[1] ? "bgClass" : "textClass";
      t[n] == null ? t[n] = r[2] : new RegExp("(?:^|\\s)" + r[2] + "(?:$|\\s)").test(t[n]) || (t[n] += " " + r[2]);
    }
  return e;
}
function HC(e, t, r, n, o, s, a) {
  let l = r.flattenSpans;
  l == null && (l = e.options.flattenSpans);
  let u = 0, f = null, c = new Ag(t, e.options.tabSize, n), d, h = e.options.addModeClass && [null];
  for (t == "" && UC(mj(r, n.state), s); !c.eol(); ) {
    if (c.pos > e.options.maxHighlightLength ? (l = !1, a && cR(e, t, n, c.pos), c.pos = t.length, d = null) : d = UC(dR(r, c, n.state, h), s), h) {
      let p = h[0].name;
      p && (d = "m-" + (d ? p + " " + d : p));
    }
    if (!l || f != d) {
      for (; u < c.start; )
        u = Math.min(c.start, u + 5e3), o(u, f);
      f = d;
    }
    c.start = c.pos;
  }
  for (; u < c.pos; ) {
    let p = Math.min(c.pos, u + 5e3);
    o(p, f), u = p;
  }
}
function Tce(e, t, r) {
  let n, o, s = e.doc, a = r ? -1 : t - (e.doc.mode.innerMode ? 1e3 : 100);
  for (let l = t; l > a; --l) {
    if (l <= s.first)
      return s.first;
    let u = Be(s, l - 1), f = u.stateAfter;
    if (f && (!r || l + (f instanceof Oh ? f.lookAhead : 0) <= s.modeFrontier))
      return l;
    let c = wn(u.text, null, e.options.tabSize);
    (o == null || n > c) && (o = l - 1, n = c);
  }
  return o;
}
function $ce(e, t) {
  if (e.modeFrontier = Math.min(e.modeFrontier, t), e.highlightFrontier < t - 10)
    return;
  let r = e.first;
  for (let n = t - 1; n > r; n--) {
    let o = Be(e, n).stateAfter;
    if (o && (!(o instanceof Oh) || n + o.lookAhead < t)) {
      r = n + 1;
      break;
    }
  }
  e.highlightFrontier = Math.min(e.highlightFrontier, r);
}
var _j = !1, yo = !1;
function Nce() {
  _j = !0;
}
function kce() {
  yo = !0;
}
function Ng(e, t, r) {
  this.marker = e, this.from = t, this.to = r;
}
function tc(e, t) {
  if (e)
    for (let r = 0; r < e.length; ++r) {
      let n = e[r];
      if (n.marker == t)
        return n;
    }
}
function Cce(e, t) {
  let r;
  for (let n = 0; n < e.length; ++n)
    e[n] != t && (r || (r = [])).push(e[n]);
  return r;
}
function Ice(e, t) {
  e.markedSpans = e.markedSpans ? e.markedSpans.concat([t]) : [t], t.marker.attachLine(e);
}
function Mce(e, t, r) {
  let n;
  if (e)
    for (let o = 0; o < e.length; ++o) {
      let s = e[o], a = s.marker;
      if (s.from == null || (a.inclusiveLeft ? s.from <= t : s.from < t) || s.from == t && a.type == "bookmark" && (!r || !s.marker.insertLeft)) {
        let u = s.to == null || (a.inclusiveRight ? s.to >= t : s.to > t);
        (n || (n = [])).push(new Ng(a, s.from, u ? null : s.to));
      }
    }
  return n;
}
function Oce(e, t, r) {
  let n;
  if (e)
    for (let o = 0; o < e.length; ++o) {
      let s = e[o], a = s.marker;
      if (s.to == null || (a.inclusiveRight ? s.to >= t : s.to > t) || s.from == t && a.type == "bookmark" && (!r || s.marker.insertLeft)) {
        let u = s.from == null || (a.inclusiveLeft ? s.from <= t : s.from < t);
        (n || (n = [])).push(new Ng(a, u ? null : s.from - t, s.to == null ? null : s.to - t));
      }
    }
  return n;
}
function KS(e, t) {
  if (t.full)
    return null;
  let r = ec(e, t.from.line) && Be(e, t.from.line).markedSpans, n = ec(e, t.to.line) && Be(e, t.to.line).markedSpans;
  if (!r && !n)
    return null;
  let o = t.from.ch, s = t.to.ch, a = Xe(t.from, t.to) == 0, l = Mce(r, o, a), u = Oce(n, s, a), f = t.text.length == 1, c = vt(t.text).length + (f ? o : 0);
  if (l)
    for (let h = 0; h < l.length; ++h) {
      let p = l[h];
      if (p.to == null) {
        let v = tc(u, p.marker);
        v ? f && (p.to = v.to == null ? null : v.to + c) : p.to = o;
      }
    }
  if (u)
    for (let h = 0; h < u.length; ++h) {
      let p = u[h];
      p.to != null && (p.to += c), p.from == null ? tc(l, p.marker) || (p.from = c, f && (l || (l = [])).push(p)) : (p.from += c, f && (l || (l = [])).push(p));
    }
  l && (l = VC(l)), u && u != l && (u = VC(u));
  let d = [l];
  if (!f) {
    let h = t.text.length - 2, p;
    if (h > 0 && l)
      for (let v = 0; v < l.length; ++v)
        l[v].to == null && (p || (p = [])).push(new Ng(l[v].marker, null, null));
    for (let v = 0; v < h; ++v)
      d.push(p);
    d.push(u);
  }
  return d;
}
function VC(e) {
  for (let t = 0; t < e.length; ++t) {
    let r = e[t];
    r.from != null && r.from == r.to && r.marker.clearWhenEmpty !== !1 && e.splice(t--, 1);
  }
  return e.length ? e : null;
}
function Lce(e, t, r) {
  let n = null;
  if (e.iter(t.line, r.line + 1, (s) => {
    if (s.markedSpans)
      for (let a = 0; a < s.markedSpans.length; ++a) {
        let l = s.markedSpans[a].marker;
        l.readOnly && (!n || _r(n, l) == -1) && (n || (n = [])).push(l);
      }
  }), !n)
    return null;
  let o = [{ from: t, to: r }];
  for (let s = 0; s < n.length; ++s) {
    let a = n[s], l = a.find(0);
    for (let u = 0; u < o.length; ++u) {
      let f = o[u];
      if (Xe(f.to, l.from) < 0 || Xe(f.from, l.to) > 0)
        continue;
      let c = [u, 1], d = Xe(f.from, l.from), h = Xe(f.to, l.to);
      (d < 0 || !a.inclusiveLeft && !d) && c.push({ from: f.from, to: l.from }), (h > 0 || !a.inclusiveRight && !h) && c.push({ from: l.to, to: f.to }), o.splice.apply(o, c), u += c.length - 3;
    }
  }
  return o;
}
function wj(e) {
  let t = e.markedSpans;
  if (t) {
    for (let r = 0; r < t.length; ++r)
      t[r].marker.detachLine(e);
    e.markedSpans = null;
  }
}
function Sj(e, t) {
  if (t) {
    for (let r = 0; r < t.length; ++r)
      t[r].marker.attachLine(e);
    e.markedSpans = t;
  }
}
function Lh(e) {
  return e.inclusiveLeft ? -1 : 0;
}
function Ph(e) {
  return e.inclusiveRight ? 1 : 0;
}
function hR(e, t) {
  let r = e.lines.length - t.lines.length;
  if (r != 0)
    return r;
  let n = e.find(), o = t.find(), s = Xe(n.from, o.from) || Lh(e) - Lh(t);
  if (s)
    return -s;
  let a = Xe(n.to, o.to) || Ph(e) - Ph(t);
  return a || t.id - e.id;
}
function Ej(e, t) {
  let r = yo && e.markedSpans, n;
  if (r)
    for (let o, s = 0; s < r.length; ++s)
      o = r[s], o.marker.collapsed && (t ? o.from : o.to) == null && (!n || hR(n, o.marker) < 0) && (n = o.marker);
  return n;
}
function xj(e) {
  return Ej(e, !0);
}
function kg(e) {
  return Ej(e, !1);
}
function Pce(e, t) {
  let r = yo && e.markedSpans, n;
  if (r)
    for (let o = 0; o < r.length; ++o) {
      let s = r[o];
      s.marker.collapsed && (s.from == null || s.from < t) && (s.to == null || s.to > t) && (!n || hR(n, s.marker) < 0) && (n = s.marker);
    }
  return n;
}
function zC(e, t, r, n, o) {
  let s = Be(e, t), a = yo && s.markedSpans;
  if (a)
    for (let l = 0; l < a.length; ++l) {
      let u = a[l];
      if (!u.marker.collapsed)
        continue;
      let f = u.marker.find(0), c = Xe(f.from, r) || Lh(u.marker) - Lh(o), d = Xe(f.to, n) || Ph(u.marker) - Ph(o);
      if (!(c >= 0 && d <= 0 || c <= 0 && d >= 0) && (c <= 0 && (u.marker.inclusiveRight && o.inclusiveLeft ? Xe(f.to, r) >= 0 : Xe(f.to, r) > 0) || c >= 0 && (u.marker.inclusiveRight && o.inclusiveLeft ? Xe(f.from, n) <= 0 : Xe(f.from, n) < 0)))
        return !0;
    }
}
function Mi(e) {
  let t;
  for (; t = xj(e); )
    e = t.find(-1, !0).line;
  return e;
}
function Dce(e) {
  let t;
  for (; t = kg(e); )
    e = t.find(1, !0).line;
  return e;
}
function Fce(e) {
  let t, r;
  for (; t = kg(e); )
    e = t.find(1, !0).line, (r || (r = [])).push(e);
  return r;
}
function pR(e, t) {
  let r = Be(e, t), n = Mi(r);
  return r == n ? t : mt(n);
}
function Rj(e, t) {
  if (t > e.lastLine())
    return t;
  let r = Be(e, t), n;
  if (!cs(e, r))
    return t;
  for (; n = kg(r); )
    r = n.find(1, !0).line;
  return mt(r) + 1;
}
function cs(e, t) {
  let r = yo && t.markedSpans;
  if (r) {
    for (let n, o = 0; o < r.length; ++o)
      if (n = r[o], !!n.marker.collapsed) {
        if (n.from == null)
          return !0;
        if (!n.marker.widgetNode && n.from == 0 && n.marker.inclusiveLeft && YS(e, t, n))
          return !0;
      }
  }
}
function YS(e, t, r) {
  if (r.to == null) {
    let n = r.marker.find(1, !0);
    return YS(e, n.line, tc(n.line.markedSpans, r.marker));
  }
  if (r.marker.inclusiveRight && r.to == t.text.length)
    return !0;
  for (let n, o = 0; o < t.markedSpans.length; ++o)
    if (n = t.markedSpans[o], n.marker.collapsed && !n.marker.widgetNode && n.from == r.to && (n.to == null || n.to != r.from) && (n.marker.inclusiveLeft || r.marker.inclusiveRight) && YS(e, t, n))
      return !0;
}
function vo(e) {
  e = Mi(e);
  let t = 0, r = e.parent;
  for (let n = 0; n < r.lines.length; ++n) {
    let o = r.lines[n];
    if (o == e)
      break;
    t += o.height;
  }
  for (let n = r.parent; n; r = n, n = r.parent)
    for (let o = 0; o < n.children.length; ++o) {
      let s = n.children[o];
      if (s == r)
        break;
      t += s.height;
    }
  return t;
}
function Dh(e) {
  if (e.height == 0)
    return 0;
  let t = e.text.length, r, n = e;
  for (; r = xj(n); ) {
    let o = r.find(0, !0);
    n = o.from.line, t += o.from.ch - o.to.ch;
  }
  for (n = e; r = kg(n); ) {
    let o = r.find(0, !0);
    t -= n.text.length - o.from.ch, n = o.to.line, t += n.text.length - o.to.ch;
  }
  return t;
}
function gR(e) {
  let t = e.display, r = e.doc;
  t.maxLine = Be(r, r.first), t.maxLineLength = Dh(t.maxLine), t.maxLineChanged = !0, r.iter((n) => {
    let o = Dh(n);
    o > t.maxLineLength && (t.maxLineLength = o, t.maxLine = n);
  });
}
var rc = class {
  constructor(e, t, r) {
    this.text = e, Sj(this, t), this.height = r ? r(this) : 1;
  }
  lineNo() {
    return mt(this);
  }
};
wu(rc);
function jce(e, t, r, n) {
  e.text = t, e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null), e.order != null && (e.order = null), wj(e), Sj(e, r);
  let o = n ? n(e) : 1;
  o != e.height && Ii(e, o);
}
function Bce(e) {
  e.parent = null, wj(e);
}
var qce = {}, Wce = {};
function GC(e, t) {
  if (!e || /^\s*$/.test(e))
    return null;
  let r = t.addModeClass ? Wce : qce;
  return r[e] || (r[e] = e.replace(/\S+/g, "cm-$&"));
}
function Aj(e, t) {
  let r = Dl("span", null, null, Nr ? "padding-right: .1px" : null), n = {
    pre: Dl("pre", [r], "CodeMirror-line"),
    content: r,
    col: 0,
    pos: 0,
    cm: e,
    trailingSpace: !1,
    splitSpaces: e.getOption("lineWrapping")
  };
  t.measure = {};
  for (let o = 0; o <= (t.rest ? t.rest.length : 0); o++) {
    let s = o ? t.rest[o - 1] : t.line, a;
    n.pos = 0, n.addToken = Hce, vce(e.display.measure) && (a = $o(s, e.doc.direction)) && (n.addToken = zce(n.addToken, a)), n.map = [];
    let l = t != e.display.externalMeasured && mt(s);
    Gce(s, n, vj(e, s, l)), s.styleClasses && (s.styleClasses.bgClass && (n.bgClass = v0(s.styleClasses.bgClass, n.bgClass || "")), s.styleClasses.textClass && (n.textClass = v0(s.styleClasses.textClass, n.textClass || ""))), n.map.length == 0 && n.map.push(0, 0, n.content.appendChild(yce(e.display.measure))), o == 0 ? (t.measure.map = n.map, t.measure.cache = {}) : ((t.measure.maps || (t.measure.maps = [])).push(n.map), (t.measure.caches || (t.measure.caches = [])).push({}));
  }
  if (Nr) {
    let o = n.content.lastChild;
    (/\bcm-tab\b/.test(o.className) || o.querySelector && o.querySelector(".cm-tab")) && (n.content.className = "cm-tab-wrap-hack");
  }
  return Ht(e, "renderLine", e, t.line, n.pre), n.pre.className && (n.textClass = v0(n.pre.className, n.textClass || "")), n;
}
function Uce(e) {
  let t = He("span", "•", "cm-invalidchar");
  return t.title = "\\u" + e.charCodeAt(0).toString(16), t.setAttribute("aria-label", t.title), t;
}
function Hce(e, t, r, n, o, s, a) {
  if (!t)
    return;
  let l = e.splitSpaces ? Vce(t, e.trailingSpace) : t, u = e.cm.state.specialChars, f = !1, c;
  if (!u.test(t))
    e.col += t.length, c = document.createTextNode(l), e.map.push(e.pos, e.pos + t.length, c), dt && kt < 9 && (f = !0), e.pos += t.length;
  else {
    c = document.createDocumentFragment();
    let d = 0;
    for (; ; ) {
      u.lastIndex = d;
      let h = u.exec(t), p = h ? h.index - d : t.length - d;
      if (p) {
        let y = document.createTextNode(l.slice(d, d + p));
        dt && kt < 9 ? c.appendChild(He("span", [y])) : c.appendChild(y), e.map.push(e.pos, e.pos + p, y), e.col += p, e.pos += p;
      }
      if (!h)
        break;
      d += p + 1;
      let v;
      if (h[0] == "	") {
        let y = e.cm.options.tabSize, w = y - e.col % y;
        v = c.appendChild(He("span", nR(w), "cm-tab")), v.setAttribute("role", "presentation"), v.setAttribute("cm-text", "	"), e.col += w;
      } else
        h[0] == "\r" || h[0] == `
` ? (v = c.appendChild(He("span", h[0] == "\r" ? "␍" : "␤", "cm-invalidchar")), v.setAttribute("cm-text", h[0]), e.col += 1) : (v = e.cm.options.specialCharPlaceholder(h[0]), v.setAttribute("cm-text", h[0]), dt && kt < 9 ? c.appendChild(He("span", [v])) : c.appendChild(v), e.col += 1);
      e.map.push(e.pos, e.pos + 1, v), e.pos++;
    }
  }
  if (e.trailingSpace = l.charCodeAt(t.length - 1) == 32, r || n || o || f || s || a) {
    let d = r || "";
    n && (d += n), o && (d += o);
    let h = He("span", [c], d, s);
    if (a)
      for (let p in a)
        a.hasOwnProperty(p) && p != "style" && p != "class" && h.setAttribute(p, a[p]);
    return e.content.appendChild(h);
  }
  e.content.appendChild(c);
}
function Vce(e, t) {
  if (e.length > 1 && !/  /.test(e))
    return e;
  let r = t, n = "";
  for (let o = 0; o < e.length; o++) {
    let s = e.charAt(o);
    s == " " && r && (o == e.length - 1 || e.charCodeAt(o + 1) == 32) && (s = " "), n += s, r = s == " ";
  }
  return n;
}
function zce(e, t) {
  return (r, n, o, s, a, l, u) => {
    o = o ? o + " cm-force-border" : "cm-force-border";
    let f = r.pos, c = f + n.length;
    for (; ; ) {
      let d;
      for (let h = 0; h < t.length && (d = t[h], !(d.to > f && d.from <= f)); h++)
        ;
      if (d.to >= c)
        return e(r, n, o, s, a, l, u);
      e(r, n.slice(0, d.to - f), o, s, null, l, u), s = null, n = n.slice(d.to - f), f = d.to;
    }
  };
}
function KC(e, t, r, n) {
  let o = !n && r.widgetNode;
  o && e.map.push(e.pos, e.pos + t, o), !n && e.cm.display.input.needsContentAttribute && (o || (o = e.content.appendChild(document.createElement("span"))), o.setAttribute("cm-marker", r.id)), o && (e.cm.display.input.setUneditable(o), e.content.appendChild(o)), e.pos += t, e.trailingSpace = !1;
}
function Gce(e, t, r) {
  let n = e.markedSpans, o = e.text, s = 0;
  if (!n) {
    for (let x = 1; x < r.length; x += 2)
      t.addToken(t, o.slice(s, s = r[x]), GC(r[x + 1], t.cm.options));
    return;
  }
  let a = o.length, l = 0, u = 1, f = "", c, d, h = 0, p, v, y, w, S;
  for (; ; ) {
    if (h == l) {
      p = v = y = d = "", S = null, w = null, h = 1 / 0;
      let E = [], N;
      for (let C = 0; C < n.length; ++C) {
        let j = n[C], J = j.marker;
        if (J.type == "bookmark" && j.from == l && J.widgetNode)
          E.push(J);
        else if (j.from <= l && (j.to == null || j.to > l || J.collapsed && j.to == l && j.from == l)) {
          if (j.to != null && j.to != l && h > j.to && (h = j.to, v = ""), J.className && (p += " " + J.className), J.css && (d = (d ? d + ";" : "") + J.css), J.startStyle && j.from == l && (y += " " + J.startStyle), J.endStyle && j.to == h && (N || (N = [])).push(J.endStyle, j.to), J.title && ((S || (S = {})).title = J.title), J.attributes)
            for (let z in J.attributes)
              (S || (S = {}))[z] = J.attributes[z];
          J.collapsed && (!w || hR(w.marker, J) < 0) && (w = j);
        } else
          j.from > l && h > j.from && (h = j.from);
      }
      if (N)
        for (let C = 0; C < N.length; C += 2)
          N[C + 1] == h && (v += " " + N[C]);
      if (!w || w.from == l)
        for (let C = 0; C < E.length; ++C)
          KC(t, 0, E[C]);
      if (w && (w.from || 0) == l) {
        if (KC(t, (w.to == null ? a + 1 : w.to) - l, w.marker, w.from == null), w.to == null)
          return;
        w.to == l && (w = !1);
      }
    }
    if (l >= a)
      break;
    let x = Math.min(a, h);
    for (; ; ) {
      if (f) {
        let E = l + f.length;
        if (!w) {
          let N = E > x ? f.slice(0, x - l) : f;
          t.addToken(t, N, c ? c + p : p, y, l + N.length == h ? v : "", d, S);
        }
        if (E >= x) {
          f = f.slice(x - l), l = x;
          break;
        }
        l = E, y = "";
      }
      f = o.slice(s, s = r[u++]), c = GC(r[u++], t.cm.options);
    }
  }
}
function Tj(e, t, r) {
  this.line = t, this.rest = Fce(t), this.size = this.rest ? mt(vt(this.rest)) - r + 1 : 1, this.node = this.text = null, this.hidden = cs(e, t);
}
function Yd(e, t, r) {
  let n = [], o;
  for (let s = t; s < r; s = o) {
    let a = new Tj(e.doc, Be(e.doc, s), s);
    o = s + a.size, n.push(a);
  }
  return n;
}
var jl = null;
function Kce(e) {
  jl ? jl.ops.push(e) : e.ownsGroup = jl = {
    ops: [e],
    delayedCallbacks: []
  };
}
function Yce(e) {
  let t = e.delayedCallbacks, r = 0;
  do {
    for (; r < t.length; r++)
      t[r].call(null);
    for (let n = 0; n < e.ops.length; n++) {
      let o = e.ops[n];
      if (o.cursorActivityHandlers)
        for (; o.cursorActivityCalled < o.cursorActivityHandlers.length; )
          o.cursorActivityHandlers[o.cursorActivityCalled++].call(null, o.cm);
    }
  } while (r < t.length);
}
function Xce(e, t) {
  let r = e.ownsGroup;
  if (r)
    try {
      Yce(r);
    } finally {
      jl = null, t(r);
    }
}
var Nf = null;
function ir(e, t) {
  let r = iR(e, t);
  if (!r.length)
    return;
  let n = Array.prototype.slice.call(arguments, 2), o;
  jl ? o = jl.delayedCallbacks : Nf ? o = Nf : (o = Nf = [], setTimeout(Jce, 0));
  for (let s = 0; s < r.length; ++s)
    o.push(() => r[s].apply(null, n));
}
function Jce() {
  let e = Nf;
  Nf = null;
  for (let t = 0; t < e.length; ++t)
    e[t]();
}
function $j(e, t, r, n) {
  for (let o = 0; o < t.changes.length; o++) {
    let s = t.changes[o];
    s == "text" ? Zce(e, t) : s == "gutter" ? kj(e, t, r, n) : s == "class" ? bR(e, t) : s == "widget" && ede(e, t, n);
  }
  t.changes = null;
}
function nc(e) {
  return e.node == e.text && (e.node = He("div", null, null, "position: relative"), e.text.parentNode && e.text.parentNode.replaceChild(e.node, e.text), e.node.appendChild(e.text), dt && kt < 8 && (e.node.style.zIndex = 2)), e.node;
}
function Qce(e, t) {
  let r = t.bgClass ? t.bgClass + " " + (t.line.bgClass || "") : t.line.bgClass;
  if (r && (r += " CodeMirror-linebackground"), t.background)
    r ? t.background.className = r : (t.background.parentNode.removeChild(t.background), t.background = null);
  else if (r) {
    let n = nc(t);
    t.background = n.insertBefore(He("div", null, r), n.firstChild), e.display.input.setUneditable(t.background);
  }
}
function Nj(e, t) {
  let r = e.display.externalMeasured;
  return r && r.line == t.line ? (e.display.externalMeasured = null, t.measure = r.measure, r.built) : Aj(e, t);
}
function Zce(e, t) {
  let r = t.text.className, n = Nj(e, t);
  t.text == t.node && (t.node = n.pre), t.text.parentNode.replaceChild(n.pre, t.text), t.text = n.pre, n.bgClass != t.bgClass || n.textClass != t.textClass ? (t.bgClass = n.bgClass, t.textClass = n.textClass, bR(e, t)) : r && (t.text.className = r);
}
function bR(e, t) {
  Qce(e, t), t.line.wrapClass ? nc(t).className = t.line.wrapClass : t.node != t.text && (t.node.className = "");
  let r = t.textClass ? t.textClass + " " + (t.line.textClass || "") : t.line.textClass;
  t.text.className = r || "";
}
function kj(e, t, r, n) {
  if (t.gutter && (t.node.removeChild(t.gutter), t.gutter = null), t.gutterBackground && (t.node.removeChild(t.gutterBackground), t.gutterBackground = null), t.line.gutterClass) {
    let s = nc(t);
    t.gutterBackground = He("div", null, "CodeMirror-gutter-background " + t.line.gutterClass, `left: ${e.options.fixedGutter ? n.fixedPos : -n.gutterTotalWidth}px; width: ${n.gutterTotalWidth}px`), e.display.input.setUneditable(t.gutterBackground), s.insertBefore(t.gutterBackground, t.text);
  }
  let o = t.line.gutterMarkers;
  if (e.options.lineNumbers || o) {
    let s = nc(t), a = t.gutter = He("div", null, "CodeMirror-gutter-wrapper", `left: ${e.options.fixedGutter ? n.fixedPos : -n.gutterTotalWidth}px`);
    if (a.setAttribute("aria-hidden", "true"), e.display.input.setUneditable(a), s.insertBefore(a, t.text), t.line.gutterClass && (a.className += " " + t.line.gutterClass), e.options.lineNumbers && (!o || !o["CodeMirror-linenumbers"]) && (t.lineNumber = a.appendChild(He("div", fR(e.options, r), "CodeMirror-linenumber CodeMirror-gutter-elt", `left: ${n.gutterLeft["CodeMirror-linenumbers"]}px; width: ${e.display.lineNumInnerWidth}px`))), o)
      for (let l = 0; l < e.display.gutterSpecs.length; ++l) {
        let u = e.display.gutterSpecs[l].className, f = o.hasOwnProperty(u) && o[u];
        f && a.appendChild(He("div", [f], "CodeMirror-gutter-elt", `left: ${n.gutterLeft[u]}px; width: ${n.gutterWidth[u]}px`));
      }
  }
}
function ede(e, t, r) {
  t.alignable && (t.alignable = null);
  let n = eu("CodeMirror-linewidget");
  for (let o = t.node.firstChild, s; o; o = s)
    s = o.nextSibling, n.test(o.className) && t.node.removeChild(o);
  Cj(e, t, r);
}
function tde(e, t, r, n) {
  let o = Nj(e, t);
  return t.text = t.node = o.pre, o.bgClass && (t.bgClass = o.bgClass), o.textClass && (t.textClass = o.textClass), bR(e, t), kj(e, t, r, n), Cj(e, t, n), t.node;
}
function Cj(e, t, r) {
  if (YC(e, t.line, t, r, !0), t.rest)
    for (let n = 0; n < t.rest.length; n++)
      YC(e, t.rest[n], t, r, !1);
}
function YC(e, t, r, n, o) {
  if (!t.widgets)
    return;
  let s = nc(r);
  for (let a = 0, l = t.widgets; a < l.length; ++a) {
    let u = l[a], f = He("div", [u.node], "CodeMirror-linewidget" + (u.className ? " " + u.className : ""));
    u.handleMouseEvents || f.setAttribute("cm-ignore-events", "true"), rde(u, f, r, n), e.display.input.setUneditable(f), o && u.above ? s.insertBefore(f, r.gutter || r.text) : s.appendChild(f), ir(u, "redraw");
  }
}
function rde(e, t, r, n) {
  if (e.noHScroll) {
    (r.alignable || (r.alignable = [])).push(t);
    let o = n.wrapperWidth;
    t.style.left = n.fixedPos + "px", e.coverGutter || (o -= n.gutterTotalWidth, t.style.paddingLeft = n.gutterTotalWidth + "px"), t.style.width = o + "px";
  }
  e.coverGutter && (t.style.zIndex = 5, t.style.position = "relative", e.noHScroll || (t.style.marginLeft = -n.gutterTotalWidth + "px"));
}
function ic(e) {
  if (e.height != null)
    return e.height;
  let t = e.doc.cm;
  if (!t)
    return 0;
  if (!fs(document.body, e.node)) {
    let r = "position: relative;";
    e.coverGutter && (r += "margin-left: -" + t.display.gutters.offsetWidth + "px;"), e.noHScroll && (r += "width: " + t.display.wrapper.clientWidth + "px;"), hn(t.display.measure, He("div", [e.node], null, r));
  }
  return e.height = e.node.parentNode.offsetHeight;
}
function mo(e, t) {
  for (let r = oR(t); r != e.wrapper; r = r.parentNode)
    if (!r || r.nodeType == 1 && r.getAttribute("cm-ignore-events") == "true" || r.parentNode == e.sizer && r != e.mover)
      return !0;
}
function Cg(e) {
  return e.lineSpace.offsetTop;
}
function yR(e) {
  return e.mover.offsetHeight - e.lineSpace.offsetHeight;
}
function Ij(e) {
  if (e.cachedPaddingH)
    return e.cachedPaddingH;
  let t = hn(e.measure, He("pre", "x", "CodeMirror-line-like")), r = window.getComputedStyle ? window.getComputedStyle(t) : t.currentStyle, n = { left: parseInt(r.paddingLeft), right: parseInt(r.paddingRight) };
  return !isNaN(n.left) && !isNaN(n.right) && (e.cachedPaddingH = n), n;
}
function Oi(e) {
  return lj - e.display.nativeBarWidth;
}
function tl(e) {
  return e.display.scroller.clientWidth - Oi(e) - e.display.barWidth;
}
function vR(e) {
  return e.display.scroller.clientHeight - Oi(e) - e.display.barHeight;
}
function nde(e, t, r) {
  let n = e.options.lineWrapping, o = n && tl(e);
  if (!t.measure.heights || n && t.measure.width != o) {
    let s = t.measure.heights = [];
    if (n) {
      t.measure.width = o;
      let a = t.text.firstChild.getClientRects();
      for (let l = 0; l < a.length - 1; l++) {
        let u = a[l], f = a[l + 1];
        Math.abs(u.bottom - f.bottom) > 2 && s.push((u.bottom + f.top) / 2 - r.top);
      }
    }
    s.push(r.bottom - r.top);
  }
}
function Mj(e, t, r) {
  if (e.line == t)
    return { map: e.measure.map, cache: e.measure.cache };
  for (let n = 0; n < e.rest.length; n++)
    if (e.rest[n] == t)
      return { map: e.measure.maps[n], cache: e.measure.caches[n] };
  for (let n = 0; n < e.rest.length; n++)
    if (mt(e.rest[n]) > r)
      return { map: e.measure.maps[n], cache: e.measure.caches[n], before: !0 };
}
function ide(e, t) {
  t = Mi(t);
  let r = mt(t), n = e.display.externalMeasured = new Tj(e.doc, t, r);
  n.lineN = r;
  let o = n.built = Aj(e, n);
  return n.text = o.pre, hn(e.display.lineMeasure, o.pre), n;
}
function Oj(e, t, r, n) {
  return Li(e, Su(e, t), r, n);
}
function mR(e, t) {
  if (t >= e.display.viewFrom && t < e.display.viewTo)
    return e.display.view[Ia(e, t)];
  let r = e.display.externalMeasured;
  if (r && t >= r.lineN && t < r.lineN + r.size)
    return r;
}
function Su(e, t) {
  let r = mt(t), n = mR(e, r);
  n && !n.text ? n = null : n && n.changes && ($j(e, n, r, SR(e)), e.curOp.forceUpdate = !0), n || (n = ide(e, t));
  let o = Mj(n, t, r);
  return {
    line: t,
    view: n,
    rect: null,
    map: o.map,
    cache: o.cache,
    before: o.before,
    hasHeights: !1
  };
}
function Li(e, t, r, n, o) {
  t.before && (r = -1);
  let s = r + (n || ""), a;
  return t.cache.hasOwnProperty(s) ? a = t.cache[s] : (t.rect || (t.rect = t.view.text.getBoundingClientRect()), t.hasHeights || (nde(e, t.view, t.rect), t.hasHeights = !0), a = sde(e, t, r, n), a.bogus || (t.cache[s] = a)), {
    left: a.left,
    right: a.right,
    top: o ? a.rtop : a.top,
    bottom: o ? a.rbottom : a.bottom
  };
}
var Lj = { left: 0, right: 0, top: 0, bottom: 0 };
function Pj(e, t, r) {
  let n, o, s, a, l, u;
  for (let f = 0; f < e.length; f += 3)
    if (l = e[f], u = e[f + 1], t < l ? (o = 0, s = 1, a = "left") : t < u ? (o = t - l, s = o + 1) : (f == e.length - 3 || t == u && e[f + 3] > t) && (s = u - l, o = s - 1, t >= u && (a = "right")), o != null) {
      if (n = e[f + 2], l == u && r == (n.insertLeft ? "left" : "right") && (a = r), r == "left" && o == 0)
        for (; f && e[f - 2] == e[f - 3] && e[f - 1].insertLeft; )
          n = e[(f -= 3) + 2], a = "left";
      if (r == "right" && o == u - l)
        for (; f < e.length - 3 && e[f + 3] == e[f + 4] && !e[f + 5].insertLeft; )
          n = e[(f += 3) + 2], a = "right";
      break;
    }
  return { node: n, start: o, end: s, collapse: a, coverStart: l, coverEnd: u };
}
function ode(e, t) {
  let r = Lj;
  if (t == "left")
    for (let n = 0; n < e.length && (r = e[n]).left == r.right; n++)
      ;
  else
    for (let n = e.length - 1; n >= 0 && (r = e[n]).left == r.right; n--)
      ;
  return r;
}
function sde(e, t, r, n) {
  let o = Pj(t.map, r, n), s = o.node, a = o.start, l = o.end, u = o.collapse, f;
  if (s.nodeType == 3) {
    for (let x = 0; x < 4; x++) {
      for (; a && HS(t.line.text.charAt(o.coverStart + a)); )
        --a;
      for (; o.coverStart + l < o.coverEnd && HS(t.line.text.charAt(o.coverStart + l)); )
        ++l;
      if (dt && kt < 9 && a == 0 && l == o.coverEnd - o.coverStart ? f = s.parentNode.getBoundingClientRect() : f = ode(Na(s, a, l).getClientRects(), n), f.left || f.right || a == 0)
        break;
      l = a, a = a - 1, u = "right";
    }
    dt && kt < 11 && (f = ade(e.display.measure, f));
  } else {
    a > 0 && (u = n = "right");
    let x;
    e.options.lineWrapping && (x = s.getClientRects()).length > 1 ? f = x[n == "right" ? x.length - 1 : 0] : f = s.getBoundingClientRect();
  }
  if (dt && kt < 9 && !a && (!f || !f.left && !f.right)) {
    let x = s.parentNode.getClientRects()[0];
    x ? f = { left: x.left, right: x.left + Eu(e.display), top: x.top, bottom: x.bottom } : f = Lj;
  }
  let c = f.top - t.rect.top, d = f.bottom - t.rect.top, h = (c + d) / 2, p = t.view.measure.heights, v = 0;
  for (; v < p.length - 1 && !(h < p[v]); v++)
    ;
  let y = v ? p[v - 1] : 0, w = p[v], S = {
    left: (u == "right" ? f.right : f.left) - t.rect.left,
    right: (u == "left" ? f.left : f.right) - t.rect.left,
    top: y,
    bottom: w
  };
  return !f.left && !f.right && (S.bogus = !0), e.options.singleCursorHeightPerLine || (S.rtop = c, S.rbottom = d), S;
}
function ade(e, t) {
  if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !wce(e))
    return t;
  let r = screen.logicalXDPI / screen.deviceXDPI, n = screen.logicalYDPI / screen.deviceYDPI;
  return {
    left: t.left * r,
    right: t.right * r,
    top: t.top * n,
    bottom: t.bottom * n
  };
}
function Dj(e) {
  if (e.measure && (e.measure.cache = {}, e.measure.heights = null, e.rest))
    for (let t = 0; t < e.rest.length; t++)
      e.measure.caches[t] = {};
}
function Fj(e) {
  e.display.externalMeasure = null, us(e.display.lineMeasure);
  for (let t = 0; t < e.display.view.length; t++)
    Dj(e.display.view[t]);
}
function oc(e) {
  Fj(e), e.display.cachedCharWidth = e.display.cachedTextHeight = e.display.cachedPaddingH = null, e.options.lineWrapping || (e.display.maxLineChanged = !0), e.display.lineNumChars = null;
}
function jj() {
  return wg && Eg ? -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) : window.pageXOffset || (document.documentElement || document.body).scrollLeft;
}
function Bj() {
  return wg && Eg ? -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) : window.pageYOffset || (document.documentElement || document.body).scrollTop;
}
function _R(e) {
  let t = 0;
  if (e.widgets)
    for (let r = 0; r < e.widgets.length; ++r)
      e.widgets[r].above && (t += ic(e.widgets[r]));
  return t;
}
function Ig(e, t, r, n, o) {
  if (!o) {
    let a = _R(t);
    r.top += a, r.bottom += a;
  }
  if (n == "line")
    return r;
  n || (n = "local");
  let s = vo(t);
  if (n == "local" ? s += Cg(e.display) : s -= e.display.viewOffset, n == "page" || n == "window") {
    let a = e.display.lineSpace.getBoundingClientRect();
    s += a.top + (n == "window" ? 0 : Bj());
    let l = a.left + (n == "window" ? 0 : jj());
    r.left += l, r.right += l;
  }
  return r.top += s, r.bottom += s, r;
}
function XC(e, t, r) {
  if (r == "div")
    return t;
  let n = t.left, o = t.top;
  if (r == "page")
    n -= jj(), o -= Bj();
  else if (r == "local" || !r) {
    let a = e.display.sizer.getBoundingClientRect();
    n += a.left, o += a.top;
  }
  let s = e.display.lineSpace.getBoundingClientRect();
  return { left: n - s.left, top: o - s.top };
}
function XS(e, t, r, n, o) {
  return n || (n = Be(e.doc, t.line)), Ig(e, n, Oj(e, n, t.ch, o), r);
}
function zn(e, t, r, n, o, s) {
  n = n || Be(e.doc, t.line), o || (o = Su(e, n));
  function a(v, y) {
    let w = Li(e, o, v, y ? "right" : "left", s);
    return y ? w.left = w.right : w.right = w.left, Ig(e, n, w, r);
  }
  let l = $o(n, e.doc.direction), u = t.ch, f = t.sticky;
  if (u >= n.text.length ? (u = n.text.length, f = "before") : u <= 0 && (u = 0, f = "after"), !l)
    return a(f == "before" ? u - 1 : u, f == "before");
  function c(v, y, w) {
    let S = l[y], x = S.level == 1;
    return a(w ? v - 1 : v, x != w);
  }
  let d = Qf(l, u, f), h = tf, p = c(u, d, f == "before");
  return h != null && (p.other = c(u, h, f != "before")), p;
}
function JC(e, t) {
  let r = 0;
  t = Ye(e.doc, t), e.options.lineWrapping || (r = Eu(e.display) * t.ch);
  let n = Be(e.doc, t.line), o = vo(n) + Cg(e.display);
  return { left: r, right: r, top: o, bottom: o + n.height };
}
function JS(e, t, r, n, o) {
  let s = Ee(e, t, r);
  return s.xRel = o, n && (s.outside = n), s;
}
function wR(e, t, r) {
  let n = e.doc;
  if (r += e.display.viewOffset, r < 0)
    return JS(n.first, 0, null, -1, -1);
  let o = Zs(n, r), s = n.first + n.size - 1;
  if (o > s)
    return JS(n.first + n.size - 1, Be(n, s).text.length, null, 1, 1);
  t < 0 && (t = 0);
  let a = Be(n, o);
  for (; ; ) {
    let l = lde(e, a, o, t, r), u = Pce(a, l.ch + (l.xRel > 0 || l.outside > 0 ? 1 : 0));
    if (!u)
      return l;
    let f = u.find(1);
    if (f.line == o)
      return f;
    a = Be(n, o = f.line);
  }
}
function qj(e, t, r, n) {
  n -= _R(t);
  let o = t.text.length, s = Jf((a) => Li(e, r, a - 1).bottom <= n, o, 0);
  return o = Jf((a) => Li(e, r, a).top > n, s, o), { begin: s, end: o };
}
function Wj(e, t, r, n) {
  r || (r = Su(e, t));
  let o = Ig(e, t, Li(e, r, n), "line").top;
  return qj(e, t, r, o);
}
function QS(e, t, r, n) {
  return e.bottom <= r ? !1 : e.top > r ? !0 : (n ? e.left : e.right) > t;
}
function lde(e, t, r, n, o) {
  o -= vo(t);
  let s = Su(e, t), a = _R(t), l = 0, u = t.text.length, f = !0, c = $o(t, e.doc.direction);
  if (c) {
    let S = (e.options.lineWrapping ? fde : ude)(e, t, r, s, c, n, o);
    f = S.level != 1, l = f ? S.from : S.to - 1, u = f ? S.to : S.from - 1;
  }
  let d = null, h = null, p = Jf((S) => {
    let x = Li(e, s, S);
    return x.top += a, x.bottom += a, QS(x, n, o, !1) ? (x.top <= o && x.left <= n && (d = S, h = x), !0) : !1;
  }, l, u), v, y, w = !1;
  if (h) {
    let S = n - h.left < h.right - n, x = S == f;
    p = d + (x ? 0 : 1), y = x ? "after" : "before", v = S ? h.left : h.right;
  } else {
    !f && (p == u || p == l) && p++, y = p == 0 ? "after" : p == t.text.length ? "before" : Li(e, s, p - (f ? 1 : 0)).bottom + a <= o == f ? "after" : "before";
    let S = zn(e, Ee(r, p, y), "line", t, s);
    v = S.left, w = o < S.top ? -1 : o >= S.bottom ? 1 : 0;
  }
  return p = fj(t.text, p, 1), JS(r, p, y, w, n - v);
}
function ude(e, t, r, n, o, s, a) {
  let l = Jf((f) => {
    let c = o[f], d = c.level != 1;
    return QS(zn(e, Ee(r, d ? c.to : c.from, d ? "before" : "after"), "line", t, n), s, a, !0);
  }, 0, o.length - 1), u = o[l];
  if (l > 0) {
    let f = u.level != 1, c = zn(e, Ee(r, f ? u.from : u.to, f ? "after" : "before"), "line", t, n);
    QS(c, s, a, !0) && c.top > a && (u = o[l - 1]);
  }
  return u;
}
function fde(e, t, r, n, o, s, a) {
  let { begin: l, end: u } = qj(e, t, n, a);
  /\s/.test(t.text.charAt(u - 1)) && u--;
  let f = null, c = null;
  for (let d = 0; d < o.length; d++) {
    let h = o[d];
    if (h.from >= u || h.to <= l)
      continue;
    let p = h.level != 1, v = Li(e, n, p ? Math.min(u, h.to) - 1 : Math.max(l, h.from)).right, y = v < s ? s - v + 1e9 : v - s;
    (!f || c > y) && (f = h, c = y);
  }
  return f || (f = o[o.length - 1]), f.from < l && (f = { from: l, to: f.to, level: f.level }), f.to > u && (f = { from: f.from, to: u, level: f.level }), f;
}
var Ds;
function ru(e) {
  if (e.cachedTextHeight != null)
    return e.cachedTextHeight;
  if (Ds == null) {
    Ds = He("pre", null, "CodeMirror-line-like");
    for (let r = 0; r < 49; ++r)
      Ds.appendChild(document.createTextNode("x")), Ds.appendChild(He("br"));
    Ds.appendChild(document.createTextNode("x"));
  }
  hn(e.measure, Ds);
  let t = Ds.offsetHeight / 50;
  return t > 3 && (e.cachedTextHeight = t), us(e.measure), t || 1;
}
function Eu(e) {
  if (e.cachedCharWidth != null)
    return e.cachedCharWidth;
  let t = He("span", "xxxxxxxxxx"), r = He("pre", [t], "CodeMirror-line-like");
  hn(e.measure, r);
  let n = t.getBoundingClientRect(), o = (n.right - n.left) / 10;
  return o > 2 && (e.cachedCharWidth = o), o || 10;
}
function SR(e) {
  let t = e.display, r = {}, n = {}, o = t.gutters.clientLeft;
  for (let s = t.gutters.firstChild, a = 0; s; s = s.nextSibling, ++a) {
    let l = e.display.gutterSpecs[a].className;
    r[l] = s.offsetLeft + s.clientLeft + o, n[l] = s.clientWidth;
  }
  return {
    fixedPos: ER(t),
    gutterTotalWidth: t.gutters.offsetWidth,
    gutterLeft: r,
    gutterWidth: n,
    wrapperWidth: t.wrapper.clientWidth
  };
}
function ER(e) {
  return e.scroller.getBoundingClientRect().left - e.sizer.getBoundingClientRect().left;
}
function Uj(e) {
  let t = ru(e.display), r = e.options.lineWrapping, n = r && Math.max(5, e.display.scroller.clientWidth / Eu(e.display) - 3);
  return (o) => {
    if (cs(e.doc, o))
      return 0;
    let s = 0;
    if (o.widgets)
      for (let a = 0; a < o.widgets.length; a++)
        o.widgets[a].height && (s += o.widgets[a].height);
    return r ? s + (Math.ceil(o.text.length / n) || 1) * t : s + t;
  };
}
function xR(e) {
  let t = e.doc, r = Uj(e);
  t.iter((n) => {
    let o = r(n);
    o != n.height && Ii(n, o);
  });
}
function Ca(e, t, r, n) {
  let o = e.display;
  if (!r && oR(t).getAttribute("cm-not-content") == "true")
    return null;
  let s, a, l = o.lineSpace.getBoundingClientRect();
  try {
    s = t.clientX - l.left, a = t.clientY - l.top;
  } catch {
    return null;
  }
  let u = wR(e, s, a), f;
  if (n && u.xRel > 0 && (f = Be(e.doc, u.line).text).length == u.ch) {
    let c = wn(f, f.length, e.options.tabSize) - f.length;
    u = Ee(u.line, Math.max(0, Math.round((s - Ij(e.display).left) / Eu(e.display)) - c));
  }
  return u;
}
function Ia(e, t) {
  if (t >= e.display.viewTo || (t -= e.display.viewFrom, t < 0))
    return null;
  let r = e.display.view;
  for (let n = 0; n < r.length; n++)
    if (t -= r[n].size, t < 0)
      return n;
}
function qr(e, t, r, n) {
  t == null && (t = e.doc.first), r == null && (r = e.doc.first + e.doc.size), n || (n = 0);
  let o = e.display;
  if (n && r < o.viewTo && (o.updateLineNumbers == null || o.updateLineNumbers > t) && (o.updateLineNumbers = t), e.curOp.viewChanged = !0, t >= o.viewTo)
    yo && pR(e.doc, t) < o.viewTo && Wo(e);
  else if (r <= o.viewFrom)
    yo && Rj(e.doc, r + n) > o.viewFrom ? Wo(e) : (o.viewFrom += n, o.viewTo += n);
  else if (t <= o.viewFrom && r >= o.viewTo)
    Wo(e);
  else if (t <= o.viewFrom) {
    let a = _d(e, r, r + n, 1);
    a ? (o.view = o.view.slice(a.index), o.viewFrom = a.lineN, o.viewTo += n) : Wo(e);
  } else if (r >= o.viewTo) {
    let a = _d(e, t, t, -1);
    a ? (o.view = o.view.slice(0, a.index), o.viewTo = a.lineN) : Wo(e);
  } else {
    let a = _d(e, t, t, -1), l = _d(e, r, r + n, 1);
    a && l ? (o.view = o.view.slice(0, a.index).concat(Yd(e, a.lineN, l.lineN)).concat(o.view.slice(l.index)), o.viewTo += n) : Wo(e);
  }
  let s = o.externalMeasured;
  s && (r < s.lineN ? s.lineN += n : t < s.lineN + s.size && (o.externalMeasured = null));
}
function Es(e, t, r) {
  e.curOp.viewChanged = !0;
  let n = e.display, o = e.display.externalMeasured;
  if (o && t >= o.lineN && t < o.lineN + o.size && (n.externalMeasured = null), t < n.viewFrom || t >= n.viewTo)
    return;
  let s = n.view[Ia(e, t)];
  if (s.node == null)
    return;
  let a = s.changes || (s.changes = []);
  _r(a, r) == -1 && a.push(r);
}
function Wo(e) {
  e.display.viewFrom = e.display.viewTo = e.doc.first, e.display.view = [], e.display.viewOffset = 0;
}
function _d(e, t, r, n) {
  let o = Ia(e, t), s, a = e.display.view;
  if (!yo || r == e.doc.first + e.doc.size)
    return { index: o, lineN: r };
  let l = e.display.viewFrom;
  for (let u = 0; u < o; u++)
    l += a[u].size;
  if (l != t) {
    if (n > 0) {
      if (o == a.length - 1)
        return null;
      s = l + a[o].size - t, o++;
    } else
      s = l - t;
    t += s, r += s;
  }
  for (; pR(e.doc, r) != r; ) {
    if (o == (n < 0 ? 0 : a.length - 1))
      return null;
    r += n * a[o - (n < 0 ? 1 : 0)].size, o += n;
  }
  return { index: o, lineN: r };
}
function cde(e, t, r) {
  let n = e.display;
  n.view.length == 0 || t >= n.viewTo || r <= n.viewFrom ? (n.view = Yd(e, t, r), n.viewFrom = t) : (n.viewFrom > t ? n.view = Yd(e, t, n.viewFrom).concat(n.view) : n.viewFrom < t && (n.view = n.view.slice(Ia(e, t))), n.viewFrom = t, n.viewTo < r ? n.view = n.view.concat(Yd(e, n.viewTo, r)) : n.viewTo > r && (n.view = n.view.slice(0, Ia(e, r)))), n.viewTo = r;
}
function QC(e) {
  let t = e.display.view, r = 0;
  for (let n = 0; n < t.length; n++) {
    let o = t[n];
    !o.hidden && (!o.node || o.changes) && ++r;
  }
  return r;
}
function kf(e) {
  e.display.input.showSelection(e.display.input.prepareSelection());
}
function Hj(e, t = !0) {
  let r = e.doc, n = {}, o = n.cursors = document.createDocumentFragment(), s = n.selection = document.createDocumentFragment();
  for (let a = 0; a < r.sel.ranges.length; a++) {
    if (!t && a == r.sel.primIndex)
      continue;
    let l = r.sel.ranges[a];
    if (l.from().line >= e.display.viewTo || l.to().line < e.display.viewFrom)
      continue;
    let u = l.empty();
    (u || e.options.showCursorWhenSelecting) && Vj(e, l.head, o), u || dde(e, l, s);
  }
  return n;
}
function Vj(e, t, r) {
  let n = zn(e, t, "div", null, null, !e.options.singleCursorHeightPerLine), o = r.appendChild(He("div", " ", "CodeMirror-cursor"));
  if (o.style.left = n.left + "px", o.style.top = n.top + "px", o.style.height = Math.max(0, n.bottom - n.top) * e.options.cursorHeight + "px", n.other) {
    let s = r.appendChild(He("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor"));
    s.style.display = "", s.style.left = n.other.left + "px", s.style.top = n.other.top + "px", s.style.height = (n.other.bottom - n.other.top) * 0.85 + "px";
  }
}
function wd(e, t) {
  return e.top - t.top || e.left - t.left;
}
function dde(e, t, r) {
  let n = e.display, o = e.doc, s = document.createDocumentFragment(), a = Ij(e.display), l = a.left, u = Math.max(n.sizerWidth, tl(e) - n.sizer.offsetLeft) - a.right, f = o.direction == "ltr";
  function c(v, y, w, S) {
    y < 0 && (y = 0), y = Math.round(y), S = Math.round(S), s.appendChild(He("div", null, "CodeMirror-selected", `position: absolute; left: ${v}px;
                             top: ${y}px; width: ${w ?? u - v}px;
                             height: ${S - y}px`));
  }
  function d(v, y, w) {
    let S = Be(o, v), x = S.text.length, E, N;
    function C(z, $) {
      return XS(e, Ee(v, z), "div", S, $);
    }
    function j(z, $, G) {
      let I = Wj(e, S, null, z), W = $ == "ltr" == (G == "after") ? "left" : "right", k = G == "after" ? I.begin : I.end - (/\s/.test(S.text.charAt(I.end - 1)) ? 2 : 1);
      return C(k, W)[W];
    }
    let J = $o(S, o.direction);
    return pce(J, y || 0, w ?? x, (z, $, G, I) => {
      let W = G == "ltr", k = C(z, W ? "left" : "right"), U = C($ - 1, W ? "right" : "left"), Z = y == null && z == 0, Y = w == null && $ == x, re = I == 0, ae = !J || I == J.length - 1;
      if (U.top - k.top <= 3) {
        let ce = (f ? Z : Y) && re, pe = (f ? Y : Z) && ae, le = ce ? l : (W ? k : U).left, ye = pe ? u : (W ? U : k).right;
        c(le, k.top, ye - le, k.bottom);
      } else {
        let ce, pe, le, ye;
        W ? (ce = f && Z && re ? l : k.left, pe = f ? u : j(z, G, "before"), le = f ? l : j($, G, "after"), ye = f && Y && ae ? u : U.right) : (ce = f ? j(z, G, "before") : l, pe = !f && Z && re ? u : k.right, le = !f && Y && ae ? l : U.left, ye = f ? j($, G, "after") : u), c(ce, k.top, pe - ce, k.bottom), k.bottom < U.top && c(l, k.bottom, null, U.top), c(le, U.top, ye - le, U.bottom);
      }
      (!E || wd(k, E) < 0) && (E = k), wd(U, E) < 0 && (E = U), (!N || wd(k, N) < 0) && (N = k), wd(U, N) < 0 && (N = U);
    }), { start: E, end: N };
  }
  let h = t.from(), p = t.to();
  if (h.line == p.line)
    d(h.line, h.ch, p.ch);
  else {
    let v = Be(o, h.line), y = Be(o, p.line), w = Mi(v) == Mi(y), S = d(h.line, h.ch, w ? v.text.length + 1 : null).end, x = d(p.line, w ? 0 : null, p.ch).start;
    w && (S.top < x.top - 2 ? (c(S.right, S.top, null, S.bottom), c(l, x.top, x.left, x.bottom)) : c(S.right, S.top, x.left - S.right, S.bottom)), S.bottom < x.top && c(l, S.bottom, null, x.top);
  }
  r.appendChild(s);
}
function RR(e) {
  if (!e.state.focused)
    return;
  let t = e.display;
  clearInterval(t.blinker);
  let r = !0;
  t.cursorDiv.style.visibility = "", e.options.cursorBlinkRate > 0 ? t.blinker = setInterval(() => {
    e.hasFocus() || xu(e), t.cursorDiv.style.visibility = (r = !r) ? "" : "hidden";
  }, e.options.cursorBlinkRate) : e.options.cursorBlinkRate < 0 && (t.cursorDiv.style.visibility = "hidden");
}
function zj(e) {
  e.hasFocus() || (e.display.input.focus(), e.state.focused || TR(e));
}
function AR(e) {
  e.state.delayingBlurEvent = !0, setTimeout(() => {
    e.state.delayingBlurEvent && (e.state.delayingBlurEvent = !1, e.state.focused && xu(e));
  }, 100);
}
function TR(e, t) {
  e.state.delayingBlurEvent && !e.state.draggingText && (e.state.delayingBlurEvent = !1), e.options.readOnly != "nocursor" && (e.state.focused || (Ht(e, "focus", e, t), e.state.focused = !0, el(e.display.wrapper, "CodeMirror-focused"), !e.curOp && e.display.selForContextMenu != e.doc.sel && (e.display.input.reset(), Nr && setTimeout(() => e.display.input.reset(!0), 20)), e.display.input.receivedFocus()), RR(e));
}
function xu(e, t) {
  e.state.delayingBlurEvent || (e.state.focused && (Ht(e, "blur", e, t), e.state.focused = !1, Za(e.display.wrapper, "CodeMirror-focused")), clearInterval(e.display.blinker), setTimeout(() => {
    e.state.focused || (e.display.shift = !1);
  }, 150));
}
function Mg(e) {
  let t = e.display, r = t.lineDiv.offsetTop;
  for (let n = 0; n < t.view.length; n++) {
    let o = t.view[n], s = e.options.lineWrapping, a, l = 0;
    if (o.hidden)
      continue;
    if (dt && kt < 8) {
      let f = o.node.offsetTop + o.node.offsetHeight;
      a = f - r, r = f;
    } else {
      let f = o.node.getBoundingClientRect();
      a = f.bottom - f.top, !s && o.text.firstChild && (l = o.text.firstChild.getBoundingClientRect().right - f.left - 1);
    }
    let u = o.line.height - a;
    if ((u > 5e-3 || u < -5e-3) && (Ii(o.line, a), ZC(o.line), o.rest))
      for (let f = 0; f < o.rest.length; f++)
        ZC(o.rest[f]);
    if (l > e.display.sizerWidth) {
      let f = Math.ceil(l / Eu(e.display));
      f > e.display.maxLineLength && (e.display.maxLineLength = f, e.display.maxLine = o.line, e.display.maxLineChanged = !0);
    }
  }
}
function ZC(e) {
  if (e.widgets)
    for (let t = 0; t < e.widgets.length; ++t) {
      let r = e.widgets[t], n = r.node.parentNode;
      n && (r.height = n.offsetHeight);
    }
}
function Fh(e, t, r) {
  let n = r && r.top != null ? Math.max(0, r.top) : e.scroller.scrollTop;
  n = Math.floor(n - Cg(e));
  let o = r && r.bottom != null ? r.bottom : n + e.wrapper.clientHeight, s = Zs(t, n), a = Zs(t, o);
  if (r && r.ensure) {
    let l = r.ensure.from.line, u = r.ensure.to.line;
    l < s ? (s = l, a = Zs(t, vo(Be(t, l)) + e.wrapper.clientHeight)) : Math.min(u, t.lastLine()) >= a && (s = Zs(t, vo(Be(t, u)) - e.wrapper.clientHeight), a = u);
  }
  return { from: s, to: Math.max(a, s + 1) };
}
function hde(e, t) {
  if (Qt(e, "scrollCursorIntoView"))
    return;
  let r = e.display, n = r.sizer.getBoundingClientRect(), o = null;
  if (t.top + n.top < 0 ? o = !0 : t.bottom + n.top > (window.innerHeight || document.documentElement.clientHeight) && (o = !1), o != null && !lce) {
    let s = He("div", "​", null, `position: absolute;
                         top: ${t.top - r.viewOffset - Cg(e.display)}px;
                         height: ${t.bottom - t.top + Oi(e) + r.barHeight}px;
                         left: ${t.left}px; width: ${Math.max(2, t.right - t.left)}px;`);
    e.display.lineSpace.appendChild(s), s.scrollIntoView(o), e.display.lineSpace.removeChild(s);
  }
}
function pde(e, t, r, n) {
  n == null && (n = 0);
  let o;
  !e.options.lineWrapping && t == r && (t = t.ch ? Ee(t.line, t.sticky == "before" ? t.ch - 1 : t.ch, "after") : t, r = t.sticky == "before" ? Ee(t.line, t.ch + 1, "before") : t);
  for (let s = 0; s < 5; s++) {
    let a = !1, l = zn(e, t), u = !r || r == t ? l : zn(e, r);
    o = {
      left: Math.min(l.left, u.left),
      top: Math.min(l.top, u.top) - n,
      right: Math.max(l.left, u.left),
      bottom: Math.max(l.bottom, u.bottom) + n
    };
    let f = $R(e, o), c = e.doc.scrollTop, d = e.doc.scrollLeft;
    if (f.scrollTop != null && (Ic(e, f.scrollTop), Math.abs(e.doc.scrollTop - c) > 1 && (a = !0)), f.scrollLeft != null && (rl(e, f.scrollLeft), Math.abs(e.doc.scrollLeft - d) > 1 && (a = !0)), !a)
      break;
  }
  return o;
}
function gde(e, t) {
  let r = $R(e, t);
  r.scrollTop != null && Ic(e, r.scrollTop), r.scrollLeft != null && rl(e, r.scrollLeft);
}
function $R(e, t) {
  let r = e.display, n = ru(e.display);
  t.top < 0 && (t.top = 0);
  let o = e.curOp && e.curOp.scrollTop != null ? e.curOp.scrollTop : r.scroller.scrollTop, s = vR(e), a = {};
  t.bottom - t.top > s && (t.bottom = t.top + s);
  let l = e.doc.height + yR(r), u = t.top < n, f = t.bottom > l - n;
  if (t.top < o)
    a.scrollTop = u ? 0 : t.top;
  else if (t.bottom > o + s) {
    let v = Math.min(t.top, (f ? l : t.bottom) - s);
    v != o && (a.scrollTop = v);
  }
  let c = e.options.fixedGutter ? 0 : r.gutters.offsetWidth, d = e.curOp && e.curOp.scrollLeft != null ? e.curOp.scrollLeft : r.scroller.scrollLeft - c, h = tl(e) - r.gutters.offsetWidth, p = t.right - t.left > h;
  return p && (t.right = t.left + h), t.left < 10 ? a.scrollLeft = 0 : t.left < d ? a.scrollLeft = Math.max(0, t.left + c - (p ? 0 : 10)) : t.right > h + d - 3 && (a.scrollLeft = t.right + (p ? 0 : 10) - h), a;
}
function NR(e, t) {
  t != null && (Og(e), e.curOp.scrollTop = (e.curOp.scrollTop == null ? e.doc.scrollTop : e.curOp.scrollTop) + t);
}
function Ru(e) {
  Og(e);
  let t = e.getCursor();
  e.curOp.scrollToPos = { from: t, to: t, margin: e.options.cursorScrollMargin };
}
function Cf(e, t, r) {
  (t != null || r != null) && Og(e), t != null && (e.curOp.scrollLeft = t), r != null && (e.curOp.scrollTop = r);
}
function bde(e, t) {
  Og(e), e.curOp.scrollToPos = t;
}
function Og(e) {
  let t = e.curOp.scrollToPos;
  if (t) {
    e.curOp.scrollToPos = null;
    let r = JC(e, t.from), n = JC(e, t.to);
    Gj(e, r, n, t.margin);
  }
}
function Gj(e, t, r, n) {
  let o = $R(e, {
    left: Math.min(t.left, r.left),
    top: Math.min(t.top, r.top) - n,
    right: Math.max(t.right, r.right),
    bottom: Math.max(t.bottom, r.bottom) + n
  });
  Cf(e, o.scrollLeft, o.scrollTop);
}
function Ic(e, t) {
  Math.abs(e.doc.scrollTop - t) < 2 || (bo || ZS(e, { top: t }), Kj(e, t, !0), bo && ZS(e), Mc(e, 100));
}
function Kj(e, t, r) {
  t = Math.max(0, Math.min(e.display.scroller.scrollHeight - e.display.scroller.clientHeight, t)), !(e.display.scroller.scrollTop == t && !r) && (e.doc.scrollTop = t, e.display.scrollbars.setScrollTop(t), e.display.scroller.scrollTop != t && (e.display.scroller.scrollTop = t));
}
function rl(e, t, r, n) {
  t = Math.max(0, Math.min(t, e.display.scroller.scrollWidth - e.display.scroller.clientWidth)), !((r ? t == e.doc.scrollLeft : Math.abs(e.doc.scrollLeft - t) < 2) && !n) && (e.doc.scrollLeft = t, Zj(e), e.display.scroller.scrollLeft != t && (e.display.scroller.scrollLeft = t), e.display.scrollbars.setScrollLeft(t));
}
function sc(e) {
  let t = e.display, r = t.gutters.offsetWidth, n = Math.round(e.doc.height + yR(e.display));
  return {
    clientHeight: t.scroller.clientHeight,
    viewHeight: t.wrapper.clientHeight,
    scrollWidth: t.scroller.scrollWidth,
    clientWidth: t.scroller.clientWidth,
    viewWidth: t.wrapper.clientWidth,
    barLeft: e.options.fixedGutter ? r : 0,
    docHeight: n,
    scrollHeight: n + Oi(e) + t.barHeight,
    nativeBarWidth: t.nativeBarWidth,
    gutterWidth: r
  };
}
var yde = class {
  constructor(e, t, r) {
    this.cm = r;
    let n = this.vert = He("div", [He("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar"), o = this.horiz = He("div", [He("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    n.tabIndex = o.tabIndex = -1, e(n), e(o), Ve(n, "scroll", () => {
      n.clientHeight && t(n.scrollTop, "vertical");
    }), Ve(o, "scroll", () => {
      o.clientWidth && t(o.scrollLeft, "horizontal");
    }), this.checkedZeroWidth = !1, dt && kt < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px");
  }
  update(e) {
    let t = e.scrollWidth > e.clientWidth + 1, r = e.scrollHeight > e.clientHeight + 1, n = e.nativeBarWidth;
    if (r) {
      this.vert.style.display = "block", this.vert.style.bottom = t ? n + "px" : "0";
      let o = e.viewHeight - (t ? n : 0);
      this.vert.firstChild.style.height = Math.max(0, e.scrollHeight - e.clientHeight + o) + "px";
    } else
      this.vert.style.display = "", this.vert.firstChild.style.height = "0";
    if (t) {
      this.horiz.style.display = "block", this.horiz.style.right = r ? n + "px" : "0", this.horiz.style.left = e.barLeft + "px";
      let o = e.viewWidth - e.barLeft - (r ? n : 0);
      this.horiz.firstChild.style.width = Math.max(0, e.scrollWidth - e.clientWidth + o) + "px";
    } else
      this.horiz.style.display = "", this.horiz.firstChild.style.width = "0";
    return !this.checkedZeroWidth && e.clientHeight > 0 && (n == 0 && this.zeroWidthHack(), this.checkedZeroWidth = !0), { right: r ? n : 0, bottom: t ? n : 0 };
  }
  setScrollLeft(e) {
    this.horiz.scrollLeft != e && (this.horiz.scrollLeft = e), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
  }
  setScrollTop(e) {
    this.vert.scrollTop != e && (this.vert.scrollTop = e), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
  }
  zeroWidthHack() {
    let e = Rn && !ace ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = e, this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none", this.disableHoriz = new tu(), this.disableVert = new tu();
  }
  enableZeroWidthBar(e, t, r) {
    e.style.pointerEvents = "auto";
    function n() {
      let o = e.getBoundingClientRect();
      (r == "vert" ? document.elementFromPoint(o.right - 1, (o.top + o.bottom) / 2) : document.elementFromPoint((o.right + o.left) / 2, o.bottom - 1)) != e ? e.style.pointerEvents = "none" : t.set(1e3, n);
    }
    t.set(1e3, n);
  }
  clear() {
    let e = this.horiz.parentNode;
    e.removeChild(this.horiz), e.removeChild(this.vert);
  }
}, vde = class {
  update() {
    return { bottom: 0, right: 0 };
  }
  setScrollLeft() {
  }
  setScrollTop() {
  }
  clear() {
  }
};
function nu(e, t) {
  t || (t = sc(e));
  let r = e.display.barWidth, n = e.display.barHeight;
  eI(e, t);
  for (let o = 0; o < 4 && r != e.display.barWidth || n != e.display.barHeight; o++)
    r != e.display.barWidth && e.options.lineWrapping && Mg(e), eI(e, sc(e)), r = e.display.barWidth, n = e.display.barHeight;
}
function eI(e, t) {
  let r = e.display, n = r.scrollbars.update(t);
  r.sizer.style.paddingRight = (r.barWidth = n.right) + "px", r.sizer.style.paddingBottom = (r.barHeight = n.bottom) + "px", r.heightForcer.style.borderBottom = n.bottom + "px solid transparent", n.right && n.bottom ? (r.scrollbarFiller.style.display = "block", r.scrollbarFiller.style.height = n.bottom + "px", r.scrollbarFiller.style.width = n.right + "px") : r.scrollbarFiller.style.display = "", n.bottom && e.options.coverGutterNextToScrollbar && e.options.fixedGutter ? (r.gutterFiller.style.display = "block", r.gutterFiller.style.height = n.bottom + "px", r.gutterFiller.style.width = t.gutterWidth + "px") : r.gutterFiller.style.display = "";
}
var Yj = { native: yde, null: vde };
function Xj(e) {
  e.display.scrollbars && (e.display.scrollbars.clear(), e.display.scrollbars.addClass && Za(e.display.wrapper, e.display.scrollbars.addClass)), e.display.scrollbars = new Yj[e.options.scrollbarStyle]((t) => {
    e.display.wrapper.insertBefore(t, e.display.scrollbarFiller), Ve(t, "mousedown", () => {
      e.state.focused && setTimeout(() => e.display.input.focus(), 0);
    }), t.setAttribute("cm-not-content", "true");
  }, (t, r) => {
    r == "horizontal" ? rl(e, t) : Ic(e, t);
  }, e), e.display.scrollbars.addClass && el(e.display.wrapper, e.display.scrollbars.addClass);
}
var mde = 0;
function nl(e) {
  e.curOp = {
    cm: e,
    viewChanged: !1,
    startHeight: e.doc.height,
    forceUpdate: !1,
    updateInput: 0,
    typing: !1,
    changeObjs: null,
    cursorActivityHandlers: null,
    cursorActivityCalled: 0,
    selectionChanged: !1,
    updateMaxLine: !1,
    scrollLeft: null,
    scrollTop: null,
    scrollToPos: null,
    focus: !1,
    id: ++mde
  }, Kce(e.curOp);
}
function il(e) {
  let t = e.curOp;
  t && Xce(t, (r) => {
    for (let n = 0; n < r.ops.length; n++)
      r.ops[n].cm.curOp = null;
    _de(r);
  });
}
function _de(e) {
  let t = e.ops;
  for (let r = 0; r < t.length; r++)
    wde(t[r]);
  for (let r = 0; r < t.length; r++)
    Sde(t[r]);
  for (let r = 0; r < t.length; r++)
    Ede(t[r]);
  for (let r = 0; r < t.length; r++)
    xde(t[r]);
  for (let r = 0; r < t.length; r++)
    Rde(t[r]);
}
function wde(e) {
  let t = e.cm, r = t.display;
  Tde(t), e.updateMaxLine && gR(t), e.mustUpdate = e.viewChanged || e.forceUpdate || e.scrollTop != null || e.scrollToPos && (e.scrollToPos.from.line < r.viewFrom || e.scrollToPos.to.line >= r.viewTo) || r.maxLineChanged && t.options.lineWrapping, e.update = e.mustUpdate && new Jj(t, e.mustUpdate && { top: e.scrollTop, ensure: e.scrollToPos }, e.forceUpdate);
}
function Sde(e) {
  e.updatedDisplay = e.mustUpdate && kR(e.cm, e.update);
}
function Ede(e) {
  let t = e.cm, r = t.display;
  e.updatedDisplay && Mg(t), e.barMeasure = sc(t), r.maxLineChanged && !t.options.lineWrapping && (e.adjustWidthTo = Oj(t, r.maxLine, r.maxLine.text.length).left + 3, t.display.sizerWidth = e.adjustWidthTo, e.barMeasure.scrollWidth = Math.max(r.scroller.clientWidth, r.sizer.offsetLeft + e.adjustWidthTo + Oi(t) + t.display.barWidth), e.maxScrollLeft = Math.max(0, r.sizer.offsetLeft + e.adjustWidthTo - tl(t))), (e.updatedDisplay || e.selectionChanged) && (e.preparedSelection = r.input.prepareSelection());
}
function xde(e) {
  let t = e.cm;
  e.adjustWidthTo != null && (t.display.sizer.style.minWidth = e.adjustWidthTo + "px", e.maxScrollLeft < t.doc.scrollLeft && rl(t, Math.min(t.display.scroller.scrollLeft, e.maxScrollLeft), !0), t.display.maxLineChanged = !1);
  let r = e.focus && e.focus == En();
  e.preparedSelection && t.display.input.showSelection(e.preparedSelection, r), (e.updatedDisplay || e.startHeight != t.doc.height) && nu(t, e.barMeasure), e.updatedDisplay && IR(t, e.barMeasure), e.selectionChanged && RR(t), t.state.focused && e.updateInput && t.display.input.reset(e.typing), r && zj(e.cm);
}
function Rde(e) {
  let t = e.cm, r = t.display, n = t.doc;
  if (e.updatedDisplay && Qj(t, e.update), r.wheelStartX != null && (e.scrollTop != null || e.scrollLeft != null || e.scrollToPos) && (r.wheelStartX = r.wheelStartY = null), e.scrollTop != null && Kj(t, e.scrollTop, e.forceScroll), e.scrollLeft != null && rl(t, e.scrollLeft, !0, !0), e.scrollToPos) {
    let a = pde(t, Ye(n, e.scrollToPos.from), Ye(n, e.scrollToPos.to), e.scrollToPos.margin);
    hde(t, a);
  }
  let o = e.maybeHiddenMarkers, s = e.maybeUnhiddenMarkers;
  if (o)
    for (let a = 0; a < o.length; ++a)
      o[a].lines.length || Ht(o[a], "hide");
  if (s)
    for (let a = 0; a < s.length; ++a)
      s[a].lines.length && Ht(s[a], "unhide");
  r.wrapper.offsetHeight && (n.scrollTop = t.display.scroller.scrollTop), e.changeObjs && Ht(t, "changes", t, e.changeObjs), e.update && e.update.finish();
}
function en(e, t) {
  if (e.curOp)
    return t();
  nl(e);
  try {
    return t();
  } finally {
    il(e);
  }
}
function tr(e, t) {
  return function() {
    if (e.curOp)
      return t.apply(e, arguments);
    nl(e);
    try {
      return t.apply(e, arguments);
    } finally {
      il(e);
    }
  };
}
function Tr(e) {
  return function() {
    if (this.curOp)
      return e.apply(this, arguments);
    nl(this);
    try {
      return e.apply(this, arguments);
    } finally {
      il(this);
    }
  };
}
function Jt(e) {
  return function() {
    let t = this.cm;
    if (!t || t.curOp)
      return e.apply(this, arguments);
    nl(t);
    try {
      return e.apply(this, arguments);
    } finally {
      il(t);
    }
  };
}
function Mc(e, t) {
  e.doc.highlightFrontier < e.display.viewTo && e.state.highlight.set(t, rR(Ade, e));
}
function Ade(e) {
  let t = e.doc;
  if (t.highlightFrontier >= e.display.viewTo)
    return;
  let r = +/* @__PURE__ */ new Date() + e.options.workTime, n = Cc(e, t.highlightFrontier), o = [];
  t.iter(n.line, Math.min(t.first + t.size, e.display.viewTo + 500), (s) => {
    if (n.line >= e.display.viewFrom) {
      let a = s.styles, l = s.text.length > e.options.maxHighlightLength ? ba(t.mode, n.state) : null, u = yj(e, s, n, !0);
      l && (n.state = l), s.styles = u.styles;
      let f = s.styleClasses, c = u.classes;
      c ? s.styleClasses = c : f && (s.styleClasses = null);
      let d = !a || a.length != s.styles.length || f != c && (!f || !c || f.bgClass != c.bgClass || f.textClass != c.textClass);
      for (let h = 0; !d && h < a.length; ++h)
        d = a[h] != s.styles[h];
      d && o.push(n.line), s.stateAfter = n.save(), n.nextLine();
    } else
      s.text.length <= e.options.maxHighlightLength && cR(e, s.text, n), s.stateAfter = n.line % 5 == 0 ? n.save() : null, n.nextLine();
    if (+/* @__PURE__ */ new Date() > r)
      return Mc(e, e.options.workDelay), !0;
  }), t.highlightFrontier = n.line, t.modeFrontier = Math.max(t.modeFrontier, n.line), o.length && en(e, () => {
    for (let s = 0; s < o.length; s++)
      Es(e, o[s], "text");
  });
}
var Jj = class {
  constructor(e, t, r) {
    let n = e.display;
    this.viewport = t, this.visible = Fh(n, e.doc, t), this.editorIsHidden = !n.wrapper.offsetWidth, this.wrapperHeight = n.wrapper.clientHeight, this.wrapperWidth = n.wrapper.clientWidth, this.oldDisplayWidth = tl(e), this.force = r, this.dims = SR(e), this.events = [];
  }
  signal(e, t) {
    An(e, t) && this.events.push(arguments);
  }
  finish() {
    for (let e = 0; e < this.events.length; e++)
      Ht.apply(null, this.events[e]);
  }
};
function Tde(e) {
  let t = e.display;
  !t.scrollbarsClipped && t.scroller.offsetWidth && (t.nativeBarWidth = t.scroller.offsetWidth - t.scroller.clientWidth, t.heightForcer.style.height = Oi(e) + "px", t.sizer.style.marginBottom = -t.nativeBarWidth + "px", t.sizer.style.borderRightWidth = Oi(e) + "px", t.scrollbarsClipped = !0);
}
function $de(e) {
  if (e.hasFocus())
    return null;
  let t = En();
  if (!t || !fs(e.display.lineDiv, t))
    return null;
  let r = { activeElt: t };
  if (window.getSelection) {
    let n = window.getSelection();
    n.anchorNode && n.extend && fs(e.display.lineDiv, n.anchorNode) && (r.anchorNode = n.anchorNode, r.anchorOffset = n.anchorOffset, r.focusNode = n.focusNode, r.focusOffset = n.focusOffset);
  }
  return r;
}
function Nde(e) {
  if (!(!e || !e.activeElt || e.activeElt == En()) && (e.activeElt.focus(), !/^(INPUT|TEXTAREA)$/.test(e.activeElt.nodeName) && e.anchorNode && fs(document.body, e.anchorNode) && fs(document.body, e.focusNode))) {
    let t = window.getSelection(), r = document.createRange();
    r.setEnd(e.anchorNode, e.anchorOffset), r.collapse(!1), t.removeAllRanges(), t.addRange(r), t.extend(e.focusNode, e.focusOffset);
  }
}
function kR(e, t) {
  let r = e.display, n = e.doc;
  if (t.editorIsHidden)
    return Wo(e), !1;
  if (!t.force && t.visible.from >= r.viewFrom && t.visible.to <= r.viewTo && (r.updateLineNumbers == null || r.updateLineNumbers >= r.viewTo) && r.renderedView == r.view && QC(e) == 0)
    return !1;
  eB(e) && (Wo(e), t.dims = SR(e));
  let o = n.first + n.size, s = Math.max(t.visible.from - e.options.viewportMargin, n.first), a = Math.min(o, t.visible.to + e.options.viewportMargin);
  r.viewFrom < s && s - r.viewFrom < 20 && (s = Math.max(n.first, r.viewFrom)), r.viewTo > a && r.viewTo - a < 20 && (a = Math.min(o, r.viewTo)), yo && (s = pR(e.doc, s), a = Rj(e.doc, a));
  let l = s != r.viewFrom || a != r.viewTo || r.lastWrapHeight != t.wrapperHeight || r.lastWrapWidth != t.wrapperWidth;
  cde(e, s, a), r.viewOffset = vo(Be(e.doc, r.viewFrom)), e.display.mover.style.top = r.viewOffset + "px";
  let u = QC(e);
  if (!l && u == 0 && !t.force && r.renderedView == r.view && (r.updateLineNumbers == null || r.updateLineNumbers >= r.viewTo))
    return !1;
  let f = $de(e);
  return u > 4 && (r.lineDiv.style.display = "none"), kde(e, r.updateLineNumbers, t.dims), u > 4 && (r.lineDiv.style.display = ""), r.renderedView = r.view, Nde(f), us(r.cursorDiv), us(r.selectionDiv), r.gutters.style.height = r.sizer.style.minHeight = 0, l && (r.lastWrapHeight = t.wrapperHeight, r.lastWrapWidth = t.wrapperWidth, Mc(e, 400)), r.updateLineNumbers = null, !0;
}
function Qj(e, t) {
  let r = t.viewport;
  for (let n = !0; ; n = !1) {
    if (!n || !e.options.lineWrapping || t.oldDisplayWidth == tl(e)) {
      if (r && r.top != null && (r = { top: Math.min(e.doc.height + yR(e.display) - vR(e), r.top) }), t.visible = Fh(e.display, e.doc, r), t.visible.from >= e.display.viewFrom && t.visible.to <= e.display.viewTo)
        break;
    } else
      n && (t.visible = Fh(e.display, e.doc, r));
    if (!kR(e, t))
      break;
    Mg(e);
    let o = sc(e);
    kf(e), nu(e, o), IR(e, o), t.force = !1;
  }
  t.signal(e, "update", e), (e.display.viewFrom != e.display.reportedViewFrom || e.display.viewTo != e.display.reportedViewTo) && (t.signal(e, "viewportChange", e, e.display.viewFrom, e.display.viewTo), e.display.reportedViewFrom = e.display.viewFrom, e.display.reportedViewTo = e.display.viewTo);
}
function ZS(e, t) {
  let r = new Jj(e, t);
  if (kR(e, r)) {
    Mg(e), Qj(e, r);
    let n = sc(e);
    kf(e), nu(e, n), IR(e, n), r.finish();
  }
}
function kde(e, t, r) {
  let n = e.display, o = e.options.lineNumbers, s = n.lineDiv, a = s.firstChild;
  function l(c) {
    let d = c.nextSibling;
    return Nr && Rn && e.display.currentWheelTarget == c ? c.style.display = "none" : c.parentNode.removeChild(c), d;
  }
  let u = n.view, f = n.viewFrom;
  for (let c = 0; c < u.length; c++) {
    let d = u[c];
    if (!d.hidden)
      if (!d.node || d.node.parentNode != s) {
        let h = tde(e, d, f, r);
        s.insertBefore(h, a);
      } else {
        for (; a != d.node; )
          a = l(a);
        let h = o && t != null && t <= f && d.lineNumber;
        d.changes && (_r(d.changes, "gutter") > -1 && (h = !1), $j(e, d, f, r)), h && (us(d.lineNumber), d.lineNumber.appendChild(document.createTextNode(fR(e.options, f)))), a = d.node.nextSibling;
      }
    f += d.size;
  }
  for (; a; )
    a = l(a);
}
function CR(e) {
  let t = e.gutters.offsetWidth;
  e.sizer.style.marginLeft = t + "px", ir(e, "gutterChanged", e);
}
function IR(e, t) {
  e.display.sizer.style.minHeight = t.docHeight + "px", e.display.heightForcer.style.top = t.docHeight + "px", e.display.gutters.style.height = t.docHeight + e.display.barHeight + Oi(e) + "px";
}
function Zj(e) {
  let t = e.display, r = t.view;
  if (!t.alignWidgets && (!t.gutters.firstChild || !e.options.fixedGutter))
    return;
  let n = ER(t) - t.scroller.scrollLeft + e.doc.scrollLeft, o = t.gutters.offsetWidth, s = n + "px";
  for (let a = 0; a < r.length; a++)
    if (!r[a].hidden) {
      e.options.fixedGutter && (r[a].gutter && (r[a].gutter.style.left = s), r[a].gutterBackground && (r[a].gutterBackground.style.left = s));
      let l = r[a].alignable;
      if (l)
        for (let u = 0; u < l.length; u++)
          l[u].style.left = s;
    }
  e.options.fixedGutter && (t.gutters.style.left = n + o + "px");
}
function eB(e) {
  if (!e.options.lineNumbers)
    return !1;
  let t = e.doc, r = fR(e.options, t.first + t.size - 1), n = e.display;
  if (r.length != n.lineNumChars) {
    let o = n.measure.appendChild(He("div", [He("div", r)], "CodeMirror-linenumber CodeMirror-gutter-elt")), s = o.firstChild.offsetWidth, a = o.offsetWidth - s;
    return n.lineGutter.style.width = "", n.lineNumInnerWidth = Math.max(s, n.lineGutter.offsetWidth - a) + 1, n.lineNumWidth = n.lineNumInnerWidth + a, n.lineNumChars = n.lineNumInnerWidth ? r.length : -1, n.lineGutter.style.width = n.lineNumWidth + "px", CR(e.display), !0;
  }
  return !1;
}
function eE(e, t) {
  let r = [], n = !1;
  for (let o = 0; o < e.length; o++) {
    let s = e[o], a = null;
    if (typeof s != "string" && (a = s.style, s = s.className), s == "CodeMirror-linenumbers")
      if (t)
        n = !0;
      else
        continue;
    r.push({ className: s, style: a });
  }
  return t && !n && r.push({ className: "CodeMirror-linenumbers", style: null }), r;
}
function tB(e) {
  let t = e.gutters, r = e.gutterSpecs;
  us(t), e.lineGutter = null;
  for (let n = 0; n < r.length; ++n) {
    let { className: o, style: s } = r[n], a = t.appendChild(He("div", null, "CodeMirror-gutter " + o));
    s && (a.style.cssText = s), o == "CodeMirror-linenumbers" && (e.lineGutter = a, a.style.width = (e.lineNumWidth || 1) + "px");
  }
  t.style.display = r.length ? "" : "none", CR(e);
}
function Du(e) {
  tB(e.display), qr(e), Zj(e);
}
function Cde(e, t, r, n) {
  let o = this;
  this.input = r, o.scrollbarFiller = He("div", null, "CodeMirror-scrollbar-filler"), o.scrollbarFiller.setAttribute("cm-not-content", "true"), o.gutterFiller = He("div", null, "CodeMirror-gutter-filler"), o.gutterFiller.setAttribute("cm-not-content", "true"), o.lineDiv = Dl("div", null, "CodeMirror-code"), o.selectionDiv = He("div", null, null, "position: relative; z-index: 1"), o.cursorDiv = He("div", null, "CodeMirror-cursors"), o.measure = He("div", null, "CodeMirror-measure"), o.lineMeasure = He("div", null, "CodeMirror-measure"), o.lineSpace = Dl("div", [o.measure, o.lineMeasure, o.selectionDiv, o.cursorDiv, o.lineDiv], null, "position: relative; outline: none");
  let s = Dl("div", [o.lineSpace], "CodeMirror-lines");
  o.mover = He("div", [s], null, "position: relative"), o.sizer = He("div", [o.mover], "CodeMirror-sizer"), o.sizerWidth = null, o.heightForcer = He("div", null, null, "position: absolute; height: " + lj + "px; width: 1px;"), o.gutters = He("div", null, "CodeMirror-gutters"), o.lineGutter = null, o.scroller = He("div", [o.sizer, o.heightForcer, o.gutters], "CodeMirror-scroll"), o.scroller.setAttribute("tabIndex", "-1"), o.wrapper = He("div", [o.scrollbarFiller, o.gutterFiller, o.scroller], "CodeMirror"), dt && kt < 8 && (o.gutters.style.zIndex = -1, o.scroller.style.paddingRight = 0), !Nr && !(bo && Yf) && (o.scroller.draggable = !0), e && (e.appendChild ? e.appendChild(o.wrapper) : e(o.wrapper)), o.viewFrom = o.viewTo = t.first, o.reportedViewFrom = o.reportedViewTo = t.first, o.view = [], o.renderedView = null, o.externalMeasured = null, o.viewOffset = 0, o.lastWrapHeight = o.lastWrapWidth = 0, o.updateLineNumbers = null, o.nativeBarWidth = o.barHeight = o.barWidth = 0, o.scrollbarsClipped = !1, o.lineNumWidth = o.lineNumInnerWidth = o.lineNumChars = null, o.alignWidgets = !1, o.cachedCharWidth = o.cachedTextHeight = o.cachedPaddingH = null, o.maxLine = null, o.maxLineLength = 0, o.maxLineChanged = !1, o.wheelDX = o.wheelDY = o.wheelStartX = o.wheelStartY = null, o.shift = !1, o.selForContextMenu = null, o.activeTouch = null, o.gutterSpecs = eE(n.gutters, n.lineNumbers), tB(o), r.init(o);
}
var Sd = 0, un = null;
dt ? un = -0.53 : bo ? un = 15 : wg ? un = -0.7 : Sg && (un = -1 / 3);
function rB(e) {
  let t = e.wheelDeltaX, r = e.wheelDeltaY;
  return t == null && e.detail && e.axis == e.HORIZONTAL_AXIS && (t = e.detail), r == null && e.detail && e.axis == e.VERTICAL_AXIS ? r = e.detail : r == null && (r = e.wheelDelta), { x: t, y: r };
}
function Ide(e) {
  let t = rB(e);
  return t.x *= un, t.y *= un, t;
}
function tI(e, t) {
  let r = rB(t), n = r.x, o = r.y, s = e.display, a = s.scroller, l = a.scrollWidth > a.clientWidth, u = a.scrollHeight > a.clientHeight;
  if (n && l || o && u) {
    if (o && Rn && Nr) {
      e:
        for (let f = t.target, c = s.view; f != a; f = f.parentNode)
          for (let d = 0; d < c.length; d++)
            if (c[d].node == f) {
              e.display.currentWheelTarget = f;
              break e;
            }
    }
    if (n && !bo && !Jn && un != null) {
      o && u && Ic(e, Math.max(0, a.scrollTop + o * un)), rl(e, Math.max(0, a.scrollLeft + n * un)), (!o || o && u) && Br(t), s.wheelStartX = null;
      return;
    }
    if (o && un != null) {
      let f = o * un, c = e.doc.scrollTop, d = c + s.wrapper.clientHeight;
      f < 0 ? c = Math.max(0, c + f - 50) : d = Math.min(e.doc.height, d + f + 50), ZS(e, { top: c, bottom: d });
    }
    Sd < 20 && (s.wheelStartX == null ? (s.wheelStartX = a.scrollLeft, s.wheelStartY = a.scrollTop, s.wheelDX = n, s.wheelDY = o, setTimeout(() => {
      if (s.wheelStartX == null)
        return;
      let f = a.scrollLeft - s.wheelStartX, c = a.scrollTop - s.wheelStartY, d = c && s.wheelDY && c / s.wheelDY || f && s.wheelDX && f / s.wheelDX;
      s.wheelStartX = s.wheelStartY = null, d && (un = (un * Sd + d) / (Sd + 1), ++Sd);
    }, 200)) : (s.wheelDX += n, s.wheelDY += o));
  }
}
var xs = class {
  constructor(t, r) {
    this.ranges = t, this.primIndex = r;
  }
  primary() {
    return this.ranges[this.primIndex];
  }
  equals(t) {
    if (t == this)
      return !0;
    if (t.primIndex != this.primIndex || t.ranges.length != this.ranges.length)
      return !1;
    for (let r = 0; r < this.ranges.length; r++) {
      let n = this.ranges[r], o = t.ranges[r];
      if (!zS(n.anchor, o.anchor) || !zS(n.head, o.head))
        return !1;
    }
    return !0;
  }
  deepCopy() {
    let t = [];
    for (let r = 0; r < this.ranges.length; r++)
      t[r] = new wt(GS(this.ranges[r].anchor), GS(this.ranges[r].head));
    return new xs(t, this.primIndex);
  }
  somethingSelected() {
    for (let t = 0; t < this.ranges.length; t++)
      if (!this.ranges[t].empty())
        return !0;
    return !1;
  }
  contains(t, r) {
    r || (r = t);
    for (let n = 0; n < this.ranges.length; n++) {
      let o = this.ranges[n];
      if (Xe(r, o.from()) >= 0 && Xe(t, o.to()) <= 0)
        return n;
    }
    return -1;
  }
}, wt = class {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  from() {
    return $g(this.anchor, this.head);
  }
  to() {
    return Tg(this.anchor, this.head);
  }
  empty() {
    return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
  }
};
function Gn(e, t, r) {
  let n = e && e.options.selectionsMayTouch, o = t[r];
  t.sort((s, a) => Xe(s.from(), a.from())), r = _r(t, o);
  for (let s = 1; s < t.length; s++) {
    let a = t[s], l = t[s - 1], u = Xe(l.to(), a.from());
    if (n && !a.empty() ? u > 0 : u >= 0) {
      let f = $g(l.from(), a.from()), c = Tg(l.to(), a.to()), d = l.empty() ? a.from() == a.head : l.from() == l.head;
      s <= r && --r, t.splice(--s, 2, new wt(d ? c : f, d ? f : c));
    }
  }
  return new xs(t, r);
}
function ds(e, t) {
  return new xs([new wt(e, t || e)], 0);
}
function hs(e) {
  return e.text ? Ee(e.from.line + e.text.length - 1, vt(e.text).length + (e.text.length == 1 ? e.from.ch : 0)) : e.to;
}
function rI(e, t) {
  if (Xe(e, t.from) < 0)
    return e;
  if (Xe(e, t.to) <= 0)
    return hs(t);
  let r = e.line + t.text.length - (t.to.line - t.from.line) - 1, n = e.ch;
  return e.line == t.to.line && (n += hs(t).ch - t.to.ch), Ee(r, n);
}
function MR(e, t) {
  let r = [];
  for (let n = 0; n < e.sel.ranges.length; n++) {
    let o = e.sel.ranges[n];
    r.push(new wt(rI(o.anchor, t), rI(o.head, t)));
  }
  return Gn(e.cm, r, e.sel.primIndex);
}
function nI(e, t, r) {
  return e.line == t.line ? Ee(r.line, e.ch - t.ch + r.ch) : Ee(r.line + (e.line - t.line), e.ch);
}
function Mde(e, t, r) {
  let n = [], o = Ee(e.first, 0), s = o;
  for (let a = 0; a < t.length; a++) {
    let l = t[a], u = nI(l.from, o, s), f = nI(hs(l), o, s);
    if (o = l.to, s = f, r == "around") {
      let c = e.sel.ranges[a], d = Xe(c.head, c.anchor) < 0;
      n[a] = new wt(d ? f : u, d ? u : f);
    } else
      n[a] = new wt(u, u);
  }
  return new xs(n, e.sel.primIndex);
}
function tE(e) {
  e.doc.mode = lR(e.options, e.doc.modeOption), rf(e);
}
function rf(e) {
  e.doc.iter((t) => {
    t.stateAfter && (t.stateAfter = null), t.styles && (t.styles = null);
  }), e.doc.modeFrontier = e.doc.highlightFrontier = e.doc.first, Mc(e, 100), e.state.modeGen++, e.curOp && qr(e);
}
function nB(e, t) {
  return t.from.ch == 0 && t.to.ch == 0 && vt(t.text) == "" && (!e.cm || e.cm.options.wholeLineUpdateBefore);
}
function OR(e, t, r, n) {
  function o(y) {
    return r ? r[y] : null;
  }
  function s(y, w, S) {
    jce(y, w, S, n), ir(y, "change", y, t);
  }
  function a(y, w) {
    let S = [];
    for (let x = y; x < w; ++x)
      S.push(new rc(f[x], o(x), n));
    return S;
  }
  let l = t.from, u = t.to, f = t.text, c = Be(e, l.line), d = Be(e, u.line), h = vt(f), p = o(f.length - 1), v = u.line - l.line;
  if (t.full)
    e.insert(0, a(0, f.length)), e.remove(f.length, e.size - f.length);
  else if (nB(e, t)) {
    let y = a(0, f.length - 1);
    s(d, d.text, p), v && e.remove(l.line, v), y.length && e.insert(l.line, y);
  } else if (c == d)
    if (f.length == 1)
      s(c, c.text.slice(0, l.ch) + h + c.text.slice(u.ch), p);
    else {
      let y = a(1, f.length - 1);
      y.push(new rc(h + c.text.slice(u.ch), p, n)), s(c, c.text.slice(0, l.ch) + f[0], o(0)), e.insert(l.line + 1, y);
    }
  else if (f.length == 1)
    s(c, c.text.slice(0, l.ch) + f[0] + d.text.slice(u.ch), o(0)), e.remove(l.line + 1, v);
  else {
    s(c, c.text.slice(0, l.ch) + f[0], o(0)), s(d, h + d.text.slice(u.ch), p);
    let y = a(1, f.length - 1);
    v > 1 && e.remove(l.line + 1, v - 1), e.insert(l.line + 1, y);
  }
  ir(e, "change", e, t);
}
function ts(e, t, r) {
  function n(o, s, a) {
    if (o.linked)
      for (let l = 0; l < o.linked.length; ++l) {
        let u = o.linked[l];
        if (u.doc == s)
          continue;
        let f = a && u.sharedHist;
        r && !f || (t(u.doc, f), n(u.doc, o, f));
      }
  }
  n(e, null, !0);
}
function iB(e, t) {
  if (t.cm)
    throw new Error("This document is already in use.");
  e.doc = t, t.cm = e, xR(e), tE(e), oB(e), e.options.lineWrapping || gR(e), e.options.mode = t.modeOption, qr(e);
}
function oB(e) {
  (e.doc.direction == "rtl" ? el : Za)(e.display.lineDiv, "CodeMirror-rtl");
}
function Ode(e) {
  en(e, () => {
    oB(e), qr(e);
  });
}
function Xd(e) {
  this.done = [], this.undone = [], this.undoDepth = e ? e.undoDepth : 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = e ? e.maxGeneration : 1;
}
function rE(e, t) {
  let r = { from: GS(t.from), to: hs(t), text: ya(e, t.from, t.to) };
  return iI(e, r, t.from.line, t.to.line + 1), ts(e, (n) => iI(n, r, t.from.line, t.to.line + 1), !0), r;
}
function sB(e) {
  for (; e.length && vt(e).ranges; )
    e.pop();
}
function Lde(e, t) {
  if (t)
    return sB(e.done), vt(e.done);
  if (e.done.length && !vt(e.done).ranges)
    return vt(e.done);
  if (e.done.length > 1 && !e.done[e.done.length - 2].ranges)
    return e.done.pop(), vt(e.done);
}
function aB(e, t, r, n) {
  let o = e.history;
  o.undone.length = 0;
  let s = +/* @__PURE__ */ new Date(), a, l;
  if ((o.lastOp == n || o.lastOrigin == t.origin && t.origin && (t.origin.charAt(0) == "+" && o.lastModTime > s - (e.cm ? e.cm.options.historyEventDelay : 500) || t.origin.charAt(0) == "*")) && (a = Lde(o, o.lastOp == n)))
    l = vt(a.changes), Xe(t.from, t.to) == 0 && Xe(t.from, l.to) == 0 ? l.to = hs(t) : a.changes.push(rE(e, t));
  else {
    let u = vt(o.done);
    for ((!u || !u.ranges) && jh(e.sel, o.done), a = {
      changes: [rE(e, t)],
      generation: o.generation
    }, o.done.push(a); o.done.length > o.undoDepth; )
      o.done.shift(), o.done[0].ranges || o.done.shift();
  }
  o.done.push(r), o.generation = ++o.maxGeneration, o.lastModTime = o.lastSelTime = s, o.lastOp = o.lastSelOp = n, o.lastOrigin = o.lastSelOrigin = t.origin, l || Ht(e, "historyAdded");
}
function Pde(e, t, r, n) {
  let o = t.charAt(0);
  return o == "*" || o == "+" && r.ranges.length == n.ranges.length && r.somethingSelected() == n.somethingSelected() && /* @__PURE__ */ new Date() - e.history.lastSelTime <= (e.cm ? e.cm.options.historyEventDelay : 500);
}
function Dde(e, t, r, n) {
  let o = e.history, s = n && n.origin;
  r == o.lastSelOp || s && o.lastSelOrigin == s && (o.lastModTime == o.lastSelTime && o.lastOrigin == s || Pde(e, s, vt(o.done), t)) ? o.done[o.done.length - 1] = t : jh(t, o.done), o.lastSelTime = +/* @__PURE__ */ new Date(), o.lastSelOrigin = s, o.lastSelOp = r, n && n.clearRedo !== !1 && sB(o.undone);
}
function jh(e, t) {
  let r = vt(t);
  r && r.ranges && r.equals(e) || t.push(e);
}
function iI(e, t, r, n) {
  let o = t["spans_" + e.id], s = 0;
  e.iter(Math.max(e.first, r), Math.min(e.first + e.size, n), (a) => {
    a.markedSpans && ((o || (o = t["spans_" + e.id] = {}))[s] = a.markedSpans), ++s;
  });
}
function Fde(e) {
  if (!e)
    return null;
  let t;
  for (let r = 0; r < e.length; ++r)
    e[r].marker.explicitlyCleared ? t || (t = e.slice(0, r)) : t && t.push(e[r]);
  return t ? t.length ? t : null : e;
}
function jde(e, t) {
  let r = t["spans_" + e.id];
  if (!r)
    return null;
  let n = [];
  for (let o = 0; o < t.text.length; ++o)
    n.push(Fde(r[o]));
  return n;
}
function oI(e, t) {
  let r = jde(e, t), n = KS(e, t);
  if (!r)
    return n;
  if (!n)
    return r;
  for (let o = 0; o < r.length; ++o) {
    let s = r[o], a = n[o];
    if (s && a)
      e:
        for (let l = 0; l < a.length; ++l) {
          let u = a[l];
          for (let f = 0; f < s.length; ++f)
            if (s[f].marker == u.marker)
              continue e;
          s.push(u);
        }
    else
      a && (r[o] = a);
  }
  return r;
}
function cl(e, t, r) {
  let n = [];
  for (let s = 0; s < e.length; ++s) {
    let a = e[s];
    if (a.ranges) {
      n.push(r ? xs.prototype.deepCopy.call(a) : a);
      continue;
    }
    let l = a.changes, u = [];
    n.push({ changes: u });
    for (let f = 0; f < l.length; ++f) {
      let c = l[f], d;
      if (u.push({ from: c.from, to: c.to, text: c.text }), t)
        for (var o in c)
          (d = o.match(/^spans_(\d+)$/)) && _r(t, Number(d[1])) > -1 && (vt(u)[o] = c[o], delete c[o]);
    }
  }
  return n;
}
function LR(e, t, r, n) {
  if (n) {
    let o = e.anchor;
    if (r) {
      let s = Xe(t, o) < 0;
      s != Xe(r, o) < 0 ? (o = t, t = r) : s != Xe(t, r) < 0 && (t = r);
    }
    return new wt(o, t);
  } else
    return new wt(r || t, t);
}
function Lg(e, t, r, n, o) {
  o == null && (o = e.cm && (e.cm.display.shift || e.extend)), pr(e, new xs([LR(e.sel.primary(), t, r, o)], 0), n);
}
function sI(e, t, r) {
  let n = [], o = e.cm && (e.cm.display.shift || e.extend);
  for (let a = 0; a < e.sel.ranges.length; a++)
    n[a] = LR(e.sel.ranges[a], t[a], null, o);
  let s = Gn(e.cm, n, e.sel.primIndex);
  pr(e, s, r);
}
function PR(e, t, r, n) {
  let o = e.sel.ranges.slice(0);
  o[t] = r, pr(e, Gn(e.cm, o, e.sel.primIndex), n);
}
function aI(e, t, r, n) {
  pr(e, ds(t, r), n);
}
function Bde(e, t, r) {
  let n = {
    ranges: t.ranges,
    update: function(o) {
      this.ranges = [];
      for (let s = 0; s < o.length; s++)
        this.ranges[s] = new wt(Ye(e, o[s].anchor), Ye(e, o[s].head));
    },
    origin: r && r.origin
  };
  return Ht(e, "beforeSelectionChange", e, n), e.cm && Ht(e.cm, "beforeSelectionChange", e.cm, n), n.ranges != t.ranges ? Gn(e.cm, n.ranges, n.ranges.length - 1) : t;
}
function lB(e, t, r) {
  let n = e.history.done, o = vt(n);
  o && o.ranges ? (n[n.length - 1] = t, Pg(e, t, r)) : pr(e, t, r);
}
function pr(e, t, r) {
  Pg(e, t, r), Dde(e, e.sel, e.cm ? e.cm.curOp.id : NaN, r);
}
function Pg(e, t, r) {
  (An(e, "beforeSelectionChange") || e.cm && An(e.cm, "beforeSelectionChange")) && (t = Bde(e, t, r));
  let n = r && r.bias || (Xe(t.primary().head, e.sel.primary().head) < 0 ? -1 : 1);
  uB(e, cB(e, t, n, !0)), !(r && r.scroll === !1) && e.cm && e.cm.getOption("readOnly") != "nocursor" && Ru(e.cm);
}
function uB(e, t) {
  t.equals(e.sel) || (e.sel = t, e.cm && (e.cm.curOp.updateInput = 1, e.cm.curOp.selectionChanged = !0, dj(e.cm)), ir(e, "cursorActivity", e));
}
function fB(e) {
  uB(e, cB(e, e.sel, null, !1));
}
function cB(e, t, r, n) {
  let o;
  for (let s = 0; s < t.ranges.length; s++) {
    let a = t.ranges[s], l = t.ranges.length == e.sel.ranges.length && e.sel.ranges[s], u = Bh(e, a.anchor, l && l.anchor, r, n), f = Bh(e, a.head, l && l.head, r, n);
    (o || u != a.anchor || f != a.head) && (o || (o = t.ranges.slice(0, s)), o[s] = new wt(u, f));
  }
  return o ? Gn(e.cm, o, t.primIndex) : t;
}
function Al(e, t, r, n, o) {
  let s = Be(e, t.line);
  if (s.markedSpans)
    for (let a = 0; a < s.markedSpans.length; ++a) {
      let l = s.markedSpans[a], u = l.marker, f = "selectLeft" in u ? !u.selectLeft : u.inclusiveLeft, c = "selectRight" in u ? !u.selectRight : u.inclusiveRight;
      if ((l.from == null || (f ? l.from <= t.ch : l.from < t.ch)) && (l.to == null || (c ? l.to >= t.ch : l.to > t.ch))) {
        if (o && (Ht(u, "beforeCursorEnter"), u.explicitlyCleared))
          if (s.markedSpans) {
            --a;
            continue;
          } else
            break;
        if (!u.atomic)
          continue;
        if (r) {
          let h = u.find(n < 0 ? 1 : -1), p;
          if ((n < 0 ? c : f) && (h = lI(e, h, -n, h && h.line == t.line ? s : null)), h && h.line == t.line && (p = Xe(h, r)) && (n < 0 ? p < 0 : p > 0))
            return Al(e, h, t, n, o);
        }
        let d = u.find(n < 0 ? -1 : 1);
        return (n < 0 ? f : c) && (d = lI(e, d, n, d.line == t.line ? s : null)), d ? Al(e, d, t, n, o) : null;
      }
    }
  return t;
}
function Bh(e, t, r, n, o) {
  let s = n || 1, a = Al(e, t, r, s, o) || !o && Al(e, t, r, s, !0) || Al(e, t, r, -s, o) || !o && Al(e, t, r, -s, !0);
  return a || (e.cantEdit = !0, Ee(e.first, 0));
}
function lI(e, t, r, n) {
  return r < 0 && t.ch == 0 ? t.line > e.first ? Ye(e, Ee(t.line - 1)) : null : r > 0 && t.ch == (n || Be(e, t.line)).text.length ? t.line < e.first + e.size - 1 ? Ee(t.line + 1, 0) : null : new Ee(t.line, t.ch + r);
}
function dB(e) {
  e.setSelection(Ee(e.firstLine(), 0), Ee(e.lastLine()), Ci);
}
function hB(e, t, r) {
  let n = {
    canceled: !1,
    from: t.from,
    to: t.to,
    text: t.text,
    origin: t.origin,
    cancel: () => n.canceled = !0
  };
  return r && (n.update = (o, s, a, l) => {
    o && (n.from = Ye(e, o)), s && (n.to = Ye(e, s)), a && (n.text = a), l !== void 0 && (n.origin = l);
  }), Ht(e, "beforeChange", e, n), e.cm && Ht(e.cm, "beforeChange", e.cm, n), n.canceled ? (e.cm && (e.cm.curOp.updateInput = 2), null) : { from: n.from, to: n.to, text: n.text, origin: n.origin };
}
function iu(e, t, r) {
  if (e.cm) {
    if (!e.cm.curOp)
      return tr(e.cm, iu)(e, t, r);
    if (e.cm.state.suppressEdits)
      return;
  }
  if ((An(e, "beforeChange") || e.cm && An(e.cm, "beforeChange")) && (t = hB(e, t, !0), !t))
    return;
  let n = _j && !r && Lce(e, t.from, t.to);
  if (n)
    for (let o = n.length - 1; o >= 0; --o)
      uI(e, { from: n[o].from, to: n[o].to, text: o ? [""] : t.text, origin: t.origin });
  else
    uI(e, t);
}
function uI(e, t) {
  if (t.text.length == 1 && t.text[0] == "" && Xe(t.from, t.to) == 0)
    return;
  let r = MR(e, t);
  aB(e, t, r, e.cm ? e.cm.curOp.id : NaN), ac(e, t, r, KS(e, t));
  let n = [];
  ts(e, (o, s) => {
    !s && _r(n, o.history) == -1 && (pB(o.history, t), n.push(o.history)), ac(o, t, null, KS(o, t));
  });
}
function Ed(e, t, r) {
  let n = e.cm && e.cm.state.suppressEdits;
  if (n && !r)
    return;
  let o = e.history, s, a = e.sel, l = t == "undo" ? o.done : o.undone, u = t == "undo" ? o.undone : o.done, f = 0;
  for (; f < l.length && (s = l[f], !(r ? s.ranges && !s.equals(e.sel) : !s.ranges)); f++)
    ;
  if (f == l.length)
    return;
  for (o.lastOrigin = o.lastSelOrigin = null; ; )
    if (s = l.pop(), s.ranges) {
      if (jh(s, u), r && !s.equals(e.sel)) {
        pr(e, s, { clearRedo: !1 });
        return;
      }
      a = s;
    } else if (n) {
      l.push(s);
      return;
    } else
      break;
  let c = [];
  jh(a, u), u.push({ changes: c, generation: o.generation }), o.generation = s.generation || ++o.maxGeneration;
  let d = An(e, "beforeChange") || e.cm && An(e.cm, "beforeChange");
  for (let h = s.changes.length - 1; h >= 0; --h) {
    let p = s.changes[h];
    if (p.origin = t, d && !hB(e, p, !1)) {
      l.length = 0;
      return;
    }
    c.push(rE(e, p));
    let v = h ? MR(e, p) : vt(l);
    ac(e, p, v, oI(e, p)), !h && e.cm && e.cm.scrollIntoView({ from: p.from, to: hs(p) });
    let y = [];
    ts(e, (w, S) => {
      !S && _r(y, w.history) == -1 && (pB(w.history, p), y.push(w.history)), ac(w, p, null, oI(w, p));
    });
  }
}
function fI(e, t) {
  if (t != 0 && (e.first += t, e.sel = new xs(Rg(e.sel.ranges, (r) => new wt(Ee(r.anchor.line + t, r.anchor.ch), Ee(r.head.line + t, r.head.ch))), e.sel.primIndex), e.cm)) {
    qr(e.cm, e.first, e.first - t, t);
    for (let r = e.cm.display, n = r.viewFrom; n < r.viewTo; n++)
      Es(e.cm, n, "gutter");
  }
}
function ac(e, t, r, n) {
  if (e.cm && !e.cm.curOp)
    return tr(e.cm, ac)(e, t, r, n);
  if (t.to.line < e.first) {
    fI(e, t.text.length - 1 - (t.to.line - t.from.line));
    return;
  }
  if (t.from.line > e.lastLine())
    return;
  if (t.from.line < e.first) {
    let s = t.text.length - 1 - (e.first - t.from.line);
    fI(e, s), t = {
      from: Ee(e.first, 0),
      to: Ee(t.to.line + s, t.to.ch),
      text: [vt(t.text)],
      origin: t.origin
    };
  }
  let o = e.lastLine();
  t.to.line > o && (t = {
    from: t.from,
    to: Ee(o, Be(e, o).text.length),
    text: [t.text[0]],
    origin: t.origin
  }), t.removed = ya(e, t.from, t.to), r || (r = MR(e, t)), e.cm ? qde(e.cm, t, n) : OR(e, t, n), Pg(e, r, Ci), e.cantEdit && Bh(e, Ee(e.firstLine(), 0)) && (e.cantEdit = !1);
}
function qde(e, t, r) {
  let n = e.doc, o = e.display, s = t.from, a = t.to, l = !1, u = s.line;
  e.options.lineWrapping || (u = mt(Mi(Be(n, s.line))), n.iter(u, a.line + 1, (h) => {
    if (h == o.maxLine)
      return l = !0, !0;
  })), n.sel.contains(t.from, t.to) > -1 && dj(e), OR(n, t, r, Uj(e)), e.options.lineWrapping || (n.iter(u, s.line + t.text.length, (h) => {
    let p = Dh(h);
    p > o.maxLineLength && (o.maxLine = h, o.maxLineLength = p, o.maxLineChanged = !0, l = !1);
  }), l && (e.curOp.updateMaxLine = !0)), $ce(n, s.line), Mc(e, 400);
  let f = t.text.length - (a.line - s.line) - 1;
  t.full ? qr(e) : s.line == a.line && t.text.length == 1 && !nB(e.doc, t) ? Es(e, s.line, "text") : qr(e, s.line, a.line + 1, f);
  let c = An(e, "changes"), d = An(e, "change");
  if (d || c) {
    let h = {
      from: s,
      to: a,
      text: t.text,
      removed: t.removed,
      origin: t.origin
    };
    d && ir(e, "change", e, h), c && (e.curOp.changeObjs || (e.curOp.changeObjs = [])).push(h);
  }
  e.display.selForContextMenu = null;
}
function Au(e, t, r, n, o) {
  n || (n = r), Xe(n, r) < 0 && ([r, n] = [n, r]), typeof t == "string" && (t = e.splitLines(t)), iu(e, { from: r, to: n, text: t, origin: o });
}
function cI(e, t, r, n) {
  r < e.line ? e.line += n : t < e.line && (e.line = t, e.ch = 0);
}
function dI(e, t, r, n) {
  for (let o = 0; o < e.length; ++o) {
    let s = e[o], a = !0;
    if (s.ranges) {
      s.copied || (s = e[o] = s.deepCopy(), s.copied = !0);
      for (let l = 0; l < s.ranges.length; l++)
        cI(s.ranges[l].anchor, t, r, n), cI(s.ranges[l].head, t, r, n);
      continue;
    }
    for (let l = 0; l < s.changes.length; ++l) {
      let u = s.changes[l];
      if (r < u.from.line)
        u.from = Ee(u.from.line + n, u.from.ch), u.to = Ee(u.to.line + n, u.to.ch);
      else if (t <= u.to.line) {
        a = !1;
        break;
      }
    }
    a || (e.splice(0, o + 1), o = 0);
  }
}
function pB(e, t) {
  let r = t.from.line, n = t.to.line, o = t.text.length - (n - r) - 1;
  dI(e.done, r, n, o), dI(e.undone, r, n, o);
}
function nf(e, t, r, n) {
  let o = t, s = t;
  return typeof t == "number" ? s = Be(e, bj(e, t)) : o = mt(t), o == null ? null : (n(s, o) && e.cm && Es(e.cm, o, r), s);
}
function If(e) {
  this.lines = e, this.parent = null;
  let t = 0;
  for (let r = 0; r < e.length; ++r)
    e[r].parent = this, t += e[r].height;
  this.height = t;
}
If.prototype = {
  chunkSize() {
    return this.lines.length;
  },
  removeInner(e, t) {
    for (let r = e, n = e + t; r < n; ++r) {
      let o = this.lines[r];
      this.height -= o.height, Bce(o), ir(o, "delete");
    }
    this.lines.splice(e, t);
  },
  collapse(e) {
    e.push.apply(e, this.lines);
  },
  insertInner(e, t, r) {
    this.height += r, this.lines = this.lines.slice(0, e).concat(t).concat(this.lines.slice(e));
    for (let n = 0; n < t.length; ++n)
      t[n].parent = this;
  },
  iterN(e, t, r) {
    for (let n = e + t; e < n; ++e)
      if (r(this.lines[e]))
        return !0;
  }
};
function Mf(e) {
  this.children = e;
  let t = 0, r = 0;
  for (let n = 0; n < e.length; ++n) {
    let o = e[n];
    t += o.chunkSize(), r += o.height, o.parent = this;
  }
  this.size = t, this.height = r, this.parent = null;
}
Mf.prototype = {
  chunkSize() {
    return this.size;
  },
  removeInner(e, t) {
    this.size -= t;
    for (let r = 0; r < this.children.length; ++r) {
      let n = this.children[r], o = n.chunkSize();
      if (e < o) {
        let s = Math.min(t, o - e), a = n.height;
        if (n.removeInner(e, s), this.height -= a - n.height, o == s && (this.children.splice(r--, 1), n.parent = null), (t -= s) == 0)
          break;
        e = 0;
      } else
        e -= o;
    }
    if (this.size - t < 25 && (this.children.length > 1 || !(this.children[0] instanceof If))) {
      let r = [];
      this.collapse(r), this.children = [new If(r)], this.children[0].parent = this;
    }
  },
  collapse(e) {
    for (let t = 0; t < this.children.length; ++t)
      this.children[t].collapse(e);
  },
  insertInner(e, t, r) {
    this.size += t.length, this.height += r;
    for (let n = 0; n < this.children.length; ++n) {
      let o = this.children[n], s = o.chunkSize();
      if (e <= s) {
        if (o.insertInner(e, t, r), o.lines && o.lines.length > 50) {
          let a = o.lines.length % 25 + 25;
          for (let l = a; l < o.lines.length; ) {
            let u = new If(o.lines.slice(l, l += 25));
            o.height -= u.height, this.children.splice(++n, 0, u), u.parent = this;
          }
          o.lines = o.lines.slice(0, a), this.maybeSpill();
        }
        break;
      }
      e -= s;
    }
  },
  maybeSpill() {
    if (this.children.length <= 10)
      return;
    let e = this;
    do {
      let t = e.children.splice(e.children.length - 5, 5), r = new Mf(t);
      if (e.parent) {
        e.size -= r.size, e.height -= r.height;
        let n = _r(e.parent.children, e);
        e.parent.children.splice(n + 1, 0, r);
      } else {
        let n = new Mf(e.children);
        n.parent = e, e.children = [n, r], e = n;
      }
      r.parent = e.parent;
    } while (e.children.length > 10);
    e.parent.maybeSpill();
  },
  iterN(e, t, r) {
    for (let n = 0; n < this.children.length; ++n) {
      let o = this.children[n], s = o.chunkSize();
      if (e < s) {
        let a = Math.min(t, s - e);
        if (o.iterN(e, a, r))
          return !0;
        if ((t -= a) == 0)
          break;
        e = 0;
      } else
        e -= s;
    }
  }
};
var DR = class {
  constructor(e, t, r) {
    if (r)
      for (let n in r)
        r.hasOwnProperty(n) && (this[n] = r[n]);
    this.doc = e, this.node = t;
  }
  clear() {
    let e = this.doc.cm, t = this.line.widgets, r = this.line, n = mt(r);
    if (n == null || !t)
      return;
    for (let s = 0; s < t.length; ++s)
      t[s] == this && t.splice(s--, 1);
    t.length || (r.widgets = null);
    let o = ic(this);
    Ii(r, Math.max(0, r.height - o)), e && (en(e, () => {
      hI(e, r, -o), Es(e, n, "widget");
    }), ir(e, "lineWidgetCleared", e, this, n));
  }
  changed() {
    let e = this.height, t = this.doc.cm, r = this.line;
    this.height = null;
    let n = ic(this) - e;
    n && (cs(this.doc, r) || Ii(r, r.height + n), t && en(t, () => {
      t.curOp.forceUpdate = !0, hI(t, r, n), ir(t, "lineWidgetChanged", t, this, mt(r));
    }));
  }
};
wu(DR);
function hI(e, t, r) {
  vo(t) < (e.curOp && e.curOp.scrollTop || e.doc.scrollTop) && NR(e, r);
}
function Wde(e, t, r, n) {
  let o = new DR(e, r, n), s = e.cm;
  return s && o.noHScroll && (s.display.alignWidgets = !0), nf(e, t, "widget", (a) => {
    let l = a.widgets || (a.widgets = []);
    if (o.insertAt == null ? l.push(o) : l.splice(Math.min(l.length, Math.max(0, o.insertAt)), 0, o), o.line = a, s && !cs(e, a)) {
      let u = vo(a) < e.scrollTop;
      Ii(a, a.height + ic(o)), u && NR(s, o.height), s.curOp.forceUpdate = !0;
    }
    return !0;
  }), s && ir(s, "lineWidgetAdded", s, o, typeof t == "number" ? t : mt(t)), o;
}
var gB = 0, FR = class {
  constructor(e, t) {
    this.lines = [], this.type = t, this.doc = e, this.id = ++gB;
  }
  clear() {
    if (this.explicitlyCleared)
      return;
    let e = this.doc.cm, t = e && !e.curOp;
    if (t && nl(e), An(this, "clear")) {
      let o = this.find();
      o && ir(this, "clear", o.from, o.to);
    }
    let r = null, n = null;
    for (let o = 0; o < this.lines.length; ++o) {
      let s = this.lines[o], a = tc(s.markedSpans, this);
      e && !this.collapsed ? Es(e, mt(s), "text") : e && (a.to != null && (n = mt(s)), a.from != null && (r = mt(s))), s.markedSpans = Cce(s.markedSpans, a), a.from == null && this.collapsed && !cs(this.doc, s) && e && Ii(s, ru(e.display));
    }
    if (e && this.collapsed && !e.options.lineWrapping)
      for (let o = 0; o < this.lines.length; ++o) {
        let s = Mi(this.lines[o]), a = Dh(s);
        a > e.display.maxLineLength && (e.display.maxLine = s, e.display.maxLineLength = a, e.display.maxLineChanged = !0);
      }
    r != null && e && this.collapsed && qr(e, r, n + 1), this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, e && fB(e.doc)), e && ir(e, "markerCleared", e, this, r, n), t && il(e), this.parent && this.parent.clear();
  }
  find(e, t) {
    e == null && this.type == "bookmark" && (e = 1);
    let r, n;
    for (let o = 0; o < this.lines.length; ++o) {
      let s = this.lines[o], a = tc(s.markedSpans, this);
      if (a.from != null && (r = Ee(t ? s : mt(s), a.from), e == -1))
        return r;
      if (a.to != null && (n = Ee(t ? s : mt(s), a.to), e == 1))
        return n;
    }
    return r && { from: r, to: n };
  }
  changed() {
    let e = this.find(-1, !0), t = this, r = this.doc.cm;
    !e || !r || en(r, () => {
      let n = e.line, o = mt(e.line), s = mR(r, o);
      if (s && (Dj(s), r.curOp.selectionChanged = r.curOp.forceUpdate = !0), r.curOp.updateMaxLine = !0, !cs(t.doc, n) && t.height != null) {
        let a = t.height;
        t.height = null;
        let l = ic(t) - a;
        l && Ii(n, n.height + l);
      }
      ir(r, "markerChanged", r, this);
    });
  }
  attachLine(e) {
    if (!this.lines.length && this.doc.cm) {
      let t = this.doc.cm.curOp;
      (!t.maybeHiddenMarkers || _r(t.maybeHiddenMarkers, this) == -1) && (t.maybeUnhiddenMarkers || (t.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(e);
  }
  detachLine(e) {
    if (this.lines.splice(_r(this.lines, e), 1), !this.lines.length && this.doc.cm) {
      let t = this.doc.cm.curOp;
      (t.maybeHiddenMarkers || (t.maybeHiddenMarkers = [])).push(this);
    }
  }
};
wu(FR);
function ou(e, t, r, n, o) {
  if (n && n.shared)
    return Ude(e, t, r, n, o);
  if (e.cm && !e.cm.curOp)
    return tr(e.cm, ou)(e, t, r, n, o);
  let s = new FR(e, o), a = Xe(t, r);
  if (n && ka(n, s, !1), a > 0 || a == 0 && s.clearWhenEmpty !== !1)
    return s;
  if (s.replacedWith && (s.collapsed = !0, s.widgetNode = Dl("span", [s.replacedWith], "CodeMirror-widget"), n.handleMouseEvents || s.widgetNode.setAttribute("cm-ignore-events", "true"), n.insertLeft && (s.widgetNode.insertLeft = !0)), s.collapsed) {
    if (zC(e, t.line, t, r, s) || t.line != r.line && zC(e, r.line, t, r, s))
      throw new Error("Inserting collapsed marker partially overlapping an existing one");
    kce();
  }
  s.addToHistory && aB(e, { from: t, to: r, origin: "markText" }, e.sel, NaN);
  let l = t.line, u = e.cm, f;
  if (e.iter(l, r.line + 1, (c) => {
    u && s.collapsed && !u.options.lineWrapping && Mi(c) == u.display.maxLine && (f = !0), s.collapsed && l != t.line && Ii(c, 0), Ice(c, new Ng(s, l == t.line ? t.ch : null, l == r.line ? r.ch : null)), ++l;
  }), s.collapsed && e.iter(t.line, r.line + 1, (c) => {
    cs(e, c) && Ii(c, 0);
  }), s.clearOnEnter && Ve(s, "beforeCursorEnter", () => s.clear()), s.readOnly && (Nce(), (e.history.done.length || e.history.undone.length) && e.clearHistory()), s.collapsed && (s.id = ++gB, s.atomic = !0), u) {
    if (f && (u.curOp.updateMaxLine = !0), s.collapsed)
      qr(u, t.line, r.line + 1);
    else if (s.className || s.startStyle || s.endStyle || s.css || s.attributes || s.title)
      for (let c = t.line; c <= r.line; c++)
        Es(u, c, "text");
    s.atomic && fB(u.doc), ir(u, "markerAdded", u, s);
  }
  return s;
}
var jR = class {
  constructor(e, t) {
    this.markers = e, this.primary = t;
    for (let r = 0; r < e.length; ++r)
      e[r].parent = this;
  }
  clear() {
    if (!this.explicitlyCleared) {
      this.explicitlyCleared = !0;
      for (let e = 0; e < this.markers.length; ++e)
        this.markers[e].clear();
      ir(this, "clear");
    }
  }
  find(e, t) {
    return this.primary.find(e, t);
  }
};
wu(jR);
function Ude(e, t, r, n, o) {
  n = ka(n), n.shared = !1;
  let s = [ou(e, t, r, n, o)], a = s[0], l = n.widgetNode;
  return ts(e, (u) => {
    l && (n.widgetNode = l.cloneNode(!0)), s.push(ou(u, Ye(u, t), Ye(u, r), n, o));
    for (let f = 0; f < u.linked.length; ++f)
      if (u.linked[f].isParent)
        return;
    a = vt(s);
  }), new jR(s, a);
}
function pI(e) {
  return e.findMarks(Ee(e.first, 0), e.clipPos(Ee(e.lastLine())), (t) => t.parent);
}
function Hde(e, t) {
  for (let r = 0; r < t.length; r++) {
    let n = t[r], o = n.find(), s = e.clipPos(o.from), a = e.clipPos(o.to);
    if (Xe(s, a)) {
      let l = ou(e, s, a, n.primary, n.primary.type);
      n.markers.push(l), l.parent = n;
    }
  }
}
function Vde(e) {
  for (let t = 0; t < e.length; t++) {
    let r = e[t], n = [r.primary.doc];
    ts(r.primary.doc, (o) => n.push(o));
    for (let o = 0; o < r.markers.length; o++) {
      let s = r.markers[o];
      _r(n, s.doc) == -1 && (s.parent = null, r.markers.splice(o--, 1));
    }
  }
}
var zde = 0, Qi = function(e, t, r, n, o) {
  if (!(this instanceof Qi))
    return new Qi(e, t, r, n, o);
  r == null && (r = 0), Mf.call(this, [new If([new rc("", null)])]), this.first = r, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, this.cleanGeneration = 1, this.modeFrontier = this.highlightFrontier = r;
  let s = Ee(r, 0);
  this.sel = ds(s), this.history = new Xd(null), this.id = ++zde, this.modeOption = t, this.lineSep = n, this.direction = o == "rtl" ? "rtl" : "ltr", this.extend = !1, typeof e == "string" && (e = this.splitLines(e)), OR(this, { from: s, to: s, text: e }), pr(this, ds(s), Ci);
};
Qi.prototype = uj(Mf.prototype, {
  constructor: Qi,
  iter: function(e, t, r) {
    r ? this.iterN(e - this.first, t - e, r) : this.iterN(this.first, this.first + this.size, e);
  },
  insert: function(e, t) {
    let r = 0;
    for (let n = 0; n < t.length; ++n)
      r += t[n].height;
    this.insertInner(e - this.first, t, r);
  },
  remove: function(e, t) {
    this.removeInner(e - this.first, t);
  },
  getValue: function(e) {
    let t = E0(this, this.first, this.first + this.size);
    return e === !1 ? t : t.join(e || this.lineSeparator());
  },
  setValue: Jt(function(e) {
    let t = Ee(this.first, 0), r = this.first + this.size - 1;
    iu(this, {
      from: t,
      to: Ee(r, Be(this, r).text.length),
      text: this.splitLines(e),
      origin: "setValue",
      full: !0
    }, !0), this.cm && Cf(this.cm, 0, 0), pr(this, ds(t), Ci);
  }),
  replaceRange: function(e, t, r, n) {
    t = Ye(this, t), r = r ? Ye(this, r) : t, Au(this, e, t, r, n);
  },
  getRange: function(e, t, r) {
    let n = ya(this, Ye(this, e), Ye(this, t));
    return r === !1 ? n : n.join(r || this.lineSeparator());
  },
  getLine: function(e) {
    let t = this.getLineHandle(e);
    return t && t.text;
  },
  getLineHandle: function(e) {
    if (ec(this, e))
      return Be(this, e);
  },
  getLineNumber: function(e) {
    return mt(e);
  },
  getLineHandleVisualStart: function(e) {
    return typeof e == "number" && (e = Be(this, e)), Mi(e);
  },
  lineCount: function() {
    return this.size;
  },
  firstLine: function() {
    return this.first;
  },
  lastLine: function() {
    return this.first + this.size - 1;
  },
  clipPos: function(e) {
    return Ye(this, e);
  },
  getCursor: function(e) {
    let t = this.sel.primary(), r;
    return e == null || e == "head" ? r = t.head : e == "anchor" ? r = t.anchor : e == "end" || e == "to" || e === !1 ? r = t.to() : r = t.from(), r;
  },
  listSelections: function() {
    return this.sel.ranges;
  },
  somethingSelected: function() {
    return this.sel.somethingSelected();
  },
  setCursor: Jt(function(e, t, r) {
    aI(this, Ye(this, typeof e == "number" ? Ee(e, t || 0) : e), null, r);
  }),
  setSelection: Jt(function(e, t, r) {
    aI(this, Ye(this, e), Ye(this, t || e), r);
  }),
  extendSelection: Jt(function(e, t, r) {
    Lg(this, Ye(this, e), t && Ye(this, t), r);
  }),
  extendSelections: Jt(function(e, t) {
    sI(this, BC(this, e), t);
  }),
  extendSelectionsBy: Jt(function(e, t) {
    let r = Rg(this.sel.ranges, e);
    sI(this, BC(this, r), t);
  }),
  setSelections: Jt(function(e, t, r) {
    if (!e.length)
      return;
    let n = [];
    for (let o = 0; o < e.length; o++)
      n[o] = new wt(Ye(this, e[o].anchor), Ye(this, e[o].head || e[o].anchor));
    t == null && (t = Math.min(e.length - 1, this.sel.primIndex)), pr(this, Gn(this.cm, n, t), r);
  }),
  addSelection: Jt(function(e, t, r) {
    let n = this.sel.ranges.slice(0);
    n.push(new wt(Ye(this, e), Ye(this, t || e))), pr(this, Gn(this.cm, n, n.length - 1), r);
  }),
  getSelection: function(e) {
    let t = this.sel.ranges, r;
    for (let n = 0; n < t.length; n++) {
      let o = ya(this, t[n].from(), t[n].to());
      r = r ? r.concat(o) : o;
    }
    return e === !1 ? r : r.join(e || this.lineSeparator());
  },
  getSelections: function(e) {
    let t = [], r = this.sel.ranges;
    for (let n = 0; n < r.length; n++) {
      let o = ya(this, r[n].from(), r[n].to());
      e !== !1 && (o = o.join(e || this.lineSeparator())), t[n] = o;
    }
    return t;
  },
  replaceSelection: function(e, t, r) {
    let n = [];
    for (let o = 0; o < this.sel.ranges.length; o++)
      n[o] = e;
    this.replaceSelections(n, t, r || "+input");
  },
  replaceSelections: Jt(function(e, t, r) {
    let n = [], o = this.sel;
    for (let a = 0; a < o.ranges.length; a++) {
      let l = o.ranges[a];
      n[a] = { from: l.from(), to: l.to(), text: this.splitLines(e[a]), origin: r };
    }
    let s = t && t != "end" && Mde(this, n, t);
    for (let a = n.length - 1; a >= 0; a--)
      iu(this, n[a]);
    s ? lB(this, s) : this.cm && Ru(this.cm);
  }),
  undo: Jt(function() {
    Ed(this, "undo");
  }),
  redo: Jt(function() {
    Ed(this, "redo");
  }),
  undoSelection: Jt(function() {
    Ed(this, "undo", !0);
  }),
  redoSelection: Jt(function() {
    Ed(this, "redo", !0);
  }),
  setExtending: function(e) {
    this.extend = e;
  },
  getExtending: function() {
    return this.extend;
  },
  historySize: function() {
    let e = this.history, t = 0, r = 0;
    for (let n = 0; n < e.done.length; n++)
      e.done[n].ranges || ++t;
    for (let n = 0; n < e.undone.length; n++)
      e.undone[n].ranges || ++r;
    return { undo: t, redo: r };
  },
  clearHistory: function() {
    this.history = new Xd(this.history), ts(this, (e) => e.history = this.history, !0);
  },
  markClean: function() {
    this.cleanGeneration = this.changeGeneration(!0);
  },
  changeGeneration: function(e) {
    return e && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation;
  },
  isClean: function(e) {
    return this.history.generation == (e || this.cleanGeneration);
  },
  getHistory: function() {
    return {
      done: cl(this.history.done),
      undone: cl(this.history.undone)
    };
  },
  setHistory: function(e) {
    let t = this.history = new Xd(this.history);
    t.done = cl(e.done.slice(0), null, !0), t.undone = cl(e.undone.slice(0), null, !0);
  },
  setGutterMarker: Jt(function(e, t, r) {
    return nf(this, e, "gutter", (n) => {
      let o = n.gutterMarkers || (n.gutterMarkers = {});
      return o[t] = r, !r && jC(o) && (n.gutterMarkers = null), !0;
    });
  }),
  clearGutter: Jt(function(e) {
    this.iter((t) => {
      t.gutterMarkers && t.gutterMarkers[e] && nf(this, t, "gutter", () => (t.gutterMarkers[e] = null, jC(t.gutterMarkers) && (t.gutterMarkers = null), !0));
    });
  }),
  lineInfo: function(e) {
    let t;
    if (typeof e == "number") {
      if (!ec(this, e) || (t = e, e = Be(this, e), !e))
        return null;
    } else if (t = mt(e), t == null)
      return null;
    return {
      line: t,
      handle: e,
      text: e.text,
      gutterMarkers: e.gutterMarkers,
      textClass: e.textClass,
      bgClass: e.bgClass,
      wrapClass: e.wrapClass,
      widgets: e.widgets
    };
  },
  addLineClass: Jt(function(e, t, r) {
    return nf(this, e, t == "gutter" ? "gutter" : "class", (n) => {
      let o = t == "text" ? "textClass" : t == "background" ? "bgClass" : t == "gutter" ? "gutterClass" : "wrapClass";
      if (!n[o])
        n[o] = r;
      else {
        if (eu(r).test(n[o]))
          return !1;
        n[o] += " " + r;
      }
      return !0;
    });
  }),
  removeLineClass: Jt(function(e, t, r) {
    return nf(this, e, t == "gutter" ? "gutter" : "class", (n) => {
      let o = t == "text" ? "textClass" : t == "background" ? "bgClass" : t == "gutter" ? "gutterClass" : "wrapClass", s = n[o];
      if (s)
        if (r == null)
          n[o] = null;
        else {
          let a = s.match(eu(r));
          if (!a)
            return !1;
          let l = a.index + a[0].length;
          n[o] = s.slice(0, a.index) + (!a.index || l == s.length ? "" : " ") + s.slice(l) || null;
        }
      else
        return !1;
      return !0;
    });
  }),
  addLineWidget: Jt(function(e, t, r) {
    return Wde(this, e, t, r);
  }),
  removeLineWidget: function(e) {
    e.clear();
  },
  markText: function(e, t, r) {
    return ou(this, Ye(this, e), Ye(this, t), r, r && r.type || "range");
  },
  setBookmark: function(e, t) {
    let r = {
      replacedWith: t && (t.nodeType == null ? t.widget : t),
      insertLeft: t && t.insertLeft,
      clearWhenEmpty: !1,
      shared: t && t.shared,
      handleMouseEvents: t && t.handleMouseEvents
    };
    return e = Ye(this, e), ou(this, e, e, r, "bookmark");
  },
  findMarksAt: function(e) {
    e = Ye(this, e);
    let t = [], r = Be(this, e.line).markedSpans;
    if (r)
      for (let n = 0; n < r.length; ++n) {
        let o = r[n];
        (o.from == null || o.from <= e.ch) && (o.to == null || o.to >= e.ch) && t.push(o.marker.parent || o.marker);
      }
    return t;
  },
  findMarks: function(e, t, r) {
    e = Ye(this, e), t = Ye(this, t);
    let n = [], o = e.line;
    return this.iter(e.line, t.line + 1, (s) => {
      let a = s.markedSpans;
      if (a)
        for (let l = 0; l < a.length; l++) {
          let u = a[l];
          !(u.to != null && o == e.line && e.ch >= u.to || u.from == null && o != e.line || u.from != null && o == t.line && u.from >= t.ch) && (!r || r(u.marker)) && n.push(u.marker.parent || u.marker);
        }
      ++o;
    }), n;
  },
  getAllMarks: function() {
    let e = [];
    return this.iter((t) => {
      let r = t.markedSpans;
      if (r)
        for (let n = 0; n < r.length; ++n)
          r[n].from != null && e.push(r[n].marker);
    }), e;
  },
  posFromIndex: function(e) {
    let t, r = this.first, n = this.lineSeparator().length;
    return this.iter((o) => {
      let s = o.text.length + n;
      if (s > e)
        return t = e, !0;
      e -= s, ++r;
    }), Ye(this, Ee(r, t));
  },
  indexFromPos: function(e) {
    e = Ye(this, e);
    let t = e.ch;
    if (e.line < this.first || e.ch < 0)
      return 0;
    let r = this.lineSeparator().length;
    return this.iter(this.first, e.line, (n) => {
      t += n.text.length + r;
    }), t;
  },
  copy: function(e) {
    let t = new Qi(E0(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
    return t.scrollTop = this.scrollTop, t.scrollLeft = this.scrollLeft, t.sel = this.sel, t.extend = !1, e && (t.history.undoDepth = this.history.undoDepth, t.setHistory(this.getHistory())), t;
  },
  linkedDoc: function(e) {
    e || (e = {});
    let t = this.first, r = this.first + this.size;
    e.from != null && e.from > t && (t = e.from), e.to != null && e.to < r && (r = e.to);
    let n = new Qi(E0(this, t, r), e.mode || this.modeOption, t, this.lineSep, this.direction);
    return e.sharedHist && (n.history = this.history), (this.linked || (this.linked = [])).push({ doc: n, sharedHist: e.sharedHist }), n.linked = [{ doc: this, isParent: !0, sharedHist: e.sharedHist }], Hde(n, pI(this)), n;
  },
  unlinkDoc: function(e) {
    if (e instanceof mhe && (e = e.doc), this.linked) {
      for (let t = 0; t < this.linked.length; ++t)
        if (this.linked[t].doc == e) {
          this.linked.splice(t, 1), e.unlinkDoc(this), Vde(pI(this));
          break;
        }
    }
    if (e.history == this.history) {
      let t = [e.id];
      ts(e, (r) => t.push(r.id), !0), e.history = new Xd(null), e.history.done = cl(this.history.done, t), e.history.undone = cl(this.history.undone, t);
    }
  },
  iterLinkedDocs: function(e) {
    ts(this, e);
  },
  getMode: function() {
    return this.mode;
  },
  getEditor: function() {
    return this.cm;
  },
  splitLines: function(e) {
    return this.lineSep ? e.split(this.lineSep) : sR(e);
  },
  lineSeparator: function() {
    return this.lineSep || `
`;
  },
  setDirection: Jt(function(e) {
    e != "rtl" && (e = "ltr"), e != this.direction && (this.direction = e, this.iter((t) => t.order = null), this.cm && Ode(this.cm));
  })
});
Qi.prototype.eachLine = Qi.prototype.iter;
var va = Qi, bB = 0;
function Gde(e) {
  let t = this;
  if (yB(t), Qt(t, e) || mo(t.display, e))
    return;
  Br(e), dt && (bB = +/* @__PURE__ */ new Date());
  let r = Ca(t, e, !0), n = e.dataTransfer.files;
  if (!(!r || t.isReadOnly()))
    if (n && n.length && window.FileReader && window.File) {
      let o = n.length, s = Array(o), a = 0;
      const l = () => {
        ++a == o && tr(t, () => {
          r = Ye(t.doc, r);
          let f = {
            from: r,
            to: r,
            text: t.doc.splitLines(s.filter((c) => c != null).join(t.doc.lineSeparator())),
            origin: "paste"
          };
          iu(t.doc, f), lB(t.doc, ds(Ye(t.doc, r), Ye(t.doc, hs(f))));
        })();
      }, u = (f, c) => {
        if (t.options.allowDropFileTypes && _r(t.options.allowDropFileTypes, f.type) == -1) {
          l();
          return;
        }
        let d = new FileReader();
        d.onerror = () => l(), d.onload = () => {
          let h = d.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(h)) {
            l();
            return;
          }
          s[c] = h, l();
        }, d.readAsText(f);
      };
      for (let f = 0; f < n.length; f++)
        u(n[f], f);
    } else {
      if (t.state.draggingText && t.doc.sel.contains(r) > -1) {
        t.state.draggingText(e), setTimeout(() => t.display.input.focus(), 20);
        return;
      }
      try {
        let o = e.dataTransfer.getData("Text");
        if (o) {
          let s;
          if (t.state.draggingText && !t.state.draggingText.copy && (s = t.listSelections()), Pg(t.doc, ds(r, r)), s)
            for (let a = 0; a < s.length; ++a)
              Au(t.doc, "", s[a].anchor, s[a].head, "drag");
          t.replaceSelection(o, "around", "paste"), t.display.input.focus();
        }
      } catch {
      }
    }
}
function Kde(e, t) {
  if (dt && (!e.state.draggingText || +/* @__PURE__ */ new Date() - bB < 100)) {
    Zf(t);
    return;
  }
  if (!(Qt(e, t) || mo(e.display, t)) && (t.dataTransfer.setData("Text", e.getSelection()), t.dataTransfer.effectAllowed = "copyMove", t.dataTransfer.setDragImage && !Sg)) {
    let r = He("img", null, null, "position: fixed; left: 0; top: 0;");
    r.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", Jn && (r.width = r.height = 1, e.display.wrapper.appendChild(r), r._top = r.offsetTop), t.dataTransfer.setDragImage(r, 0, 0), Jn && r.parentNode.removeChild(r);
  }
}
function Yde(e, t) {
  let r = Ca(e, t);
  if (!r)
    return;
  let n = document.createDocumentFragment();
  Vj(e, r, n), e.display.dragCursor || (e.display.dragCursor = He("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), e.display.lineSpace.insertBefore(e.display.dragCursor, e.display.cursorDiv)), hn(e.display.dragCursor, n);
}
function yB(e) {
  e.display.dragCursor && (e.display.lineSpace.removeChild(e.display.dragCursor), e.display.dragCursor = null);
}
function gI(e) {
  if (!document.getElementsByClassName)
    return;
  let t = document.getElementsByClassName("CodeMirror"), r = [];
  for (let n = 0; n < t.length; n++) {
    let o = t[n].CodeMirror;
    o && r.push(o);
  }
  r.length && r[0].operation(() => {
    for (let n = 0; n < r.length; n++)
      e(r[n]);
  });
}
var bI = !1;
function Xde() {
  bI || (Jde(), bI = !0);
}
function Jde() {
  let e;
  Ve(window, "resize", () => {
    e == null && (e = setTimeout(() => {
      e = null, gI(Qde);
    }, 100));
  }), Ve(window, "blur", () => gI(xu));
}
function Qde(e) {
  let t = e.display;
  t.cachedCharWidth = t.cachedTextHeight = t.cachedPaddingH = null, t.scrollbarsClipped = !1, e.setSize();
}
var ps = {
  3: "Pause",
  8: "Backspace",
  9: "Tab",
  13: "Enter",
  16: "Shift",
  17: "Ctrl",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Esc",
  32: "Space",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "Left",
  38: "Up",
  39: "Right",
  40: "Down",
  44: "PrintScrn",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Mod",
  92: "Mod",
  93: "Mod",
  106: "*",
  107: "=",
  109: "-",
  110: ".",
  111: "/",
  145: "ScrollLock",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  224: "Mod",
  63232: "Up",
  63233: "Down",
  63234: "Left",
  63235: "Right",
  63272: "Delete",
  63273: "Home",
  63275: "End",
  63276: "PageUp",
  63277: "PageDown",
  63302: "Insert"
};
for (let e = 0; e < 10; e++)
  ps[e + 48] = ps[e + 96] = String(e);
for (let e = 65; e <= 90; e++)
  ps[e] = String.fromCharCode(e);
for (let e = 1; e <= 12; e++)
  ps[e + 111] = ps[e + 63235] = "F" + e;
var no = {};
no.basic = {
  Left: "goCharLeft",
  Right: "goCharRight",
  Up: "goLineUp",
  Down: "goLineDown",
  End: "goLineEnd",
  Home: "goLineStartSmart",
  PageUp: "goPageUp",
  PageDown: "goPageDown",
  Delete: "delCharAfter",
  Backspace: "delCharBefore",
  "Shift-Backspace": "delCharBefore",
  Tab: "defaultTab",
  "Shift-Tab": "indentAuto",
  Enter: "newlineAndIndent",
  Insert: "toggleOverwrite",
  Esc: "singleSelection"
};
no.pcDefault = {
  "Ctrl-A": "selectAll",
  "Ctrl-D": "deleteLine",
  "Ctrl-Z": "undo",
  "Shift-Ctrl-Z": "redo",
  "Ctrl-Y": "redo",
  "Ctrl-Home": "goDocStart",
  "Ctrl-End": "goDocEnd",
  "Ctrl-Up": "goLineUp",
  "Ctrl-Down": "goLineDown",
  "Ctrl-Left": "goGroupLeft",
  "Ctrl-Right": "goGroupRight",
  "Alt-Left": "goLineStart",
  "Alt-Right": "goLineEnd",
  "Ctrl-Backspace": "delGroupBefore",
  "Ctrl-Delete": "delGroupAfter",
  "Ctrl-S": "save",
  "Ctrl-F": "find",
  "Ctrl-G": "findNext",
  "Shift-Ctrl-G": "findPrev",
  "Shift-Ctrl-F": "replace",
  "Shift-Ctrl-R": "replaceAll",
  "Ctrl-[": "indentLess",
  "Ctrl-]": "indentMore",
  "Ctrl-U": "undoSelection",
  "Shift-Ctrl-U": "redoSelection",
  "Alt-U": "redoSelection",
  fallthrough: "basic"
};
no.emacsy = {
  "Ctrl-F": "goCharRight",
  "Ctrl-B": "goCharLeft",
  "Ctrl-P": "goLineUp",
  "Ctrl-N": "goLineDown",
  "Ctrl-A": "goLineStart",
  "Ctrl-E": "goLineEnd",
  "Ctrl-V": "goPageDown",
  "Shift-Ctrl-V": "goPageUp",
  "Ctrl-D": "delCharAfter",
  "Ctrl-H": "delCharBefore",
  "Alt-Backspace": "delWordBefore",
  "Ctrl-K": "killLine",
  "Ctrl-T": "transposeChars",
  "Ctrl-O": "openLine"
};
no.macDefault = {
  "Cmd-A": "selectAll",
  "Cmd-D": "deleteLine",
  "Cmd-Z": "undo",
  "Shift-Cmd-Z": "redo",
  "Cmd-Y": "redo",
  "Cmd-Home": "goDocStart",
  "Cmd-Up": "goDocStart",
  "Cmd-End": "goDocEnd",
  "Cmd-Down": "goDocEnd",
  "Alt-Left": "goGroupLeft",
  "Alt-Right": "goGroupRight",
  "Cmd-Left": "goLineLeft",
  "Cmd-Right": "goLineRight",
  "Alt-Backspace": "delGroupBefore",
  "Ctrl-Alt-Backspace": "delGroupAfter",
  "Alt-Delete": "delGroupAfter",
  "Cmd-S": "save",
  "Cmd-F": "find",
  "Cmd-G": "findNext",
  "Shift-Cmd-G": "findPrev",
  "Cmd-Alt-F": "replace",
  "Shift-Cmd-Alt-F": "replaceAll",
  "Cmd-[": "indentLess",
  "Cmd-]": "indentMore",
  "Cmd-Backspace": "delWrappedLineLeft",
  "Cmd-Delete": "delWrappedLineRight",
  "Cmd-U": "undoSelection",
  "Shift-Cmd-U": "redoSelection",
  "Ctrl-Up": "goDocStart",
  "Ctrl-Down": "goDocEnd",
  fallthrough: ["basic", "emacsy"]
};
no.default = Rn ? no.macDefault : no.pcDefault;
function Zde(e) {
  let t = e.split(/-(?!$)/);
  e = t[t.length - 1];
  let r, n, o, s;
  for (let a = 0; a < t.length - 1; a++) {
    let l = t[a];
    if (/^(cmd|meta|m)$/i.test(l))
      s = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      n = !0;
    else if (/^s(hift)?$/i.test(l))
      o = !0;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return r && (e = "Alt-" + e), n && (e = "Ctrl-" + e), s && (e = "Cmd-" + e), o && (e = "Shift-" + e), e;
}
function ehe(e) {
  let t = {};
  for (let r in e)
    if (e.hasOwnProperty(r)) {
      let n = e[r];
      if (/^(name|fallthrough|(de|at)tach)$/.test(r))
        continue;
      if (n == "...") {
        delete e[r];
        continue;
      }
      let o = Rg(r.split(" "), Zde);
      for (let s = 0; s < o.length; s++) {
        let a, l;
        s == o.length - 1 ? (l = o.join(" "), a = n) : (l = o.slice(0, s + 1).join(" "), a = "...");
        let u = t[l];
        if (!u)
          t[l] = a;
        else if (u != a)
          throw new Error("Inconsistent bindings for " + l);
      }
      delete e[r];
    }
  for (let r in t)
    e[r] = t[r];
  return e;
}
function Bl(e, t, r, n) {
  t = qh(t);
  let o = t.call ? t.call(e, n) : t[e];
  if (o === !1)
    return "nothing";
  if (o === "...")
    return "multi";
  if (o != null && r(o))
    return "handled";
  if (t.fallthrough) {
    if (Object.prototype.toString.call(t.fallthrough) != "[object Array]")
      return Bl(e, t.fallthrough, r, n);
    for (let s = 0; s < t.fallthrough.length; s++) {
      let a = Bl(e, t.fallthrough[s], r, n);
      if (a)
        return a;
    }
  }
}
function vB(e) {
  let t = typeof e == "string" ? e : ps[e.keyCode];
  return t == "Ctrl" || t == "Alt" || t == "Shift" || t == "Mod";
}
function mB(e, t, r) {
  let n = e;
  return t.altKey && n != "Alt" && (e = "Alt-" + e), (DC ? t.metaKey : t.ctrlKey) && n != "Ctrl" && (e = "Ctrl-" + e), (DC ? t.ctrlKey : t.metaKey) && n != "Mod" && (e = "Cmd-" + e), !r && t.shiftKey && n != "Shift" && (e = "Shift-" + e), e;
}
function _B(e, t) {
  if (Jn && e.keyCode == 34 && e.char)
    return !1;
  let r = ps[e.keyCode];
  return r == null || e.altGraphKey ? !1 : (e.keyCode == 3 && e.code && (r = e.code), mB(r, e, t));
}
function qh(e) {
  return typeof e == "string" ? no[e] : e;
}
function wl(e, t) {
  let r = e.doc.sel.ranges, n = [];
  for (let o = 0; o < r.length; o++) {
    let s = t(r[o]);
    for (; n.length && Xe(s.from, vt(n).to) <= 0; ) {
      let a = n.pop();
      if (Xe(a.from, s.from) < 0) {
        s.from = a.from;
        break;
      }
    }
    n.push(s);
  }
  en(e, () => {
    for (let o = n.length - 1; o >= 0; o--)
      Au(e.doc, "", n[o].from, n[o].to, "+delete");
    Ru(e);
  });
}
function BR(e, t, r) {
  let n = fj(e.text, t + r, r);
  return n < 0 || n > e.text.length ? null : n;
}
function nE(e, t, r) {
  let n = BR(e, t.ch, r);
  return n == null ? null : new Ee(t.line, n, r < 0 ? "after" : "before");
}
function qR(e, t, r, n, o) {
  if (e) {
    t.doc.direction == "rtl" && (o = -o);
    let s = $o(r, t.doc.direction);
    if (s) {
      let a = o < 0 ? vt(s) : s[0], u = o < 0 == (a.level == 1) ? "after" : "before", f;
      if (a.level > 0 || t.doc.direction == "rtl") {
        let c = Su(t, r);
        f = o < 0 ? r.text.length - 1 : 0;
        let d = Li(t, c, f).top;
        f = Jf((h) => Li(t, c, h).top == d, o < 0 == (a.level == 1) ? a.from : a.to - 1, f), u == "before" && (f = BR(r, f, 1));
      } else
        f = o < 0 ? a.to : a.from;
      return new Ee(n, f, u);
    }
  }
  return new Ee(n, o < 0 ? r.text.length : 0, o < 0 ? "before" : "after");
}
function the(e, t, r, n) {
  let o = $o(t, e.doc.direction);
  if (!o)
    return nE(t, r, n);
  r.ch >= t.text.length ? (r.ch = t.text.length, r.sticky = "before") : r.ch <= 0 && (r.ch = 0, r.sticky = "after");
  let s = Qf(o, r.ch, r.sticky), a = o[s];
  if (e.doc.direction == "ltr" && a.level % 2 == 0 && (n > 0 ? a.to > r.ch : a.from < r.ch))
    return nE(t, r, n);
  let l = (v, y) => BR(t, v instanceof Ee ? v.ch : v, y), u, f = (v) => e.options.lineWrapping ? (u = u || Su(e, t), Wj(e, t, u, v)) : { begin: 0, end: t.text.length }, c = f(r.sticky == "before" ? l(r, -1) : r.ch);
  if (e.doc.direction == "rtl" || a.level == 1) {
    let v = a.level == 1 == n < 0, y = l(r, v ? 1 : -1);
    if (y != null && (v ? y <= a.to && y <= c.end : y >= a.from && y >= c.begin)) {
      let w = v ? "before" : "after";
      return new Ee(r.line, y, w);
    }
  }
  let d = (v, y, w) => {
    let S = (x, E) => E ? new Ee(r.line, l(x, 1), "before") : new Ee(r.line, x, "after");
    for (; v >= 0 && v < o.length; v += y) {
      let x = o[v], E = y > 0 == (x.level != 1), N = E ? w.begin : l(w.end, -1);
      if (x.from <= N && N < x.to || (N = E ? x.from : l(x.to, -1), w.begin <= N && N < w.end))
        return S(N, E);
    }
  }, h = d(s + n, n, c);
  if (h)
    return h;
  let p = n > 0 ? c.end : l(c.begin, -1);
  return p != null && !(n > 0 && p == t.text.length) && (h = d(n > 0 ? 0 : o.length - 1, n, f(p)), h) ? h : null;
}
var lc = {
  selectAll: dB,
  singleSelection: (e) => e.setSelection(e.getCursor("anchor"), e.getCursor("head"), Ci),
  killLine: (e) => wl(e, (t) => {
    if (t.empty()) {
      let r = Be(e.doc, t.head.line).text.length;
      return t.head.ch == r && t.head.line < e.lastLine() ? { from: t.head, to: Ee(t.head.line + 1, 0) } : { from: t.head, to: Ee(t.head.line, r) };
    } else
      return { from: t.from(), to: t.to() };
  }),
  deleteLine: (e) => wl(e, (t) => ({
    from: Ee(t.from().line, 0),
    to: Ye(e.doc, Ee(t.to().line + 1, 0))
  })),
  delLineLeft: (e) => wl(e, (t) => ({
    from: Ee(t.from().line, 0),
    to: t.from()
  })),
  delWrappedLineLeft: (e) => wl(e, (t) => {
    let r = e.charCoords(t.head, "div").top + 5;
    return { from: e.coordsChar({ left: 0, top: r }, "div"), to: t.from() };
  }),
  delWrappedLineRight: (e) => wl(e, (t) => {
    let r = e.charCoords(t.head, "div").top + 5, n = e.coordsChar({ left: e.display.lineDiv.offsetWidth + 100, top: r }, "div");
    return { from: t.from(), to: n };
  }),
  undo: (e) => e.undo(),
  redo: (e) => e.redo(),
  undoSelection: (e) => e.undoSelection(),
  redoSelection: (e) => e.redoSelection(),
  goDocStart: (e) => e.extendSelection(Ee(e.firstLine(), 0)),
  goDocEnd: (e) => e.extendSelection(Ee(e.lastLine())),
  goLineStart: (e) => e.extendSelectionsBy((t) => wB(e, t.head.line), { origin: "+move", bias: 1 }),
  goLineStartSmart: (e) => e.extendSelectionsBy((t) => yI(e, t.head), { origin: "+move", bias: 1 }),
  goLineEnd: (e) => e.extendSelectionsBy((t) => rhe(e, t.head.line), { origin: "+move", bias: -1 }),
  goLineRight: (e) => e.extendSelectionsBy((t) => {
    let r = e.cursorCoords(t.head, "div").top + 5;
    return e.coordsChar({ left: e.display.lineDiv.offsetWidth + 100, top: r }, "div");
  }, Tf),
  goLineLeft: (e) => e.extendSelectionsBy((t) => {
    let r = e.cursorCoords(t.head, "div").top + 5;
    return e.coordsChar({ left: 0, top: r }, "div");
  }, Tf),
  goLineLeftSmart: (e) => e.extendSelectionsBy((t) => {
    let r = e.cursorCoords(t.head, "div").top + 5, n = e.coordsChar({ left: 0, top: r }, "div");
    return n.ch < e.getLine(n.line).search(/\S/) ? yI(e, t.head) : n;
  }, Tf),
  goLineUp: (e) => e.moveV(-1, "line"),
  goLineDown: (e) => e.moveV(1, "line"),
  goPageUp: (e) => e.moveV(-1, "page"),
  goPageDown: (e) => e.moveV(1, "page"),
  goCharLeft: (e) => e.moveH(-1, "char"),
  goCharRight: (e) => e.moveH(1, "char"),
  goColumnLeft: (e) => e.moveH(-1, "column"),
  goColumnRight: (e) => e.moveH(1, "column"),
  goWordLeft: (e) => e.moveH(-1, "word"),
  goGroupRight: (e) => e.moveH(1, "group"),
  goGroupLeft: (e) => e.moveH(-1, "group"),
  goWordRight: (e) => e.moveH(1, "word"),
  delCharBefore: (e) => e.deleteH(-1, "codepoint"),
  delCharAfter: (e) => e.deleteH(1, "char"),
  delWordBefore: (e) => e.deleteH(-1, "word"),
  delWordAfter: (e) => e.deleteH(1, "word"),
  delGroupBefore: (e) => e.deleteH(-1, "group"),
  delGroupAfter: (e) => e.deleteH(1, "group"),
  indentAuto: (e) => e.indentSelection("smart"),
  indentMore: (e) => e.indentSelection("add"),
  indentLess: (e) => e.indentSelection("subtract"),
  insertTab: (e) => e.replaceSelection("	"),
  insertSoftTab: (e) => {
    let t = [], r = e.listSelections(), n = e.options.tabSize;
    for (let o = 0; o < r.length; o++) {
      let s = r[o].from(), a = wn(e.getLine(s.line), s.ch, n);
      t.push(nR(n - a % n));
    }
    e.replaceSelections(t);
  },
  defaultTab: (e) => {
    e.somethingSelected() ? e.indentSelection("add") : e.execCommand("insertTab");
  },
  transposeChars: (e) => en(e, () => {
    let t = e.listSelections(), r = [];
    for (let n = 0; n < t.length; n++) {
      if (!t[n].empty())
        continue;
      let o = t[n].head, s = Be(e.doc, o.line).text;
      if (s) {
        if (o.ch == s.length && (o = new Ee(o.line, o.ch - 1)), o.ch > 0)
          o = new Ee(o.line, o.ch + 1), e.replaceRange(s.charAt(o.ch - 1) + s.charAt(o.ch - 2), Ee(o.line, o.ch - 2), o, "+transpose");
        else if (o.line > e.doc.first) {
          let a = Be(e.doc, o.line - 1).text;
          a && (o = new Ee(o.line, 1), e.replaceRange(s.charAt(0) + e.doc.lineSeparator() + a.charAt(a.length - 1), Ee(o.line - 1, a.length - 1), o, "+transpose"));
        }
      }
      r.push(new wt(o, o));
    }
    e.setSelections(r);
  }),
  newlineAndIndent: (e) => en(e, () => {
    let t = e.listSelections();
    for (let r = t.length - 1; r >= 0; r--)
      e.replaceRange(e.doc.lineSeparator(), t[r].anchor, t[r].head, "+input");
    t = e.listSelections();
    for (let r = 0; r < t.length; r++)
      e.indentLine(t[r].from().line, null, !0);
    Ru(e);
  }),
  openLine: (e) => e.replaceSelection(`
`, "start"),
  toggleOverwrite: (e) => e.toggleOverwrite()
};
function wB(e, t) {
  let r = Be(e.doc, t), n = Mi(r);
  return n != r && (t = mt(n)), qR(!0, e, n, t, 1);
}
function rhe(e, t) {
  let r = Be(e.doc, t), n = Dce(r);
  return n != r && (t = mt(n)), qR(!0, e, r, t, -1);
}
function yI(e, t) {
  let r = wB(e, t.line), n = Be(e.doc, r.line), o = $o(n, e.doc.direction);
  if (!o || o[0].level == 0) {
    let s = Math.max(r.ch, n.text.search(/\S/)), a = t.line == r.line && t.ch <= s && t.ch;
    return Ee(r.line, a ? 0 : s, r.sticky);
  }
  return r;
}
function Jd(e, t, r) {
  if (typeof t == "string" && (t = lc[t], !t))
    return !1;
  e.display.input.ensurePolled();
  let n = e.display.shift, o = !1;
  try {
    e.isReadOnly() && (e.state.suppressEdits = !0), r && (e.display.shift = !1), o = t(e) != xg;
  } finally {
    e.display.shift = n, e.state.suppressEdits = !1;
  }
  return o;
}
function nhe(e, t, r) {
  for (let n = 0; n < e.state.keyMaps.length; n++) {
    let o = Bl(t, e.state.keyMaps[n], r, e);
    if (o)
      return o;
  }
  return e.options.extraKeys && Bl(t, e.options.extraKeys, r, e) || Bl(t, e.options.keyMap, r, e);
}
var ihe = new tu();
function Of(e, t, r, n) {
  let o = e.state.keySeq;
  if (o) {
    if (vB(t))
      return "handled";
    if (/\'$/.test(t) ? e.state.keySeq = null : ihe.set(50, () => {
      e.state.keySeq == o && (e.state.keySeq = null, e.display.input.reset());
    }), vI(e, o + " " + t, r, n))
      return !0;
  }
  return vI(e, t, r, n);
}
function vI(e, t, r, n) {
  let o = nhe(e, t, n);
  return o == "multi" && (e.state.keySeq = t), o == "handled" && ir(e, "keyHandled", e, t, r), (o == "handled" || o == "multi") && (Br(r), RR(e)), !!o;
}
function SB(e, t) {
  let r = _B(t, !0);
  return r ? t.shiftKey && !e.state.keySeq ? Of(e, "Shift-" + r, t, (n) => Jd(e, n, !0)) || Of(e, r, t, (n) => {
    if (typeof n == "string" ? /^go[A-Z]/.test(n) : n.motion)
      return Jd(e, n);
  }) : Of(e, r, t, (n) => Jd(e, n)) : !1;
}
function ohe(e, t, r) {
  return Of(e, "'" + r + "'", t, (n) => Jd(e, n, !0));
}
var iE = null;
function EB(e) {
  let t = this;
  if (e.target && e.target != t.display.input.getField() || (t.curOp.focus = En(), Qt(t, e)))
    return;
  dt && kt < 11 && e.keyCode == 27 && (e.returnValue = !1);
  let r = e.keyCode;
  t.display.shift = r == 16 || e.shiftKey;
  let n = SB(t, e);
  Jn && (iE = n ? r : null, !n && r == 88 && !_ce && (Rn ? e.metaKey : e.ctrlKey) && t.replaceSelection("", null, "cut")), bo && !Rn && !n && r == 46 && e.shiftKey && !e.ctrlKey && document.execCommand && document.execCommand("cut"), r == 18 && !/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className) && she(t);
}
function she(e) {
  let t = e.display.lineDiv;
  el(t, "CodeMirror-crosshair");
  function r(n) {
    (n.keyCode == 18 || !n.altKey) && (Za(t, "CodeMirror-crosshair"), cn(document, "keyup", r), cn(document, "mouseover", r));
  }
  Ve(document, "keyup", r), Ve(document, "mouseover", r);
}
function xB(e) {
  e.keyCode == 16 && (this.doc.sel.shift = !1), Qt(this, e);
}
function RB(e) {
  let t = this;
  if (e.target && e.target != t.display.input.getField() || mo(t.display, e) || Qt(t, e) || e.ctrlKey && !e.altKey || Rn && e.metaKey)
    return;
  let r = e.keyCode, n = e.charCode;
  if (Jn && r == iE) {
    iE = null, Br(e);
    return;
  }
  if (Jn && (!e.which || e.which < 10) && SB(t, e))
    return;
  let o = String.fromCharCode(n ?? r);
  o != "\b" && (ohe(t, e, o) || t.display.input.onKeyPress(e));
}
var ahe = 400, mI = class {
  constructor(e, t, r) {
    this.time = e, this.pos = t, this.button = r;
  }
  compare(e, t, r) {
    return this.time + ahe > e && Xe(t, this.pos) == 0 && r == this.button;
  }
}, Fu, ju;
function lhe(e, t) {
  let r = +/* @__PURE__ */ new Date();
  return ju && ju.compare(r, e, t) ? (Fu = ju = null, "triple") : Fu && Fu.compare(r, e, t) ? (ju = new mI(r, e, t), Fu = null, "double") : (Fu = new mI(r, e, t), ju = null, "single");
}
function AB(e) {
  let t = this, r = t.display;
  if (Qt(t, e) || r.activeTouch && r.input.supportsTouch())
    return;
  if (r.input.ensurePolled(), r.shift = e.shiftKey, mo(r, e)) {
    Nr || (r.scroller.draggable = !1, setTimeout(() => r.scroller.draggable = !0, 100));
    return;
  }
  if (oE(t, e))
    return;
  let n = Ca(t, e), o = pj(e), s = n ? lhe(n, o) : "single";
  window.focus(), o == 1 && t.state.selectingText && t.state.selectingText(e), !(n && uhe(t, o, n, s, e)) && (o == 1 ? n ? che(t, n, s, e) : oR(e) == r.scroller && Br(e) : o == 2 ? (n && Lg(t.doc, n), setTimeout(() => r.input.focus(), 20)) : o == 3 && (tR ? t.display.input.onContextMenu(e) : AR(t)));
}
function uhe(e, t, r, n, o) {
  let s = "Click";
  return n == "double" ? s = "Double" + s : n == "triple" && (s = "Triple" + s), s = (t == 1 ? "Left" : t == 2 ? "Middle" : "Right") + s, Of(e, mB(s, o), o, (a) => {
    if (typeof a == "string" && (a = lc[a]), !a)
      return !1;
    let l = !1;
    try {
      e.isReadOnly() && (e.state.suppressEdits = !0), l = a(e, r) != xg;
    } finally {
      e.state.suppressEdits = !1;
    }
    return l;
  });
}
function fhe(e, t, r) {
  let n = e.getOption("configureMouse"), o = n ? n(e, t, r) : {};
  if (o.unit == null) {
    let s = uce ? r.shiftKey && r.metaKey : r.altKey;
    o.unit = s ? "rectangle" : t == "single" ? "char" : t == "double" ? "word" : "line";
  }
  return (o.extend == null || e.doc.extend) && (o.extend = e.doc.extend || r.shiftKey), o.addNew == null && (o.addNew = Rn ? r.metaKey : r.ctrlKey), o.moveOnDrag == null && (o.moveOnDrag = !(Rn ? r.altKey : r.ctrlKey)), o;
}
function che(e, t, r, n) {
  dt ? setTimeout(rR(zj, e), 0) : e.curOp.focus = En();
  let o = fhe(e, r, n), s = e.doc.sel, a;
  e.options.dragDrop && bce && !e.isReadOnly() && r == "single" && (a = s.contains(t)) > -1 && (Xe((a = s.ranges[a]).from(), t) < 0 || t.xRel > 0) && (Xe(a.to(), t) > 0 || t.xRel < 0) ? dhe(e, n, t, o) : hhe(e, n, t, o);
}
function dhe(e, t, r, n) {
  let o = e.display, s = !1, a = tr(e, (f) => {
    Nr && (o.scroller.draggable = !1), e.state.draggingText = !1, e.state.delayingBlurEvent && (e.hasFocus() ? e.state.delayingBlurEvent = !1 : AR(e)), cn(o.wrapper.ownerDocument, "mouseup", a), cn(o.wrapper.ownerDocument, "mousemove", l), cn(o.scroller, "dragstart", u), cn(o.scroller, "drop", a), s || (Br(f), n.addNew || Lg(e.doc, r, null, null, n.extend), Nr && !Sg || dt && kt == 9 ? setTimeout(() => {
      o.wrapper.ownerDocument.body.focus({ preventScroll: !0 }), o.input.focus();
    }, 20) : o.input.focus());
  }), l = function(f) {
    s = s || Math.abs(t.clientX - f.clientX) + Math.abs(t.clientY - f.clientY) >= 10;
  }, u = () => s = !0;
  Nr && (o.scroller.draggable = !0), e.state.draggingText = a, a.copy = !n.moveOnDrag, Ve(o.wrapper.ownerDocument, "mouseup", a), Ve(o.wrapper.ownerDocument, "mousemove", l), Ve(o.scroller, "dragstart", u), Ve(o.scroller, "drop", a), e.state.delayingBlurEvent = !0, setTimeout(() => o.input.focus(), 20), o.scroller.dragDrop && o.scroller.dragDrop();
}
function _I(e, t, r) {
  if (r == "char")
    return new wt(t, t);
  if (r == "word")
    return e.findWordAt(t);
  if (r == "line")
    return new wt(Ee(t.line, 0), Ye(e.doc, Ee(t.line + 1, 0)));
  let n = r(e, t);
  return new wt(n.from, n.to);
}
function hhe(e, t, r, n) {
  dt && AR(e);
  let o = e.display, s = e.doc;
  Br(t);
  let a, l, u = s.sel, f = u.ranges;
  if (n.addNew && !n.extend ? (l = s.sel.contains(r), l > -1 ? a = f[l] : a = new wt(r, r)) : (a = s.sel.primary(), l = s.sel.primIndex), n.unit == "rectangle")
    n.addNew || (a = new wt(r, r)), r = Ca(e, t, !0, !0), l = -1;
  else {
    let x = _I(e, r, n.unit);
    n.extend ? a = LR(a, x.anchor, x.head, n.extend) : a = x;
  }
  n.addNew ? l == -1 ? (l = f.length, pr(s, Gn(e, f.concat([a]), l), { scroll: !1, origin: "*mouse" })) : f.length > 1 && f[l].empty() && n.unit == "char" && !n.extend ? (pr(s, Gn(e, f.slice(0, l).concat(f.slice(l + 1)), 0), { scroll: !1, origin: "*mouse" }), u = s.sel) : PR(s, l, a, m0) : (l = 0, pr(s, new xs([a], 0), m0), u = s.sel);
  let c = r;
  function d(x) {
    if (Xe(c, x) != 0)
      if (c = x, n.unit == "rectangle") {
        let E = [], N = e.options.tabSize, C = wn(Be(s, r.line).text, r.ch, N), j = wn(Be(s, x.line).text, x.ch, N), J = Math.min(C, j), z = Math.max(C, j);
        for (let $ = Math.min(r.line, x.line), G = Math.min(e.lastLine(), Math.max(r.line, x.line)); $ <= G; $++) {
          let I = Be(s, $).text, W = WS(I, J, N);
          J == z ? E.push(new wt(Ee($, W), Ee($, W))) : I.length > W && E.push(new wt(Ee($, W), Ee($, WS(I, z, N))));
        }
        E.length || E.push(new wt(r, r)), pr(s, Gn(e, u.ranges.slice(0, l).concat(E), l), { origin: "*mouse", scroll: !1 }), e.scrollIntoView(x);
      } else {
        let E = a, N = _I(e, x, n.unit), C = E.anchor, j;
        Xe(N.anchor, C) > 0 ? (j = N.head, C = $g(E.from(), N.anchor)) : (j = N.anchor, C = Tg(E.to(), N.head));
        let J = u.ranges.slice(0);
        J[l] = phe(e, new wt(Ye(s, C), j)), pr(s, Gn(e, J, l), m0);
      }
  }
  let h = o.wrapper.getBoundingClientRect(), p = 0;
  function v(x) {
    let E = ++p, N = Ca(e, x, !0, n.unit == "rectangle");
    if (N)
      if (Xe(N, c) != 0) {
        e.curOp.focus = En(), d(N);
        let C = Fh(o, s);
        (N.line >= C.to || N.line < C.from) && setTimeout(tr(e, () => {
          p == E && v(x);
        }), 150);
      } else {
        let C = x.clientY < h.top ? -20 : x.clientY > h.bottom ? 20 : 0;
        C && setTimeout(tr(e, () => {
          p == E && (o.scroller.scrollTop += C, v(x));
        }), 50);
      }
  }
  function y(x) {
    e.state.selectingText = !1, p = 1 / 0, x && (Br(x), o.input.focus()), cn(o.wrapper.ownerDocument, "mousemove", w), cn(o.wrapper.ownerDocument, "mouseup", S), s.history.lastSelOrigin = null;
  }
  let w = tr(e, (x) => {
    x.buttons === 0 || !pj(x) ? y(x) : v(x);
  }), S = tr(e, y);
  e.state.selectingText = S, Ve(o.wrapper.ownerDocument, "mousemove", w), Ve(o.wrapper.ownerDocument, "mouseup", S);
}
function phe(e, t) {
  let { anchor: r, head: n } = t, o = Be(e.doc, r.line);
  if (Xe(r, n) == 0 && r.sticky == n.sticky)
    return t;
  let s = $o(o);
  if (!s)
    return t;
  let a = Qf(s, r.ch, r.sticky), l = s[a];
  if (l.from != r.ch && l.to != r.ch)
    return t;
  let u = a + (l.from == r.ch == (l.level != 1) ? 0 : 1);
  if (u == 0 || u == s.length)
    return t;
  let f;
  if (n.line != r.line)
    f = (n.line - r.line) * (e.doc.direction == "ltr" ? 1 : -1) > 0;
  else {
    let v = Qf(s, n.ch, n.sticky), y = v - a || (n.ch - r.ch) * (l.level == 1 ? -1 : 1);
    v == u - 1 || v == u ? f = y < 0 : f = y > 0;
  }
  let c = s[u + (f ? -1 : 0)], d = f == (c.level == 1), h = d ? c.from : c.to, p = d ? "after" : "before";
  return r.ch == h && r.sticky == p ? t : new wt(new Ee(r.line, h, p), n);
}
function TB(e, t, r, n) {
  let o, s;
  if (t.touches)
    o = t.touches[0].clientX, s = t.touches[0].clientY;
  else
    try {
      o = t.clientX, s = t.clientY;
    } catch {
      return !1;
    }
  if (o >= Math.floor(e.display.gutters.getBoundingClientRect().right))
    return !1;
  n && Br(t);
  let a = e.display, l = a.lineDiv.getBoundingClientRect();
  if (s > l.bottom || !An(e, r))
    return VS(t);
  s -= l.top - a.viewOffset;
  for (let u = 0; u < e.display.gutterSpecs.length; ++u) {
    let f = a.gutters.childNodes[u];
    if (f && f.getBoundingClientRect().right >= o) {
      let c = Zs(e.doc, s), d = e.display.gutterSpecs[u];
      return Ht(e, r, e, c, d.className, t), VS(t);
    }
  }
}
function oE(e, t) {
  return TB(e, t, "gutterClick", !0);
}
function wI(e, t) {
  mo(e.display, t) || ghe(e, t) || Qt(e, t, "contextmenu") || tR || e.display.input.onContextMenu(t);
}
function ghe(e, t) {
  return An(e, "gutterContextMenu") ? TB(e, t, "gutterContextMenu", !1) : !1;
}
function $B(e) {
  e.display.wrapper.className = e.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + e.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), oc(e);
}
var Tl = { toString: function() {
  return "CodeMirror.Init";
} }, NB = {}, Qd = {};
function bhe(e) {
  let t = e.optionHandlers;
  function r(n, o, s, a) {
    e.defaults[n] = o, s && (t[n] = a ? (l, u, f) => {
      f != Tl && s(l, u, f);
    } : s);
  }
  e.defineOption = r, e.Init = Tl, r("value", "", (n, o) => n.setValue(o), !0), r("mode", null, (n, o) => {
    n.doc.modeOption = o, tE(n);
  }, !0), r("indentUnit", 2, tE, !0), r("indentWithTabs", !1), r("smartIndent", !0), r("tabSize", 4, (n) => {
    rf(n), oc(n), qr(n);
  }, !0), r("lineSeparator", null, (n, o) => {
    if (n.doc.lineSep = o, !o)
      return;
    let s = [], a = n.doc.first;
    n.doc.iter((l) => {
      for (let u = 0; ; ) {
        let f = l.text.indexOf(o, u);
        if (f == -1)
          break;
        u = f + o.length, s.push(Ee(a, f));
      }
      a++;
    });
    for (let l = s.length - 1; l >= 0; l--)
      Au(n.doc, o, s[l], Ee(s[l].line, s[l].ch + o.length));
  }), r("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, (n, o, s) => {
    n.state.specialChars = new RegExp(o.source + (o.test("	") ? "" : "|	"), "g"), s != Tl && n.refresh();
  }), r("specialCharPlaceholder", Uce, (n) => n.refresh(), !0), r("electricChars", !0), r("inputStyle", Yf ? "contenteditable" : "textarea", () => {
    throw new Error("inputStyle can not (yet) be changed in a running editor");
  }, !0), r("spellcheck", !1, (n, o) => n.getInputField().spellcheck = o, !0), r("autocorrect", !1, (n, o) => n.getInputField().autocorrect = o, !0), r("autocapitalize", !1, (n, o) => n.getInputField().autocapitalize = o, !0), r("rtlMoveVisually", !fce), r("wholeLineUpdateBefore", !0), r("theme", "default", (n) => {
    $B(n), Du(n);
  }, !0), r("keyMap", "default", (n, o, s) => {
    let a = qh(o), l = s != Tl && qh(s);
    l && l.detach && l.detach(n, a), a.attach && a.attach(n, l || null);
  }), r("extraKeys", null), r("configureMouse", null), r("lineWrapping", !1, vhe, !0), r("gutters", [], (n, o) => {
    n.display.gutterSpecs = eE(o, n.options.lineNumbers), Du(n);
  }, !0), r("fixedGutter", !0, (n, o) => {
    n.display.gutters.style.left = o ? ER(n.display) + "px" : "0", n.refresh();
  }, !0), r("coverGutterNextToScrollbar", !1, (n) => nu(n), !0), r("scrollbarStyle", "native", (n) => {
    Xj(n), nu(n), n.display.scrollbars.setScrollTop(n.doc.scrollTop), n.display.scrollbars.setScrollLeft(n.doc.scrollLeft);
  }, !0), r("lineNumbers", !1, (n, o) => {
    n.display.gutterSpecs = eE(n.options.gutters, o), Du(n);
  }, !0), r("firstLineNumber", 1, Du, !0), r("lineNumberFormatter", (n) => n, Du, !0), r("showCursorWhenSelecting", !1, kf, !0), r("resetSelectionOnContextMenu", !0), r("lineWiseCopyCut", !0), r("pasteLinesPerSelection", !0), r("selectionsMayTouch", !1), r("readOnly", !1, (n, o) => {
    o == "nocursor" && (xu(n), n.display.input.blur()), n.display.input.readOnlyChanged(o);
  }), r("screenReaderLabel", null, (n, o) => {
    o = o === "" ? null : o, n.display.input.screenReaderLabelChanged(o);
  }), r("disableInput", !1, (n, o) => {
    o || n.display.input.reset();
  }, !0), r("dragDrop", !0, yhe), r("allowDropFileTypes", null), r("cursorBlinkRate", 530), r("cursorScrollMargin", 0), r("cursorHeight", 1, kf, !0), r("singleCursorHeightPerLine", !0, kf, !0), r("workTime", 100), r("workDelay", 100), r("flattenSpans", !0, rf, !0), r("addModeClass", !1, rf, !0), r("pollInterval", 100), r("undoDepth", 200, (n, o) => n.doc.history.undoDepth = o), r("historyEventDelay", 1250), r("viewportMargin", 10, (n) => n.refresh(), !0), r("maxHighlightLength", 1e4, rf, !0), r("moveInputWithCursor", !0, (n, o) => {
    o || n.display.input.resetPosition();
  }), r("tabindex", null, (n, o) => n.display.input.getField().tabIndex = o || ""), r("autofocus", null), r("direction", "ltr", (n, o) => n.doc.setDirection(o), !0), r("phrases", null);
}
function yhe(e, t, r) {
  let n = r && r != Tl;
  if (!t != !n) {
    let o = e.display.dragFunctions, s = t ? Ve : cn;
    s(e.display.scroller, "dragstart", o.start), s(e.display.scroller, "dragenter", o.enter), s(e.display.scroller, "dragover", o.over), s(e.display.scroller, "dragleave", o.leave), s(e.display.scroller, "drop", o.drop);
  }
}
function vhe(e) {
  e.options.lineWrapping ? (el(e.display.wrapper, "CodeMirror-wrap"), e.display.sizer.style.minWidth = "", e.display.sizerWidth = null) : (Za(e.display.wrapper, "CodeMirror-wrap"), gR(e)), xR(e), qr(e), oc(e), setTimeout(() => nu(e), 100);
}
function It(e, t) {
  if (!(this instanceof It))
    return new It(e, t);
  this.options = t = t ? ka(t) : {}, ka(NB, t, !1);
  let r = t.value;
  typeof r == "string" ? r = new va(r, t.mode, null, t.lineSeparator, t.direction) : t.mode && (r.modeOption = t.mode), this.doc = r;
  let n = new It.inputStyles[t.inputStyle](this), o = this.display = new Cde(e, r, n, t);
  o.wrapper.CodeMirror = this, $B(this), t.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), Xj(this), this.state = {
    keyMaps: [],
    overlays: [],
    modeGen: 0,
    overwrite: !1,
    delayingBlurEvent: !1,
    focused: !1,
    suppressEdits: !1,
    pasteIncoming: -1,
    cutIncoming: -1,
    selectingText: !1,
    draggingText: !1,
    highlight: new tu(),
    keySeq: null,
    specialChars: null
  }, t.autofocus && !Yf && o.input.focus(), dt && kt < 11 && setTimeout(() => this.display.input.reset(!0), 20), _he(this), Xde(), nl(this), this.curOp.forceUpdate = !0, iB(this, r), t.autofocus && !Yf || this.hasFocus() ? setTimeout(() => {
    this.hasFocus() && !this.state.focused && TR(this);
  }, 20) : xu(this);
  for (let s in Qd)
    Qd.hasOwnProperty(s) && Qd[s](this, t[s], Tl);
  eB(this), t.finishInit && t.finishInit(this);
  for (let s = 0; s < sE.length; ++s)
    sE[s](this);
  il(this), Nr && t.lineWrapping && getComputedStyle(o.lineDiv).textRendering == "optimizelegibility" && (o.lineDiv.style.textRendering = "auto");
}
It.defaults = NB;
It.optionHandlers = Qd;
var mhe = It;
function _he(e) {
  let t = e.display;
  Ve(t.scroller, "mousedown", tr(e, AB)), dt && kt < 11 ? Ve(t.scroller, "dblclick", tr(e, (u) => {
    if (Qt(e, u))
      return;
    let f = Ca(e, u);
    if (!f || oE(e, u) || mo(e.display, u))
      return;
    Br(u);
    let c = e.findWordAt(f);
    Lg(e.doc, c.anchor, c.head);
  })) : Ve(t.scroller, "dblclick", (u) => Qt(e, u) || Br(u)), Ve(t.scroller, "contextmenu", (u) => wI(e, u)), Ve(t.input.getField(), "contextmenu", (u) => {
    t.scroller.contains(u.target) || wI(e, u);
  });
  let r, n = { end: 0 };
  function o() {
    t.activeTouch && (r = setTimeout(() => t.activeTouch = null, 1e3), n = t.activeTouch, n.end = +/* @__PURE__ */ new Date());
  }
  function s(u) {
    if (u.touches.length != 1)
      return !1;
    let f = u.touches[0];
    return f.radiusX <= 1 && f.radiusY <= 1;
  }
  function a(u, f) {
    if (f.left == null)
      return !0;
    let c = f.left - u.left, d = f.top - u.top;
    return c * c + d * d > 20 * 20;
  }
  Ve(t.scroller, "touchstart", (u) => {
    if (!Qt(e, u) && !s(u) && !oE(e, u)) {
      t.input.ensurePolled(), clearTimeout(r);
      let f = +/* @__PURE__ */ new Date();
      t.activeTouch = {
        start: f,
        moved: !1,
        prev: f - n.end <= 300 ? n : null
      }, u.touches.length == 1 && (t.activeTouch.left = u.touches[0].pageX, t.activeTouch.top = u.touches[0].pageY);
    }
  }), Ve(t.scroller, "touchmove", () => {
    t.activeTouch && (t.activeTouch.moved = !0);
  }), Ve(t.scroller, "touchend", (u) => {
    let f = t.activeTouch;
    if (f && !mo(t, u) && f.left != null && !f.moved && /* @__PURE__ */ new Date() - f.start < 300) {
      let c = e.coordsChar(t.activeTouch, "page"), d;
      !f.prev || a(f, f.prev) ? d = new wt(c, c) : !f.prev.prev || a(f, f.prev.prev) ? d = e.findWordAt(c) : d = new wt(Ee(c.line, 0), Ye(e.doc, Ee(c.line + 1, 0))), e.setSelection(d.anchor, d.head), e.focus(), Br(u);
    }
    o();
  }), Ve(t.scroller, "touchcancel", o), Ve(t.scroller, "scroll", () => {
    t.scroller.clientHeight && (Ic(e, t.scroller.scrollTop), rl(e, t.scroller.scrollLeft, !0), Ht(e, "scroll", e));
  }), Ve(t.scroller, "mousewheel", (u) => tI(e, u)), Ve(t.scroller, "DOMMouseScroll", (u) => tI(e, u)), Ve(t.wrapper, "scroll", () => t.wrapper.scrollTop = t.wrapper.scrollLeft = 0), t.dragFunctions = {
    enter: (u) => {
      Qt(e, u) || Zf(u);
    },
    over: (u) => {
      Qt(e, u) || (Yde(e, u), Zf(u));
    },
    start: (u) => Kde(e, u),
    drop: tr(e, Gde),
    leave: (u) => {
      Qt(e, u) || yB(e);
    }
  };
  let l = t.input.getField();
  Ve(l, "keyup", (u) => xB.call(e, u)), Ve(l, "keydown", tr(e, EB)), Ve(l, "keypress", tr(e, RB)), Ve(l, "focus", (u) => TR(e, u)), Ve(l, "blur", (u) => xu(e, u));
}
var sE = [];
It.defineInitHook = (e) => sE.push(e);
function Lf(e, t, r, n) {
  let o = e.doc, s;
  r == null && (r = "add"), r == "smart" && (o.mode.indent ? s = Cc(e, t).state : r = "prev");
  let a = e.options.tabSize, l = Be(o, t), u = wn(l.text, null, a);
  l.stateAfter && (l.stateAfter = null);
  let f = l.text.match(/^\s*/)[0], c;
  if (!n && !/\S/.test(l.text))
    c = 0, r = "not";
  else if (r == "smart" && (c = o.mode.indent(s, l.text.slice(f.length), l.text), c == xg || c > 150)) {
    if (!n)
      return;
    r = "prev";
  }
  r == "prev" ? t > o.first ? c = wn(Be(o, t - 1).text, null, a) : c = 0 : r == "add" ? c = u + e.options.indentUnit : r == "subtract" ? c = u - e.options.indentUnit : typeof r == "number" && (c = u + r), c = Math.max(0, c);
  let d = "", h = 0;
  if (e.options.indentWithTabs)
    for (let p = Math.floor(c / a); p; --p)
      h += a, d += "	";
  if (h < c && (d += nR(c - h)), d != f)
    return Au(o, d, Ee(t, 0), Ee(t, f.length), "+input"), l.stateAfter = null, !0;
  for (let p = 0; p < o.sel.ranges.length; p++) {
    let v = o.sel.ranges[p];
    if (v.head.line == t && v.head.ch < f.length) {
      let y = Ee(t, f.length);
      PR(o, p, new wt(y, y));
      break;
    }
  }
}
var qn = null;
function Wh(e) {
  qn = e;
}
function WR(e, t, r, n, o) {
  let s = e.doc;
  e.display.shift = !1, n || (n = s.sel);
  let a = +/* @__PURE__ */ new Date() - 200, l = o == "paste" || e.state.pasteIncoming > a, u = sR(t), f = null;
  if (l && n.ranges.length > 1)
    if (qn && qn.text.join(`
`) == t) {
      if (n.ranges.length % qn.text.length == 0) {
        f = [];
        for (let d = 0; d < qn.text.length; d++)
          f.push(s.splitLines(qn.text[d]));
      }
    } else
      u.length == n.ranges.length && e.options.pasteLinesPerSelection && (f = Rg(u, (d) => [d]));
  let c = e.curOp.updateInput;
  for (let d = n.ranges.length - 1; d >= 0; d--) {
    let h = n.ranges[d], p = h.from(), v = h.to();
    h.empty() && (r && r > 0 ? p = Ee(p.line, p.ch - r) : e.state.overwrite && !l ? v = Ee(v.line, Math.min(Be(s, v.line).text.length, v.ch + vt(u).length)) : l && qn && qn.lineWise && qn.text.join(`
`) == u.join(`
`) && (p = v = Ee(p.line, 0)));
    let y = {
      from: p,
      to: v,
      text: f ? f[d % f.length] : u,
      origin: o || (l ? "paste" : e.state.cutIncoming > a ? "cut" : "+input")
    };
    iu(e.doc, y), ir(e, "inputRead", e, y);
  }
  t && !l && CB(e, t), Ru(e), e.curOp.updateInput < 2 && (e.curOp.updateInput = c), e.curOp.typing = !0, e.state.pasteIncoming = e.state.cutIncoming = -1;
}
function kB(e, t) {
  let r = e.clipboardData && e.clipboardData.getData("Text");
  if (r)
    return e.preventDefault(), !t.isReadOnly() && !t.options.disableInput && en(t, () => WR(t, r, 0, null, "paste")), !0;
}
function CB(e, t) {
  if (!e.options.electricChars || !e.options.smartIndent)
    return;
  let r = e.doc.sel;
  for (let n = r.ranges.length - 1; n >= 0; n--) {
    let o = r.ranges[n];
    if (o.head.ch > 100 || n && r.ranges[n - 1].head.line == o.head.line)
      continue;
    let s = e.getModeAt(o.head), a = !1;
    if (s.electricChars) {
      for (let l = 0; l < s.electricChars.length; l++)
        if (t.indexOf(s.electricChars.charAt(l)) > -1) {
          a = Lf(e, o.head.line, "smart");
          break;
        }
    } else
      s.electricInput && s.electricInput.test(Be(e.doc, o.head.line).text.slice(0, o.head.ch)) && (a = Lf(e, o.head.line, "smart"));
    a && ir(e, "electricInput", e, o.head.line);
  }
}
function IB(e) {
  let t = [], r = [];
  for (let n = 0; n < e.doc.sel.ranges.length; n++) {
    let o = e.doc.sel.ranges[n].head.line, s = { anchor: Ee(o, 0), head: Ee(o + 1, 0) };
    r.push(s), t.push(e.getRange(s.anchor, s.head));
  }
  return { text: t, ranges: r };
}
function MB(e, t, r, n) {
  e.setAttribute("autocorrect", r ? "" : "off"), e.setAttribute("autocapitalize", n ? "" : "off"), e.setAttribute("spellcheck", !!t);
}
function OB() {
  let e = He("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"), t = He("div", [e], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
  return Nr ? e.style.width = "1000px" : e.setAttribute("wrap", "off"), kc && (e.style.border = "1px solid black"), MB(e), t;
}
function whe(e) {
  let t = e.optionHandlers, r = e.helpers = {};
  e.prototype = {
    constructor: e,
    focus: function() {
      window.focus(), this.display.input.focus();
    },
    setOption: function(n, o) {
      let s = this.options, a = s[n];
      s[n] == o && n != "mode" || (s[n] = o, t.hasOwnProperty(n) && tr(this, t[n])(this, o, a), Ht(this, "optionChange", this, n));
    },
    getOption: function(n) {
      return this.options[n];
    },
    getDoc: function() {
      return this.doc;
    },
    addKeyMap: function(n, o) {
      this.state.keyMaps[o ? "push" : "unshift"](qh(n));
    },
    removeKeyMap: function(n) {
      let o = this.state.keyMaps;
      for (let s = 0; s < o.length; ++s)
        if (o[s] == n || o[s].name == n)
          return o.splice(s, 1), !0;
    },
    addOverlay: Tr(function(n, o) {
      let s = n.token ? n : e.getMode(this.options, n);
      if (s.startState)
        throw new Error("Overlays may not be stateful.");
      cce(this.state.overlays, {
        mode: s,
        modeSpec: n,
        opaque: o && o.opaque,
        priority: o && o.priority || 0
      }, (a) => a.priority), this.state.modeGen++, qr(this);
    }),
    removeOverlay: Tr(function(n) {
      let o = this.state.overlays;
      for (let s = 0; s < o.length; ++s) {
        let a = o[s].modeSpec;
        if (a == n || typeof n == "string" && a.name == n) {
          o.splice(s, 1), this.state.modeGen++, qr(this);
          return;
        }
      }
    }),
    indentLine: Tr(function(n, o, s) {
      typeof o != "string" && typeof o != "number" && (o == null ? o = this.options.smartIndent ? "smart" : "prev" : o = o ? "add" : "subtract"), ec(this.doc, n) && Lf(this, n, o, s);
    }),
    indentSelection: Tr(function(n) {
      let o = this.doc.sel.ranges, s = -1;
      for (let a = 0; a < o.length; a++) {
        let l = o[a];
        if (l.empty())
          l.head.line > s && (Lf(this, l.head.line, n, !0), s = l.head.line, a == this.doc.sel.primIndex && Ru(this));
        else {
          let u = l.from(), f = l.to(), c = Math.max(s, u.line);
          s = Math.min(this.lastLine(), f.line - (f.ch ? 0 : 1)) + 1;
          for (let h = c; h < s; ++h)
            Lf(this, h, n);
          let d = this.doc.sel.ranges;
          u.ch == 0 && o.length == d.length && d[a].from().ch > 0 && PR(this.doc, a, new wt(u, d[a].to()), Ci);
        }
      }
    }),
    getTokenAt: function(n, o) {
      return WC(this, n, o);
    },
    getLineTokens: function(n, o) {
      return WC(this, Ee(n), o, !0);
    },
    getTokenTypeAt: function(n) {
      n = Ye(this.doc, n);
      let o = vj(this, Be(this.doc, n.line)), s = 0, a = (o.length - 1) / 2, l = n.ch, u;
      if (l == 0)
        u = o[2];
      else
        for (; ; ) {
          let c = s + a >> 1;
          if ((c ? o[c * 2 - 1] : 0) >= l)
            a = c;
          else if (o[c * 2 + 1] < l)
            s = c + 1;
          else {
            u = o[c * 2 + 2];
            break;
          }
        }
      let f = u ? u.indexOf("overlay ") : -1;
      return f < 0 ? u : f == 0 ? null : u.slice(0, f - 1);
    },
    getModeAt: function(n) {
      let o = this.doc.mode;
      return o.innerMode ? e.innerMode(o, this.getTokenAt(n).state).mode : o;
    },
    getHelper: function(n, o) {
      return this.getHelpers(n, o)[0];
    },
    getHelpers: function(n, o) {
      let s = [];
      if (!r.hasOwnProperty(o))
        return s;
      let a = r[o], l = this.getModeAt(n);
      if (typeof l[o] == "string")
        a[l[o]] && s.push(a[l[o]]);
      else if (l[o])
        for (let u = 0; u < l[o].length; u++) {
          let f = a[l[o][u]];
          f && s.push(f);
        }
      else
        l.helperType && a[l.helperType] ? s.push(a[l.helperType]) : a[l.name] && s.push(a[l.name]);
      for (let u = 0; u < a._global.length; u++) {
        let f = a._global[u];
        f.pred(l, this) && _r(s, f.val) == -1 && s.push(f.val);
      }
      return s;
    },
    getStateAfter: function(n, o) {
      let s = this.doc;
      return n = bj(s, n ?? s.first + s.size - 1), Cc(this, n + 1, o).state;
    },
    cursorCoords: function(n, o) {
      let s, a = this.doc.sel.primary();
      return n == null ? s = a.head : typeof n == "object" ? s = Ye(this.doc, n) : s = n ? a.from() : a.to(), zn(this, s, o || "page");
    },
    charCoords: function(n, o) {
      return XS(this, Ye(this.doc, n), o || "page");
    },
    coordsChar: function(n, o) {
      return n = XC(this, n, o || "page"), wR(this, n.left, n.top);
    },
    lineAtHeight: function(n, o) {
      return n = XC(this, { top: n, left: 0 }, o || "page").top, Zs(this.doc, n + this.display.viewOffset);
    },
    heightAtLine: function(n, o, s) {
      let a = !1, l;
      if (typeof n == "number") {
        let u = this.doc.first + this.doc.size - 1;
        n < this.doc.first ? n = this.doc.first : n > u && (n = u, a = !0), l = Be(this.doc, n);
      } else
        l = n;
      return Ig(this, l, { top: 0, left: 0 }, o || "page", s || a).top + (a ? this.doc.height - vo(l) : 0);
    },
    defaultTextHeight: function() {
      return ru(this.display);
    },
    defaultCharWidth: function() {
      return Eu(this.display);
    },
    getViewport: function() {
      return { from: this.display.viewFrom, to: this.display.viewTo };
    },
    addWidget: function(n, o, s, a, l) {
      let u = this.display;
      n = zn(this, Ye(this.doc, n));
      let f = n.bottom, c = n.left;
      if (o.style.position = "absolute", o.setAttribute("cm-ignore-events", "true"), this.display.input.setUneditable(o), u.sizer.appendChild(o), a == "over")
        f = n.top;
      else if (a == "above" || a == "near") {
        let d = Math.max(u.wrapper.clientHeight, this.doc.height), h = Math.max(u.sizer.clientWidth, u.lineSpace.clientWidth);
        (a == "above" || n.bottom + o.offsetHeight > d) && n.top > o.offsetHeight ? f = n.top - o.offsetHeight : n.bottom + o.offsetHeight <= d && (f = n.bottom), c + o.offsetWidth > h && (c = h - o.offsetWidth);
      }
      o.style.top = f + "px", o.style.left = o.style.right = "", l == "right" ? (c = u.sizer.clientWidth - o.offsetWidth, o.style.right = "0px") : (l == "left" ? c = 0 : l == "middle" && (c = (u.sizer.clientWidth - o.offsetWidth) / 2), o.style.left = c + "px"), s && gde(this, { left: c, top: f, right: c + o.offsetWidth, bottom: f + o.offsetHeight });
    },
    triggerOnKeyDown: Tr(EB),
    triggerOnKeyPress: Tr(RB),
    triggerOnKeyUp: xB,
    triggerOnMouseDown: Tr(AB),
    execCommand: function(n) {
      if (lc.hasOwnProperty(n))
        return lc[n].call(null, this);
    },
    triggerElectric: Tr(function(n) {
      CB(this, n);
    }),
    findPosH: function(n, o, s, a) {
      let l = 1;
      o < 0 && (l = -1, o = -o);
      let u = Ye(this.doc, n);
      for (let f = 0; f < o && (u = x0(this.doc, u, l, s, a), !u.hitSide); ++f)
        ;
      return u;
    },
    moveH: Tr(function(n, o) {
      this.extendSelectionsBy((s) => this.display.shift || this.doc.extend || s.empty() ? x0(this.doc, s.head, n, o, this.options.rtlMoveVisually) : n < 0 ? s.from() : s.to(), Tf);
    }),
    deleteH: Tr(function(n, o) {
      let s = this.doc.sel, a = this.doc;
      s.somethingSelected() ? a.replaceSelection("", null, "+delete") : wl(this, (l) => {
        let u = x0(a, l.head, n, o, !1);
        return n < 0 ? { from: u, to: l.head } : { from: l.head, to: u };
      });
    }),
    findPosV: function(n, o, s, a) {
      let l = 1, u = a;
      o < 0 && (l = -1, o = -o);
      let f = Ye(this.doc, n);
      for (let c = 0; c < o; ++c) {
        let d = zn(this, f, "div");
        if (u == null ? u = d.left : d.left = u, f = SI(this, d, l, s), f.hitSide)
          break;
      }
      return f;
    },
    moveV: Tr(function(n, o) {
      let s = this.doc, a = [], l = !this.display.shift && !s.extend && s.sel.somethingSelected();
      if (s.extendSelectionsBy((u) => {
        if (l)
          return n < 0 ? u.from() : u.to();
        let f = zn(this, u.head, "div");
        u.goalColumn != null && (f.left = u.goalColumn), a.push(f.left);
        let c = SI(this, f, n, o);
        return o == "page" && u == s.sel.primary() && NR(this, XS(this, c, "div").top - f.top), c;
      }, Tf), a.length)
        for (let u = 0; u < s.sel.ranges.length; u++)
          s.sel.ranges[u].goalColumn = a[u];
    }),
    findWordAt: function(n) {
      let o = this.doc, s = Be(o, n.line).text, a = n.ch, l = n.ch;
      if (s) {
        let u = this.getHelper(n, "wordChars");
        (n.sticky == "before" || l == s.length) && a ? --a : ++l;
        let f = s.charAt(a), c = Kd(f, u) ? (d) => Kd(d, u) : /\s/.test(f) ? (d) => /\s/.test(d) : (d) => !/\s/.test(d) && !Kd(d);
        for (; a > 0 && c(s.charAt(a - 1)); )
          --a;
        for (; l < s.length && c(s.charAt(l)); )
          ++l;
      }
      return new wt(Ee(n.line, a), Ee(n.line, l));
    },
    toggleOverwrite: function(n) {
      n != null && n == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? el(this.display.cursorDiv, "CodeMirror-overwrite") : Za(this.display.cursorDiv, "CodeMirror-overwrite"), Ht(this, "overwriteToggle", this, this.state.overwrite));
    },
    hasFocus: function() {
      return this.display.input.getField() == En();
    },
    isReadOnly: function() {
      return !!(this.options.readOnly || this.doc.cantEdit);
    },
    scrollTo: Tr(function(n, o) {
      Cf(this, n, o);
    }),
    getScrollInfo: function() {
      let n = this.display.scroller;
      return {
        left: n.scrollLeft,
        top: n.scrollTop,
        height: n.scrollHeight - Oi(this) - this.display.barHeight,
        width: n.scrollWidth - Oi(this) - this.display.barWidth,
        clientHeight: vR(this),
        clientWidth: tl(this)
      };
    },
    scrollIntoView: Tr(function(n, o) {
      n == null ? (n = { from: this.doc.sel.primary().head, to: null }, o == null && (o = this.options.cursorScrollMargin)) : typeof n == "number" ? n = { from: Ee(n, 0), to: null } : n.from == null && (n = { from: n, to: null }), n.to || (n.to = n.from), n.margin = o || 0, n.from.line != null ? bde(this, n) : Gj(this, n.from, n.to, n.margin);
    }),
    setSize: Tr(function(n, o) {
      let s = (l) => typeof l == "number" || /^\d+$/.test(String(l)) ? l + "px" : l;
      n != null && (this.display.wrapper.style.width = s(n)), o != null && (this.display.wrapper.style.height = s(o)), this.options.lineWrapping && Fj(this);
      let a = this.display.viewFrom;
      this.doc.iter(a, this.display.viewTo, (l) => {
        if (l.widgets) {
          for (let u = 0; u < l.widgets.length; u++)
            if (l.widgets[u].noHScroll) {
              Es(this, a, "widget");
              break;
            }
        }
        ++a;
      }), this.curOp.forceUpdate = !0, Ht(this, "refresh", this);
    }),
    operation: function(n) {
      return en(this, n);
    },
    startOperation: function() {
      return nl(this);
    },
    endOperation: function() {
      return il(this);
    },
    refresh: Tr(function() {
      let n = this.display.cachedTextHeight;
      qr(this), this.curOp.forceUpdate = !0, oc(this), Cf(this, this.doc.scrollLeft, this.doc.scrollTop), CR(this.display), (n == null || Math.abs(n - ru(this.display)) > 0.5 || this.options.lineWrapping) && xR(this), Ht(this, "refresh", this);
    }),
    swapDoc: Tr(function(n) {
      let o = this.doc;
      return o.cm = null, this.state.selectingText && this.state.selectingText(), iB(this, n), oc(this), this.display.input.reset(), Cf(this, n.scrollLeft, n.scrollTop), this.curOp.forceScroll = !0, ir(this, "swapDoc", this, o), o;
    }),
    phrase: function(n) {
      let o = this.options.phrases;
      return o && Object.prototype.hasOwnProperty.call(o, n) ? o[n] : n;
    },
    getInputField: function() {
      return this.display.input.getField();
    },
    getWrapperElement: function() {
      return this.display.wrapper;
    },
    getScrollerElement: function() {
      return this.display.scroller;
    },
    getGutterElement: function() {
      return this.display.gutters;
    }
  }, wu(e), e.registerHelper = function(n, o, s) {
    r.hasOwnProperty(n) || (r[n] = e[n] = { _global: [] }), r[n][o] = s;
  }, e.registerGlobalHelper = function(n, o, s, a) {
    e.registerHelper(n, o, a), r[n]._global.push({ pred: s, val: a });
  };
}
function x0(e, t, r, n, o) {
  let s = t, a = r, l = Be(e, t.line), u = o && e.direction == "rtl" ? -r : r;
  function f() {
    let h = t.line + u;
    return h < e.first || h >= e.first + e.size ? !1 : (t = new Ee(h, t.ch, t.sticky), l = Be(e, h));
  }
  function c(h) {
    let p;
    if (n == "codepoint") {
      let v = l.text.charCodeAt(t.ch + (r > 0 ? 0 : -1));
      if (isNaN(v))
        p = null;
      else {
        let y = r > 0 ? v >= 55296 && v < 56320 : v >= 56320 && v < 57343;
        p = new Ee(t.line, Math.max(0, Math.min(l.text.length, t.ch + r * (y ? 2 : 1))), -r);
      }
    } else
      o ? p = the(e.cm, l, t, r) : p = nE(l, t, r);
    if (p == null)
      if (!h && f())
        t = qR(o, e.cm, l, t.line, u);
      else
        return !1;
    else
      t = p;
    return !0;
  }
  if (n == "char" || n == "codepoint")
    c();
  else if (n == "column")
    c(!0);
  else if (n == "word" || n == "group") {
    let h = null, p = n == "group", v = e.cm && e.cm.getHelper(t, "wordChars");
    for (let y = !0; !(r < 0 && !c(!y)); y = !1) {
      let w = l.text.charAt(t.ch) || `
`, S = Kd(w, v) ? "w" : p && w == `
` ? "n" : !p || /\s/.test(w) ? null : "p";
      if (p && !y && !S && (S = "s"), h && h != S) {
        r < 0 && (r = 1, c(), t.sticky = "after");
        break;
      }
      if (S && (h = S), r > 0 && !c(!y))
        break;
    }
  }
  let d = Bh(e, t, s, a, !0);
  return zS(s, d) && (d.hitSide = !0), d;
}
function SI(e, t, r, n) {
  let o = e.doc, s = t.left, a;
  if (n == "page") {
    let u = Math.min(e.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight), f = Math.max(u - 0.5 * ru(e.display), 3);
    a = (r > 0 ? t.bottom : t.top) + r * f;
  } else
    n == "line" && (a = r > 0 ? t.bottom + 3 : t.top - 3);
  let l;
  for (; l = wR(e, s, a), !!l.outside; ) {
    if (r < 0 ? a <= 0 : a >= o.height) {
      l.hitSide = !0;
      break;
    }
    a += r * 5;
  }
  return l;
}
var LB = class {
  constructor(e) {
    this.cm = e, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, this.polling = new tu(), this.composing = null, this.gracePeriod = !1, this.readDOMTimeout = null;
  }
  init(e) {
    let t = this, r = t.cm, n = t.div = e.lineDiv;
    n.contentEditable = !0, MB(n, r.options.spellcheck, r.options.autocorrect, r.options.autocapitalize);
    function o(a) {
      for (let l = a.target; l; l = l.parentNode) {
        if (l == n)
          return !0;
        if (/\bCodeMirror-(?:line)?widget\b/.test(l.className))
          break;
      }
      return !1;
    }
    Ve(n, "paste", (a) => {
      !o(a) || Qt(r, a) || kB(a, r) || kt <= 11 && setTimeout(tr(r, () => this.updateFromDOM()), 20);
    }), Ve(n, "compositionstart", (a) => {
      this.composing = { data: a.data, done: !1 };
    }), Ve(n, "compositionupdate", (a) => {
      this.composing || (this.composing = { data: a.data, done: !1 });
    }), Ve(n, "compositionend", (a) => {
      this.composing && (a.data != this.composing.data && this.readFromDOMSoon(), this.composing.done = !0);
    }), Ve(n, "touchstart", () => t.forceCompositionEnd()), Ve(n, "input", () => {
      this.composing || this.readFromDOMSoon();
    });
    function s(a) {
      if (!o(a) || Qt(r, a))
        return;
      if (r.somethingSelected())
        Wh({ lineWise: !1, text: r.getSelections() }), a.type == "cut" && r.replaceSelection("", null, "cut");
      else if (r.options.lineWiseCopyCut) {
        let c = IB(r);
        Wh({ lineWise: !0, text: c.text }), a.type == "cut" && r.operation(() => {
          r.setSelections(c.ranges, 0, Ci), r.replaceSelection("", null, "cut");
        });
      } else
        return;
      if (a.clipboardData) {
        a.clipboardData.clearData();
        let c = qn.text.join(`
`);
        if (a.clipboardData.setData("Text", c), a.clipboardData.getData("Text") == c) {
          a.preventDefault();
          return;
        }
      }
      let l = OB(), u = l.firstChild;
      r.display.lineSpace.insertBefore(l, r.display.lineSpace.firstChild), u.value = qn.text.join(`
`);
      let f = En();
      Xf(u), setTimeout(() => {
        r.display.lineSpace.removeChild(l), f.focus(), f == n && t.showPrimarySelection();
      }, 50);
    }
    Ve(n, "copy", s), Ve(n, "cut", s);
  }
  screenReaderLabelChanged(e) {
    e ? this.div.setAttribute("aria-label", e) : this.div.removeAttribute("aria-label");
  }
  prepareSelection() {
    let e = Hj(this.cm, !1);
    return e.focus = En() == this.div, e;
  }
  showSelection(e, t) {
    !e || !this.cm.display.view.length || ((e.focus || t) && this.showPrimarySelection(), this.showMultipleSelections(e));
  }
  getSelection() {
    return this.cm.display.wrapper.ownerDocument.getSelection();
  }
  showPrimarySelection() {
    let e = this.getSelection(), t = this.cm, r = t.doc.sel.primary(), n = r.from(), o = r.to();
    if (t.display.viewTo == t.display.viewFrom || n.line >= t.display.viewTo || o.line < t.display.viewFrom) {
      e.removeAllRanges();
      return;
    }
    let s = xd(t, e.anchorNode, e.anchorOffset), a = xd(t, e.focusNode, e.focusOffset);
    if (s && !s.bad && a && !a.bad && Xe($g(s, a), n) == 0 && Xe(Tg(s, a), o) == 0)
      return;
    let l = t.display.view, u = n.line >= t.display.viewFrom && EI(t, n) || { node: l[0].measure.map[2], offset: 0 }, f = o.line < t.display.viewTo && EI(t, o);
    if (!f) {
      let h = l[l.length - 1].measure, p = h.maps ? h.maps[h.maps.length - 1] : h.map;
      f = { node: p[p.length - 1], offset: p[p.length - 2] - p[p.length - 3] };
    }
    if (!u || !f) {
      e.removeAllRanges();
      return;
    }
    let c = e.rangeCount && e.getRangeAt(0), d;
    try {
      d = Na(u.node, u.offset, f.offset, f.node);
    } catch {
    }
    d && (!bo && t.state.focused ? (e.collapse(u.node, u.offset), d.collapsed || (e.removeAllRanges(), e.addRange(d))) : (e.removeAllRanges(), e.addRange(d)), c && e.anchorNode == null ? e.addRange(c) : bo && this.startGracePeriod()), this.rememberSelection();
  }
  startGracePeriod() {
    clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(() => {
      this.gracePeriod = !1, this.selectionChanged() && this.cm.operation(() => this.cm.curOp.selectionChanged = !0);
    }, 20);
  }
  showMultipleSelections(e) {
    hn(this.cm.display.cursorDiv, e.cursors), hn(this.cm.display.selectionDiv, e.selection);
  }
  rememberSelection() {
    let e = this.getSelection();
    this.lastAnchorNode = e.anchorNode, this.lastAnchorOffset = e.anchorOffset, this.lastFocusNode = e.focusNode, this.lastFocusOffset = e.focusOffset;
  }
  selectionInEditor() {
    let e = this.getSelection();
    if (!e.rangeCount)
      return !1;
    let t = e.getRangeAt(0).commonAncestorContainer;
    return fs(this.div, t);
  }
  focus() {
    this.cm.options.readOnly != "nocursor" && ((!this.selectionInEditor() || En() != this.div) && this.showSelection(this.prepareSelection(), !0), this.div.focus());
  }
  blur() {
    this.div.blur();
  }
  getField() {
    return this.div;
  }
  supportsTouch() {
    return !0;
  }
  receivedFocus() {
    let e = this;
    this.selectionInEditor() ? this.pollSelection() : en(this.cm, () => e.cm.curOp.selectionChanged = !0);
    function t() {
      e.cm.state.focused && (e.pollSelection(), e.polling.set(e.cm.options.pollInterval, t));
    }
    this.polling.set(this.cm.options.pollInterval, t);
  }
  selectionChanged() {
    let e = this.getSelection();
    return e.anchorNode != this.lastAnchorNode || e.anchorOffset != this.lastAnchorOffset || e.focusNode != this.lastFocusNode || e.focusOffset != this.lastFocusOffset;
  }
  pollSelection() {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged())
      return;
    let e = this.getSelection(), t = this.cm;
    if (Eg && wg && this.cm.display.gutterSpecs.length && Ehe(e.anchorNode)) {
      this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs }), this.blur(), this.focus();
      return;
    }
    if (this.composing)
      return;
    this.rememberSelection();
    let r = xd(t, e.anchorNode, e.anchorOffset), n = xd(t, e.focusNode, e.focusOffset);
    r && n && en(t, () => {
      pr(t.doc, ds(r, n), Ci), (r.bad || n.bad) && (t.curOp.selectionChanged = !0);
    });
  }
  pollContent() {
    this.readDOMTimeout != null && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null);
    let e = this.cm, t = e.display, r = e.doc.sel.primary(), n = r.from(), o = r.to();
    if (n.ch == 0 && n.line > e.firstLine() && (n = Ee(n.line - 1, Be(e.doc, n.line - 1).length)), o.ch == Be(e.doc, o.line).text.length && o.line < e.lastLine() && (o = Ee(o.line + 1, 0)), n.line < t.viewFrom || o.line > t.viewTo - 1)
      return !1;
    let s, a, l;
    n.line == t.viewFrom || (s = Ia(e, n.line)) == 0 ? (a = mt(t.view[0].line), l = t.view[0].node) : (a = mt(t.view[s].line), l = t.view[s - 1].node.nextSibling);
    let u = Ia(e, o.line), f, c;
    if (u == t.view.length - 1 ? (f = t.viewTo - 1, c = t.lineDiv.lastChild) : (f = mt(t.view[u + 1].line) - 1, c = t.view[u + 1].node.previousSibling), !l)
      return !1;
    let d = e.doc.splitLines(xhe(e, l, c, a, f)), h = ya(e.doc, Ee(a, 0), Ee(f, Be(e.doc, f).text.length));
    for (; d.length > 1 && h.length > 1; )
      if (vt(d) == vt(h))
        d.pop(), h.pop(), f--;
      else if (d[0] == h[0])
        d.shift(), h.shift(), a++;
      else
        break;
    let p = 0, v = 0, y = d[0], w = h[0], S = Math.min(y.length, w.length);
    for (; p < S && y.charCodeAt(p) == w.charCodeAt(p); )
      ++p;
    let x = vt(d), E = vt(h), N = Math.min(x.length - (d.length == 1 ? p : 0), E.length - (h.length == 1 ? p : 0));
    for (; v < N && x.charCodeAt(x.length - v - 1) == E.charCodeAt(E.length - v - 1); )
      ++v;
    if (d.length == 1 && h.length == 1 && a == n.line)
      for (; p && p > n.ch && x.charCodeAt(x.length - v - 1) == E.charCodeAt(E.length - v - 1); )
        p--, v++;
    d[d.length - 1] = x.slice(0, x.length - v).replace(/^\u200b+/, ""), d[0] = d[0].slice(p).replace(/\u200b+$/, "");
    let C = Ee(a, p), j = Ee(f, h.length ? vt(h).length - v : 0);
    if (d.length > 1 || d[0] || Xe(C, j))
      return Au(e.doc, d, C, j, "+input"), !0;
  }
  ensurePolled() {
    this.forceCompositionEnd();
  }
  reset() {
    this.forceCompositionEnd();
  }
  forceCompositionEnd() {
    this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), this.div.blur(), this.div.focus());
  }
  readFromDOMSoon() {
    this.readDOMTimeout == null && (this.readDOMTimeout = setTimeout(() => {
      if (this.readDOMTimeout = null, this.composing)
        if (this.composing.done)
          this.composing = null;
        else
          return;
      this.updateFromDOM();
    }, 80));
  }
  updateFromDOM() {
    (this.cm.isReadOnly() || !this.pollContent()) && en(this.cm, () => qr(this.cm));
  }
  setUneditable(e) {
    e.contentEditable = "false";
  }
  onKeyPress(e) {
    e.charCode == 0 || this.composing || (e.preventDefault(), this.cm.isReadOnly() || tr(this.cm, WR)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0));
  }
  readOnlyChanged(e) {
    this.div.contentEditable = String(e != "nocursor");
  }
  onContextMenu() {
  }
  resetPosition() {
  }
}, She = LB;
LB.prototype.needsContentAttribute = !0;
function EI(e, t) {
  let r = mR(e, t.line);
  if (!r || r.hidden)
    return null;
  let n = Be(e.doc, t.line), o = Mj(r, n, t.line), s = $o(n, e.doc.direction), a = "left";
  s && (a = Qf(s, t.ch) % 2 ? "right" : "left");
  let l = Pj(o.map, t.ch, a);
  return l.offset = l.collapse == "right" ? l.end : l.start, l;
}
function Ehe(e) {
  for (let t = e; t; t = t.parentNode)
    if (/CodeMirror-gutter-wrapper/.test(t.className))
      return !0;
  return !1;
}
function Sl(e, t) {
  return t && (e.bad = !0), e;
}
function xhe(e, t, r, n, o) {
  let s = "", a = !1, l = e.doc.lineSeparator(), u = !1;
  function f(p) {
    return (v) => v.id == p;
  }
  function c() {
    a && (s += l, u && (s += l), a = u = !1);
  }
  function d(p) {
    p && (c(), s += p);
  }
  function h(p) {
    if (p.nodeType == 1) {
      let v = p.getAttribute("cm-text");
      if (v) {
        d(v);
        return;
      }
      let y = p.getAttribute("cm-marker"), w;
      if (y) {
        let x = e.findMarks(Ee(n, 0), Ee(o + 1, 0), f(+y));
        x.length && (w = x[0].find(0)) && d(ya(e.doc, w.from, w.to).join(l));
        return;
      }
      if (p.getAttribute("contenteditable") == "false")
        return;
      let S = /^(pre|div|p|li|table|br)$/i.test(p.nodeName);
      if (!/^br$/i.test(p.nodeName) && p.textContent.length == 0)
        return;
      S && c();
      for (let x = 0; x < p.childNodes.length; x++)
        h(p.childNodes[x]);
      /^(pre|p)$/i.test(p.nodeName) && (u = !0), S && (a = !0);
    } else
      p.nodeType == 3 && d(p.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
  }
  for (; h(t), t != r; )
    t = t.nextSibling, u = !1;
  return s;
}
function xd(e, t, r) {
  let n;
  if (t == e.display.lineDiv) {
    if (n = e.display.lineDiv.childNodes[r], !n)
      return Sl(e.clipPos(Ee(e.display.viewTo - 1)), !0);
    t = null, r = 0;
  } else
    for (n = t; ; n = n.parentNode) {
      if (!n || n == e.display.lineDiv)
        return null;
      if (n.parentNode && n.parentNode == e.display.lineDiv)
        break;
    }
  for (let o = 0; o < e.display.view.length; o++) {
    let s = e.display.view[o];
    if (s.node == n)
      return Rhe(s, t, r);
  }
}
function Rhe(e, t, r) {
  let n = e.text.firstChild, o = !1;
  if (!t || !fs(n, t))
    return Sl(Ee(mt(e.line), 0), !0);
  if (t == n && (o = !0, t = n.childNodes[r], r = 0, !t)) {
    let d = e.rest ? vt(e.rest) : e.line;
    return Sl(Ee(mt(d), d.text.length), o);
  }
  let s = t.nodeType == 3 ? t : null, a = t;
  for (!s && t.childNodes.length == 1 && t.firstChild.nodeType == 3 && (s = t.firstChild, r && (r = s.nodeValue.length)); a.parentNode != n; )
    a = a.parentNode;
  let l = e.measure, u = l.maps;
  function f(d, h, p) {
    for (let v = -1; v < (u ? u.length : 0); v++) {
      let y = v < 0 ? l.map : u[v];
      for (let w = 0; w < y.length; w += 3) {
        let S = y[w + 2];
        if (S == d || S == h) {
          let x = mt(v < 0 ? e.line : e.rest[v]), E = y[w] + p;
          return (p < 0 || S != d) && (E = y[w + (p ? 1 : 0)]), Ee(x, E);
        }
      }
    }
  }
  let c = f(s, a, r);
  if (c)
    return Sl(c, o);
  for (let d = a.nextSibling, h = s ? s.nodeValue.length - r : 0; d; d = d.nextSibling) {
    if (c = f(d, d.firstChild, 0), c)
      return Sl(Ee(c.line, c.ch - h), o);
    h += d.textContent.length;
  }
  for (let d = a.previousSibling, h = r; d; d = d.previousSibling) {
    if (c = f(d, d.firstChild, -1), c)
      return Sl(Ee(c.line, c.ch + h), o);
    h += d.textContent.length;
  }
}
var PB = class {
  constructor(e) {
    this.cm = e, this.prevInput = "", this.pollingFast = !1, this.polling = new tu(), this.hasSelection = !1, this.composing = null;
  }
  init(e) {
    let t = this, r = this.cm;
    this.createField(e);
    const n = this.textarea;
    e.wrapper.insertBefore(this.wrapper, e.wrapper.firstChild), kc && (n.style.width = "0px"), Ve(n, "input", () => {
      dt && kt >= 9 && this.hasSelection && (this.hasSelection = null), t.poll();
    }), Ve(n, "paste", (s) => {
      Qt(r, s) || kB(s, r) || (r.state.pasteIncoming = +/* @__PURE__ */ new Date(), t.fastPoll());
    });
    function o(s) {
      if (!Qt(r, s)) {
        if (r.somethingSelected())
          Wh({ lineWise: !1, text: r.getSelections() });
        else if (r.options.lineWiseCopyCut) {
          let a = IB(r);
          Wh({ lineWise: !0, text: a.text }), s.type == "cut" ? r.setSelections(a.ranges, null, Ci) : (t.prevInput = "", n.value = a.text.join(`
`), Xf(n));
        } else
          return;
        s.type == "cut" && (r.state.cutIncoming = +/* @__PURE__ */ new Date());
      }
    }
    Ve(n, "cut", o), Ve(n, "copy", o), Ve(e.scroller, "paste", (s) => {
      if (mo(e, s) || Qt(r, s))
        return;
      if (!n.dispatchEvent) {
        r.state.pasteIncoming = +/* @__PURE__ */ new Date(), t.focus();
        return;
      }
      const a = new Event("paste");
      a.clipboardData = s.clipboardData, n.dispatchEvent(a);
    }), Ve(e.lineSpace, "selectstart", (s) => {
      mo(e, s) || Br(s);
    }), Ve(n, "compositionstart", () => {
      let s = r.getCursor("from");
      t.composing && t.composing.range.clear(), t.composing = {
        start: s,
        range: r.markText(s, r.getCursor("to"), { className: "CodeMirror-composing" })
      };
    }), Ve(n, "compositionend", () => {
      t.composing && (t.poll(), t.composing.range.clear(), t.composing = null);
    });
  }
  createField(e) {
    this.wrapper = OB(), this.textarea = this.wrapper.firstChild;
  }
  screenReaderLabelChanged(e) {
    e ? this.textarea.setAttribute("aria-label", e) : this.textarea.removeAttribute("aria-label");
  }
  prepareSelection() {
    let e = this.cm, t = e.display, r = e.doc, n = Hj(e);
    if (e.options.moveInputWithCursor) {
      let o = zn(e, r.sel.primary().head, "div"), s = t.wrapper.getBoundingClientRect(), a = t.lineDiv.getBoundingClientRect();
      n.teTop = Math.max(0, Math.min(t.wrapper.clientHeight - 10, o.top + a.top - s.top)), n.teLeft = Math.max(0, Math.min(t.wrapper.clientWidth - 10, o.left + a.left - s.left));
    }
    return n;
  }
  showSelection(e) {
    let t = this.cm, r = t.display;
    hn(r.cursorDiv, e.cursors), hn(r.selectionDiv, e.selection), e.teTop != null && (this.wrapper.style.top = e.teTop + "px", this.wrapper.style.left = e.teLeft + "px");
  }
  reset(e) {
    if (this.contextMenuPending || this.composing)
      return;
    let t = this.cm;
    if (t.somethingSelected()) {
      this.prevInput = "";
      let r = t.getSelection();
      this.textarea.value = r, t.state.focused && Xf(this.textarea), dt && kt >= 9 && (this.hasSelection = r);
    } else
      e || (this.prevInput = this.textarea.value = "", dt && kt >= 9 && (this.hasSelection = null));
  }
  getField() {
    return this.textarea;
  }
  supportsTouch() {
    return !1;
  }
  focus() {
    if (this.cm.options.readOnly != "nocursor" && (!Yf || En() != this.textarea))
      try {
        this.textarea.focus();
      } catch {
      }
  }
  blur() {
    this.textarea.blur();
  }
  resetPosition() {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  }
  receivedFocus() {
    this.slowPoll();
  }
  slowPoll() {
    this.pollingFast || this.polling.set(this.cm.options.pollInterval, () => {
      this.poll(), this.cm.state.focused && this.slowPoll();
    });
  }
  fastPoll() {
    let e = !1, t = this;
    t.pollingFast = !0;
    function r() {
      !t.poll() && !e ? (e = !0, t.polling.set(60, r)) : (t.pollingFast = !1, t.slowPoll());
    }
    t.polling.set(20, r);
  }
  poll() {
    let e = this.cm, t = this.textarea, r = this.prevInput;
    if (this.contextMenuPending || !e.state.focused || mce(t) && !r && !this.composing || e.isReadOnly() || e.options.disableInput || e.state.keySeq)
      return !1;
    let n = t.value;
    if (n == r && !e.somethingSelected())
      return !1;
    if (dt && kt >= 9 && this.hasSelection === n || Rn && /[\uf700-\uf7ff]/.test(n))
      return e.display.input.reset(), !1;
    if (e.doc.sel == e.display.selForContextMenu) {
      let a = n.charCodeAt(0);
      if (a == 8203 && !r && (r = "​"), a == 8666)
        return this.reset(), this.cm.execCommand("undo");
    }
    let o = 0, s = Math.min(r.length, n.length);
    for (; o < s && r.charCodeAt(o) == n.charCodeAt(o); )
      ++o;
    return en(e, () => {
      WR(e, n.slice(o), r.length - o, null, this.composing ? "*compose" : null), n.length > 1e3 || n.indexOf(`
`) > -1 ? t.value = this.prevInput = "" : this.prevInput = n, this.composing && (this.composing.range.clear(), this.composing.range = e.markText(this.composing.start, e.getCursor("to"), { className: "CodeMirror-composing" }));
    }), !0;
  }
  ensurePolled() {
    this.pollingFast && this.poll() && (this.pollingFast = !1);
  }
  onKeyPress() {
    dt && kt >= 9 && (this.hasSelection = null), this.fastPoll();
  }
  onContextMenu(e) {
    let t = this, r = t.cm, n = r.display, o = t.textarea;
    t.contextMenuPending && t.contextMenuPending();
    let s = Ca(r, e), a = n.scroller.scrollTop;
    if (!s || Jn)
      return;
    r.options.resetSelectionOnContextMenu && r.doc.sel.contains(s) == -1 && tr(r, pr)(r.doc, ds(s), Ci);
    let u = o.style.cssText, f = t.wrapper.style.cssText, c = t.wrapper.offsetParent.getBoundingClientRect();
    t.wrapper.style.cssText = "position: static", o.style.cssText = `position: absolute; width: 30px; height: 30px;
      top: ${e.clientY - c.top - 5}px; left: ${e.clientX - c.left - 5}px;
      z-index: 1000; background: ${dt ? "rgba(255, 255, 255, .05)" : "transparent"};
      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);`;
    let d;
    Nr && (d = window.scrollY), n.input.focus(), Nr && window.scrollTo(null, d), n.input.reset(), r.somethingSelected() || (o.value = t.prevInput = " "), t.contextMenuPending = p, n.selForContextMenu = r.doc.sel, clearTimeout(n.detectingSelectAll);
    function h() {
      if (o.selectionStart != null) {
        let v = r.somethingSelected(), y = "​" + (v ? o.value : "");
        o.value = "⇚", o.value = y, t.prevInput = v ? "" : "​", o.selectionStart = 1, o.selectionEnd = y.length, n.selForContextMenu = r.doc.sel;
      }
    }
    function p() {
      if (t.contextMenuPending == p && (t.contextMenuPending = !1, t.wrapper.style.cssText = f, o.style.cssText = u, dt && kt < 9 && n.scrollbars.setScrollTop(n.scroller.scrollTop = a), o.selectionStart != null)) {
        (!dt || dt && kt < 9) && h();
        let v = 0, y = () => {
          n.selForContextMenu == r.doc.sel && o.selectionStart == 0 && o.selectionEnd > 0 && t.prevInput == "​" ? tr(r, dB)(r) : v++ < 10 ? n.detectingSelectAll = setTimeout(y, 500) : (n.selForContextMenu = null, n.input.reset());
        };
        n.detectingSelectAll = setTimeout(y, 200);
      }
    }
    if (dt && kt >= 9 && h(), tR) {
      Zf(e);
      let v = () => {
        cn(window, "mouseup", v), setTimeout(p, 20);
      };
      Ve(window, "mouseup", v);
    } else
      setTimeout(p, 50);
  }
  readOnlyChanged(e) {
    e || this.reset(), this.textarea.disabled = e == "nocursor", this.textarea.readOnly = !!e;
  }
  setUneditable() {
  }
}, Ahe = PB;
PB.prototype.needsContentAttribute = !1;
function The(e, t) {
  if (t = t ? ka(t) : {}, t.value = e.value, !t.tabindex && e.tabIndex && (t.tabindex = e.tabIndex), !t.placeholder && e.placeholder && (t.placeholder = e.placeholder), t.autofocus == null) {
    let s = En();
    t.autofocus = s == e || e.getAttribute("autofocus") != null && s == document.body;
  }
  function r() {
    e.value = o.getValue();
  }
  let n;
  if (e.form && (Ve(e.form, "submit", r), !t.leaveSubmitMethodAlone)) {
    let s = e.form;
    n = s.submit;
    try {
      let a = s.submit = () => {
        r(), s.submit = n, s.submit(), s.submit = a;
      };
    } catch {
    }
  }
  t.finishInit = (s) => {
    s.save = r, s.getTextArea = () => e, s.toTextArea = () => {
      s.toTextArea = isNaN, r(), e.parentNode.removeChild(s.getWrapperElement()), e.style.display = "", e.form && (cn(e.form, "submit", r), !t.leaveSubmitMethodAlone && typeof e.form.submit == "function" && (e.form.submit = n));
    };
  }, e.style.display = "none";
  let o = It((s) => e.parentNode.insertBefore(s, e.nextSibling), t);
  return o;
}
function $he(e) {
  e.off = cn, e.on = Ve, e.wheelEventPixels = Ide, e.Doc = va, e.splitLines = sR, e.countColumn = wn, e.findColumn = WS, e.isWordChar = US, e.Pass = xg, e.signal = Ht, e.Line = rc, e.changeEnd = hs, e.scrollbarModel = Yj, e.Pos = Ee, e.cmpPos = Xe, e.modes = aR, e.mimeModes = Rl, e.resolveMode = Mh, e.getMode = lR, e.modeExtensions = Fl, e.extendMode = xce, e.copyState = ba, e.startState = gj, e.innerMode = uR, e.commands = lc, e.keyMap = no, e.keyName = _B, e.isModifierKey = vB, e.lookupKey = Bl, e.normalizeKeyMap = ehe, e.StringStream = Ag, e.SharedTextMarker = jR, e.TextMarker = FR, e.LineWidget = DR, e.e_preventDefault = Br, e.e_stopPropagation = hj, e.e_stop = Zf, e.addClass = el, e.contains = fs, e.rmClass = Za, e.keyNames = ps;
}
bhe(It);
whe(It);
var Nhe = "iter insert remove copy getEditor constructor".split(" ");
for (let e in va.prototype)
  va.prototype.hasOwnProperty(e) && _r(Nhe, e) < 0 && (It.prototype[e] = /* @__PURE__ */ function(t) {
    return function() {
      return t.apply(this.doc, arguments);
    };
  }(va.prototype[e]));
wu(va);
It.inputStyles = { textarea: Ahe, contenteditable: She };
It.defineMode = function(e) {
  !It.defaults.mode && e != "null" && (It.defaults.mode = e), Sce.apply(this, arguments);
};
It.defineMIME = Ece;
It.defineMode("null", () => ({ token: (e) => e.skipToEnd() }));
It.defineMIME("text/plain", "null");
It.defineExtension = (e, t) => {
  It.prototype[e] = t;
};
It.defineDocExtension = (e, t) => {
  va.prototype[e] = t;
};
It.fromTextArea = The;
$he(It);
It.version = "5.61.0";
var Zd = It;
document.body.insertAdjacentHTML("beforeend", `
<style>
/* BASICS */

.CodeMirror {
  /* Set height, width, borders, and global font properties here */
  font-family: monospace;
  height: auto;
  color: black;
  direction: ltr;
}

/* PADDING */

.CodeMirror-lines {
  padding: 4px 0; /* Vertical padding around content */
}
.CodeMirror pre.CodeMirror-line,
.CodeMirror pre.CodeMirror-line-like {
  padding: 0 4px; /* Horizontal padding of content */
}

.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
  background-color: white; /* The little square between H and V scrollbars */
}

/* GUTTER */

.CodeMirror-gutters {
  border-right: 1px solid #ddd;
  background-color: #f7f7f7;
  white-space: nowrap;
}
.CodeMirror-linenumbers {}
.CodeMirror-linenumber {
  padding: 0 3px 0 5px;
  min-width: 20px;
  text-align: right;
  color: #999;
  white-space: nowrap;
}

.CodeMirror-guttermarker { color: black; }
.CodeMirror-guttermarker-subtle { color: #999; }

/* CURSOR */

.CodeMirror-cursor {
  border-left: 1px solid black;
  border-right: none;
  width: 0;
}
/* Shown when moving in bi-directional text */
.CodeMirror div.CodeMirror-secondarycursor {
  border-left: 1px solid silver;
}
.cm-fat-cursor .CodeMirror-cursor {
  width: auto;
  border: 0 !important;
  background: #7e7;
}
.cm-fat-cursor div.CodeMirror-cursors {
  z-index: 1;
}
.cm-fat-cursor-mark {
  background-color: rgba(20, 255, 20, 0.5);
  -webkit-animation: blink 1.06s steps(1) infinite;
  -moz-animation: blink 1.06s steps(1) infinite;
  animation: blink 1.06s steps(1) infinite;
}
.cm-animate-fat-cursor {
  width: auto;
  border: 0;
  -webkit-animation: blink 1.06s steps(1) infinite;
  -moz-animation: blink 1.06s steps(1) infinite;
  animation: blink 1.06s steps(1) infinite;
  background-color: #7e7;
}
@-moz-keyframes blink {
  0% {}
  50% { background-color: transparent; }
  100% {}
}
@-webkit-keyframes blink {
  0% {}
  50% { background-color: transparent; }
  100% {}
}
@keyframes blink {
  0% {}
  50% { background-color: transparent; }
  100% {}
}

/* Can style cursor different in overwrite (non-insert) mode */
.CodeMirror-overwrite .CodeMirror-cursor {}

.cm-tab { display: inline-block; text-decoration: inherit; }

.CodeMirror-rulers {
  position: absolute;
  left: 0; right: 0; top: -50px; bottom: 0;
  overflow: hidden;
}
.CodeMirror-ruler {
  border-left: 1px solid #ccc;
  top: 0; bottom: 0;
  position: absolute;
}

/* DEFAULT THEME */

.cm-s-default .cm-header {color: blue;}
.cm-s-default .cm-quote {color: #090;}
.cm-negative {color: #d44;}
.cm-positive {color: #292;}
.cm-header, .cm-strong {font-weight: bold;}
.cm-em {font-style: italic;}
.cm-link {text-decoration: underline;}
.cm-strikethrough {text-decoration: line-through;}

.cm-s-default .cm-keyword {color: #708;}
.cm-s-default .cm-atom {color: #219;}
.cm-s-default .cm-number {color: #164;}
.cm-s-default .cm-def {color: #00f;}
.cm-s-default .cm-variable,
.cm-s-default .cm-punctuation,
.cm-s-default .cm-property,
.cm-s-default .cm-operator {}
.cm-s-default .cm-variable-2 {color: #05a;}
.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}
.cm-s-default .cm-comment {color: #a50;}
.cm-s-default .cm-string {color: #a11;}
.cm-s-default .cm-string-2 {color: #f50;}
.cm-s-default .cm-meta {color: #555;}
.cm-s-default .cm-qualifier {color: #555;}
.cm-s-default .cm-builtin {color: #30a;}
.cm-s-default .cm-bracket {color: #997;}
.cm-s-default .cm-tag {color: #170;}
.cm-s-default .cm-attribute {color: #00c;}
.cm-s-default .cm-hr {color: #999;}
.cm-s-default .cm-link {color: #00c;}

.cm-s-default .cm-error {color: #f00;}
.cm-invalidchar {color: #f00;}

.CodeMirror-composing { border-bottom: 2px solid; }

/* Default styles for common addons */

div.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}
div.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}
.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }
.CodeMirror-activeline-background {background: #e8f2ff;}

/* STOP */

/* The rest of this file contains styles related to the mechanics of
    the editor. You probably shouldn't touch them. */

.CodeMirror {
  position: relative;
  overflow: hidden;
  background: white;
}

.CodeMirror-scroll {
  overflow: scroll !important; /* Things will break if this is overridden */
  /* 50px is the magic margin used to hide the element's real scrollbars */
  /* See overflow: hidden in .CodeMirror */
  margin-bottom: -50px; margin-right: -50px;
  padding-bottom: 50px;
  height: 100%;
  outline: none; /* Prevent dragging from highlighting the element */
  position: relative;
}
.CodeMirror-sizer {
  position: relative;
  border-right: 50px solid transparent;
}

/* The fake, visible scrollbars. Used to force redraw during scrolling
    before actual scrolling happens, thus preventing shaking and
    flickering artifacts. */
.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
  position: absolute;
  z-index: 6;
  display: none;
}
.CodeMirror-vscrollbar {
  right: 0; top: 0;
  overflow-x: hidden;
  overflow-y: scroll;
}
.CodeMirror-hscrollbar {
  bottom: 0; left: 0;
  overflow-y: hidden;
  overflow-x: scroll;
}
.CodeMirror-scrollbar-filler {
  right: 0; bottom: 0;
}
.CodeMirror-gutter-filler {
  left: 0; bottom: 0;
}

.CodeMirror-gutters {
  position: absolute; left: 0; top: 0;
  min-height: 100%;
  z-index: 3;
}
.CodeMirror-gutter {
  white-space: normal;
  height: 100%;
  display: inline-block;
  vertical-align: top;
  margin-bottom: -50px;
}
.CodeMirror-gutter-wrapper {
  position: absolute;
  z-index: 4;
  background: none !important;
  border: none !important;
}
.CodeMirror-gutter-background {
  position: absolute;
  top: 0; bottom: 0;
  z-index: 4;
}
.CodeMirror-gutter-elt {
  position: absolute;
  cursor: default;
  z-index: 4;
}
.CodeMirror-gutter-wrapper ::selection { background-color: transparent }
.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }

.CodeMirror-lines {
  cursor: text;
  min-height: 1px; /* prevents collapsing before first draw */
}
.CodeMirror pre.CodeMirror-line,
.CodeMirror pre.CodeMirror-line-like {
  /* Reset some styles that the rest of the page might have set */
  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;
  border-width: 0;
  background: transparent;
  font-family: inherit;
  font-size: inherit;
  margin: 0;
  white-space: pre;
  word-wrap: normal;
  line-height: inherit;
  color: inherit;
  z-index: 2;
  position: relative;
  overflow: visible;
  -webkit-tap-highlight-color: transparent;
  -webkit-font-variant-ligatures: contextual;
  font-variant-ligatures: contextual;
}
.CodeMirror-wrap pre.CodeMirror-line,
.CodeMirror-wrap pre.CodeMirror-line-like {
  word-wrap: break-word;
  white-space: pre-wrap;
  word-break: normal;
}

.CodeMirror-linebackground {
  position: absolute;
  left: 0; right: 0; top: 0; bottom: 0;
  z-index: 0;
}

.CodeMirror-linewidget {
  position: relative;
  z-index: 2;
  padding: 0.1px; /* Force widget margins to stay inside of the container */
}

.CodeMirror-widget {}

.CodeMirror-rtl pre { direction: rtl; }

.CodeMirror-code {
  outline: none;
}

/* Force content-box sizing for the elements where we expect it */
.CodeMirror-scroll,
.CodeMirror-sizer,
.CodeMirror-gutter,
.CodeMirror-gutters,
.CodeMirror-linenumber {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
}

.CodeMirror-measure {
  position: absolute;
  width: 100%;
  height: 0;
  overflow: hidden;
  visibility: hidden;
}

.CodeMirror-cursor {
  position: absolute;
  pointer-events: none;
}
.CodeMirror-measure pre { position: static; }

div.CodeMirror-cursors {
  visibility: hidden;
  position: relative;
  z-index: 3;
}
div.CodeMirror-dragcursors {
  visibility: visible;
}

.CodeMirror-focused div.CodeMirror-cursors {
  visibility: visible;
}

.CodeMirror-selected { background: #d9d9d9; }
.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }
.CodeMirror-crosshair { cursor: crosshair; }
.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }
.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }

.cm-searching {
  background-color: #ffa;
  background-color: rgba(255, 255, 0, .4);
}

/* Used to force a border model for a node */
.cm-force-border { padding-right: .1px; }

@media print {
  /* Hide the cursor when printing */
  .CodeMirror div.CodeMirror-cursors {
    visibility: hidden;
  }
}

/* See issue #2901 */
.cm-tab-wrap-hack:after { content: ''; }

/* Help users use markselection to safely style text background */
span.CodeMirror-selectedtext { background: none; }
</style>
`);
self.CodeMirror = Zd;
var aE = class extends HTMLElement {
  static get observedAttributes() {
    return ["src", "readonly", "mode", "theme"];
  }
  attributeChangedCallback(e, t, r) {
    this.__initialized && t !== r && (e === "readonly" ? this[e] = r !== null : this[e] = r);
  }
  get readonly() {
    return this.editor.getOption("readOnly");
  }
  set readonly(e) {
    this.editor.setOption("readOnly", e);
  }
  get mode() {
    return this.editor.getOption("mode");
  }
  set mode(e) {
    this.editor.setOption("mode", e);
  }
  get theme() {
    return this.editor.getOption("theme");
  }
  set theme(e) {
    this.editor.setOption("theme", e);
  }
  get src() {
    return this.getAttribute("src");
  }
  set src(e) {
    this.setAttribute("src", e), this.setSrc();
  }
  get value() {
    return this.editor.getValue();
  }
  set value(e) {
    this.setValue(e);
  }
  constructor() {
    super(), this.__initialized = !1, this.__element = null, this.editor = null;
  }
  async connectedCallback() {
    const e = document.createElement("template");
    e.innerHTML = aE.template(), this.appendChild(e.content.cloneNode(!0)), this.style.display = "block", this.__element = this.querySelector("textarea");
    const t = this.hasAttribute("mode") ? this.getAttribute("mode") : "null", r = this.hasAttribute("theme") ? this.getAttribute("theme") : "default";
    let n = this.getAttribute("readonly");
    n === "" ? n = !0 : n !== "nocursor" && (n = !1);
    let o = "";
    const s = this.querySelector("script");
    s && s.getAttribute("type") === "wc-content" && (o = aE.dedentText(s.innerHTML), o = o.replace(/&lt;(\/?script)(.*?)&gt;/g, "<$1$2>"));
    let a = Zd.defaults.viewportMargin;
    if (this.hasAttribute("viewport-margin")) {
      const l = this.getAttribute("viewport-margin").toLowerCase();
      a = l === "infinity" ? 1 / 0 : parseInt(l);
    }
    this.editor = Zd.fromTextArea(this.__element, {
      lineNumbers: !0,
      readOnly: n,
      mode: t,
      theme: r,
      viewportMargin: a
    }), this.hasAttribute("src") ? this.setSrc(this.getAttribute("src")) : (await new Promise((l) => setTimeout(l, 50)), this.value = o), this.__initialized = !0;
  }
  disconnectedCallback() {
    this.editor && this.editor.toTextArea(), this.editor = null, this.__initialized = !1;
  }
  async setSrc() {
    const e = this.getAttribute("src"), t = await this.fetchSrc(e);
    this.value = t;
  }
  async setValue(e) {
    this.editor.swapDoc(Zd.Doc(e, this.getAttribute("mode"))), this.editor.refresh();
  }
  async fetchSrc(e) {
    return (await fetch(e)).text();
  }
  static template() {
    return `
      <textarea style="display:inherit; width:inherit; height:inherit;"></textarea>
    `;
  }
  static dedentText(e) {
    const t = e.split(`
`);
    t[0] === "" && t.splice(0, 1);
    const r = t[0];
    let n = 0;
    const s = r[0] === "	" ? "	" : " ";
    for (; r[n] === s; )
      n += 1;
    const a = [];
    for (const l of t) {
      let u = l;
      for (let f = 0; f < n && u[0] === s; f++)
        u = u.substring(1);
      a.push(u);
    }
    return a[a.length - 1] === "" && a.splice(a.length - 1, 1), a.join(`
`);
  }
};
customElements.define("wc-codemirror", aE);
function xI(e, t, r, n) {
  var o, s = !1, a = 0;
  function l() {
    o && clearTimeout(o);
  }
  function u() {
    l(), s = !0;
  }
  typeof t != "boolean" && (n = r, r = t, t = void 0);
  function f() {
    for (var c = arguments.length, d = new Array(c), h = 0; h < c; h++)
      d[h] = arguments[h];
    var p = this, v = Date.now() - a;
    if (s)
      return;
    function y() {
      a = Date.now(), r.apply(p, d);
    }
    function w() {
      o = void 0;
    }
    n && !o && y(), l(), n === void 0 && v > e ? y() : t !== !0 && (o = setTimeout(n ? w : y, n === void 0 ? e - v : e));
  }
  return f.cancel = u, f;
}
function khe(e, t, r) {
  return r === void 0 ? xI(e, t, !1) : xI(e, r, t !== !1);
}
const Oo = Symbol("Initial value"), R0 = Symbol("Editor dirty"), Vi = Symbol("ParseHandler");
function Che(e) {
  let n = 0;
  return new Promise((o, s) => {
    const a = setInterval(() => {
      e() && (clearInterval(a), o()), n += 1, n === 100 && (clearInterval(a), s(new Error("Value did not become truthy in time")));
    }, 10);
  });
}
class Ihe extends Af {
  static get styles() {
    return Vfe`
      :host {
        display: block;
        text-align: left;
      }

      [part='error'] {
        text-decoration: underline;
        text-decoration-color: red;
        text-decoration-style: wavy;
      }

      wc-codemirror,
      #wrapper {
        width: 100%;
        height: 100%;
      }

      :host(:not([ready])) #wrapper {
        display: none;
      }
    `;
  }
  static get properties() {
    return {
      value: { type: String, noAccessor: !0 },
      readonly: { type: Boolean, reflect: !0 },
      prefixes: { type: String, attribute: "prefixes" },
      isParsing: { type: Boolean, attribute: "is-parsing", reflect: !0 },
      autoParse: { type: Boolean, attribute: "auto-parse" },
      parseDelay: { type: Number },
      customPrefixes: { type: Object }
    };
  }
  constructor() {
    super(), this.parseDelay = 250, this[Oo] = "", this.customPrefixes = {}, this.__style = document.createElement("link"), this.__style.rel = "stylesheet", this.__style.href = "https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.61.1/codemirror.min.css";
  }
  connectedCallback() {
    const t = new Promise((r) => {
      this.__style.onload = r;
    });
    super.connectedCallback(), this.ready = Promise.resolve().then(async () => {
      await t, await this.requestUpdate(), await Che(
        () => this.codeMirror && this.codeMirror.editor && this.codeMirror.__initialized
      ), await this._initializeCodeMirror(), [...this.renderRoot.querySelectorAll("[class^=CodeMirror]")].forEach(
        (r) => {
          r.classList.forEach((n) => {
            n.match(/^CodeMirror/) && r.setAttribute("part", n);
          });
        }
      ), this.setAttribute("ready", ""), this.codeMirror.editor.refresh(), this[Oo] && this.codeMirror.editor.setValue(this[Oo]);
    });
  }
  get _prefixes() {
    return async () => {
      const t = await Promise.resolve().then(() => $E);
      return (this.prefixes || "").split(",").map((n) => n.trim()).reduce((n, o) => o in t ? { ...n, [o]: t[o]().value } : n, {});
    };
  }
  /**
   * The underlying `<wc-codemirror>` element
   */
  get codeMirror() {
    return this.renderRoot.querySelector("wc-codemirror");
  }
  /**
   * Gets the text contents of the underlying editor
   * @returns {string}
   */
  get value() {
    return this.hasAttribute("ready") ? this.codeMirror.editor.getValue() : this[Oo] || "";
  }
  set value(t) {
    typeof t == "string" && (this.hasAttribute("ready") ? this.value !== t && (this.codeMirror.editor.setValue(t), this[Vi]()) : this[Oo] = t);
  }
  async firstUpdated(t) {
    super.firstUpdated(t), this[Oo] && (await this.ready, this.codeMirror.editor.setValue(this[Oo]), this[Vi](), this[Oo] = void 0);
  }
  updated(t) {
    super.updated(t), (t.has("autoParse") || t.has("parseDelay")) && this.__setParseHandler();
  }
  render() {
    return Jfe`${this.__style}
      <div id="wrapper">
        <wc-codemirror mode="${this.format}" ?readonly="${this.readonly}">
        </wc-codemirror>
      </div>`;
  }
  async parse() {
    if (!this.isParsing) {
      this.__errorMarker && this.__errorMarker.clear(), this.isParsing = !0;
      try {
        await this._parse();
      } catch (t) {
        typeof this._errorLine == "function" && await this.__highlightError(this._errorLine(t)), this.dispatchEvent(
          new CustomEvent("parsing-failed", {
            detail: { error: t }
          })
        );
      } finally {
        this.isParsing = !1;
      }
    }
  }
  async _initializeCodeMirror() {
    this.codeMirror.editor.setSize("100%", "100%"), this.__setParseHandler(), this.codeMirror.editor.on("change", () => {
      this[R0] = !0;
    });
  }
  __setParseHandler() {
    this.codeMirror.editor && (this[Vi] && (this.codeMirror.editor.off("blur", this[Vi]), this.codeMirror.editor.off("change", this[Vi])), this.autoParse ? (this[Vi] = khe(
      this.parseDelay,
      this.__beginParse.bind(this)
    ), this.codeMirror.editor.on("change", this[Vi])) : (this[Vi] = this.__beginParse.bind(this), this.codeMirror.editor.on("blur", this[Vi])));
  }
  async __beginParse() {
    this[R0] && await this.parse(), this[R0] = !1;
  }
  async __highlightError(t) {
    if (!this.ready)
      return;
    let r = { line: 0, ch: 0 }, n = { line: 0, ch: Number.MAX_SAFE_INTEGER };
    t && t.from && (r = t.from, this.codeMirror.editor.scrollIntoView(r)), t && t.to && (n = t.to);
    const o = t ? t.message : "";
    await this.ready, this.__errorMarker = this.codeMirror.editor.getDoc().markText(r, n, {
      attributes: { part: "error", title: o }
    });
  }
  async _combinePrefixes() {
    return Object.entries(this.customPrefixes).reduce((t, [r, n]) => !n || !r || typeof n != "string" || typeof r != "string" ? t : {
      ...t,
      [r]: n
    }, await this._prefixes());
  }
}
window.CodeMirror.defineMode("javascript", function(e, t) {
  var r = e.indentUnit, n = t.statementIndent, o = t.jsonld, s = t.json || o, a = t.typescript, l = t.wordCharacters || /[\w$\xa1-\uffff]/, u = function() {
    function P(Pr) {
      return { type: Pr, style: "keyword" };
    }
    var Q = P("keyword a"), _e = P("keyword b"), Ae = P("keyword c"), Qe = P("keyword d"), pt = P("operator"), $t = { type: "atom", style: "atom" };
    return {
      if: P("if"),
      while: Q,
      with: Q,
      else: _e,
      do: _e,
      try: _e,
      finally: _e,
      return: Qe,
      break: Qe,
      continue: Qe,
      new: P("new"),
      delete: Ae,
      void: Ae,
      throw: Ae,
      debugger: P("debugger"),
      var: P("var"),
      const: P("var"),
      let: P("var"),
      function: P("function"),
      catch: P("catch"),
      for: P("for"),
      switch: P("switch"),
      case: P("case"),
      default: P("default"),
      in: pt,
      typeof: pt,
      instanceof: pt,
      true: $t,
      false: $t,
      null: $t,
      undefined: $t,
      NaN: $t,
      Infinity: $t,
      this: P("this"),
      class: P("class"),
      super: P("atom"),
      yield: Ae,
      export: P("export"),
      import: P("import"),
      extends: Ae,
      await: Ae
    };
  }(), f = /[+\-*&%=<>!?|~^@]/, c = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
  function d(P) {
    for (var Q = !1, _e, Ae = !1; (_e = P.next()) != null; ) {
      if (!Q) {
        if (_e == "/" && !Ae)
          return;
        _e == "[" ? Ae = !0 : Ae && _e == "]" && (Ae = !1);
      }
      Q = !Q && _e == "\\";
    }
  }
  var h, p;
  function v(P, Q, _e) {
    return h = P, p = _e, Q;
  }
  function y(P, Q) {
    var _e = P.next();
    if (_e == '"' || _e == "'")
      return Q.tokenize = w(_e), Q.tokenize(P, Q);
    if (_e == "." && P.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/))
      return v("number", "number");
    if (_e == "." && P.match(".."))
      return v("spread", "meta");
    if (/[\[\]{}\(\),;\:\.]/.test(_e))
      return v(_e);
    if (_e == "=" && P.eat(">"))
      return v("=>", "operator");
    if (_e == "0" && P.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/))
      return v("number", "number");
    if (/\d/.test(_e))
      return P.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/), v("number", "number");
    if (_e == "/")
      return P.eat("*") ? (Q.tokenize = S, S(P, Q)) : P.eat("/") ? (P.skipToEnd(), v("comment", "comment")) : $A(P, Q, 1) ? (d(P), P.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/), v("regexp", "string-2")) : (P.eat("="), v("operator", "operator", P.current()));
    if (_e == "`")
      return Q.tokenize = x, x(P, Q);
    if (_e == "#")
      return P.skipToEnd(), v("error", "error");
    if (_e == "<" && P.match("!--") || _e == "-" && P.match("->"))
      return P.skipToEnd(), v("comment", "comment");
    if (f.test(_e))
      return (_e != ">" || !Q.lexical || Q.lexical.type != ">") && (P.eat("=") ? (_e == "!" || _e == "=") && P.eat("=") : /[<>*+\-]/.test(_e) && (P.eat(_e), _e == ">" && P.eat(_e))), v("operator", "operator", P.current());
    if (l.test(_e)) {
      P.eatWhile(l);
      var Ae = P.current();
      if (Q.lastType != ".") {
        if (u.propertyIsEnumerable(Ae)) {
          var Qe = u[Ae];
          return v(Qe.type, Qe.style, Ae);
        }
        if (Ae == "async" && P.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, !1))
          return v("async", "keyword", Ae);
      }
      return v("variable", "variable", Ae);
    }
  }
  function w(P) {
    return function(Q, _e) {
      var Ae = !1, Qe;
      if (o && Q.peek() == "@" && Q.match(c))
        return _e.tokenize = y, v("jsonld-keyword", "meta");
      for (; (Qe = Q.next()) != null && !(Qe == P && !Ae); )
        Ae = !Ae && Qe == "\\";
      return Ae || (_e.tokenize = y), v("string", "string");
    };
  }
  function S(P, Q) {
    for (var _e = !1, Ae; Ae = P.next(); ) {
      if (Ae == "/" && _e) {
        Q.tokenize = y;
        break;
      }
      _e = Ae == "*";
    }
    return v("comment", "comment");
  }
  function x(P, Q) {
    for (var _e = !1, Ae; (Ae = P.next()) != null; ) {
      if (!_e && (Ae == "`" || Ae == "$" && P.eat("{"))) {
        Q.tokenize = y;
        break;
      }
      _e = !_e && Ae == "\\";
    }
    return v("quasi", "string-2", P.current());
  }
  var E = "([{}])";
  function N(P, Q) {
    Q.fatArrowAt && (Q.fatArrowAt = null);
    var _e = P.string.indexOf("=>", P.start);
    if (!(_e < 0)) {
      if (a) {
        var Ae = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(
          P.string.slice(P.start, _e)
        );
        Ae && (_e = Ae.index);
      }
      for (var Qe = 0, pt = !1, $t = _e - 1; $t >= 0; --$t) {
        var Pr = P.string.charAt($t), ai = E.indexOf(Pr);
        if (ai >= 0 && ai < 3) {
          if (!Qe) {
            ++$t;
            break;
          }
          if (--Qe == 0) {
            Pr == "(" && (pt = !0);
            break;
          }
        } else if (ai >= 3 && ai < 6)
          ++Qe;
        else if (l.test(Pr))
          pt = !0;
        else if (/["'\/`]/.test(Pr))
          for (; ; --$t) {
            if ($t == 0)
              return;
            var hW = P.string.charAt($t - 1);
            if (hW == Pr && P.string.charAt($t - 2) != "\\") {
              $t--;
              break;
            }
          }
        else if (pt && !Qe) {
          ++$t;
          break;
        }
      }
      pt && !Qe && (Q.fatArrowAt = $t);
    }
  }
  var C = {
    atom: !0,
    number: !0,
    variable: !0,
    string: !0,
    regexp: !0,
    this: !0,
    "jsonld-keyword": !0
  };
  function j(P, Q, _e, Ae, Qe, pt) {
    this.indented = P, this.column = Q, this.type = _e, this.prev = Qe, this.info = pt, Ae != null && (this.align = Ae);
  }
  function J(P, Q) {
    for (var _e = P.localVars; _e; _e = _e.next)
      if (_e.name == Q)
        return !0;
    for (var Ae = P.context; Ae; Ae = Ae.prev)
      for (var _e = Ae.vars; _e; _e = _e.next)
        if (_e.name == Q)
          return !0;
  }
  function z(P, Q, _e, Ae, Qe) {
    var pt = P.cc;
    for ($.state = P, $.stream = Qe, $.marked = null, $.cc = pt, $.style = Q, P.lexical.hasOwnProperty("align") || (P.lexical.align = !0); ; ) {
      var $t = pt.length ? pt.pop() : s ? ee : Ce;
      if ($t(_e, Ae)) {
        for (; pt.length && pt[pt.length - 1].lex; )
          pt.pop()();
        return $.marked ? $.marked : _e == "variable" && J(P, Ae) ? "variable-2" : Q;
      }
    }
  }
  var $ = { state: null, column: null, marked: null, cc: null };
  function G() {
    for (var P = arguments.length - 1; P >= 0; P--)
      $.cc.push(arguments[P]);
  }
  function I() {
    return G.apply(null, arguments), !0;
  }
  function W(P, Q) {
    for (var _e = Q; _e; _e = _e.next)
      if (_e.name == P)
        return !0;
    return !1;
  }
  function k(P) {
    var Q = $.state;
    if ($.marked = "def", Q.context) {
      if (Q.lexical.info == "var" && Q.context && Q.context.block) {
        var _e = U(P, Q.context);
        if (_e != null) {
          Q.context = _e;
          return;
        }
      } else if (!W(P, Q.localVars)) {
        Q.localVars = new re(P, Q.localVars);
        return;
      }
    }
    t.globalVars && !W(P, Q.globalVars) && (Q.globalVars = new re(P, Q.globalVars));
  }
  function U(P, Q) {
    if (Q)
      if (Q.block) {
        var _e = U(P, Q.prev);
        return _e ? _e == Q.prev ? Q : new Y(_e, Q.vars, !0) : null;
      } else
        return W(P, Q.vars) ? Q : new Y(Q.prev, new re(P, Q.vars), !1);
    else
      return null;
  }
  function Z(P) {
    return P == "public" || P == "private" || P == "protected" || P == "abstract" || P == "readonly";
  }
  function Y(P, Q, _e) {
    this.prev = P, this.vars = Q, this.block = _e;
  }
  function re(P, Q) {
    this.name = P, this.next = Q;
  }
  var ae = new re("this", new re("arguments", null));
  function ce() {
    $.state.context = new Y($.state.context, $.state.localVars, !1), $.state.localVars = ae;
  }
  function pe() {
    $.state.context = new Y($.state.context, $.state.localVars, !0), $.state.localVars = null;
  }
  function le() {
    $.state.localVars = $.state.context.vars, $.state.context = $.state.context.prev;
  }
  le.lex = !0;
  function ye(P, Q) {
    var _e = function() {
      var Ae = $.state, Qe = Ae.indented;
      if (Ae.lexical.type == "stat")
        Qe = Ae.lexical.indented;
      else
        for (var pt = Ae.lexical; pt && pt.type == ")" && pt.align; pt = pt.prev)
          Qe = pt.indented;
      Ae.lexical = new j(
        Qe,
        $.stream.column(),
        P,
        null,
        Ae.lexical,
        Q
      );
    };
    return _e.lex = !0, _e;
  }
  function H() {
    var P = $.state;
    P.lexical.prev && (P.lexical.type == ")" && (P.indented = P.lexical.indented), P.lexical = P.lexical.prev);
  }
  H.lex = !0;
  function ge(P) {
    function Q(_e) {
      return _e == P ? I() : P == ";" || _e == "}" || _e == ")" || _e == "]" ? G() : I(Q);
    }
    return Q;
  }
  function Ce(P, Q) {
    return P == "var" ? I(ye("vardef", Q), Lr, ge(";"), H) : P == "keyword a" ? I(ye("form"), Te, Ce, H) : P == "keyword b" ? I(ye("form"), Ce, H) : P == "keyword d" ? $.stream.match(/^\s*$/, !1) ? I() : I(ye("stat"), K, ge(";"), H) : P == "debugger" ? I(ge(";")) : P == "{" ? I(ye("}"), pe, R, H, le) : P == ";" ? I() : P == "if" ? ($.state.lexical.info == "else" && $.state.cc[$.state.cc.length - 1] == H && $.state.cc.pop()(), I(ye("form"), Te, Ce, H, g)) : P == "function" ? I(X) : P == "for" ? I(ye("form"), m, Ce, H) : P == "class" || a && Q == "interface" ? ($.marked = "keyword", I(
      ye("form", P == "class" ? P : Q),
      Kr,
      H
    )) : P == "variable" ? a && Q == "declare" ? ($.marked = "keyword", I(Ce)) : a && (Q == "module" || Q == "enum" || Q == "type") && $.stream.match(/^\s*\w/, !1) ? ($.marked = "keyword", Q == "enum" ? I(TA) : Q == "type" ? I(Ue, ge("operator"), he, ge(";")) : I(
      ye("form"),
      Tt,
      ge("{"),
      ye("}"),
      R,
      H,
      H
    )) : a && Q == "namespace" ? ($.marked = "keyword", I(ye("form"), ee, Ce, H)) : a && Q == "abstract" ? ($.marked = "keyword", I(Ce)) : I(ye("stat"), ve) : P == "switch" ? I(
      ye("form"),
      Te,
      ge("{"),
      ye("}", "switch"),
      pe,
      R,
      H,
      H,
      le
    ) : P == "case" ? I(ee, ge(":")) : P == "default" ? I(ge(":")) : P == "catch" ? I(
      ye("form"),
      ce,
      ue,
      Ce,
      H,
      le
    ) : P == "export" ? I(ye("stat"), cr, H) : P == "import" ? I(ye("stat"), dr, H) : P == "async" ? I(Ce) : Q == "@" ? I(ee, Ce) : G(ye("stat"), ee, ge(";"), H);
  }
  function ue(P) {
    if (P == "(")
      return I(Xt, ge(")"));
  }
  function ee(P, Q) {
    return Pe(P, Q, !1);
  }
  function be(P, Q) {
    return Pe(P, Q, !0);
  }
  function Te(P) {
    return P != "(" ? G() : I(ye(")"), ee, ge(")"), H);
  }
  function Pe(P, Q, _e) {
    if ($.state.fatArrowAt == $.stream.start) {
      var Ae = _e ? O : L;
      if (P == "(")
        return I(
          ce,
          ye(")"),
          Me(Xt, ")"),
          H,
          ge("=>"),
          Ae,
          le
        );
      if (P == "variable")
        return G(ce, Tt, ge("=>"), Ae, le);
    }
    var Qe = _e ? b : V;
    return C.hasOwnProperty(P) ? I(Qe) : P == "function" ? I(X, Qe) : P == "class" || a && Q == "interface" ? ($.marked = "keyword", I(ye("form"), ht, H)) : P == "keyword c" || P == "async" ? I(_e ? be : ee) : P == "(" ? I(ye(")"), K, ge(")"), H, Qe) : P == "operator" || P == "spread" ? I(_e ? be : ee) : P == "[" ? I(ye("]"), fW, H, Qe) : P == "{" ? M(me, "}", null, Qe) : P == "quasi" ? G(_, Qe) : P == "new" ? I(ie(_e)) : P == "import" ? I(ee) : I();
  }
  function K(P) {
    return P.match(/[;\}\)\],]/) ? G() : G(ee);
  }
  function V(P, Q) {
    return P == "," ? I(ee) : b(P, Q, !1);
  }
  function b(P, Q, _e) {
    var Ae = _e == !1 ? V : b, Qe = _e == !1 ? ee : be;
    if (P == "=>")
      return I(
        ce,
        _e ? O : L,
        le
      );
    if (P == "operator")
      return /\+\+|--/.test(Q) || a && Q == "!" ? I(Ae) : a && Q == "<" && $.stream.match(/^([^>]|<.*?>)*>\s*\(/, !1) ? I(ye(">"), Me(he, ">"), H, Ae) : Q == "?" ? I(ee, ge(":"), Qe) : I(Qe);
    if (P == "quasi")
      return G(_, Ae);
    if (P != ";") {
      if (P == "(")
        return M(be, ")", "call", Ae);
      if (P == ".")
        return I(B, Ae);
      if (P == "[")
        return I(ye("]"), K, ge("]"), H, Ae);
      if (a && Q == "as")
        return $.marked = "keyword", I(he, Ae);
      if (P == "regexp")
        return $.state.lastType = $.marked = "operator", $.stream.backUp($.stream.pos - $.stream.start - 1), I(Qe);
    }
  }
  function _(P, Q) {
    return P != "quasi" ? G() : Q.slice(Q.length - 2) != "${" ? I(_) : I(ee, T);
  }
  function T(P) {
    if (P == "}")
      return $.marked = "string-2", $.state.tokenize = x, I(_);
  }
  function L(P) {
    return N($.stream, $.state), G(P == "{" ? Ce : ee);
  }
  function O(P) {
    return N($.stream, $.state), G(P == "{" ? Ce : be);
  }
  function ie(P) {
    return function(Q) {
      return Q == "." ? I(P ? se : fe) : Q == "variable" && a ? I(
        et,
        P ? b : V
      ) : G(P ? be : ee);
    };
  }
  function fe(P, Q) {
    if (Q == "target")
      return $.marked = "keyword", I(V);
  }
  function se(P, Q) {
    if (Q == "target")
      return $.marked = "keyword", I(b);
  }
  function ve(P) {
    return P == ":" ? I(H, Ce) : G(V, ge(";"), H);
  }
  function B(P) {
    if (P == "variable")
      return $.marked = "property", I();
  }
  function me(P, Q) {
    if (P == "async")
      return $.marked = "property", I(me);
    if (P == "variable" || $.style == "keyword") {
      if ($.marked = "property", Q == "get" || Q == "set")
        return I(ke);
      var _e;
      return a && $.state.fatArrowAt == $.stream.start && (_e = $.stream.match(/^\s*:\s*/, !1)) && ($.state.fatArrowAt = $.stream.pos + _e[0].length), I(Ie);
    } else {
      if (P == "number" || P == "string")
        return $.marked = o ? "property" : $.style + " property", I(Ie);
      if (P == "jsonld-keyword")
        return I(Ie);
      if (a && Z(Q))
        return $.marked = "keyword", I(me);
      if (P == "[")
        return I(ee, A, ge("]"), Ie);
      if (P == "spread")
        return I(be, Ie);
      if (Q == "*")
        return $.marked = "keyword", I(me);
      if (P == ":")
        return G(Ie);
    }
  }
  function ke(P) {
    return P != "variable" ? G(Ie) : ($.marked = "property", I(X));
  }
  function Ie(P) {
    if (P == ":")
      return I(be);
    if (P == "(")
      return G(X);
  }
  function Me(P, Q, _e) {
    function Ae(Qe, pt) {
      if (_e ? _e.indexOf(Qe) > -1 : Qe == ",") {
        var $t = $.state.lexical;
        return $t.info == "call" && ($t.pos = ($t.pos || 0) + 1), I(function(Pr, ai) {
          return Pr == Q || ai == Q ? G() : G(P);
        }, Ae);
      }
      return Qe == Q || pt == Q ? I() : _e && _e.indexOf(";") > -1 ? G(P) : I(ge(Q));
    }
    return function(Qe, pt) {
      return Qe == Q || pt == Q ? I() : G(P, Ae);
    };
  }
  function M(P, Q, _e) {
    for (var Ae = 3; Ae < arguments.length; Ae++)
      $.cc.push(arguments[Ae]);
    return I(ye(Q, _e), Me(P, Q), H);
  }
  function R(P) {
    return P == "}" ? I() : G(Ce, R);
  }
  function A(P, Q) {
    if (a) {
      if (P == ":")
        return I(he);
      if (Q == "?")
        return I(A);
    }
  }
  function q(P, Q) {
    if (a && (P == ":" || Q == "in"))
      return I(he);
  }
  function ne(P) {
    if (a && P == ":")
      return $.stream.match(/^\s*\w+\s+is\b/, !1) ? I(ee, de, he) : I(he);
  }
  function de(P, Q) {
    if (Q == "is")
      return $.marked = "keyword", I();
  }
  function he(P, Q) {
    if (Q == "keyof" || Q == "typeof" || Q == "infer")
      return $.marked = "keyword", I(Q == "typeof" ? be : he);
    if (P == "variable" || Q == "void")
      return $.marked = "type", I(Ke);
    if (Q == "|" || Q == "&")
      return I(he);
    if (P == "string" || P == "number" || P == "atom")
      return I(Ke);
    if (P == "[")
      return I(
        ye("]"),
        Me(he, "]", ","),
        H,
        Ke
      );
    if (P == "{")
      return I(
        ye("}"),
        Me(ot, "}", ",;"),
        H,
        Ke
      );
    if (P == "(")
      return I(Me(ze, ")"), Fe, Ke);
    if (P == "<")
      return I(Me(he, ">"), he);
  }
  function Fe(P) {
    if (P == "=>")
      return I(he);
  }
  function ot(P, Q) {
    if (P == "variable" || $.style == "keyword")
      return $.marked = "property", I(ot);
    if (Q == "?" || P == "number" || P == "string")
      return I(ot);
    if (P == ":")
      return I(he);
    if (P == "[")
      return I(ge("variable"), q, ge("]"), ot);
    if (P == "(")
      return G(Le, ot);
  }
  function ze(P, Q) {
    return P == "variable" && $.stream.match(/^\s*[?:]/, !1) || Q == "?" ? I(ze) : P == ":" ? I(he) : P == "spread" ? I(ze) : G(he);
  }
  function Ke(P, Q) {
    if (Q == "<")
      return I(ye(">"), Me(he, ">"), H, Ke);
    if (Q == "|" || P == "." || Q == "&")
      return I(he);
    if (P == "[")
      return I(he, ge("]"), Ke);
    if (Q == "extends" || Q == "implements")
      return $.marked = "keyword", I(he);
    if (Q == "?")
      return I(he, ge(":"), he);
  }
  function et(P, Q) {
    if (Q == "<")
      return I(ye(">"), Me(he, ">"), H, Ke);
  }
  function Rr() {
    return G(he, Wi);
  }
  function Wi(P, Q) {
    if (Q == "=")
      return I(he);
  }
  function Lr(P, Q) {
    return Q == "enum" ? ($.marked = "keyword", I(TA)) : G(Tt, A, Mt, ln);
  }
  function Tt(P, Q) {
    if (a && Z(Q))
      return $.marked = "keyword", I(Tt);
    if (P == "variable")
      return k(Q), I();
    if (P == "spread")
      return I(Tt);
    if (P == "[")
      return M(Ui, "]");
    if (P == "{")
      return M(si, "}");
  }
  function si(P, Q) {
    return P == "variable" && !$.stream.match(/^\s*:/, !1) ? (k(Q), I(Mt)) : (P == "variable" && ($.marked = "property"), P == "spread" ? I(Tt) : P == "}" ? G() : P == "[" ? I(ee, ge("]"), ge(":"), si) : I(ge(":"), Tt, Mt));
  }
  function Ui() {
    return G(Tt, Mt);
  }
  function Mt(P, Q) {
    if (Q == "=")
      return I(be);
  }
  function ln(P) {
    if (P == ",")
      return I(Lr);
  }
  function g(P, Q) {
    if (P == "keyword b" && Q == "else")
      return I(ye("form", "else"), Ce, H);
  }
  function m(P, Q) {
    if (Q == "await")
      return I(m);
    if (P == "(")
      return I(ye(")"), F, H);
  }
  function F(P) {
    return P == "var" ? I(Lr, D) : P == "variable" ? I(D) : G(D);
  }
  function D(P, Q) {
    return P == ")" ? I() : P == ";" ? I(D) : Q == "in" || Q == "of" ? ($.marked = "keyword", I(ee, D)) : G(ee, D);
  }
  function X(P, Q) {
    if (Q == "*")
      return $.marked = "keyword", I(X);
    if (P == "variable")
      return k(Q), I(X);
    if (P == "(")
      return I(
        ce,
        ye(")"),
        Me(Xt, ")"),
        H,
        ne,
        Ce,
        le
      );
    if (a && Q == "<")
      return I(ye(">"), Me(Rr, ">"), H, X);
  }
  function Le(P, Q) {
    if (Q == "*")
      return $.marked = "keyword", I(Le);
    if (P == "variable")
      return k(Q), I(Le);
    if (P == "(")
      return I(
        ce,
        ye(")"),
        Me(Xt, ")"),
        H,
        ne,
        le
      );
    if (a && Q == "<")
      return I(ye(">"), Me(Rr, ">"), H, Le);
  }
  function Ue(P, Q) {
    if (P == "keyword" || P == "variable")
      return $.marked = "type", I(Ue);
    if (Q == "<")
      return I(ye(">"), Me(Rr, ">"), H);
  }
  function Xt(P, Q) {
    return Q == "@" && I(ee, Xt), P == "spread" ? I(Xt) : a && Z(Q) ? ($.marked = "keyword", I(Xt)) : a && P == "this" ? I(A, Mt) : G(Tt, A, Mt);
  }
  function ht(P, Q) {
    return P == "variable" ? Kr(P, Q) : yn(P, Q);
  }
  function Kr(P, Q) {
    if (P == "variable")
      return k(Q), I(yn);
  }
  function yn(P, Q) {
    if (Q == "<")
      return I(
        ye(">"),
        Me(Rr, ">"),
        H,
        yn
      );
    if (Q == "extends" || Q == "implements" || a && P == ",")
      return Q == "implements" && ($.marked = "keyword"), I(a ? he : ee, yn);
    if (P == "{")
      return I(ye("}"), Wt, H);
  }
  function Wt(P, Q) {
    if (P == "async" || P == "variable" && (Q == "static" || Q == "get" || Q == "set" || a && Z(Q)) && $.stream.match(/^\s+[\w$\xa1-\uffff]/, !1))
      return $.marked = "keyword", I(Wt);
    if (P == "variable" || $.style == "keyword")
      return $.marked = "property", I(a ? Ar : X, Wt);
    if (P == "number" || P == "string")
      return I(a ? Ar : X, Wt);
    if (P == "[")
      return I(
        ee,
        A,
        ge("]"),
        a ? Ar : X,
        Wt
      );
    if (Q == "*")
      return $.marked = "keyword", I(Wt);
    if (a && P == "(")
      return G(Le, Wt);
    if (P == ";" || P == ",")
      return I(Wt);
    if (P == "}")
      return I();
    if (Q == "@")
      return I(ee, Wt);
  }
  function Ar(P, Q) {
    if (Q == "?")
      return I(Ar);
    if (P == ":")
      return I(he, Mt);
    if (Q == "=")
      return I(be);
    var _e = $.state.lexical.prev, Ae = _e && _e.info == "interface";
    return G(Ae ? Le : X);
  }
  function cr(P, Q) {
    return Q == "*" ? ($.marked = "keyword", I(hb, ge(";"))) : Q == "default" ? ($.marked = "keyword", I(ee, ge(";"))) : P == "{" ? I(Me(or, "}"), hb, ge(";")) : G(Ce);
  }
  function or(P, Q) {
    if (Q == "as")
      return $.marked = "keyword", I(ge("variable"));
    if (P == "variable")
      return G(be, or);
  }
  function dr(P) {
    return P == "string" ? I() : P == "(" ? G(ee) : G(Et, ct, hb);
  }
  function Et(P, Q) {
    return P == "{" ? M(Et, "}") : (P == "variable" && k(Q), Q == "*" && ($.marked = "keyword"), I(nt));
  }
  function ct(P) {
    if (P == ",")
      return I(Et, ct);
  }
  function nt(P, Q) {
    if (Q == "as")
      return $.marked = "keyword", I(Et);
  }
  function hb(P, Q) {
    if (Q == "from")
      return $.marked = "keyword", I(ee);
  }
  function fW(P) {
    return P == "]" ? I() : G(Me(be, "]"));
  }
  function TA() {
    return G(
      ye("form"),
      Tt,
      ge("{"),
      ye("}"),
      Me(cW, "}"),
      H,
      H
    );
  }
  function cW() {
    return G(Tt, Mt);
  }
  function dW(P, Q) {
    return P.lastType == "operator" || P.lastType == "," || f.test(Q.charAt(0)) || /[,.]/.test(Q.charAt(0));
  }
  function $A(P, Q, _e) {
    return Q.tokenize == y && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(
      Q.lastType
    ) || Q.lastType == "quasi" && /\{\s*$/.test(P.string.slice(0, P.pos - (_e || 0)));
  }
  return {
    startState: function(P) {
      var Q = {
        tokenize: y,
        lastType: "sof",
        cc: [],
        lexical: new j(
          (P || 0) - r,
          0,
          "block",
          !1
        ),
        localVars: t.localVars,
        context: t.localVars && new Y(null, null, !1),
        indented: P || 0
      };
      return t.globalVars && typeof t.globalVars == "object" && (Q.globalVars = t.globalVars), Q;
    },
    token: function(P, Q) {
      if (P.sol() && (Q.lexical.hasOwnProperty("align") || (Q.lexical.align = !1), Q.indented = P.indentation(), N(P, Q)), Q.tokenize != S && P.eatSpace())
        return null;
      var _e = Q.tokenize(P, Q);
      return h == "comment" ? _e : (Q.lastType = h == "operator" && (p == "++" || p == "--") ? "incdec" : h, z(Q, _e, h, p, P));
    },
    indent: function(P, Q) {
      if (P.tokenize == S)
        return CodeMirror.Pass;
      if (P.tokenize != y)
        return 0;
      var _e = Q && Q.charAt(0), Ae = P.lexical, Qe;
      if (!/^\s*else\b/.test(Q))
        for (var pt = P.cc.length - 1; pt >= 0; --pt) {
          var $t = P.cc[pt];
          if ($t == H)
            Ae = Ae.prev;
          else if ($t != g)
            break;
        }
      for (; (Ae.type == "stat" || Ae.type == "form") && (_e == "}" || (Qe = P.cc[P.cc.length - 1]) && (Qe == V || Qe == b) && !/^[,\.=+\-*:?[\(]/.test(Q)); )
        Ae = Ae.prev;
      n && Ae.type == ")" && Ae.prev.type == "stat" && (Ae = Ae.prev);
      var Pr = Ae.type, ai = _e == Pr;
      return Pr == "vardef" ? Ae.indented + (P.lastType == "operator" || P.lastType == "," ? Ae.info.length + 1 : 0) : Pr == "form" && _e == "{" ? Ae.indented : Pr == "form" ? Ae.indented + r : Pr == "stat" ? Ae.indented + (dW(P, Q) ? n || r : 0) : Ae.info == "switch" && !ai && t.doubleIndentSwitch != !1 ? Ae.indented + (/^(?:case|default)\b/.test(Q) ? r : 2 * r) : Ae.align ? Ae.column + (ai ? 0 : 1) : Ae.indented + (ai ? 0 : r);
    },
    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
    blockCommentStart: s ? null : "/*",
    blockCommentEnd: s ? null : "*/",
    blockCommentContinue: s ? null : " * ",
    lineComment: s ? null : "//",
    fold: "brace",
    closeBrackets: "()[]{}''\"\"``",
    helperType: s ? "json" : "javascript",
    jsonldMode: o,
    jsonMode: s,
    expressionAllowed: $A,
    skipExpression: function(P) {
      var Q = P.cc[P.cc.length - 1];
      (Q == ee || Q == be) && P.cc.pop();
    }
  };
});
CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);
CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/x-javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", { name: "javascript", json: !0 });
CodeMirror.defineMIME("application/x-json", { name: "javascript", json: !0 });
CodeMirror.defineMIME("application/ld+json", {
  name: "javascript",
  jsonld: !0
});
CodeMirror.defineMIME("text/typescript", {
  name: "javascript",
  typescript: !0
});
CodeMirror.defineMIME("application/typescript", {
  name: "javascript",
  typescript: !0
});
window.CodeMirror.defineMode("turtle", function(e) {
  var t = e.indentUnit, r;
  function n(c) {
    return new RegExp("^(?:" + c.join("|") + ")$", "i");
  }
  n([]);
  var o = n(["@prefix", "@base", "a"]), s = /[*+\-<>=&|]/;
  function a(c, d) {
    var h = c.next();
    if (r = null, h == "<" && !c.match(/^[\s\u00a0=]/, !1))
      return c.match(/^[^\s\u00a0>]*>?/), "atom";
    if (h == '"' || h == "'")
      return d.tokenize = l(h), d.tokenize(c, d);
    if (/[{}\(\),\.;\[\]]/.test(h))
      return r = h, null;
    if (h == "#")
      return c.skipToEnd(), "comment";
    if (s.test(h))
      return c.eatWhile(s), null;
    if (h == ":")
      return "operator";
    if (c.eatWhile(/[_\w\d]/), c.peek() == ":")
      return "variable-3";
    var p = c.current();
    return o.test(p) ? "meta" : h >= "A" && h <= "Z" ? "comment" : "keyword";
    var p = c.current();
  }
  function l(c) {
    return function(d, h) {
      for (var p = !1, v; (v = d.next()) != null; ) {
        if (v == c && !p) {
          h.tokenize = a;
          break;
        }
        p = !p && v == "\\";
      }
      return "string";
    };
  }
  function u(c, d, h) {
    c.context = {
      prev: c.context,
      indent: c.indent,
      col: h,
      type: d
    };
  }
  function f(c) {
    c.indent = c.context.indent, c.context = c.context.prev;
  }
  return {
    startState: function() {
      return { tokenize: a, context: null, indent: 0, col: 0 };
    },
    token: function(c, d) {
      if (c.sol() && (d.context && d.context.align == null && (d.context.align = !1), d.indent = c.indentation()), c.eatSpace())
        return null;
      var h = d.tokenize(c, d);
      if (h != "comment" && d.context && d.context.align == null && d.context.type != "pattern" && (d.context.align = !0), r == "(")
        u(d, ")", c.column());
      else if (r == "[")
        u(d, "]", c.column());
      else if (r == "{")
        u(d, "}", c.column());
      else if (/[\]\}\)]/.test(r)) {
        for (; d.context && d.context.type == "pattern"; )
          f(d);
        d.context && r == d.context.type && f(d);
      } else
        r == "." && d.context && d.context.type == "pattern" ? f(d) : /atom|string|variable/.test(h) && d.context && (/[\}\]]/.test(d.context.type) ? u(d, "pattern", c.column()) : d.context.type == "pattern" && !d.context.align && (d.context.align = !0, d.context.col = c.column()));
      return h;
    },
    indent: function(c, d) {
      var h = d && d.charAt(0), p = c.context;
      if (/[\]\}]/.test(h))
        for (; p && p.type == "pattern"; )
          p = p.prev;
      var v = p && h == p.type;
      return p ? p.type == "pattern" ? p.col : p.align ? p.col + (v ? 0 : 1) : p.indent + (v ? 0 : t) : 0;
    },
    lineComment: "#"
  };
});
CodeMirror.defineMIME("text/turtle", "turtle");
CodeMirror.defineMIME("text/n3", "turtle");
CodeMirror.defineMIME("application/trig", "turtle");
window.CodeMirror.defineMode("ntriples", function() {
  var e = {
    PRE_SUBJECT: 0,
    WRITING_SUB_URI: 1,
    WRITING_BNODE_URI: 2,
    PRE_PRED: 3,
    WRITING_PRED_URI: 4,
    PRE_OBJ: 5,
    WRITING_OBJ_URI: 6,
    WRITING_OBJ_BNODE: 7,
    WRITING_OBJ_LITERAL: 8,
    WRITING_LIT_LANG: 9,
    WRITING_LIT_TYPE: 10,
    POST_OBJ: 11,
    ERROR: 12
  };
  function t(r, n) {
    var o = r.location, s;
    o == e.PRE_SUBJECT && n == "<" ? s = e.WRITING_SUB_URI : o == e.PRE_SUBJECT && n == "_" ? s = e.WRITING_BNODE_URI : o == e.PRE_PRED && n == "<" ? s = e.WRITING_PRED_URI : o == e.PRE_OBJ && n == "<" ? s = e.WRITING_OBJ_URI : o == e.PRE_OBJ && n == "_" ? s = e.WRITING_OBJ_BNODE : o == e.PRE_OBJ && n == '"' ? s = e.WRITING_OBJ_LITERAL : o == e.WRITING_SUB_URI && n == ">" || o == e.WRITING_BNODE_URI && n == " " ? s = e.PRE_PRED : o == e.WRITING_PRED_URI && n == ">" ? s = e.PRE_OBJ : o == e.WRITING_OBJ_URI && n == ">" || o == e.WRITING_OBJ_BNODE && n == " " || o == e.WRITING_OBJ_LITERAL && n == '"' || o == e.WRITING_LIT_LANG && n == " " || o == e.WRITING_LIT_TYPE && n == ">" ? s = e.POST_OBJ : o == e.WRITING_OBJ_LITERAL && n == "@" ? s = e.WRITING_LIT_LANG : o == e.WRITING_OBJ_LITERAL && n == "^" ? s = e.WRITING_LIT_TYPE : n == " " && (o == e.PRE_SUBJECT || o == e.PRE_PRED || o == e.PRE_OBJ || o == e.POST_OBJ) ? s = o : o == e.POST_OBJ && n == "." ? s = e.PRE_SUBJECT : s = e.ERROR, r.location = s;
  }
  return {
    startState: function() {
      return {
        location: e.PRE_SUBJECT,
        uris: [],
        anchors: [],
        bnodes: [],
        langs: [],
        types: []
      };
    },
    token: function(r, n) {
      var o = r.next();
      if (o == "<") {
        t(n, o);
        var s = "";
        return r.eatWhile(function(c) {
          return c != "#" && c != ">" ? (s += c, !0) : !1;
        }), n.uris.push(s), r.match("#", !1) || (r.next(), t(n, ">")), "variable";
      }
      if (o == "#") {
        var a = "";
        return r.eatWhile(function(c) {
          return c != ">" && c != " " ? (a += c, !0) : !1;
        }), n.anchors.push(a), "variable-2";
      }
      if (o == ">")
        return t(n, ">"), "variable";
      if (o == "_") {
        t(n, o);
        var l = "";
        return r.eatWhile(function(c) {
          return c != " " ? (l += c, !0) : !1;
        }), n.bnodes.push(l), r.next(), t(n, " "), "builtin";
      }
      if (o == '"')
        return t(n, o), r.eatWhile(function(c) {
          return c != '"';
        }), r.next(), r.peek() != "@" && r.peek() != "^" && t(n, '"'), "string";
      if (o == "@") {
        t(n, "@");
        var u = "";
        return r.eatWhile(function(c) {
          return c != " " ? (u += c, !0) : !1;
        }), n.langs.push(u), r.next(), t(n, " "), "string-2";
      }
      if (o == "^") {
        r.next(), t(n, "^");
        var f = "";
        return r.eatWhile(function(c) {
          return c != ">" ? (f += c, !0) : !1;
        }), n.types.push(f), r.next(), t(n, ">"), "variable";
      }
      o == " " && t(n, o), o == "." && t(n, o);
    }
  };
});
CodeMirror.defineMIME("application/n-triples", "ntriples");
CodeMirror.defineMIME("application/n-quads", "ntriples");
CodeMirror.defineMIME("text/n-triples", "ntriples");
var Mhe = {
  autoSelfClosers: {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    command: !0,
    embed: !0,
    frame: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
    menuitem: !0
  },
  implicitlyClosed: {
    dd: !0,
    li: !0,
    optgroup: !0,
    option: !0,
    p: !0,
    rp: !0,
    rt: !0,
    tbody: !0,
    td: !0,
    tfoot: !0,
    th: !0,
    tr: !0
  },
  contextGrabbers: {
    dd: { dd: !0, dt: !0 },
    dt: { dd: !0, dt: !0 },
    li: { li: !0 },
    option: { option: !0, optgroup: !0 },
    optgroup: { optgroup: !0 },
    p: {
      address: !0,
      article: !0,
      aside: !0,
      blockquote: !0,
      dir: !0,
      div: !0,
      dl: !0,
      fieldset: !0,
      footer: !0,
      form: !0,
      h1: !0,
      h2: !0,
      h3: !0,
      h4: !0,
      h5: !0,
      h6: !0,
      header: !0,
      hgroup: !0,
      hr: !0,
      menu: !0,
      nav: !0,
      ol: !0,
      p: !0,
      pre: !0,
      section: !0,
      table: !0,
      ul: !0
    },
    rp: { rp: !0, rt: !0 },
    rt: { rp: !0, rt: !0 },
    tbody: { tbody: !0, tfoot: !0 },
    td: { td: !0, th: !0 },
    tfoot: { tbody: !0 },
    th: { td: !0, th: !0 },
    thead: { tbody: !0, tfoot: !0 },
    tr: { tr: !0 }
  },
  doNotIndent: { pre: !0 },
  allowUnquoted: !0,
  allowMissing: !0,
  caseFold: !0
}, Ohe = {
  autoSelfClosers: {},
  implicitlyClosed: {},
  contextGrabbers: {},
  doNotIndent: {},
  allowUnquoted: !1,
  allowMissing: !1,
  allowMissingTagName: !1,
  caseFold: !1
};
window.CodeMirror.defineMode("xml", function(e, t) {
  var r = e.indentUnit, n = {}, o = t.htmlMode ? Mhe : Ohe;
  for (var s in o)
    n[s] = o[s];
  for (var s in t)
    n[s] = t[s];
  var a, l;
  function u($, G) {
    function I(U) {
      return G.tokenize = U, U($, G);
    }
    var W = $.next();
    if (W == "<")
      return $.eat("!") ? $.eat("[") ? $.match("CDATA[") ? I(d("atom", "]]>")) : null : $.match("--") ? I(d("comment", "-->")) : $.match("DOCTYPE", !0, !0) ? ($.eatWhile(/[\w\._\-]/), I(h(1))) : null : $.eat("?") ? ($.eatWhile(/[\w\._\-]/), G.tokenize = d("meta", "?>"), "meta") : (a = $.eat("/") ? "closeTag" : "openTag", G.tokenize = f, "tag bracket");
    if (W == "&") {
      var k;
      return $.eat("#") ? $.eat("x") ? k = $.eatWhile(/[a-fA-F\d]/) && $.eat(";") : k = $.eatWhile(/[\d]/) && $.eat(";") : k = $.eatWhile(/[\w\.\-:]/) && $.eat(";"), k ? "atom" : "error";
    } else
      return $.eatWhile(/[^&<]/), null;
  }
  u.isInText = !0;
  function f($, G) {
    var I = $.next();
    if (I == ">" || I == "/" && $.eat(">"))
      return G.tokenize = u, a = I == ">" ? "endTag" : "selfcloseTag", "tag bracket";
    if (I == "=")
      return a = "equals", null;
    if (I == "<") {
      G.tokenize = u, G.state = w, G.tagName = G.tagStart = null;
      var W = G.tokenize($, G);
      return W ? W + " tag error" : "tag error";
    } else
      return /[\'\"]/.test(I) ? (G.tokenize = c(I), G.stringStartCol = $.column(), G.tokenize($, G)) : ($.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/), "word");
  }
  function c($) {
    var G = function(I, W) {
      for (; !I.eol(); )
        if (I.next() == $) {
          W.tokenize = f;
          break;
        }
      return "string";
    };
    return G.isInAttribute = !0, G;
  }
  function d($, G) {
    return function(I, W) {
      for (; !I.eol(); ) {
        if (I.match(G)) {
          W.tokenize = u;
          break;
        }
        I.next();
      }
      return $;
    };
  }
  function h($) {
    return function(G, I) {
      for (var W; (W = G.next()) != null; ) {
        if (W == "<")
          return I.tokenize = h($ + 1), I.tokenize(G, I);
        if (W == ">")
          if ($ == 1) {
            I.tokenize = u;
            break;
          } else
            return I.tokenize = h($ - 1), I.tokenize(G, I);
      }
      return "meta";
    };
  }
  function p($, G, I) {
    this.prev = $.context, this.tagName = G, this.indent = $.indented, this.startOfLine = I, (n.doNotIndent.hasOwnProperty(G) || $.context && $.context.noIndent) && (this.noIndent = !0);
  }
  function v($) {
    $.context && ($.context = $.context.prev);
  }
  function y($, G) {
    for (var I; ; ) {
      if (!$.context || (I = $.context.tagName, !n.contextGrabbers.hasOwnProperty(I) || !n.contextGrabbers[I].hasOwnProperty(G)))
        return;
      v($);
    }
  }
  function w($, G, I) {
    return $ == "openTag" ? (I.tagStart = G.column(), S) : $ == "closeTag" ? x : w;
  }
  function S($, G, I) {
    return $ == "word" ? (I.tagName = G.current(), l = "tag", C) : n.allowMissingTagName && $ == "endTag" ? (l = "tag bracket", C($, G, I)) : (l = "error", S);
  }
  function x($, G, I) {
    if ($ == "word") {
      var W = G.current();
      return I.context && I.context.tagName != W && n.implicitlyClosed.hasOwnProperty(I.context.tagName) && v(I), I.context && I.context.tagName == W || n.matchClosing === !1 ? (l = "tag", E) : (l = "tag error", N);
    } else
      return n.allowMissingTagName && $ == "endTag" ? (l = "tag bracket", E($, G, I)) : (l = "error", N);
  }
  function E($, G, I) {
    return $ != "endTag" ? (l = "error", E) : (v(I), w);
  }
  function N($, G, I) {
    return l = "error", E($, G, I);
  }
  function C($, G, I) {
    if ($ == "word")
      return l = "attribute", j;
    if ($ == "endTag" || $ == "selfcloseTag") {
      var W = I.tagName, k = I.tagStart;
      return I.tagName = I.tagStart = null, $ == "selfcloseTag" || n.autoSelfClosers.hasOwnProperty(W) ? y(I, W) : (y(I, W), I.context = new p(I, W, k == I.indented)), w;
    }
    return l = "error", C;
  }
  function j($, G, I) {
    return $ == "equals" ? J : (n.allowMissing || (l = "error"), C($, G, I));
  }
  function J($, G, I) {
    return $ == "string" ? z : $ == "word" && n.allowUnquoted ? (l = "string", C) : (l = "error", C($, G, I));
  }
  function z($, G, I) {
    return $ == "string" ? z : C($, G, I);
  }
  return {
    startState: function($) {
      var G = {
        tokenize: u,
        state: w,
        indented: $ || 0,
        tagName: null,
        tagStart: null,
        context: null
      };
      return $ != null && (G.baseIndent = $), G;
    },
    token: function($, G) {
      if (!G.tagName && $.sol() && (G.indented = $.indentation()), $.eatSpace())
        return null;
      a = null;
      var I = G.tokenize($, G);
      return (I || a) && I != "comment" && (l = null, G.state = G.state(a || I, $, G), l && (I = l == "error" ? I + " error" : l)), I;
    },
    indent: function($, G, I) {
      var W = $.context;
      if ($.tokenize.isInAttribute)
        return $.tagStart == $.indented ? $.stringStartCol + 1 : $.indented + r;
      if (W && W.noIndent)
        return CodeMirror.Pass;
      if ($.tokenize != f && $.tokenize != u)
        return I ? I.match(/^(\s*)/)[0].length : 0;
      if ($.tagName)
        return n.multilineTagIndentPastTag !== !1 ? $.tagStart + $.tagName.length + 2 : $.tagStart + r * (n.multilineTagIndentFactor || 1);
      if (n.alignCDATA && /<!\[CDATA\[/.test(G))
        return 0;
      var k = G && /^<(\/)?([\w_:\.-]*)/.exec(G);
      if (k && k[1])
        for (; W; )
          if (W.tagName == k[2]) {
            W = W.prev;
            break;
          } else if (n.implicitlyClosed.hasOwnProperty(W.tagName))
            W = W.prev;
          else
            break;
      else if (k)
        for (; W; ) {
          var U = n.contextGrabbers[W.tagName];
          if (U && U.hasOwnProperty(k[2]))
            W = W.prev;
          else
            break;
        }
      for (; W && W.prev && !W.startOfLine; )
        W = W.prev;
      return W ? W.indent + r : $.baseIndent || 0;
    },
    electricInput: /<\/[\s\w:]+>$/,
    blockCommentStart: "<!--",
    blockCommentEnd: "-->",
    configuration: n.htmlMode ? "html" : "xml",
    helperType: n.htmlMode ? "html" : "xml",
    skipAttribute: function($) {
      $.state == J && ($.state = C);
    },
    xmlCurrentTag: function($) {
      return $.tagName ? { name: $.tagName, close: $.type == "closeTag" } : null;
    },
    xmlCurrentContext: function($) {
      for (var G = [], I = $.context; I; I = I.prev)
        I.tagName && G.push(I.tagName);
      return G.reverse();
    }
  };
});
CodeMirror.defineMIME("text/xml", "xml");
CodeMirror.defineMIME("application/xml", "xml");
CodeMirror.mimeModes.hasOwnProperty("text/html") || CodeMirror.defineMIME("text/html", { name: "xml", htmlMode: !0 });
const Rd = Symbol("parsed quads");
class Lhe extends Ihe {
  static get properties() {
    return {
      format: { type: String, reflect: !0 },
      quads: { type: Array },
      noReserialize: { type: Boolean, attribute: "no-reserialize" }
    };
  }
  constructor() {
    super(), this.isParsing = !1, this.noReserialize = !1;
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.ready = null;
  }
  /**
   * Gets or set RDF/JS quads. Setting will parse them using the chosen `format` and set to the text editor
   *
   * @returns {Quad[]}
   */
  get quads() {
    return this[Rd];
  }
  set quads(t) {
    if (typeof t > "u" || t === null)
      return;
    const r = this[Rd];
    this[Rd] = t, this.requestUpdate("quads", r);
  }
  async updated(t) {
    super.updated(t);
    let r = !1, n = !1;
    const o = this.quads && this.quads.length > 0;
    t.has("format") && (r = o && !this.noReserialize, n = !r), t.has("quads") && (r = !0), (t.has("prefixes") || t.has("customPrefixes")) && (r = o), n ? this.parse() : r && this.__serialize();
  }
  async _parse() {
    const { toStream: t } = await import("./stream-1CRCGY_S.js"), r = t(this.value), n = [], o = {}, s = this.$rdf.formats.parsers.import(
      this.format,
      r
    );
    if (!s) {
      this.dispatchEvent(
        new CustomEvent("parsing-failed", {
          detail: {
            notFound: !0
          }
        })
      );
      return;
    }
    s.on("prefix", (a, l) => {
      o[a] = l;
    });
    for await (const a of s)
      n.push(a);
    this[Rd] = n, this.dispatchEvent(
      new CustomEvent("quads-changed", {
        detail: {
          value: n
        }
      })
    ), this.__notifyParsedPrefixes(o);
  }
  async __serialize() {
    if (!this.format)
      return;
    await this.ready;
    const { Readable: t } = await import("./stream-1CRCGY_S.js"), r = [...this.quads || []], n = new t({
      objectMode: !0,
      read() {
        if (r.length === 0) {
          this.push(null);
          return;
        }
        this.push(r.shift());
      }
    }), o = this.$rdf.formats.serializers.import(
      this.format,
      n,
      {
        prefixes: await this._combinePrefixes()
      }
    );
    if (!o) {
      this.value = `No serializer found for media type ${this.format}`;
      return;
    }
    let s = "";
    for await (const a of o)
      s += a;
    this.format === ti.jsonLd && (s = JSON.stringify(JSON.parse(s), null, 2)), this.value = s, this.dispatchEvent(
      new CustomEvent("serialized", {
        detail: {
          value: s
        }
      })
    );
  }
  // eslint-disable-next-line class-methods-use-this
  _errorLine(t) {
    const r = { message: t.message };
    return t.context && t.context.line && (r.from = { line: t.context.line - 1, ch: 0 }, r.to = {
      line: t.context.line - 1,
      ch: Number.MAX_SAFE_INTEGER
    }), r;
  }
  __notifyParsedPrefixes(t) {
    const r = {}, n = { ...t };
    for (const [o, s] of Object.entries(t))
      o in $E && (r[o] = s, delete n[o]);
    this.dispatchEvent(
      new CustomEvent("prefixes-parsed", {
        detail: {
          prefixes: {
            ...r,
            ...n
          }
        }
      })
    );
  }
}
const DB = new mp([m3, uu]);
DB.formats.import(Ln);
window.customElements.define(
  "rdf-editor",
  class extends yse(Lhe, DB) {
  }
);
function kr(e, t, ...r) {
  if (e in t) {
    let o = t[e];
    return typeof o == "function" ? o(...r) : o;
  }
  let n = new Error(`Tried to handle "${e}" but there is no handler defined. Only defined handlers are: ${Object.keys(t).map((o) => `"${o}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(n, kr), n;
}
var Ma = ((e) => (e[e.None = 0] = "None", e[e.RenderStrategy = 1] = "RenderStrategy", e[e.Static = 2] = "Static", e))(Ma || {}), Phe = ((e) => (e[e.Unmount = 0] = "Unmount", e[e.Hidden = 1] = "Hidden", e))(Phe || {});
function fr({ visible: e = !0, features: t = 0, ourProps: r, theirProps: n, ...o }) {
  var s;
  let a = jB(n, r), l = Object.assign(o, { props: a });
  if (e || t & 2 && a.static)
    return A0(l);
  if (t & 1) {
    let u = (s = a.unmount) == null || s ? 0 : 1;
    return kr(u, { 0() {
      return null;
    }, 1() {
      return A0({ ...o, props: { ...a, hidden: !0, style: { display: "none" } } });
    } });
  }
  return A0(l);
}
function A0({ props: e, attrs: t, slots: r, slot: n, name: o }) {
  var s, a;
  let { as: l, ...u } = Dg(e, ["unmount", "static"]), f = (s = r.default) == null ? void 0 : s.call(r, n), c = {};
  if (n) {
    let d = !1, h = [];
    for (let [p, v] of Object.entries(n))
      typeof v == "boolean" && (d = !0), v === !0 && h.push(p);
    d && (c["data-headlessui-state"] = h.join(" "));
  }
  if (l === "template") {
    if (f = FB(f ?? []), Object.keys(u).length > 0 || Object.keys(t).length > 0) {
      let [d, ...h] = f ?? [];
      if (!Dhe(d) || h.length > 0)
        throw new Error(['Passing props on "template"!', "", `The current component <${o} /> is rendering a "template".`, "However we need to passthrough the following props:", Object.keys(u).concat(Object.keys(t)).map((y) => y.trim()).filter((y, w, S) => S.indexOf(y) === w).sort((y, w) => y.localeCompare(w)).map((y) => `  - ${y}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map((y) => `  - ${y}`).join(`
`)].join(`
`));
      let p = jB((a = d.props) != null ? a : {}, u), v = Xn(d, p);
      for (let y in p)
        y.startsWith("on") && (v.props || (v.props = {}), v.props[y] = p[y]);
      return v;
    }
    return Array.isArray(f) && f.length === 1 ? f[0] : f;
  }
  return Ut(l, Object.assign({}, u, c), { default: () => f });
}
function FB(e) {
  return e.flatMap((t) => t.type === ut ? FB(t.children) : [t]);
}
function jB(...e) {
  if (e.length === 0)
    return {};
  if (e.length === 1)
    return e[0];
  let t = {}, r = {};
  for (let n of e)
    for (let o in n)
      o.startsWith("on") && typeof n[o] == "function" ? (r[o] != null || (r[o] = []), r[o].push(n[o])) : t[o] = n[o];
  if (t.disabled || t["aria-disabled"])
    return Object.assign(t, Object.fromEntries(Object.keys(r).map((n) => [n, void 0])));
  for (let n in r)
    Object.assign(t, { [n](o, ...s) {
      let a = r[n];
      for (let l of a) {
        if (o instanceof Event && o.defaultPrevented)
          return;
        l(o, ...s);
      }
    } });
  return t;
}
function UR(e) {
  let t = Object.assign({}, e);
  for (let r in t)
    t[r] === void 0 && delete t[r];
  return t;
}
function Dg(e, t = []) {
  let r = Object.assign({}, e);
  for (let n of t)
    n in r && delete r[n];
  return r;
}
function Dhe(e) {
  return e == null ? !1 : typeof e.type == "string" || typeof e.type == "object" || typeof e.type == "function";
}
let Fhe = 0;
function jhe() {
  return ++Fhe;
}
function ri() {
  return jhe();
}
var rt = ((e) => (e.Space = " ", e.Enter = "Enter", e.Escape = "Escape", e.Backspace = "Backspace", e.Delete = "Delete", e.ArrowLeft = "ArrowLeft", e.ArrowUp = "ArrowUp", e.ArrowRight = "ArrowRight", e.ArrowDown = "ArrowDown", e.Home = "Home", e.End = "End", e.PageUp = "PageUp", e.PageDown = "PageDown", e.Tab = "Tab", e))(rt || {});
function Bhe(e) {
  throw new Error("Unexpected object: " + e);
}
var Nt = ((e) => (e[e.First = 0] = "First", e[e.Previous = 1] = "Previous", e[e.Next = 2] = "Next", e[e.Last = 3] = "Last", e[e.Specific = 4] = "Specific", e[e.Nothing = 5] = "Nothing", e))(Nt || {});
function BB(e, t) {
  let r = t.resolveItems();
  if (r.length <= 0)
    return null;
  let n = t.resolveActiveIndex(), o = n ?? -1, s = (() => {
    switch (e.focus) {
      case 0:
        return r.findIndex((a) => !t.resolveDisabled(a));
      case 1: {
        let a = r.slice().reverse().findIndex((l, u, f) => o !== -1 && f.length - u - 1 >= o ? !1 : !t.resolveDisabled(l));
        return a === -1 ? a : r.length - 1 - a;
      }
      case 2:
        return r.findIndex((a, l) => l <= o ? !1 : !t.resolveDisabled(a));
      case 3: {
        let a = r.slice().reverse().findIndex((l) => !t.resolveDisabled(l));
        return a === -1 ? a : r.length - 1 - a;
      }
      case 4:
        return r.findIndex((a) => t.resolveId(a) === e.id);
      case 5:
        return null;
      default:
        Bhe(e);
    }
  })();
  return s === -1 ? n : s;
}
function qe(e) {
  var t;
  return e == null || e.value == null ? null : (t = e.value.$el) != null ? t : e.value;
}
let qB = Symbol("Context");
var dn = ((e) => (e[e.Open = 1] = "Open", e[e.Closed = 2] = "Closed", e[e.Closing = 4] = "Closing", e[e.Opening = 8] = "Opening", e))(dn || {});
function HR() {
  return vr(qB, null);
}
function WB(e) {
  $n(qB, e);
}
function RI(e, t) {
  if (e)
    return e;
  let r = t ?? "button";
  if (typeof r == "string" && r.toLowerCase() === "button")
    return "button";
}
function VR(e, t) {
  let r = Ne(RI(e.value.type, e.value.as));
  return Dt(() => {
    r.value = RI(e.value.type, e.value.as);
  }), Qn(() => {
    var n;
    r.value || qe(t) && qe(t) instanceof HTMLButtonElement && !((n = qe(t)) != null && n.hasAttribute("type")) && (r.value = "button");
  }), r;
}
var qhe = Object.defineProperty, Whe = (e, t, r) => t in e ? qhe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, AI = (e, t, r) => (Whe(e, typeof t != "symbol" ? t + "" : t, r), r);
let Uhe = class {
  constructor() {
    AI(this, "current", this.detect()), AI(this, "currentId", 0);
  }
  set(t) {
    this.current !== t && (this.currentId = 0, this.current = t);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
}, Fg = new Uhe();
function Yn(e) {
  if (Fg.isServer)
    return null;
  if (e instanceof Node)
    return e.ownerDocument;
  if (e != null && e.hasOwnProperty("value")) {
    let t = qe(e);
    if (t)
      return t.ownerDocument;
  }
  return document;
}
function UB({ container: e, accept: t, walk: r, enabled: n }) {
  Qn(() => {
    let o = e.value;
    if (!o || n !== void 0 && !n.value)
      return;
    let s = Yn(e);
    if (!s)
      return;
    let a = Object.assign((u) => t(u), { acceptNode: t }), l = s.createTreeWalker(o, NodeFilter.SHOW_ELEMENT, a, !1);
    for (; l.nextNode(); )
      r(l.currentNode);
  });
}
let lE = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e) => `${e}:not([tabindex='-1'])`).join(",");
var Qr = ((e) => (e[e.First = 1] = "First", e[e.Previous = 2] = "Previous", e[e.Next = 4] = "Next", e[e.Last = 8] = "Last", e[e.WrapAround = 16] = "WrapAround", e[e.NoScroll = 32] = "NoScroll", e))(Qr || {}), Uh = ((e) => (e[e.Error = 0] = "Error", e[e.Overflow = 1] = "Overflow", e[e.Success = 2] = "Success", e[e.Underflow = 3] = "Underflow", e))(Uh || {}), Hhe = ((e) => (e[e.Previous = -1] = "Previous", e[e.Next = 1] = "Next", e))(Hhe || {});
function HB(e = document.body) {
  return e == null ? [] : Array.from(e.querySelectorAll(lE)).sort((t, r) => Math.sign((t.tabIndex || Number.MAX_SAFE_INTEGER) - (r.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var jg = ((e) => (e[e.Strict = 0] = "Strict", e[e.Loose = 1] = "Loose", e))(jg || {});
function Bg(e, t = 0) {
  var r;
  return e === ((r = Yn(e)) == null ? void 0 : r.body) ? !1 : kr(t, { 0() {
    return e.matches(lE);
  }, 1() {
    let n = e;
    for (; n !== null; ) {
      if (n.matches(lE))
        return !0;
      n = n.parentElement;
    }
    return !1;
  } });
}
function VB(e) {
  let t = Yn(e);
  br(() => {
    t && !Bg(t.activeElement, 0) && rs(e);
  });
}
var Vhe = ((e) => (e[e.Keyboard = 0] = "Keyboard", e[e.Mouse = 1] = "Mouse", e))(Vhe || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (e) => {
  e.metaKey || e.altKey || e.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (e) => {
  e.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function rs(e) {
  e == null || e.focus({ preventScroll: !0 });
}
let zhe = ["textarea", "input"].join(",");
function Ghe(e) {
  var t, r;
  return (r = (t = e == null ? void 0 : e.matches) == null ? void 0 : t.call(e, zhe)) != null ? r : !1;
}
function qg(e, t = (r) => r) {
  return e.slice().sort((r, n) => {
    let o = t(r), s = t(n);
    if (o === null || s === null)
      return 0;
    let a = o.compareDocumentPosition(s);
    return a & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : a & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function Khe(e, t) {
  return ma(HB(), t, { relativeTo: e });
}
function ma(e, t, { sorted: r = !0, relativeTo: n = null, skipElements: o = [] } = {}) {
  var s;
  let a = (s = Array.isArray(e) ? e.length > 0 ? e[0].ownerDocument : document : e == null ? void 0 : e.ownerDocument) != null ? s : document, l = Array.isArray(e) ? r ? qg(e) : e : HB(e);
  o.length > 0 && l.length > 1 && (l = l.filter((v) => !o.includes(v))), n = n ?? a.activeElement;
  let u = (() => {
    if (t & 5)
      return 1;
    if (t & 10)
      return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), f = (() => {
    if (t & 1)
      return 0;
    if (t & 2)
      return Math.max(0, l.indexOf(n)) - 1;
    if (t & 4)
      return Math.max(0, l.indexOf(n)) + 1;
    if (t & 8)
      return l.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), c = t & 32 ? { preventScroll: !0 } : {}, d = 0, h = l.length, p;
  do {
    if (d >= h || d + h <= 0)
      return 0;
    let v = f + d;
    if (t & 16)
      v = (v + h) % h;
    else {
      if (v < 0)
        return 3;
      if (v >= h)
        return 1;
    }
    p = l[v], p == null || p.focus(c), d += u;
  } while (p !== a.activeElement);
  return t & 6 && Ghe(p) && p.select(), 2;
}
function TI(e, t, r) {
  Fg.isServer || Qn((n) => {
    document.addEventListener(e, t, r), n(() => document.removeEventListener(e, t, r));
  });
}
function zB(e, t, r) {
  Fg.isServer || Qn((n) => {
    window.addEventListener(e, t, r), n(() => window.removeEventListener(e, t, r));
  });
}
function zR(e, t, r = Oe(() => !0)) {
  function n(s, a) {
    if (!r.value || s.defaultPrevented)
      return;
    let l = a(s);
    if (l === null || !l.getRootNode().contains(l))
      return;
    let u = function f(c) {
      return typeof c == "function" ? f(c()) : Array.isArray(c) || c instanceof Set ? c : [c];
    }(e);
    for (let f of u) {
      if (f === null)
        continue;
      let c = f instanceof HTMLElement ? f : qe(f);
      if (c != null && c.contains(l) || s.composed && s.composedPath().includes(c))
        return;
    }
    return !Bg(l, jg.Loose) && l.tabIndex !== -1 && s.preventDefault(), t(s, l);
  }
  let o = Ne(null);
  TI("mousedown", (s) => {
    var a, l;
    r.value && (o.value = ((l = (a = s.composedPath) == null ? void 0 : a.call(s)) == null ? void 0 : l[0]) || s.target);
  }, !0), TI("click", (s) => {
    o.value && (n(s, () => o.value), o.value = null);
  }, !0), zB("blur", (s) => n(s, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
var Oa = ((e) => (e[e.None = 1] = "None", e[e.Focusable = 2] = "Focusable", e[e.Hidden = 4] = "Hidden", e))(Oa || {});
let su = it({ name: "Hidden", props: { as: { type: [Object, String], default: "div" }, features: { type: Number, default: 1 } }, setup(e, { slots: t, attrs: r }) {
  return () => {
    let { features: n, ...o } = e, s = { "aria-hidden": (n & 2) === 2 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(n & 4) === 4 && (n & 2) !== 2 && { display: "none" } } };
    return fr({ ourProps: s, theirProps: o, slot: {}, attrs: r, slots: t, name: "Hidden" });
  };
} });
function GR(e = {}, t = null, r = []) {
  for (let [n, o] of Object.entries(e))
    KB(r, GB(t, n), o);
  return r;
}
function GB(e, t) {
  return e ? e + "[" + t + "]" : t;
}
function KB(e, t, r) {
  if (Array.isArray(r))
    for (let [n, o] of r.entries())
      KB(e, GB(t, n.toString()), o);
  else
    r instanceof Date ? e.push([t, r.toISOString()]) : typeof r == "boolean" ? e.push([t, r ? "1" : "0"]) : typeof r == "string" ? e.push([t, r]) : typeof r == "number" ? e.push([t, `${r}`]) : r == null ? e.push([t, ""]) : GR(r, t, e);
}
function YB(e) {
  var t;
  let r = (t = e == null ? void 0 : e.form) != null ? t : e.closest("form");
  if (r) {
    for (let n of r.elements)
      if (n.tagName === "INPUT" && n.type === "submit" || n.tagName === "BUTTON" && n.type === "submit" || n.nodeName === "INPUT" && n.type === "image") {
        n.click();
        return;
      }
  }
}
function KR(e, t, r) {
  let n = Ne(r == null ? void 0 : r.value), o = Oe(() => e.value !== void 0);
  return [Oe(() => o.value ? e.value : n.value), function(s) {
    return o.value || (n.value = s), t == null ? void 0 : t(s);
  }];
}
function $I(e) {
  return [e.screenX, e.screenY];
}
function XB() {
  let e = Ne([-1, -1]);
  return { wasMoved(t) {
    let r = $I(t);
    return e.value[0] === r[0] && e.value[1] === r[1] ? !1 : (e.value = r, !0);
  }, update(t) {
    e.value = $I(t);
  } };
}
function Yhe() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function JB() {
  let e = [], t = { addEventListener(r, n, o, s) {
    return r.addEventListener(n, o, s), t.add(() => r.removeEventListener(n, o, s));
  }, requestAnimationFrame(...r) {
    let n = requestAnimationFrame(...r);
    t.add(() => cancelAnimationFrame(n));
  }, nextFrame(...r) {
    t.requestAnimationFrame(() => {
      t.requestAnimationFrame(...r);
    });
  }, setTimeout(...r) {
    let n = setTimeout(...r);
    t.add(() => clearTimeout(n));
  }, style(r, n, o) {
    let s = r.style.getPropertyValue(n);
    return Object.assign(r.style, { [n]: o }), this.add(() => {
      Object.assign(r.style, { [n]: s });
    });
  }, group(r) {
    let n = JB();
    return r(n), this.add(() => n.dispose());
  }, add(r) {
    return e.push(r), () => {
      let n = e.indexOf(r);
      if (n >= 0)
        for (let o of e.splice(n, 1))
          o();
    };
  }, dispose() {
    for (let r of e.splice(0))
      r();
  } };
  return t;
}
var of = ((e) => (e[e.Forwards = 0] = "Forwards", e[e.Backwards = 1] = "Backwards", e))(of || {});
function Xhe() {
  let e = Ne(0);
  return zB("keydown", (t) => {
    t.key === "Tab" && (e.value = t.shiftKey ? 1 : 0);
  }), e;
}
function QB(e, t, r, n) {
  Fg.isServer || Qn((o) => {
    e = e ?? window, e.addEventListener(t, r, n), o(() => e.removeEventListener(t, r, n));
  });
}
function ZB(e) {
  typeof queueMicrotask == "function" ? queueMicrotask(e) : Promise.resolve().then(e).catch((t) => setTimeout(() => {
    throw t;
  }));
}
function Jhe(e) {
  function t() {
    document.readyState !== "loading" && (e(), document.removeEventListener("DOMContentLoaded", t));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", t), t());
}
function eq(e) {
  if (!e)
    return /* @__PURE__ */ new Set();
  if (typeof e == "function")
    return new Set(e());
  let t = /* @__PURE__ */ new Set();
  for (let r of e.value) {
    let n = qe(r);
    n instanceof HTMLElement && t.add(n);
  }
  return t;
}
var tq = ((e) => (e[e.None = 1] = "None", e[e.InitialFocus = 2] = "InitialFocus", e[e.TabLock = 4] = "TabLock", e[e.FocusLock = 8] = "FocusLock", e[e.RestoreFocus = 16] = "RestoreFocus", e[e.All = 30] = "All", e))(tq || {});
let Bu = Object.assign(it({ name: "FocusTrap", props: { as: { type: [Object, String], default: "div" }, initialFocus: { type: Object, default: null }, features: { type: Number, default: 30 }, containers: { type: [Object, Function], default: Ne(/* @__PURE__ */ new Set()) } }, inheritAttrs: !1, setup(e, { attrs: t, slots: r, expose: n }) {
  let o = Ne(null);
  n({ el: o, $el: o });
  let s = Oe(() => Yn(o)), a = Ne(!1);
  Dt(() => a.value = !0), xn(() => a.value = !1), Zhe({ ownerDocument: s }, Oe(() => a.value && !!(e.features & 16)));
  let l = epe({ ownerDocument: s, container: o, initialFocus: Oe(() => e.initialFocus) }, Oe(() => a.value && !!(e.features & 2)));
  tpe({ ownerDocument: s, container: o, containers: e.containers, previousActiveElement: l }, Oe(() => a.value && !!(e.features & 8)));
  let u = Xhe();
  function f(p) {
    let v = qe(o);
    v && ((y) => y())(() => {
      kr(u.value, { [of.Forwards]: () => {
        ma(v, Qr.First, { skipElements: [p.relatedTarget] });
      }, [of.Backwards]: () => {
        ma(v, Qr.Last, { skipElements: [p.relatedTarget] });
      } });
    });
  }
  let c = Ne(!1);
  function d(p) {
    p.key === "Tab" && (c.value = !0, requestAnimationFrame(() => {
      c.value = !1;
    }));
  }
  function h(p) {
    if (!a.value)
      return;
    let v = eq(e.containers);
    qe(o) instanceof HTMLElement && v.add(qe(o));
    let y = p.relatedTarget;
    y instanceof HTMLElement && y.dataset.headlessuiFocusGuard !== "true" && (rq(v, y) || (c.value ? ma(qe(o), kr(u.value, { [of.Forwards]: () => Qr.Next, [of.Backwards]: () => Qr.Previous }) | Qr.WrapAround, { relativeTo: p.target }) : p.target instanceof HTMLElement && rs(p.target)));
  }
  return () => {
    let p = {}, v = { ref: o, onKeydown: d, onFocusout: h }, { features: y, initialFocus: w, containers: S, ...x } = e;
    return Ut(ut, [!!(y & 4) && Ut(su, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: f, features: Oa.Focusable }), fr({ ourProps: v, theirProps: { ...t, ...x }, slot: p, attrs: t, slots: r, name: "FocusTrap" }), !!(y & 4) && Ut(su, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: f, features: Oa.Focusable })]);
  };
} }), { features: tq }), Ks = [];
Jhe(() => {
  function e(t) {
    t.target instanceof HTMLElement && t.target !== document.body && Ks[0] !== t.target && (Ks.unshift(t.target), Ks = Ks.filter((r) => r != null && r.isConnected), Ks.splice(10));
  }
  window.addEventListener("click", e, { capture: !0 }), window.addEventListener("mousedown", e, { capture: !0 }), window.addEventListener("focus", e, { capture: !0 }), document.body.addEventListener("click", e, { capture: !0 }), document.body.addEventListener("mousedown", e, { capture: !0 }), document.body.addEventListener("focus", e, { capture: !0 });
});
function Qhe(e) {
  let t = Ne(Ks.slice());
  return yr([e], ([r], [n]) => {
    n === !0 && r === !1 ? ZB(() => {
      t.value.splice(0);
    }) : n === !1 && r === !0 && (t.value = Ks.slice());
  }, { flush: "post" }), () => {
    var r;
    return (r = t.value.find((n) => n != null && n.isConnected)) != null ? r : null;
  };
}
function Zhe({ ownerDocument: e }, t) {
  let r = Qhe(t);
  Dt(() => {
    Qn(() => {
      var n, o;
      t.value || ((n = e.value) == null ? void 0 : n.activeElement) === ((o = e.value) == null ? void 0 : o.body) && rs(r());
    }, { flush: "post" });
  }), xn(() => {
    t.value && rs(r());
  });
}
function epe({ ownerDocument: e, container: t, initialFocus: r }, n) {
  let o = Ne(null), s = Ne(!1);
  return Dt(() => s.value = !0), xn(() => s.value = !1), Dt(() => {
    yr([t, r, n], (a, l) => {
      if (a.every((f, c) => (l == null ? void 0 : l[c]) === f) || !n.value)
        return;
      let u = qe(t);
      u && ZB(() => {
        var f, c;
        if (!s.value)
          return;
        let d = qe(r), h = (f = e.value) == null ? void 0 : f.activeElement;
        if (d) {
          if (d === h) {
            o.value = h;
            return;
          }
        } else if (u.contains(h)) {
          o.value = h;
          return;
        }
        d ? rs(d) : ma(u, Qr.First | Qr.NoScroll) === Uh.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), o.value = (c = e.value) == null ? void 0 : c.activeElement;
      });
    }, { immediate: !0, flush: "post" });
  }), o;
}
function tpe({ ownerDocument: e, container: t, containers: r, previousActiveElement: n }, o) {
  var s;
  QB((s = e.value) == null ? void 0 : s.defaultView, "focus", (a) => {
    if (!o.value)
      return;
    let l = eq(r);
    qe(t) instanceof HTMLElement && l.add(qe(t));
    let u = n.value;
    if (!u)
      return;
    let f = a.target;
    f && f instanceof HTMLElement ? rq(l, f) ? (n.value = f, rs(f)) : (a.preventDefault(), a.stopPropagation(), rs(u)) : rs(n.value);
  }, !0);
}
function rq(e, t) {
  for (let r of e)
    if (r.contains(t))
      return !0;
  return !1;
}
let T0 = /* @__PURE__ */ new Map(), qu = /* @__PURE__ */ new Map();
function NI(e, t = Ne(!0)) {
  Qn((r) => {
    var n;
    if (!t.value)
      return;
    let o = qe(e);
    if (!o)
      return;
    r(function() {
      var a;
      if (!o)
        return;
      let l = (a = qu.get(o)) != null ? a : 1;
      if (l === 1 ? qu.delete(o) : qu.set(o, l - 1), l !== 1)
        return;
      let u = T0.get(o);
      u && (u["aria-hidden"] === null ? o.removeAttribute("aria-hidden") : o.setAttribute("aria-hidden", u["aria-hidden"]), o.inert = u.inert, T0.delete(o));
    });
    let s = (n = qu.get(o)) != null ? n : 0;
    qu.set(o, s + 1), s === 0 && (T0.set(o, { "aria-hidden": o.getAttribute("aria-hidden"), inert: o.inert }), o.setAttribute("aria-hidden", "true"), o.inert = !0);
  });
}
let nq = Symbol("ForcePortalRootContext");
function rpe() {
  return vr(nq, !1);
}
let kI = it({ name: "ForcePortalRoot", props: { as: { type: [Object, String], default: "template" }, force: { type: Boolean, default: !1 } }, setup(e, { slots: t, attrs: r }) {
  return $n(nq, e.force), () => {
    let { force: n, ...o } = e;
    return fr({ theirProps: o, ourProps: {}, slot: {}, slots: t, attrs: r, name: "ForcePortalRoot" });
  };
} });
function npe(e) {
  let t = Yn(e);
  if (!t) {
    if (e === null)
      return null;
    throw new Error(`[Headless UI]: Cannot find ownerDocument for contextElement: ${e}`);
  }
  let r = t.getElementById("headlessui-portal-root");
  if (r)
    return r;
  let n = t.createElement("div");
  return n.setAttribute("id", "headlessui-portal-root"), t.body.appendChild(n);
}
let ipe = it({ name: "Portal", props: { as: { type: [Object, String], default: "div" } }, setup(e, { slots: t, attrs: r }) {
  let n = Ne(null), o = Oe(() => Yn(n)), s = rpe(), a = vr(iq, null), l = Ne(s === !0 || a == null ? npe(n.value) : a.resolveTarget());
  Qn(() => {
    s || a != null && (l.value = a.resolveTarget());
  });
  let u = vr(uE, null);
  return Dt(() => {
    let f = qe(n);
    f && u && xn(u.register(f));
  }), xn(() => {
    var f, c;
    let d = (f = o.value) == null ? void 0 : f.getElementById("headlessui-portal-root");
    d && l.value === d && l.value.children.length <= 0 && ((c = l.value.parentElement) == null || c.removeChild(l.value));
  }), () => {
    if (l.value === null)
      return null;
    let f = { ref: n, "data-headlessui-portal": "" };
    return Ut(BU, { to: l.value }, fr({ ourProps: f, theirProps: e, slot: {}, attrs: r, slots: t, name: "Portal" }));
  };
} }), uE = Symbol("PortalParentContext");
function ope() {
  let e = vr(uE, null), t = Ne([]);
  function r(s) {
    return t.value.push(s), e && e.register(s), () => n(s);
  }
  function n(s) {
    let a = t.value.indexOf(s);
    a !== -1 && t.value.splice(a, 1), e && e.unregister(s);
  }
  let o = { register: r, unregister: n, portals: t };
  return [t, it({ name: "PortalWrapper", setup(s, { slots: a }) {
    return $n(uE, o), () => {
      var l;
      return (l = a.default) == null ? void 0 : l.call(a);
    };
  } })];
}
let iq = Symbol("PortalGroupContext"), spe = it({ name: "PortalGroup", props: { as: { type: [Object, String], default: "template" }, target: { type: Object, default: null } }, setup(e, { attrs: t, slots: r }) {
  let n = lp({ resolveTarget() {
    return e.target;
  } });
  return $n(iq, n), () => {
    let { target: o, ...s } = e;
    return fr({ theirProps: s, ourProps: {}, slot: {}, attrs: t, slots: r, name: "PortalGroup" });
  };
} }), oq = Symbol("StackContext");
var fE = ((e) => (e[e.Add = 0] = "Add", e[e.Remove = 1] = "Remove", e))(fE || {});
function ape() {
  return vr(oq, () => {
  });
}
function lpe({ type: e, enabled: t, element: r, onUpdate: n }) {
  let o = ape();
  function s(...a) {
    n == null || n(...a), o(...a);
  }
  Dt(() => {
    yr(t, (a, l) => {
      a ? s(0, e, r) : l === !0 && s(1, e, r);
    }, { immediate: !0, flush: "sync" });
  }), xn(() => {
    t.value && s(1, e, r);
  }), $n(oq, s);
}
let upe = Symbol("DescriptionContext");
function YR({ slot: e = Ne({}), name: t = "Description", props: r = {} } = {}) {
  let n = Ne([]);
  function o(s) {
    return n.value.push(s), () => {
      let a = n.value.indexOf(s);
      a !== -1 && n.value.splice(a, 1);
    };
  }
  return $n(upe, { register: o, slot: e, name: t, props: r }), Oe(() => n.value.length > 0 ? n.value.join(" ") : void 0);
}
function fpe(e) {
  let t = d4(e.getSnapshot());
  return xn(e.subscribe(() => {
    t.value = e.getSnapshot();
  })), t;
}
function cpe(e, t) {
  let r = e(), n = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return r;
  }, subscribe(o) {
    return n.add(o), () => n.delete(o);
  }, dispatch(o, ...s) {
    let a = t[o].call(r, ...s);
    a && (r = a, n.forEach((l) => l()));
  } };
}
function dpe() {
  let e;
  return { before({ doc: t }) {
    var r;
    let n = t.documentElement;
    e = ((r = t.defaultView) != null ? r : window).innerWidth - n.clientWidth;
  }, after({ doc: t, d: r }) {
    let n = t.documentElement, o = n.clientWidth - n.offsetWidth, s = e - o;
    r.style(n, "paddingRight", `${s}px`);
  } };
}
function hpe() {
  if (!Yhe())
    return {};
  let e;
  return { before() {
    e = window.pageYOffset;
  }, after({ doc: t, d: r, meta: n }) {
    function o(a) {
      return n.containers.flatMap((l) => l()).some((l) => l.contains(a));
    }
    r.style(t.body, "marginTop", `-${e}px`), window.scrollTo(0, 0);
    let s = null;
    r.addEventListener(t, "click", (a) => {
      if (a.target instanceof HTMLElement)
        try {
          let l = a.target.closest("a");
          if (!l)
            return;
          let { hash: u } = new URL(l.href), f = t.querySelector(u);
          f && !o(f) && (s = f);
        } catch {
        }
    }, !0), r.addEventListener(t, "touchmove", (a) => {
      a.target instanceof HTMLElement && !o(a.target) && a.preventDefault();
    }, { passive: !1 }), r.add(() => {
      window.scrollTo(0, window.pageYOffset + e), s && s.isConnected && (s.scrollIntoView({ block: "nearest" }), s = null);
    });
  } };
}
function ppe() {
  return { before({ doc: e, d: t }) {
    t.style(e.documentElement, "overflow", "hidden");
  } };
}
function gpe(e) {
  let t = {};
  for (let r of e)
    Object.assign(t, r(t));
  return t;
}
let ea = cpe(() => /* @__PURE__ */ new Map(), { PUSH(e, t) {
  var r;
  let n = (r = this.get(e)) != null ? r : { doc: e, count: 0, d: JB(), meta: /* @__PURE__ */ new Set() };
  return n.count++, n.meta.add(t), this.set(e, n), this;
}, POP(e, t) {
  let r = this.get(e);
  return r && (r.count--, r.meta.delete(t)), this;
}, SCROLL_PREVENT({ doc: e, d: t, meta: r }) {
  let n = { doc: e, d: t, meta: gpe(r) }, o = [hpe(), dpe(), ppe()];
  o.forEach(({ before: s }) => s == null ? void 0 : s(n)), o.forEach(({ after: s }) => s == null ? void 0 : s(n));
}, SCROLL_ALLOW({ d: e }) {
  e.dispose();
}, TEARDOWN({ doc: e }) {
  this.delete(e);
} });
ea.subscribe(() => {
  let e = ea.getSnapshot(), t = /* @__PURE__ */ new Map();
  for (let [r] of e)
    t.set(r, r.documentElement.style.overflow);
  for (let r of e.values()) {
    let n = t.get(r.doc) === "hidden", o = r.count !== 0;
    (o && !n || !o && n) && ea.dispatch(r.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", r), r.count === 0 && ea.dispatch("TEARDOWN", r);
  }
});
function bpe(e, t, r) {
  let n = fpe(ea), o = Oe(() => {
    let s = e.value ? n.value.get(e.value) : void 0;
    return s ? s.count > 0 : !1;
  });
  return yr([e, t], ([s, a], [l], u) => {
    if (!s || !a)
      return;
    ea.dispatch("PUSH", s, r);
    let f = !1;
    u(() => {
      f || (ea.dispatch("POP", l ?? s, r), f = !0);
    });
  }, { immediate: !0 }), o;
}
function ype({ defaultContainers: e = [], portals: t } = {}) {
  let r = Ne(null), n = Yn(r);
  function o() {
    var s;
    let a = [];
    for (let l of e)
      l !== null && (l instanceof HTMLElement ? a.push(l) : "value" in l && l.value instanceof HTMLElement && a.push(l.value));
    if (t != null && t.value)
      for (let l of t.value)
        a.push(l);
    for (let l of (s = n == null ? void 0 : n.querySelectorAll("html > *, body > *")) != null ? s : [])
      l !== document.body && l !== document.head && l instanceof HTMLElement && l.id !== "headlessui-portal-root" && (l.contains(qe(r)) || a.some((u) => l.contains(u)) || a.push(l));
    return a;
  }
  return { resolveContainers: o, contains(s) {
    return o().some((a) => a.contains(s));
  }, mainTreeNodeRef: r, MainTreeNode() {
    return Ut(su, { features: Oa.Hidden, ref: r });
  } };
}
var vpe = ((e) => (e[e.Open = 0] = "Open", e[e.Closed = 1] = "Closed", e))(vpe || {});
let cE = Symbol("DialogContext");
function sq(e) {
  let t = vr(cE, null);
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, sq), r;
  }
  return t;
}
let Ad = "DC8F892D-2EBD-447C-A4C8-A03058436FF4", mpe = it({ name: "Dialog", inheritAttrs: !1, props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, open: { type: [Boolean, String], default: Ad }, initialFocus: { type: Object, default: null }, id: { type: String, default: () => `headlessui-dialog-${ri()}` } }, emits: { close: (e) => !0 }, setup(e, { emit: t, attrs: r, slots: n, expose: o }) {
  var s;
  let a = Ne(!1);
  Dt(() => {
    a.value = !0;
  });
  let l = Ne(0), u = HR(), f = Oe(() => e.open === Ad && u !== null ? (u.value & dn.Open) === dn.Open : e.open), c = Ne(null), d = Oe(() => Yn(c));
  if (o({ el: c, $el: c }), !(e.open !== Ad || u !== null))
    throw new Error("You forgot to provide an `open` prop to the `Dialog`.");
  if (typeof f.value != "boolean")
    throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${f.value === Ad ? void 0 : e.open}`);
  let h = Oe(() => a.value && f.value ? 0 : 1), p = Oe(() => h.value === 0), v = Oe(() => l.value > 1), y = vr(cE, null) !== null, [w, S] = ope(), { resolveContainers: x, mainTreeNodeRef: E, MainTreeNode: N } = ype({ portals: w, defaultContainers: [Oe(() => {
    var re;
    return (re = k.panelRef.value) != null ? re : c.value;
  })] }), C = Oe(() => v.value ? "parent" : "leaf"), j = Oe(() => u !== null ? (u.value & dn.Closing) === dn.Closing : !1), J = Oe(() => y || j.value ? !1 : p.value), z = Oe(() => {
    var re, ae, ce;
    return (ce = Array.from((ae = (re = d.value) == null ? void 0 : re.querySelectorAll("body > *")) != null ? ae : []).find((pe) => pe.id === "headlessui-portal-root" ? !1 : pe.contains(qe(E)) && pe instanceof HTMLElement)) != null ? ce : null;
  });
  NI(z, J);
  let $ = Oe(() => v.value ? !0 : p.value), G = Oe(() => {
    var re, ae, ce;
    return (ce = Array.from((ae = (re = d.value) == null ? void 0 : re.querySelectorAll("[data-headlessui-portal]")) != null ? ae : []).find((pe) => pe.contains(qe(E)) && pe instanceof HTMLElement)) != null ? ce : null;
  });
  NI(G, $), lpe({ type: "Dialog", enabled: Oe(() => h.value === 0), element: c, onUpdate: (re, ae) => {
    if (ae === "Dialog")
      return kr(re, { [fE.Add]: () => l.value += 1, [fE.Remove]: () => l.value -= 1 });
  } });
  let I = YR({ name: "DialogDescription", slot: Oe(() => ({ open: f.value })) }), W = Ne(null), k = { titleId: W, panelRef: Ne(null), dialogState: h, setTitleId(re) {
    W.value !== re && (W.value = re);
  }, close() {
    t("close", !1);
  } };
  $n(cE, k);
  let U = Oe(() => !(!p.value || v.value));
  zR(x, (re, ae) => {
    k.close(), br(() => ae == null ? void 0 : ae.focus());
  }, U);
  let Z = Oe(() => !(v.value || h.value !== 0));
  QB((s = d.value) == null ? void 0 : s.defaultView, "keydown", (re) => {
    Z.value && (re.defaultPrevented || re.key === rt.Escape && (re.preventDefault(), re.stopPropagation(), k.close()));
  });
  let Y = Oe(() => !(j.value || h.value !== 0 || y));
  return bpe(d, Y, (re) => {
    var ae;
    return { containers: [...(ae = re.containers) != null ? ae : [], x] };
  }), Qn((re) => {
    if (h.value !== 0)
      return;
    let ae = qe(c);
    if (!ae)
      return;
    let ce = new ResizeObserver((pe) => {
      for (let le of pe) {
        let ye = le.target.getBoundingClientRect();
        ye.x === 0 && ye.y === 0 && ye.width === 0 && ye.height === 0 && k.close();
      }
    });
    ce.observe(ae), re(() => ce.disconnect());
  }), () => {
    let { id: re, open: ae, initialFocus: ce, ...pe } = e, le = { ...r, ref: c, id: re, role: "dialog", "aria-modal": h.value === 0 ? !0 : void 0, "aria-labelledby": W.value, "aria-describedby": I.value }, ye = { open: h.value === 0 };
    return Ut(kI, { force: !0 }, () => [Ut(ipe, () => Ut(spe, { target: c.value }, () => Ut(kI, { force: !1 }, () => Ut(Bu, { initialFocus: ce, containers: x, features: p.value ? kr(C.value, { parent: Bu.features.RestoreFocus, leaf: Bu.features.All & ~Bu.features.FocusLock }) : Bu.features.None }, () => Ut(S, {}, () => fr({ ourProps: le, theirProps: { ...pe, ...r }, slot: ye, attrs: r, slots: n, visible: h.value === 0, features: Ma.RenderStrategy | Ma.Static, name: "Dialog" })))))), Ut(N)]);
  };
} }), _pe = it({ name: "DialogOverlay", props: { as: { type: [Object, String], default: "div" }, id: { type: String, default: () => `headlessui-dialog-overlay-${ri()}` } }, setup(e, { attrs: t, slots: r }) {
  let n = sq("DialogOverlay");
  function o(s) {
    s.target === s.currentTarget && (s.preventDefault(), s.stopPropagation(), n.close());
  }
  return () => {
    let { id: s, ...a } = e;
    return fr({ ourProps: { id: s, "aria-hidden": !0, onClick: o }, theirProps: a, slot: { open: n.dialogState.value === 0 }, attrs: t, slots: r, name: "DialogOverlay" });
  };
} }), CI = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function II(e) {
  var t, r;
  let n = (t = e.innerText) != null ? t : "", o = e.cloneNode(!0);
  if (!(o instanceof HTMLElement))
    return n;
  let s = !1;
  for (let l of o.querySelectorAll('[hidden],[aria-hidden],[role="img"]'))
    l.remove(), s = !0;
  let a = s ? (r = o.innerText) != null ? r : "" : n;
  return CI.test(a) && (a = a.replace(CI, "")), a;
}
function wpe(e) {
  let t = e.getAttribute("aria-label");
  if (typeof t == "string")
    return t.trim();
  let r = e.getAttribute("aria-labelledby");
  if (r) {
    let n = r.split(" ").map((o) => {
      let s = document.getElementById(o);
      if (s) {
        let a = s.getAttribute("aria-label");
        return typeof a == "string" ? a.trim() : II(s).trim();
      }
      return null;
    }).filter(Boolean);
    if (n.length > 0)
      return n.join(", ");
  }
  return II(e).trim();
}
function aq(e) {
  let t = Ne(""), r = Ne("");
  return () => {
    let n = qe(e);
    if (!n)
      return "";
    let o = n.innerText;
    if (t.value === o)
      return r.value;
    let s = wpe(n).trim().toLowerCase();
    return t.value = o, r.value = s, s;
  };
}
function Spe(e, t) {
  return e === t;
}
var Epe = ((e) => (e[e.Open = 0] = "Open", e[e.Closed = 1] = "Closed", e))(Epe || {}), xpe = ((e) => (e[e.Single = 0] = "Single", e[e.Multi = 1] = "Multi", e))(xpe || {}), Rpe = ((e) => (e[e.Pointer = 0] = "Pointer", e[e.Other = 1] = "Other", e))(Rpe || {});
function Ape(e) {
  requestAnimationFrame(() => requestAnimationFrame(e));
}
let lq = Symbol("ListboxContext");
function Wg(e) {
  let t = vr(lq, null);
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <Listbox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, Wg), r;
  }
  return t;
}
let Tpe = it({ name: "Listbox", emits: { "update:modelValue": (e) => !0 }, props: { as: { type: [Object, String], default: "template" }, disabled: { type: [Boolean], default: !1 }, by: { type: [String, Function], default: () => Spe }, horizontal: { type: [Boolean], default: !1 }, modelValue: { type: [Object, String, Number, Boolean], default: void 0 }, defaultValue: { type: [Object, String, Number, Boolean], default: void 0 }, form: { type: String, optional: !0 }, name: { type: String, optional: !0 }, multiple: { type: [Boolean], default: !1 } }, inheritAttrs: !1, setup(e, { slots: t, attrs: r, emit: n }) {
  let o = Ne(1), s = Ne(null), a = Ne(null), l = Ne(null), u = Ne([]), f = Ne(""), c = Ne(null), d = Ne(1);
  function h(x = (E) => E) {
    let E = c.value !== null ? u.value[c.value] : null, N = qg(x(u.value.slice()), (j) => qe(j.dataRef.domRef)), C = E ? N.indexOf(E) : null;
    return C === -1 && (C = null), { options: N, activeOptionIndex: C };
  }
  let p = Oe(() => e.multiple ? 1 : 0), [v, y] = KR(Oe(() => e.modelValue === void 0 ? kr(p.value, { 1: [], 0: void 0 }) : e.modelValue), (x) => n("update:modelValue", x), Oe(() => e.defaultValue)), w = { listboxState: o, value: v, mode: p, compare(x, E) {
    if (typeof e.by == "string") {
      let N = e.by;
      return (x == null ? void 0 : x[N]) === (E == null ? void 0 : E[N]);
    }
    return e.by(x, E);
  }, orientation: Oe(() => e.horizontal ? "horizontal" : "vertical"), labelRef: s, buttonRef: a, optionsRef: l, disabled: Oe(() => e.disabled), options: u, searchQuery: f, activeOptionIndex: c, activationTrigger: d, closeListbox() {
    e.disabled || o.value !== 1 && (o.value = 1, c.value = null);
  }, openListbox() {
    e.disabled || o.value !== 0 && (o.value = 0);
  }, goToOption(x, E, N) {
    if (e.disabled || o.value === 1)
      return;
    let C = h(), j = BB(x === Nt.Specific ? { focus: Nt.Specific, id: E } : { focus: x }, { resolveItems: () => C.options, resolveActiveIndex: () => C.activeOptionIndex, resolveId: (J) => J.id, resolveDisabled: (J) => J.dataRef.disabled });
    f.value = "", c.value = j, d.value = N ?? 1, u.value = C.options;
  }, search(x) {
    if (e.disabled || o.value === 1)
      return;
    let E = f.value !== "" ? 0 : 1;
    f.value += x.toLowerCase();
    let N = (c.value !== null ? u.value.slice(c.value + E).concat(u.value.slice(0, c.value + E)) : u.value).find((j) => j.dataRef.textValue.startsWith(f.value) && !j.dataRef.disabled), C = N ? u.value.indexOf(N) : -1;
    C === -1 || C === c.value || (c.value = C, d.value = 1);
  }, clearSearch() {
    e.disabled || o.value !== 1 && f.value !== "" && (f.value = "");
  }, registerOption(x, E) {
    let N = h((C) => [...C, { id: x, dataRef: E }]);
    u.value = N.options, c.value = N.activeOptionIndex;
  }, unregisterOption(x) {
    let E = h((N) => {
      let C = N.findIndex((j) => j.id === x);
      return C !== -1 && N.splice(C, 1), N;
    });
    u.value = E.options, c.value = E.activeOptionIndex, d.value = 1;
  }, select(x) {
    e.disabled || y(kr(p.value, { 0: () => x, 1: () => {
      let E = je(w.value.value).slice(), N = je(x), C = E.findIndex((j) => w.compare(N, je(j)));
      return C === -1 ? E.push(N) : E.splice(C, 1), E;
    } }));
  } };
  zR([a, l], (x, E) => {
    var N;
    w.closeListbox(), Bg(E, jg.Loose) || (x.preventDefault(), (N = qe(a)) == null || N.focus());
  }, Oe(() => o.value === 0)), $n(lq, w), WB(Oe(() => kr(o.value, { 0: dn.Open, 1: dn.Closed })));
  let S = Oe(() => {
    var x;
    return (x = qe(a)) == null ? void 0 : x.closest("form");
  });
  return Dt(() => {
    yr([S], () => {
      if (!S.value || e.defaultValue === void 0)
        return;
      function x() {
        w.select(e.defaultValue);
      }
      return S.value.addEventListener("reset", x), () => {
        var E;
        (E = S.value) == null || E.removeEventListener("reset", x);
      };
    }, { immediate: !0 });
  }), () => {
    let { name: x, modelValue: E, disabled: N, form: C, ...j } = e, J = { open: o.value === 0, disabled: N, value: v.value };
    return Ut(ut, [...x != null && v.value != null ? GR({ [x]: v.value }).map(([z, $]) => Ut(su, UR({ features: Oa.Hidden, key: z, as: "input", type: "hidden", hidden: !0, readOnly: !0, form: C, name: z, value: $ }))) : [], fr({ ourProps: {}, theirProps: { ...r, ...Dg(j, ["defaultValue", "onUpdate:modelValue", "horizontal", "multiple", "by"]) }, slot: J, slots: t, attrs: r, name: "Listbox" })]);
  };
} }), $pe = it({ name: "ListboxButton", props: { as: { type: [Object, String], default: "button" }, id: { type: String, default: () => `headlessui-listbox-button-${ri()}` } }, setup(e, { attrs: t, slots: r, expose: n }) {
  let o = Wg("ListboxButton");
  n({ el: o.buttonRef, $el: o.buttonRef });
  function s(f) {
    switch (f.key) {
      case rt.Space:
      case rt.Enter:
      case rt.ArrowDown:
        f.preventDefault(), o.openListbox(), br(() => {
          var c;
          (c = qe(o.optionsRef)) == null || c.focus({ preventScroll: !0 }), o.value.value || o.goToOption(Nt.First);
        });
        break;
      case rt.ArrowUp:
        f.preventDefault(), o.openListbox(), br(() => {
          var c;
          (c = qe(o.optionsRef)) == null || c.focus({ preventScroll: !0 }), o.value.value || o.goToOption(Nt.Last);
        });
        break;
    }
  }
  function a(f) {
    switch (f.key) {
      case rt.Space:
        f.preventDefault();
        break;
    }
  }
  function l(f) {
    o.disabled.value || (o.listboxState.value === 0 ? (o.closeListbox(), br(() => {
      var c;
      return (c = qe(o.buttonRef)) == null ? void 0 : c.focus({ preventScroll: !0 });
    })) : (f.preventDefault(), o.openListbox(), Ape(() => {
      var c;
      return (c = qe(o.optionsRef)) == null ? void 0 : c.focus({ preventScroll: !0 });
    })));
  }
  let u = VR(Oe(() => ({ as: e.as, type: t.type })), o.buttonRef);
  return () => {
    var f, c;
    let d = { open: o.listboxState.value === 0, disabled: o.disabled.value, value: o.value.value }, { id: h, ...p } = e, v = { ref: o.buttonRef, id: h, type: u.value, "aria-haspopup": "listbox", "aria-controls": (f = qe(o.optionsRef)) == null ? void 0 : f.id, "aria-expanded": o.disabled.value ? void 0 : o.listboxState.value === 0, "aria-labelledby": o.labelRef.value ? [(c = qe(o.labelRef)) == null ? void 0 : c.id, h].join(" ") : void 0, disabled: o.disabled.value === !0 ? !0 : void 0, onKeydown: s, onKeyup: a, onClick: l };
    return fr({ ourProps: v, theirProps: p, slot: d, attrs: t, slots: r, name: "ListboxButton" });
  };
} }), Npe = it({ name: "ListboxOptions", props: { as: { type: [Object, String], default: "ul" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, id: { type: String, default: () => `headlessui-listbox-options-${ri()}` } }, setup(e, { attrs: t, slots: r, expose: n }) {
  let o = Wg("ListboxOptions"), s = Ne(null);
  n({ el: o.optionsRef, $el: o.optionsRef });
  function a(f) {
    switch (s.value && clearTimeout(s.value), f.key) {
      case rt.Space:
        if (o.searchQuery.value !== "")
          return f.preventDefault(), f.stopPropagation(), o.search(f.key);
      case rt.Enter:
        if (f.preventDefault(), f.stopPropagation(), o.activeOptionIndex.value !== null) {
          let c = o.options.value[o.activeOptionIndex.value];
          o.select(c.dataRef.value);
        }
        o.mode.value === 0 && (o.closeListbox(), br(() => {
          var c;
          return (c = qe(o.buttonRef)) == null ? void 0 : c.focus({ preventScroll: !0 });
        }));
        break;
      case kr(o.orientation.value, { vertical: rt.ArrowDown, horizontal: rt.ArrowRight }):
        return f.preventDefault(), f.stopPropagation(), o.goToOption(Nt.Next);
      case kr(o.orientation.value, { vertical: rt.ArrowUp, horizontal: rt.ArrowLeft }):
        return f.preventDefault(), f.stopPropagation(), o.goToOption(Nt.Previous);
      case rt.Home:
      case rt.PageUp:
        return f.preventDefault(), f.stopPropagation(), o.goToOption(Nt.First);
      case rt.End:
      case rt.PageDown:
        return f.preventDefault(), f.stopPropagation(), o.goToOption(Nt.Last);
      case rt.Escape:
        f.preventDefault(), f.stopPropagation(), o.closeListbox(), br(() => {
          var c;
          return (c = qe(o.buttonRef)) == null ? void 0 : c.focus({ preventScroll: !0 });
        });
        break;
      case rt.Tab:
        f.preventDefault(), f.stopPropagation();
        break;
      default:
        f.key.length === 1 && (o.search(f.key), s.value = setTimeout(() => o.clearSearch(), 350));
        break;
    }
  }
  let l = HR(), u = Oe(() => l !== null ? (l.value & dn.Open) === dn.Open : o.listboxState.value === 0);
  return () => {
    var f, c, d, h;
    let p = { open: o.listboxState.value === 0 }, { id: v, ...y } = e, w = { "aria-activedescendant": o.activeOptionIndex.value === null || (f = o.options.value[o.activeOptionIndex.value]) == null ? void 0 : f.id, "aria-multiselectable": o.mode.value === 1 ? !0 : void 0, "aria-labelledby": (h = (c = qe(o.labelRef)) == null ? void 0 : c.id) != null ? h : (d = qe(o.buttonRef)) == null ? void 0 : d.id, "aria-orientation": o.orientation.value, id: v, onKeydown: a, role: "listbox", tabIndex: 0, ref: o.optionsRef };
    return fr({ ourProps: w, theirProps: y, slot: p, attrs: t, slots: r, features: Ma.RenderStrategy | Ma.Static, visible: u.value, name: "ListboxOptions" });
  };
} }), kpe = it({ name: "ListboxOption", props: { as: { type: [Object, String], default: "li" }, value: { type: [Object, String, Number, Boolean] }, disabled: { type: Boolean, default: !1 }, id: { type: String, default: () => `headlessui-listbox.option-${ri()}` } }, setup(e, { slots: t, attrs: r, expose: n }) {
  let o = Wg("ListboxOption"), s = Ne(null);
  n({ el: s, $el: s });
  let a = Oe(() => o.activeOptionIndex.value !== null ? o.options.value[o.activeOptionIndex.value].id === e.id : !1), l = Oe(() => kr(o.mode.value, { 0: () => o.compare(je(o.value.value), je(e.value)), 1: () => je(o.value.value).some((S) => o.compare(je(S), je(e.value))) })), u = Oe(() => kr(o.mode.value, { 1: () => {
    var S;
    let x = je(o.value.value);
    return ((S = o.options.value.find((E) => x.some((N) => o.compare(je(N), je(E.dataRef.value))))) == null ? void 0 : S.id) === e.id;
  }, 0: () => l.value })), f = aq(s), c = Oe(() => ({ disabled: e.disabled, value: e.value, get textValue() {
    return f();
  }, domRef: s }));
  Dt(() => o.registerOption(e.id, c)), xn(() => o.unregisterOption(e.id)), Dt(() => {
    yr([o.listboxState, l], () => {
      o.listboxState.value === 0 && l.value && kr(o.mode.value, { 1: () => {
        u.value && o.goToOption(Nt.Specific, e.id);
      }, 0: () => {
        o.goToOption(Nt.Specific, e.id);
      } });
    }, { immediate: !0 });
  }), Qn(() => {
    o.listboxState.value === 0 && a.value && o.activationTrigger.value !== 0 && br(() => {
      var S, x;
      return (x = (S = qe(s)) == null ? void 0 : S.scrollIntoView) == null ? void 0 : x.call(S, { block: "nearest" });
    });
  });
  function d(S) {
    if (e.disabled)
      return S.preventDefault();
    o.select(e.value), o.mode.value === 0 && (o.closeListbox(), br(() => {
      var x;
      return (x = qe(o.buttonRef)) == null ? void 0 : x.focus({ preventScroll: !0 });
    }));
  }
  function h() {
    if (e.disabled)
      return o.goToOption(Nt.Nothing);
    o.goToOption(Nt.Specific, e.id);
  }
  let p = XB();
  function v(S) {
    p.update(S);
  }
  function y(S) {
    p.wasMoved(S) && (e.disabled || a.value || o.goToOption(Nt.Specific, e.id, 0));
  }
  function w(S) {
    p.wasMoved(S) && (e.disabled || a.value && o.goToOption(Nt.Nothing));
  }
  return () => {
    let { disabled: S } = e, x = { active: a.value, selected: l.value, disabled: S }, { id: E, value: N, disabled: C, ...j } = e, J = { id: E, ref: s, role: "option", tabIndex: S === !0 ? void 0 : -1, "aria-disabled": S === !0 ? !0 : void 0, "aria-selected": l.value, disabled: void 0, onClick: d, onFocus: h, onPointerenter: v, onMouseenter: v, onPointermove: y, onMousemove: y, onPointerleave: w, onMouseleave: w };
    return fr({ ourProps: J, theirProps: j, slot: x, attrs: r, slots: t, name: "ListboxOption" });
  };
} });
var Cpe = ((e) => (e[e.Open = 0] = "Open", e[e.Closed = 1] = "Closed", e))(Cpe || {}), Ipe = ((e) => (e[e.Pointer = 0] = "Pointer", e[e.Other = 1] = "Other", e))(Ipe || {});
function Mpe(e) {
  requestAnimationFrame(() => requestAnimationFrame(e));
}
let uq = Symbol("MenuContext");
function Ug(e) {
  let t = vr(uq, null);
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, Ug), r;
  }
  return t;
}
let Ope = it({ name: "Menu", props: { as: { type: [Object, String], default: "template" } }, setup(e, { slots: t, attrs: r }) {
  let n = Ne(1), o = Ne(null), s = Ne(null), a = Ne([]), l = Ne(""), u = Ne(null), f = Ne(1);
  function c(h = (p) => p) {
    let p = u.value !== null ? a.value[u.value] : null, v = qg(h(a.value.slice()), (w) => qe(w.dataRef.domRef)), y = p ? v.indexOf(p) : null;
    return y === -1 && (y = null), { items: v, activeItemIndex: y };
  }
  let d = { menuState: n, buttonRef: o, itemsRef: s, items: a, searchQuery: l, activeItemIndex: u, activationTrigger: f, closeMenu: () => {
    n.value = 1, u.value = null;
  }, openMenu: () => n.value = 0, goToItem(h, p, v) {
    let y = c(), w = BB(h === Nt.Specific ? { focus: Nt.Specific, id: p } : { focus: h }, { resolveItems: () => y.items, resolveActiveIndex: () => y.activeItemIndex, resolveId: (S) => S.id, resolveDisabled: (S) => S.dataRef.disabled });
    l.value = "", u.value = w, f.value = v ?? 1, a.value = y.items;
  }, search(h) {
    let p = l.value !== "" ? 0 : 1;
    l.value += h.toLowerCase();
    let v = (u.value !== null ? a.value.slice(u.value + p).concat(a.value.slice(0, u.value + p)) : a.value).find((w) => w.dataRef.textValue.startsWith(l.value) && !w.dataRef.disabled), y = v ? a.value.indexOf(v) : -1;
    y === -1 || y === u.value || (u.value = y, f.value = 1);
  }, clearSearch() {
    l.value = "";
  }, registerItem(h, p) {
    let v = c((y) => [...y, { id: h, dataRef: p }]);
    a.value = v.items, u.value = v.activeItemIndex, f.value = 1;
  }, unregisterItem(h) {
    let p = c((v) => {
      let y = v.findIndex((w) => w.id === h);
      return y !== -1 && v.splice(y, 1), v;
    });
    a.value = p.items, u.value = p.activeItemIndex, f.value = 1;
  } };
  return zR([o, s], (h, p) => {
    var v;
    d.closeMenu(), Bg(p, jg.Loose) || (h.preventDefault(), (v = qe(o)) == null || v.focus());
  }, Oe(() => n.value === 0)), $n(uq, d), WB(Oe(() => kr(n.value, { 0: dn.Open, 1: dn.Closed }))), () => {
    let h = { open: n.value === 0, close: d.closeMenu };
    return fr({ ourProps: {}, theirProps: e, slot: h, slots: t, attrs: r, name: "Menu" });
  };
} }), Lpe = it({ name: "MenuButton", props: { disabled: { type: Boolean, default: !1 }, as: { type: [Object, String], default: "button" }, id: { type: String, default: () => `headlessui-menu-button-${ri()}` } }, setup(e, { attrs: t, slots: r, expose: n }) {
  let o = Ug("MenuButton");
  n({ el: o.buttonRef, $el: o.buttonRef });
  function s(f) {
    switch (f.key) {
      case rt.Space:
      case rt.Enter:
      case rt.ArrowDown:
        f.preventDefault(), f.stopPropagation(), o.openMenu(), br(() => {
          var c;
          (c = qe(o.itemsRef)) == null || c.focus({ preventScroll: !0 }), o.goToItem(Nt.First);
        });
        break;
      case rt.ArrowUp:
        f.preventDefault(), f.stopPropagation(), o.openMenu(), br(() => {
          var c;
          (c = qe(o.itemsRef)) == null || c.focus({ preventScroll: !0 }), o.goToItem(Nt.Last);
        });
        break;
    }
  }
  function a(f) {
    switch (f.key) {
      case rt.Space:
        f.preventDefault();
        break;
    }
  }
  function l(f) {
    e.disabled || (o.menuState.value === 0 ? (o.closeMenu(), br(() => {
      var c;
      return (c = qe(o.buttonRef)) == null ? void 0 : c.focus({ preventScroll: !0 });
    })) : (f.preventDefault(), o.openMenu(), Mpe(() => {
      var c;
      return (c = qe(o.itemsRef)) == null ? void 0 : c.focus({ preventScroll: !0 });
    })));
  }
  let u = VR(Oe(() => ({ as: e.as, type: t.type })), o.buttonRef);
  return () => {
    var f;
    let c = { open: o.menuState.value === 0 }, { id: d, ...h } = e, p = { ref: o.buttonRef, id: d, type: u.value, "aria-haspopup": "menu", "aria-controls": (f = qe(o.itemsRef)) == null ? void 0 : f.id, "aria-expanded": e.disabled ? void 0 : o.menuState.value === 0, onKeydown: s, onKeyup: a, onClick: l };
    return fr({ ourProps: p, theirProps: h, slot: c, attrs: t, slots: r, name: "MenuButton" });
  };
} }), Ppe = it({ name: "MenuItems", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, id: { type: String, default: () => `headlessui-menu-items-${ri()}` } }, setup(e, { attrs: t, slots: r, expose: n }) {
  let o = Ug("MenuItems"), s = Ne(null);
  n({ el: o.itemsRef, $el: o.itemsRef }), UB({ container: Oe(() => qe(o.itemsRef)), enabled: Oe(() => o.menuState.value === 0), accept(c) {
    return c.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : c.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(c) {
    c.setAttribute("role", "none");
  } });
  function a(c) {
    var d;
    switch (s.value && clearTimeout(s.value), c.key) {
      case rt.Space:
        if (o.searchQuery.value !== "")
          return c.preventDefault(), c.stopPropagation(), o.search(c.key);
      case rt.Enter:
        if (c.preventDefault(), c.stopPropagation(), o.activeItemIndex.value !== null) {
          let h = o.items.value[o.activeItemIndex.value];
          (d = qe(h.dataRef.domRef)) == null || d.click();
        }
        o.closeMenu(), VB(qe(o.buttonRef));
        break;
      case rt.ArrowDown:
        return c.preventDefault(), c.stopPropagation(), o.goToItem(Nt.Next);
      case rt.ArrowUp:
        return c.preventDefault(), c.stopPropagation(), o.goToItem(Nt.Previous);
      case rt.Home:
      case rt.PageUp:
        return c.preventDefault(), c.stopPropagation(), o.goToItem(Nt.First);
      case rt.End:
      case rt.PageDown:
        return c.preventDefault(), c.stopPropagation(), o.goToItem(Nt.Last);
      case rt.Escape:
        c.preventDefault(), c.stopPropagation(), o.closeMenu(), br(() => {
          var h;
          return (h = qe(o.buttonRef)) == null ? void 0 : h.focus({ preventScroll: !0 });
        });
        break;
      case rt.Tab:
        c.preventDefault(), c.stopPropagation(), o.closeMenu(), br(() => Khe(qe(o.buttonRef), c.shiftKey ? Qr.Previous : Qr.Next));
        break;
      default:
        c.key.length === 1 && (o.search(c.key), s.value = setTimeout(() => o.clearSearch(), 350));
        break;
    }
  }
  function l(c) {
    switch (c.key) {
      case rt.Space:
        c.preventDefault();
        break;
    }
  }
  let u = HR(), f = Oe(() => u !== null ? (u.value & dn.Open) === dn.Open : o.menuState.value === 0);
  return () => {
    var c, d;
    let h = { open: o.menuState.value === 0 }, { id: p, ...v } = e, y = { "aria-activedescendant": o.activeItemIndex.value === null || (c = o.items.value[o.activeItemIndex.value]) == null ? void 0 : c.id, "aria-labelledby": (d = qe(o.buttonRef)) == null ? void 0 : d.id, id: p, onKeydown: a, onKeyup: l, role: "menu", tabIndex: 0, ref: o.itemsRef };
    return fr({ ourProps: y, theirProps: v, slot: h, attrs: t, slots: r, features: Ma.RenderStrategy | Ma.Static, visible: f.value, name: "MenuItems" });
  };
} }), MI = it({ name: "MenuItem", inheritAttrs: !1, props: { as: { type: [Object, String], default: "template" }, disabled: { type: Boolean, default: !1 }, id: { type: String, default: () => `headlessui-menu-item-${ri()}` } }, setup(e, { slots: t, attrs: r, expose: n }) {
  let o = Ug("MenuItem"), s = Ne(null);
  n({ el: s, $el: s });
  let a = Oe(() => o.activeItemIndex.value !== null ? o.items.value[o.activeItemIndex.value].id === e.id : !1), l = aq(s), u = Oe(() => ({ disabled: e.disabled, get textValue() {
    return l();
  }, domRef: s }));
  Dt(() => o.registerItem(e.id, u)), xn(() => o.unregisterItem(e.id)), Qn(() => {
    o.menuState.value === 0 && a.value && o.activationTrigger.value !== 0 && br(() => {
      var y, w;
      return (w = (y = qe(s)) == null ? void 0 : y.scrollIntoView) == null ? void 0 : w.call(y, { block: "nearest" });
    });
  });
  function f(y) {
    if (e.disabled)
      return y.preventDefault();
    o.closeMenu(), VB(qe(o.buttonRef));
  }
  function c() {
    if (e.disabled)
      return o.goToItem(Nt.Nothing);
    o.goToItem(Nt.Specific, e.id);
  }
  let d = XB();
  function h(y) {
    d.update(y);
  }
  function p(y) {
    d.wasMoved(y) && (e.disabled || a.value || o.goToItem(Nt.Specific, e.id, 0));
  }
  function v(y) {
    d.wasMoved(y) && (e.disabled || a.value && o.goToItem(Nt.Nothing));
  }
  return () => {
    let { disabled: y } = e, w = { active: a.value, disabled: y, close: o.closeMenu }, { id: S, ...x } = e;
    return fr({ ourProps: { id: S, ref: s, role: "menuitem", tabIndex: y === !0 ? void 0 : -1, "aria-disabled": y === !0 ? !0 : void 0, disabled: void 0, onClick: f, onFocus: c, onPointerenter: h, onMouseenter: h, onPointermove: p, onMousemove: p, onPointerleave: v, onMouseleave: v }, theirProps: { ...r, ...x }, slot: w, attrs: r, slots: t, name: "MenuItem" });
  };
} }), Dpe = Symbol("LabelContext");
function fq({ slot: e = {}, name: t = "Label", props: r = {} } = {}) {
  let n = Ne([]);
  function o(s) {
    return n.value.push(s), () => {
      let a = n.value.indexOf(s);
      a !== -1 && n.value.splice(a, 1);
    };
  }
  return $n(Dpe, { register: o, slot: e, name: t, props: r }), Oe(() => n.value.length > 0 ? n.value.join(" ") : void 0);
}
function Fpe(e, t) {
  return e === t;
}
let cq = Symbol("RadioGroupContext");
function dq(e) {
  let t = vr(cq, null);
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <RadioGroup /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, dq), r;
  }
  return t;
}
let jpe = it({ name: "RadioGroup", emits: { "update:modelValue": (e) => !0 }, props: { as: { type: [Object, String], default: "div" }, disabled: { type: [Boolean], default: !1 }, by: { type: [String, Function], default: () => Fpe }, modelValue: { type: [Object, String, Number, Boolean], default: void 0 }, defaultValue: { type: [Object, String, Number, Boolean], default: void 0 }, form: { type: String, optional: !0 }, name: { type: String, optional: !0 }, id: { type: String, default: () => `headlessui-radiogroup-${ri()}` } }, inheritAttrs: !1, setup(e, { emit: t, attrs: r, slots: n, expose: o }) {
  let s = Ne(null), a = Ne([]), l = fq({ name: "RadioGroupLabel" }), u = YR({ name: "RadioGroupDescription" });
  o({ el: s, $el: s });
  let [f, c] = KR(Oe(() => e.modelValue), (v) => t("update:modelValue", v), Oe(() => e.defaultValue)), d = { options: a, value: f, disabled: Oe(() => e.disabled), firstOption: Oe(() => a.value.find((v) => !v.propsRef.disabled)), containsCheckedOption: Oe(() => a.value.some((v) => d.compare(je(v.propsRef.value), je(e.modelValue)))), compare(v, y) {
    if (typeof e.by == "string") {
      let w = e.by;
      return (v == null ? void 0 : v[w]) === (y == null ? void 0 : y[w]);
    }
    return e.by(v, y);
  }, change(v) {
    var y;
    if (e.disabled || d.compare(je(f.value), je(v)))
      return !1;
    let w = (y = a.value.find((S) => d.compare(je(S.propsRef.value), je(v)))) == null ? void 0 : y.propsRef;
    return w != null && w.disabled ? !1 : (c(v), !0);
  }, registerOption(v) {
    a.value.push(v), a.value = qg(a.value, (y) => y.element);
  }, unregisterOption(v) {
    let y = a.value.findIndex((w) => w.id === v);
    y !== -1 && a.value.splice(y, 1);
  } };
  $n(cq, d), UB({ container: Oe(() => qe(s)), accept(v) {
    return v.getAttribute("role") === "radio" ? NodeFilter.FILTER_REJECT : v.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(v) {
    v.setAttribute("role", "none");
  } });
  function h(v) {
    if (!s.value || !s.value.contains(v.target))
      return;
    let y = a.value.filter((w) => w.propsRef.disabled === !1).map((w) => w.element);
    switch (v.key) {
      case rt.Enter:
        YB(v.currentTarget);
        break;
      case rt.ArrowLeft:
      case rt.ArrowUp:
        if (v.preventDefault(), v.stopPropagation(), ma(y, Qr.Previous | Qr.WrapAround) === Uh.Success) {
          let w = a.value.find((S) => {
            var x;
            return S.element === ((x = Yn(s)) == null ? void 0 : x.activeElement);
          });
          w && d.change(w.propsRef.value);
        }
        break;
      case rt.ArrowRight:
      case rt.ArrowDown:
        if (v.preventDefault(), v.stopPropagation(), ma(y, Qr.Next | Qr.WrapAround) === Uh.Success) {
          let w = a.value.find((S) => {
            var x;
            return S.element === ((x = Yn(S.element)) == null ? void 0 : x.activeElement);
          });
          w && d.change(w.propsRef.value);
        }
        break;
      case rt.Space:
        {
          v.preventDefault(), v.stopPropagation();
          let w = a.value.find((S) => {
            var x;
            return S.element === ((x = Yn(S.element)) == null ? void 0 : x.activeElement);
          });
          w && d.change(w.propsRef.value);
        }
        break;
    }
  }
  let p = Oe(() => {
    var v;
    return (v = qe(s)) == null ? void 0 : v.closest("form");
  });
  return Dt(() => {
    yr([p], () => {
      if (!p.value || e.defaultValue === void 0)
        return;
      function v() {
        d.change(e.defaultValue);
      }
      return p.value.addEventListener("reset", v), () => {
        var y;
        (y = p.value) == null || y.removeEventListener("reset", v);
      };
    }, { immediate: !0 });
  }), () => {
    let { disabled: v, name: y, id: w, form: S, ...x } = e, E = { ref: s, id: w, role: "radiogroup", "aria-labelledby": l.value, "aria-describedby": u.value, onKeydown: h };
    return Ut(ut, [...y != null && f.value != null ? GR({ [y]: f.value }).map(([N, C]) => Ut(su, UR({ features: Oa.Hidden, key: N, as: "input", type: "hidden", hidden: !0, readOnly: !0, form: S, name: N, value: C }))) : [], fr({ ourProps: E, theirProps: { ...r, ...Dg(x, ["modelValue", "defaultValue", "by"]) }, slot: {}, attrs: r, slots: n, name: "RadioGroup" })]);
  };
} });
var Bpe = ((e) => (e[e.Empty = 1] = "Empty", e[e.Active = 2] = "Active", e))(Bpe || {});
let qpe = it({ name: "RadioGroupOption", props: { as: { type: [Object, String], default: "div" }, value: { type: [Object, String, Number, Boolean] }, disabled: { type: Boolean, default: !1 }, id: { type: String, default: () => `headlessui-radiogroup-option-${ri()}` } }, setup(e, { attrs: t, slots: r, expose: n }) {
  let o = dq("RadioGroupOption"), s = fq({ name: "RadioGroupLabel" }), a = YR({ name: "RadioGroupDescription" }), l = Ne(null), u = Oe(() => ({ value: e.value, disabled: e.disabled })), f = Ne(1);
  n({ el: l, $el: l });
  let c = Oe(() => qe(l));
  Dt(() => o.registerOption({ id: e.id, element: c, propsRef: u })), xn(() => o.unregisterOption(e.id));
  let d = Oe(() => {
    var x;
    return ((x = o.firstOption.value) == null ? void 0 : x.id) === e.id;
  }), h = Oe(() => o.disabled.value || e.disabled), p = Oe(() => o.compare(je(o.value.value), je(e.value))), v = Oe(() => h.value ? -1 : p.value || !o.containsCheckedOption.value && d.value ? 0 : -1);
  function y() {
    var x;
    o.change(e.value) && (f.value |= 2, (x = qe(l)) == null || x.focus());
  }
  function w() {
    f.value |= 2;
  }
  function S() {
    f.value &= -3;
  }
  return () => {
    let { id: x, value: E, disabled: N, ...C } = e, j = { checked: p.value, disabled: h.value, active: !!(f.value & 2) }, J = { id: x, ref: l, role: "radio", "aria-checked": p.value ? "true" : "false", "aria-labelledby": s.value, "aria-describedby": a.value, "aria-disabled": h.value ? !0 : void 0, tabIndex: v.value, onClick: h.value ? void 0 : y, onFocus: h.value ? void 0 : w, onBlur: h.value ? void 0 : S };
    return fr({ ourProps: J, theirProps: C, slot: j, attrs: t, slots: r, name: "RadioGroupOption" });
  };
} }), Wpe = Symbol("GroupContext"), Upe = it({ name: "Switch", emits: { "update:modelValue": (e) => !0 }, props: { as: { type: [Object, String], default: "button" }, modelValue: { type: Boolean, default: void 0 }, defaultChecked: { type: Boolean, optional: !0 }, form: { type: String, optional: !0 }, name: { type: String, optional: !0 }, value: { type: String, optional: !0 }, id: { type: String, default: () => `headlessui-switch-${ri()}` } }, inheritAttrs: !1, setup(e, { emit: t, attrs: r, slots: n, expose: o }) {
  let s = vr(Wpe, null), [a, l] = KR(Oe(() => e.modelValue), (w) => t("update:modelValue", w), Oe(() => e.defaultChecked));
  function u() {
    l(!a.value);
  }
  let f = Ne(null), c = s === null ? f : s.switchRef, d = VR(Oe(() => ({ as: e.as, type: r.type })), c);
  o({ el: c, $el: c });
  function h(w) {
    w.preventDefault(), u();
  }
  function p(w) {
    w.key === rt.Space ? (w.preventDefault(), u()) : w.key === rt.Enter && YB(w.currentTarget);
  }
  function v(w) {
    w.preventDefault();
  }
  let y = Oe(() => {
    var w, S;
    return (S = (w = qe(c)) == null ? void 0 : w.closest) == null ? void 0 : S.call(w, "form");
  });
  return Dt(() => {
    yr([y], () => {
      if (!y.value || e.defaultChecked === void 0)
        return;
      function w() {
        l(e.defaultChecked);
      }
      return y.value.addEventListener("reset", w), () => {
        var S;
        (S = y.value) == null || S.removeEventListener("reset", w);
      };
    }, { immediate: !0 });
  }), () => {
    let { id: w, name: S, value: x, form: E, ...N } = e, C = { checked: a.value }, j = { id: w, ref: c, role: "switch", type: d.value, tabIndex: 0, "aria-checked": a.value, "aria-labelledby": s == null ? void 0 : s.labelledby.value, "aria-describedby": s == null ? void 0 : s.describedby.value, onClick: h, onKeyup: p, onKeypress: v };
    return Ut(ut, [S != null && a.value != null ? Ut(su, UR({ features: Oa.Hidden, as: "input", type: "checkbox", hidden: !0, readOnly: !0, checked: a.value, form: E, name: S, value: x })) : null, fr({ ourProps: j, theirProps: { ...r, ...Dg(N, ["modelValue", "defaultChecked"]) }, slot: C, attrs: r, slots: n, name: "Switch" })]);
  };
} });
const Hpe = { class: "flex items-center justify-center min-h-screen" }, Vpe = { class: "modal-card" }, zpe = {
  name: "SpexDialog"
}, hq = /* @__PURE__ */ it({
  ...zpe,
  props: {
    open: { type: Boolean }
  },
  emits: ["close"],
  setup(e, { emit: t }) {
    return (r, n) => (we(), xt(De(mpe), {
      open: r.open,
      onClose: n[0] || (n[0] = (o) => r.$emit("close")),
      class: "fixed inset-0 z-10 overflow-y-auto"
    }, {
      default: Ge(() => [
        oe("div", Hpe, [
          xe(De(_pe), { class: "fixed inset-0 bg-black opacity-50" }),
          oe("div", Vpe, [
            io(r.$slots, "default")
          ])
        ])
      ]),
      _: 3
    }, 8, ["open"]));
  }
}), Gpe = { class: "group inline-block relative" }, Kpe = {
  key: 0,
  class: "invisible group-hover:visible absolute z-10 bottom-full left-1/2 -translate-x-1/2 -translate-y-1 delay-300"
}, Ype = { class: "bg-gray-800 text-white font-normal text-sm rounded py-1 px-3 whitespace-nowrap" }, Xpe = /* @__PURE__ */ oe("svg", {
  class: "absolute h-3 w-full left-0 top-full fill-current text-gray-800",
  viewBox: "0 0 255 255"
}, [
  /* @__PURE__ */ oe("polygon", { points: "0,0 127.5,127.5 255,0" })
], -1), Jpe = {
  name: "SpexTooltip"
}, Wr = /* @__PURE__ */ it({
  ...Jpe,
  props: {
    label: {},
    position: {}
  },
  setup(e) {
    return (t, r) => (we(), $e("div", Gpe, [
      t.label ? (we(), $e("div", Kpe, [
        oe("div", Ype, [
          tn(gt(t.label) + " ", 1),
          Xpe
        ])
      ])) : bt("", !0),
      oe("div", null, [
        io(t.$slots, "default")
      ])
    ]));
  }
}), pq = (e) => (B4("data-v-a0722119"), e = e(), q4(), e), Qpe = { class: "modal-card-head py-4" }, Zpe = /* @__PURE__ */ pq(() => /* @__PURE__ */ oe("h3", { style: { color: "grey" } }, "Generated SHACL shapes", -1)), ege = { class: "ml-auto" }, tge = { class: "modal-card-body overflow-y-hidden flex flex-col pb-0" }, rge = { class: "flex justify-between" }, nge = { class: "flex items-center gap-2" }, ige = /* @__PURE__ */ pq(() => /* @__PURE__ */ oe("span", null, "Copy", -1)), oge = {
  name: "ModalShacl"
}, sge = /* @__PURE__ */ it({
  ...oge,
  props: {
    datamodel: {},
    loadShacl: {}
  },
  emits: ["close", "open-load-shacl"],
  setup(e, { emit: t }) {
    const r = e, n = co.getInstance(), o = Oe(() => n.prefixes.reduce((p, { prefix: v, namespace: y }) => ({ ...p, [v]: y }), {})), s = Oe(() => [...n.dataModelToSHACL(r.datamodel).dataset]), a = Ne(null), l = Ne(null), u = Ne([
      { label: "JSON-LD", value: "application/ld+json" },
      { label: "Turtle", value: "text/turtle" },
      { label: "N-Triples", value: "application/n-triples" }
    ]), f = Ne("application/ld+json"), c = Ne(["sh", "schema"].join(","));
    async function d() {
      const p = l.value.codeMirror.value;
      await navigator.clipboard.writeText(p), a.value = "Copied 👍", setTimeout(() => {
        a.value = null;
      }, 3e3);
    }
    function h() {
      t("open-load-shacl"), t("close");
    }
    return (p, v) => {
      const y = T1("rdf-editor");
      return we(), xt(hq, {
        onClose: v[2] || (v[2] = (w) => p.$emit("close"))
      }, {
        default: Ge(() => [
          oe("div", Qpe, [
            Zpe,
            oe("div", ege, [
              xe(Wr, {
                label: "Load SHACL shapes",
                position: "bottom",
                class: "mr-4"
              }, {
                default: Ge(() => [
                  oe("button", {
                    class: "button",
                    onClick: h
                  }, [
                    xe(De(WH), { class: "icon" })
                  ])
                ]),
                _: 1
              }),
              xe(Wr, {
                label: "Close",
                position: "bottom"
              }, {
                default: Ge(() => [
                  oe("button", {
                    class: "button is-light",
                    onClick: v[0] || (v[0] = (w) => p.$emit("close"))
                  }, [
                    xe(De(as), { class: "icon" })
                  ])
                ]),
                _: 1
              })
            ])
          ]),
          oe("div", tge, [
            oe("div", rge, [
              xe(De(jpe), {
                modelValue: f.value,
                "onUpdate:modelValue": v[1] || (v[1] = (w) => f.value = w),
                class: "field has-addons"
              }, {
                default: Ge(() => [
                  (we(!0), $e(ut, null, gr(u.value, (w) => (we(), xt(De(qpe), {
                    key: w.value,
                    value: w.value,
                    class: "control"
                  }, {
                    default: Ge(({ checked: S }) => [
                      oe("span", {
                        class: lr(["button", S ? "is-primary" : ""])
                      }, gt(w.label), 3)
                    ]),
                    _: 2
                  }, 1032, ["value"]))), 128))
                ]),
                _: 1
              }, 8, ["modelValue"]),
              oe("div", nge, [
                jr(oe("span", { class: "text-green-500" }, gt(a.value), 513), [
                  [Ea, a.value]
                ]),
                oe("button", {
                  class: "button",
                  onClick: d
                }, [
                  xe(De(d3), { class: "icon" }),
                  ige
                ])
              ])
            ]),
            xe(y, {
              format: f.value,
              ".quads": s.value,
              ".prefixes": c.value,
              ".customPrefixes": o.value,
              ref_key: "snippet",
              ref: l,
              class: "overflow-y-auto"
            }, null, 8, ["format", ".quads", ".prefixes", ".customPrefixes"])
          ])
        ]),
        _: 1
      });
    };
  }
}), ni = (e, t) => {
  const r = e.__vccOpts || e;
  for (const [n, o] of t)
    r[n] = o;
  return r;
}, age = /* @__PURE__ */ ni(sge, [["__scopeId", "data-v-a0722119"]]), lge = {
  name: "ModalShaclLoad",
  props: ["load", "endpoint"],
  emits: ["close"],
  components: { SpexDialog: hq, XMarkIcon: as },
  data() {
    return {
      data: "",
      error: null
    };
  },
  methods: {
    async onSubmit() {
      if (this.data)
        try {
          const e = Gt.formast.parsers.import("text/turtle", M8.Readable.from(this.data)), t = await Gt.dataset().import(e), r = Gt.clownface({ dataset: t, term: Jo.DefaultShapes }).in(Un.type).in(Jo.shape);
          if (!r.term)
            throw new Error("No node with spex:shape pointing to a spex:DefaultShapes found");
          const n = this.endpoint.dataModelFromSHACL(r);
          this.load(n), this.$emit("close");
        } catch (e) {
          this.error = e.toString();
        }
    }
  }
}, uge = { class: "modal-card-head py-4" }, fge = /* @__PURE__ */ oe("h3", { style: { color: "grey" } }, "Load SHACL shapes", -1), cge = { class: "ml-auto" }, dge = { class: "modal-card-body" }, hge = { class: "field" }, pge = {
  key: 0,
  class: "help is-danger"
}, gge = /* @__PURE__ */ oe("p", {
  class: "help",
  style: { color: "grey" }
}, [
  /* @__PURE__ */ tn(" Paste your SHACL shapes in "),
  /* @__PURE__ */ oe("strong", null, "Turtle"),
  /* @__PURE__ */ tn(" format in the field above. ")
], -1), bge = /* @__PURE__ */ oe("div", { class: "field" }, [
  /* @__PURE__ */ oe("button", {
    class: "button is-primary",
    type: "submit"
  }, "Load")
], -1);
function yge(e, t, r, n, o, s) {
  const a = T1("XMarkIcon"), l = T1("SpexDialog");
  return we(), xt(l, {
    onClose: t[3] || (t[3] = (u) => e.$emit("close"))
  }, {
    default: Ge(() => [
      oe("div", uge, [
        fge,
        oe("div", cge, [
          oe("button", {
            class: "button is-light",
            title: "Close",
            onClick: t[0] || (t[0] = (u) => e.$emit("close"))
          }, [
            xe(a, { class: "icon" })
          ])
        ])
      ]),
      oe("div", dge, [
        oe("form", {
          onSubmit: t[2] || (t[2] = CH((...u) => s.onSubmit && s.onSubmit(...u), ["prevent"]))
        }, [
          oe("div", hge, [
            jr(oe("textarea", {
              type: "textarea",
              class: lr(["textarea", { "is-danger": o.error }]),
              "onUpdate:modelValue": t[1] || (t[1] = (u) => o.data = u)
            }, null, 2), [
              [Vo, o.data]
            ]),
            o.error ? (we(), $e("p", pge, gt(o.error), 1)) : bt("", !0),
            gge
          ]),
          bge
        ], 32)
      ])
    ]),
    _: 1
  });
}
const vge = /* @__PURE__ */ ni(lge, [["render", yge]]), mge = { class: "flex justify-center flex-row gap-1" }, _ge = { class: "relative z-50 text-right flex justify-center flex-row" }, wge = { class: "flex h-full justify-center" }, Sge = { class: "px-1 py-1" }, Ege = {
  name: "ShapeComponentActions"
}, xge = /* @__PURE__ */ it({
  ...Ege,
  props: {
    table: {}
  },
  emits: ["hide", "explore", "export"],
  setup(e, { emit: t }) {
    const r = Ne(null);
    function n(o) {
      t("export", o), r.value = "👍", setTimeout(() => {
        r.value = null;
      }, 1500);
    }
    return (o, s) => (we(), $e("div", mge, [
      oe("div", null, [
        oe("div", _ge, [
          xe(De(Ope), {
            as: "div",
            class: "relative inline-block"
          }, {
            default: Ge(() => [
              oe("div", wge, [
                xe(De(Lpe), {
                  style: { "font-size": "0.75rem", height: "2.5em", width: "2.5em", "border-radius": "2px", "padding-top": "1px" },
                  class: "inline-flex w-full justify-center rounded-md bg-black bg-opacity-20 text-sm font-medium text-white hover:bg-opacity-30 focus:outline-none focus-visible:ring-2 focus-visible:ring-white focus-visible:ring-opacity-75"
                }, {
                  default: Ge(() => [
                    xe(De(KH), {
                      class: "h-7 w-7 --color-primary-300 hover:text-orange",
                      "aria-hidden": "true"
                    })
                  ]),
                  _: 1
                })
              ]),
              xe(vp, {
                "enter-active-class": "transition duration-100 ease-out",
                "enter-from-class": "transform scale-95 opacity-0",
                "enter-to-class": "transform scale-100 opacity-100",
                "leave-active-class": "transition duration-75 ease-in",
                "leave-from-class": "transform scale-100 opacity-100",
                "leave-to-class": "transform scale-95 opacity-0"
              }, {
                default: Ge(() => [
                  xe(De(Ppe), { class: "absolute right-0 mt-2 w-56 origin-top-right divide-y divide-gray-100 rounded-md bg-white shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none" }, {
                    default: Ge(() => [
                      oe("div", Sge, [
                        xe(De(MI), null, {
                          default: Ge(({ active: a }) => [
                            oe("button", {
                              class: lr([
                                a ? "bg-orange-400 text-white" : "text-gray-900",
                                "group flex w-full items-center rounded-md px-2 py-2 text-sm"
                              ]),
                              onClick: s[0] || (s[0] = (l) => n(o.table))
                            }, [
                              xe(De(d3), {
                                class: "mr-2 h-5 w-5 icon",
                                "aria-hidden": "true"
                              }),
                              tn(" Copy NodeShape ")
                            ], 2)
                          ]),
                          _: 1
                        }),
                        xe(De(MI), null, {
                          default: Ge(({ active: a }) => [
                            oe("button", {
                              class: lr([
                                a ? "bg-orange-400 text-white" : "text-gray-900",
                                "group flex w-full items-center rounded-md px-2 py-2 text-sm"
                              ]),
                              onClick: s[1] || (s[1] = (l) => o.$emit("explore", o.table))
                            }, [
                              xe(De(QH), {
                                class: "mr-2 h-5 w-5 icon",
                                "aria-hidden": "true"
                              }),
                              tn(" Explore Data ")
                            ], 2)
                          ]),
                          _: 1
                        })
                      ])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ])
      ]),
      xe(Wr, { label: "Hide" }, {
        default: Ge(() => [
          oe("button", {
            class: "button is-light is-small",
            onClick: s[2] || (s[2] = (a) => o.$emit("hide", o.table))
          }, [
            xe(De(h3), { class: "icon" })
          ])
        ]),
        _: 1
      })
    ]));
  }
}), Rge = { class: "font-bold" }, Age = { class: "w-full" }, Tge = ["data-id", "onMouseenter", "onMouseleave"], $ge = { class: "text-inherit dark:border-gray-500 px-3 py-2" }, Nge = { class: "text-inherit dark:border-gray-500 px-3 py-2" }, kge = {
  name: "ShapeComponent"
}, Cge = /* @__PURE__ */ it({
  ...kge,
  props: {
    table: {},
    activeLinks: {}
  },
  emits: ["hide", "explore", "export", "hover-title", "unhover-title", "hover-property", "unhover-property"],
  setup(e, { emit: t }) {
    const r = e;
    function n(a) {
      a.stopPropagation();
    }
    const o = Oe(() => r.activeLinks.some((a) => a.target === r.table.id));
    function s(a) {
      return r.activeLinks.some((l) => l.source === r.table.id && l.sourceProperty === a.id);
    }
    return (a, l) => (we(), $e("div", {
      class: lr(["border dark:border-gray-500 rounded-lg shadow-md bg-white dark:bg-gray-800 opacity-90 text-sm", { active: o.value }])
    }, [
      oe("header", {
        class: "bg-gray-100 dark:bg-gray-900 flex items-center gap-4 justify-between px-3 py-2 rounded-lg",
        onMouseenter: l[3] || (l[3] = (u) => a.$emit("hover-title", a.table)),
        onMouseleave: l[4] || (l[4] = (u) => a.$emit("unhover-title", a.table))
      }, [
        xe(Wr, {
          label: a.table.id
        }, {
          default: Ge(() => [
            oe("h3", Rge, gt(a.table.name), 1)
          ]),
          _: 1
        }, 8, ["label"]),
        xe(xge, {
          table: a.table,
          onExport: l[0] || (l[0] = (u) => a.$emit("export", a.table)),
          onHide: l[1] || (l[1] = (u) => a.$emit("hide", a.table)),
          onExplore: l[2] || (l[2] = (u) => a.$emit("explore", a.table))
        }, null, 8, ["table"])
      ], 32),
      oe("table", Age, [
        (we(!0), $e(ut, null, gr(a.table.properties, (u, f) => (we(), $e("tr", {
          class: lr(["border-b last:border-b-0 hover:bg-orange-400 hover:bg-opacity-20 text-gray-800 dark:text-gray-50", { active: s(u) }]),
          key: f,
          "data-id": u.id,
          onMouseenter: (c) => a.$emit("hover-property", a.table, u),
          onMouseleave: (c) => a.$emit("unhover-property", a.table, u)
        }, [
          oe("th", $ge, [
            xe(Wr, {
              label: u.id
            }, {
              default: Ge(() => [
                oe("span", { onMousedown: n }, gt(u.name), 33)
              ]),
              _: 2
            }, 1032, ["label"])
          ]),
          oe("td", Nge, [
            (we(!0), $e(ut, null, gr(u.values, (c) => (we(), $e("div", {
              key: c.id
            }, [
              io(a.$slots, "property-value", { value: c }, () => [
                xe(Wr, {
                  label: c.id
                }, {
                  default: Ge(() => [
                    oe("span", { onMousedown: n }, gt(c.name), 33)
                  ]),
                  _: 2
                }, 1032, ["label"])
              ])
            ]))), 128))
          ])
        ], 42, Tge))), 128))
      ])
    ], 2));
  }
});
var Ige = { value: () => {
} };
function Oc() {
  for (var e = 0, t = arguments.length, r = {}, n; e < t; ++e) {
    if (!(n = arguments[e] + "") || n in r || /[\s.]/.test(n))
      throw new Error("illegal type: " + n);
    r[n] = [];
  }
  return new eh(r);
}
function eh(e) {
  this._ = e;
}
function Mge(e, t) {
  return e.trim().split(/^|\s+/).map(function(r) {
    var n = "", o = r.indexOf(".");
    if (o >= 0 && (n = r.slice(o + 1), r = r.slice(0, o)), r && !t.hasOwnProperty(r))
      throw new Error("unknown type: " + r);
    return { type: r, name: n };
  });
}
eh.prototype = Oc.prototype = {
  constructor: eh,
  on: function(e, t) {
    var r = this._, n = Mge(e + "", r), o, s = -1, a = n.length;
    if (arguments.length < 2) {
      for (; ++s < a; )
        if ((o = (e = n[s]).type) && (o = Oge(r[o], e.name)))
          return o;
      return;
    }
    if (t != null && typeof t != "function")
      throw new Error("invalid callback: " + t);
    for (; ++s < a; )
      if (o = (e = n[s]).type)
        r[o] = OI(r[o], e.name, t);
      else if (t == null)
        for (o in r)
          r[o] = OI(r[o], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var r in t)
      e[r] = t[r].slice();
    return new eh(e);
  },
  call: function(e, t) {
    if ((o = arguments.length - 2) > 0)
      for (var r = new Array(o), n = 0, o, s; n < o; ++n)
        r[n] = arguments[n + 2];
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (s = this._[e], n = 0, o = s.length; n < o; ++n)
      s[n].value.apply(t, r);
  },
  apply: function(e, t, r) {
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (var n = this._[e], o = 0, s = n.length; o < s; ++o)
      n[o].value.apply(t, r);
  }
};
function Oge(e, t) {
  for (var r = 0, n = e.length, o; r < n; ++r)
    if ((o = e[r]).name === t)
      return o.value;
}
function OI(e, t, r) {
  for (var n = 0, o = e.length; n < o; ++n)
    if (e[n].name === t) {
      e[n] = Ige, e = e.slice(0, n).concat(e.slice(n + 1));
      break;
    }
  return r != null && e.push({ name: t, value: r }), e;
}
var dE = "http://www.w3.org/1999/xhtml";
const LI = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: dE,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Hg(e) {
  var t = e += "", r = t.indexOf(":");
  return r >= 0 && (t = e.slice(0, r)) !== "xmlns" && (e = e.slice(r + 1)), LI.hasOwnProperty(t) ? { space: LI[t], local: e } : e;
}
function Lge(e) {
  return function() {
    var t = this.ownerDocument, r = this.namespaceURI;
    return r === dE && t.documentElement.namespaceURI === dE ? t.createElement(e) : t.createElementNS(r, e);
  };
}
function Pge(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function gq(e) {
  var t = Hg(e);
  return (t.local ? Pge : Lge)(t);
}
function Dge() {
}
function XR(e) {
  return e == null ? Dge : function() {
    return this.querySelector(e);
  };
}
function Fge(e) {
  typeof e != "function" && (e = XR(e));
  for (var t = this._groups, r = t.length, n = new Array(r), o = 0; o < r; ++o)
    for (var s = t[o], a = s.length, l = n[o] = new Array(a), u, f, c = 0; c < a; ++c)
      (u = s[c]) && (f = e.call(u, u.__data__, c, s)) && ("__data__" in u && (f.__data__ = u.__data__), l[c] = f);
  return new pn(n, this._parents);
}
function jge(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function Bge() {
  return [];
}
function bq(e) {
  return e == null ? Bge : function() {
    return this.querySelectorAll(e);
  };
}
function qge(e) {
  return function() {
    return jge(e.apply(this, arguments));
  };
}
function Wge(e) {
  typeof e == "function" ? e = qge(e) : e = bq(e);
  for (var t = this._groups, r = t.length, n = [], o = [], s = 0; s < r; ++s)
    for (var a = t[s], l = a.length, u, f = 0; f < l; ++f)
      (u = a[f]) && (n.push(e.call(u, u.__data__, f, a)), o.push(u));
  return new pn(n, o);
}
function yq(e) {
  return function() {
    return this.matches(e);
  };
}
function vq(e) {
  return function(t) {
    return t.matches(e);
  };
}
var Uge = Array.prototype.find;
function Hge(e) {
  return function() {
    return Uge.call(this.children, e);
  };
}
function Vge() {
  return this.firstElementChild;
}
function zge(e) {
  return this.select(e == null ? Vge : Hge(typeof e == "function" ? e : vq(e)));
}
var Gge = Array.prototype.filter;
function Kge() {
  return Array.from(this.children);
}
function Yge(e) {
  return function() {
    return Gge.call(this.children, e);
  };
}
function Xge(e) {
  return this.selectAll(e == null ? Kge : Yge(typeof e == "function" ? e : vq(e)));
}
function Jge(e) {
  typeof e != "function" && (e = yq(e));
  for (var t = this._groups, r = t.length, n = new Array(r), o = 0; o < r; ++o)
    for (var s = t[o], a = s.length, l = n[o] = [], u, f = 0; f < a; ++f)
      (u = s[f]) && e.call(u, u.__data__, f, s) && l.push(u);
  return new pn(n, this._parents);
}
function mq(e) {
  return new Array(e.length);
}
function Qge() {
  return new pn(this._enter || this._groups.map(mq), this._parents);
}
function Hh(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
Hh.prototype = {
  constructor: Hh,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function Zge(e) {
  return function() {
    return e;
  };
}
function ebe(e, t, r, n, o, s) {
  for (var a = 0, l, u = t.length, f = s.length; a < f; ++a)
    (l = t[a]) ? (l.__data__ = s[a], n[a] = l) : r[a] = new Hh(e, s[a]);
  for (; a < u; ++a)
    (l = t[a]) && (o[a] = l);
}
function tbe(e, t, r, n, o, s, a) {
  var l, u, f = /* @__PURE__ */ new Map(), c = t.length, d = s.length, h = new Array(c), p;
  for (l = 0; l < c; ++l)
    (u = t[l]) && (h[l] = p = a.call(u, u.__data__, l, t) + "", f.has(p) ? o[l] = u : f.set(p, u));
  for (l = 0; l < d; ++l)
    p = a.call(e, s[l], l, s) + "", (u = f.get(p)) ? (n[l] = u, u.__data__ = s[l], f.delete(p)) : r[l] = new Hh(e, s[l]);
  for (l = 0; l < c; ++l)
    (u = t[l]) && f.get(h[l]) === u && (o[l] = u);
}
function rbe(e) {
  return e.__data__;
}
function nbe(e, t) {
  if (!arguments.length)
    return Array.from(this, rbe);
  var r = t ? tbe : ebe, n = this._parents, o = this._groups;
  typeof e != "function" && (e = Zge(e));
  for (var s = o.length, a = new Array(s), l = new Array(s), u = new Array(s), f = 0; f < s; ++f) {
    var c = n[f], d = o[f], h = d.length, p = ibe(e.call(c, c && c.__data__, f, n)), v = p.length, y = l[f] = new Array(v), w = a[f] = new Array(v), S = u[f] = new Array(h);
    r(c, d, y, w, S, p, t);
    for (var x = 0, E = 0, N, C; x < v; ++x)
      if (N = y[x]) {
        for (x >= E && (E = x + 1); !(C = w[E]) && ++E < v; )
          ;
        N._next = C || null;
      }
  }
  return a = new pn(a, n), a._enter = l, a._exit = u, a;
}
function ibe(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function obe() {
  return new pn(this._exit || this._groups.map(mq), this._parents);
}
function sbe(e, t, r) {
  var n = this.enter(), o = this, s = this.exit();
  return typeof e == "function" ? (n = e(n), n && (n = n.selection())) : n = n.append(e + ""), t != null && (o = t(o), o && (o = o.selection())), r == null ? s.remove() : r(s), n && o ? n.merge(o).order() : o;
}
function abe(e) {
  for (var t = e.selection ? e.selection() : e, r = this._groups, n = t._groups, o = r.length, s = n.length, a = Math.min(o, s), l = new Array(o), u = 0; u < a; ++u)
    for (var f = r[u], c = n[u], d = f.length, h = l[u] = new Array(d), p, v = 0; v < d; ++v)
      (p = f[v] || c[v]) && (h[v] = p);
  for (; u < o; ++u)
    l[u] = r[u];
  return new pn(l, this._parents);
}
function lbe() {
  for (var e = this._groups, t = -1, r = e.length; ++t < r; )
    for (var n = e[t], o = n.length - 1, s = n[o], a; --o >= 0; )
      (a = n[o]) && (s && a.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(a, s), s = a);
  return this;
}
function ube(e) {
  e || (e = fbe);
  function t(d, h) {
    return d && h ? e(d.__data__, h.__data__) : !d - !h;
  }
  for (var r = this._groups, n = r.length, o = new Array(n), s = 0; s < n; ++s) {
    for (var a = r[s], l = a.length, u = o[s] = new Array(l), f, c = 0; c < l; ++c)
      (f = a[c]) && (u[c] = f);
    u.sort(t);
  }
  return new pn(o, this._parents).order();
}
function fbe(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function cbe() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function dbe() {
  return Array.from(this);
}
function hbe() {
  for (var e = this._groups, t = 0, r = e.length; t < r; ++t)
    for (var n = e[t], o = 0, s = n.length; o < s; ++o) {
      var a = n[o];
      if (a)
        return a;
    }
  return null;
}
function pbe() {
  let e = 0;
  for (const t of this)
    ++e;
  return e;
}
function gbe() {
  return !this.node();
}
function bbe(e) {
  for (var t = this._groups, r = 0, n = t.length; r < n; ++r)
    for (var o = t[r], s = 0, a = o.length, l; s < a; ++s)
      (l = o[s]) && e.call(l, l.__data__, s, o);
  return this;
}
function ybe(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function vbe(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function mbe(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function _be(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function wbe(e, t) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.removeAttribute(e) : this.setAttribute(e, r);
  };
}
function Sbe(e, t) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, r);
  };
}
function Ebe(e, t) {
  var r = Hg(e);
  if (arguments.length < 2) {
    var n = this.node();
    return r.local ? n.getAttributeNS(r.space, r.local) : n.getAttribute(r);
  }
  return this.each((t == null ? r.local ? vbe : ybe : typeof t == "function" ? r.local ? Sbe : wbe : r.local ? _be : mbe)(r, t));
}
function _q(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function xbe(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function Rbe(e, t, r) {
  return function() {
    this.style.setProperty(e, t, r);
  };
}
function Abe(e, t, r) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.style.removeProperty(e) : this.style.setProperty(e, n, r);
  };
}
function Tbe(e, t, r) {
  return arguments.length > 1 ? this.each((t == null ? xbe : typeof t == "function" ? Abe : Rbe)(e, t, r ?? "")) : au(this.node(), e);
}
function au(e, t) {
  return e.style.getPropertyValue(t) || _q(e).getComputedStyle(e, null).getPropertyValue(t);
}
function $be(e) {
  return function() {
    delete this[e];
  };
}
function Nbe(e, t) {
  return function() {
    this[e] = t;
  };
}
function kbe(e, t) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? delete this[e] : this[e] = r;
  };
}
function Cbe(e, t) {
  return arguments.length > 1 ? this.each((t == null ? $be : typeof t == "function" ? kbe : Nbe)(e, t)) : this.node()[e];
}
function wq(e) {
  return e.trim().split(/^|\s+/);
}
function JR(e) {
  return e.classList || new Sq(e);
}
function Sq(e) {
  this._node = e, this._names = wq(e.getAttribute("class") || "");
}
Sq.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function Eq(e, t) {
  for (var r = JR(e), n = -1, o = t.length; ++n < o; )
    r.add(t[n]);
}
function xq(e, t) {
  for (var r = JR(e), n = -1, o = t.length; ++n < o; )
    r.remove(t[n]);
}
function Ibe(e) {
  return function() {
    Eq(this, e);
  };
}
function Mbe(e) {
  return function() {
    xq(this, e);
  };
}
function Obe(e, t) {
  return function() {
    (t.apply(this, arguments) ? Eq : xq)(this, e);
  };
}
function Lbe(e, t) {
  var r = wq(e + "");
  if (arguments.length < 2) {
    for (var n = JR(this.node()), o = -1, s = r.length; ++o < s; )
      if (!n.contains(r[o]))
        return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? Obe : t ? Ibe : Mbe)(r, t));
}
function Pbe() {
  this.textContent = "";
}
function Dbe(e) {
  return function() {
    this.textContent = e;
  };
}
function Fbe(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function jbe(e) {
  return arguments.length ? this.each(e == null ? Pbe : (typeof e == "function" ? Fbe : Dbe)(e)) : this.node().textContent;
}
function Bbe() {
  this.innerHTML = "";
}
function qbe(e) {
  return function() {
    this.innerHTML = e;
  };
}
function Wbe(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function Ube(e) {
  return arguments.length ? this.each(e == null ? Bbe : (typeof e == "function" ? Wbe : qbe)(e)) : this.node().innerHTML;
}
function Hbe() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function Vbe() {
  return this.each(Hbe);
}
function zbe() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function Gbe() {
  return this.each(zbe);
}
function Kbe(e) {
  var t = typeof e == "function" ? e : gq(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function Ybe() {
  return null;
}
function Xbe(e, t) {
  var r = typeof e == "function" ? e : gq(e), n = t == null ? Ybe : typeof t == "function" ? t : XR(t);
  return this.select(function() {
    return this.insertBefore(r.apply(this, arguments), n.apply(this, arguments) || null);
  });
}
function Jbe() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function Qbe() {
  return this.each(Jbe);
}
function Zbe() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function eye() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function tye(e) {
  return this.select(e ? eye : Zbe);
}
function rye(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function nye(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function iye(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var r = "", n = t.indexOf(".");
    return n >= 0 && (r = t.slice(n + 1), t = t.slice(0, n)), { type: t, name: r };
  });
}
function oye(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var r = 0, n = -1, o = t.length, s; r < o; ++r)
        s = t[r], (!e.type || s.type === e.type) && s.name === e.name ? this.removeEventListener(s.type, s.listener, s.options) : t[++n] = s;
      ++n ? t.length = n : delete this.__on;
    }
  };
}
function sye(e, t, r) {
  return function() {
    var n = this.__on, o, s = nye(t);
    if (n) {
      for (var a = 0, l = n.length; a < l; ++a)
        if ((o = n[a]).type === e.type && o.name === e.name) {
          this.removeEventListener(o.type, o.listener, o.options), this.addEventListener(o.type, o.listener = s, o.options = r), o.value = t;
          return;
        }
    }
    this.addEventListener(e.type, s, r), o = { type: e.type, name: e.name, value: t, listener: s, options: r }, n ? n.push(o) : this.__on = [o];
  };
}
function aye(e, t, r) {
  var n = iye(e + ""), o, s = n.length, a;
  if (arguments.length < 2) {
    var l = this.node().__on;
    if (l) {
      for (var u = 0, f = l.length, c; u < f; ++u)
        for (o = 0, c = l[u]; o < s; ++o)
          if ((a = n[o]).type === c.type && a.name === c.name)
            return c.value;
    }
    return;
  }
  for (l = t ? sye : oye, o = 0; o < s; ++o)
    this.each(l(n[o], t, r));
  return this;
}
function Rq(e, t, r) {
  var n = _q(e), o = n.CustomEvent;
  typeof o == "function" ? o = new o(t, r) : (o = n.document.createEvent("Event"), r ? (o.initEvent(t, r.bubbles, r.cancelable), o.detail = r.detail) : o.initEvent(t, !1, !1)), e.dispatchEvent(o);
}
function lye(e, t) {
  return function() {
    return Rq(this, e, t);
  };
}
function uye(e, t) {
  return function() {
    return Rq(this, e, t.apply(this, arguments));
  };
}
function fye(e, t) {
  return this.each((typeof t == "function" ? uye : lye)(e, t));
}
function* cye() {
  for (var e = this._groups, t = 0, r = e.length; t < r; ++t)
    for (var n = e[t], o = 0, s = n.length, a; o < s; ++o)
      (a = n[o]) && (yield a);
}
var Aq = [null];
function pn(e, t) {
  this._groups = e, this._parents = t;
}
function Lc() {
  return new pn([[document.documentElement]], Aq);
}
function dye() {
  return this;
}
pn.prototype = Lc.prototype = {
  constructor: pn,
  select: Fge,
  selectAll: Wge,
  selectChild: zge,
  selectChildren: Xge,
  filter: Jge,
  data: nbe,
  enter: Qge,
  exit: obe,
  join: sbe,
  merge: abe,
  selection: dye,
  order: lbe,
  sort: ube,
  call: cbe,
  nodes: dbe,
  node: hbe,
  size: pbe,
  empty: gbe,
  each: bbe,
  attr: Ebe,
  style: Tbe,
  property: Cbe,
  classed: Lbe,
  text: jbe,
  html: Ube,
  raise: Vbe,
  lower: Gbe,
  append: Kbe,
  insert: Xbe,
  remove: Qbe,
  clone: tye,
  datum: rye,
  on: aye,
  dispatch: fye,
  [Symbol.iterator]: cye
};
function _n(e) {
  return typeof e == "string" ? new pn([[document.querySelector(e)]], [document.documentElement]) : new pn([[e]], Aq);
}
function hye(e) {
  let t;
  for (; t = e.sourceEvent; )
    e = t;
  return e;
}
function Xi(e, t) {
  if (e = hye(e), t === void 0 && (t = e.currentTarget), t) {
    var r = t.ownerSVGElement || t;
    if (r.createSVGPoint) {
      var n = r.createSVGPoint();
      return n.x = e.clientX, n.y = e.clientY, n = n.matrixTransform(t.getScreenCTM().inverse()), [n.x, n.y];
    }
    if (t.getBoundingClientRect) {
      var o = t.getBoundingClientRect();
      return [e.clientX - o.left - t.clientLeft, e.clientY - o.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
const pye = { passive: !1 }, uc = { capture: !0, passive: !1 };
function $0(e) {
  e.stopImmediatePropagation();
}
function ql(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function Tq(e) {
  var t = e.document.documentElement, r = _n(e).on("dragstart.drag", ql, uc);
  "onselectstart" in t ? r.on("selectstart.drag", ql, uc) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function $q(e, t) {
  var r = e.document.documentElement, n = _n(e).on("dragstart.drag", null);
  t && (n.on("click.drag", ql, uc), setTimeout(function() {
    n.on("click.drag", null);
  }, 0)), "onselectstart" in r ? n.on("selectstart.drag", null) : (r.style.MozUserSelect = r.__noselect, delete r.__noselect);
}
const Td = (e) => () => e;
function hE(e, {
  sourceEvent: t,
  subject: r,
  target: n,
  identifier: o,
  active: s,
  x: a,
  y: l,
  dx: u,
  dy: f,
  dispatch: c
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    subject: { value: r, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    identifier: { value: o, enumerable: !0, configurable: !0 },
    active: { value: s, enumerable: !0, configurable: !0 },
    x: { value: a, enumerable: !0, configurable: !0 },
    y: { value: l, enumerable: !0, configurable: !0 },
    dx: { value: u, enumerable: !0, configurable: !0 },
    dy: { value: f, enumerable: !0, configurable: !0 },
    _: { value: c }
  });
}
hE.prototype.on = function() {
  var e = this._.on.apply(this._, arguments);
  return e === this._ ? this : e;
};
function gye(e) {
  return !e.ctrlKey && !e.button;
}
function bye() {
  return this.parentNode;
}
function yye(e, t) {
  return t ?? { x: e.x, y: e.y };
}
function vye() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function mye() {
  var e = gye, t = bye, r = yye, n = vye, o = {}, s = Oc("start", "drag", "end"), a = 0, l, u, f, c, d = 0;
  function h(N) {
    N.on("mousedown.drag", p).filter(n).on("touchstart.drag", w).on("touchmove.drag", S, pye).on("touchend.drag touchcancel.drag", x).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function p(N, C) {
    if (!(c || !e.call(this, N, C))) {
      var j = E(this, t.call(this, N, C), N, C, "mouse");
      j && (_n(N.view).on("mousemove.drag", v, uc).on("mouseup.drag", y, uc), Tq(N.view), $0(N), f = !1, l = N.clientX, u = N.clientY, j("start", N));
    }
  }
  function v(N) {
    if (ql(N), !f) {
      var C = N.clientX - l, j = N.clientY - u;
      f = C * C + j * j > d;
    }
    o.mouse("drag", N);
  }
  function y(N) {
    _n(N.view).on("mousemove.drag mouseup.drag", null), $q(N.view, f), ql(N), o.mouse("end", N);
  }
  function w(N, C) {
    if (e.call(this, N, C)) {
      var j = N.changedTouches, J = t.call(this, N, C), z = j.length, $, G;
      for ($ = 0; $ < z; ++$)
        (G = E(this, J, N, C, j[$].identifier, j[$])) && ($0(N), G("start", N, j[$]));
    }
  }
  function S(N) {
    var C = N.changedTouches, j = C.length, J, z;
    for (J = 0; J < j; ++J)
      (z = o[C[J].identifier]) && (ql(N), z("drag", N, C[J]));
  }
  function x(N) {
    var C = N.changedTouches, j = C.length, J, z;
    for (c && clearTimeout(c), c = setTimeout(function() {
      c = null;
    }, 500), J = 0; J < j; ++J)
      (z = o[C[J].identifier]) && ($0(N), z("end", N, C[J]));
  }
  function E(N, C, j, J, z, $) {
    var G = s.copy(), I = Xi($ || j, C), W, k, U;
    if ((U = r.call(N, new hE("beforestart", {
      sourceEvent: j,
      target: h,
      identifier: z,
      active: a,
      x: I[0],
      y: I[1],
      dx: 0,
      dy: 0,
      dispatch: G
    }), J)) != null)
      return W = U.x - I[0] || 0, k = U.y - I[1] || 0, function Z(Y, re, ae) {
        var ce = I, pe;
        switch (Y) {
          case "start":
            o[z] = Z, pe = a++;
            break;
          case "end":
            delete o[z], --a;
          case "drag":
            I = Xi(ae || re, C), pe = a;
            break;
        }
        G.call(
          Y,
          N,
          new hE(Y, {
            sourceEvent: re,
            subject: U,
            target: h,
            identifier: z,
            active: pe,
            x: I[0] + W,
            y: I[1] + k,
            dx: I[0] - ce[0],
            dy: I[1] - ce[1],
            dispatch: G
          }),
          J
        );
      };
  }
  return h.filter = function(N) {
    return arguments.length ? (e = typeof N == "function" ? N : Td(!!N), h) : e;
  }, h.container = function(N) {
    return arguments.length ? (t = typeof N == "function" ? N : Td(N), h) : t;
  }, h.subject = function(N) {
    return arguments.length ? (r = typeof N == "function" ? N : Td(N), h) : r;
  }, h.touchable = function(N) {
    return arguments.length ? (n = typeof N == "function" ? N : Td(!!N), h) : n;
  }, h.on = function() {
    var N = s.on.apply(s, arguments);
    return N === s ? h : N;
  }, h.clickDistance = function(N) {
    return arguments.length ? (d = (N = +N) * N, h) : Math.sqrt(d);
  }, h;
}
function QR(e, t, r) {
  e.prototype = t.prototype = r, r.constructor = e;
}
function Nq(e, t) {
  var r = Object.create(e.prototype);
  for (var n in t)
    r[n] = t[n];
  return r;
}
function Pc() {
}
var fc = 0.7, Vh = 1 / fc, Wl = "\\s*([+-]?\\d+)\\s*", cc = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", xi = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", _ye = /^#([0-9a-f]{3,8})$/, wye = new RegExp(`^rgb\\(${Wl},${Wl},${Wl}\\)$`), Sye = new RegExp(`^rgb\\(${xi},${xi},${xi}\\)$`), Eye = new RegExp(`^rgba\\(${Wl},${Wl},${Wl},${cc}\\)$`), xye = new RegExp(`^rgba\\(${xi},${xi},${xi},${cc}\\)$`), Rye = new RegExp(`^hsl\\(${cc},${xi},${xi}\\)$`), Aye = new RegExp(`^hsla\\(${cc},${xi},${xi},${cc}\\)$`), PI = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
QR(Pc, dc, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: DI,
  // Deprecated! Use color.formatHex.
  formatHex: DI,
  formatHex8: Tye,
  formatHsl: $ye,
  formatRgb: FI,
  toString: FI
});
function DI() {
  return this.rgb().formatHex();
}
function Tye() {
  return this.rgb().formatHex8();
}
function $ye() {
  return kq(this).formatHsl();
}
function FI() {
  return this.rgb().formatRgb();
}
function dc(e) {
  var t, r;
  return e = (e + "").trim().toLowerCase(), (t = _ye.exec(e)) ? (r = t[1].length, t = parseInt(t[1], 16), r === 6 ? jI(t) : r === 3 ? new Zr(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : r === 8 ? $d(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : r === 4 ? $d(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = wye.exec(e)) ? new Zr(t[1], t[2], t[3], 1) : (t = Sye.exec(e)) ? new Zr(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = Eye.exec(e)) ? $d(t[1], t[2], t[3], t[4]) : (t = xye.exec(e)) ? $d(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = Rye.exec(e)) ? WI(t[1], t[2] / 100, t[3] / 100, 1) : (t = Aye.exec(e)) ? WI(t[1], t[2] / 100, t[3] / 100, t[4]) : PI.hasOwnProperty(e) ? jI(PI[e]) : e === "transparent" ? new Zr(NaN, NaN, NaN, 0) : null;
}
function jI(e) {
  return new Zr(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function $d(e, t, r, n) {
  return n <= 0 && (e = t = r = NaN), new Zr(e, t, r, n);
}
function Nye(e) {
  return e instanceof Pc || (e = dc(e)), e ? (e = e.rgb(), new Zr(e.r, e.g, e.b, e.opacity)) : new Zr();
}
function pE(e, t, r, n) {
  return arguments.length === 1 ? Nye(e) : new Zr(e, t, r, n ?? 1);
}
function Zr(e, t, r, n) {
  this.r = +e, this.g = +t, this.b = +r, this.opacity = +n;
}
QR(Zr, pE, Nq(Pc, {
  brighter(e) {
    return e = e == null ? Vh : Math.pow(Vh, e), new Zr(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? fc : Math.pow(fc, e), new Zr(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Zr(_a(this.r), _a(this.g), _a(this.b), zh(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: BI,
  // Deprecated! Use color.formatHex.
  formatHex: BI,
  formatHex8: kye,
  formatRgb: qI,
  toString: qI
}));
function BI() {
  return `#${ta(this.r)}${ta(this.g)}${ta(this.b)}`;
}
function kye() {
  return `#${ta(this.r)}${ta(this.g)}${ta(this.b)}${ta((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function qI() {
  const e = zh(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${_a(this.r)}, ${_a(this.g)}, ${_a(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function zh(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function _a(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function ta(e) {
  return e = _a(e), (e < 16 ? "0" : "") + e.toString(16);
}
function WI(e, t, r, n) {
  return n <= 0 ? e = t = r = NaN : r <= 0 || r >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Hn(e, t, r, n);
}
function kq(e) {
  if (e instanceof Hn)
    return new Hn(e.h, e.s, e.l, e.opacity);
  if (e instanceof Pc || (e = dc(e)), !e)
    return new Hn();
  if (e instanceof Hn)
    return e;
  e = e.rgb();
  var t = e.r / 255, r = e.g / 255, n = e.b / 255, o = Math.min(t, r, n), s = Math.max(t, r, n), a = NaN, l = s - o, u = (s + o) / 2;
  return l ? (t === s ? a = (r - n) / l + (r < n) * 6 : r === s ? a = (n - t) / l + 2 : a = (t - r) / l + 4, l /= u < 0.5 ? s + o : 2 - s - o, a *= 60) : l = u > 0 && u < 1 ? 0 : a, new Hn(a, l, u, e.opacity);
}
function Cye(e, t, r, n) {
  return arguments.length === 1 ? kq(e) : new Hn(e, t, r, n ?? 1);
}
function Hn(e, t, r, n) {
  this.h = +e, this.s = +t, this.l = +r, this.opacity = +n;
}
QR(Hn, Cye, Nq(Pc, {
  brighter(e) {
    return e = e == null ? Vh : Math.pow(Vh, e), new Hn(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? fc : Math.pow(fc, e), new Hn(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, r = this.l, n = r + (r < 0.5 ? r : 1 - r) * t, o = 2 * r - n;
    return new Zr(
      N0(e >= 240 ? e - 240 : e + 120, o, n),
      N0(e, o, n),
      N0(e < 120 ? e + 240 : e - 120, o, n),
      this.opacity
    );
  },
  clamp() {
    return new Hn(UI(this.h), Nd(this.s), Nd(this.l), zh(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = zh(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${UI(this.h)}, ${Nd(this.s) * 100}%, ${Nd(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function UI(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function Nd(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function N0(e, t, r) {
  return (e < 60 ? t + (r - t) * e / 60 : e < 180 ? r : e < 240 ? t + (r - t) * (240 - e) / 60 : t) * 255;
}
const Cq = (e) => () => e;
function Iye(e, t) {
  return function(r) {
    return e + r * t;
  };
}
function Mye(e, t, r) {
  return e = Math.pow(e, r), t = Math.pow(t, r) - e, r = 1 / r, function(n) {
    return Math.pow(e + n * t, r);
  };
}
function Oye(e) {
  return (e = +e) == 1 ? Iq : function(t, r) {
    return r - t ? Mye(t, r, e) : Cq(isNaN(t) ? r : t);
  };
}
function Iq(e, t) {
  var r = t - e;
  return r ? Iye(e, r) : Cq(isNaN(e) ? t : e);
}
const HI = function e(t) {
  var r = Oye(t);
  function n(o, s) {
    var a = r((o = pE(o)).r, (s = pE(s)).r), l = r(o.g, s.g), u = r(o.b, s.b), f = Iq(o.opacity, s.opacity);
    return function(c) {
      return o.r = a(c), o.g = l(c), o.b = u(c), o.opacity = f(c), o + "";
    };
  }
  return n.gamma = e, n;
}(1);
function Uo(e, t) {
  return e = +e, t = +t, function(r) {
    return e * (1 - r) + t * r;
  };
}
var gE = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, k0 = new RegExp(gE.source, "g");
function Lye(e) {
  return function() {
    return e;
  };
}
function Pye(e) {
  return function(t) {
    return e(t) + "";
  };
}
function Dye(e, t) {
  var r = gE.lastIndex = k0.lastIndex = 0, n, o, s, a = -1, l = [], u = [];
  for (e = e + "", t = t + ""; (n = gE.exec(e)) && (o = k0.exec(t)); )
    (s = o.index) > r && (s = t.slice(r, s), l[a] ? l[a] += s : l[++a] = s), (n = n[0]) === (o = o[0]) ? l[a] ? l[a] += o : l[++a] = o : (l[++a] = null, u.push({ i: a, x: Uo(n, o) })), r = k0.lastIndex;
  return r < t.length && (s = t.slice(r), l[a] ? l[a] += s : l[++a] = s), l.length < 2 ? u[0] ? Pye(u[0].x) : Lye(t) : (t = u.length, function(f) {
    for (var c = 0, d; c < t; ++c)
      l[(d = u[c]).i] = d.x(f);
    return l.join("");
  });
}
var VI = 180 / Math.PI, bE = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function Mq(e, t, r, n, o, s) {
  var a, l, u;
  return (a = Math.sqrt(e * e + t * t)) && (e /= a, t /= a), (u = e * r + t * n) && (r -= e * u, n -= t * u), (l = Math.sqrt(r * r + n * n)) && (r /= l, n /= l, u /= l), e * n < t * r && (e = -e, t = -t, u = -u, a = -a), {
    translateX: o,
    translateY: s,
    rotate: Math.atan2(t, e) * VI,
    skewX: Math.atan(u) * VI,
    scaleX: a,
    scaleY: l
  };
}
var kd;
function Fye(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? bE : Mq(t.a, t.b, t.c, t.d, t.e, t.f);
}
function jye(e) {
  return e == null || (kd || (kd = document.createElementNS("http://www.w3.org/2000/svg", "g")), kd.setAttribute("transform", e), !(e = kd.transform.baseVal.consolidate())) ? bE : (e = e.matrix, Mq(e.a, e.b, e.c, e.d, e.e, e.f));
}
function Oq(e, t, r, n) {
  function o(f) {
    return f.length ? f.pop() + " " : "";
  }
  function s(f, c, d, h, p, v) {
    if (f !== d || c !== h) {
      var y = p.push("translate(", null, t, null, r);
      v.push({ i: y - 4, x: Uo(f, d) }, { i: y - 2, x: Uo(c, h) });
    } else
      (d || h) && p.push("translate(" + d + t + h + r);
  }
  function a(f, c, d, h) {
    f !== c ? (f - c > 180 ? c += 360 : c - f > 180 && (f += 360), h.push({ i: d.push(o(d) + "rotate(", null, n) - 2, x: Uo(f, c) })) : c && d.push(o(d) + "rotate(" + c + n);
  }
  function l(f, c, d, h) {
    f !== c ? h.push({ i: d.push(o(d) + "skewX(", null, n) - 2, x: Uo(f, c) }) : c && d.push(o(d) + "skewX(" + c + n);
  }
  function u(f, c, d, h, p, v) {
    if (f !== d || c !== h) {
      var y = p.push(o(p) + "scale(", null, ",", null, ")");
      v.push({ i: y - 4, x: Uo(f, d) }, { i: y - 2, x: Uo(c, h) });
    } else
      (d !== 1 || h !== 1) && p.push(o(p) + "scale(" + d + "," + h + ")");
  }
  return function(f, c) {
    var d = [], h = [];
    return f = e(f), c = e(c), s(f.translateX, f.translateY, c.translateX, c.translateY, d, h), a(f.rotate, c.rotate, d, h), l(f.skewX, c.skewX, d, h), u(f.scaleX, f.scaleY, c.scaleX, c.scaleY, d, h), f = c = null, function(p) {
      for (var v = -1, y = h.length, w; ++v < y; )
        d[(w = h[v]).i] = w.x(p);
      return d.join("");
    };
  };
}
var Bye = Oq(Fye, "px, ", "px)", "deg)"), qye = Oq(jye, ", ", ")", ")"), Wye = 1e-12;
function zI(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function Uye(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function Hye(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const Vye = function e(t, r, n) {
  function o(s, a) {
    var l = s[0], u = s[1], f = s[2], c = a[0], d = a[1], h = a[2], p = c - l, v = d - u, y = p * p + v * v, w, S;
    if (y < Wye)
      S = Math.log(h / f) / t, w = function(J) {
        return [
          l + J * p,
          u + J * v,
          f * Math.exp(t * J * S)
        ];
      };
    else {
      var x = Math.sqrt(y), E = (h * h - f * f + n * y) / (2 * f * r * x), N = (h * h - f * f - n * y) / (2 * h * r * x), C = Math.log(Math.sqrt(E * E + 1) - E), j = Math.log(Math.sqrt(N * N + 1) - N);
      S = (j - C) / t, w = function(J) {
        var z = J * S, $ = zI(C), G = f / (r * x) * ($ * Hye(t * z + C) - Uye(C));
        return [
          l + G * p,
          u + G * v,
          f * $ / zI(t * z + C)
        ];
      };
    }
    return w.duration = S * 1e3 * t / Math.SQRT2, w;
  }
  return o.rho = function(s) {
    var a = Math.max(1e-3, +s), l = a * a, u = l * l;
    return e(a, l, u);
  }, o;
}(Math.SQRT2, 2, 4);
var lu = 0, sf = 0, Wu = 0, Lq = 1e3, Gh, af, Kh = 0, La = 0, Vg = 0, hc = typeof performance == "object" && performance.now ? performance : Date, Pq = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function ZR() {
  return La || (Pq(zye), La = hc.now() + Vg);
}
function zye() {
  La = 0;
}
function Yh() {
  this._call = this._time = this._next = null;
}
Yh.prototype = eA.prototype = {
  constructor: Yh,
  restart: function(e, t, r) {
    if (typeof e != "function")
      throw new TypeError("callback is not a function");
    r = (r == null ? ZR() : +r) + (t == null ? 0 : +t), !this._next && af !== this && (af ? af._next = this : Gh = this, af = this), this._call = e, this._time = r, yE();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, yE());
  }
};
function eA(e, t, r) {
  var n = new Yh();
  return n.restart(e, t, r), n;
}
function Gye() {
  ZR(), ++lu;
  for (var e = Gh, t; e; )
    (t = La - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --lu;
}
function GI() {
  La = (Kh = hc.now()) + Vg, lu = sf = 0;
  try {
    Gye();
  } finally {
    lu = 0, Yye(), La = 0;
  }
}
function Kye() {
  var e = hc.now(), t = e - Kh;
  t > Lq && (Vg -= t, Kh = e);
}
function Yye() {
  for (var e, t = Gh, r, n = 1 / 0; t; )
    t._call ? (n > t._time && (n = t._time), e = t, t = t._next) : (r = t._next, t._next = null, t = e ? e._next = r : Gh = r);
  af = e, yE(n);
}
function yE(e) {
  if (!lu) {
    sf && (sf = clearTimeout(sf));
    var t = e - La;
    t > 24 ? (e < 1 / 0 && (sf = setTimeout(GI, e - hc.now() - Vg)), Wu && (Wu = clearInterval(Wu))) : (Wu || (Kh = hc.now(), Wu = setInterval(Kye, Lq)), lu = 1, Pq(GI));
  }
}
function KI(e, t, r) {
  var n = new Yh();
  return t = t == null ? 0 : +t, n.restart((o) => {
    n.stop(), e(o + t);
  }, t, r), n;
}
var Xye = Oc("start", "end", "cancel", "interrupt"), Jye = [], Dq = 0, YI = 1, vE = 2, th = 3, XI = 4, mE = 5, rh = 6;
function zg(e, t, r, n, o, s) {
  var a = e.__transition;
  if (!a)
    e.__transition = {};
  else if (r in a)
    return;
  Qye(e, r, {
    name: t,
    index: n,
    // For context during callback.
    group: o,
    // For context during callback.
    on: Xye,
    tween: Jye,
    time: s.time,
    delay: s.delay,
    duration: s.duration,
    ease: s.ease,
    timer: null,
    state: Dq
  });
}
function tA(e, t) {
  var r = ii(e, t);
  if (r.state > Dq)
    throw new Error("too late; already scheduled");
  return r;
}
function qi(e, t) {
  var r = ii(e, t);
  if (r.state > th)
    throw new Error("too late; already running");
  return r;
}
function ii(e, t) {
  var r = e.__transition;
  if (!r || !(r = r[t]))
    throw new Error("transition not found");
  return r;
}
function Qye(e, t, r) {
  var n = e.__transition, o;
  n[t] = r, r.timer = eA(s, 0, r.time);
  function s(f) {
    r.state = YI, r.timer.restart(a, r.delay, r.time), r.delay <= f && a(f - r.delay);
  }
  function a(f) {
    var c, d, h, p;
    if (r.state !== YI)
      return u();
    for (c in n)
      if (p = n[c], p.name === r.name) {
        if (p.state === th)
          return KI(a);
        p.state === XI ? (p.state = rh, p.timer.stop(), p.on.call("interrupt", e, e.__data__, p.index, p.group), delete n[c]) : +c < t && (p.state = rh, p.timer.stop(), p.on.call("cancel", e, e.__data__, p.index, p.group), delete n[c]);
      }
    if (KI(function() {
      r.state === th && (r.state = XI, r.timer.restart(l, r.delay, r.time), l(f));
    }), r.state = vE, r.on.call("start", e, e.__data__, r.index, r.group), r.state === vE) {
      for (r.state = th, o = new Array(h = r.tween.length), c = 0, d = -1; c < h; ++c)
        (p = r.tween[c].value.call(e, e.__data__, r.index, r.group)) && (o[++d] = p);
      o.length = d + 1;
    }
  }
  function l(f) {
    for (var c = f < r.duration ? r.ease.call(null, f / r.duration) : (r.timer.restart(u), r.state = mE, 1), d = -1, h = o.length; ++d < h; )
      o[d].call(e, c);
    r.state === mE && (r.on.call("end", e, e.__data__, r.index, r.group), u());
  }
  function u() {
    r.state = rh, r.timer.stop(), delete n[t];
    for (var f in n)
      return;
    delete e.__transition;
  }
}
function nh(e, t) {
  var r = e.__transition, n, o, s = !0, a;
  if (r) {
    t = t == null ? null : t + "";
    for (a in r) {
      if ((n = r[a]).name !== t) {
        s = !1;
        continue;
      }
      o = n.state > vE && n.state < mE, n.state = rh, n.timer.stop(), n.on.call(o ? "interrupt" : "cancel", e, e.__data__, n.index, n.group), delete r[a];
    }
    s && delete e.__transition;
  }
}
function Zye(e) {
  return this.each(function() {
    nh(this, e);
  });
}
function e0e(e, t) {
  var r, n;
  return function() {
    var o = qi(this, e), s = o.tween;
    if (s !== r) {
      n = r = s;
      for (var a = 0, l = n.length; a < l; ++a)
        if (n[a].name === t) {
          n = n.slice(), n.splice(a, 1);
          break;
        }
    }
    o.tween = n;
  };
}
function t0e(e, t, r) {
  var n, o;
  if (typeof r != "function")
    throw new Error();
  return function() {
    var s = qi(this, e), a = s.tween;
    if (a !== n) {
      o = (n = a).slice();
      for (var l = { name: t, value: r }, u = 0, f = o.length; u < f; ++u)
        if (o[u].name === t) {
          o[u] = l;
          break;
        }
      u === f && o.push(l);
    }
    s.tween = o;
  };
}
function r0e(e, t) {
  var r = this._id;
  if (e += "", arguments.length < 2) {
    for (var n = ii(this.node(), r).tween, o = 0, s = n.length, a; o < s; ++o)
      if ((a = n[o]).name === e)
        return a.value;
    return null;
  }
  return this.each((t == null ? e0e : t0e)(r, e, t));
}
function rA(e, t, r) {
  var n = e._id;
  return e.each(function() {
    var o = qi(this, n);
    (o.value || (o.value = {}))[t] = r.apply(this, arguments);
  }), function(o) {
    return ii(o, n).value[t];
  };
}
function Fq(e, t) {
  var r;
  return (typeof t == "number" ? Uo : t instanceof dc ? HI : (r = dc(t)) ? (t = r, HI) : Dye)(e, t);
}
function n0e(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function i0e(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function o0e(e, t, r) {
  var n, o = r + "", s;
  return function() {
    var a = this.getAttribute(e);
    return a === o ? null : a === n ? s : s = t(n = a, r);
  };
}
function s0e(e, t, r) {
  var n, o = r + "", s;
  return function() {
    var a = this.getAttributeNS(e.space, e.local);
    return a === o ? null : a === n ? s : s = t(n = a, r);
  };
}
function a0e(e, t, r) {
  var n, o, s;
  return function() {
    var a, l = r(this), u;
    return l == null ? void this.removeAttribute(e) : (a = this.getAttribute(e), u = l + "", a === u ? null : a === n && u === o ? s : (o = u, s = t(n = a, l)));
  };
}
function l0e(e, t, r) {
  var n, o, s;
  return function() {
    var a, l = r(this), u;
    return l == null ? void this.removeAttributeNS(e.space, e.local) : (a = this.getAttributeNS(e.space, e.local), u = l + "", a === u ? null : a === n && u === o ? s : (o = u, s = t(n = a, l)));
  };
}
function u0e(e, t) {
  var r = Hg(e), n = r === "transform" ? qye : Fq;
  return this.attrTween(e, typeof t == "function" ? (r.local ? l0e : a0e)(r, n, rA(this, "attr." + e, t)) : t == null ? (r.local ? i0e : n0e)(r) : (r.local ? s0e : o0e)(r, n, t));
}
function f0e(e, t) {
  return function(r) {
    this.setAttribute(e, t.call(this, r));
  };
}
function c0e(e, t) {
  return function(r) {
    this.setAttributeNS(e.space, e.local, t.call(this, r));
  };
}
function d0e(e, t) {
  var r, n;
  function o() {
    var s = t.apply(this, arguments);
    return s !== n && (r = (n = s) && c0e(e, s)), r;
  }
  return o._value = t, o;
}
function h0e(e, t) {
  var r, n;
  function o() {
    var s = t.apply(this, arguments);
    return s !== n && (r = (n = s) && f0e(e, s)), r;
  }
  return o._value = t, o;
}
function p0e(e, t) {
  var r = "attr." + e;
  if (arguments.length < 2)
    return (r = this.tween(r)) && r._value;
  if (t == null)
    return this.tween(r, null);
  if (typeof t != "function")
    throw new Error();
  var n = Hg(e);
  return this.tween(r, (n.local ? d0e : h0e)(n, t));
}
function g0e(e, t) {
  return function() {
    tA(this, e).delay = +t.apply(this, arguments);
  };
}
function b0e(e, t) {
  return t = +t, function() {
    tA(this, e).delay = t;
  };
}
function y0e(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? g0e : b0e)(t, e)) : ii(this.node(), t).delay;
}
function v0e(e, t) {
  return function() {
    qi(this, e).duration = +t.apply(this, arguments);
  };
}
function m0e(e, t) {
  return t = +t, function() {
    qi(this, e).duration = t;
  };
}
function _0e(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? v0e : m0e)(t, e)) : ii(this.node(), t).duration;
}
function w0e(e, t) {
  if (typeof t != "function")
    throw new Error();
  return function() {
    qi(this, e).ease = t;
  };
}
function S0e(e) {
  var t = this._id;
  return arguments.length ? this.each(w0e(t, e)) : ii(this.node(), t).ease;
}
function E0e(e, t) {
  return function() {
    var r = t.apply(this, arguments);
    if (typeof r != "function")
      throw new Error();
    qi(this, e).ease = r;
  };
}
function x0e(e) {
  if (typeof e != "function")
    throw new Error();
  return this.each(E0e(this._id, e));
}
function R0e(e) {
  typeof e != "function" && (e = yq(e));
  for (var t = this._groups, r = t.length, n = new Array(r), o = 0; o < r; ++o)
    for (var s = t[o], a = s.length, l = n[o] = [], u, f = 0; f < a; ++f)
      (u = s[f]) && e.call(u, u.__data__, f, s) && l.push(u);
  return new _o(n, this._parents, this._name, this._id);
}
function A0e(e) {
  if (e._id !== this._id)
    throw new Error();
  for (var t = this._groups, r = e._groups, n = t.length, o = r.length, s = Math.min(n, o), a = new Array(n), l = 0; l < s; ++l)
    for (var u = t[l], f = r[l], c = u.length, d = a[l] = new Array(c), h, p = 0; p < c; ++p)
      (h = u[p] || f[p]) && (d[p] = h);
  for (; l < n; ++l)
    a[l] = t[l];
  return new _o(a, this._parents, this._name, this._id);
}
function T0e(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var r = t.indexOf(".");
    return r >= 0 && (t = t.slice(0, r)), !t || t === "start";
  });
}
function $0e(e, t, r) {
  var n, o, s = T0e(t) ? tA : qi;
  return function() {
    var a = s(this, e), l = a.on;
    l !== n && (o = (n = l).copy()).on(t, r), a.on = o;
  };
}
function N0e(e, t) {
  var r = this._id;
  return arguments.length < 2 ? ii(this.node(), r).on.on(e) : this.each($0e(r, e, t));
}
function k0e(e) {
  return function() {
    var t = this.parentNode;
    for (var r in this.__transition)
      if (+r !== e)
        return;
    t && t.removeChild(this);
  };
}
function C0e() {
  return this.on("end.remove", k0e(this._id));
}
function I0e(e) {
  var t = this._name, r = this._id;
  typeof e != "function" && (e = XR(e));
  for (var n = this._groups, o = n.length, s = new Array(o), a = 0; a < o; ++a)
    for (var l = n[a], u = l.length, f = s[a] = new Array(u), c, d, h = 0; h < u; ++h)
      (c = l[h]) && (d = e.call(c, c.__data__, h, l)) && ("__data__" in c && (d.__data__ = c.__data__), f[h] = d, zg(f[h], t, r, h, f, ii(c, r)));
  return new _o(s, this._parents, t, r);
}
function M0e(e) {
  var t = this._name, r = this._id;
  typeof e != "function" && (e = bq(e));
  for (var n = this._groups, o = n.length, s = [], a = [], l = 0; l < o; ++l)
    for (var u = n[l], f = u.length, c, d = 0; d < f; ++d)
      if (c = u[d]) {
        for (var h = e.call(c, c.__data__, d, u), p, v = ii(c, r), y = 0, w = h.length; y < w; ++y)
          (p = h[y]) && zg(p, t, r, y, h, v);
        s.push(h), a.push(c);
      }
  return new _o(s, a, t, r);
}
var O0e = Lc.prototype.constructor;
function L0e() {
  return new O0e(this._groups, this._parents);
}
function P0e(e, t) {
  var r, n, o;
  return function() {
    var s = au(this, e), a = (this.style.removeProperty(e), au(this, e));
    return s === a ? null : s === r && a === n ? o : o = t(r = s, n = a);
  };
}
function jq(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function D0e(e, t, r) {
  var n, o = r + "", s;
  return function() {
    var a = au(this, e);
    return a === o ? null : a === n ? s : s = t(n = a, r);
  };
}
function F0e(e, t, r) {
  var n, o, s;
  return function() {
    var a = au(this, e), l = r(this), u = l + "";
    return l == null && (u = l = (this.style.removeProperty(e), au(this, e))), a === u ? null : a === n && u === o ? s : (o = u, s = t(n = a, l));
  };
}
function j0e(e, t) {
  var r, n, o, s = "style." + t, a = "end." + s, l;
  return function() {
    var u = qi(this, e), f = u.on, c = u.value[s] == null ? l || (l = jq(t)) : void 0;
    (f !== r || o !== c) && (n = (r = f).copy()).on(a, o = c), u.on = n;
  };
}
function B0e(e, t, r) {
  var n = (e += "") == "transform" ? Bye : Fq;
  return t == null ? this.styleTween(e, P0e(e, n)).on("end.style." + e, jq(e)) : typeof t == "function" ? this.styleTween(e, F0e(e, n, rA(this, "style." + e, t))).each(j0e(this._id, e)) : this.styleTween(e, D0e(e, n, t), r).on("end.style." + e, null);
}
function q0e(e, t, r) {
  return function(n) {
    this.style.setProperty(e, t.call(this, n), r);
  };
}
function W0e(e, t, r) {
  var n, o;
  function s() {
    var a = t.apply(this, arguments);
    return a !== o && (n = (o = a) && q0e(e, a, r)), n;
  }
  return s._value = t, s;
}
function U0e(e, t, r) {
  var n = "style." + (e += "");
  if (arguments.length < 2)
    return (n = this.tween(n)) && n._value;
  if (t == null)
    return this.tween(n, null);
  if (typeof t != "function")
    throw new Error();
  return this.tween(n, W0e(e, t, r ?? ""));
}
function H0e(e) {
  return function() {
    this.textContent = e;
  };
}
function V0e(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function z0e(e) {
  return this.tween("text", typeof e == "function" ? V0e(rA(this, "text", e)) : H0e(e == null ? "" : e + ""));
}
function G0e(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function K0e(e) {
  var t, r;
  function n() {
    var o = e.apply(this, arguments);
    return o !== r && (t = (r = o) && G0e(o)), t;
  }
  return n._value = e, n;
}
function Y0e(e) {
  var t = "text";
  if (arguments.length < 1)
    return (t = this.tween(t)) && t._value;
  if (e == null)
    return this.tween(t, null);
  if (typeof e != "function")
    throw new Error();
  return this.tween(t, K0e(e));
}
function X0e() {
  for (var e = this._name, t = this._id, r = Bq(), n = this._groups, o = n.length, s = 0; s < o; ++s)
    for (var a = n[s], l = a.length, u, f = 0; f < l; ++f)
      if (u = a[f]) {
        var c = ii(u, t);
        zg(u, e, r, f, a, {
          time: c.time + c.delay + c.duration,
          delay: 0,
          duration: c.duration,
          ease: c.ease
        });
      }
  return new _o(n, this._parents, e, r);
}
function J0e() {
  var e, t, r = this, n = r._id, o = r.size();
  return new Promise(function(s, a) {
    var l = { value: a }, u = { value: function() {
      --o === 0 && s();
    } };
    r.each(function() {
      var f = qi(this, n), c = f.on;
      c !== e && (t = (e = c).copy(), t._.cancel.push(l), t._.interrupt.push(l), t._.end.push(u)), f.on = t;
    }), o === 0 && s();
  });
}
var Q0e = 0;
function _o(e, t, r, n) {
  this._groups = e, this._parents = t, this._name = r, this._id = n;
}
function Bq() {
  return ++Q0e;
}
var zi = Lc.prototype;
_o.prototype = {
  constructor: _o,
  select: I0e,
  selectAll: M0e,
  selectChild: zi.selectChild,
  selectChildren: zi.selectChildren,
  filter: R0e,
  merge: A0e,
  selection: L0e,
  transition: X0e,
  call: zi.call,
  nodes: zi.nodes,
  node: zi.node,
  size: zi.size,
  empty: zi.empty,
  each: zi.each,
  on: N0e,
  attr: u0e,
  attrTween: p0e,
  style: B0e,
  styleTween: U0e,
  text: z0e,
  textTween: Y0e,
  remove: C0e,
  tween: r0e,
  delay: y0e,
  duration: _0e,
  ease: S0e,
  easeVarying: x0e,
  end: J0e,
  [Symbol.iterator]: zi[Symbol.iterator]
};
function Z0e(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var eve = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: Z0e
};
function tve(e, t) {
  for (var r; !(r = e.__transition) || !(r = r[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return r;
}
function rve(e) {
  var t, r;
  e instanceof _o ? (t = e._id, e = e._name) : (t = Bq(), (r = eve).time = ZR(), e = e == null ? null : e + "");
  for (var n = this._groups, o = n.length, s = 0; s < o; ++s)
    for (var a = n[s], l = a.length, u, f = 0; f < l; ++f)
      (u = a[f]) && zg(u, e, t, f, a, r || tve(u, t));
  return new _o(n, this._parents, e, t);
}
Lc.prototype.interrupt = Zye;
Lc.prototype.transition = rve;
const _E = Math.PI, wE = 2 * _E, Vs = 1e-6, nve = wE - Vs;
function qq(e) {
  this._ += e[0];
  for (let t = 1, r = e.length; t < r; ++t)
    this._ += arguments[t] + e[t];
}
function ive(e) {
  let t = Math.floor(e);
  if (!(t >= 0))
    throw new Error(`invalid digits: ${e}`);
  if (t > 15)
    return qq;
  const r = 10 ** t;
  return function(n) {
    this._ += n[0];
    for (let o = 1, s = n.length; o < s; ++o)
      this._ += Math.round(arguments[o] * r) / r + n[o];
  };
}
class ove {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? qq : ive(t);
  }
  moveTo(t, r) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +r}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, r) {
    this._append`L${this._x1 = +t},${this._y1 = +r}`;
  }
  quadraticCurveTo(t, r, n, o) {
    this._append`Q${+t},${+r},${this._x1 = +n},${this._y1 = +o}`;
  }
  bezierCurveTo(t, r, n, o, s, a) {
    this._append`C${+t},${+r},${+n},${+o},${this._x1 = +s},${this._y1 = +a}`;
  }
  arcTo(t, r, n, o, s) {
    if (t = +t, r = +r, n = +n, o = +o, s = +s, s < 0)
      throw new Error(`negative radius: ${s}`);
    let a = this._x1, l = this._y1, u = n - t, f = o - r, c = a - t, d = l - r, h = c * c + d * d;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = r}`;
    else if (h > Vs)
      if (!(Math.abs(d * u - f * c) > Vs) || !s)
        this._append`L${this._x1 = t},${this._y1 = r}`;
      else {
        let p = n - a, v = o - l, y = u * u + f * f, w = p * p + v * v, S = Math.sqrt(y), x = Math.sqrt(h), E = s * Math.tan((_E - Math.acos((y + h - w) / (2 * S * x))) / 2), N = E / x, C = E / S;
        Math.abs(N - 1) > Vs && this._append`L${t + N * c},${r + N * d}`, this._append`A${s},${s},0,0,${+(d * p > c * v)},${this._x1 = t + C * u},${this._y1 = r + C * f}`;
      }
  }
  arc(t, r, n, o, s, a) {
    if (t = +t, r = +r, n = +n, a = !!a, n < 0)
      throw new Error(`negative radius: ${n}`);
    let l = n * Math.cos(o), u = n * Math.sin(o), f = t + l, c = r + u, d = 1 ^ a, h = a ? o - s : s - o;
    this._x1 === null ? this._append`M${f},${c}` : (Math.abs(this._x1 - f) > Vs || Math.abs(this._y1 - c) > Vs) && this._append`L${f},${c}`, n && (h < 0 && (h = h % wE + wE), h > nve ? this._append`A${n},${n},0,1,${d},${t - l},${r - u}A${n},${n},0,1,${d},${this._x1 = f},${this._y1 = c}` : h > Vs && this._append`A${n},${n},0,${+(h >= _E)},${d},${this._x1 = t + n * Math.cos(s)},${this._y1 = r + n * Math.sin(s)}`);
  }
  rect(t, r, n, o) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +r}h${n = +n}v${+o}h${-n}Z`;
  }
  toString() {
    return this._;
  }
}
function Kn(e) {
  return function() {
    return e;
  };
}
function JI(e) {
  return (e() - 0.5) * 1e-6;
}
function sve(e) {
  return e.index;
}
function QI(e, t) {
  var r = e.get(t);
  if (!r)
    throw new Error("node not found: " + t);
  return r;
}
function ave(e) {
  var t = sve, r = d, n, o = Kn(30), s, a, l, u, f, c = 1;
  e == null && (e = []);
  function d(w) {
    return 1 / Math.min(l[w.source.index], l[w.target.index]);
  }
  function h(w) {
    for (var S = 0, x = e.length; S < c; ++S)
      for (var E = 0, N, C, j, J, z, $, G; E < x; ++E)
        N = e[E], C = N.source, j = N.target, J = j.x + j.vx - C.x - C.vx || JI(f), z = j.y + j.vy - C.y - C.vy || JI(f), $ = Math.sqrt(J * J + z * z), $ = ($ - s[E]) / $ * w * n[E], J *= $, z *= $, j.vx -= J * (G = u[E]), j.vy -= z * G, C.vx += J * (G = 1 - G), C.vy += z * G;
  }
  function p() {
    if (a) {
      var w, S = a.length, x = e.length, E = new Map(a.map((C, j) => [t(C, j, a), C])), N;
      for (w = 0, l = new Array(S); w < x; ++w)
        N = e[w], N.index = w, typeof N.source != "object" && (N.source = QI(E, N.source)), typeof N.target != "object" && (N.target = QI(E, N.target)), l[N.source.index] = (l[N.source.index] || 0) + 1, l[N.target.index] = (l[N.target.index] || 0) + 1;
      for (w = 0, u = new Array(x); w < x; ++w)
        N = e[w], u[w] = l[N.source.index] / (l[N.source.index] + l[N.target.index]);
      n = new Array(x), v(), s = new Array(x), y();
    }
  }
  function v() {
    if (a)
      for (var w = 0, S = e.length; w < S; ++w)
        n[w] = +r(e[w], w, e);
  }
  function y() {
    if (a)
      for (var w = 0, S = e.length; w < S; ++w)
        s[w] = +o(e[w], w, e);
  }
  return h.initialize = function(w, S) {
    a = w, f = S, p();
  }, h.links = function(w) {
    return arguments.length ? (e = w, p(), h) : e;
  }, h.id = function(w) {
    return arguments.length ? (t = w, h) : t;
  }, h.iterations = function(w) {
    return arguments.length ? (c = +w, h) : c;
  }, h.strength = function(w) {
    return arguments.length ? (r = typeof w == "function" ? w : Kn(+w), v(), h) : r;
  }, h.distance = function(w) {
    return arguments.length ? (o = typeof w == "function" ? w : Kn(+w), y(), h) : o;
  }, h;
}
const lve = 1664525, uve = 1013904223, ZI = 4294967296;
function fve() {
  let e = 1;
  return () => (e = (lve * e + uve) % ZI) / ZI;
}
var cve = 10, dve = Math.PI * (3 - Math.sqrt(5));
function hve(e) {
  var t, r = 1, n = 1e-3, o = 1 - Math.pow(n, 1 / 300), s = 0, a = 0.6, l = /* @__PURE__ */ new Map(), u = eA(d), f = Oc("tick", "end"), c = fve();
  e == null && (e = []);
  function d() {
    h(), f.call("tick", t), r < n && (u.stop(), f.call("end", t));
  }
  function h(y) {
    var w, S = e.length, x;
    y === void 0 && (y = 1);
    for (var E = 0; E < y; ++E)
      for (r += (s - r) * o, l.forEach(function(N) {
        N(r);
      }), w = 0; w < S; ++w)
        x = e[w], x.fx == null ? x.x += x.vx *= a : (x.x = x.fx, x.vx = 0), x.fy == null ? x.y += x.vy *= a : (x.y = x.fy, x.vy = 0);
    return t;
  }
  function p() {
    for (var y = 0, w = e.length, S; y < w; ++y) {
      if (S = e[y], S.index = y, S.fx != null && (S.x = S.fx), S.fy != null && (S.y = S.fy), isNaN(S.x) || isNaN(S.y)) {
        var x = cve * Math.sqrt(0.5 + y), E = y * dve;
        S.x = x * Math.cos(E), S.y = x * Math.sin(E);
      }
      (isNaN(S.vx) || isNaN(S.vy)) && (S.vx = S.vy = 0);
    }
  }
  function v(y) {
    return y.initialize && y.initialize(e, c), y;
  }
  return p(), t = {
    tick: h,
    restart: function() {
      return u.restart(d), t;
    },
    stop: function() {
      return u.stop(), t;
    },
    nodes: function(y) {
      return arguments.length ? (e = y, p(), l.forEach(v), t) : e;
    },
    alpha: function(y) {
      return arguments.length ? (r = +y, t) : r;
    },
    alphaMin: function(y) {
      return arguments.length ? (n = +y, t) : n;
    },
    alphaDecay: function(y) {
      return arguments.length ? (o = +y, t) : +o;
    },
    alphaTarget: function(y) {
      return arguments.length ? (s = +y, t) : s;
    },
    velocityDecay: function(y) {
      return arguments.length ? (a = 1 - y, t) : 1 - a;
    },
    randomSource: function(y) {
      return arguments.length ? (c = y, l.forEach(v), t) : c;
    },
    force: function(y, w) {
      return arguments.length > 1 ? (w == null ? l.delete(y) : l.set(y, v(w)), t) : l.get(y);
    },
    find: function(y, w, S) {
      var x = 0, E = e.length, N, C, j, J, z;
      for (S == null ? S = 1 / 0 : S *= S, x = 0; x < E; ++x)
        J = e[x], N = y - J.x, C = w - J.y, j = N * N + C * C, j < S && (z = J, S = j);
      return z;
    },
    on: function(y, w) {
      return arguments.length > 1 ? (f.on(y, w), t) : f.on(y);
    }
  };
}
function pve(e) {
  var t = Kn(0.1), r, n, o;
  typeof e != "function" && (e = Kn(e == null ? 0 : +e));
  function s(l) {
    for (var u = 0, f = r.length, c; u < f; ++u)
      c = r[u], c.vx += (o[u] - c.x) * n[u] * l;
  }
  function a() {
    if (r) {
      var l, u = r.length;
      for (n = new Array(u), o = new Array(u), l = 0; l < u; ++l)
        n[l] = isNaN(o[l] = +e(r[l], l, r)) ? 0 : +t(r[l], l, r);
    }
  }
  return s.initialize = function(l) {
    r = l, a();
  }, s.strength = function(l) {
    return arguments.length ? (t = typeof l == "function" ? l : Kn(+l), a(), s) : t;
  }, s.x = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : Kn(+l), a(), s) : e;
  }, s;
}
function gve(e) {
  var t = Kn(0.1), r, n, o;
  typeof e != "function" && (e = Kn(e == null ? 0 : +e));
  function s(l) {
    for (var u = 0, f = r.length, c; u < f; ++u)
      c = r[u], c.vy += (o[u] - c.y) * n[u] * l;
  }
  function a() {
    if (r) {
      var l, u = r.length;
      for (n = new Array(u), o = new Array(u), l = 0; l < u; ++l)
        n[l] = isNaN(o[l] = +e(r[l], l, r)) ? 0 : +t(r[l], l, r);
    }
  }
  return s.initialize = function(l) {
    r = l, a();
  }, s.strength = function(l) {
    return arguments.length ? (t = typeof l == "function" ? l : Kn(+l), a(), s) : t;
  }, s.y = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : Kn(+l), a(), s) : e;
  }, s;
}
function e2(e) {
  return function() {
    return e;
  };
}
function bve(e) {
  let t = 3;
  return e.digits = function(r) {
    if (!arguments.length)
      return t;
    if (r == null)
      t = null;
    else {
      const n = Math.floor(r);
      if (!(n >= 0))
        throw new RangeError(`invalid digits: ${r}`);
      t = n;
    }
    return e;
  }, () => new ove(t);
}
var yve = Array.prototype.slice;
function vve(e) {
  return e[0];
}
function mve(e) {
  return e[1];
}
class _ve {
  constructor(t, r) {
    this._context = t, this._x = r;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(t, r) {
    switch (t = +t, r = +r, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(t, r) : this._context.moveTo(t, r);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, r, t, r) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + r) / 2, t, this._y0, t, r);
        break;
      }
    }
    this._x0 = t, this._y0 = r;
  }
}
function wve(e) {
  return new _ve(e, !0);
}
function Sve(e) {
  return e.source;
}
function Eve(e) {
  return e.target;
}
function xve(e) {
  let t = Sve, r = Eve, n = vve, o = mve, s = null, a = null, l = bve(u);
  function u() {
    let f;
    const c = yve.call(arguments), d = t.apply(this, c), h = r.apply(this, c);
    if (s == null && (a = e(f = l())), a.lineStart(), c[0] = d, a.point(+n.apply(this, c), +o.apply(this, c)), c[0] = h, a.point(+n.apply(this, c), +o.apply(this, c)), a.lineEnd(), f)
      return a = null, f + "" || null;
  }
  return u.source = function(f) {
    return arguments.length ? (t = f, u) : t;
  }, u.target = function(f) {
    return arguments.length ? (r = f, u) : r;
  }, u.x = function(f) {
    return arguments.length ? (n = typeof f == "function" ? f : e2(+f), u) : n;
  }, u.y = function(f) {
    return arguments.length ? (o = typeof f == "function" ? f : e2(+f), u) : o;
  }, u.context = function(f) {
    return arguments.length ? (f == null ? s = a = null : a = e(s = f), u) : s;
  }, u;
}
function Rve() {
  return xve(wve);
}
const Cd = (e) => () => e;
function Ave(e, {
  sourceEvent: t,
  target: r,
  transform: n,
  dispatch: o
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: r, enumerable: !0, configurable: !0 },
    transform: { value: n, enumerable: !0, configurable: !0 },
    _: { value: o }
  });
}
function Zi(e, t, r) {
  this.k = e, this.x = t, this.y = r;
}
Zi.prototype = {
  constructor: Zi,
  scale: function(e) {
    return e === 1 ? this : new Zi(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new Zi(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var Gg = new Zi(1, 0, 0);
nA.prototype = Zi.prototype;
function nA(e) {
  for (; !e.__zoom; )
    if (!(e = e.parentNode))
      return Gg;
  return e.__zoom;
}
function C0(e) {
  e.stopImmediatePropagation();
}
function Uu(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function Tve(e) {
  return (!e.ctrlKey || e.type === "wheel") && !e.button;
}
function $ve() {
  var e = this;
  return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
}
function t2() {
  return this.__zoom || Gg;
}
function Nve(e) {
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
}
function kve() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Cve(e, t, r) {
  var n = e.invertX(t[0][0]) - r[0][0], o = e.invertX(t[1][0]) - r[1][0], s = e.invertY(t[0][1]) - r[0][1], a = e.invertY(t[1][1]) - r[1][1];
  return e.translate(
    o > n ? (n + o) / 2 : Math.min(0, n) || Math.max(0, o),
    a > s ? (s + a) / 2 : Math.min(0, s) || Math.max(0, a)
  );
}
function Ive() {
  var e = Tve, t = $ve, r = Cve, n = Nve, o = kve, s = [0, 1 / 0], a = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], l = 250, u = Vye, f = Oc("start", "zoom", "end"), c, d, h, p = 500, v = 150, y = 0, w = 10;
  function S(U) {
    U.property("__zoom", t2).on("wheel.zoom", z, { passive: !1 }).on("mousedown.zoom", $).on("dblclick.zoom", G).filter(o).on("touchstart.zoom", I).on("touchmove.zoom", W).on("touchend.zoom touchcancel.zoom", k).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  S.transform = function(U, Z, Y, re) {
    var ae = U.selection ? U.selection() : U;
    ae.property("__zoom", t2), U !== ae ? C(U, Z, Y, re) : ae.interrupt().each(function() {
      j(this, arguments).event(re).start().zoom(null, typeof Z == "function" ? Z.apply(this, arguments) : Z).end();
    });
  }, S.scaleBy = function(U, Z, Y, re) {
    S.scaleTo(U, function() {
      var ae = this.__zoom.k, ce = typeof Z == "function" ? Z.apply(this, arguments) : Z;
      return ae * ce;
    }, Y, re);
  }, S.scaleTo = function(U, Z, Y, re) {
    S.transform(U, function() {
      var ae = t.apply(this, arguments), ce = this.__zoom, pe = Y == null ? N(ae) : typeof Y == "function" ? Y.apply(this, arguments) : Y, le = ce.invert(pe), ye = typeof Z == "function" ? Z.apply(this, arguments) : Z;
      return r(E(x(ce, ye), pe, le), ae, a);
    }, Y, re);
  }, S.translateBy = function(U, Z, Y, re) {
    S.transform(U, function() {
      return r(this.__zoom.translate(
        typeof Z == "function" ? Z.apply(this, arguments) : Z,
        typeof Y == "function" ? Y.apply(this, arguments) : Y
      ), t.apply(this, arguments), a);
    }, null, re);
  }, S.translateTo = function(U, Z, Y, re, ae) {
    S.transform(U, function() {
      var ce = t.apply(this, arguments), pe = this.__zoom, le = re == null ? N(ce) : typeof re == "function" ? re.apply(this, arguments) : re;
      return r(Gg.translate(le[0], le[1]).scale(pe.k).translate(
        typeof Z == "function" ? -Z.apply(this, arguments) : -Z,
        typeof Y == "function" ? -Y.apply(this, arguments) : -Y
      ), ce, a);
    }, re, ae);
  };
  function x(U, Z) {
    return Z = Math.max(s[0], Math.min(s[1], Z)), Z === U.k ? U : new Zi(Z, U.x, U.y);
  }
  function E(U, Z, Y) {
    var re = Z[0] - Y[0] * U.k, ae = Z[1] - Y[1] * U.k;
    return re === U.x && ae === U.y ? U : new Zi(U.k, re, ae);
  }
  function N(U) {
    return [(+U[0][0] + +U[1][0]) / 2, (+U[0][1] + +U[1][1]) / 2];
  }
  function C(U, Z, Y, re) {
    U.on("start.zoom", function() {
      j(this, arguments).event(re).start();
    }).on("interrupt.zoom end.zoom", function() {
      j(this, arguments).event(re).end();
    }).tween("zoom", function() {
      var ae = this, ce = arguments, pe = j(ae, ce).event(re), le = t.apply(ae, ce), ye = Y == null ? N(le) : typeof Y == "function" ? Y.apply(ae, ce) : Y, H = Math.max(le[1][0] - le[0][0], le[1][1] - le[0][1]), ge = ae.__zoom, Ce = typeof Z == "function" ? Z.apply(ae, ce) : Z, ue = u(ge.invert(ye).concat(H / ge.k), Ce.invert(ye).concat(H / Ce.k));
      return function(ee) {
        if (ee === 1)
          ee = Ce;
        else {
          var be = ue(ee), Te = H / be[2];
          ee = new Zi(Te, ye[0] - be[0] * Te, ye[1] - be[1] * Te);
        }
        pe.zoom(null, ee);
      };
    });
  }
  function j(U, Z, Y) {
    return !Y && U.__zooming || new J(U, Z);
  }
  function J(U, Z) {
    this.that = U, this.args = Z, this.active = 0, this.sourceEvent = null, this.extent = t.apply(U, Z), this.taps = 0;
  }
  J.prototype = {
    event: function(U) {
      return U && (this.sourceEvent = U), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(U, Z) {
      return this.mouse && U !== "mouse" && (this.mouse[1] = Z.invert(this.mouse[0])), this.touch0 && U !== "touch" && (this.touch0[1] = Z.invert(this.touch0[0])), this.touch1 && U !== "touch" && (this.touch1[1] = Z.invert(this.touch1[0])), this.that.__zoom = Z, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(U) {
      var Z = _n(this.that).datum();
      f.call(
        U,
        this.that,
        new Ave(U, {
          sourceEvent: this.sourceEvent,
          target: S,
          type: U,
          transform: this.that.__zoom,
          dispatch: f
        }),
        Z
      );
    }
  };
  function z(U, ...Z) {
    if (!e.apply(this, arguments))
      return;
    var Y = j(this, Z).event(U), re = this.__zoom, ae = Math.max(s[0], Math.min(s[1], re.k * Math.pow(2, n.apply(this, arguments)))), ce = Xi(U);
    if (Y.wheel)
      (Y.mouse[0][0] !== ce[0] || Y.mouse[0][1] !== ce[1]) && (Y.mouse[1] = re.invert(Y.mouse[0] = ce)), clearTimeout(Y.wheel);
    else {
      if (re.k === ae)
        return;
      Y.mouse = [ce, re.invert(ce)], nh(this), Y.start();
    }
    Uu(U), Y.wheel = setTimeout(pe, v), Y.zoom("mouse", r(E(x(re, ae), Y.mouse[0], Y.mouse[1]), Y.extent, a));
    function pe() {
      Y.wheel = null, Y.end();
    }
  }
  function $(U, ...Z) {
    if (h || !e.apply(this, arguments))
      return;
    var Y = U.currentTarget, re = j(this, Z, !0).event(U), ae = _n(U.view).on("mousemove.zoom", ye, !0).on("mouseup.zoom", H, !0), ce = Xi(U, Y), pe = U.clientX, le = U.clientY;
    Tq(U.view), C0(U), re.mouse = [ce, this.__zoom.invert(ce)], nh(this), re.start();
    function ye(ge) {
      if (Uu(ge), !re.moved) {
        var Ce = ge.clientX - pe, ue = ge.clientY - le;
        re.moved = Ce * Ce + ue * ue > y;
      }
      re.event(ge).zoom("mouse", r(E(re.that.__zoom, re.mouse[0] = Xi(ge, Y), re.mouse[1]), re.extent, a));
    }
    function H(ge) {
      ae.on("mousemove.zoom mouseup.zoom", null), $q(ge.view, re.moved), Uu(ge), re.event(ge).end();
    }
  }
  function G(U, ...Z) {
    if (e.apply(this, arguments)) {
      var Y = this.__zoom, re = Xi(U.changedTouches ? U.changedTouches[0] : U, this), ae = Y.invert(re), ce = Y.k * (U.shiftKey ? 0.5 : 2), pe = r(E(x(Y, ce), re, ae), t.apply(this, Z), a);
      Uu(U), l > 0 ? _n(this).transition().duration(l).call(C, pe, re, U) : _n(this).call(S.transform, pe, re, U);
    }
  }
  function I(U, ...Z) {
    if (e.apply(this, arguments)) {
      var Y = U.touches, re = Y.length, ae = j(this, Z, U.changedTouches.length === re).event(U), ce, pe, le, ye;
      for (C0(U), pe = 0; pe < re; ++pe)
        le = Y[pe], ye = Xi(le, this), ye = [ye, this.__zoom.invert(ye), le.identifier], ae.touch0 ? !ae.touch1 && ae.touch0[2] !== ye[2] && (ae.touch1 = ye, ae.taps = 0) : (ae.touch0 = ye, ce = !0, ae.taps = 1 + !!c);
      c && (c = clearTimeout(c)), ce && (ae.taps < 2 && (d = ye[0], c = setTimeout(function() {
        c = null;
      }, p)), nh(this), ae.start());
    }
  }
  function W(U, ...Z) {
    if (this.__zooming) {
      var Y = j(this, Z).event(U), re = U.changedTouches, ae = re.length, ce, pe, le, ye;
      for (Uu(U), ce = 0; ce < ae; ++ce)
        pe = re[ce], le = Xi(pe, this), Y.touch0 && Y.touch0[2] === pe.identifier ? Y.touch0[0] = le : Y.touch1 && Y.touch1[2] === pe.identifier && (Y.touch1[0] = le);
      if (pe = Y.that.__zoom, Y.touch1) {
        var H = Y.touch0[0], ge = Y.touch0[1], Ce = Y.touch1[0], ue = Y.touch1[1], ee = (ee = Ce[0] - H[0]) * ee + (ee = Ce[1] - H[1]) * ee, be = (be = ue[0] - ge[0]) * be + (be = ue[1] - ge[1]) * be;
        pe = x(pe, Math.sqrt(ee / be)), le = [(H[0] + Ce[0]) / 2, (H[1] + Ce[1]) / 2], ye = [(ge[0] + ue[0]) / 2, (ge[1] + ue[1]) / 2];
      } else if (Y.touch0)
        le = Y.touch0[0], ye = Y.touch0[1];
      else
        return;
      Y.zoom("touch", r(E(pe, le, ye), Y.extent, a));
    }
  }
  function k(U, ...Z) {
    if (this.__zooming) {
      var Y = j(this, Z).event(U), re = U.changedTouches, ae = re.length, ce, pe;
      for (C0(U), h && clearTimeout(h), h = setTimeout(function() {
        h = null;
      }, p), ce = 0; ce < ae; ++ce)
        pe = re[ce], Y.touch0 && Y.touch0[2] === pe.identifier ? delete Y.touch0 : Y.touch1 && Y.touch1[2] === pe.identifier && delete Y.touch1;
      if (Y.touch1 && !Y.touch0 && (Y.touch0 = Y.touch1, delete Y.touch1), Y.touch0)
        Y.touch0[1] = this.__zoom.invert(Y.touch0[0]);
      else if (Y.end(), Y.taps === 2 && (pe = Xi(pe, this), Math.hypot(d[0] - pe[0], d[1] - pe[1]) < w)) {
        var le = _n(this).on("dblclick.zoom");
        le && le.apply(this, arguments);
      }
    }
  }
  return S.wheelDelta = function(U) {
    return arguments.length ? (n = typeof U == "function" ? U : Cd(+U), S) : n;
  }, S.filter = function(U) {
    return arguments.length ? (e = typeof U == "function" ? U : Cd(!!U), S) : e;
  }, S.touchable = function(U) {
    return arguments.length ? (o = typeof U == "function" ? U : Cd(!!U), S) : o;
  }, S.extent = function(U) {
    return arguments.length ? (t = typeof U == "function" ? U : Cd([[+U[0][0], +U[0][1]], [+U[1][0], +U[1][1]]]), S) : t;
  }, S.scaleExtent = function(U) {
    return arguments.length ? (s[0] = +U[0], s[1] = +U[1], S) : [s[0], s[1]];
  }, S.translateExtent = function(U) {
    return arguments.length ? (a[0][0] = +U[0][0], a[1][0] = +U[1][0], a[0][1] = +U[0][1], a[1][1] = +U[1][1], S) : [[a[0][0], a[0][1]], [a[1][0], a[1][1]]];
  }, S.constrain = function(U) {
    return arguments.length ? (r = U, S) : r;
  }, S.duration = function(U) {
    return arguments.length ? (l = +U, S) : l;
  }, S.interpolate = function(U) {
    return arguments.length ? (u = U, S) : u;
  }, S.on = function() {
    var U = f.on.apply(f, arguments);
    return U === f ? S : U;
  }, S.clickDistance = function(U) {
    return arguments.length ? (y = (U = +U) * U, S) : Math.sqrt(y);
  }, S.tapDistance = function(U) {
    return arguments.length ? (w = +U, S) : w;
  }, S;
}
function iA(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var I0, r2;
function Mve() {
  if (r2)
    return I0;
  r2 = 1;
  function e() {
    this.__data__ = [], this.size = 0;
  }
  return I0 = e, I0;
}
var M0, n2;
function Tu() {
  if (n2)
    return M0;
  n2 = 1;
  function e(t, r) {
    return t === r || t !== t && r !== r;
  }
  return M0 = e, M0;
}
var O0, i2;
function Kg() {
  if (i2)
    return O0;
  i2 = 1;
  var e = Tu();
  function t(r, n) {
    for (var o = r.length; o--; )
      if (e(r[o][0], n))
        return o;
    return -1;
  }
  return O0 = t, O0;
}
var L0, o2;
function Ove() {
  if (o2)
    return L0;
  o2 = 1;
  var e = Kg(), t = Array.prototype, r = t.splice;
  function n(o) {
    var s = this.__data__, a = e(s, o);
    if (a < 0)
      return !1;
    var l = s.length - 1;
    return a == l ? s.pop() : r.call(s, a, 1), --this.size, !0;
  }
  return L0 = n, L0;
}
var P0, s2;
function Lve() {
  if (s2)
    return P0;
  s2 = 1;
  var e = Kg();
  function t(r) {
    var n = this.__data__, o = e(n, r);
    return o < 0 ? void 0 : n[o][1];
  }
  return P0 = t, P0;
}
var D0, a2;
function Pve() {
  if (a2)
    return D0;
  a2 = 1;
  var e = Kg();
  function t(r) {
    return e(this.__data__, r) > -1;
  }
  return D0 = t, D0;
}
var F0, l2;
function Dve() {
  if (l2)
    return F0;
  l2 = 1;
  var e = Kg();
  function t(r, n) {
    var o = this.__data__, s = e(o, r);
    return s < 0 ? (++this.size, o.push([r, n])) : o[s][1] = n, this;
  }
  return F0 = t, F0;
}
var j0, u2;
function Yg() {
  if (u2)
    return j0;
  u2 = 1;
  var e = Mve(), t = Ove(), r = Lve(), n = Pve(), o = Dve();
  function s(a) {
    var l = -1, u = a == null ? 0 : a.length;
    for (this.clear(); ++l < u; ) {
      var f = a[l];
      this.set(f[0], f[1]);
    }
  }
  return s.prototype.clear = e, s.prototype.delete = t, s.prototype.get = r, s.prototype.has = n, s.prototype.set = o, j0 = s, j0;
}
var B0, f2;
function Fve() {
  if (f2)
    return B0;
  f2 = 1;
  var e = Yg();
  function t() {
    this.__data__ = new e(), this.size = 0;
  }
  return B0 = t, B0;
}
var q0, c2;
function jve() {
  if (c2)
    return q0;
  c2 = 1;
  function e(t) {
    var r = this.__data__, n = r.delete(t);
    return this.size = r.size, n;
  }
  return q0 = e, q0;
}
var W0, d2;
function Bve() {
  if (d2)
    return W0;
  d2 = 1;
  function e(t) {
    return this.__data__.get(t);
  }
  return W0 = e, W0;
}
var U0, h2;
function qve() {
  if (h2)
    return U0;
  h2 = 1;
  function e(t) {
    return this.__data__.has(t);
  }
  return U0 = e, U0;
}
var H0, p2;
function Dc() {
  if (p2)
    return H0;
  p2 = 1;
  var e = Ka(), t = In(), r = "[object AsyncFunction]", n = "[object Function]", o = "[object GeneratorFunction]", s = "[object Proxy]";
  function a(l) {
    if (!t(l))
      return !1;
    var u = e(l);
    return u == n || u == o || u == r || u == s;
  }
  return H0 = a, H0;
}
var V0, g2;
function Wve() {
  if (g2)
    return V0;
  g2 = 1;
  var e = Zn(), t = e["__core-js_shared__"];
  return V0 = t, V0;
}
var z0, b2;
function Uve() {
  if (b2)
    return z0;
  b2 = 1;
  var e = Wve(), t = function() {
    var n = /[^.]+$/.exec(e && e.keys && e.keys.IE_PROTO || "");
    return n ? "Symbol(src)_1." + n : "";
  }();
  function r(n) {
    return !!t && t in n;
  }
  return z0 = r, z0;
}
var G0, y2;
function Wq() {
  if (y2)
    return G0;
  y2 = 1;
  var e = Function.prototype, t = e.toString;
  function r(n) {
    if (n != null) {
      try {
        return t.call(n);
      } catch {
      }
      try {
        return n + "";
      } catch {
      }
    }
    return "";
  }
  return G0 = r, G0;
}
var K0, v2;
function Hve() {
  if (v2)
    return K0;
  v2 = 1;
  var e = Dc(), t = Uve(), r = In(), n = Wq(), o = /[\\^$.*+?()[\]{}|]/g, s = /^\[object .+?Constructor\]$/, a = Function.prototype, l = Object.prototype, u = a.toString, f = l.hasOwnProperty, c = RegExp(
    "^" + u.call(f).replace(o, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function d(h) {
    if (!r(h) || t(h))
      return !1;
    var p = e(h) ? c : s;
    return p.test(n(h));
  }
  return K0 = d, K0;
}
var Y0, m2;
function Vve() {
  if (m2)
    return Y0;
  m2 = 1;
  function e(t, r) {
    return t == null ? void 0 : t[r];
  }
  return Y0 = e, Y0;
}
var X0, _2;
function ol() {
  if (_2)
    return X0;
  _2 = 1;
  var e = Hve(), t = Vve();
  function r(n, o) {
    var s = t(n, o);
    return e(s) ? s : void 0;
  }
  return X0 = r, X0;
}
var J0, w2;
function oA() {
  if (w2)
    return J0;
  w2 = 1;
  var e = ol(), t = Zn(), r = e(t, "Map");
  return J0 = r, J0;
}
var Q0, S2;
function Xg() {
  if (S2)
    return Q0;
  S2 = 1;
  var e = ol(), t = e(Object, "create");
  return Q0 = t, Q0;
}
var Z0, E2;
function zve() {
  if (E2)
    return Z0;
  E2 = 1;
  var e = Xg();
  function t() {
    this.__data__ = e ? e(null) : {}, this.size = 0;
  }
  return Z0 = t, Z0;
}
var ev, x2;
function Gve() {
  if (x2)
    return ev;
  x2 = 1;
  function e(t) {
    var r = this.has(t) && delete this.__data__[t];
    return this.size -= r ? 1 : 0, r;
  }
  return ev = e, ev;
}
var tv, R2;
function Kve() {
  if (R2)
    return tv;
  R2 = 1;
  var e = Xg(), t = "__lodash_hash_undefined__", r = Object.prototype, n = r.hasOwnProperty;
  function o(s) {
    var a = this.__data__;
    if (e) {
      var l = a[s];
      return l === t ? void 0 : l;
    }
    return n.call(a, s) ? a[s] : void 0;
  }
  return tv = o, tv;
}
var rv, A2;
function Yve() {
  if (A2)
    return rv;
  A2 = 1;
  var e = Xg(), t = Object.prototype, r = t.hasOwnProperty;
  function n(o) {
    var s = this.__data__;
    return e ? s[o] !== void 0 : r.call(s, o);
  }
  return rv = n, rv;
}
var nv, T2;
function Xve() {
  if (T2)
    return nv;
  T2 = 1;
  var e = Xg(), t = "__lodash_hash_undefined__";
  function r(n, o) {
    var s = this.__data__;
    return this.size += this.has(n) ? 0 : 1, s[n] = e && o === void 0 ? t : o, this;
  }
  return nv = r, nv;
}
var iv, $2;
function Jve() {
  if ($2)
    return iv;
  $2 = 1;
  var e = zve(), t = Gve(), r = Kve(), n = Yve(), o = Xve();
  function s(a) {
    var l = -1, u = a == null ? 0 : a.length;
    for (this.clear(); ++l < u; ) {
      var f = a[l];
      this.set(f[0], f[1]);
    }
  }
  return s.prototype.clear = e, s.prototype.delete = t, s.prototype.get = r, s.prototype.has = n, s.prototype.set = o, iv = s, iv;
}
var ov, N2;
function Qve() {
  if (N2)
    return ov;
  N2 = 1;
  var e = Jve(), t = Yg(), r = oA();
  function n() {
    this.size = 0, this.__data__ = {
      hash: new e(),
      map: new (r || t)(),
      string: new e()
    };
  }
  return ov = n, ov;
}
var sv, k2;
function Zve() {
  if (k2)
    return sv;
  k2 = 1;
  function e(t) {
    var r = typeof t;
    return r == "string" || r == "number" || r == "symbol" || r == "boolean" ? t !== "__proto__" : t === null;
  }
  return sv = e, sv;
}
var av, C2;
function Jg() {
  if (C2)
    return av;
  C2 = 1;
  var e = Zve();
  function t(r, n) {
    var o = r.__data__;
    return e(n) ? o[typeof n == "string" ? "string" : "hash"] : o.map;
  }
  return av = t, av;
}
var lv, I2;
function eme() {
  if (I2)
    return lv;
  I2 = 1;
  var e = Jg();
  function t(r) {
    var n = e(this, r).delete(r);
    return this.size -= n ? 1 : 0, n;
  }
  return lv = t, lv;
}
var uv, M2;
function tme() {
  if (M2)
    return uv;
  M2 = 1;
  var e = Jg();
  function t(r) {
    return e(this, r).get(r);
  }
  return uv = t, uv;
}
var fv, O2;
function rme() {
  if (O2)
    return fv;
  O2 = 1;
  var e = Jg();
  function t(r) {
    return e(this, r).has(r);
  }
  return fv = t, fv;
}
var cv, L2;
function nme() {
  if (L2)
    return cv;
  L2 = 1;
  var e = Jg();
  function t(r, n) {
    var o = e(this, r), s = o.size;
    return o.set(r, n), this.size += o.size == s ? 0 : 1, this;
  }
  return cv = t, cv;
}
var dv, P2;
function sA() {
  if (P2)
    return dv;
  P2 = 1;
  var e = Qve(), t = eme(), r = tme(), n = rme(), o = nme();
  function s(a) {
    var l = -1, u = a == null ? 0 : a.length;
    for (this.clear(); ++l < u; ) {
      var f = a[l];
      this.set(f[0], f[1]);
    }
  }
  return s.prototype.clear = e, s.prototype.delete = t, s.prototype.get = r, s.prototype.has = n, s.prototype.set = o, dv = s, dv;
}
var hv, D2;
function ime() {
  if (D2)
    return hv;
  D2 = 1;
  var e = Yg(), t = oA(), r = sA(), n = 200;
  function o(s, a) {
    var l = this.__data__;
    if (l instanceof e) {
      var u = l.__data__;
      if (!t || u.length < n - 1)
        return u.push([s, a]), this.size = ++l.size, this;
      l = this.__data__ = new r(u);
    }
    return l.set(s, a), this.size = l.size, this;
  }
  return hv = o, hv;
}
var pv, F2;
function Qg() {
  if (F2)
    return pv;
  F2 = 1;
  var e = Yg(), t = Fve(), r = jve(), n = Bve(), o = qve(), s = ime();
  function a(l) {
    var u = this.__data__ = new e(l);
    this.size = u.size;
  }
  return a.prototype.clear = t, a.prototype.delete = r, a.prototype.get = n, a.prototype.has = o, a.prototype.set = s, pv = a, pv;
}
var gv, j2;
function aA() {
  if (j2)
    return gv;
  j2 = 1;
  function e(t, r) {
    for (var n = -1, o = t == null ? 0 : t.length; ++n < o && r(t[n], n, t) !== !1; )
      ;
    return t;
  }
  return gv = e, gv;
}
var bv, B2;
function Uq() {
  if (B2)
    return bv;
  B2 = 1;
  var e = ol(), t = function() {
    try {
      var r = e(Object, "defineProperty");
      return r({}, "", {}), r;
    } catch {
    }
  }();
  return bv = t, bv;
}
var yv, q2;
function Zg() {
  if (q2)
    return yv;
  q2 = 1;
  var e = Uq();
  function t(r, n, o) {
    n == "__proto__" && e ? e(r, n, {
      configurable: !0,
      enumerable: !0,
      value: o,
      writable: !0
    }) : r[n] = o;
  }
  return yv = t, yv;
}
var vv, W2;
function eb() {
  if (W2)
    return vv;
  W2 = 1;
  var e = Zg(), t = Tu(), r = Object.prototype, n = r.hasOwnProperty;
  function o(s, a, l) {
    var u = s[a];
    (!(n.call(s, a) && t(u, l)) || l === void 0 && !(a in s)) && e(s, a, l);
  }
  return vv = o, vv;
}
var mv, U2;
function Fc() {
  if (U2)
    return mv;
  U2 = 1;
  var e = eb(), t = Zg();
  function r(n, o, s, a) {
    var l = !s;
    s || (s = {});
    for (var u = -1, f = o.length; ++u < f; ) {
      var c = o[u], d = a ? a(s[c], n[c], c, s, n) : void 0;
      d === void 0 && (d = n[c]), l ? t(s, c, d) : e(s, c, d);
    }
    return s;
  }
  return mv = r, mv;
}
var _v, H2;
function ome() {
  if (H2)
    return _v;
  H2 = 1;
  function e(t, r) {
    for (var n = -1, o = Array(t); ++n < t; )
      o[n] = r(n);
    return o;
  }
  return _v = e, _v;
}
var wv, V2;
function sme() {
  if (V2)
    return wv;
  V2 = 1;
  var e = Ka(), t = ji(), r = "[object Arguments]";
  function n(o) {
    return t(o) && e(o) == r;
  }
  return wv = n, wv;
}
var Sv, z2;
function jc() {
  if (z2)
    return Sv;
  z2 = 1;
  var e = sme(), t = ji(), r = Object.prototype, n = r.hasOwnProperty, o = r.propertyIsEnumerable, s = e(/* @__PURE__ */ function() {
    return arguments;
  }()) ? e : function(a) {
    return t(a) && n.call(a, "callee") && !o.call(a, "callee");
  };
  return Sv = s, Sv;
}
var Ev, G2;
function Yt() {
  if (G2)
    return Ev;
  G2 = 1;
  var e = Array.isArray;
  return Ev = e, Ev;
}
var lf = { exports: {} }, xv, K2;
function ame() {
  if (K2)
    return xv;
  K2 = 1;
  function e() {
    return !1;
  }
  return xv = e, xv;
}
lf.exports;
var Y2;
function $u() {
  return Y2 || (Y2 = 1, function(e, t) {
    var r = Zn(), n = ame(), o = t && !t.nodeType && t, s = o && !0 && e && !e.nodeType && e, a = s && s.exports === o, l = a ? r.Buffer : void 0, u = l ? l.isBuffer : void 0, f = u || n;
    e.exports = f;
  }(lf, lf.exports)), lf.exports;
}
var Rv, X2;
function tb() {
  if (X2)
    return Rv;
  X2 = 1;
  var e = 9007199254740991, t = /^(?:0|[1-9]\d*)$/;
  function r(n, o) {
    var s = typeof n;
    return o = o ?? e, !!o && (s == "number" || s != "symbol" && t.test(n)) && n > -1 && n % 1 == 0 && n < o;
  }
  return Rv = r, Rv;
}
var Av, J2;
function lA() {
  if (J2)
    return Av;
  J2 = 1;
  var e = 9007199254740991;
  function t(r) {
    return typeof r == "number" && r > -1 && r % 1 == 0 && r <= e;
  }
  return Av = t, Av;
}
var Tv, Q2;
function lme() {
  if (Q2)
    return Tv;
  Q2 = 1;
  var e = Ka(), t = lA(), r = ji(), n = "[object Arguments]", o = "[object Array]", s = "[object Boolean]", a = "[object Date]", l = "[object Error]", u = "[object Function]", f = "[object Map]", c = "[object Number]", d = "[object Object]", h = "[object RegExp]", p = "[object Set]", v = "[object String]", y = "[object WeakMap]", w = "[object ArrayBuffer]", S = "[object DataView]", x = "[object Float32Array]", E = "[object Float64Array]", N = "[object Int8Array]", C = "[object Int16Array]", j = "[object Int32Array]", J = "[object Uint8Array]", z = "[object Uint8ClampedArray]", $ = "[object Uint16Array]", G = "[object Uint32Array]", I = {};
  I[x] = I[E] = I[N] = I[C] = I[j] = I[J] = I[z] = I[$] = I[G] = !0, I[n] = I[o] = I[w] = I[s] = I[S] = I[a] = I[l] = I[u] = I[f] = I[c] = I[d] = I[h] = I[p] = I[v] = I[y] = !1;
  function W(k) {
    return r(k) && t(k.length) && !!I[e(k)];
  }
  return Tv = W, Tv;
}
var $v, Z2;
function rb() {
  if (Z2)
    return $v;
  Z2 = 1;
  function e(t) {
    return function(r) {
      return t(r);
    };
  }
  return $v = e, $v;
}
var uf = { exports: {} };
uf.exports;
var eM;
function uA() {
  return eM || (eM = 1, function(e, t) {
    var r = T7(), n = t && !t.nodeType && t, o = n && !0 && e && !e.nodeType && e, s = o && o.exports === n, a = s && r.process, l = function() {
      try {
        var u = o && o.require && o.require("util").types;
        return u || a && a.binding && a.binding("util");
      } catch {
      }
    }();
    e.exports = l;
  }(uf, uf.exports)), uf.exports;
}
var Nv, tM;
function Bc() {
  if (tM)
    return Nv;
  tM = 1;
  var e = lme(), t = rb(), r = uA(), n = r && r.isTypedArray, o = n ? t(n) : e;
  return Nv = o, Nv;
}
var kv, rM;
function Hq() {
  if (rM)
    return kv;
  rM = 1;
  var e = ome(), t = jc(), r = Yt(), n = $u(), o = tb(), s = Bc(), a = Object.prototype, l = a.hasOwnProperty;
  function u(f, c) {
    var d = r(f), h = !d && t(f), p = !d && !h && n(f), v = !d && !h && !p && s(f), y = d || h || p || v, w = y ? e(f.length, String) : [], S = w.length;
    for (var x in f)
      (c || l.call(f, x)) && !(y && // Safari 9 has enumerable `arguments.length` in strict mode.
      (x == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      p && (x == "offset" || x == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      v && (x == "buffer" || x == "byteLength" || x == "byteOffset") || // Skip index properties.
      o(x, S))) && w.push(x);
    return w;
  }
  return kv = u, kv;
}
var Cv, nM;
function nb() {
  if (nM)
    return Cv;
  nM = 1;
  var e = Object.prototype;
  function t(r) {
    var n = r && r.constructor, o = typeof n == "function" && n.prototype || e;
    return r === o;
  }
  return Cv = t, Cv;
}
var Iv, iM;
function Vq() {
  if (iM)
    return Iv;
  iM = 1;
  function e(t, r) {
    return function(n) {
      return t(r(n));
    };
  }
  return Iv = e, Iv;
}
var Mv, oM;
function ume() {
  if (oM)
    return Mv;
  oM = 1;
  var e = Vq(), t = e(Object.keys, Object);
  return Mv = t, Mv;
}
var Ov, sM;
function fA() {
  if (sM)
    return Ov;
  sM = 1;
  var e = nb(), t = ume(), r = Object.prototype, n = r.hasOwnProperty;
  function o(s) {
    if (!e(s))
      return t(s);
    var a = [];
    for (var l in Object(s))
      n.call(s, l) && l != "constructor" && a.push(l);
    return a;
  }
  return Ov = o, Ov;
}
var Lv, aM;
function No() {
  if (aM)
    return Lv;
  aM = 1;
  var e = Dc(), t = lA();
  function r(n) {
    return n != null && t(n.length) && !e(n);
  }
  return Lv = r, Lv;
}
var Pv, lM;
function Rs() {
  if (lM)
    return Pv;
  lM = 1;
  var e = Hq(), t = fA(), r = No();
  function n(o) {
    return r(o) ? e(o) : t(o);
  }
  return Pv = n, Pv;
}
var Dv, uM;
function fme() {
  if (uM)
    return Dv;
  uM = 1;
  var e = Fc(), t = Rs();
  function r(n, o) {
    return n && e(o, t(o), n);
  }
  return Dv = r, Dv;
}
var Fv, fM;
function cme() {
  if (fM)
    return Fv;
  fM = 1;
  function e(t) {
    var r = [];
    if (t != null)
      for (var n in Object(t))
        r.push(n);
    return r;
  }
  return Fv = e, Fv;
}
var jv, cM;
function dme() {
  if (cM)
    return jv;
  cM = 1;
  var e = In(), t = nb(), r = cme(), n = Object.prototype, o = n.hasOwnProperty;
  function s(a) {
    if (!e(a))
      return r(a);
    var l = t(a), u = [];
    for (var f in a)
      f == "constructor" && (l || !o.call(a, f)) || u.push(f);
    return u;
  }
  return jv = s, jv;
}
var Bv, dM;
function sl() {
  if (dM)
    return Bv;
  dM = 1;
  var e = Hq(), t = dme(), r = No();
  function n(o) {
    return r(o) ? e(o, !0) : t(o);
  }
  return Bv = n, Bv;
}
var qv, hM;
function hme() {
  if (hM)
    return qv;
  hM = 1;
  var e = Fc(), t = sl();
  function r(n, o) {
    return n && e(o, t(o), n);
  }
  return qv = r, qv;
}
var ff = { exports: {} };
ff.exports;
var pM;
function zq() {
  return pM || (pM = 1, function(e, t) {
    var r = Zn(), n = t && !t.nodeType && t, o = n && !0 && e && !e.nodeType && e, s = o && o.exports === n, a = s ? r.Buffer : void 0, l = a ? a.allocUnsafe : void 0;
    function u(f, c) {
      if (c)
        return f.slice();
      var d = f.length, h = l ? l(d) : new f.constructor(d);
      return f.copy(h), h;
    }
    e.exports = u;
  }(ff, ff.exports)), ff.exports;
}
var Wv, gM;
function Gq() {
  if (gM)
    return Wv;
  gM = 1;
  function e(t, r) {
    var n = -1, o = t.length;
    for (r || (r = Array(o)); ++n < o; )
      r[n] = t[n];
    return r;
  }
  return Wv = e, Wv;
}
var Uv, bM;
function Kq() {
  if (bM)
    return Uv;
  bM = 1;
  function e(t, r) {
    for (var n = -1, o = t == null ? 0 : t.length, s = 0, a = []; ++n < o; ) {
      var l = t[n];
      r(l, n, t) && (a[s++] = l);
    }
    return a;
  }
  return Uv = e, Uv;
}
var Hv, yM;
function Yq() {
  if (yM)
    return Hv;
  yM = 1;
  function e() {
    return [];
  }
  return Hv = e, Hv;
}
var Vv, vM;
function cA() {
  if (vM)
    return Vv;
  vM = 1;
  var e = Kq(), t = Yq(), r = Object.prototype, n = r.propertyIsEnumerable, o = Object.getOwnPropertySymbols, s = o ? function(a) {
    return a == null ? [] : (a = Object(a), e(o(a), function(l) {
      return n.call(a, l);
    }));
  } : t;
  return Vv = s, Vv;
}
var zv, mM;
function pme() {
  if (mM)
    return zv;
  mM = 1;
  var e = Fc(), t = cA();
  function r(n, o) {
    return e(n, t(n), o);
  }
  return zv = r, zv;
}
var Gv, _M;
function dA() {
  if (_M)
    return Gv;
  _M = 1;
  function e(t, r) {
    for (var n = -1, o = r.length, s = t.length; ++n < o; )
      t[s + n] = r[n];
    return t;
  }
  return Gv = e, Gv;
}
var Kv, wM;
function ib() {
  if (wM)
    return Kv;
  wM = 1;
  var e = Vq(), t = e(Object.getPrototypeOf, Object);
  return Kv = t, Kv;
}
var Yv, SM;
function Xq() {
  if (SM)
    return Yv;
  SM = 1;
  var e = dA(), t = ib(), r = cA(), n = Yq(), o = Object.getOwnPropertySymbols, s = o ? function(a) {
    for (var l = []; a; )
      e(l, r(a)), a = t(a);
    return l;
  } : n;
  return Yv = s, Yv;
}
var Xv, EM;
function gme() {
  if (EM)
    return Xv;
  EM = 1;
  var e = Fc(), t = Xq();
  function r(n, o) {
    return e(n, t(n), o);
  }
  return Xv = r, Xv;
}
var Jv, xM;
function Jq() {
  if (xM)
    return Jv;
  xM = 1;
  var e = dA(), t = Yt();
  function r(n, o, s) {
    var a = o(n);
    return t(n) ? a : e(a, s(n));
  }
  return Jv = r, Jv;
}
var Qv, RM;
function Qq() {
  if (RM)
    return Qv;
  RM = 1;
  var e = Jq(), t = cA(), r = Rs();
  function n(o) {
    return e(o, r, t);
  }
  return Qv = n, Qv;
}
var Zv, AM;
function bme() {
  if (AM)
    return Zv;
  AM = 1;
  var e = Jq(), t = Xq(), r = sl();
  function n(o) {
    return e(o, r, t);
  }
  return Zv = n, Zv;
}
var em, TM;
function yme() {
  if (TM)
    return em;
  TM = 1;
  var e = ol(), t = Zn(), r = e(t, "DataView");
  return em = r, em;
}
var tm, $M;
function vme() {
  if ($M)
    return tm;
  $M = 1;
  var e = ol(), t = Zn(), r = e(t, "Promise");
  return tm = r, tm;
}
var rm, NM;
function Zq() {
  if (NM)
    return rm;
  NM = 1;
  var e = ol(), t = Zn(), r = e(t, "Set");
  return rm = r, rm;
}
var nm, kM;
function mme() {
  if (kM)
    return nm;
  kM = 1;
  var e = ol(), t = Zn(), r = e(t, "WeakMap");
  return nm = r, nm;
}
var im, CM;
function Nu() {
  if (CM)
    return im;
  CM = 1;
  var e = yme(), t = oA(), r = vme(), n = Zq(), o = mme(), s = Ka(), a = Wq(), l = "[object Map]", u = "[object Object]", f = "[object Promise]", c = "[object Set]", d = "[object WeakMap]", h = "[object DataView]", p = a(e), v = a(t), y = a(r), w = a(n), S = a(o), x = s;
  return (e && x(new e(new ArrayBuffer(1))) != h || t && x(new t()) != l || r && x(r.resolve()) != f || n && x(new n()) != c || o && x(new o()) != d) && (x = function(E) {
    var N = s(E), C = N == u ? E.constructor : void 0, j = C ? a(C) : "";
    if (j)
      switch (j) {
        case p:
          return h;
        case v:
          return l;
        case y:
          return f;
        case w:
          return c;
        case S:
          return d;
      }
    return N;
  }), im = x, im;
}
var om, IM;
function _me() {
  if (IM)
    return om;
  IM = 1;
  var e = Object.prototype, t = e.hasOwnProperty;
  function r(n) {
    var o = n.length, s = new n.constructor(o);
    return o && typeof n[0] == "string" && t.call(n, "index") && (s.index = n.index, s.input = n.input), s;
  }
  return om = r, om;
}
var sm, MM;
function e6() {
  if (MM)
    return sm;
  MM = 1;
  var e = Zn(), t = e.Uint8Array;
  return sm = t, sm;
}
var am, OM;
function hA() {
  if (OM)
    return am;
  OM = 1;
  var e = e6();
  function t(r) {
    var n = new r.constructor(r.byteLength);
    return new e(n).set(new e(r)), n;
  }
  return am = t, am;
}
var lm, LM;
function wme() {
  if (LM)
    return lm;
  LM = 1;
  var e = hA();
  function t(r, n) {
    var o = n ? e(r.buffer) : r.buffer;
    return new r.constructor(o, r.byteOffset, r.byteLength);
  }
  return lm = t, lm;
}
var um, PM;
function Sme() {
  if (PM)
    return um;
  PM = 1;
  var e = /\w*$/;
  function t(r) {
    var n = new r.constructor(r.source, e.exec(r));
    return n.lastIndex = r.lastIndex, n;
  }
  return um = t, um;
}
var fm, DM;
function Eme() {
  if (DM)
    return fm;
  DM = 1;
  var e = bu(), t = e ? e.prototype : void 0, r = t ? t.valueOf : void 0;
  function n(o) {
    return r ? Object(r.call(o)) : {};
  }
  return fm = n, fm;
}
var cm, FM;
function t6() {
  if (FM)
    return cm;
  FM = 1;
  var e = hA();
  function t(r, n) {
    var o = n ? e(r.buffer) : r.buffer;
    return new r.constructor(o, r.byteOffset, r.length);
  }
  return cm = t, cm;
}
var dm, jM;
function xme() {
  if (jM)
    return dm;
  jM = 1;
  var e = hA(), t = wme(), r = Sme(), n = Eme(), o = t6(), s = "[object Boolean]", a = "[object Date]", l = "[object Map]", u = "[object Number]", f = "[object RegExp]", c = "[object Set]", d = "[object String]", h = "[object Symbol]", p = "[object ArrayBuffer]", v = "[object DataView]", y = "[object Float32Array]", w = "[object Float64Array]", S = "[object Int8Array]", x = "[object Int16Array]", E = "[object Int32Array]", N = "[object Uint8Array]", C = "[object Uint8ClampedArray]", j = "[object Uint16Array]", J = "[object Uint32Array]";
  function z($, G, I) {
    var W = $.constructor;
    switch (G) {
      case p:
        return e($);
      case s:
      case a:
        return new W(+$);
      case v:
        return t($, I);
      case y:
      case w:
      case S:
      case x:
      case E:
      case N:
      case C:
      case j:
      case J:
        return o($, I);
      case l:
        return new W();
      case u:
      case d:
        return new W($);
      case f:
        return r($);
      case c:
        return new W();
      case h:
        return n($);
    }
  }
  return dm = z, dm;
}
var hm, BM;
function r6() {
  if (BM)
    return hm;
  BM = 1;
  var e = In(), t = Object.create, r = /* @__PURE__ */ function() {
    function n() {
    }
    return function(o) {
      if (!e(o))
        return {};
      if (t)
        return t(o);
      n.prototype = o;
      var s = new n();
      return n.prototype = void 0, s;
    };
  }();
  return hm = r, hm;
}
var pm, qM;
function n6() {
  if (qM)
    return pm;
  qM = 1;
  var e = r6(), t = ib(), r = nb();
  function n(o) {
    return typeof o.constructor == "function" && !r(o) ? e(t(o)) : {};
  }
  return pm = n, pm;
}
var gm, WM;
function Rme() {
  if (WM)
    return gm;
  WM = 1;
  var e = Nu(), t = ji(), r = "[object Map]";
  function n(o) {
    return t(o) && e(o) == r;
  }
  return gm = n, gm;
}
var bm, UM;
function Ame() {
  if (UM)
    return bm;
  UM = 1;
  var e = Rme(), t = rb(), r = uA(), n = r && r.isMap, o = n ? t(n) : e;
  return bm = o, bm;
}
var ym, HM;
function Tme() {
  if (HM)
    return ym;
  HM = 1;
  var e = Nu(), t = ji(), r = "[object Set]";
  function n(o) {
    return t(o) && e(o) == r;
  }
  return ym = n, ym;
}
var vm, VM;
function $me() {
  if (VM)
    return vm;
  VM = 1;
  var e = Tme(), t = rb(), r = uA(), n = r && r.isSet, o = n ? t(n) : e;
  return vm = o, vm;
}
var mm, zM;
function i6() {
  if (zM)
    return mm;
  zM = 1;
  var e = Qg(), t = aA(), r = eb(), n = fme(), o = hme(), s = zq(), a = Gq(), l = pme(), u = gme(), f = Qq(), c = bme(), d = Nu(), h = _me(), p = xme(), v = n6(), y = Yt(), w = $u(), S = Ame(), x = In(), E = $me(), N = Rs(), C = sl(), j = 1, J = 2, z = 4, $ = "[object Arguments]", G = "[object Array]", I = "[object Boolean]", W = "[object Date]", k = "[object Error]", U = "[object Function]", Z = "[object GeneratorFunction]", Y = "[object Map]", re = "[object Number]", ae = "[object Object]", ce = "[object RegExp]", pe = "[object Set]", le = "[object String]", ye = "[object Symbol]", H = "[object WeakMap]", ge = "[object ArrayBuffer]", Ce = "[object DataView]", ue = "[object Float32Array]", ee = "[object Float64Array]", be = "[object Int8Array]", Te = "[object Int16Array]", Pe = "[object Int32Array]", K = "[object Uint8Array]", V = "[object Uint8ClampedArray]", b = "[object Uint16Array]", _ = "[object Uint32Array]", T = {};
  T[$] = T[G] = T[ge] = T[Ce] = T[I] = T[W] = T[ue] = T[ee] = T[be] = T[Te] = T[Pe] = T[Y] = T[re] = T[ae] = T[ce] = T[pe] = T[le] = T[ye] = T[K] = T[V] = T[b] = T[_] = !0, T[k] = T[U] = T[H] = !1;
  function L(O, ie, fe, se, ve, B) {
    var me, ke = ie & j, Ie = ie & J, Me = ie & z;
    if (fe && (me = ve ? fe(O, se, ve, B) : fe(O)), me !== void 0)
      return me;
    if (!x(O))
      return O;
    var M = y(O);
    if (M) {
      if (me = h(O), !ke)
        return a(O, me);
    } else {
      var R = d(O), A = R == U || R == Z;
      if (w(O))
        return s(O, ke);
      if (R == ae || R == $ || A && !ve) {
        if (me = Ie || A ? {} : v(O), !ke)
          return Ie ? u(O, o(me, O)) : l(O, n(me, O));
      } else {
        if (!T[R])
          return ve ? O : {};
        me = p(O, R, ke);
      }
    }
    B || (B = new e());
    var q = B.get(O);
    if (q)
      return q;
    B.set(O, me), E(O) ? O.forEach(function(he) {
      me.add(L(he, ie, fe, he, O, B));
    }) : S(O) && O.forEach(function(he, Fe) {
      me.set(Fe, L(he, ie, fe, Fe, O, B));
    });
    var ne = Me ? Ie ? c : f : Ie ? C : N, de = M ? void 0 : ne(O);
    return t(de || O, function(he, Fe) {
      de && (Fe = he, he = O[Fe]), r(me, Fe, L(he, ie, fe, Fe, O, B));
    }), me;
  }
  return mm = L, mm;
}
var _m, GM;
function Nme() {
  if (GM)
    return _m;
  GM = 1;
  var e = i6(), t = 4;
  function r(n) {
    return e(n, t);
  }
  return _m = r, _m;
}
var wm, KM;
function pA() {
  if (KM)
    return wm;
  KM = 1;
  function e(t) {
    return function() {
      return t;
    };
  }
  return wm = e, wm;
}
var Sm, YM;
function kme() {
  if (YM)
    return Sm;
  YM = 1;
  function e(t) {
    return function(r, n, o) {
      for (var s = -1, a = Object(r), l = o(r), u = l.length; u--; ) {
        var f = l[t ? u : ++s];
        if (n(a[f], f, a) === !1)
          break;
      }
      return r;
    };
  }
  return Sm = e, Sm;
}
var Em, XM;
function gA() {
  if (XM)
    return Em;
  XM = 1;
  var e = kme(), t = e();
  return Em = t, Em;
}
var xm, JM;
function bA() {
  if (JM)
    return xm;
  JM = 1;
  var e = gA(), t = Rs();
  function r(n, o) {
    return n && e(n, o, t);
  }
  return xm = r, xm;
}
var Rm, QM;
function Cme() {
  if (QM)
    return Rm;
  QM = 1;
  var e = No();
  function t(r, n) {
    return function(o, s) {
      if (o == null)
        return o;
      if (!e(o))
        return r(o, s);
      for (var a = o.length, l = n ? a : -1, u = Object(o); (n ? l-- : ++l < a) && s(u[l], l, u) !== !1; )
        ;
      return o;
    };
  }
  return Rm = t, Rm;
}
var Am, ZM;
function ob() {
  if (ZM)
    return Am;
  ZM = 1;
  var e = bA(), t = Cme(), r = t(e);
  return Am = r, Am;
}
var Tm, eO;
function al() {
  if (eO)
    return Tm;
  eO = 1;
  function e(t) {
    return t;
  }
  return Tm = e, Tm;
}
var $m, tO;
function o6() {
  if (tO)
    return $m;
  tO = 1;
  var e = al();
  function t(r) {
    return typeof r == "function" ? r : e;
  }
  return $m = t, $m;
}
var Nm, rO;
function s6() {
  if (rO)
    return Nm;
  rO = 1;
  var e = aA(), t = ob(), r = o6(), n = Yt();
  function o(s, a) {
    var l = n(s) ? e : t;
    return l(s, r(a));
  }
  return Nm = o, Nm;
}
var km, nO;
function a6() {
  return nO || (nO = 1, km = s6()), km;
}
var Cm, iO;
function Ime() {
  if (iO)
    return Cm;
  iO = 1;
  var e = ob();
  function t(r, n) {
    var o = [];
    return e(r, function(s, a, l) {
      n(s, a, l) && o.push(s);
    }), o;
  }
  return Cm = t, Cm;
}
var Im, oO;
function Mme() {
  if (oO)
    return Im;
  oO = 1;
  var e = "__lodash_hash_undefined__";
  function t(r) {
    return this.__data__.set(r, e), this;
  }
  return Im = t, Im;
}
var Mm, sO;
function Ome() {
  if (sO)
    return Mm;
  sO = 1;
  function e(t) {
    return this.__data__.has(t);
  }
  return Mm = e, Mm;
}
var Om, aO;
function l6() {
  if (aO)
    return Om;
  aO = 1;
  var e = sA(), t = Mme(), r = Ome();
  function n(o) {
    var s = -1, a = o == null ? 0 : o.length;
    for (this.__data__ = new e(); ++s < a; )
      this.add(o[s]);
  }
  return n.prototype.add = n.prototype.push = t, n.prototype.has = r, Om = n, Om;
}
var Lm, lO;
function Lme() {
  if (lO)
    return Lm;
  lO = 1;
  function e(t, r) {
    for (var n = -1, o = t == null ? 0 : t.length; ++n < o; )
      if (r(t[n], n, t))
        return !0;
    return !1;
  }
  return Lm = e, Lm;
}
var Pm, uO;
function u6() {
  if (uO)
    return Pm;
  uO = 1;
  function e(t, r) {
    return t.has(r);
  }
  return Pm = e, Pm;
}
var Dm, fO;
function f6() {
  if (fO)
    return Dm;
  fO = 1;
  var e = l6(), t = Lme(), r = u6(), n = 1, o = 2;
  function s(a, l, u, f, c, d) {
    var h = u & n, p = a.length, v = l.length;
    if (p != v && !(h && v > p))
      return !1;
    var y = d.get(a), w = d.get(l);
    if (y && w)
      return y == l && w == a;
    var S = -1, x = !0, E = u & o ? new e() : void 0;
    for (d.set(a, l), d.set(l, a); ++S < p; ) {
      var N = a[S], C = l[S];
      if (f)
        var j = h ? f(C, N, S, l, a, d) : f(N, C, S, a, l, d);
      if (j !== void 0) {
        if (j)
          continue;
        x = !1;
        break;
      }
      if (E) {
        if (!t(l, function(J, z) {
          if (!r(E, z) && (N === J || c(N, J, u, f, d)))
            return E.push(z);
        })) {
          x = !1;
          break;
        }
      } else if (!(N === C || c(N, C, u, f, d))) {
        x = !1;
        break;
      }
    }
    return d.delete(a), d.delete(l), x;
  }
  return Dm = s, Dm;
}
var Fm, cO;
function Pme() {
  if (cO)
    return Fm;
  cO = 1;
  function e(t) {
    var r = -1, n = Array(t.size);
    return t.forEach(function(o, s) {
      n[++r] = [s, o];
    }), n;
  }
  return Fm = e, Fm;
}
var jm, dO;
function yA() {
  if (dO)
    return jm;
  dO = 1;
  function e(t) {
    var r = -1, n = Array(t.size);
    return t.forEach(function(o) {
      n[++r] = o;
    }), n;
  }
  return jm = e, jm;
}
var Bm, hO;
function Dme() {
  if (hO)
    return Bm;
  hO = 1;
  var e = bu(), t = e6(), r = Tu(), n = f6(), o = Pme(), s = yA(), a = 1, l = 2, u = "[object Boolean]", f = "[object Date]", c = "[object Error]", d = "[object Map]", h = "[object Number]", p = "[object RegExp]", v = "[object Set]", y = "[object String]", w = "[object Symbol]", S = "[object ArrayBuffer]", x = "[object DataView]", E = e ? e.prototype : void 0, N = E ? E.valueOf : void 0;
  function C(j, J, z, $, G, I, W) {
    switch (z) {
      case x:
        if (j.byteLength != J.byteLength || j.byteOffset != J.byteOffset)
          return !1;
        j = j.buffer, J = J.buffer;
      case S:
        return !(j.byteLength != J.byteLength || !I(new t(j), new t(J)));
      case u:
      case f:
      case h:
        return r(+j, +J);
      case c:
        return j.name == J.name && j.message == J.message;
      case p:
      case y:
        return j == J + "";
      case d:
        var k = o;
      case v:
        var U = $ & a;
        if (k || (k = s), j.size != J.size && !U)
          return !1;
        var Z = W.get(j);
        if (Z)
          return Z == J;
        $ |= l, W.set(j, J);
        var Y = n(k(j), k(J), $, G, I, W);
        return W.delete(j), Y;
      case w:
        if (N)
          return N.call(j) == N.call(J);
    }
    return !1;
  }
  return Bm = C, Bm;
}
var qm, pO;
function Fme() {
  if (pO)
    return qm;
  pO = 1;
  var e = Qq(), t = 1, r = Object.prototype, n = r.hasOwnProperty;
  function o(s, a, l, u, f, c) {
    var d = l & t, h = e(s), p = h.length, v = e(a), y = v.length;
    if (p != y && !d)
      return !1;
    for (var w = p; w--; ) {
      var S = h[w];
      if (!(d ? S in a : n.call(a, S)))
        return !1;
    }
    var x = c.get(s), E = c.get(a);
    if (x && E)
      return x == a && E == s;
    var N = !0;
    c.set(s, a), c.set(a, s);
    for (var C = d; ++w < p; ) {
      S = h[w];
      var j = s[S], J = a[S];
      if (u)
        var z = d ? u(J, j, S, a, s, c) : u(j, J, S, s, a, c);
      if (!(z === void 0 ? j === J || f(j, J, l, u, c) : z)) {
        N = !1;
        break;
      }
      C || (C = S == "constructor");
    }
    if (N && !C) {
      var $ = s.constructor, G = a.constructor;
      $ != G && "constructor" in s && "constructor" in a && !(typeof $ == "function" && $ instanceof $ && typeof G == "function" && G instanceof G) && (N = !1);
    }
    return c.delete(s), c.delete(a), N;
  }
  return qm = o, qm;
}
var Wm, gO;
function jme() {
  if (gO)
    return Wm;
  gO = 1;
  var e = Qg(), t = f6(), r = Dme(), n = Fme(), o = Nu(), s = Yt(), a = $u(), l = Bc(), u = 1, f = "[object Arguments]", c = "[object Array]", d = "[object Object]", h = Object.prototype, p = h.hasOwnProperty;
  function v(y, w, S, x, E, N) {
    var C = s(y), j = s(w), J = C ? c : o(y), z = j ? c : o(w);
    J = J == f ? d : J, z = z == f ? d : z;
    var $ = J == d, G = z == d, I = J == z;
    if (I && a(y)) {
      if (!a(w))
        return !1;
      C = !0, $ = !1;
    }
    if (I && !$)
      return N || (N = new e()), C || l(y) ? t(y, w, S, x, E, N) : r(y, w, J, S, x, E, N);
    if (!(S & u)) {
      var W = $ && p.call(y, "__wrapped__"), k = G && p.call(w, "__wrapped__");
      if (W || k) {
        var U = W ? y.value() : y, Z = k ? w.value() : w;
        return N || (N = new e()), E(U, Z, S, x, N);
      }
    }
    return I ? (N || (N = new e()), n(y, w, S, x, E, N)) : !1;
  }
  return Wm = v, Wm;
}
var Um, bO;
function c6() {
  if (bO)
    return Um;
  bO = 1;
  var e = jme(), t = ji();
  function r(n, o, s, a, l) {
    return n === o ? !0 : n == null || o == null || !t(n) && !t(o) ? n !== n && o !== o : e(n, o, s, a, r, l);
  }
  return Um = r, Um;
}
var Hm, yO;
function Bme() {
  if (yO)
    return Hm;
  yO = 1;
  var e = Qg(), t = c6(), r = 1, n = 2;
  function o(s, a, l, u) {
    var f = l.length, c = f, d = !u;
    if (s == null)
      return !c;
    for (s = Object(s); f--; ) {
      var h = l[f];
      if (d && h[2] ? h[1] !== s[h[0]] : !(h[0] in s))
        return !1;
    }
    for (; ++f < c; ) {
      h = l[f];
      var p = h[0], v = s[p], y = h[1];
      if (d && h[2]) {
        if (v === void 0 && !(p in s))
          return !1;
      } else {
        var w = new e();
        if (u)
          var S = u(v, y, p, s, a, w);
        if (!(S === void 0 ? t(y, v, r | n, u, w) : S))
          return !1;
      }
    }
    return !0;
  }
  return Hm = o, Hm;
}
var Vm, vO;
function d6() {
  if (vO)
    return Vm;
  vO = 1;
  var e = In();
  function t(r) {
    return r === r && !e(r);
  }
  return Vm = t, Vm;
}
var zm, mO;
function qme() {
  if (mO)
    return zm;
  mO = 1;
  var e = d6(), t = Rs();
  function r(n) {
    for (var o = t(n), s = o.length; s--; ) {
      var a = o[s], l = n[a];
      o[s] = [a, l, e(l)];
    }
    return o;
  }
  return zm = r, zm;
}
var Gm, _O;
function h6() {
  if (_O)
    return Gm;
  _O = 1;
  function e(t, r) {
    return function(n) {
      return n == null ? !1 : n[t] === r && (r !== void 0 || t in Object(n));
    };
  }
  return Gm = e, Gm;
}
var Km, wO;
function Wme() {
  if (wO)
    return Km;
  wO = 1;
  var e = Bme(), t = qme(), r = h6();
  function n(o) {
    var s = t(o);
    return s.length == 1 && s[0][2] ? r(s[0][0], s[0][1]) : function(a) {
      return a === o || e(a, o, s);
    };
  }
  return Km = n, Km;
}
var Ym, SO;
function vA() {
  if (SO)
    return Ym;
  SO = 1;
  var e = Yt(), t = yu(), r = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, n = /^\w*$/;
  function o(s, a) {
    if (e(s))
      return !1;
    var l = typeof s;
    return l == "number" || l == "symbol" || l == "boolean" || s == null || t(s) ? !0 : n.test(s) || !r.test(s) || a != null && s in Object(a);
  }
  return Ym = o, Ym;
}
var Xm, EO;
function Ume() {
  if (EO)
    return Xm;
  EO = 1;
  var e = sA(), t = "Expected a function";
  function r(n, o) {
    if (typeof n != "function" || o != null && typeof o != "function")
      throw new TypeError(t);
    var s = function() {
      var a = arguments, l = o ? o.apply(this, a) : a[0], u = s.cache;
      if (u.has(l))
        return u.get(l);
      var f = n.apply(this, a);
      return s.cache = u.set(l, f) || u, f;
    };
    return s.cache = new (r.Cache || e)(), s;
  }
  return r.Cache = e, Xm = r, Xm;
}
var Jm, xO;
function Hme() {
  if (xO)
    return Jm;
  xO = 1;
  var e = Ume(), t = 500;
  function r(n) {
    var o = e(n, function(a) {
      return s.size === t && s.clear(), a;
    }), s = o.cache;
    return o;
  }
  return Jm = r, Jm;
}
var Qm, RO;
function Vme() {
  if (RO)
    return Qm;
  RO = 1;
  var e = Hme(), t = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, r = /\\(\\)?/g, n = e(function(o) {
    var s = [];
    return o.charCodeAt(0) === 46 && s.push(""), o.replace(t, function(a, l, u, f) {
      s.push(u ? f.replace(r, "$1") : l || a);
    }), s;
  });
  return Qm = n, Qm;
}
var Zm, AO;
function sb() {
  if (AO)
    return Zm;
  AO = 1;
  function e(t, r) {
    for (var n = -1, o = t == null ? 0 : t.length, s = Array(o); ++n < o; )
      s[n] = r(t[n], n, t);
    return s;
  }
  return Zm = e, Zm;
}
var e_, TO;
function zme() {
  if (TO)
    return e_;
  TO = 1;
  var e = bu(), t = sb(), r = Yt(), n = yu(), o = 1 / 0, s = e ? e.prototype : void 0, a = s ? s.toString : void 0;
  function l(u) {
    if (typeof u == "string")
      return u;
    if (r(u))
      return t(u, l) + "";
    if (n(u))
      return a ? a.call(u) : "";
    var f = u + "";
    return f == "0" && 1 / u == -o ? "-0" : f;
  }
  return e_ = l, e_;
}
var t_, $O;
function p6() {
  if ($O)
    return t_;
  $O = 1;
  var e = zme();
  function t(r) {
    return r == null ? "" : e(r);
  }
  return t_ = t, t_;
}
var r_, NO;
function ab() {
  if (NO)
    return r_;
  NO = 1;
  var e = Yt(), t = vA(), r = Vme(), n = p6();
  function o(s, a) {
    return e(s) ? s : t(s, a) ? [s] : r(n(s));
  }
  return r_ = o, r_;
}
var n_, kO;
function qc() {
  if (kO)
    return n_;
  kO = 1;
  var e = yu(), t = 1 / 0;
  function r(n) {
    if (typeof n == "string" || e(n))
      return n;
    var o = n + "";
    return o == "0" && 1 / n == -t ? "-0" : o;
  }
  return n_ = r, n_;
}
var i_, CO;
function lb() {
  if (CO)
    return i_;
  CO = 1;
  var e = ab(), t = qc();
  function r(n, o) {
    o = e(o, n);
    for (var s = 0, a = o.length; n != null && s < a; )
      n = n[t(o[s++])];
    return s && s == a ? n : void 0;
  }
  return i_ = r, i_;
}
var o_, IO;
function Gme() {
  if (IO)
    return o_;
  IO = 1;
  var e = lb();
  function t(r, n, o) {
    var s = r == null ? void 0 : e(r, n);
    return s === void 0 ? o : s;
  }
  return o_ = t, o_;
}
var s_, MO;
function Kme() {
  if (MO)
    return s_;
  MO = 1;
  function e(t, r) {
    return t != null && r in Object(t);
  }
  return s_ = e, s_;
}
var a_, OO;
function g6() {
  if (OO)
    return a_;
  OO = 1;
  var e = ab(), t = jc(), r = Yt(), n = tb(), o = lA(), s = qc();
  function a(l, u, f) {
    u = e(u, l);
    for (var c = -1, d = u.length, h = !1; ++c < d; ) {
      var p = s(u[c]);
      if (!(h = l != null && f(l, p)))
        break;
      l = l[p];
    }
    return h || ++c != d ? h : (d = l == null ? 0 : l.length, !!d && o(d) && n(p, d) && (r(l) || t(l)));
  }
  return a_ = a, a_;
}
var l_, LO;
function b6() {
  if (LO)
    return l_;
  LO = 1;
  var e = Kme(), t = g6();
  function r(n, o) {
    return n != null && t(n, o, e);
  }
  return l_ = r, l_;
}
var u_, PO;
function Yme() {
  if (PO)
    return u_;
  PO = 1;
  var e = c6(), t = Gme(), r = b6(), n = vA(), o = d6(), s = h6(), a = qc(), l = 1, u = 2;
  function f(c, d) {
    return n(c) && o(d) ? s(a(c), d) : function(h) {
      var p = t(h, c);
      return p === void 0 && p === d ? r(h, c) : e(d, p, l | u);
    };
  }
  return u_ = f, u_;
}
var f_, DO;
function y6() {
  if (DO)
    return f_;
  DO = 1;
  function e(t) {
    return function(r) {
      return r == null ? void 0 : r[t];
    };
  }
  return f_ = e, f_;
}
var c_, FO;
function Xme() {
  if (FO)
    return c_;
  FO = 1;
  var e = lb();
  function t(r) {
    return function(n) {
      return e(n, r);
    };
  }
  return c_ = t, c_;
}
var d_, jO;
function Jme() {
  if (jO)
    return d_;
  jO = 1;
  var e = y6(), t = Xme(), r = vA(), n = qc();
  function o(s) {
    return r(s) ? e(n(s)) : t(s);
  }
  return d_ = o, d_;
}
var h_, BO;
function ko() {
  if (BO)
    return h_;
  BO = 1;
  var e = Wme(), t = Yme(), r = al(), n = Yt(), o = Jme();
  function s(a) {
    return typeof a == "function" ? a : a == null ? r : typeof a == "object" ? n(a) ? t(a[0], a[1]) : e(a) : o(a);
  }
  return h_ = s, h_;
}
var p_, qO;
function v6() {
  if (qO)
    return p_;
  qO = 1;
  var e = Kq(), t = Ime(), r = ko(), n = Yt();
  function o(s, a) {
    var l = n(s) ? e : t;
    return l(s, r(a, 3));
  }
  return p_ = o, p_;
}
var g_, WO;
function Qme() {
  if (WO)
    return g_;
  WO = 1;
  var e = Object.prototype, t = e.hasOwnProperty;
  function r(n, o) {
    return n != null && t.call(n, o);
  }
  return g_ = r, g_;
}
var b_, UO;
function m6() {
  if (UO)
    return b_;
  UO = 1;
  var e = Qme(), t = g6();
  function r(n, o) {
    return n != null && t(n, o, e);
  }
  return b_ = r, b_;
}
var y_, HO;
function Zme() {
  if (HO)
    return y_;
  HO = 1;
  var e = fA(), t = Nu(), r = jc(), n = Yt(), o = No(), s = $u(), a = nb(), l = Bc(), u = "[object Map]", f = "[object Set]", c = Object.prototype, d = c.hasOwnProperty;
  function h(p) {
    if (p == null)
      return !0;
    if (o(p) && (n(p) || typeof p == "string" || typeof p.splice == "function" || s(p) || l(p) || r(p)))
      return !p.length;
    var v = t(p);
    if (v == u || v == f)
      return !p.size;
    if (a(p))
      return !e(p).length;
    for (var y in p)
      if (d.call(p, y))
        return !1;
    return !0;
  }
  return y_ = h, y_;
}
var v_, VO;
function _6() {
  if (VO)
    return v_;
  VO = 1;
  function e(t) {
    return t === void 0;
  }
  return v_ = e, v_;
}
var m_, zO;
function w6() {
  if (zO)
    return m_;
  zO = 1;
  var e = ob(), t = No();
  function r(n, o) {
    var s = -1, a = t(n) ? Array(n.length) : [];
    return e(n, function(l, u, f) {
      a[++s] = o(l, u, f);
    }), a;
  }
  return m_ = r, m_;
}
var __, GO;
function S6() {
  if (GO)
    return __;
  GO = 1;
  var e = sb(), t = ko(), r = w6(), n = Yt();
  function o(s, a) {
    var l = n(s) ? e : r;
    return l(s, t(a, 3));
  }
  return __ = o, __;
}
var w_, KO;
function e_e() {
  if (KO)
    return w_;
  KO = 1;
  function e(t, r, n, o) {
    var s = -1, a = t == null ? 0 : t.length;
    for (o && a && (n = t[++s]); ++s < a; )
      n = r(n, t[s], s, t);
    return n;
  }
  return w_ = e, w_;
}
var S_, YO;
function t_e() {
  if (YO)
    return S_;
  YO = 1;
  function e(t, r, n, o, s) {
    return s(t, function(a, l, u) {
      n = o ? (o = !1, a) : r(n, a, l, u);
    }), n;
  }
  return S_ = e, S_;
}
var E_, XO;
function E6() {
  if (XO)
    return E_;
  XO = 1;
  var e = e_e(), t = ob(), r = ko(), n = t_e(), o = Yt();
  function s(a, l, u) {
    var f = o(a) ? e : n, c = arguments.length < 3;
    return f(a, r(l, 4), u, c, t);
  }
  return E_ = s, E_;
}
var x_, JO;
function r_e() {
  if (JO)
    return x_;
  JO = 1;
  var e = Ka(), t = Yt(), r = ji(), n = "[object String]";
  function o(s) {
    return typeof s == "string" || !t(s) && r(s) && e(s) == n;
  }
  return x_ = o, x_;
}
var R_, QO;
function n_e() {
  if (QO)
    return R_;
  QO = 1;
  var e = y6(), t = e("length");
  return R_ = t, R_;
}
var A_, ZO;
function i_e() {
  if (ZO)
    return A_;
  ZO = 1;
  var e = "\\ud800-\\udfff", t = "\\u0300-\\u036f", r = "\\ufe20-\\ufe2f", n = "\\u20d0-\\u20ff", o = t + r + n, s = "\\ufe0e\\ufe0f", a = "\\u200d", l = RegExp("[" + a + e + o + s + "]");
  function u(f) {
    return l.test(f);
  }
  return A_ = u, A_;
}
var T_, eL;
function o_e() {
  if (eL)
    return T_;
  eL = 1;
  var e = "\\ud800-\\udfff", t = "\\u0300-\\u036f", r = "\\ufe20-\\ufe2f", n = "\\u20d0-\\u20ff", o = t + r + n, s = "\\ufe0e\\ufe0f", a = "[" + e + "]", l = "[" + o + "]", u = "\\ud83c[\\udffb-\\udfff]", f = "(?:" + l + "|" + u + ")", c = "[^" + e + "]", d = "(?:\\ud83c[\\udde6-\\uddff]){2}", h = "[\\ud800-\\udbff][\\udc00-\\udfff]", p = "\\u200d", v = f + "?", y = "[" + s + "]?", w = "(?:" + p + "(?:" + [c, d, h].join("|") + ")" + y + v + ")*", S = y + v + w, x = "(?:" + [c + l + "?", l, d, h, a].join("|") + ")", E = RegExp(u + "(?=" + u + ")|" + x + S, "g");
  function N(C) {
    for (var j = E.lastIndex = 0; E.test(C); )
      ++j;
    return j;
  }
  return T_ = N, T_;
}
var $_, tL;
function s_e() {
  if (tL)
    return $_;
  tL = 1;
  var e = n_e(), t = i_e(), r = o_e();
  function n(o) {
    return t(o) ? r(o) : e(o);
  }
  return $_ = n, $_;
}
var N_, rL;
function a_e() {
  if (rL)
    return N_;
  rL = 1;
  var e = fA(), t = Nu(), r = No(), n = r_e(), o = s_e(), s = "[object Map]", a = "[object Set]";
  function l(u) {
    if (u == null)
      return 0;
    if (r(u))
      return n(u) ? o(u) : u.length;
    var f = t(u);
    return f == s || f == a ? u.size : e(u).length;
  }
  return N_ = l, N_;
}
var k_, nL;
function l_e() {
  if (nL)
    return k_;
  nL = 1;
  var e = aA(), t = r6(), r = bA(), n = ko(), o = ib(), s = Yt(), a = $u(), l = Dc(), u = In(), f = Bc();
  function c(d, h, p) {
    var v = s(d), y = v || a(d) || f(d);
    if (h = n(h, 4), p == null) {
      var w = d && d.constructor;
      y ? p = v ? new w() : [] : u(d) ? p = l(w) ? t(o(d)) : {} : p = {};
    }
    return (y ? e : r)(d, function(S, x, E) {
      return h(p, S, x, E);
    }), p;
  }
  return k_ = c, k_;
}
var C_, iL;
function u_e() {
  if (iL)
    return C_;
  iL = 1;
  var e = bu(), t = jc(), r = Yt(), n = e ? e.isConcatSpreadable : void 0;
  function o(s) {
    return r(s) || t(s) || !!(n && s && s[n]);
  }
  return C_ = o, C_;
}
var I_, oL;
function mA() {
  if (oL)
    return I_;
  oL = 1;
  var e = dA(), t = u_e();
  function r(n, o, s, a, l) {
    var u = -1, f = n.length;
    for (s || (s = t), l || (l = []); ++u < f; ) {
      var c = n[u];
      o > 0 && s(c) ? o > 1 ? r(c, o - 1, s, a, l) : e(l, c) : a || (l[l.length] = c);
    }
    return l;
  }
  return I_ = r, I_;
}
var M_, sL;
function f_e() {
  if (sL)
    return M_;
  sL = 1;
  function e(t, r, n) {
    switch (n.length) {
      case 0:
        return t.call(r);
      case 1:
        return t.call(r, n[0]);
      case 2:
        return t.call(r, n[0], n[1]);
      case 3:
        return t.call(r, n[0], n[1], n[2]);
    }
    return t.apply(r, n);
  }
  return M_ = e, M_;
}
var O_, aL;
function x6() {
  if (aL)
    return O_;
  aL = 1;
  var e = f_e(), t = Math.max;
  function r(n, o, s) {
    return o = t(o === void 0 ? n.length - 1 : o, 0), function() {
      for (var a = arguments, l = -1, u = t(a.length - o, 0), f = Array(u); ++l < u; )
        f[l] = a[o + l];
      l = -1;
      for (var c = Array(o + 1); ++l < o; )
        c[l] = a[l];
      return c[o] = s(f), e(n, this, c);
    };
  }
  return O_ = r, O_;
}
var L_, lL;
function c_e() {
  if (lL)
    return L_;
  lL = 1;
  var e = pA(), t = Uq(), r = al(), n = t ? function(o, s) {
    return t(o, "toString", {
      configurable: !0,
      enumerable: !1,
      value: e(s),
      writable: !0
    });
  } : r;
  return L_ = n, L_;
}
var P_, uL;
function d_e() {
  if (uL)
    return P_;
  uL = 1;
  var e = 800, t = 16, r = Date.now;
  function n(o) {
    var s = 0, a = 0;
    return function() {
      var l = r(), u = t - (l - a);
      if (a = l, u > 0) {
        if (++s >= e)
          return arguments[0];
      } else
        s = 0;
      return o.apply(void 0, arguments);
    };
  }
  return P_ = n, P_;
}
var D_, fL;
function R6() {
  if (fL)
    return D_;
  fL = 1;
  var e = c_e(), t = d_e(), r = t(e);
  return D_ = r, D_;
}
var F_, cL;
function ub() {
  if (cL)
    return F_;
  cL = 1;
  var e = al(), t = x6(), r = R6();
  function n(o, s) {
    return r(t(o, s, e), o + "");
  }
  return F_ = n, F_;
}
var j_, dL;
function A6() {
  if (dL)
    return j_;
  dL = 1;
  function e(t, r, n, o) {
    for (var s = t.length, a = n + (o ? 1 : -1); o ? a-- : ++a < s; )
      if (r(t[a], a, t))
        return a;
    return -1;
  }
  return j_ = e, j_;
}
var B_, hL;
function h_e() {
  if (hL)
    return B_;
  hL = 1;
  function e(t) {
    return t !== t;
  }
  return B_ = e, B_;
}
var q_, pL;
function p_e() {
  if (pL)
    return q_;
  pL = 1;
  function e(t, r, n) {
    for (var o = n - 1, s = t.length; ++o < s; )
      if (t[o] === r)
        return o;
    return -1;
  }
  return q_ = e, q_;
}
var W_, gL;
function g_e() {
  if (gL)
    return W_;
  gL = 1;
  var e = A6(), t = h_e(), r = p_e();
  function n(o, s, a) {
    return s === s ? r(o, s, a) : e(o, t, a);
  }
  return W_ = n, W_;
}
var U_, bL;
function b_e() {
  if (bL)
    return U_;
  bL = 1;
  var e = g_e();
  function t(r, n) {
    var o = r == null ? 0 : r.length;
    return !!o && e(r, n, 0) > -1;
  }
  return U_ = t, U_;
}
var H_, yL;
function y_e() {
  if (yL)
    return H_;
  yL = 1;
  function e(t, r, n) {
    for (var o = -1, s = t == null ? 0 : t.length; ++o < s; )
      if (n(r, t[o]))
        return !0;
    return !1;
  }
  return H_ = e, H_;
}
var V_, vL;
function v_e() {
  if (vL)
    return V_;
  vL = 1;
  function e() {
  }
  return V_ = e, V_;
}
var z_, mL;
function m_e() {
  if (mL)
    return z_;
  mL = 1;
  var e = Zq(), t = v_e(), r = yA(), n = 1 / 0, o = e && 1 / r(new e([, -0]))[1] == n ? function(s) {
    return new e(s);
  } : t;
  return z_ = o, z_;
}
var G_, _L;
function __e() {
  if (_L)
    return G_;
  _L = 1;
  var e = l6(), t = b_e(), r = y_e(), n = u6(), o = m_e(), s = yA(), a = 200;
  function l(u, f, c) {
    var d = -1, h = t, p = u.length, v = !0, y = [], w = y;
    if (c)
      v = !1, h = r;
    else if (p >= a) {
      var S = f ? null : o(u);
      if (S)
        return s(S);
      v = !1, h = n, w = new e();
    } else
      w = f ? [] : y;
    e:
      for (; ++d < p; ) {
        var x = u[d], E = f ? f(x) : x;
        if (x = c || x !== 0 ? x : 0, v && E === E) {
          for (var N = w.length; N--; )
            if (w[N] === E)
              continue e;
          f && w.push(E), y.push(x);
        } else
          h(w, E, c) || (w !== y && w.push(E), y.push(x));
      }
    return y;
  }
  return G_ = l, G_;
}
var K_, wL;
function T6() {
  if (wL)
    return K_;
  wL = 1;
  var e = No(), t = ji();
  function r(n) {
    return t(n) && e(n);
  }
  return K_ = r, K_;
}
var Y_, SL;
function w_e() {
  if (SL)
    return Y_;
  SL = 1;
  var e = mA(), t = ub(), r = __e(), n = T6(), o = t(function(s) {
    return r(e(s, 1, n, !0));
  });
  return Y_ = o, Y_;
}
var X_, EL;
function S_e() {
  if (EL)
    return X_;
  EL = 1;
  var e = sb();
  function t(r, n) {
    return e(n, function(o) {
      return r[o];
    });
  }
  return X_ = t, X_;
}
var J_, xL;
function $6() {
  if (xL)
    return J_;
  xL = 1;
  var e = S_e(), t = Rs();
  function r(n) {
    return n == null ? [] : e(n, t(n));
  }
  return J_ = r, J_;
}
var Q_, RL;
function Pn() {
  if (RL)
    return Q_;
  RL = 1;
  var e;
  if (typeof iA == "function")
    try {
      e = {
        clone: Nme(),
        constant: pA(),
        each: a6(),
        filter: v6(),
        has: m6(),
        isArray: Yt(),
        isEmpty: Zme(),
        isFunction: Dc(),
        isUndefined: _6(),
        keys: Rs(),
        map: S6(),
        reduce: E6(),
        size: a_e(),
        transform: l_e(),
        union: w_e(),
        values: $6()
      };
    } catch {
    }
  return e || (e = window._), Q_ = e, Q_;
}
var Z_, AL;
function _A() {
  if (AL)
    return Z_;
  AL = 1;
  var e = Pn();
  Z_ = o;
  var t = "\0", r = "\0", n = "";
  function o(c) {
    this._isDirected = e.has(c, "directed") ? c.directed : !0, this._isMultigraph = e.has(c, "multigraph") ? c.multigraph : !1, this._isCompound = e.has(c, "compound") ? c.compound : !1, this._label = void 0, this._defaultNodeLabelFn = e.constant(void 0), this._defaultEdgeLabelFn = e.constant(void 0), this._nodes = {}, this._isCompound && (this._parent = {}, this._children = {}, this._children[r] = {}), this._in = {}, this._preds = {}, this._out = {}, this._sucs = {}, this._edgeObjs = {}, this._edgeLabels = {};
  }
  o.prototype._nodeCount = 0, o.prototype._edgeCount = 0, o.prototype.isDirected = function() {
    return this._isDirected;
  }, o.prototype.isMultigraph = function() {
    return this._isMultigraph;
  }, o.prototype.isCompound = function() {
    return this._isCompound;
  }, o.prototype.setGraph = function(c) {
    return this._label = c, this;
  }, o.prototype.graph = function() {
    return this._label;
  }, o.prototype.setDefaultNodeLabel = function(c) {
    return e.isFunction(c) || (c = e.constant(c)), this._defaultNodeLabelFn = c, this;
  }, o.prototype.nodeCount = function() {
    return this._nodeCount;
  }, o.prototype.nodes = function() {
    return e.keys(this._nodes);
  }, o.prototype.sources = function() {
    var c = this;
    return e.filter(this.nodes(), function(d) {
      return e.isEmpty(c._in[d]);
    });
  }, o.prototype.sinks = function() {
    var c = this;
    return e.filter(this.nodes(), function(d) {
      return e.isEmpty(c._out[d]);
    });
  }, o.prototype.setNodes = function(c, d) {
    var h = arguments, p = this;
    return e.each(c, function(v) {
      h.length > 1 ? p.setNode(v, d) : p.setNode(v);
    }), this;
  }, o.prototype.setNode = function(c, d) {
    return e.has(this._nodes, c) ? (arguments.length > 1 && (this._nodes[c] = d), this) : (this._nodes[c] = arguments.length > 1 ? d : this._defaultNodeLabelFn(c), this._isCompound && (this._parent[c] = r, this._children[c] = {}, this._children[r][c] = !0), this._in[c] = {}, this._preds[c] = {}, this._out[c] = {}, this._sucs[c] = {}, ++this._nodeCount, this);
  }, o.prototype.node = function(c) {
    return this._nodes[c];
  }, o.prototype.hasNode = function(c) {
    return e.has(this._nodes, c);
  }, o.prototype.removeNode = function(c) {
    var d = this;
    if (e.has(this._nodes, c)) {
      var h = function(p) {
        d.removeEdge(d._edgeObjs[p]);
      };
      delete this._nodes[c], this._isCompound && (this._removeFromParentsChildList(c), delete this._parent[c], e.each(this.children(c), function(p) {
        d.setParent(p);
      }), delete this._children[c]), e.each(e.keys(this._in[c]), h), delete this._in[c], delete this._preds[c], e.each(e.keys(this._out[c]), h), delete this._out[c], delete this._sucs[c], --this._nodeCount;
    }
    return this;
  }, o.prototype.setParent = function(c, d) {
    if (!this._isCompound)
      throw new Error("Cannot set parent in a non-compound graph");
    if (e.isUndefined(d))
      d = r;
    else {
      d += "";
      for (var h = d; !e.isUndefined(h); h = this.parent(h))
        if (h === c)
          throw new Error("Setting " + d + " as parent of " + c + " would create a cycle");
      this.setNode(d);
    }
    return this.setNode(c), this._removeFromParentsChildList(c), this._parent[c] = d, this._children[d][c] = !0, this;
  }, o.prototype._removeFromParentsChildList = function(c) {
    delete this._children[this._parent[c]][c];
  }, o.prototype.parent = function(c) {
    if (this._isCompound) {
      var d = this._parent[c];
      if (d !== r)
        return d;
    }
  }, o.prototype.children = function(c) {
    if (e.isUndefined(c) && (c = r), this._isCompound) {
      var d = this._children[c];
      if (d)
        return e.keys(d);
    } else {
      if (c === r)
        return this.nodes();
      if (this.hasNode(c))
        return [];
    }
  }, o.prototype.predecessors = function(c) {
    var d = this._preds[c];
    if (d)
      return e.keys(d);
  }, o.prototype.successors = function(c) {
    var d = this._sucs[c];
    if (d)
      return e.keys(d);
  }, o.prototype.neighbors = function(c) {
    var d = this.predecessors(c);
    if (d)
      return e.union(d, this.successors(c));
  }, o.prototype.isLeaf = function(c) {
    var d;
    return this.isDirected() ? d = this.successors(c) : d = this.neighbors(c), d.length === 0;
  }, o.prototype.filterNodes = function(c) {
    var d = new this.constructor({
      directed: this._isDirected,
      multigraph: this._isMultigraph,
      compound: this._isCompound
    });
    d.setGraph(this.graph());
    var h = this;
    e.each(this._nodes, function(y, w) {
      c(w) && d.setNode(w, y);
    }), e.each(this._edgeObjs, function(y) {
      d.hasNode(y.v) && d.hasNode(y.w) && d.setEdge(y, h.edge(y));
    });
    var p = {};
    function v(y) {
      var w = h.parent(y);
      return w === void 0 || d.hasNode(w) ? (p[y] = w, w) : w in p ? p[w] : v(w);
    }
    return this._isCompound && e.each(d.nodes(), function(y) {
      d.setParent(y, v(y));
    }), d;
  }, o.prototype.setDefaultEdgeLabel = function(c) {
    return e.isFunction(c) || (c = e.constant(c)), this._defaultEdgeLabelFn = c, this;
  }, o.prototype.edgeCount = function() {
    return this._edgeCount;
  }, o.prototype.edges = function() {
    return e.values(this._edgeObjs);
  }, o.prototype.setPath = function(c, d) {
    var h = this, p = arguments;
    return e.reduce(c, function(v, y) {
      return p.length > 1 ? h.setEdge(v, y, d) : h.setEdge(v, y), y;
    }), this;
  }, o.prototype.setEdge = function() {
    var c, d, h, p, v = !1, y = arguments[0];
    typeof y == "object" && y !== null && "v" in y ? (c = y.v, d = y.w, h = y.name, arguments.length === 2 && (p = arguments[1], v = !0)) : (c = y, d = arguments[1], h = arguments[3], arguments.length > 2 && (p = arguments[2], v = !0)), c = "" + c, d = "" + d, e.isUndefined(h) || (h = "" + h);
    var w = l(this._isDirected, c, d, h);
    if (e.has(this._edgeLabels, w))
      return v && (this._edgeLabels[w] = p), this;
    if (!e.isUndefined(h) && !this._isMultigraph)
      throw new Error("Cannot set a named edge when isMultigraph = false");
    this.setNode(c), this.setNode(d), this._edgeLabels[w] = v ? p : this._defaultEdgeLabelFn(c, d, h);
    var S = u(this._isDirected, c, d, h);
    return c = S.v, d = S.w, Object.freeze(S), this._edgeObjs[w] = S, s(this._preds[d], c), s(this._sucs[c], d), this._in[d][w] = S, this._out[c][w] = S, this._edgeCount++, this;
  }, o.prototype.edge = function(c, d, h) {
    var p = arguments.length === 1 ? f(this._isDirected, arguments[0]) : l(this._isDirected, c, d, h);
    return this._edgeLabels[p];
  }, o.prototype.hasEdge = function(c, d, h) {
    var p = arguments.length === 1 ? f(this._isDirected, arguments[0]) : l(this._isDirected, c, d, h);
    return e.has(this._edgeLabels, p);
  }, o.prototype.removeEdge = function(c, d, h) {
    var p = arguments.length === 1 ? f(this._isDirected, arguments[0]) : l(this._isDirected, c, d, h), v = this._edgeObjs[p];
    return v && (c = v.v, d = v.w, delete this._edgeLabels[p], delete this._edgeObjs[p], a(this._preds[d], c), a(this._sucs[c], d), delete this._in[d][p], delete this._out[c][p], this._edgeCount--), this;
  }, o.prototype.inEdges = function(c, d) {
    var h = this._in[c];
    if (h) {
      var p = e.values(h);
      return d ? e.filter(p, function(v) {
        return v.v === d;
      }) : p;
    }
  }, o.prototype.outEdges = function(c, d) {
    var h = this._out[c];
    if (h) {
      var p = e.values(h);
      return d ? e.filter(p, function(v) {
        return v.w === d;
      }) : p;
    }
  }, o.prototype.nodeEdges = function(c, d) {
    var h = this.inEdges(c, d);
    if (h)
      return h.concat(this.outEdges(c, d));
  };
  function s(c, d) {
    c[d] ? c[d]++ : c[d] = 1;
  }
  function a(c, d) {
    --c[d] || delete c[d];
  }
  function l(c, d, h, p) {
    var v = "" + d, y = "" + h;
    if (!c && v > y) {
      var w = v;
      v = y, y = w;
    }
    return v + n + y + n + (e.isUndefined(p) ? t : p);
  }
  function u(c, d, h, p) {
    var v = "" + d, y = "" + h;
    if (!c && v > y) {
      var w = v;
      v = y, y = w;
    }
    var S = { v, w: y };
    return p && (S.name = p), S;
  }
  function f(c, d) {
    return l(c, d.v, d.w, d.name);
  }
  return Z_;
}
var ew, TL;
function E_e() {
  return TL || (TL = 1, ew = "2.1.8"), ew;
}
var tw, $L;
function x_e() {
  return $L || ($L = 1, tw = {
    Graph: _A(),
    version: E_e()
  }), tw;
}
var rw, NL;
function R_e() {
  if (NL)
    return rw;
  NL = 1;
  var e = Pn(), t = _A();
  rw = {
    write: r,
    read: s
  };
  function r(a) {
    var l = {
      options: {
        directed: a.isDirected(),
        multigraph: a.isMultigraph(),
        compound: a.isCompound()
      },
      nodes: n(a),
      edges: o(a)
    };
    return e.isUndefined(a.graph()) || (l.value = e.clone(a.graph())), l;
  }
  function n(a) {
    return e.map(a.nodes(), function(l) {
      var u = a.node(l), f = a.parent(l), c = { v: l };
      return e.isUndefined(u) || (c.value = u), e.isUndefined(f) || (c.parent = f), c;
    });
  }
  function o(a) {
    return e.map(a.edges(), function(l) {
      var u = a.edge(l), f = { v: l.v, w: l.w };
      return e.isUndefined(l.name) || (f.name = l.name), e.isUndefined(u) || (f.value = u), f;
    });
  }
  function s(a) {
    var l = new t(a.options).setGraph(a.value);
    return e.each(a.nodes, function(u) {
      l.setNode(u.v, u.value), u.parent && l.setParent(u.v, u.parent);
    }), e.each(a.edges, function(u) {
      l.setEdge({ v: u.v, w: u.w, name: u.name }, u.value);
    }), l;
  }
  return rw;
}
var nw, kL;
function A_e() {
  if (kL)
    return nw;
  kL = 1;
  var e = Pn();
  nw = t;
  function t(r) {
    var n = {}, o = [], s;
    function a(l) {
      e.has(n, l) || (n[l] = !0, s.push(l), e.each(r.successors(l), a), e.each(r.predecessors(l), a));
    }
    return e.each(r.nodes(), function(l) {
      s = [], a(l), s.length && o.push(s);
    }), o;
  }
  return nw;
}
var iw, CL;
function N6() {
  if (CL)
    return iw;
  CL = 1;
  var e = Pn();
  iw = t;
  function t() {
    this._arr = [], this._keyIndices = {};
  }
  return t.prototype.size = function() {
    return this._arr.length;
  }, t.prototype.keys = function() {
    return this._arr.map(function(r) {
      return r.key;
    });
  }, t.prototype.has = function(r) {
    return e.has(this._keyIndices, r);
  }, t.prototype.priority = function(r) {
    var n = this._keyIndices[r];
    if (n !== void 0)
      return this._arr[n].priority;
  }, t.prototype.min = function() {
    if (this.size() === 0)
      throw new Error("Queue underflow");
    return this._arr[0].key;
  }, t.prototype.add = function(r, n) {
    var o = this._keyIndices;
    if (r = String(r), !e.has(o, r)) {
      var s = this._arr, a = s.length;
      return o[r] = a, s.push({ key: r, priority: n }), this._decrease(a), !0;
    }
    return !1;
  }, t.prototype.removeMin = function() {
    this._swap(0, this._arr.length - 1);
    var r = this._arr.pop();
    return delete this._keyIndices[r.key], this._heapify(0), r.key;
  }, t.prototype.decrease = function(r, n) {
    var o = this._keyIndices[r];
    if (n > this._arr[o].priority)
      throw new Error("New priority is greater than current priority. Key: " + r + " Old: " + this._arr[o].priority + " New: " + n);
    this._arr[o].priority = n, this._decrease(o);
  }, t.prototype._heapify = function(r) {
    var n = this._arr, o = 2 * r, s = o + 1, a = r;
    o < n.length && (a = n[o].priority < n[a].priority ? o : a, s < n.length && (a = n[s].priority < n[a].priority ? s : a), a !== r && (this._swap(r, a), this._heapify(a)));
  }, t.prototype._decrease = function(r) {
    for (var n = this._arr, o = n[r].priority, s; r !== 0 && (s = r >> 1, !(n[s].priority < o)); )
      this._swap(r, s), r = s;
  }, t.prototype._swap = function(r, n) {
    var o = this._arr, s = this._keyIndices, a = o[r], l = o[n];
    o[r] = l, o[n] = a, s[l.key] = r, s[a.key] = n;
  }, iw;
}
var ow, IL;
function k6() {
  if (IL)
    return ow;
  IL = 1;
  var e = Pn(), t = N6();
  ow = n;
  var r = e.constant(1);
  function n(s, a, l, u) {
    return o(
      s,
      String(a),
      l || r,
      u || function(f) {
        return s.outEdges(f);
      }
    );
  }
  function o(s, a, l, u) {
    var f = {}, c = new t(), d, h, p = function(v) {
      var y = v.v !== d ? v.v : v.w, w = f[y], S = l(v), x = h.distance + S;
      if (S < 0)
        throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + v + " Weight: " + S);
      x < w.distance && (w.distance = x, w.predecessor = d, c.decrease(y, x));
    };
    for (s.nodes().forEach(function(v) {
      var y = v === a ? 0 : Number.POSITIVE_INFINITY;
      f[v] = { distance: y }, c.add(v, y);
    }); c.size() > 0 && (d = c.removeMin(), h = f[d], h.distance !== Number.POSITIVE_INFINITY); )
      u(d).forEach(p);
    return f;
  }
  return ow;
}
var sw, ML;
function T_e() {
  if (ML)
    return sw;
  ML = 1;
  var e = k6(), t = Pn();
  sw = r;
  function r(n, o, s) {
    return t.transform(n.nodes(), function(a, l) {
      a[l] = e(n, l, o, s);
    }, {});
  }
  return sw;
}
var aw, OL;
function C6() {
  if (OL)
    return aw;
  OL = 1;
  var e = Pn();
  aw = t;
  function t(r) {
    var n = 0, o = [], s = {}, a = [];
    function l(u) {
      var f = s[u] = {
        onStack: !0,
        lowlink: n,
        index: n++
      };
      if (o.push(u), r.successors(u).forEach(function(h) {
        e.has(s, h) ? s[h].onStack && (f.lowlink = Math.min(f.lowlink, s[h].index)) : (l(h), f.lowlink = Math.min(f.lowlink, s[h].lowlink));
      }), f.lowlink === f.index) {
        var c = [], d;
        do
          d = o.pop(), s[d].onStack = !1, c.push(d);
        while (u !== d);
        a.push(c);
      }
    }
    return r.nodes().forEach(function(u) {
      e.has(s, u) || l(u);
    }), a;
  }
  return aw;
}
var lw, LL;
function $_e() {
  if (LL)
    return lw;
  LL = 1;
  var e = Pn(), t = C6();
  lw = r;
  function r(n) {
    return e.filter(t(n), function(o) {
      return o.length > 1 || o.length === 1 && n.hasEdge(o[0], o[0]);
    });
  }
  return lw;
}
var uw, PL;
function N_e() {
  if (PL)
    return uw;
  PL = 1;
  var e = Pn();
  uw = r;
  var t = e.constant(1);
  function r(o, s, a) {
    return n(
      o,
      s || t,
      a || function(l) {
        return o.outEdges(l);
      }
    );
  }
  function n(o, s, a) {
    var l = {}, u = o.nodes();
    return u.forEach(function(f) {
      l[f] = {}, l[f][f] = { distance: 0 }, u.forEach(function(c) {
        f !== c && (l[f][c] = { distance: Number.POSITIVE_INFINITY });
      }), a(f).forEach(function(c) {
        var d = c.v === f ? c.w : c.v, h = s(c);
        l[f][d] = { distance: h, predecessor: f };
      });
    }), u.forEach(function(f) {
      var c = l[f];
      u.forEach(function(d) {
        var h = l[d];
        u.forEach(function(p) {
          var v = h[f], y = c[p], w = h[p], S = v.distance + y.distance;
          S < w.distance && (w.distance = S, w.predecessor = y.predecessor);
        });
      });
    }), l;
  }
  return uw;
}
var fw, DL;
function I6() {
  if (DL)
    return fw;
  DL = 1;
  var e = Pn();
  fw = t, t.CycleException = r;
  function t(n) {
    var o = {}, s = {}, a = [];
    function l(u) {
      if (e.has(s, u))
        throw new r();
      e.has(o, u) || (s[u] = !0, o[u] = !0, e.each(n.predecessors(u), l), delete s[u], a.push(u));
    }
    if (e.each(n.sinks(), l), e.size(o) !== n.nodeCount())
      throw new r();
    return a;
  }
  function r() {
  }
  return r.prototype = new Error(), fw;
}
var cw, FL;
function k_e() {
  if (FL)
    return cw;
  FL = 1;
  var e = I6();
  cw = t;
  function t(r) {
    try {
      e(r);
    } catch (n) {
      if (n instanceof e.CycleException)
        return !1;
      throw n;
    }
    return !0;
  }
  return cw;
}
var dw, jL;
function M6() {
  if (jL)
    return dw;
  jL = 1;
  var e = Pn();
  dw = t;
  function t(n, o, s) {
    e.isArray(o) || (o = [o]);
    var a = (n.isDirected() ? n.successors : n.neighbors).bind(n), l = [], u = {};
    return e.each(o, function(f) {
      if (!n.hasNode(f))
        throw new Error("Graph does not have node: " + f);
      r(n, f, s === "post", u, a, l);
    }), l;
  }
  function r(n, o, s, a, l, u) {
    e.has(a, o) || (a[o] = !0, s || u.push(o), e.each(l(o), function(f) {
      r(n, f, s, a, l, u);
    }), s && u.push(o));
  }
  return dw;
}
var hw, BL;
function C_e() {
  if (BL)
    return hw;
  BL = 1;
  var e = M6();
  hw = t;
  function t(r, n) {
    return e(r, n, "post");
  }
  return hw;
}
var pw, qL;
function I_e() {
  if (qL)
    return pw;
  qL = 1;
  var e = M6();
  pw = t;
  function t(r, n) {
    return e(r, n, "pre");
  }
  return pw;
}
var gw, WL;
function M_e() {
  if (WL)
    return gw;
  WL = 1;
  var e = Pn(), t = _A(), r = N6();
  gw = n;
  function n(o, s) {
    var a = new t(), l = {}, u = new r(), f;
    function c(h) {
      var p = h.v === f ? h.w : h.v, v = u.priority(p);
      if (v !== void 0) {
        var y = s(h);
        y < v && (l[p] = f, u.decrease(p, y));
      }
    }
    if (o.nodeCount() === 0)
      return a;
    e.each(o.nodes(), function(h) {
      u.add(h, Number.POSITIVE_INFINITY), a.setNode(h);
    }), u.decrease(o.nodes()[0], 0);
    for (var d = !1; u.size() > 0; ) {
      if (f = u.removeMin(), e.has(l, f))
        a.setEdge(f, l[f]);
      else {
        if (d)
          throw new Error("Input graph is not connected: " + o);
        d = !0;
      }
      o.nodeEdges(f).forEach(c);
    }
    return a;
  }
  return gw;
}
var bw, UL;
function O_e() {
  return UL || (UL = 1, bw = {
    components: A_e(),
    dijkstra: k6(),
    dijkstraAll: T_e(),
    findCycles: $_e(),
    floydWarshall: N_e(),
    isAcyclic: k_e(),
    postorder: C_e(),
    preorder: I_e(),
    prim: M_e(),
    tarjan: C6(),
    topsort: I6()
  }), bw;
}
var yw, HL;
function L_e() {
  if (HL)
    return yw;
  HL = 1;
  var e = x_e();
  return yw = {
    Graph: e.Graph,
    json: R_e(),
    alg: O_e(),
    version: e.version
  }, yw;
}
var Xh;
if (typeof iA == "function")
  try {
    Xh = L_e();
  } catch {
  }
Xh || (Xh = window.graphlib);
var oi = Xh, vw, VL;
function P_e() {
  if (VL)
    return vw;
  VL = 1;
  var e = i6(), t = 1, r = 4;
  function n(o) {
    return e(o, t | r);
  }
  return vw = n, vw;
}
var mw, zL;
function fb() {
  if (zL)
    return mw;
  zL = 1;
  var e = Tu(), t = No(), r = tb(), n = In();
  function o(s, a, l) {
    if (!n(l))
      return !1;
    var u = typeof a;
    return (u == "number" ? t(l) && r(a, l.length) : u == "string" && a in l) ? e(l[a], s) : !1;
  }
  return mw = o, mw;
}
var _w, GL;
function D_e() {
  if (GL)
    return _w;
  GL = 1;
  var e = ub(), t = Tu(), r = fb(), n = sl(), o = Object.prototype, s = o.hasOwnProperty, a = e(function(l, u) {
    l = Object(l);
    var f = -1, c = u.length, d = c > 2 ? u[2] : void 0;
    for (d && r(u[0], u[1], d) && (c = 1); ++f < c; )
      for (var h = u[f], p = n(h), v = -1, y = p.length; ++v < y; ) {
        var w = p[v], S = l[w];
        (S === void 0 || t(S, o[w]) && !s.call(l, w)) && (l[w] = h[w]);
      }
    return l;
  });
  return _w = a, _w;
}
var ww, KL;
function F_e() {
  if (KL)
    return ww;
  KL = 1;
  var e = ko(), t = No(), r = Rs();
  function n(o) {
    return function(s, a, l) {
      var u = Object(s);
      if (!t(s)) {
        var f = e(a, 3);
        s = r(s), a = function(d) {
          return f(u[d], d, u);
        };
      }
      var c = o(s, a, l);
      return c > -1 ? u[f ? s[c] : c] : void 0;
    };
  }
  return ww = n, ww;
}
var Sw, YL;
function j_e() {
  if (YL)
    return Sw;
  YL = 1;
  var e = A6(), t = ko(), r = N7, n = Math.max;
  function o(s, a, l) {
    var u = s == null ? 0 : s.length;
    if (!u)
      return -1;
    var f = l == null ? 0 : r(l);
    return f < 0 && (f = n(u + f, 0)), e(s, t(a, 3), f);
  }
  return Sw = o, Sw;
}
var Ew, XL;
function B_e() {
  if (XL)
    return Ew;
  XL = 1;
  var e = F_e(), t = j_e(), r = e(t);
  return Ew = r, Ew;
}
var xw, JL;
function O6() {
  if (JL)
    return xw;
  JL = 1;
  var e = mA();
  function t(r) {
    var n = r == null ? 0 : r.length;
    return n ? e(r, 1) : [];
  }
  return xw = t, xw;
}
var Rw, QL;
function q_e() {
  if (QL)
    return Rw;
  QL = 1;
  var e = gA(), t = o6(), r = sl();
  function n(o, s) {
    return o == null ? o : e(o, t(s), r);
  }
  return Rw = n, Rw;
}
var Aw, ZL;
function W_e() {
  if (ZL)
    return Aw;
  ZL = 1;
  function e(t) {
    var r = t == null ? 0 : t.length;
    return r ? t[r - 1] : void 0;
  }
  return Aw = e, Aw;
}
var Tw, eP;
function U_e() {
  if (eP)
    return Tw;
  eP = 1;
  var e = Zg(), t = bA(), r = ko();
  function n(o, s) {
    var a = {};
    return s = r(s, 3), t(o, function(l, u, f) {
      e(a, u, s(l, u, f));
    }), a;
  }
  return Tw = n, Tw;
}
var $w, tP;
function wA() {
  if (tP)
    return $w;
  tP = 1;
  var e = yu();
  function t(r, n, o) {
    for (var s = -1, a = r.length; ++s < a; ) {
      var l = r[s], u = n(l);
      if (u != null && (f === void 0 ? u === u && !e(u) : o(u, f)))
        var f = u, c = l;
    }
    return c;
  }
  return $w = t, $w;
}
var Nw, rP;
function H_e() {
  if (rP)
    return Nw;
  rP = 1;
  function e(t, r) {
    return t > r;
  }
  return Nw = e, Nw;
}
var kw, nP;
function V_e() {
  if (nP)
    return kw;
  nP = 1;
  var e = wA(), t = H_e(), r = al();
  function n(o) {
    return o && o.length ? e(o, r, t) : void 0;
  }
  return kw = n, kw;
}
var Cw, iP;
function L6() {
  if (iP)
    return Cw;
  iP = 1;
  var e = Zg(), t = Tu();
  function r(n, o, s) {
    (s !== void 0 && !t(n[o], s) || s === void 0 && !(o in n)) && e(n, o, s);
  }
  return Cw = r, Cw;
}
var Iw, oP;
function z_e() {
  if (oP)
    return Iw;
  oP = 1;
  var e = Ka(), t = ib(), r = ji(), n = "[object Object]", o = Function.prototype, s = Object.prototype, a = o.toString, l = s.hasOwnProperty, u = a.call(Object);
  function f(c) {
    if (!r(c) || e(c) != n)
      return !1;
    var d = t(c);
    if (d === null)
      return !0;
    var h = l.call(d, "constructor") && d.constructor;
    return typeof h == "function" && h instanceof h && a.call(h) == u;
  }
  return Iw = f, Iw;
}
var Mw, sP;
function P6() {
  if (sP)
    return Mw;
  sP = 1;
  function e(t, r) {
    if (!(r === "constructor" && typeof t[r] == "function") && r != "__proto__")
      return t[r];
  }
  return Mw = e, Mw;
}
var Ow, aP;
function G_e() {
  if (aP)
    return Ow;
  aP = 1;
  var e = Fc(), t = sl();
  function r(n) {
    return e(n, t(n));
  }
  return Ow = r, Ow;
}
var Lw, lP;
function K_e() {
  if (lP)
    return Lw;
  lP = 1;
  var e = L6(), t = zq(), r = t6(), n = Gq(), o = n6(), s = jc(), a = Yt(), l = T6(), u = $u(), f = Dc(), c = In(), d = z_e(), h = Bc(), p = P6(), v = G_e();
  function y(w, S, x, E, N, C, j) {
    var J = p(w, x), z = p(S, x), $ = j.get(z);
    if ($) {
      e(w, x, $);
      return;
    }
    var G = C ? C(J, z, x + "", w, S, j) : void 0, I = G === void 0;
    if (I) {
      var W = a(z), k = !W && u(z), U = !W && !k && h(z);
      G = z, W || k || U ? a(J) ? G = J : l(J) ? G = n(J) : k ? (I = !1, G = t(z, !0)) : U ? (I = !1, G = r(z, !0)) : G = [] : d(z) || s(z) ? (G = J, s(J) ? G = v(J) : (!c(J) || f(J)) && (G = o(z))) : I = !1;
    }
    I && (j.set(z, G), N(G, z, E, C, j), j.delete(z)), e(w, x, G);
  }
  return Lw = y, Lw;
}
var Pw, uP;
function Y_e() {
  if (uP)
    return Pw;
  uP = 1;
  var e = Qg(), t = L6(), r = gA(), n = K_e(), o = In(), s = sl(), a = P6();
  function l(u, f, c, d, h) {
    u !== f && r(f, function(p, v) {
      if (h || (h = new e()), o(p))
        n(u, f, v, c, l, d, h);
      else {
        var y = d ? d(a(u, v), p, v + "", u, f, h) : void 0;
        y === void 0 && (y = p), t(u, v, y);
      }
    }, s);
  }
  return Pw = l, Pw;
}
var Dw, fP;
function X_e() {
  if (fP)
    return Dw;
  fP = 1;
  var e = ub(), t = fb();
  function r(n) {
    return e(function(o, s) {
      var a = -1, l = s.length, u = l > 1 ? s[l - 1] : void 0, f = l > 2 ? s[2] : void 0;
      for (u = n.length > 3 && typeof u == "function" ? (l--, u) : void 0, f && t(s[0], s[1], f) && (u = l < 3 ? void 0 : u, l = 1), o = Object(o); ++a < l; ) {
        var c = s[a];
        c && n(o, c, a, u);
      }
      return o;
    });
  }
  return Dw = r, Dw;
}
var Fw, cP;
function J_e() {
  if (cP)
    return Fw;
  cP = 1;
  var e = Y_e(), t = X_e(), r = t(function(n, o, s) {
    e(n, o, s);
  });
  return Fw = r, Fw;
}
var jw, dP;
function D6() {
  if (dP)
    return jw;
  dP = 1;
  function e(t, r) {
    return t < r;
  }
  return jw = e, jw;
}
var Bw, hP;
function Q_e() {
  if (hP)
    return Bw;
  hP = 1;
  var e = wA(), t = D6(), r = al();
  function n(o) {
    return o && o.length ? e(o, r, t) : void 0;
  }
  return Bw = n, Bw;
}
var qw, pP;
function Z_e() {
  if (pP)
    return qw;
  pP = 1;
  var e = wA(), t = ko(), r = D6();
  function n(o, s) {
    return o && o.length ? e(o, t(s, 2), r) : void 0;
  }
  return qw = n, qw;
}
var Ww, gP;
function ewe() {
  if (gP)
    return Ww;
  gP = 1;
  var e = Zn(), t = function() {
    return e.Date.now();
  };
  return Ww = t, Ww;
}
var Uw, bP;
function twe() {
  if (bP)
    return Uw;
  bP = 1;
  var e = eb(), t = ab(), r = tb(), n = In(), o = qc();
  function s(a, l, u, f) {
    if (!n(a))
      return a;
    l = t(l, a);
    for (var c = -1, d = l.length, h = d - 1, p = a; p != null && ++c < d; ) {
      var v = o(l[c]), y = u;
      if (v === "__proto__" || v === "constructor" || v === "prototype")
        return a;
      if (c != h) {
        var w = p[v];
        y = f ? f(w, v, p) : void 0, y === void 0 && (y = n(w) ? w : r(l[c + 1]) ? [] : {});
      }
      e(p, v, y), p = p[v];
    }
    return a;
  }
  return Uw = s, Uw;
}
var Hw, yP;
function rwe() {
  if (yP)
    return Hw;
  yP = 1;
  var e = lb(), t = twe(), r = ab();
  function n(o, s, a) {
    for (var l = -1, u = s.length, f = {}; ++l < u; ) {
      var c = s[l], d = e(o, c);
      a(d, c) && t(f, r(c, o), d);
    }
    return f;
  }
  return Hw = n, Hw;
}
var Vw, vP;
function nwe() {
  if (vP)
    return Vw;
  vP = 1;
  var e = rwe(), t = b6();
  function r(n, o) {
    return e(n, o, function(s, a) {
      return t(n, a);
    });
  }
  return Vw = r, Vw;
}
var zw, mP;
function iwe() {
  if (mP)
    return zw;
  mP = 1;
  var e = O6(), t = x6(), r = R6();
  function n(o) {
    return r(t(o, void 0, e), o + "");
  }
  return zw = n, zw;
}
var Gw, _P;
function owe() {
  if (_P)
    return Gw;
  _P = 1;
  var e = nwe(), t = iwe(), r = t(function(n, o) {
    return n == null ? {} : e(n, o);
  });
  return Gw = r, Gw;
}
var Kw, wP;
function swe() {
  if (wP)
    return Kw;
  wP = 1;
  var e = Math.ceil, t = Math.max;
  function r(n, o, s, a) {
    for (var l = -1, u = t(e((o - n) / (s || 1)), 0), f = Array(u); u--; )
      f[a ? u : ++l] = n, n += s;
    return f;
  }
  return Kw = r, Kw;
}
var Yw, SP;
function awe() {
  if (SP)
    return Yw;
  SP = 1;
  var e = swe(), t = fb(), r = $7;
  function n(o) {
    return function(s, a, l) {
      return l && typeof l != "number" && t(s, a, l) && (a = l = void 0), s = r(s), a === void 0 ? (a = s, s = 0) : a = r(a), l = l === void 0 ? s < a ? 1 : -1 : r(l), e(s, a, l, o);
    };
  }
  return Yw = n, Yw;
}
var Xw, EP;
function lwe() {
  if (EP)
    return Xw;
  EP = 1;
  var e = awe(), t = e();
  return Xw = t, Xw;
}
var Jw, xP;
function uwe() {
  if (xP)
    return Jw;
  xP = 1;
  function e(t, r) {
    var n = t.length;
    for (t.sort(r); n--; )
      t[n] = t[n].value;
    return t;
  }
  return Jw = e, Jw;
}
var Qw, RP;
function fwe() {
  if (RP)
    return Qw;
  RP = 1;
  var e = yu();
  function t(r, n) {
    if (r !== n) {
      var o = r !== void 0, s = r === null, a = r === r, l = e(r), u = n !== void 0, f = n === null, c = n === n, d = e(n);
      if (!f && !d && !l && r > n || l && u && c && !f && !d || s && u && c || !o && c || !a)
        return 1;
      if (!s && !l && !d && r < n || d && o && a && !s && !l || f && o && a || !u && a || !c)
        return -1;
    }
    return 0;
  }
  return Qw = t, Qw;
}
var Zw, AP;
function cwe() {
  if (AP)
    return Zw;
  AP = 1;
  var e = fwe();
  function t(r, n, o) {
    for (var s = -1, a = r.criteria, l = n.criteria, u = a.length, f = o.length; ++s < u; ) {
      var c = e(a[s], l[s]);
      if (c) {
        if (s >= f)
          return c;
        var d = o[s];
        return c * (d == "desc" ? -1 : 1);
      }
    }
    return r.index - n.index;
  }
  return Zw = t, Zw;
}
var e1, TP;
function dwe() {
  if (TP)
    return e1;
  TP = 1;
  var e = sb(), t = lb(), r = ko(), n = w6(), o = uwe(), s = rb(), a = cwe(), l = al(), u = Yt();
  function f(c, d, h) {
    d.length ? d = e(d, function(y) {
      return u(y) ? function(w) {
        return t(w, y.length === 1 ? y[0] : y);
      } : y;
    }) : d = [l];
    var p = -1;
    d = e(d, s(r));
    var v = n(c, function(y, w, S) {
      var x = e(d, function(E) {
        return E(y);
      });
      return { criteria: x, index: ++p, value: y };
    });
    return o(v, function(y, w) {
      return a(y, w, h);
    });
  }
  return e1 = f, e1;
}
var t1, $P;
function hwe() {
  if ($P)
    return t1;
  $P = 1;
  var e = mA(), t = dwe(), r = ub(), n = fb(), o = r(function(s, a) {
    if (s == null)
      return [];
    var l = a.length;
    return l > 1 && n(s, a[0], a[1]) ? a = [] : l > 2 && n(a[0], a[1], a[2]) && (a = [a[0]]), t(s, e(a, 1), []);
  });
  return t1 = o, t1;
}
var r1, NP;
function pwe() {
  if (NP)
    return r1;
  NP = 1;
  var e = p6(), t = 0;
  function r(n) {
    var o = ++t;
    return e(n) + o;
  }
  return r1 = r, r1;
}
var n1, kP;
function gwe() {
  if (kP)
    return n1;
  kP = 1;
  function e(t, r, n) {
    for (var o = -1, s = t.length, a = r.length, l = {}; ++o < s; ) {
      var u = o < a ? r[o] : void 0;
      n(l, t[o], u);
    }
    return l;
  }
  return n1 = e, n1;
}
var i1, CP;
function bwe() {
  if (CP)
    return i1;
  CP = 1;
  var e = eb(), t = gwe();
  function r(n, o) {
    return t(n || [], o || [], e);
  }
  return i1 = r, i1;
}
var Jh;
if (typeof iA == "function")
  try {
    Jh = {
      cloneDeep: P_e(),
      constant: pA(),
      defaults: D_e(),
      each: a6(),
      filter: v6(),
      find: B_e(),
      flatten: O6(),
      forEach: s6(),
      forIn: q_e(),
      has: m6(),
      isUndefined: _6(),
      last: W_e(),
      map: S6(),
      mapValues: U_e(),
      max: V_e(),
      merge: J_e(),
      min: Q_e(),
      minBy: Z_e(),
      now: ewe(),
      pick: owe(),
      range: lwe(),
      reduce: E6(),
      sortBy: hwe(),
      uniqueId: pwe(),
      values: $6(),
      zipObject: bwe()
    };
  } catch {
  }
Jh || (Jh = window._);
var Lt = Jh, ywe = cb;
function cb() {
  var e = {};
  e._next = e._prev = e, this._sentinel = e;
}
cb.prototype.dequeue = function() {
  var e = this._sentinel, t = e._prev;
  if (t !== e)
    return F6(t), t;
};
cb.prototype.enqueue = function(e) {
  var t = this._sentinel;
  e._prev && e._next && F6(e), e._next = t._next, t._next._prev = e, t._next = e, e._prev = t;
};
cb.prototype.toString = function() {
  for (var e = [], t = this._sentinel, r = t._prev; r !== t; )
    e.push(JSON.stringify(r, vwe)), r = r._prev;
  return "[" + e.join(", ") + "]";
};
function F6(e) {
  e._prev._next = e._next, e._next._prev = e._prev, delete e._next, delete e._prev;
}
function vwe(e, t) {
  if (e !== "_next" && e !== "_prev")
    return t;
}
var eo = Lt, mwe = oi.Graph, _we = ywe, wwe = Ewe, Swe = eo.constant(1);
function Ewe(e, t) {
  if (e.nodeCount() <= 1)
    return [];
  var r = Rwe(e, t || Swe), n = xwe(r.graph, r.buckets, r.zeroIdx);
  return eo.flatten(eo.map(n, function(o) {
    return e.outEdges(o.v, o.w);
  }), !0);
}
function xwe(e, t, r) {
  for (var n = [], o = t[t.length - 1], s = t[0], a; e.nodeCount(); ) {
    for (; a = s.dequeue(); )
      o1(e, t, r, a);
    for (; a = o.dequeue(); )
      o1(e, t, r, a);
    if (e.nodeCount()) {
      for (var l = t.length - 2; l > 0; --l)
        if (a = t[l].dequeue(), a) {
          n = n.concat(o1(e, t, r, a, !0));
          break;
        }
    }
  }
  return n;
}
function o1(e, t, r, n, o) {
  var s = o ? [] : void 0;
  return eo.forEach(e.inEdges(n.v), function(a) {
    var l = e.edge(a), u = e.node(a.v);
    o && s.push({ v: a.v, w: a.w }), u.out -= l, SE(t, r, u);
  }), eo.forEach(e.outEdges(n.v), function(a) {
    var l = e.edge(a), u = a.w, f = e.node(u);
    f.in -= l, SE(t, r, f);
  }), e.removeNode(n.v), s;
}
function Rwe(e, t) {
  var r = new mwe(), n = 0, o = 0;
  eo.forEach(e.nodes(), function(l) {
    r.setNode(l, { v: l, in: 0, out: 0 });
  }), eo.forEach(e.edges(), function(l) {
    var u = r.edge(l.v, l.w) || 0, f = t(l), c = u + f;
    r.setEdge(l.v, l.w, c), o = Math.max(o, r.node(l.v).out += f), n = Math.max(n, r.node(l.w).in += f);
  });
  var s = eo.range(o + n + 3).map(function() {
    return new _we();
  }), a = n + 1;
  return eo.forEach(r.nodes(), function(l) {
    SE(s, a, r.node(l));
  }), { graph: r, buckets: s, zeroIdx: a };
}
function SE(e, t, r) {
  r.out ? r.in ? e[r.out - r.in + t].enqueue(r) : e[e.length - 1].enqueue(r) : e[0].enqueue(r);
}
var ra = Lt, Awe = wwe, Twe = {
  run: $we,
  undo: kwe
};
function $we(e) {
  var t = e.graph().acyclicer === "greedy" ? Awe(e, r(e)) : Nwe(e);
  ra.forEach(t, function(n) {
    var o = e.edge(n);
    e.removeEdge(n), o.forwardName = n.name, o.reversed = !0, e.setEdge(n.w, n.v, o, ra.uniqueId("rev"));
  });
  function r(n) {
    return function(o) {
      return n.edge(o).weight;
    };
  }
}
function Nwe(e) {
  var t = [], r = {}, n = {};
  function o(s) {
    ra.has(n, s) || (n[s] = !0, r[s] = !0, ra.forEach(e.outEdges(s), function(a) {
      ra.has(r, a.w) ? t.push(a) : o(a.w);
    }), delete r[s]);
  }
  return ra.forEach(e.nodes(), o), t;
}
function kwe(e) {
  ra.forEach(e.edges(), function(t) {
    var r = e.edge(t);
    if (r.reversed) {
      e.removeEdge(t);
      var n = r.forwardName;
      delete r.reversed, delete r.forwardName, e.setEdge(t.w, t.v, r, n);
    }
  });
}
var yt = Lt, j6 = oi.Graph, rn = {
  addDummyNode: B6,
  simplify: Cwe,
  asNonCompoundGraph: Iwe,
  successorWeights: Mwe,
  predecessorWeights: Owe,
  intersectRect: Lwe,
  buildLayerMatrix: Pwe,
  normalizeRanks: Dwe,
  removeEmptyRanks: Fwe,
  addBorderNode: jwe,
  maxRank: q6,
  partition: Bwe,
  time: qwe,
  notime: Wwe
};
function B6(e, t, r, n) {
  var o;
  do
    o = yt.uniqueId(n);
  while (e.hasNode(o));
  return r.dummy = t, e.setNode(o, r), o;
}
function Cwe(e) {
  var t = new j6().setGraph(e.graph());
  return yt.forEach(e.nodes(), function(r) {
    t.setNode(r, e.node(r));
  }), yt.forEach(e.edges(), function(r) {
    var n = t.edge(r.v, r.w) || { weight: 0, minlen: 1 }, o = e.edge(r);
    t.setEdge(r.v, r.w, {
      weight: n.weight + o.weight,
      minlen: Math.max(n.minlen, o.minlen)
    });
  }), t;
}
function Iwe(e) {
  var t = new j6({ multigraph: e.isMultigraph() }).setGraph(e.graph());
  return yt.forEach(e.nodes(), function(r) {
    e.children(r).length || t.setNode(r, e.node(r));
  }), yt.forEach(e.edges(), function(r) {
    t.setEdge(r, e.edge(r));
  }), t;
}
function Mwe(e) {
  var t = yt.map(e.nodes(), function(r) {
    var n = {};
    return yt.forEach(e.outEdges(r), function(o) {
      n[o.w] = (n[o.w] || 0) + e.edge(o).weight;
    }), n;
  });
  return yt.zipObject(e.nodes(), t);
}
function Owe(e) {
  var t = yt.map(e.nodes(), function(r) {
    var n = {};
    return yt.forEach(e.inEdges(r), function(o) {
      n[o.v] = (n[o.v] || 0) + e.edge(o).weight;
    }), n;
  });
  return yt.zipObject(e.nodes(), t);
}
function Lwe(e, t) {
  var r = e.x, n = e.y, o = t.x - r, s = t.y - n, a = e.width / 2, l = e.height / 2;
  if (!o && !s)
    throw new Error("Not possible to find intersection inside of the rectangle");
  var u, f;
  return Math.abs(s) * a > Math.abs(o) * l ? (s < 0 && (l = -l), u = l * o / s, f = l) : (o < 0 && (a = -a), u = a, f = a * s / o), { x: r + u, y: n + f };
}
function Pwe(e) {
  var t = yt.map(yt.range(q6(e) + 1), function() {
    return [];
  });
  return yt.forEach(e.nodes(), function(r) {
    var n = e.node(r), o = n.rank;
    yt.isUndefined(o) || (t[o][n.order] = r);
  }), t;
}
function Dwe(e) {
  var t = yt.min(yt.map(e.nodes(), function(r) {
    return e.node(r).rank;
  }));
  yt.forEach(e.nodes(), function(r) {
    var n = e.node(r);
    yt.has(n, "rank") && (n.rank -= t);
  });
}
function Fwe(e) {
  var t = yt.min(yt.map(e.nodes(), function(s) {
    return e.node(s).rank;
  })), r = [];
  yt.forEach(e.nodes(), function(s) {
    var a = e.node(s).rank - t;
    r[a] || (r[a] = []), r[a].push(s);
  });
  var n = 0, o = e.graph().nodeRankFactor;
  yt.forEach(r, function(s, a) {
    yt.isUndefined(s) && a % o !== 0 ? --n : n && yt.forEach(s, function(l) {
      e.node(l).rank += n;
    });
  });
}
function jwe(e, t, r, n) {
  var o = {
    width: 0,
    height: 0
  };
  return arguments.length >= 4 && (o.rank = r, o.order = n), B6(e, "border", o, t);
}
function q6(e) {
  return yt.max(yt.map(e.nodes(), function(t) {
    var r = e.node(t).rank;
    if (!yt.isUndefined(r))
      return r;
  }));
}
function Bwe(e, t) {
  var r = { lhs: [], rhs: [] };
  return yt.forEach(e, function(n) {
    t(n) ? r.lhs.push(n) : r.rhs.push(n);
  }), r;
}
function qwe(e, t) {
  var r = yt.now();
  try {
    return t();
  } finally {
    console.log(e + " time: " + (yt.now() - r) + "ms");
  }
}
function Wwe(e, t) {
  return t();
}
var W6 = Lt, Uwe = rn, Hwe = {
  run: Vwe,
  undo: Gwe
};
function Vwe(e) {
  e.graph().dummyChains = [], W6.forEach(e.edges(), function(t) {
    zwe(e, t);
  });
}
function zwe(e, t) {
  var r = t.v, n = e.node(r).rank, o = t.w, s = e.node(o).rank, a = t.name, l = e.edge(t), u = l.labelRank;
  if (s !== n + 1) {
    e.removeEdge(t);
    var f, c, d;
    for (d = 0, ++n; n < s; ++d, ++n)
      l.points = [], c = {
        width: 0,
        height: 0,
        edgeLabel: l,
        edgeObj: t,
        rank: n
      }, f = Uwe.addDummyNode(e, "edge", c, "_d"), n === u && (c.width = l.width, c.height = l.height, c.dummy = "edge-label", c.labelpos = l.labelpos), e.setEdge(r, f, { weight: l.weight }, a), d === 0 && e.graph().dummyChains.push(f), r = f;
    e.setEdge(r, o, { weight: l.weight }, a);
  }
}
function Gwe(e) {
  W6.forEach(e.graph().dummyChains, function(t) {
    var r = e.node(t), n = r.edgeLabel, o;
    for (e.setEdge(r.edgeObj, n); r.dummy; )
      o = e.successors(t)[0], e.removeNode(t), n.points.push({ x: r.x, y: r.y }), r.dummy === "edge-label" && (n.x = r.x, n.y = r.y, n.width = r.width, n.height = r.height), t = o, r = e.node(t);
  });
}
var Id = Lt, db = {
  longestPath: Kwe,
  slack: Ywe
};
function Kwe(e) {
  var t = {};
  function r(n) {
    var o = e.node(n);
    if (Id.has(t, n))
      return o.rank;
    t[n] = !0;
    var s = Id.min(Id.map(e.outEdges(n), function(a) {
      return r(a.w) - e.edge(a).minlen;
    }));
    return (s === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3
    s === void 0 || // return value of _.map([]) for Lodash 4
    s === null) && (s = 0), o.rank = s;
  }
  Id.forEach(e.sources(), r);
}
function Ywe(e, t) {
  return e.node(t.w).rank - e.node(t.v).rank - e.edge(t).minlen;
}
var Qh = Lt, Xwe = oi.Graph, Zh = db.slack, U6 = Jwe;
function Jwe(e) {
  var t = new Xwe({ directed: !1 }), r = e.nodes()[0], n = e.nodeCount();
  t.setNode(r, {});
  for (var o, s; Qwe(t, e) < n; )
    o = Zwe(t, e), s = t.hasNode(o.v) ? Zh(e, o) : -Zh(e, o), e1e(t, e, s);
  return t;
}
function Qwe(e, t) {
  function r(n) {
    Qh.forEach(t.nodeEdges(n), function(o) {
      var s = o.v, a = n === s ? o.w : s;
      !e.hasNode(a) && !Zh(t, o) && (e.setNode(a, {}), e.setEdge(n, a, {}), r(a));
    });
  }
  return Qh.forEach(e.nodes(), r), e.nodeCount();
}
function Zwe(e, t) {
  return Qh.minBy(t.edges(), function(r) {
    if (e.hasNode(r.v) !== e.hasNode(r.w))
      return Zh(t, r);
  });
}
function e1e(e, t, r) {
  Qh.forEach(e.nodes(), function(n) {
    t.node(n).rank += r;
  });
}
var wo = Lt, t1e = U6, r1e = db.slack, n1e = db.longestPath, i1e = oi.alg.preorder, o1e = oi.alg.postorder, s1e = rn.simplify, a1e = ll;
ll.initLowLimValues = EA;
ll.initCutValues = SA;
ll.calcCutValue = H6;
ll.leaveEdge = z6;
ll.enterEdge = G6;
ll.exchangeEdges = K6;
function ll(e) {
  e = s1e(e), n1e(e);
  var t = t1e(e);
  EA(t), SA(t, e);
  for (var r, n; r = z6(t); )
    n = G6(t, e, r), K6(t, e, r, n);
}
function SA(e, t) {
  var r = o1e(e, e.nodes());
  r = r.slice(0, r.length - 1), wo.forEach(r, function(n) {
    l1e(e, t, n);
  });
}
function l1e(e, t, r) {
  var n = e.node(r), o = n.parent;
  e.edge(r, o).cutvalue = H6(e, t, r);
}
function H6(e, t, r) {
  var n = e.node(r), o = n.parent, s = !0, a = t.edge(r, o), l = 0;
  return a || (s = !1, a = t.edge(o, r)), l = a.weight, wo.forEach(t.nodeEdges(r), function(u) {
    var f = u.v === r, c = f ? u.w : u.v;
    if (c !== o) {
      var d = f === s, h = t.edge(u).weight;
      if (l += d ? h : -h, f1e(e, r, c)) {
        var p = e.edge(r, c).cutvalue;
        l += d ? -p : p;
      }
    }
  }), l;
}
function EA(e, t) {
  arguments.length < 2 && (t = e.nodes()[0]), V6(e, {}, 1, t);
}
function V6(e, t, r, n, o) {
  var s = r, a = e.node(n);
  return t[n] = !0, wo.forEach(e.neighbors(n), function(l) {
    wo.has(t, l) || (r = V6(e, t, r, l, n));
  }), a.low = s, a.lim = r++, o ? a.parent = o : delete a.parent, r;
}
function z6(e) {
  return wo.find(e.edges(), function(t) {
    return e.edge(t).cutvalue < 0;
  });
}
function G6(e, t, r) {
  var n = r.v, o = r.w;
  t.hasEdge(n, o) || (n = r.w, o = r.v);
  var s = e.node(n), a = e.node(o), l = s, u = !1;
  s.lim > a.lim && (l = a, u = !0);
  var f = wo.filter(t.edges(), function(c) {
    return u === IP(e, e.node(c.v), l) && u !== IP(e, e.node(c.w), l);
  });
  return wo.minBy(f, function(c) {
    return r1e(t, c);
  });
}
function K6(e, t, r, n) {
  var o = r.v, s = r.w;
  e.removeEdge(o, s), e.setEdge(n.v, n.w, {}), EA(e), SA(e, t), u1e(e, t);
}
function u1e(e, t) {
  var r = wo.find(e.nodes(), function(o) {
    return !t.node(o).parent;
  }), n = i1e(e, r);
  n = n.slice(1), wo.forEach(n, function(o) {
    var s = e.node(o).parent, a = t.edge(o, s), l = !1;
    a || (a = t.edge(s, o), l = !0), t.node(o).rank = t.node(s).rank + (l ? a.minlen : -a.minlen);
  });
}
function f1e(e, t, r) {
  return e.hasEdge(t, r);
}
function IP(e, t, r) {
  return r.low <= t.lim && t.lim <= r.lim;
}
var c1e = db, Y6 = c1e.longestPath, d1e = U6, h1e = a1e, p1e = g1e;
function g1e(e) {
  switch (e.graph().ranker) {
    case "network-simplex":
      MP(e);
      break;
    case "tight-tree":
      y1e(e);
      break;
    case "longest-path":
      b1e(e);
      break;
    default:
      MP(e);
  }
}
var b1e = Y6;
function y1e(e) {
  Y6(e), d1e(e);
}
function MP(e) {
  h1e(e);
}
var EE = Lt, v1e = m1e;
function m1e(e) {
  var t = w1e(e);
  EE.forEach(e.graph().dummyChains, function(r) {
    for (var n = e.node(r), o = n.edgeObj, s = _1e(e, t, o.v, o.w), a = s.path, l = s.lca, u = 0, f = a[u], c = !0; r !== o.w; ) {
      if (n = e.node(r), c) {
        for (; (f = a[u]) !== l && e.node(f).maxRank < n.rank; )
          u++;
        f === l && (c = !1);
      }
      if (!c) {
        for (; u < a.length - 1 && e.node(f = a[u + 1]).minRank <= n.rank; )
          u++;
        f = a[u];
      }
      e.setParent(r, f), r = e.successors(r)[0];
    }
  });
}
function _1e(e, t, r, n) {
  var o = [], s = [], a = Math.min(t[r].low, t[n].low), l = Math.max(t[r].lim, t[n].lim), u, f;
  u = r;
  do
    u = e.parent(u), o.push(u);
  while (u && (t[u].low > a || l > t[u].lim));
  for (f = u, u = n; (u = e.parent(u)) !== f; )
    s.push(u);
  return { path: o.concat(s.reverse()), lca: f };
}
function w1e(e) {
  var t = {}, r = 0;
  function n(o) {
    var s = r;
    EE.forEach(e.children(o), n), t[o] = { low: s, lim: r++ };
  }
  return EE.forEach(e.children(), n), t;
}
var to = Lt, xE = rn, S1e = {
  run: E1e,
  cleanup: A1e
};
function E1e(e) {
  var t = xE.addDummyNode(e, "root", {}, "_root"), r = x1e(e), n = to.max(to.values(r)) - 1, o = 2 * n + 1;
  e.graph().nestingRoot = t, to.forEach(e.edges(), function(a) {
    e.edge(a).minlen *= o;
  });
  var s = R1e(e) + 1;
  to.forEach(e.children(), function(a) {
    X6(e, t, o, s, n, r, a);
  }), e.graph().nodeRankFactor = o;
}
function X6(e, t, r, n, o, s, a) {
  var l = e.children(a);
  if (!l.length) {
    a !== t && e.setEdge(t, a, { weight: 0, minlen: r });
    return;
  }
  var u = xE.addBorderNode(e, "_bt"), f = xE.addBorderNode(e, "_bb"), c = e.node(a);
  e.setParent(u, a), c.borderTop = u, e.setParent(f, a), c.borderBottom = f, to.forEach(l, function(d) {
    X6(e, t, r, n, o, s, d);
    var h = e.node(d), p = h.borderTop ? h.borderTop : d, v = h.borderBottom ? h.borderBottom : d, y = h.borderTop ? n : 2 * n, w = p !== v ? 1 : o - s[a] + 1;
    e.setEdge(u, p, {
      weight: y,
      minlen: w,
      nestingEdge: !0
    }), e.setEdge(v, f, {
      weight: y,
      minlen: w,
      nestingEdge: !0
    });
  }), e.parent(a) || e.setEdge(t, u, { weight: 0, minlen: o + s[a] });
}
function x1e(e) {
  var t = {};
  function r(n, o) {
    var s = e.children(n);
    s && s.length && to.forEach(s, function(a) {
      r(a, o + 1);
    }), t[n] = o;
  }
  return to.forEach(e.children(), function(n) {
    r(n, 1);
  }), t;
}
function R1e(e) {
  return to.reduce(e.edges(), function(t, r) {
    return t + e.edge(r).weight;
  }, 0);
}
function A1e(e) {
  var t = e.graph();
  e.removeNode(t.nestingRoot), delete t.nestingRoot, to.forEach(e.edges(), function(r) {
    var n = e.edge(r);
    n.nestingEdge && e.removeEdge(r);
  });
}
var s1 = Lt, T1e = rn, $1e = N1e;
function N1e(e) {
  function t(r) {
    var n = e.children(r), o = e.node(r);
    if (n.length && s1.forEach(n, t), s1.has(o, "minRank")) {
      o.borderLeft = [], o.borderRight = [];
      for (var s = o.minRank, a = o.maxRank + 1; s < a; ++s)
        OP(e, "borderLeft", "_bl", r, o, s), OP(e, "borderRight", "_br", r, o, s);
    }
  }
  s1.forEach(e.children(), t);
}
function OP(e, t, r, n, o, s) {
  var a = { width: 0, height: 0, rank: s, borderType: t }, l = o[t][s - 1], u = T1e.addDummyNode(e, "border", a, r);
  o[t][s] = u, e.setParent(u, n), l && e.setEdge(l, u, { weight: 1 });
}
var yi = Lt, k1e = {
  adjust: C1e,
  undo: I1e
};
function C1e(e) {
  var t = e.graph().rankdir.toLowerCase();
  (t === "lr" || t === "rl") && J6(e);
}
function I1e(e) {
  var t = e.graph().rankdir.toLowerCase();
  (t === "bt" || t === "rl") && M1e(e), (t === "lr" || t === "rl") && (O1e(e), J6(e));
}
function J6(e) {
  yi.forEach(e.nodes(), function(t) {
    LP(e.node(t));
  }), yi.forEach(e.edges(), function(t) {
    LP(e.edge(t));
  });
}
function LP(e) {
  var t = e.width;
  e.width = e.height, e.height = t;
}
function M1e(e) {
  yi.forEach(e.nodes(), function(t) {
    a1(e.node(t));
  }), yi.forEach(e.edges(), function(t) {
    var r = e.edge(t);
    yi.forEach(r.points, a1), yi.has(r, "y") && a1(r);
  });
}
function a1(e) {
  e.y = -e.y;
}
function O1e(e) {
  yi.forEach(e.nodes(), function(t) {
    l1(e.node(t));
  }), yi.forEach(e.edges(), function(t) {
    var r = e.edge(t);
    yi.forEach(r.points, l1), yi.has(r, "x") && l1(r);
  });
}
function l1(e) {
  var t = e.x;
  e.x = e.y, e.y = t;
}
var Gi = Lt, L1e = P1e;
function P1e(e) {
  var t = {}, r = Gi.filter(e.nodes(), function(l) {
    return !e.children(l).length;
  }), n = Gi.max(Gi.map(r, function(l) {
    return e.node(l).rank;
  })), o = Gi.map(Gi.range(n + 1), function() {
    return [];
  });
  function s(l) {
    if (!Gi.has(t, l)) {
      t[l] = !0;
      var u = e.node(l);
      o[u.rank].push(l), Gi.forEach(e.successors(l), s);
    }
  }
  var a = Gi.sortBy(r, function(l) {
    return e.node(l).rank;
  });
  return Gi.forEach(a, s), o;
}
var Lo = Lt, D1e = F1e;
function F1e(e, t) {
  for (var r = 0, n = 1; n < t.length; ++n)
    r += j1e(e, t[n - 1], t[n]);
  return r;
}
function j1e(e, t, r) {
  for (var n = Lo.zipObject(
    r,
    Lo.map(r, function(f, c) {
      return c;
    })
  ), o = Lo.flatten(Lo.map(t, function(f) {
    return Lo.sortBy(Lo.map(e.outEdges(f), function(c) {
      return { pos: n[c.w], weight: e.edge(c).weight };
    }), "pos");
  }), !0), s = 1; s < r.length; )
    s <<= 1;
  var a = 2 * s - 1;
  s -= 1;
  var l = Lo.map(new Array(a), function() {
    return 0;
  }), u = 0;
  return Lo.forEach(o.forEach(function(f) {
    var c = f.pos + s;
    l[c] += f.weight;
    for (var d = 0; c > 0; )
      c % 2 && (d += l[c + 1]), c = c - 1 >> 1, l[c] += f.weight;
    u += f.weight * d;
  })), u;
}
var PP = Lt, B1e = q1e;
function q1e(e, t) {
  return PP.map(t, function(r) {
    var n = e.inEdges(r);
    if (n.length) {
      var o = PP.reduce(n, function(s, a) {
        var l = e.edge(a), u = e.node(a.v);
        return {
          sum: s.sum + l.weight * u.order,
          weight: s.weight + l.weight
        };
      }, { sum: 0, weight: 0 });
      return {
        v: r,
        barycenter: o.sum / o.weight,
        weight: o.weight
      };
    } else
      return { v: r };
  });
}
var fn = Lt, W1e = U1e;
function U1e(e, t) {
  var r = {};
  fn.forEach(e, function(o, s) {
    var a = r[o.v] = {
      indegree: 0,
      in: [],
      out: [],
      vs: [o.v],
      i: s
    };
    fn.isUndefined(o.barycenter) || (a.barycenter = o.barycenter, a.weight = o.weight);
  }), fn.forEach(t.edges(), function(o) {
    var s = r[o.v], a = r[o.w];
    !fn.isUndefined(s) && !fn.isUndefined(a) && (a.indegree++, s.out.push(r[o.w]));
  });
  var n = fn.filter(r, function(o) {
    return !o.indegree;
  });
  return H1e(n);
}
function H1e(e) {
  var t = [];
  function r(s) {
    return function(a) {
      a.merged || (fn.isUndefined(a.barycenter) || fn.isUndefined(s.barycenter) || a.barycenter >= s.barycenter) && V1e(s, a);
    };
  }
  function n(s) {
    return function(a) {
      a.in.push(s), --a.indegree === 0 && e.push(a);
    };
  }
  for (; e.length; ) {
    var o = e.pop();
    t.push(o), fn.forEach(o.in.reverse(), r(o)), fn.forEach(o.out, n(o));
  }
  return fn.map(
    fn.filter(t, function(s) {
      return !s.merged;
    }),
    function(s) {
      return fn.pick(s, ["vs", "i", "barycenter", "weight"]);
    }
  );
}
function V1e(e, t) {
  var r = 0, n = 0;
  e.weight && (r += e.barycenter * e.weight, n += e.weight), t.weight && (r += t.barycenter * t.weight, n += t.weight), e.vs = t.vs.concat(e.vs), e.barycenter = r / n, e.weight = n, e.i = Math.min(t.i, e.i), t.merged = !0;
}
var cf = Lt, z1e = rn, G1e = K1e;
function K1e(e, t) {
  var r = z1e.partition(e, function(c) {
    return cf.has(c, "barycenter");
  }), n = r.lhs, o = cf.sortBy(r.rhs, function(c) {
    return -c.i;
  }), s = [], a = 0, l = 0, u = 0;
  n.sort(Y1e(!!t)), u = DP(s, o, u), cf.forEach(n, function(c) {
    u += c.vs.length, s.push(c.vs), a += c.barycenter * c.weight, l += c.weight, u = DP(s, o, u);
  });
  var f = { vs: cf.flatten(s, !0) };
  return l && (f.barycenter = a / l, f.weight = l), f;
}
function DP(e, t, r) {
  for (var n; t.length && (n = cf.last(t)).i <= r; )
    t.pop(), e.push(n.vs), r++;
  return r;
}
function Y1e(e) {
  return function(t, r) {
    return t.barycenter < r.barycenter ? -1 : t.barycenter > r.barycenter ? 1 : e ? r.i - t.i : t.i - r.i;
  };
}
var Ko = Lt, X1e = B1e, J1e = W1e, Q1e = G1e, Z1e = Q6;
function Q6(e, t, r, n) {
  var o = e.children(t), s = e.node(t), a = s ? s.borderLeft : void 0, l = s ? s.borderRight : void 0, u = {};
  a && (o = Ko.filter(o, function(v) {
    return v !== a && v !== l;
  }));
  var f = X1e(e, o);
  Ko.forEach(f, function(v) {
    if (e.children(v.v).length) {
      var y = Q6(e, v.v, r, n);
      u[v.v] = y, Ko.has(y, "barycenter") && tSe(v, y);
    }
  });
  var c = J1e(f, r);
  eSe(c, u);
  var d = Q1e(c, n);
  if (a && (d.vs = Ko.flatten([a, d.vs, l], !0), e.predecessors(a).length)) {
    var h = e.node(e.predecessors(a)[0]), p = e.node(e.predecessors(l)[0]);
    Ko.has(d, "barycenter") || (d.barycenter = 0, d.weight = 0), d.barycenter = (d.barycenter * d.weight + h.order + p.order) / (d.weight + 2), d.weight += 2;
  }
  return d;
}
function eSe(e, t) {
  Ko.forEach(e, function(r) {
    r.vs = Ko.flatten(r.vs.map(function(n) {
      return t[n] ? t[n].vs : n;
    }), !0);
  });
}
function tSe(e, t) {
  Ko.isUndefined(e.barycenter) ? (e.barycenter = t.barycenter, e.weight = t.weight) : (e.barycenter = (e.barycenter * e.weight + t.barycenter * t.weight) / (e.weight + t.weight), e.weight += t.weight);
}
var df = Lt, rSe = oi.Graph, nSe = iSe;
function iSe(e, t, r) {
  var n = oSe(e), o = new rSe({ compound: !0 }).setGraph({ root: n }).setDefaultNodeLabel(function(s) {
    return e.node(s);
  });
  return df.forEach(e.nodes(), function(s) {
    var a = e.node(s), l = e.parent(s);
    (a.rank === t || a.minRank <= t && t <= a.maxRank) && (o.setNode(s), o.setParent(s, l || n), df.forEach(e[r](s), function(u) {
      var f = u.v === s ? u.w : u.v, c = o.edge(f, s), d = df.isUndefined(c) ? 0 : c.weight;
      o.setEdge(f, s, { weight: e.edge(u).weight + d });
    }), df.has(a, "minRank") && o.setNode(s, {
      borderLeft: a.borderLeft[t],
      borderRight: a.borderRight[t]
    }));
  }), o;
}
function oSe(e) {
  for (var t; e.hasNode(t = df.uniqueId("_root")); )
    ;
  return t;
}
var sSe = Lt, aSe = lSe;
function lSe(e, t, r) {
  var n = {}, o;
  sSe.forEach(r, function(s) {
    for (var a = e.parent(s), l, u; a; ) {
      if (l = e.parent(a), l ? (u = n[l], n[l] = a) : (u = o, o = a), u && u !== a) {
        t.setEdge(u, a);
        return;
      }
      a = l;
    }
  });
}
var ns = Lt, uSe = L1e, fSe = D1e, cSe = Z1e, dSe = nSe, hSe = aSe, pSe = oi.Graph, FP = rn, gSe = bSe;
function bSe(e) {
  var t = FP.maxRank(e), r = jP(e, ns.range(1, t + 1), "inEdges"), n = jP(e, ns.range(t - 1, -1, -1), "outEdges"), o = uSe(e);
  BP(e, o);
  for (var s = Number.POSITIVE_INFINITY, a, l = 0, u = 0; u < 4; ++l, ++u) {
    ySe(l % 2 ? r : n, l % 4 >= 2), o = FP.buildLayerMatrix(e);
    var f = fSe(e, o);
    f < s && (u = 0, a = ns.cloneDeep(o), s = f);
  }
  BP(e, a);
}
function jP(e, t, r) {
  return ns.map(t, function(n) {
    return dSe(e, n, r);
  });
}
function ySe(e, t) {
  var r = new pSe();
  ns.forEach(e, function(n) {
    var o = n.graph().root, s = cSe(n, o, r, t);
    ns.forEach(s.vs, function(a, l) {
      n.node(a).order = l;
    }), hSe(n, r, s.vs);
  });
}
function BP(e, t) {
  ns.forEach(t, function(r) {
    ns.forEach(r, function(n, o) {
      e.node(n).order = o;
    });
  });
}
var tt = Lt, vSe = oi.Graph, mSe = rn, _Se = {
  positionX: ESe,
  findType1Conflicts: Z6,
  findType2Conflicts: eW,
  addConflict: xA,
  hasConflict: tW,
  verticalAlignment: rW,
  horizontalCompaction: nW,
  alignCoordinates: oW,
  findSmallestWidthAlignment: iW,
  balance: sW
};
function Z6(e, t) {
  var r = {};
  function n(o, s) {
    var a = 0, l = 0, u = o.length, f = tt.last(s);
    return tt.forEach(s, function(c, d) {
      var h = wSe(e, c), p = h ? e.node(h).order : u;
      (h || c === f) && (tt.forEach(s.slice(l, d + 1), function(v) {
        tt.forEach(e.predecessors(v), function(y) {
          var w = e.node(y), S = w.order;
          (S < a || p < S) && !(w.dummy && e.node(v).dummy) && xA(r, y, v);
        });
      }), l = d + 1, a = p);
    }), s;
  }
  return tt.reduce(t, n), r;
}
function eW(e, t) {
  var r = {};
  function n(s, a, l, u, f) {
    var c;
    tt.forEach(tt.range(a, l), function(d) {
      c = s[d], e.node(c).dummy && tt.forEach(e.predecessors(c), function(h) {
        var p = e.node(h);
        p.dummy && (p.order < u || p.order > f) && xA(r, h, c);
      });
    });
  }
  function o(s, a) {
    var l = -1, u, f = 0;
    return tt.forEach(a, function(c, d) {
      if (e.node(c).dummy === "border") {
        var h = e.predecessors(c);
        h.length && (u = e.node(h[0]).order, n(a, f, d, l, u), f = d, l = u);
      }
      n(a, f, a.length, u, s.length);
    }), a;
  }
  return tt.reduce(t, o), r;
}
function wSe(e, t) {
  if (e.node(t).dummy)
    return tt.find(e.predecessors(t), function(r) {
      return e.node(r).dummy;
    });
}
function xA(e, t, r) {
  if (t > r) {
    var n = t;
    t = r, r = n;
  }
  var o = e[t];
  o || (e[t] = o = {}), o[r] = !0;
}
function tW(e, t, r) {
  if (t > r) {
    var n = t;
    t = r, r = n;
  }
  return tt.has(e[t], r);
}
function rW(e, t, r, n) {
  var o = {}, s = {}, a = {};
  return tt.forEach(t, function(l) {
    tt.forEach(l, function(u, f) {
      o[u] = u, s[u] = u, a[u] = f;
    });
  }), tt.forEach(t, function(l) {
    var u = -1;
    tt.forEach(l, function(f) {
      var c = n(f);
      if (c.length) {
        c = tt.sortBy(c, function(y) {
          return a[y];
        });
        for (var d = (c.length - 1) / 2, h = Math.floor(d), p = Math.ceil(d); h <= p; ++h) {
          var v = c[h];
          s[f] === f && u < a[v] && !tW(r, f, v) && (s[v] = f, s[f] = o[f] = o[v], u = a[v]);
        }
      }
    });
  }), { root: o, align: s };
}
function nW(e, t, r, n, o) {
  var s = {}, a = SSe(e, t, r, o), l = o ? "borderLeft" : "borderRight";
  function u(d, h) {
    for (var p = a.nodes(), v = p.pop(), y = {}; v; )
      y[v] ? d(v) : (y[v] = !0, p.push(v), p = p.concat(h(v))), v = p.pop();
  }
  function f(d) {
    s[d] = a.inEdges(d).reduce(function(h, p) {
      return Math.max(h, s[p.v] + a.edge(p));
    }, 0);
  }
  function c(d) {
    var h = a.outEdges(d).reduce(function(v, y) {
      return Math.min(v, s[y.w] - a.edge(y));
    }, Number.POSITIVE_INFINITY), p = e.node(d);
    h !== Number.POSITIVE_INFINITY && p.borderType !== l && (s[d] = Math.max(s[d], h));
  }
  return u(f, a.predecessors.bind(a)), u(c, a.successors.bind(a)), tt.forEach(n, function(d) {
    s[d] = s[r[d]];
  }), s;
}
function SSe(e, t, r, n) {
  var o = new vSe(), s = e.graph(), a = xSe(s.nodesep, s.edgesep, n);
  return tt.forEach(t, function(l) {
    var u;
    tt.forEach(l, function(f) {
      var c = r[f];
      if (o.setNode(c), u) {
        var d = r[u], h = o.edge(d, c);
        o.setEdge(d, c, Math.max(a(e, f, u), h || 0));
      }
      u = f;
    });
  }), o;
}
function iW(e, t) {
  return tt.minBy(tt.values(t), function(r) {
    var n = Number.NEGATIVE_INFINITY, o = Number.POSITIVE_INFINITY;
    return tt.forIn(r, function(s, a) {
      var l = RSe(e, a) / 2;
      n = Math.max(s + l, n), o = Math.min(s - l, o);
    }), n - o;
  });
}
function oW(e, t) {
  var r = tt.values(t), n = tt.min(r), o = tt.max(r);
  tt.forEach(["u", "d"], function(s) {
    tt.forEach(["l", "r"], function(a) {
      var l = s + a, u = e[l], f;
      if (u !== t) {
        var c = tt.values(u);
        f = a === "l" ? n - tt.min(c) : o - tt.max(c), f && (e[l] = tt.mapValues(u, function(d) {
          return d + f;
        }));
      }
    });
  });
}
function sW(e, t) {
  return tt.mapValues(e.ul, function(r, n) {
    if (t)
      return e[t.toLowerCase()][n];
    var o = tt.sortBy(tt.map(e, n));
    return (o[1] + o[2]) / 2;
  });
}
function ESe(e) {
  var t = mSe.buildLayerMatrix(e), r = tt.merge(
    Z6(e, t),
    eW(e, t)
  ), n = {}, o;
  tt.forEach(["u", "d"], function(a) {
    o = a === "u" ? t : tt.values(t).reverse(), tt.forEach(["l", "r"], function(l) {
      l === "r" && (o = tt.map(o, function(d) {
        return tt.values(d).reverse();
      }));
      var u = (a === "u" ? e.predecessors : e.successors).bind(e), f = rW(e, o, r, u), c = nW(
        e,
        o,
        f.root,
        f.align,
        l === "r"
      );
      l === "r" && (c = tt.mapValues(c, function(d) {
        return -d;
      })), n[a + l] = c;
    });
  });
  var s = iW(e, n);
  return oW(n, s), sW(n, e.graph().align);
}
function xSe(e, t, r) {
  return function(n, o, s) {
    var a = n.node(o), l = n.node(s), u = 0, f;
    if (u += a.width / 2, tt.has(a, "labelpos"))
      switch (a.labelpos.toLowerCase()) {
        case "l":
          f = -a.width / 2;
          break;
        case "r":
          f = a.width / 2;
          break;
      }
    if (f && (u += r ? f : -f), f = 0, u += (a.dummy ? t : e) / 2, u += (l.dummy ? t : e) / 2, u += l.width / 2, tt.has(l, "labelpos"))
      switch (l.labelpos.toLowerCase()) {
        case "l":
          f = l.width / 2;
          break;
        case "r":
          f = -l.width / 2;
          break;
      }
    return f && (u += r ? f : -f), f = 0, u;
  };
}
function RSe(e, t) {
  return e.node(t).width;
}
var hf = Lt, aW = rn, ASe = _Se.positionX, TSe = $Se;
function $Se(e) {
  e = aW.asNonCompoundGraph(e), NSe(e), hf.forEach(ASe(e), function(t, r) {
    e.node(r).x = t;
  });
}
function NSe(e) {
  var t = aW.buildLayerMatrix(e), r = e.graph().ranksep, n = 0;
  hf.forEach(t, function(o) {
    var s = hf.max(hf.map(o, function(a) {
      return e.node(a).height;
    }));
    hf.forEach(o, function(a) {
      e.node(a).y = n + s / 2;
    }), n += s + r;
  });
}
var st = Lt, qP = Twe, WP = Hwe, kSe = p1e, CSe = rn.normalizeRanks, ISe = v1e, MSe = rn.removeEmptyRanks, UP = S1e, OSe = $1e, HP = k1e, LSe = gSe, PSe = TSe, gs = rn, DSe = oi.Graph, FSe = jSe;
function jSe(e, t) {
  var r = t && t.debugTiming ? gs.time : gs.notime;
  r("layout", function() {
    var n = r("  buildLayoutGraph", function() {
      return XSe(e);
    });
    r("  runLayout", function() {
      BSe(n, r);
    }), r("  updateInputGraph", function() {
      qSe(e, n);
    });
  });
}
function BSe(e, t) {
  t("    makeSpaceForEdgeLabels", function() {
    JSe(e);
  }), t("    removeSelfEdges", function() {
    sEe(e);
  }), t("    acyclic", function() {
    qP.run(e);
  }), t("    nestingGraph.run", function() {
    UP.run(e);
  }), t("    rank", function() {
    kSe(gs.asNonCompoundGraph(e));
  }), t("    injectEdgeLabelProxies", function() {
    QSe(e);
  }), t("    removeEmptyRanks", function() {
    MSe(e);
  }), t("    nestingGraph.cleanup", function() {
    UP.cleanup(e);
  }), t("    normalizeRanks", function() {
    CSe(e);
  }), t("    assignRankMinMax", function() {
    ZSe(e);
  }), t("    removeEdgeLabelProxies", function() {
    eEe(e);
  }), t("    normalize.run", function() {
    WP.run(e);
  }), t("    parentDummyChains", function() {
    ISe(e);
  }), t("    addBorderSegments", function() {
    OSe(e);
  }), t("    order", function() {
    LSe(e);
  }), t("    insertSelfEdges", function() {
    aEe(e);
  }), t("    adjustCoordinateSystem", function() {
    HP.adjust(e);
  }), t("    position", function() {
    PSe(e);
  }), t("    positionSelfEdges", function() {
    lEe(e);
  }), t("    removeBorderNodes", function() {
    oEe(e);
  }), t("    normalize.undo", function() {
    WP.undo(e);
  }), t("    fixupEdgeLabelCoords", function() {
    nEe(e);
  }), t("    undoCoordinateSystem", function() {
    HP.undo(e);
  }), t("    translateGraph", function() {
    tEe(e);
  }), t("    assignNodeIntersects", function() {
    rEe(e);
  }), t("    reversePoints", function() {
    iEe(e);
  }), t("    acyclic.undo", function() {
    qP.undo(e);
  });
}
function qSe(e, t) {
  st.forEach(e.nodes(), function(r) {
    var n = e.node(r), o = t.node(r);
    n && (n.x = o.x, n.y = o.y, t.children(r).length && (n.width = o.width, n.height = o.height));
  }), st.forEach(e.edges(), function(r) {
    var n = e.edge(r), o = t.edge(r);
    n.points = o.points, st.has(o, "x") && (n.x = o.x, n.y = o.y);
  }), e.graph().width = t.graph().width, e.graph().height = t.graph().height;
}
var WSe = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"], USe = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" }, HSe = ["acyclicer", "ranker", "rankdir", "align"], VSe = ["width", "height"], zSe = { width: 0, height: 0 }, GSe = ["minlen", "weight", "width", "height", "labeloffset"], KSe = {
  minlen: 1,
  weight: 1,
  width: 0,
  height: 0,
  labeloffset: 10,
  labelpos: "r"
}, YSe = ["labelpos"];
function XSe(e) {
  var t = new DSe({ multigraph: !0, compound: !0 }), r = f1(e.graph());
  return t.setGraph(st.merge(
    {},
    USe,
    u1(r, WSe),
    st.pick(r, HSe)
  )), st.forEach(e.nodes(), function(n) {
    var o = f1(e.node(n));
    t.setNode(n, st.defaults(u1(o, VSe), zSe)), t.setParent(n, e.parent(n));
  }), st.forEach(e.edges(), function(n) {
    var o = f1(e.edge(n));
    t.setEdge(n, st.merge(
      {},
      KSe,
      u1(o, GSe),
      st.pick(o, YSe)
    ));
  }), t;
}
function JSe(e) {
  var t = e.graph();
  t.ranksep /= 2, st.forEach(e.edges(), function(r) {
    var n = e.edge(r);
    n.minlen *= 2, n.labelpos.toLowerCase() !== "c" && (t.rankdir === "TB" || t.rankdir === "BT" ? n.width += n.labeloffset : n.height += n.labeloffset);
  });
}
function QSe(e) {
  st.forEach(e.edges(), function(t) {
    var r = e.edge(t);
    if (r.width && r.height) {
      var n = e.node(t.v), o = e.node(t.w), s = { rank: (o.rank - n.rank) / 2 + n.rank, e: t };
      gs.addDummyNode(e, "edge-proxy", s, "_ep");
    }
  });
}
function ZSe(e) {
  var t = 0;
  st.forEach(e.nodes(), function(r) {
    var n = e.node(r);
    n.borderTop && (n.minRank = e.node(n.borderTop).rank, n.maxRank = e.node(n.borderBottom).rank, t = st.max(t, n.maxRank));
  }), e.graph().maxRank = t;
}
function eEe(e) {
  st.forEach(e.nodes(), function(t) {
    var r = e.node(t);
    r.dummy === "edge-proxy" && (e.edge(r.e).labelRank = r.rank, e.removeNode(t));
  });
}
function tEe(e) {
  var t = Number.POSITIVE_INFINITY, r = 0, n = Number.POSITIVE_INFINITY, o = 0, s = e.graph(), a = s.marginx || 0, l = s.marginy || 0;
  function u(f) {
    var c = f.x, d = f.y, h = f.width, p = f.height;
    t = Math.min(t, c - h / 2), r = Math.max(r, c + h / 2), n = Math.min(n, d - p / 2), o = Math.max(o, d + p / 2);
  }
  st.forEach(e.nodes(), function(f) {
    u(e.node(f));
  }), st.forEach(e.edges(), function(f) {
    var c = e.edge(f);
    st.has(c, "x") && u(c);
  }), t -= a, n -= l, st.forEach(e.nodes(), function(f) {
    var c = e.node(f);
    c.x -= t, c.y -= n;
  }), st.forEach(e.edges(), function(f) {
    var c = e.edge(f);
    st.forEach(c.points, function(d) {
      d.x -= t, d.y -= n;
    }), st.has(c, "x") && (c.x -= t), st.has(c, "y") && (c.y -= n);
  }), s.width = r - t + a, s.height = o - n + l;
}
function rEe(e) {
  st.forEach(e.edges(), function(t) {
    var r = e.edge(t), n = e.node(t.v), o = e.node(t.w), s, a;
    r.points ? (s = r.points[0], a = r.points[r.points.length - 1]) : (r.points = [], s = o, a = n), r.points.unshift(gs.intersectRect(n, s)), r.points.push(gs.intersectRect(o, a));
  });
}
function nEe(e) {
  st.forEach(e.edges(), function(t) {
    var r = e.edge(t);
    if (st.has(r, "x"))
      switch ((r.labelpos === "l" || r.labelpos === "r") && (r.width -= r.labeloffset), r.labelpos) {
        case "l":
          r.x -= r.width / 2 + r.labeloffset;
          break;
        case "r":
          r.x += r.width / 2 + r.labeloffset;
          break;
      }
  });
}
function iEe(e) {
  st.forEach(e.edges(), function(t) {
    var r = e.edge(t);
    r.reversed && r.points.reverse();
  });
}
function oEe(e) {
  st.forEach(e.nodes(), function(t) {
    if (e.children(t).length) {
      var r = e.node(t), n = e.node(r.borderTop), o = e.node(r.borderBottom), s = e.node(st.last(r.borderLeft)), a = e.node(st.last(r.borderRight));
      r.width = Math.abs(a.x - s.x), r.height = Math.abs(o.y - n.y), r.x = s.x + r.width / 2, r.y = n.y + r.height / 2;
    }
  }), st.forEach(e.nodes(), function(t) {
    e.node(t).dummy === "border" && e.removeNode(t);
  });
}
function sEe(e) {
  st.forEach(e.edges(), function(t) {
    if (t.v === t.w) {
      var r = e.node(t.v);
      r.selfEdges || (r.selfEdges = []), r.selfEdges.push({ e: t, label: e.edge(t) }), e.removeEdge(t);
    }
  });
}
function aEe(e) {
  var t = gs.buildLayerMatrix(e);
  st.forEach(t, function(r) {
    var n = 0;
    st.forEach(r, function(o, s) {
      var a = e.node(o);
      a.order = s + n, st.forEach(a.selfEdges, function(l) {
        gs.addDummyNode(e, "selfedge", {
          width: l.label.width,
          height: l.label.height,
          rank: a.rank,
          order: s + ++n,
          e: l.e,
          label: l.label
        }, "_se");
      }), delete a.selfEdges;
    });
  });
}
function lEe(e) {
  st.forEach(e.nodes(), function(t) {
    var r = e.node(t);
    if (r.dummy === "selfedge") {
      var n = e.node(r.e.v), o = n.x + n.width / 2, s = n.y, a = r.x - o, l = n.height / 2;
      e.setEdge(r.e, r.label), e.removeNode(t), r.label.points = [
        { x: o + 2 * a / 3, y: s - l },
        { x: o + 5 * a / 6, y: s - l },
        { x: o + a, y: s },
        { x: o + 5 * a / 6, y: s + l },
        { x: o + 2 * a / 3, y: s + l }
      ], r.label.x = r.x, r.label.y = r.y;
    }
  });
}
function u1(e, t) {
  return st.mapValues(st.pick(e, t), Number);
}
function f1(e) {
  var t = {};
  return st.forEach(e, function(r, n) {
    t[n.toLowerCase()] = r;
  }), t;
}
var Md = Lt, uEe = rn, fEe = oi.Graph, cEe = {
  debugOrdering: dEe
};
function dEe(e) {
  var t = uEe.buildLayerMatrix(e), r = new fEe({ compound: !0, multigraph: !0 }).setGraph({});
  return Md.forEach(e.nodes(), function(n) {
    r.setNode(n, { label: n }), r.setParent(n, "layer" + e.node(n).rank);
  }), Md.forEach(e.edges(), function(n) {
    r.setEdge(n.v, n.w, {}, n.name);
  }), Md.forEach(t, function(n, o) {
    var s = "layer" + o;
    r.setNode(s, { rank: "same" }), Md.reduce(n, function(a, l) {
      return r.setEdge(a, l, { style: "invis" }), l;
    });
  }), r;
}
var hEe = "0.8.5", pEe = {
  graphlib: oi,
  layout: FSe,
  debug: cEe,
  util: {
    time: rn.time,
    notime: rn.notime
  },
  version: hEe
};
const VP = /* @__PURE__ */ Tn(pEe), gEe = {
  name: "GraphLayout",
  props: {
    // List of objects with an `id` property
    nodes: { required: !0, type: Array },
    // List of objects with `label`, `source` and `target` properties
    links: { required: !0, type: Array },
    // List of currently highlighted links
    activeLinks: { required: !0, type: Array },
    // Adjust zoom level when nodes change
    autoZoom: { default: !0 },
    layoutCfg: {
      type: Object,
      /**
             rankdir: The direction in which the graph is laid out. Can be "TB" (top to bottom), "BT" (bottom to top), "LR" (left to right), or "RL" (right to left).
             align: Determines how the nodes are aligned within their rank. Can be "UL" (up and left), "UR" (up and right), "DL" (down and left), "DR" (down and right), or undefined.
             nodesep: The minimum distance between nodes on the same rank.
             ranksep: The minimum distance between ranks.
             marginx: The margin to be added to the left and right of the graph.
             marginy: The margin to be added to the top and bottom of the graph.
      
             */
      default: function() {
        return {
          rankdir: "RL",
          align: void 0,
          nodesep: 20,
          ranksep: 50,
          marginx: 10,
          marginy: 10
        };
      }
    }
  },
  emits: ["link-enter", "link-out"],
  mounted() {
    this.renderGraph();
  },
  watch: {
    nodes() {
      this.renderGraph();
    },
    layoutCfg: {
      handler: "onLayoutCfgChange",
      deep: !0
    }
  },
  methods: {
    onLayoutCfgChange() {
      this.renderGraph();
    },
    async renderGraph() {
      if (this.nodes.length === 0)
        return;
      await br();
      const e = this.$el, t = _n(e), r = _n(this.$refs.layout), n = this.nodes.map((E) => ({ ...E })), o = this.links.map((E) => ({ ...E })), s = mEe(r, n, o, this.layoutCfg), a = hve().nodes(n);
      a.force(
        "links",
        ave(o).id(({ id: E }) => E).strength(0)
      ).force(
        "posX",
        pve().strength(1).x((E) => s.nodes[E.id].x)
      ).force(
        "posY",
        gve().strength(1).y((E) => s.nodes[E.id].y)
      ).stop(), r.style("width", `${s.width}px`), r.style("height", `${s.height}px`);
      const l = e.clientWidth / s.width, u = e.clientHeight / s.height, f = Math.min(l, u, 1), c = Math.max(
        (e.clientWidth - s.width * f) / 2,
        0
      ), d = Math.max(
        (e.clientHeight - s.height * f) / 2,
        0
      ), h = Ive().scaleExtent([0.1, 1.2]).on("zoom", ({ transform: E }) => {
        r.style(
          "transform",
          `translate(${E.x}px, ${E.y}px) scale(${E.k})`
        ), r.style("transform-origin", "0 0");
      });
      t.call(h), _Ee(t, h), this.autoZoom && t.call(
        h.transform,
        Gg.translate(c, d).scale(f)
      );
      const p = (E) => this.links.find(
        ({ source: N, target: C }) => N === E.source.id && C === E.target.id
      ), v = r.select(".links").selectAll(".link").data(o).on("mouseover", (E, N) => {
        const C = p(N);
        this.$emit("link-enter", C);
      }).on("mouseout", (E, N) => {
        const C = p(N);
        this.$emit("link-out", C);
      }), y = r.select(".links").selectAll(".arrow-head").data(o).on("mouseover", (E, N) => {
        const C = p(N);
        this.$emit("link-enter", C);
      }).on("mouseout", (E, N) => {
        const C = p(N);
        this.$emit("link-out", C);
      }), w = () => bEe(
        x,
        v,
        t,
        y
      ), S = t.node(), x = r.selectAll(".node").data(n).call(yEe(a, w, S));
      for (let E = 0, N = Math.ceil(
        Math.log(a.alphaMin()) / Math.log(1 - a.alphaDecay())
      ); E < N; ++E)
        a.tick();
      w(), a.force("posX", null).force("posY", null);
    }
  }
};
function bEe(e, t, r, n) {
  const o = r.node(), s = nA(o).k;
  e.join().attr(
    "style",
    (f) => ((isNaN(f.x) || isNaN(f.y)) && (f.x = 300, f.y = 300), `left: ${f.x}px; top: ${f.y}px`)
  );
  const a = Rve().source((f) => lW(f, o, s)).target((f) => zP(f, o, s)).x(({ x: f }) => f).y(({ y: f }) => f), l = (f) => (zP(f, o, s), "M -10 -5 L 0 0 L -10 5 z"), u = (f) => {
    const c = a(f), d = c.split("C")[1].split(",").map((S) => new Number(S.trim()).valueOf()), h = c.split("C")[0].replace("M", "").split(",").map((S) => new Number(S.trim()).valueOf()), p = [d[0], d[1]], v = [d[2], d[3]], y = [d[4], d[5]], w = wEe(h, p, v, y);
    return `translate(${y[0]}, ${y[1]}) rotate(${w(0.95)})`;
  };
  t.attr("d", a), n.attr("d", l), n.attr("transform", u);
}
function yEe(e, t, r) {
  let n = 0, o = 0;
  function s(u, f) {
    u.active || e.alphaTarget(0.3).restart(), n = u.x, o = u.y, f.fx = f.x, f.fy = f.y;
  }
  function a(u, f) {
    const c = nA(r).k;
    f.fx = n + (u.x - n) / c, f.fy = o + (u.y - o) / c, t();
  }
  function l(u, f) {
    u.active || e.alphaTarget(0), f.fx = null, f.fy = null, t();
  }
  return mye().on("start", s).on("drag", a).on("end", l);
}
function lW(e, t, r) {
  const o = t.querySelector(`[data-id="${e.source.id}"]`), s = o.querySelector(
    `[data-id="${e.sourceProperty}"]`
  ), a = s ?? o, l = e.target.x > e.source.x ? a.clientWidth + 3 : -3, u = s ? s.getBoundingClientRect().y / r - o.getBoundingClientRect().y / r + s.clientHeight / 2 : o.clientHeight / 2;
  return {
    x: e.source.x + l,
    y: e.source.y + u
  };
}
function zP(e, t, r) {
  const n = t.querySelector(`[data-id="${e.target.id}"]`), o = lW(e, t, r);
  return vEe(
    o,
    e.target,
    n.clientWidth,
    n.clientHeight
  );
}
function GP(e, t, r) {
  return Math.max(t, Math.min(r, e));
}
function vEe(e, t, r, n) {
  const o = {
    x: t.x + r,
    y: t.y + n
  }, s = GP(e.x, t.x, o.x), a = GP(e.y, t.y, o.y), l = Math.abs(s - t.x), u = Math.abs(s - o.x), f = Math.abs(a - t.y), c = Math.abs(a - o.y), d = Math.min(l, u, f, c);
  return d === f ? { x: s, y: t.y } : d === c ? { x: s, y: o.y } : d === l ? { x: t.x, y: a } : { x: o.x, y: a };
}
function mEe(e, t, r, n) {
  const o = new VP.graphlib.Graph();
  return o.setGraph(n), o.setDefaultEdgeLabel(() => ({})), t.forEach((s) => {
    const a = e.select(`[data-id="${s.id}"]`), l = a.style("width").replace("px", ""), u = a.style("height").replace("px", "");
    o.setNode(s.id, { width: l, height: u });
  }), r.forEach(({ source: s, target: a }) => {
    o.setEdge(s, a);
  }), VP.layout(o), {
    width: o._label.width,
    height: o._label.height,
    nodes: o.nodes().reduce((s, a) => {
      const l = o.node(a);
      return {
        ...s,
        [a]: {
          id: a,
          x: l.x - l.width / 2,
          y: l.y - l.height / 2
        }
      };
    }, {})
  };
}
function _Ee(e, t) {
  _n("body").on("keydown", (r) => {
    if (r.target.localName !== "body")
      return;
    const n = 50, o = {
      ArrowUp: [0, n],
      ArrowRight: [-n, 0],
      ArrowDown: [0, -n],
      ArrowLeft: [n, 0]
    }[r.key];
    o && e.call(t.translateBy, ...o);
  });
}
function wEe(e, t, r, n) {
  return function(s) {
    const a = 3 * Math.pow(1 - s, 2) * (t[0] - e[0]) + 6 * (1 - s) * s * (r[0] - t[0]) + 3 * Math.pow(s, 2) * (n[0] - r[0]), l = 3 * Math.pow(1 - s, 2) * (t[1] - e[1]) + 6 * (1 - s) * s * (r[1] - t[1]) + 3 * Math.pow(s, 2) * (n[1] - r[1]);
    return Math.atan2(l, a) * (180 / Math.PI);
  };
}
const SEe = { class: "graph-layout" }, EEe = {
  ref: "layout",
  class: "layout"
}, xEe = ["data-id"], REe = { class: "links" }, AEe = /* @__PURE__ */ oe("defs", null, [
  /* @__PURE__ */ oe("marker", {
    id: "dot",
    viewBox: "0 0 100 100",
    refX: "50",
    refY: "50",
    markerUnits: "userSpaceOnUse",
    markerWidth: "6",
    markerHeight: "6",
    orient: "auto",
    class: "fill-gray-600 dark:fill-gray-100"
  }, [
    /* @__PURE__ */ oe("circle", {
      cx: "50",
      cy: "50",
      r: "50",
      class: "link-start"
    })
  ]),
  /* @__PURE__ */ oe("marker", {
    id: "dot-active",
    viewBox: "0 0 100 100",
    refX: "50",
    refY: "50",
    markerUnits: "userSpaceOnUse",
    markerWidth: "6",
    markerHeight: "6",
    orient: "auto",
    class: "fill-primary-300"
  }, [
    /* @__PURE__ */ oe("circle", {
      cx: "50",
      cy: "50",
      r: "50",
      class: "link-start"
    })
  ])
], -1);
function TEe(e, t, r, n, o, s) {
  return we(), $e("div", SEe, [
    oe("div", EEe, [
      (we(!0), $e(ut, null, gr(r.nodes, (a) => (we(), $e("div", {
        key: a.id,
        class: "node",
        "data-id": a.id
      }, [
        io(e.$slots, "node", { node: a }, () => [
          tn(" Missing slot ")
        ])
      ], 8, xEe))), 128)),
      (we(), $e("svg", REe, [
        AEe,
        (we(!0), $e(ut, null, gr(r.links, (a, l) => (we(), $e("g", {
          class: "link-container",
          key: l
        }, [
          oe("path", {
            class: lr(["link stroke-gray-700 dark:stroke-gray-100", { active: r.activeLinks.includes(a) }])
          }, [
            oe("title", null, gt(a.label), 1)
          ], 2),
          oe("path", {
            class: lr(["arrow-head fill-gray-600 dark:fill-gray-100", { active: r.activeLinks.includes(a) }])
          }, null, 2)
        ]))), 128))
      ]))
    ], 512),
    io(e.$slots, "default")
  ]);
}
const uW = /* @__PURE__ */ ni(gEe, [["render", TEe]]), $Ee = { class: "z-10 absolute bottom-2 right-2 text-sm text-gray-400" }, NEe = {
  key: 1,
  class: "flex-grow bg-light dark:bg-dark flex flex-col items-center justify-center"
}, kEe = /* @__PURE__ */ oe("p", { class: "pb-4" }, "No classes to show", -1), CEe = [
  kEe
], IEe = {
  name: "DataModelComponent"
}, MEe = /* @__PURE__ */ it({
  ...IEe,
  props: {
    datamodel: {}
  },
  emits: ["explore", "toggle-shape", "export"],
  setup(e, { emit: t }) {
    const r = e, n = Ne([]), o = Oe(() => r.datamodel.tables.filter(({ isShown: d }) => d)), s = {
      rankdir: "LR",
      align: "UR",
      nodesep: 40,
      ranksep: 500,
      marginx: 10,
      marginy: 10
    }, a = Oe(
      () => {
        const d = new Set(o.value.map(({ id: h }) => h));
        return o.value.flatMap((h) => h.properties.map((p) => ({ ...p, table: h }))).reduce((h, p) => (p.values.forEach((v) => {
          const y = p.table.id, w = v.id;
          d.has(w) && h.push({ source: y, target: w, sourceProperty: p.id, label: p.name });
        }), h), []);
      }
    );
    function l(d) {
      n.value = a.value.filter((h) => h.source === d.id);
    }
    function u(d, h) {
      n.value = a.value.filter((p) => p.source === d.id && p.sourceProperty === h.id);
    }
    function f() {
      n.value = [];
    }
    function c(d) {
      n.value = [d];
    }
    return (d, h) => o.value.length > 0 ? (we(), xt(De(uW), {
      key: 0,
      nodes: o.value,
      links: a.value,
      "active-links": n.value,
      layoutCfg: s,
      onLinkEnter: c,
      onLinkOut: f,
      class: "bg-light dark:bg-dark flex-grow"
    }, {
      node: Ge(({ node: p }) => [
        xe(Cge, {
          table: p,
          "active-links": n.value,
          onExplore: h[0] || (h[0] = (v) => d.$emit("explore", v)),
          onHide: h[1] || (h[1] = (v) => d.$emit("toggle-shape", v, !1)),
          onExport: h[2] || (h[2] = (v) => d.$emit("export", v)),
          onHoverTitle: l,
          onUnhoverTitle: f,
          onHoverProperty: u,
          onUnhoverProperty: f
        }, null, 8, ["table", "active-links"])
      ]),
      default: Ge(() => [
        io(d.$slots, "default"),
        jr(oe("p", $Ee, " introspected ", 512), [
          [Ea, d.datamodel.isIntrospected]
        ])
      ]),
      _: 3
    }, 8, ["nodes", "links", "active-links"])) : (we(), $e("div", NEe, CEe));
  }
}), OEe = { class: "font-bold" }, LEe = { class: "flex flex-nowrap" }, PEe = { class: "w-full" }, DEe = ["data-id", "onMouseenter", "onMouseleave"], FEe = { class: "border-b dark:border-gray-500 px-3 py-2 text-gray-800 dark:text-gray-50" }, jEe = { class: "border-b dark:border-gray-500 px-3 py-2" }, BEe = {
  name: "ResourceCard"
}, qEe = /* @__PURE__ */ it({
  ...BEe,
  props: {
    resource: {},
    activeLinks: {}
  },
  emits: ["hover-title", "unhover-title", "hover-property", "unhover-property"],
  setup(e, { emit: t }) {
    const r = e;
    function n(a) {
      a.stopPropagation();
    }
    const o = Oe(() => r.activeLinks.some((a) => a.target === r.resource.id));
    function s(a) {
      return r.activeLinks.some((l) => l.source === r.resource.id && l.sourceProperty === a.id);
    }
    return (a, l) => (we(), $e("div", {
      class: lr(["border dark:border-gray-500 rounded shadow-md bg-white dark:bg-gray-800 opacity-90 text-sm", { active: o.value }])
    }, [
      oe("header", {
        class: "bg-gray-100 dark:bg-gray-900 flex items-center gap-4 justify-between px-3 py-2",
        onMouseenter: l[0] || (l[0] = (u) => a.$emit("hover-title", a.resource)),
        onMouseleave: l[1] || (l[1] = (u) => a.$emit("unhover-title", a.resource))
      }, [
        oe("h3", OEe, [
          xe(Wr, {
            label: a.resource.id
          }, {
            default: Ge(() => [
              tn(gt(a.resource.name), 1)
            ]),
            _: 1
          }, 8, ["label"])
        ]),
        oe("span", LEe, [
          io(a.$slots, "actions", {}, void 0, !0)
        ])
      ], 32),
      oe("table", PEe, [
        (we(!0), $e(ut, null, gr(a.resource.properties, (u, f) => (we(), $e("tr", {
          key: f,
          "data-id": u.id,
          class: lr({ active: s(u) }),
          onMouseenter: (c) => a.$emit("hover-property", a.resource, u),
          onMouseleave: (c) => a.$emit("unhover-property", a.resource, u)
        }, [
          oe("th", FEe, [
            xe(Wr, {
              label: u.id
            }, {
              default: Ge(() => [
                oe("span", { onMousedown: n }, gt(u.name), 33)
              ]),
              _: 2
            }, 1032, ["label"])
          ]),
          oe("td", jEe, [
            (we(!0), $e(ut, null, gr(u.values, (c) => (we(), $e("div", {
              key: c.id
            }, [
              io(a.$slots, "property-value", { value: c }, () => [
                xe(Wr, {
                  label: c.id
                }, {
                  default: Ge(() => [
                    oe("span", { onMousedown: n }, gt(c.name), 33)
                  ]),
                  _: 2
                }, 1032, ["label"])
              ], !0)
            ]))), 128))
          ])
        ], 42, DEe))), 128))
      ])
    ], 2));
  }
}), WEe = /* @__PURE__ */ ni(qEe, [["__scopeId", "data-v-e05bd27a"]]), UEe = {
  key: 0,
  class: "has-text-grey"
}, HEe = {
  name: "SpexTerm"
}, RE = /* @__PURE__ */ it({
  ...HEe,
  props: {
    term: {}
  },
  setup(e) {
    const t = e, r = co.getInstance(), n = Ne(l(r, t.term)), o = u(r, t.term), s = Ne(t.term && t.term.language), a = Ne(o !== n.value ? o : "");
    function l(f, c) {
      return c && (c.termType === "NamedNode" ? f.shrink(c.value) : c.value);
    }
    function u(f, c) {
      if (c.termType === "Literal") {
        const d = c.datatype ? `^^${f.shrink(c.datatype.value)}` : "", h = c.language ? `@${c.language}` : "";
        return `${c.value}${d}${h}`;
      }
      return c.value;
    }
    return (f, c) => (we(), xt(Wr, { label: a.value }, {
      default: Ge(() => [
        tn(gt(n.value), 1),
        s.value ? (we(), $e("small", UEe, "@" + gt(s.value), 1)) : bt("", !0)
      ]),
      _: 1
    }, 8, ["label"]));
  }
}), VEe = {
  name: "TermExploreButton"
}, AE = /* @__PURE__ */ it({
  ...VEe,
  props: {
    term: {}
  },
  emits: ["explore-resource"],
  setup(e, { emit: t }) {
    const r = e, n = Oe(() => ["NamedNode", "BlankNode"].includes(r.term.termType)), o = Oe(
      () => ({ id: r.term.value, name: r.term.value, term: r.term })
    );
    return (s, a) => n.value ? (we(), xt(Wr, {
      key: 0,
      label: "Explore"
    }, {
      default: Ge(() => [
        oe("button", {
          class: "button is-white is-small",
          onClick: a[0] || (a[0] = (l) => s.$emit("explore-resource", o.value))
        }, [
          xe(De(YH), { class: "icon" })
        ])
      ]),
      _: 1
    })) : bt("", !0);
  }
});
/*!
  * vue-router v4.2.2
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */
var KP;
(function(e) {
  e.pop = "pop", e.push = "push";
})(KP || (KP = {}));
var YP;
(function(e) {
  e.back = "back", e.forward = "forward", e.unknown = "";
})(YP || (YP = {}));
Symbol(process.env.NODE_ENV !== "production" ? "navigation failure" : "");
var XP;
(function(e) {
  e[e.aborted = 4] = "aborted", e[e.cancelled = 8] = "cancelled", e[e.duplicated = 16] = "duplicated";
})(XP || (XP = {}));
Symbol(process.env.NODE_ENV !== "production" ? "router view location matched" : "");
Symbol(process.env.NODE_ENV !== "production" ? "router view depth" : "");
Symbol(process.env.NODE_ENV !== "production" ? "router" : "");
const zEe = Symbol(process.env.NODE_ENV !== "production" ? "route location" : "");
Symbol(process.env.NODE_ENV !== "production" ? "router view location" : "");
function GEe() {
  return vr(zEe);
}
const KEe = { class: "card h-full flex flex-col" }, YEe = { class: "card-header has-background-light" }, XEe = /* @__PURE__ */ oe("h3", { class: "card-header-title" }, " Resources Explorer ", -1), JEe = { class: "card-header-icon py-0 px-1" }, QEe = ["href"], ZEe = ["onClick"], exe = { class: "flex items-center" }, txe = {
  name: "ResourcesExplorer"
}, rxe = /* @__PURE__ */ it({
  ...txe,
  props: {
    resources: {}
  },
  emits: ["explore-resource", "unexplore-resource", "close"],
  setup(e, { emit: t }) {
    const r = e, n = GEe(), o = co.getInstance(), s = Oe(() => {
      const h = new Set(r.resources.map(({ id: p }) => p));
      return r.resources.filter((p) => p.properties).flatMap((p) => p.properties.map((v) => ({ ...v, resource: p }))).reduce((p, v) => (v.values.forEach((y) => {
        const w = v.resource.id, S = y.value;
        h.has(S) && p.push({ source: w, target: S, sourceProperty: v.id, label: v.name });
      }), p), []);
    }), a = Ne([]);
    function l(h) {
      a.value.push(h);
    }
    function u() {
      a.value = [];
    }
    function f(h) {
      a.value = s.value.filter((p) => p.source === h.id);
    }
    function c(h, p) {
      a.value = s.value.filter((v) => v.source === h.id && v.sourceProperty === p.id);
    }
    async function d() {
      r.resources.forEach(
        async (h) => {
          if (!h.isFetched)
            try {
              const v = { ...await o.fetchResource(h.id), isFetched: !0 };
              t("explore-resource", v);
            } catch {
              const v = { ...h, isFetched: !0 };
              t("explore-resource", v);
            }
        }
      );
    }
    return Dt(() => {
      d();
    }), yr(r.resources, d), Oe(() => n.params.uri), (h, p) => (we(), $e("div", KEe, [
      oe("div", YEe, [
        XEe,
        oe("p", JEe, [
          oe("button", {
            class: "button is-light",
            onClick: p[0] || (p[0] = (v) => h.$emit("close")),
            title: "Close"
          }, [
            xe(De(as), { class: "icon" })
          ])
        ])
      ]),
      xe(De(uW), {
        class: "card-content p-0",
        nodes: h.resources,
        links: s.value,
        "active-links": a.value,
        "auto-zoom": !1,
        onLinkEnter: l,
        onLinkOut: u
      }, {
        node: Ge(({ node: v }) => [
          xe(WEe, {
            resource: v,
            "active-links": a.value,
            onHoverTitle: f,
            onUnhoverTitle: u,
            onHoverProperty: c,
            onUnhoverProperty: u
          }, {
            actions: Ge(() => [
              xe(Wr, { label: "Open URI in new tab" }, {
                default: Ge(() => [
                  oe("a", {
                    href: v.id,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    class: "button is-light"
                  }, [
                    xe(De(qH), { class: "icon" })
                  ], 8, QEe)
                ]),
                _: 2
              }, 1024),
              xe(Wr, { label: "Hide" }, {
                default: Ge(() => [
                  oe("button", {
                    class: "button is-light",
                    onClick: (y) => h.$emit("unexplore-resource", v)
                  }, [
                    xe(De(h3), { class: "icon" })
                  ], 8, ZEe)
                ]),
                _: 2
              }, 1024)
            ]),
            "property-value": Ge(({ value: y }) => [
              oe("div", exe, [
                xe(RE, {
                  term: y,
                  endpoint: De(o)
                }, null, 8, ["term", "endpoint"]),
                xe(AE, {
                  term: y,
                  onExploreResource: p[1] || (p[1] = (w) => h.$emit("explore-resource", w))
                }, null, 8, ["term"])
              ])
            ]),
            _: 2
          }, 1032, ["resource", "active-links"])
        ]),
        _: 1
      }, 8, ["nodes", "links", "active-links"])
    ]));
  }
}), nxe = {}, ixe = {
  class: "animate-spin h-8 w-8",
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 24 24"
}, oxe = /* @__PURE__ */ oe("circle", {
  class: "opacity-25",
  cx: "12",
  cy: "12",
  r: "10",
  stroke: "#ffb15e",
  "stroke-width": "4"
}, null, -1), sxe = /* @__PURE__ */ oe("path", {
  class: "opacity-75",
  fill: "#ffb15e",
  d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
}, null, -1), axe = [
  oxe,
  sxe
];
function lxe(e, t) {
  return we(), $e("svg", ixe, axe);
}
const RA = /* @__PURE__ */ ni(nxe, [["render", lxe]]), uxe = ["id", "value"], fxe = { key: 0 }, cxe = /* @__PURE__ */ oe("span", null, "Load more", -1), dxe = {
  name: "SelectGraph"
}, hxe = /* @__PURE__ */ it({
  ...dxe,
  props: {
    id: {},
    modelValue: {},
    graphs: {},
    loading: { type: Boolean },
    hasMoreGraphs: { type: Boolean }
  },
  emits: ["update:modelValue", "fetch-more"],
  setup(e, { emit: t }) {
    return (r, n) => (we(), xt(De(Tpe), {
      as: "div",
      class: "control",
      modelValue: r.modelValue,
      "onUpdate:modelValue": n[2] || (n[2] = (o) => r.$emit("update:modelValue", o))
    }, {
      default: Ge(() => [
        xe(De($pe), {
          as: "div",
          class: "relative"
        }, {
          default: Ge(() => [
            oe("input", {
              id: r.id,
              placeholder: "DEFAULT",
              class: "input",
              value: r.modelValue,
              onInput: n[0] || (n[0] = (o) => r.$emit("update:modelValue", o.target.value)),
              autocomplete: "off"
            }, null, 40, uxe),
            jr(xe(RA, { class: "absolute top-2 right-2" }, null, 512), [
              [Ea, r.loading]
            ])
          ]),
          _: 1
        }),
        xe(vp, {
          "enter-active-class": "transition duration-100 ease-out",
          "enter-from-class": "scale-95 opacity-0",
          "enter-to-class": "scale-100 opacity-100",
          "leave-active-class": "transition duration-75 ease-out",
          "leave-from-class": "scale-100 opacity-100",
          "leave-to-class": "scale-95 opacity-0"
        }, {
          default: Ge(() => [
            xe(De(Npe), {
              as: "ul",
              class: "bg-white border border-gray-100 shadow-md absolute w-full z-10 max-h-64 overflow-y-scroll"
            }, {
              default: Ge(() => [
                (we(!0), $e(ut, null, gr(r.graphs, (o) => (we(), xt(De(kpe), {
                  as: "template",
                  key: o,
                  value: o
                }, {
                  default: Ge(({ active: s, selected: a }) => [
                    oe("li", {
                      class: lr(["px-2 py-2", {
                        "bg-gray-100": s,
                        "bg-primary-300": a
                      }])
                    }, gt(o), 3)
                  ]),
                  _: 2
                }, 1032, ["value"]))), 128)),
                r.hasMoreGraphs ? (we(), $e("li", fxe, [
                  oe("button", {
                    type: "button",
                    class: lr(["button is-light justify-start w-full", { "is-loading": r.loading }]),
                    onClick: n[1] || (n[1] = (o) => r.$emit("fetch-more"))
                  }, [
                    xe(De(BH), { class: "icon" }),
                    cxe
                  ], 2)
                ])) : bt("", !0)
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["modelValue"]));
  }
}), pxe = {
  name: "SpexSwitch"
}, AA = /* @__PURE__ */ it({
  ...pxe,
  props: {
    modelValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    return (r, n) => (we(), xt(De(Upe), {
      modelValue: r.modelValue,
      "onUpdate:modelValue": n[0] || (n[0] = (o) => r.$emit("update:modelValue", o)),
      class: lr([r.modelValue ? "bg-primary-400" : "bg-gray-300", "relative inline-flex shrink-0 items-center h-6 w-10 rounded-full shadow-inner"])
    }, {
      default: Ge(() => [
        oe("span", {
          class: lr([r.modelValue ? "translate-x-5" : "translate-x-1", "inline-block w-4 h-4 bg-white rounded-full shadow transition duration-200 ease-in-out"])
        }, null, 2)
      ]),
      _: 1
    }, 8, ["modelValue", "class"]));
  }
}), gxe = { class: "card is-shadowless h-full overflow-y-auto" }, bxe = { class: "card-header has-background-light" }, yxe = /* @__PURE__ */ oe("h3", { class: "card-header-title" }, "Options", -1), vxe = { class: "card-header-icon py-0 px-1" }, mxe = { class: "card-content" }, _xe = { class: "field" }, wxe = /* @__PURE__ */ oe("label", {
  class: "label",
  for: "endpoint"
}, "Sparql Endpoint URL", -1), Sxe = { class: "control has-icons-right" }, Exe = {
  key: 0,
  class: "icon is-small is-right",
  CheckIcon: ""
}, xxe = { class: "field" }, Rxe = /* @__PURE__ */ oe("label", {
  class: "label",
  for: "username"
}, "Username", -1), Axe = { class: "field" }, Txe = /* @__PURE__ */ oe("label", {
  class: "label",
  for: "password"
}, "Password", -1), $xe = /* @__PURE__ */ oe("label", {
  class: "label",
  for: "graph"
}, "Named Graph", -1), Nxe = { class: "field" }, kxe = {
  key: 0,
  class: "message is-danger"
}, Cxe = { class: "message-body" }, Ixe = { class: "field" }, Mxe = /* @__PURE__ */ oe("label", { class: "label" }, "Custom prefixes", -1), Oxe = { class: "flex flex-col gap-1" }, Lxe = ["onUpdate:modelValue"], Pxe = ["onUpdate:modelValue"], Dxe = ["onClick"], Fxe = {
  key: 0,
  class: "has-text-grey"
}, jxe = { class: "field" }, Bxe = { class: "label flex items-center gap-2" }, qxe = /* @__PURE__ */ oe("p", { class: "help" }, [
  /* @__PURE__ */ tn(" By default, the explorer will use the endpoint schema provided at "),
  /* @__PURE__ */ oe("code", null, "endpoint/.well-known/void"),
  /* @__PURE__ */ tn(" (if any). Use this option to force an introspection. ")
], -1), Wxe = {
  name: "SettingsPane"
}, Uxe = /* @__PURE__ */ it({
  ...Wxe,
  props: {
    settings: {}
  },
  emits: ["settingsChanged", "close"],
  setup(e, { emit: t }) {
    const r = e, n = 10, o = Ne({
      sparqlEndpoint: r.settings.sparqlEndpoint,
      namedGraph: r.settings.namedGraph,
      prefixes: r.settings.prefixes,
      username: r.settings.username,
      password: r.settings.password,
      forceIntrospection: r.settings.forceIntrospection
    }), s = Ne(!1), a = Ne(!1);
    let l = null;
    r.settings.sparqlEndpoint && S();
    const u = Ne([]), f = Ne(!1), c = Ne(!1), d = Ne(null), h = Ne(0);
    Dt(async () => {
      r.settings.sparqlEndpoint !== null && await x();
    });
    function p(z) {
      z.preventDefault(), z.stopPropagation(), t("settingsChanged", o.value);
    }
    function v() {
      t("close");
    }
    function y(z) {
      o.value.namedGraph = null, S();
    }
    function w(z) {
      var $, G, I, W;
      (((($ = o.value.username) == null ? void 0 : $.length) ?? 0) > 0 && (((G = o.value.username) == null ? void 0 : G.length) ?? 0) > 0 || (((I = o.value.username) == null ? void 0 : I.length) ?? 0) === 0 && (((W = o.value.username) == null ? void 0 : W.length) ?? 0) === 0) && S();
    }
    async function S() {
      const z = co.getInstance(o.value);
      s.value = await z.canFetchOne(), a.value = !1, s.value && x();
    }
    async function x() {
      c.value = !0, l = co.getInstance(o.value), h.value = 0, u.value = await N() ?? [];
    }
    async function E() {
      const z = await N() ?? [];
      u.value = u.value.concat(z);
    }
    async function N() {
      c.value = !0, d.value = "";
      try {
        const z = { offset: h.value, limit: n }, $ = await (l == null ? void 0 : l.fetchGraphs(z));
        return h.value = h.value + n, f.value = (($ == null ? void 0 : $.length) ?? 0) >= n, $;
      } catch (z) {
        return d.value = z.toString(), [];
      } finally {
        c.value = !1;
      }
    }
    function C() {
      o.value.prefixes.push({ prefix: "", namespace: "" });
    }
    function j(z) {
      o.value.prefixes.splice(z, 1);
    }
    function J() {
      a.value = !0, l = null;
    }
    return (z, $) => (we(), $e("div", gxe, [
      oe("div", bxe, [
        yxe,
        oe("p", vxe, [
          oe("button", {
            type: "button",
            class: "button is-light",
            onClick: v,
            title: "Close"
          }, [
            xe(De(as), { class: "icon" })
          ])
        ])
      ]),
      oe("form", mxe, [
        oe("div", _xe, [
          wxe,
          oe("p", Sxe, [
            jr(oe("input", {
              id: "endpoint",
              type: "text",
              class: "input",
              "onUpdate:modelValue": $[0] || ($[0] = (G) => o.value.sparqlEndpoint = G),
              onBlur: y,
              onFocusin: J
            }, null, 544), [
              [Vo, o.value.sparqlEndpoint]
            ]),
            a.value ? bt("", !0) : (we(), $e("span", Exe, [
              s.value ? (we(), xt(De(HH), {
                key: 0,
                class: "icon",
                style: { color: "green" }
              })) : bt("", !0),
              s.value ? bt("", !0) : (we(), xt(De(as), {
                key: 1,
                class: "icon",
                style: { color: "red" }
              }))
            ]))
          ])
        ]),
        oe("div", xxe, [
          Rxe,
          jr(oe("input", {
            id: "username",
            type: "text",
            class: "input",
            "onUpdate:modelValue": $[1] || ($[1] = (G) => o.value.username = G),
            onBlur: w
          }, null, 544), [
            [Vo, o.value.username]
          ])
        ]),
        oe("div", Axe, [
          Txe,
          jr(oe("input", {
            id: "password",
            type: "password",
            class: "input",
            "onUpdate:modelValue": $[2] || ($[2] = (G) => o.value.password = G),
            onBlur: w
          }, null, 544), [
            [Vo, o.value.password]
          ])
        ]),
        oe("div", {
          class: lr(["field", d.value ? "is-danger" : ""])
        }, [
          $xe,
          xe(hxe, {
            id: "graph",
            modelValue: o.value.namedGraph,
            "onUpdate:modelValue": $[3] || ($[3] = (G) => o.value.namedGraph = G),
            graphs: u.value,
            loading: c.value,
            "has-more-graphs": f.value,
            onFetchMore: E
          }, null, 8, ["modelValue", "graphs", "loading", "has-more-graphs"])
        ], 2),
        oe("div", Nxe, [
          d.value ? (we(), $e("div", kxe, [
            oe("div", Cxe, gt(d.value), 1)
          ])) : bt("", !0)
        ]),
        oe("div", Ixe, [
          Mxe,
          oe("div", Oxe, [
            (we(!0), $e(ut, null, gr(o.value.prefixes, (G, I) => (we(), $e("div", {
              key: I,
              class: "flex gap-1"
            }, [
              jr(oe("input", {
                type: "text",
                "onUpdate:modelValue": (W) => G.prefix = W,
                placeholder: "schema",
                class: "input w-24",
                required: ""
              }, null, 8, Lxe), [
                [Vo, G.prefix]
              ]),
              jr(oe("input", {
                type: "text",
                "onUpdate:modelValue": (W) => G.namespace = W,
                placeholder: "http://schema.org/",
                class: "input flex-grow",
                required: ""
              }, null, 8, Pxe), [
                [Vo, G.namespace]
              ]),
              oe("button", {
                type: "button",
                class: "button is-white",
                title: "Remove prefix",
                onClick: (W) => j(I)
              }, [
                xe(De(XH), { class: "icon" })
              ], 8, Dxe)
            ]))), 128)),
            o.value.prefixes.length === 0 ? (we(), $e("p", Fxe, " No custom prefix ")) : bt("", !0),
            oe("p", null, [
              oe("button", {
                type: "button",
                class: "button is-white",
                title: "Add prefix",
                onClick: C
              }, [
                xe(De(JH), { class: "icon" })
              ])
            ])
          ])
        ]),
        oe("div", jxe, [
          oe("label", Bxe, [
            xe(AA, {
              modelValue: o.value.forceIntrospection,
              "onUpdate:modelValue": $[4] || ($[4] = (G) => o.value.forceIntrospection = G)
            }, null, 8, ["modelValue"]),
            tn(" Force introspection ")
          ]),
          qxe
        ]),
        oe("div", { class: "field" }, [
          oe("button", {
            class: "button is-primary",
            type: "submit",
            onClick: p
          }, "Load")
        ])
      ])
    ]));
  }
}), Hxe = { class: "card h-full flex flex-col" }, Vxe = { class: "card-header has-background-light" }, zxe = { class: "card-header-title" }, Gxe = { key: 0 }, Kxe = { key: 1 }, Yxe = { class: "card-header-icon py-0 px-1" }, Xxe = { class: "card-content h-full p-0 overflow-auto flex flex-col" }, Jxe = {
  key: 0,
  class: "table is-fullwidth mb-0"
}, Qxe = /* @__PURE__ */ oe("th", null, "URI", -1), Zxe = { class: "border-b" }, eRe = { class: "flex items-center" }, tRe = { class: "sticky bottom-0" }, rRe = { class: "bg-gray-50" }, nRe = ["colspan"], iRe = { class: "flex items-center gap-2" }, oRe = ["disabled"], sRe = {
  key: 1,
  class: "flex-grow flex justify-center items-center"
}, aRe = {
  key: 2,
  class: "message is-danger"
}, lRe = { class: "message-body" }, uRe = {
  name: "TableExplorer"
}, fRe = /* @__PURE__ */ it({
  ...uRe,
  props: {
    table: {},
    tables: {}
  },
  emits: ["close", "explore-resource"],
  setup(e, { emit: t }) {
    const r = e, n = co.getInstance(), o = Ne([]), s = Ne(null), a = Ne(!1), l = 10, u = Ne(1), f = async () => {
      if (o.value = [], s.value = null, !r.table)
        return;
      const d = (u.value - 1) * l, h = l;
      a.value = !0;
      try {
        n && (o.value = await n.fetchTableData(r.table, { offset: d, limit: h }));
      } catch (p) {
        s.value = p, console.error(p);
      } finally {
        a.value = !1;
      }
    };
    yr(() => r.table, (d, h) => {
      c(1);
    });
    const c = (d) => {
      u.value = d, f();
    };
    return Dt(() => {
      c(1);
    }), (d, h) => (we(), $e("div", Hxe, [
      oe("div", Vxe, [
        oe("h3", zxe, [
          d.table ? (we(), $e("span", Gxe, gt(d.table.name), 1)) : (we(), $e("span", Kxe, "No table selected"))
        ]),
        oe("p", Yxe, [
          oe("button", {
            class: "button is-light",
            onClick: h[0] || (h[0] = (p) => d.$emit("close")),
            title: "Close"
          }, [
            xe(De(as), { class: "icon" })
          ])
        ])
      ]),
      oe("div", Xxe, [
        d.table ? (we(), $e("table", Jxe, [
          oe("thead", null, [
            oe("tr", null, [
              Qxe,
              (we(!0), $e(ut, null, gr(d.table.properties, (p, v) => (we(), $e("th", { key: v }, gt(p.name), 1))), 128))
            ])
          ]),
          oe("tbody", Zxe, [
            (we(!0), $e(ut, null, gr(o.value, (p, v) => (we(), $e("tr", { key: v }, [
              oe("td", null, [
                oe("p", eRe, [
                  xe(RE, {
                    term: p.term,
                    endpoint: De(n)
                  }, null, 8, ["term", "endpoint"]),
                  xe(AE, {
                    term: p.term,
                    onExploreResource: h[1] || (h[1] = (y) => d.$emit("explore-resource", y))
                  }, null, 8, ["term"])
                ])
              ]),
              (we(!0), $e(ut, null, gr(d.table.properties, (y, w) => (we(), $e("td", { key: w }, [
                (we(!0), $e(ut, null, gr(p[y.id] || [], (S, x) => (we(), $e("p", {
                  class: "flex items-center",
                  key: x
                }, [
                  xe(RE, {
                    term: S,
                    endpoint: De(n)
                  }, null, 8, ["term", "endpoint"]),
                  xe(AE, {
                    term: S,
                    onExploreResource: h[2] || (h[2] = (E) => d.$emit("explore-resource", E))
                  }, null, 8, ["term"])
                ]))), 128))
              ]))), 128))
            ]))), 128))
          ]),
          jr(oe("tfoot", tRe, [
            oe("tr", rRe, [
              oe("td", {
                colspan: 1 + d.table.properties.length
              }, [
                oe("div", iRe, [
                  oe("button", {
                    class: "button px-2",
                    disabled: u.value === 1,
                    onClick: h[3] || (h[3] = (p) => c(u.value - 1))
                  }, [
                    xe(De(VH), { class: "w-5 h-5" })
                  ], 8, oRe),
                  oe("span", null, "Page " + gt(u.value), 1),
                  oe("button", {
                    class: "button px-2",
                    onClick: h[4] || (h[4] = (p) => c(u.value + 1))
                  }, [
                    xe(De(zH), { class: "w-5 h-5" })
                  ])
                ])
              ], 8, nRe)
            ])
          ], 512), [
            [Ea, !a.value]
          ])
        ])) : bt("", !0),
        a.value ? (we(), $e("div", sRe, [
          xe(RA)
        ])) : bt("", !0),
        s.value ? (we(), $e("div", aRe, [
          oe("div", lRe, " Error loading data: " + gt(s.value), 1)
        ])) : bt("", !0)
      ])
    ]));
  }
});
function cRe(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M12 6.042A8.967 8.967 0 006 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 016 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 016-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0018 18a8.967 8.967 0 00-6 2.292m0-14.25v14.25"
    })
  ]);
}
function dRe(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M19.5 8.25l-7.5 7.5-7.5-7.5"
    })
  ]);
}
function hRe(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M4.5 15.75l7.5-7.5 7.5 7.5"
    })
  ]);
}
function pRe(e, t) {
  return we(), $e("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    oe("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"
    })
  ]);
}
const gRe = { class: "panel-block is-justify-content-space-between" }, bRe = { style: { "flex-grow": "1", "overflow-x": "clip", "text-overflow": "ellipsis" } }, yRe = {
  style: { "flex-grow": "0" },
  class: "badge"
}, vRe = {
  name: "TableListItem"
}, mRe = /* @__PURE__ */ it({
  ...vRe,
  props: {
    table: {}
  },
  emits: ["toggle-table", "select-viewport"],
  setup(e, { emit: t }) {
    const r = e, n = Oe(() => {
      const s = r.table.count ?? 0;
      return s > 1e3 && s < 1e6 ? o(s / 1e3, 1) + "K" : s > 1e6 ? o(s / 1e6, 1) + "M" : `${s}`;
    });
    function o(s, a) {
      const l = Math.pow(10, a || 0);
      return Math.round(s * l) / l;
    }
    return (s, a) => (we(), $e("div", gRe, [
      oe("span", bRe, gt(s.table.name), 1),
      xe(Wr, { label: "Instances" }, {
        default: Ge(() => [
          oe("div", yRe, gt(n.value), 1)
        ]),
        _: 1
      }),
      xe(AA, {
        style: { "flex-grow": "0" },
        modelValue: s.table.isShown,
        "onUpdate:modelValue": a[0] || (a[0] = (l) => s.$emit("toggle-table", s.table, l))
      }, null, 8, ["modelValue"])
    ]));
  }
}), _Re = /* @__PURE__ */ ni(mRe, [["__scopeId", "data-v-f6057106"]]), wRe = { class: "card is-shadowless overflow-y-auto" }, SRe = { class: "card-header has-background-light" }, ERe = /* @__PURE__ */ oe("h3", { class: "card-header-title" }, "Classes", -1), xRe = { class: "card-header-icon py-0 px-1" }, RRe = { class: "card-content px-0 py-1" }, ARe = { class: "field m-0 px-2 py-2 border-b flex flex-wrap justify-end items-center gap-2" }, TRe = /* @__PURE__ */ oe("label", {
  class: "label m-0",
  for: "predefined-views"
}, "Predefined views", -1), $Re = { class: "select" }, NRe = /* @__PURE__ */ oe("option", { value: "" }, "-", -1), kRe = ["value"], CRe = { class: "panel-block is-justify-content-space-between" }, IRe = { style: { "flex-grow": "1", display: "flex", "flex-direction": "row", "align-items": "center" } }, MRe = {
  name: "TableList"
}, ORe = /* @__PURE__ */ it({
  ...MRe,
  props: {
    datamodel: {}
  },
  emits: ["toggle-table", "select-viewport", "close"],
  setup(e, { emit: t }) {
    const r = e, n = Ne(!0), o = Ne(!1), s = Ne(""), a = Ne(r.datamodel.tables);
    Dt(() => {
      a.value = a.value.sort((c, d) => (d.count ?? 0) - (c.count ?? 0));
    }), yr(s, (c, d) => {
      o.value ? a.value = r.datamodel.tables.filter((h) => h.name.toLocaleLowerCase().indexOf(c.toLocaleLowerCase()) > -1).sort((h, p) => (h.count ?? 0) - (p.count ?? 0)) : a.value = r.datamodel.tables.filter((h) => h.name.toLocaleLowerCase().indexOf(c.toLocaleLowerCase()) > -1).sort((h, p) => (p.count ?? 0) - (h.count ?? 0));
    }), yr(o, (c, d) => {
      c ? a.value = r.datamodel.tables.filter((h) => h.name.toLocaleLowerCase().indexOf(s.value.toLocaleLowerCase()) > -1).sort((h, p) => (h.count ?? 0) - (p.count ?? 0)) : a.value = r.datamodel.tables.filter((h) => h.name.toLocaleLowerCase().indexOf(s.value.toLocaleLowerCase()) > -1).sort((h, p) => (p.count ?? 0) - (h.count ?? 0));
    });
    const l = (c) => {
      const d = c.target.value, h = r.datamodel.viewports.find((p) => p.id === d) ?? null;
      t("select-viewport", h);
    };
    function u() {
      o.value = !o.value;
    }
    const f = (c) => {
      n.value = c, r.datamodel.tables.forEach((d) => {
        d.isShown = c;
      });
    };
    return (c, d) => (we(), $e("div", wRe, [
      oe("div", SRe, [
        ERe,
        oe("p", xRe, [
          oe("button", {
            class: "button is-light",
            onClick: d[0] || (d[0] = (h) => c.$emit("close"))
          }, [
            xe(De(as), { class: "icon" })
          ])
        ])
      ]),
      oe("div", RRe, [
        jr(oe("div", ARe, [
          TRe,
          oe("div", $Re, [
            oe("select", {
              id: "predefined-views",
              onInput: l
            }, [
              NRe,
              (we(!0), $e(ut, null, gr(c.datamodel.viewports, (h) => (we(), $e("option", {
                key: h.id,
                value: h.id
              }, gt(h.name), 9, kRe))), 128))
            ], 32)
          ])
        ], 512), [
          [Ea, c.datamodel.viewports.length > 0]
        ]),
        oe("ul", null, [
          oe("li", CRe, [
            oe("div", IRe, [
              xe(De(pRe), {
                class: "icon",
                style: { "margin-right": "5px" }
              }),
              jr(oe("input", {
                type: "text",
                class: "input",
                "onUpdate:modelValue": d[1] || (d[1] = (h) => s.value = h)
              }, null, 512), [
                [Vo, s.value]
              ])
            ]),
            oe("button", {
              onClick: u,
              style: { "flex-grow": "0", "margin-left": "5px", "margin-right": "5px", width: "35px" }
            }, [
              o.value ? (we(), xt(De(dRe), {
                key: 0,
                class: "icon"
              })) : bt("", !0),
              o.value ? bt("", !0) : (we(), xt(De(hRe), {
                key: 1,
                class: "icon"
              }))
            ]),
            xe(AA, {
              style: { "flex-grow": "0" },
              modelValue: n.value,
              "onUpdate:modelValue": f
            }, null, 8, ["modelValue"])
          ]),
          (we(!0), $e(ut, null, gr(a.value, (h) => (we(), xt(_Re, {
            key: h.id,
            table: h,
            onToggleTable: (p) => c.$emit("toggle-table", h, p)
          }, null, 8, ["table", "onToggleTable"]))), 128))
        ])
      ])
    ]));
  }
}), LRe = {
  name: "GitHubLogo"
}, PRe = {
  href: "https://github.com/zazuko/SPEX",
  target: "_blank",
  rel: "noopener noreferer",
  title: "Github repository"
}, DRe = /* @__PURE__ */ oe("svg", {
  class: "w-5 h-5 opacity-100 dark:fill-white hover:opacity-70",
  "aria-hidden": "true",
  viewBox: "0 0 16 16",
  version: "1.1",
  "data-view-component": "true"
}, [
  /* @__PURE__ */ oe("path", {
    "fill-rule": "evenodd",
    d: "M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
  })
], -1), FRe = [
  DRe
];
function jRe(e, t, r, n, o, s) {
  return we(), $e("a", PRe, FRe);
}
const BRe = /* @__PURE__ */ ni(LRe, [["render", jRe]]), qRe = {
  name: "ZazukoLogo"
}, WRe = {
  href: "https://zazuko.com",
  target: "_blank",
  rel: "noopener"
}, URe = /* @__PURE__ */ a3('<svg class="h-8 dark:fill-white opacity-100 hover:opacity-70" clip-rule="evenodd" fill-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="1.41421" viewBox="0 0 768 260" xmlns="http://www.w3.org/2000/svg"><path d="m2137 3767c1-1-44-1-42-1h240c6-2 12-7 12-14s-5-13-12-14h-195c-35 0-63-29-63-64 0-31 23-57 53-62 2-1-14-1-13-1h223c7-1 12-7 12-14 0-8-7-14-15-14-80 0-161 2-242 2-16 0-27-17-31-30-21-62-34-144-80-190-121-121-165-296-94-456 66-149 211-240 374-241 336-3 529 388 328 654 16 21 25 47 25 74 0 65-53 119-118 119-66 0-119-54-119-119 0-66 53-119 119-119 19 0 37 5 53 13 175-233 5-574-287-571-143 1-270 80-329 211-62 140-23 293 84 399 56 56 66 131 90 204v1h227c35 0 64 28 64 63 0 31-23 58-53 63-2 0-32 0-34 0h29c-2 0-4 0-6 0h-199c-7 2-12 8-12 14 0 7 5 13 12 14h194c35 0 64 29 64 64 0 31-23 57-54 62-1 1 27 1 25 1h-29c-2 0-4 0-6 0h-188c-6 1-11 7-11 14 0 8 6 14 14 14 21 0 73-1 94 0 206 15 363-55 512-199 135-131 211-315 211-502 0-69-10-136-29-200h-1c-25-86-67-167-123-238h-2c-85-108-201-190-335-233v-3l-1 2c-34-11-69-19-105-24-3 11-8 22-15 33-37 54-110 69-165 33-23-16-40-39-48-65-333 56-587 346-587 695 0 89 17 178 50 261 14-7 30-10 46-10 66 0 119 53 119 119 0 65-53 118-119 118-65 0-118-53-118-118 0-30 10-58 30-80-38-92-58-190-58-290 0-374 273-685 631-744 0-2 1-5 1-7h2c3-15 9-30 18-44 36-54 110-69 165-33 29 20 47 50 51 82 43 6 85 17 126 30v1c77 26 149 64 213 112v-1c70 53 129 115 176 186h1c80 120 126 263 126 418 0 237-111 459-301 603-205 141-324 151-565 147-35 0-64-28-64-63 0-31 23-58 54-62zm183-1327v-1c1-1 1-2 1-3l1-1v-1-1-1l1-1v-1-1l1-2v-1-1-1-1-1l1-1v-1c0-1 0-2 0-3v-1-1-1-1-1-1-1-1-1-1-1-1l-1-1v-1-1-2-1l-1-2v-1-1l-1-1v-1-1-1h-1v-1c-5-14-14-27-28-36-32-22-77-13-99 20-3 5-6 11-8 17v2h-1v3h-1v5h-1v23l1 1v4l1 1v3l1 1v2l1 1v2l1 1c5 13 14 24 26 32 33 22 77 13 99-19 3-5 5-9 7-13zm234 910c-7-7-15-13-23-18-10-5-21-7-32-7-39 0-71 32-71 71s31 71 71 71c39 0 71-32 71-71 0-17-6-33-16-46zm-905 233c40 0 71-32 71-71 0-40-31-72-71-72-39 0-71 32-71 72 0 39 32 71 71 71z" transform="matrix(.14637844056 0 0 .14637844056 -192.39293319 -322.90052908)"></path><g fill="#ff441c"><path d="m3509 3401.22c-4 5-6 10-6 17 0 3 1 6 2 10l6 9c2 2 5 4 8 5s7 2 11 2h417c7 0 13-2 18-7 5-6 8-12 8-20s-3-13-8-19c-5-5-11-7-18-7h-343c-4 0-7-2-8-5s-1-7 1-9l371-443c4-5 6-11 6-18 0-3-1-6-2-9s-4-7-6-9-5-4-8-6c-4-1-7-2-11-2h-417c-8 0-13 3-18 8-6 5-8 11-8 18 0 8 2 14 8 20 5 5 10 8 18 8h342c3 0 6 1 8 4 1 3 1 7-2 9z" transform="matrix(.12790089092 0 0 .12790089092 -128.22109287 -266.58431113)"></path><path d="m4479 3418.22c0 7 2 13 7 18 6 6 12 8 20 8 7 0 13-2 18-8 6-5 8-11 8-18v-251c0-77-27-142-81-196s-119-81-196-81-142 27-196 81c-54 55-81 119-81 196s27 142 81 196 119 81 196 81c32 0 63-5 93-16 29-10 56-26 81-45l36-29c2-2 6-3 9-1 3 1 5 4 5 7zm-224-474c30 0 60 5 88 17 26 12 50 28 70 49 21 20 37 44 48 70 12 28 18 57 18 87s-6 59-18 87c-11 26-27 50-48 70-20 21-44 37-71 49s-57 18-87 18-60-6-88-18c-27-12-50-28-71-48-20-21-36-45-47-71-12-28-18-57-18-87s6-59 18-87c11-26 27-50 47-70 21-21 44-37 71-49 28-12 57-17 88-17z" transform="matrix(.12790089092 0 0 .12790089092 -128.22109287 -266.58431113)"></path><path d="m4597 3401.22c-4 5-5 10-5 17 0 3 0 6 2 10 1 3 3 6 5 9 3 2 5 4 8 5s7 2 11 2h417c7 0 13-2 18-7 6-6 8-12 8-20s-2-13-8-19c-5-5-10-7-18-7h-343c-4 0-6-2-8-5-1-3-1-7 1-9l371-443c5-5 6-11 6-18 0-3-1-6-2-9s-3-7-6-9c-2-2-5-4-8-6-3-1-7-2-11-2h-417c-7 0-13 3-18 8-6 5-8 11-8 18 0 8 2 14 8 20 5 5 11 8 18 8h342c3 0 6 1 8 4 1 3 1 7-1 9z" transform="matrix(.12790089092 0 0 .12790089092 -128.22109287 -266.58431113)"></path><path d="m5609 3444.22c8 0 14-2 20-7 5-6 7-12 7-19v-502c0-7-2-13-7-18-6-5-11-8-19-8s-14 2-19 8c-6 5-8 11-8 18v272c0 27-5 54-16 79-10 24-25 46-43 64-19 19-41 33-65 44-25 11-51 16-79 16-27 0-54-5-79-16-24-11-46-25-64-43-19-19-33-41-43-65-11-25-16-52-16-79v-272c0-7-3-13-8-18-6-5-11-8-19-8s-13 2-19 8c-5 5-8 11-8 18v272c0 34 7 67 20 99 14 30 32 58 56 82 24 23 51 41 82 55 31 13 64 20 98 20 28 0 56-3 83-12 26-8 49-21 70-38l35-27c3-2 6-3 9-1 3 1 5 4 5 7l1 44c0 8 3 14 8 20 5 5 11 7 18 7z" transform="matrix(.12790089092 0 0 .12790089092 -128.22109287 -266.58431113)"></path><path d="m6162 3439.22c4 4 10 5 16 5 4 0 8 0 11-2 3-1 5-3 8-5 3-3 5-6 6-10 2-3 2-6 2-9 0-8-3-14-8-20l-253-285c-2-2-3-5-2-7 0-3 1-5 3-6l252-163c7-5 8-12 8-21 0-3 0-6-1-9-2-3-4-7-7-9-2-2-5-4-8-6-3-1-7-2-11-2-5 0-9 1-14 4l-363 236c-2 2-5 2-8 0-3-1-5-4-5-7v-470c0-7-2-13-7-19-6-5-12-8-19-8-8 0-14 3-19 8-6 6-8 12-8 19v764c0 8 2 14 8 19 5 6 11 8 19 8 7 0 13-2 18-8 6-5 8-11 8-19v-210c0-3 2-6 4-7l93-61c4-3 8-2 11 1z" transform="matrix(.12790089092 0 0 .12790089092 -128.22109287 -266.58431113)"></path><path d="m6802.94 3171.21c0-39.08-6.34-76.05-21.12-111.96-14.79-35.91-36.97-67.59-64.43-95.06-57.04-57.03-125.69-85.55-207.02-85.55-80.27 0-148.92 28.52-207.01 85.55-57.04 58.09-85.55 125.69-85.55 207.02 0 81.32 28.51 149.98 85.55 207.01 58.09 57.04 126.74 85.55 207.01 85.55 81.33 0 149.98-28.51 207.02-85.55 58.09-57.03 86.6-125.69 85.55-207.01zm-292.57-235.53c32.74 0 63.37 5.28 92.95 17.95 27.46 12.68 52.81 29.58 74.99 51.76 21.12 21.12 38.02 46.47 49.64 73.93 12.67 29.57 19.01 60.2 19.01 91.89 0 31.68-6.34 62.31-19.01 91.89-11.62 27.46-28.52 52.81-49.64 73.93-22.18 22.18-47.53 39.08-74.99 51.75-29.58 12.68-60.21 19.02-92.95 19.02-31.68 0-63.37-6.34-92.94-19.02-27.46-12.67-52.81-29.57-73.94-50.69-22.18-22.18-39.08-47.53-50.69-74.99-12.68-29.58-17.96-60.21-17.96-91.89 0-31.69 5.28-62.32 17.96-91.89 11.61-27.46 28.51-52.81 50.69-73.93 21.13-22.18 46.48-39.08 73.94-51.76 29.57-12.67 61.26-17.95 92.94-17.95z" transform="matrix(.12790089092 0 0 .12790089092 -129.98018937 -266.58431113)"></path></g></svg>', 1), HRe = [
  URe
];
function VRe(e, t, r, n, o, s) {
  return we(), $e("a", WRe, HRe);
}
const zRe = /* @__PURE__ */ ni(qRe, [["render", VRe]]), GRe = {
  name: "SpexLogo"
}, KRe = {
  width: "100%",
  height: "100%",
  viewBox: "0 0 284 284",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "xml:space": "preserve",
  "xmlns:serif": "http://www.serif.com/",
  style: { "fill-rule": "evenodd", "clip-rule": "evenodd", "stroke-linejoin": "round", "stroke-miterlimit": "2", fill: "rgba(0,0,0,0.3)" }
}, YRe = /* @__PURE__ */ a3('<path d="M283.465,55.991c-0,-30.902 -25.089,-55.991 -55.992,-55.991l-171.482,0c-30.902,0 -55.991,25.089 -55.991,55.991l-0,171.482c-0,30.903 25.089,55.992 55.991,55.992l171.482,-0c30.903,-0 55.992,-25.089 55.992,-55.992l-0,-171.482Z"></path><clipPath id="_clip1"><path d="M141.732,34.873l92.543,53.43l-0,106.859l-92.543,53.429l-92.542,-53.429l-0,-106.859l92.542,-53.43Zm0,18.209l-76.773,44.325l0,88.65l76.773,44.325l76.773,-44.325l0,-88.65l-76.773,-44.325Z"></path></clipPath><g clip-path="url(#_clip1)"><use xlink:href="#_Image2" x="49.19" y="34.873" width="186px" height="214px"></use></g><defs><image id="_Image2" width="186px" height="214px" xlink:href="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQIBAQEBAQIBAQECAgICAgICAgIDAwQDAwMDAwICAwQDAwQEBAQEAgMFBQQEBQQEBAT/2wBDAQEBAQEBAQIBAQIEAwIDBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAT/wAARCADWALoDAREAAhEBAxEB/8QAHgAAAgMBAQEBAQEAAAAAAAAABAYDBQcIAgkKAQD/xABAEAABAgQDBQUHAgQEBwEAAAABAAIDBBEhBTFBBhIiUWFxgZGh8AcTIzKxwdFS4QgUYvFCgpKiCRUWJENTcmP/xAAfAQACAgIDAQEBAAAAAAAAAAAFBgMHBAgCCQsKAQD/xAA3EQABAwQCAQIFAgUEAgIDAAABAAIEAwURIQYxEkFhBxMiQlEVMggUcYGhCVKRwSMzYuGx0fD/2gAMAwEAAhEDEQA/APjJNymdv3X2TUay6So9fOEqTspY2pflkjFCttH40jYSjPSlK2zzRqPWTBFkdbSbPyvzWRyPWTHEr9JTjQzDedL2RljvJqbLfJLXA5XqG7LwK/Hj1VjWiX0Mo6G6vqqx3j1VoWeUDhHQzp5FY7x6q1bLJBxtHQnZX8Bmsd6tiyV/27VjDNdajzKxn9q3bHVGso2F/hWM79yuGxP6VrLH8fVYdb9yt+ynNI/2/wC1awr0/wDlCJHSdIIyrqXbWnU5pXnO7TtbG5IKYpVtSEnz34BVkWqmSQmaUh5JFuFXZVoWehoEppk4VaJDudfGVa9mik+KapODWlkhXKTjKtmyw840muUgi3RV/cpXe1bdng6GlaE7ooO5JMyvknKdKbABgdBDudQdUsyq/anAycIdxoOuiXpNftTAYGFC45k/3S/JkHala31Kh33c/JCjXP5UixGbk6VtZd5tCvleU9Hk/hKk5J03rWKMUK/uj0aRnCUZ6T+a1e6qNx66YosjPqkuflKb1uxHY1ZMkSR1kpIxCUpU0TBGrBNEORsKiHC6h50KIEZCerRMwQMoyE5QOGsK07PL+obVhDdl9qBYrhkK2rLKyRtHwnEc6c81juGQrgscjY2rGERao7KZhYz+lclirZI2rCFanU3WK/tXRYKnkWhW0vp2flYNXtXVZP8A1H+ytYGh9ZoPKP0lPEAdFX8q27fEUSlPd2E/WpgLgUzSbK0tqki5VMZwrPs9HpNUnDy/CQLlWwCVbdljE4TbJQcrfhV5cpHZVv2SHnGk3yMCu7ZV1dJWyrjsUDo4TNCYIbOSr64Sck7VpwY/yaYHqV4c7MlKUuR2iYGNBDudqUsSpHama3AQ7nalLkmT2pWtzsqBztT3BL8mSpe9BQ755BCzIOVJ8v3SHOSWdB+670aFdeT3Hk9JUnJL5hTyuEYoSEfjSekoT0nnVvbyRuhX62mKLJ6OUmYhJfNZHY1fraZIknraRsRk/mtTuTDFr9JphyekiTkuYbyaUGtkwUKge3Cb7fK8XAhQQn9fNSPHqrPss7ONqxhOy86myxnjat+xTMgKwhOyy5LFcN4V0WGVnx2rOCeVe0rFeNEK7LBXz4qyhZ94WJU9FeXHquS1W8sbgLCrDeVelidmjj+iuZcXA7EClnAT/bfRMUo3w9FJlwdjIKsaz084wmuSh13fVUgXWt2rbsdDPjpN8jCrT1VVxdpGAVcthiE+Ok5yMCu7bVVrdpWMq67BAz46TlJwA0AkeIVaXWXs4KuqyQAxocRpHPdp4pEmye03MbgIV7q62CVJkntTsb6lDOdW+QCWJcnana3Oyh3u1OQyS5Lk+6lA9Ah3Orc/2S/Ik+6ma3Cj3x1Qwyd9rkoJuRz4e6i706EheStHlY9Uqzsjnb1yRihIR6NK90oT0jmCEajyPRMMWUkvEJH5hu+OiPxpA1tM0SV0kTEpH5rFMMWR1hNMKV0s+xSS+bhPgmSJI903wZPST3NMKIQdCjjSHtyn+zTi1wGUZCdl/aigeNYVx2Gdtu1ZQj+RqsR49Vd/HpmfEZVnBP8A9LFeNq9+NychuFaQqeSwqnSv3jVb9quJb5u2qwqyv/j5yz/hX0uKu70vTTohWVbGg4JTPJMy7aV5JEuVTAO1aNkpE+Ok4yEOtLX5Kt7tX2Vc/H42caTth8H5bZ9yq+7ytnavPjsLPjpPOHS/y2VV3mbs7V8cct2fHSZQBDYAM6UVZ3GX5ElWvFoClTDAh3u011SZNld7Wc1uShnu8B5pTmSu9rIa3KFe/U5aBK8uV2pgPQIdzq3OX0S5Jk97UzW4UDnV6BL8mV7qVrc7Ki3x1Qz+b91J4j8J1m5CteHuyXexRkryKo8v0StOYfna6L0JPujsaX7pQnsPrvcPlkjVCT1tMMWX1tJWIYf81r9iPRpKZokzpIuIyB4uHyTFEk77TVCl9bWeYph9nVCZocnpOEGXjG1muKSRY4uAv6smmJXDhgp2t0zBByqmE+h3Tancs149VbPH7jnx2rSE7LNYjx2FfHHJwPjtWsB3d1F1hVAthOMy8lu1bQTWnl4LCqDGVsVxWvnxV3KmpHYh9fQytjeNOzT/ALBMEoN4ivO6WrgcNJVq2lvkQm6QZXdsOaru61QAVcHH6GS1PWHQa7tvuqqvEjAccq+eNw/Lx0n7DZb5bevFVHepmA7a2E41bc+Ok9ykEQ2bxtZVHeJxJIBV/WSA2jSD8bUj3687BV7Pl7O0zNb6BCPdpXtKTZsvvayWtzoIV7/D6pRmS+9qcD0CFc7U9wSxKmd7UzW4UDnanuCXJMtTNZ6lQOdXOwS/Il+6lAJ6UW+OqGGWFz+X7rdZrDs6N8vXNd7tGUvH9jzfTKWJzDs+GnWmSL0JPujsaZ65SjPYb83Dra1UZjyuto/Fm9bSZiGG3dw3zCOxpaZIk3raRcSw35uFMMWUNbTXCm9bWdYrhvzcOvqyZ4crracIE0ZG1mOL4ceOjTrfNNkKV1tPFumdZKzaagOloxsQK8qJqo1BUYrIslw8Ht3pTQH9fuo6jdK+eMXEEtBKuIDsr6f2WDUHa2R4pO8vHauoBrTtGqwaq2d4jIz47V7KGpHYhsj9uVtDxZ3lS/t/2maSbUi3YlK6OwCrjsrPItTvh0KtK0VXXuv4g7V6cajeRaFoeFy9d23lRU3fpYGRlbHcUt5cWkhaRhcpZpI68lSt/uGC7a2Y4paNNJCYnkAboyGaqW5zcknKtmjTDGBrUE9/ifJIc+b3tZjG+gQb3jnb6pLnTe9rJa30CFe/n3BKUyaN7UzW4/qhnP53PJK8qb3tTtbjZQ7n6m55JckzFM1mdlQOfzPcgUiZ3tSgY0FH7zp5oYZ4z2uXg5ddTWG2PDTuqu+GjMXjmUJnulucwzOrfAXRahL90ajzSMbSpO4Wb8Nq8skZoS/dHo04a2k6fwuu9w539etUcjTPdMkWd1kpFxLCvmq1MEWZ1tNMOf1tZ1iuFfNw30NM0zw5nW04wJ/W1mOM4VZ3CRnVNsGZ1tPFtnjW1kOOYYRvndoRqnW3ywcDKsK1TxkbSZDJhvLDm05eu5HXAOHkFdXFrrhzW5VzAfkc1g1G4W0HDrkHFu1eyzrU08EOqhbY8Kl+RZhMUnSo7EKkftW3fDnh1D+3/YTbh4qQKapKvD8NOFe/HaXk5q0PCYNd235VN8hkhudrY7iEIvLNLUcHlK7llRHI7gG+RJW1nDLSX+H0rRZeGIEIfqIy5Kib7cfN7trZezwGxY4BG1FEf+3VVjc5/eCmBjfVAxImd+080gXGeN5KymM9B2g3xL9dBoElzp+ztZLW+gQrn8jU6lKUyf3tTtbjpDOfy7yliVO91M1mNlDuicvEpelTwPVShpKHdE/uUuSrls7UzWfhRe8H6j5oOZ4O8qT5fuvoZM4VWvD5LvsozsdFeMpRmY2ClubwrPh8rIxQne6L0J3ulicwnM7vr1RGqE73RyNP90oz2EfNw+SOR5vW0wRbj1tJGI4OTvcHkj8Wd7poh3EDG1nuK4NQO4OeiZYc7rJTdAuWxtZjjOC2dweVKJtgz+tp3t1y2NrHsfwY8fBzOSd7dOyRtWParj+3axTGZB0rFMRrbV4k+QZIqs8SrX4/dCyo0goSVeLHyU1Zq2g4ReA4sw5Mco7JC6wW53AZ4eWbTPIXI+iDyuv+Vu9wN/zKH9v+wnjC27xb9VXl+qeLStlOK0C+o1argktvblvwqA5RODPLa2z4LbDULNLYMGk9xoe4UAFVrdym6jLmgrc7hNkDKbarxoK6ixNNFR94uOztW1TZrA6VfFiZ+H7KsrpctnazGMP90BEiZ9PAJBn3LZ2spjPwg3xOtvMpLm3H3WS1n4Qr4n9glSXcQNkqdrfQIV8Xv+gStMugGcFTNpod0Tv+gSvKune1OGflDuid58kuSbnvtTNYovef1DyQv9S91z8Gr6xTGFf0+IXfxSn+68VmjPx0VQzOE2PB1yy0RWjcPdFaNwB0Sl2bwb5qMHhZGKFwxjaL0Lh+ClSdwXPg8qo5GuXW0cj3LHqkyfwM0PBXuTBFuI1tMcS54OikLE8Ds7g7hZMkS4jI2myDdetrM8YwAkPqw9lE1wbjsbTtbrsARgrIMewB1H0ZXuyTrbrlsYKsO03cZG1gu0+AENicHPRWNaLiPp2rYsd2BxtY4+E+UmHQnAjiq3qnhrxXpB7VsPwa/BlVjCVdycQVF6+dVgV2rez4aXdtQ08FOGH3cBXNApX7SuxD4aV/mUB/RaRgcIuLBSqqblMgU2uW4HBohrVGLcdm5HfLLctFqxzO7CmHbW9/w1sBrGngfhaiGtgQhDFBQXWrfJLv5vccrcC2QmxI7aLR0gI0Wnq6pm83bZ2jdOmq2JF6+uirG53cDIBWYymgXxev4SFcLrknay20/wAoN8b1qkudeGtztZDaZKDfF9ZBJs28g52shtNDPi9fGwSnLvHe1O2mh3Rete3JLcq7Z9VO2moHRa+qBAZF1znakDAovef1DyQ03Xfak8Hfhfb+NhBvw1Glrkr6CKdw914jFOcR6qmj4Pnw+SI0rh7ohSuOD2qOZwU34PAInRuXuidG5e6XZvAya8GfRGKF0wRkozQuuPVKk7gFd7g7wEcjXXraOxrqNbSRiOzjjvD3Z7gmWJdxrJTJEu4bjazvFtmyQ4+78AmuFdhkbThb71gjaybHdmCd74Z10TnbruBjasC1XwDG1g21GyzqRKQz/pVi2i8DI2rVsd+GR9S5f2x2diwHPishneYSQaUyVt2O5sqgMcVfHFb8G1GODtpJkYpJFbEWOlDkj0lmtLfD4R8lbVfSHl+E+YW7ecw+skuTdMcu1v4PSRJjsxvS2XZeVMV0O2o7lr7zyeKDH7XYh8K7W6VVp4HeF0dgMk2WlhFeBvEDdWj3PuQA1HsDl2afDjjzYMBsmo3fojpiPndawcivrcuHkrfpUlURY+d1TV5voydojTpKuiR+vRVldL61ucuWYymgIkx1VfXLkLd4cstlFBPj9Uizr+Dn6lkspIR8fP6pRmXzOdrIbT9EO6N18LnxS3JvWT2pm01A6L1+5QGReM+qkFNROi+ickHrXb3UoplePe9WrA/Vl+/L91+h+JhF6bmWlKL6GGXH1yvDZp3Deiq6LgxI+XXlVZlO4+6y6dy91Vx8DrXg1rlQlZ1O549VnU7kPyqWY2frXg7bWoiVK7Y9UQpXTH3JfmtnC4H4da9EVoXgD1RWhd8eqVp3ZgnepD8kdjXrB/cjka9+P3JJxLZPeDvhZ60TJCv2CPqTNCv4BAys0xrYxzmupCz/AKaFOVv5CMjLk523kQBB8lie0mw7i2J8E3B0VhWrkLcg+Ssuy8oAI+pcu7dbBvLI3wb3yard4/yMeTfqV6cW5W0OaPJcbbQ4PHwLE3B7C2DFeQKjIq8rbOp3CIMH6gFuj8I+aNoTqTXP0SPVX2BvD3Mv0Qu5/RTcV3ifw4XVtzjUy050F1FsBhJmDCcW8IG8SchzWlvxf5DTgMqAux2u7L+HjiNS5PpVC3WitqmIzITBDZZrRutC65ubcsaatRxf+V2NwITI9FtGmMNAwFQTE1nda0ci5WzLsuR2lQVPGmxehVL3rl9ME4ciNOPpVkWazuqtunLQ4n6lnMjoF8z1SFP5P5Z+pZTaKFdH6/slOXyPJP1KdtFQOj9ful2Rf8/cpW0lA6OOdfNBK97ye1KKXsozGOlfohVW85Pa5hn5URi9R9ShtW759VzFMfhefe/1eSxv1Y/lcvln8L9QbsHN6sPgvoqbcMbyvCSbPOO0K7Bq14LHpVStuQzklTNuR6yhH4HpuZ5Gl1kMueD2sht0I7KBi7P1qNzvospl2x9yyWXcDeVXRtm6/wDj8qrMp3jHqs2nesfcqiPssTX4fkiFK+4PaIUr7jtyX5vY7er8Lnk1FaHIvH7kVociA+5KWIbBmJvUg1/y5JgicpDMfUj8TlAZ09ZvjXs0dFDqS9ag5MzThbuZhhB80423mQpkEuWCbX+yGLHhxd2VN6/4FaNi57SY4eT1anH/AIgspObmp/lcE+2T2Hzn8tNRIUnEDmguaQw1BzC2T4N8QI5qsa6oMf1W1/w2+KNBkin5VfUeq432el5mUxV2FzbHw5qXj+5iMcN2vI99ldd7r0alsdOpHLC0kH+y+if+ADnFDl9alApvDqgAGM/0XdWzMmzBcElzEAbMTEMPIdm1tLeOa6c/4ivijEo3SvGbVGGkjv1/+l9dHwI4OePcQjVq7MVqrQfcNI1/z3/woJ3FG1dx1Nea6zOb/FaIKj//AC5/uti40FxHSXo+JAk31WtPIPigyq52Kmv6oxShEeiqok9WvEqmufPvmE/Ws9kXCDfOV1STN5mHknzWQ2PhDumuuaW5HKw7P1KYUMKF0xfNBq3JfL7lIKKiMfv60QuryDP3KQUl4Mfr50WBUvmfVchS9l4MbqPqsR96z6rkKeF5971p3LFfeM/cv35fuv5749fAKH9WH5X74BfrmOGQjy7xVfR3+pY6K8FH+eevJwqHoR4UX9+p49V/fzz14OEwznumvrkv0XUA7d/lchcaoXn/AJNB5NXMXgDef8r9/Uqo6UZwKA7Ms8F/frjf9y5i6VBvCjds9LHN0MdoK5DkLW681zF2qAYUTtmJR4u5lOgK5DlFNv3qRt5qs9Chomx8i+xfDv0I+y5DmVNh/wDYFM2/yBsZVfG2Dw2KDV8P/SfrRTD4hUKIz80f8rKp8omU9gFUU37LMFmg4RIkC4/TVZDPjBEh7dXAx7olH5zcaBy0FZttH/DfsjjsGJDmZmWYHgh29COvcikX+K6z8ZIrSJgAb7pytHxjv1rqNfRY4491wTt5/wALTEdvfaHgU/7IdqNm37QOfMR5nZvGTMYdAxxkvLxpmHLwplkF7GRosSEyDDMbdh70wN97BxBL+OH+vN/Dt/DZ8I7s7nFKZPlFgp0GwqdOo5lWq4Uw+r82tRaKNMONSqWOfV8GH5dKo7DT32/6I/8AHFbLb/GjxHgXxWjV6fH5tSoyRIptFT5Ip0alVjns8mnwfVYyiXNyWfN8g12PE8ue0f8Ahz/iI2HxKaw7an2ez2Ex5WIYT4bY7I8Ju6acL28JFrEWXQnyr/VO498ZZNS72OR40qpJAJ3ve/f8r00uD/Gj4Lcmt9KRxy7sqUyBj6S3AxoeJwRj8YWDz2xO3ks4iZwWYhEfMHHJVVM/iTbeHF4r5z7q3YnKuI12h1CU0hUEXZvaZh+Jh8VtOaCVfi5/NHPzf8otTvlid/66wKCfgmOD5pOI3vosN3xCNU/v/wArKbdbSf21QhnYTi4zlnHTKqx3c0NT71MLjbT09RHDMTGcBw71EeVl33KQT4J6evBw7ENYLvquB5IXdOUn87C/3heDh88M4ZHbZcf18u+5folxDsOXn+Rnv/WPH9lxN8J9VyEqL0HBef5Gd/8AWfE/hcTec9uX7/NRvyv5/JTn6P8Acfwvz9Xz9y/f5mh+V/v5Kc/R/uP4X9+rH/cv3+ao/lfr096PVV9GTr6R25eCJ4D1X89+B+5/dY77+R9y/vALyZjvCxX8iI+5fvg1eDMch30Cw6nJiM/Uv0MHovJmSNfOhQ+ryrx6cuXhn0UTpo6uHfdC6/MPH7lyFI9gKJ03S9T10CByudeH3/5XMUSh3ztzeumdSlad8R/lg/8Ak/ypGxxnaDiYjT/F36n1dV/d/i06g0n5n+VO2KD6KqmMWIrR/bQqjeVfHevQa5tOqc/1WZTh59EtzuLRSHcZHetSPiD8ar3Op1A6QQ38An/KLR4Lc9LX/YJKvh7SwsciV96xwbANbsbXMdv4XUR/FVy6RySE631ahLM9LtJ/07+LG1c7ZzN7cVBph9Q32/r/APjC769pHst2c9qGADFJjDpaZnjBAnt+C174hIp7zLM6nn2rro4zy658Quf8nSqltPP04PQ/H/6/+l9ivwF+Mt1oW2OachzXgDor5d+1D+EvBjFmYklh0Npq4+790ARfTmttuI/GecGNZXqk9eq7IuC/xC3RlNjJdYn3yuI9rv4bYcnEi0kGihNPhq/bL8VHSGgGp/lbR8c+N75TG5q/5WD4z7D2y5fSTAof0KxoPxAdUAPn/lW5bPisawB+Z/lZviHsl90SP5b/AGppjc1c/H1p3h/EU1Pv/wApQm/ZruV/7el/0I5R5YXb8kyR+c+YH1pdmPZ/uZQKU5tRSlybP3I1Q5iXfcqaPsPSo9yf9NlnU+Q5+5E6XKs7LlWRdjQ0Ee68s1lsvwP3LOZyYHB8kBE2SpUe7p/luFlNvWfuWY3kQIz5IJ+y1P8AxnvGSnbd8+qymX/X7kP/ANLj9DPBS/q/uVL+uj/cv06GIMzXtOq+h2revdeFCKa8GMNPzVDqt+xvyXMUl4MY6IVX5CB9y5ikFC6Na7h9UFkclx9y5hgULpgaVKXpXKSB+5cwz8BDumTpQdl0rTeWlufrUgp5Qr5rma9qR7lzXwBPmpW0UDFnKa66GgVX3vnzmg4esltEKrjTbjrQKm77zaTI8g1+AsplFVUaYN76qm75yN58iXbWfSoqtY185MQ4La8TuKmgWvnM+ROFF58kz2C1PuVwpxGDsjP9F1j7LZNsn/L7raEU6UXXp8Wp7ptV/kfVdzv8KdkZZqNH5YxoLv8A2ExTdgw4USjob2br2OuHAi4K0w5NCDqhe3RBXd78IOSPi0qbfLWkNt3sRLTbHzMCE10OK3faQK0roo+PX+rQIpVTsLfHifKXGm0hy5E2w9nEtH96Iks0k5O3LhXXZOUVaYBa9X/x7mEih4mnUK5e2s9kkL4jocu0i+TakK3LNzSpoFyvTj/xEqDDXvwf6rnrH/Zc1hfSWFq5sorMtvLy8D6lcln56XgZesixf2dNYX/9vr+iydoXJ/ID6lY1u5oXAfWs7xHYIN3vg9flTNF5FnGHJ0hcuLsfUkud2K3an3XZbsR2hfifVM8XlPlj6krzWx+7vfC8kXo3zONo/Q5LkD6kvTGygBp7rwF0SpXnP3IzR5Dn7lSx9lwK/Dp3VRCnd99opSv2eygP+mf/AMz5rJ/V/dZf67/8l93TFaF9B1e9ne14ieFEY50QWRfCPVcvAlQuinU/dAZN+x9y5BigdGA69c0ty+RYB+pStp/gId8Y80oT+TeIP1KVtPKEfMUyNSkS58qOD9SmFMBAxI5OvnYKt7ryio/IYVO2mekFEi9exV/cbw9+XPdlZDaYCBiRc+ngEh3O76O1lMpqtjRc7qrr3dT4u2s2lTTHszImLHbFc27nZ0yWvXNLtljmgq/fhPx01pjJNRuyQusNiYPu/daEUWmfOq3zqjt/ldu/wQhiJRp4H4XVWyc2YYh3I+y13vtDzLiuyX4e3E0RTwfwt8w6NCxCT/lotCHDgJFd0qr5lJ8av86n6LdHh19Py2AuWW7V7LDei/D1OQsE1Wa7kAbWwNkvRAbtYBj2y4BifDqKkZKybdd9DDlaNsvJwNrFse2Lgxt/4IBv/hpX190+W++1GY+pWPauS1qGPq0sSx7YNoL6QbXpaqfbdyJ2vqVn2jlxIH1LIcY2IDd/4VP8tk7weQl2MlWPbeVZx9SzfEtjab3wq5n5U1RL6HYw5O8HkxIH1JEn9kqV+FQ9iYo969CU2xORZ6clCd2Vz+H22qjVC759UyRr/wC6WJrZkAn4fZayLUbr7o9HvufVVB2ZufhnPsWZ+qn8oiL9rtfUsxQP3X0ASbxjO14voaT0FC6KTbP1yS/KvePuUgZ+VA6LzPcleZftfuUraf4Qz49Ms0oT7+d/UpAwBCPjE5nuGaR7jyBxyA5ShhPaGfE59wCTJt0qVM+RUzaf4Qr4n7DQJWmXDvJU7W+gQr4nXtPJKM+4nB2p2M9B2gokT9vykS5zyM7WUxiHhQzMRmtvStyqwvlwwxxyjtogumy208aWtbNSYYYdByoVr3yucXh2St0fhdZRSdT+ldFbLs3BDWsnKX/MqE+67J/hbQFGiz+y6A2ejbm5fKmqpi7Uw4nAW7XDJXgGbW3YFO0DL9RdVzco+c6W0/EroWNbtO85LQ8TlN6gMRreKgzCWqNR0Svj0Ww9huvk1u1ju0GAir6Mz6WTtbbkRjJVp2y6HA2sdxjAab53L15Zp4hXDONp+t9zOAcrMsUwFrt8GHUUy3U1w7iRg5TjCuZGC0rMcY2VZEDt2GK8qJthXhzcZKdrdyCpT09yyzF9kgN/4XlVN0K9HRyn+28jJxhyzfE9lQC6sIf6U1RLycDBTtB5BnALkhz+y93UZ4iyZI13BA2m6HfTgYck2d2cpvfDNB0R2hc8+qZYt8zjJVEdnbn4Zz5fsiIueu0XF7/+S7AdEAvX8Lvul3nvBXjyhhPaHfGz6+sksTLyd7UgaAhnxSczQeaU5t672uYaSh3PJysEpS7m+pnalazHSgL+Xil6RM91MGY7Q7n5geKX5U33UgaSh3vrUA9p5pZmTe9qdrfQIR7/AA06pQnzTvayGt9Ag4jvE5/hI1ymdrJY3JwFe4NKEva5wuTU1yVV3+cSCMq2eE2cuqte4bK2TAJfd3PE2oqJ5JJLvLC3Z+HtuFMswPwttwAbohilLKguQO8nkre34fU/Cm1bNgkSm7Uqrri3LVtbxet4hpWuYPMkBmed0i3CiCSFsTxqaW+IytQwqcs29QbGuqTJsfOfyr74/ciA05XrGMNZMQzFYBR1bDRQwpTqTvBxVuWu4ZAOdLJMZwcDf4agkitMk5wZx1tPtvnnW1l+K4OL1b30TdDm5A2nOFPOBkrP8Qwi54RnQUHromSLNx6ppiz+slI+I4Kx+9vMy1GaYYs8txgpliXF7MFpWe4ps2071GVHZdMkS6fkpvgXwjAcVneJbN03iIfgEzRbpkDJTnBvecYckaf2eHF8PttdMUa6HW02RL11kpdOz4qeDXoPsioupx2jYvAx2nl0Qmt6dV3xy7t7ryRACelA6Jy8UsS7m5/RUgYB2oXOpmalAK8snsqVrSVC5/M0HJB68r3UoAHSgc6vQIJJlrm1udqBz65WH1S9Kl97UwHoEM99egHmlmZL7U7W40EK9+vcAlCdK0VO1uAvMCGYsUWNAanqUjXSXhpyUatMMyZAbjS0DB5am5bNVRe5efI5WyPDLZ4lmlq+CwqbpAvl2Kmb9WLg5be8HhhhZgLXcFbTc7Kql727Lytx+EsDKbVquEvoWU18qqvZ7dOWx3HKmAFpmFRqbv5SbOp5V6WCTgNK0XDJizbpSmUt5V12GaQG7T3KRmxofu30IIoa3S1Iplj/ADardtE/Q2l3GMLB3zu2zFNURgy+lYlvmnSzDFMLoXcFtLJshy8Y2nGFNx6rPMSwwcXD5Jniy+tpqiTcY2keewyleG1a5I/Hl+6ZI0wjGClCdwwcXDz0qjdCX7o9HmA9FJ8/gzHhw3ADzojkec5vqmCLcn0yNpGxHABV1WDPkmCNcvwU1Qrz1kpYOAXPAc/0hFf1Eo8Lu3HaQC4nM/hd89eW53ZXlPgZ0FEX8vFC60n3UoYB2onOAzuUJryVzULnVuTkg0iTrtSNZ6lQOdW2Q+qCSZKkA9AoHurYZfVLsuSpmtwh3urbQeaWZknvanY31Qr3VNuwJTnSO1PTaXFXeGyx3m2qa3SBd5eiMqyuL23bSRsrRsKgULTS1u9VbeZGiFsvxKAGlgwtMwmHTc7R2lVPe6uQQtpuHxvEtK1DCBTd6CiqW7nLltVxJnjTAWj4YSN2iSJgySr6sL8YWh4bEoWHK+ZSlLZkEK5LHXwAn7D49C2/Q1SxKp5BVu2WXjCeJCYpu3yNEuSaWQQrYtE3Q2mN7GTUGhu4C2tUHBdRqZVkW2ZloBKScVw6pdw+SPQ5XunOFL0ASs8xLDfm4UyxJXQymqJK6BKR8Qw6lTu5dEwxZWUyxpWANpMncOu6jdfFHKEn3R+PL/BSrNyAvwoxQkn8o3Hl+hSzN4cDUboPSiL0ZX4KM0JRGwVRnCGVPBryCICa4ayiInnHa5YLiezku/6rIXl4AAdKJz6WGfPkhlaR7r9URNLkoRXkKVrMbKhc6vYg0iQufegoXOrYd55oHJkFTNbhDvdoO9L0qR3lSsbnZQ73aDvS1Lr9qYDJwvUvD95EBzDcko3CTgFGrVFNeuNaCcsNgAUJVfXSRnO1eHGYABbpP+GQabuncq2u1fJO1sTxaHgtOFoeGMpuZ1+qrC8VM5WyXFKHj4rR8LtloB9FWN1OXLZXjDcMan7D3WYK2oCUnygMlXTZHY8U9Ye/5ezPQJYlN2VbNmqkEJ4kItm36cktymbKtO0SMEJzkY1m+B1S/JpYJVoWmV1tN8lMZCvRApNL1VjW2X0QUTOyzY0PfaNLgLGoVTTd4lPUKVkAhIeIyA4rV7rpiiyMYTVEkkpHn5H5gWpgjyPUFMkWV6JMnpClRu+SOx5OUfjSkpzkhXet2FGaMhHY8nKWJqRzq0orRke6MUJOFUGRHIf6VnfzLvyiIlLhdz62GX1X0D1a68xUAk4CjJAFShdauVK1uFCSSUIr11y70FG52gz1KC166ma3Cgc6g66IHJr+65tGSoHOoK6pflV/dT9aCHNTYZuS3Lr4BU1JhJ16q6kYNN0JNuMjR2rD4/AwGkhO0hC+UX5m4SDca/e1efHYXiG6Tzh0K7fuq8uVXOdq/ONRsBoT7hzaObqbCqri6v8AInK2E4zSx44T9h2Q7FXVzOXLYTjgw1qd5B1A3mRRKsofUVbtndjxTpIPFG8vqlyW36irPtVTGE5yEU0Arl3JflM9VZdrr6CbpKLSl7HwQKTTyFY9rkaCa5SNYXyQOsxWLbJWgmeWih7aG4NiEGrU/F2k82+VjAVdiEmDUgAg3BWRGr40U3xZHRCSJ+Sz4f2R+PXTJFkZ3lJs7JZgt7DTJHKFdH40n0KUp2R+bh/CN0JGUdoSNaStNyQvY/hFqNdGaEhU5kbng1Wd8/3/AMoh8/3/AMr5ykgBfQVWrLzOgAOlCSTmhVauV+qNzqWGepQivWUzW4ChJoKoNIrLl3oKEmtygcispwAAh3Oqa6IBJrLm0ZKlloe+/ep2JZm1+0btkU1qocU1SEHI068vNJNwr5yrdsUMZbpOMhDqQadlQki5VtFXVYIuPHSdcPh5WqPokG41NFXnx6PjxTthzRUWpfNV9cjnKvbjtLHineRy7/ukK4ZLsK9rFpjf7J0kTQN6BLMkfUValqdjGU3SLsunr7oBKb6qyLY86TdJRKFvL6IFJbkFWJbKuAE1ykTL0UErNVg2ytjCaJSL8pqgleng4T9bpHW0yykahCE16eQnqBI6V4N2ND3TyshZyx2QnKDJyAlyfk7utz0RSNXTLGr4wk6dkxe2aN0KyYI9bPqlKblPmBH3RmjWRuPISvNyYFeFGKFfOkaoVyPVUxlLng15LPFb/wDsogK6+WZJJqV9BlasvNXUbnUsM/ohVaspWtxsqI8yhNesuahcanpog1espWtxtQvOnigcir2uaiu4hg1zQGVWwCsmlTLiGjtXMrCyCVZ1fRT5ZYeANJsk4VALUJt1SZOrZyresUTrSbZGHQDL7FJNxqZyrjsMbrScZBlKaU8Cki41NFXTYaOCE44e00aCL6JEuDgCSFdlgp48QnGSH1H2STO2/Kuqyj6AU3yZ+Xtp9Utye1Z1sOQCmuSdces0ElN+nSsG2uwAmmUf8vqiCVm5T9bKvSaZWJ8p5oJXbgp7t9XBATLKRdOaESGaynu31+kxy0XK6EVWJ2t8jpMUrGsBXsQqvTxtOMKRjCLjwmxodaXpfqsam803YTXFr5ASpOymdkZoVkfjV8eqU52UqTb90YoVkdoVkrzUrnZFqNZGY8hUxlLng15IgJBRIVgvkQ51B1X0H1qq83NrcbKhQutWXNRPdWwy16oRXqqRjfUqNxoOuiD16qkUBNKkoLIqrmwZ2p5aGXHeKXpdbtG7ZHNSp5Jjk4Vxa/0SlOrZyFaFniYwMJplId2imXqyUZtXtWxZo2MaTXKM+UWzrTmkydUySrdskfGE2yTLDyKTLg/SuCxUsYTdItpunUZpJnHOcK5LEzBGE2yfyt9cknTTlyuK0jDQmqUNB3pek7P9lYdt9E0SjqEdMkGkNyCn+3HACZpV1KfZBKw0ni3VOslMso+wCESG4OQnmDU6THLRPlv539flCqrU6wK3QymKWifKa9qEVWYJBTnBr4wr6Xi0pfsQ2qz8pxh11fwIgIHWxQqqzBwmqHIxhDzkuHAlorW650KuDgplj1sgbSpOSw4reWSM0KqNx6+e0rzktWvDfVFqNVGaNX1CpjLXNteSzvnFZ4rL4vZ3K+hOtVXnILw91LDPXohdaquTW5KiQmvVUyhcanpog9eqv0DJwvAG84N01QWTVwCsqlT83BgVxLQqUCWplZPFpiYwUyykLI0SnMq9qzrRFORpMsnDuO2pSrNq6KtO0R9gYTRKMuPVEnzKmcq17NR6TVKtoAOZSfPeMq2rJSx4prkm5V5eYSbNd3hW5ZGYwmmUsGjkfuEoy/34Vs2r9oTRKZDt+4QKR/0rBt5wAmOVdl2evqhNYJ4t7sYKZJVwt2evogtYb2nSA/GAmOUfQjO9kLrt0nWDU0Ewyz9PXr8ITVanGDV6V/KxNELrt9U4wq3SvZeJle+SGVGpuhV+ley0XLSqHVqeek1RK/RVu0h7d0696HuHifIJmiV+lUTktnRtvqsyhW9Cj1Gr7pXm5Y3t2IvRqozHrKnMs2p4df0rOFUoh80L4duNBVfQtWqFedIN6UCFVnntTgADAUbzp3lCq7yv1RE0BKEV6h2pWDWURLMqanOt0ClVDtGbbRDnglX8qwEhLEyockKx7XQAATHLMFGjmb9yWJbztWXaaAGEySjRbtSrOedqzLRSGQmWUb8vXuSpMcVadopgYTPKtruDndKE55ycq1bMwHBTRKWoO9KUw9q1bM0DGEzSmQ7fuEqS/wB5Vp2zQATLKuq2nT90Er+hT3AOwExSxy6evshNUaTrAd6pilTUN6WQiuPqKcoLiFfSzsvXrJDKrc5TjBf0mKXcbH1zQmsNlNsJ50Fey7yCPXRDqrQdflN8KocAq8gPy6oVUCbIVQ6V1AiGoWDVamqHVOldy8QkUvY0Q2swA/1TJFqlFxGCIypF1jNJa7CY41UkApdm4Dan1RFKFQlGaNQ6KqPcdfNZvzPZZ/z1/9k="></image></defs>', 4), XRe = [
  YRe
];
function JRe(e, t, r, n, o, s) {
  return we(), $e("svg", KRe, XRe);
}
const QRe = /* @__PURE__ */ ni(GRe, [["render", JRe]]), ZRe = {
  class: "z-10 py-1 shadow-sm flex justify-between items-center",
  style: { "background-color": "rgba(0,0,0,0.1)" }
}, eAe = { class: "flex flex-row ml-2 items-center gap-3" }, tAe = /* @__PURE__ */ oe("h1", { class: "py-2 text-2xl text-black dark:text-white font-bold font-title" }, " SPEX ", -1), rAe = { class: "flex flex-row items-center gap-3" }, nAe = { key: 0 }, iAe = { key: 1 }, oAe = {
  key: 0,
  class: "flex flex-row items-center mr-2"
}, sAe = /* @__PURE__ */ oe("div", { style: { height: "15px", "border-left": "1px solid", "margin-left": "6px", "margin-right": "8px", width: "1px" } }, null, -1), aAe = { key: 1 }, lAe = {
  name: "SpexHeader"
}, uAe = /* @__PURE__ */ it({
  ...lAe,
  props: {
    isSettingsEditorShown: { type: Boolean },
    sparqlEndpointUrl: {}
  },
  emits: ["toggle-settings-editor", "toggle-prefix-help"],
  setup(e, { emit: t }) {
    const r = e;
    function n() {
      t("toggle-settings-editor", !r.isSettingsEditorShown);
    }
    function o() {
      t("toggle-prefix-help");
    }
    return (s, a) => (we(), $e("div", ZRe, [
      oe("div", eAe, [
        xe(QRe, { style: { width: "30px", height: "30px" } }),
        tAe
      ]),
      oe("div", rAe, [
        oe("button", {
          class: "button is-white dark:is-dark flex items-center gap-1",
          title: "Options",
          onClick: n
        }, [
          oe("h2", null, [
            s.sparqlEndpointUrl ? (we(), $e("span", nAe, gt(s.sparqlEndpointUrl), 1)) : (we(), $e("span", iAe, "No endpoint configured yet"))
          ]),
          xe(De(GH), { class: "icon" })
        ]),
        oe("button", {
          class: "button is-white dark:is-dark",
          title: "Prefix Zazuko",
          onClick: o
        }, [
          xe(De(cRe), { class: "icon" })
        ])
      ]),
      s.isSettingsEditorShown ? bt("", !0) : (we(), $e("div", oAe, [
        xe(zRe),
        sAe,
        xe(BRe)
      ])),
      s.isSettingsEditorShown ? (we(), $e("div", aAe)) : bt("", !0)
    ]));
  }
});
var fAe = "Expected a function", JP = NaN, cAe = "[object Symbol]", dAe = /^\s+|\s+$/g, hAe = /^[-+]0x[0-9a-f]+$/i, pAe = /^0b[01]+$/i, gAe = /^0o[0-7]+$/i, bAe = parseInt, yAe = typeof window == "object" && window && window.Object === Object && window, vAe = typeof self == "object" && self && self.Object === Object && self, mAe = yAe || vAe || Function("return this")(), _Ae = Object.prototype, wAe = _Ae.toString, SAe = Math.max, EAe = Math.min, c1 = function() {
  return mAe.Date.now();
};
function xAe(e, t, r) {
  var n, o, s, a, l, u, f = 0, c = !1, d = !1, h = !0;
  if (typeof e != "function")
    throw new TypeError(fAe);
  t = QP(t) || 0, TE(r) && (c = !!r.leading, d = "maxWait" in r, s = d ? SAe(QP(r.maxWait) || 0, t) : s, h = "trailing" in r ? !!r.trailing : h);
  function p(j) {
    var J = n, z = o;
    return n = o = void 0, f = j, a = e.apply(z, J), a;
  }
  function v(j) {
    return f = j, l = setTimeout(S, t), c ? p(j) : a;
  }
  function y(j) {
    var J = j - u, z = j - f, $ = t - J;
    return d ? EAe($, s - z) : $;
  }
  function w(j) {
    var J = j - u, z = j - f;
    return u === void 0 || J >= t || J < 0 || d && z >= s;
  }
  function S() {
    var j = c1();
    if (w(j))
      return x(j);
    l = setTimeout(S, y(j));
  }
  function x(j) {
    return l = void 0, h && n ? p(j) : (n = o = void 0, a);
  }
  function E() {
    l !== void 0 && clearTimeout(l), f = 0, n = u = o = l = void 0;
  }
  function N() {
    return l === void 0 ? a : x(c1());
  }
  function C() {
    var j = c1(), J = w(j);
    if (n = arguments, o = this, u = j, J) {
      if (l === void 0)
        return v(u);
      if (d)
        return l = setTimeout(S, t), p(u);
    }
    return l === void 0 && (l = setTimeout(S, t)), a;
  }
  return C.cancel = E, C.flush = N, C;
}
function TE(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function RAe(e) {
  return !!e && typeof e == "object";
}
function AAe(e) {
  return typeof e == "symbol" || RAe(e) && wAe.call(e) == cAe;
}
function QP(e) {
  if (typeof e == "number")
    return e;
  if (AAe(e))
    return JP;
  if (TE(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = TE(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(dAe, "");
  var r = pAe.test(e);
  return r || gAe.test(e) ? bAe(e.slice(2), r ? 2 : 8) : hAe.test(e) ? JP : +e;
}
var TAe = xAe;
const $Ae = /* @__PURE__ */ Tn(TAe);
class NAe {
  constructor(t) {
    As(this, "_type");
    As(this, "_comment");
    As(this, "_serverResponseItem");
    var n, o, s;
    this._serverResponseItem = t, this._type = ((n = t.parts.filter((a) => a.predicate === "rdf:type")[0]) == null ? void 0 : n.object) ?? "";
    const r = t.parts.filter((a) => a.predicate === "rdfs:comment");
    if (r.length < 2)
      this._comment = ep(((o = r[0]) == null ? void 0 : o.object) ?? "no comment");
    else {
      const a = r.filter((l) => l.object.language === "en");
      a.length === 1 ? this._comment = ep(((s = a[0]) == null ? void 0 : s.object) ?? "no comment") : this._comment = "no comment";
    }
  }
  get type() {
    return this._type;
  }
  get avatar() {
    const t = this.type.split(":");
    return t.length < 2 ? "NT" : (t[0].charAt(0) + t[1].charAt(0)).toUpperCase();
  }
  get itemText() {
    return this._serverResponseItem.itemText;
  }
  get ontologyTitle() {
    return this._serverResponseItem.ontologyTitle;
  }
  get label() {
    return this._serverResponseItem.label;
  }
  get splitA() {
    return this._serverResponseItem.prefixedSplitA;
  }
  get splitB() {
    return this._serverResponseItem.prefixedSplitB;
  }
  get comment() {
    return this._comment;
  }
  get parts() {
    return this._serverResponseItem.parts;
  }
}
function ep(e) {
  return typeof e == "string" ? e : e.datatype && e.datatype.value === "http://www.w3.org/2001/XMLSchema#string" || e.datatype && e.datatype.value === "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" ? e.value : "";
}
const kAe = { class: "avatar" }, CAe = { class: "card-text" }, IAe = { class: "card-title" }, MAe = { class: "card-comment" }, OAe = {
  name: "PrefixZazukoListItem"
}, LAe = /* @__PURE__ */ it({
  ...OAe,
  props: {
    item: {}
  },
  emits: ["item-selected"],
  setup(e, { emit: t }) {
    const r = e;
    return (n, o) => (we(), $e("div", {
      class: "card",
      onClick: o[0] || (o[0] = (s) => n.$emit("item-selected", r.item))
    }, [
      xe(Wr, {
        label: r.item.type
      }, {
        default: Ge(() => [
          oe("div", kAe, gt(r.item.avatar), 1)
        ]),
        _: 1
      }, 8, ["label"]),
      oe("div", CAe, [
        oe("div", IAe, gt(r.item.itemText), 1),
        oe("div", MAe, gt(r.item.comment), 1)
      ])
    ]));
  }
}), PAe = /* @__PURE__ */ ni(LAe, [["__scopeId", "data-v-9c005fb0"]]), DAe = {
  name: "PrefixZazukoList"
}, FAe = /* @__PURE__ */ it({
  ...DAe,
  props: {
    items: {}
  },
  emits: ["item-selected"],
  setup(e, { emit: t }) {
    const r = e;
    function n(o) {
      t("item-selected", o);
    }
    return (o, s) => (we(!0), $e(ut, null, gr(r.items, (a) => (we(), xt(PAe, {
      key: a.itemText,
      item: a,
      onItemSelected: n
    }, null, 8, ["item"]))), 128));
  }
}), jAe = ["item"], BAe = {
  name: "PrefixZazukoDetail"
}, qAe = /* @__PURE__ */ it({
  ...BAe,
  props: {
    item: {}
  },
  emits: ["item-selected"],
  setup(e, { emit: t }) {
    const r = e;
    return (n, o) => (we(), $e("table", null, [
      (we(!0), $e(ut, null, gr(r.item.parts, (s) => (we(), $e("tr", {
        key: s.predicate,
        item: s
      }, [
        oe("th", null, gt(De(ep)(s.predicate)), 1),
        oe("td", null, gt(De(ep)(s.object)), 1)
      ], 8, jAe))), 128))
    ]));
  }
}), WAe = /* @__PURE__ */ ni(qAe, [["__scopeId", "data-v-2dcbeccb"]]), UAe = { class: "card is-shadowless h-full overflow-y-auto" }, HAe = { class: "card-header has-background-light" }, VAe = /* @__PURE__ */ oe("h3", { class: "card-header-title" }, "Resolve RDF Terms", -1), zAe = { class: "card-header-icon py-0 px-1" }, GAe = {
  key: 0,
  style: { padding: "21px" }
}, KAe = { class: "field" }, YAe = /* @__PURE__ */ oe("div", { class: "flex flex-row" }, [
  /* @__PURE__ */ oe("label", {
    class: "label",
    for: "prefix"
  }, "Prefix"),
  /* @__PURE__ */ tn("   ("),
  /* @__PURE__ */ oe("a", {
    target: "_blank",
    href: "https://prefix.zazuko.com/"
  }, "prefix.zazuko.com"),
  /* @__PURE__ */ tn(") ")
], -1), XAe = {
  key: 1,
  style: { padding: "21px" }
}, JAe = { class: "flex flex-row items-center mb-4" }, QAe = {
  style: { display: "flex", "flex-direction": "column" },
  class: "pl-4"
}, ZAe = { class: "title mb-0" }, eTe = {
  name: "PrefixHelp"
}, tTe = /* @__PURE__ */ it({
  ...eTe,
  props: {
    searchString: {}
  },
  emits: ["close"],
  setup(e, { emit: t }) {
    const n = Ne(e.searchString), o = Ne([]), s = Ne(null);
    yr(n, $Ae((c) => {
      a(c);
    }, 300));
    async function a(c) {
      const d = "https://prefix.zazuko.com/api/v1/search", h = `q=${encodeURIComponent(c)}`, y = (await (await fetch(d + "?" + h)).json()).map((w) => new NAe(w));
      o.value = y;
    }
    function l() {
      t("close");
    }
    function u(c) {
      s.value = c;
    }
    function f() {
      s.value = null;
    }
    return (c, d) => (we(), $e("div", UAe, [
      oe("div", HAe, [
        VAe,
        oe("p", zAe, [
          oe("button", {
            type: "button",
            class: "button is-light",
            onClick: l,
            title: "Close"
          }, [
            xe(De(as), { class: "icon" })
          ])
        ])
      ]),
      s.value === null ? (we(), $e("div", GAe, [
        oe("div", KAe, [
          YAe,
          jr(oe("input", {
            type: "text",
            "onUpdate:modelValue": d[0] || (d[0] = (h) => n.value = h),
            placeholder: "Start typing to search... eg. sh:name",
            class: "input",
            required: ""
          }, null, 512), [
            [Vo, n.value]
          ])
        ]),
        xe(FAe, {
          items: o.value,
          onItemSelected: u
        }, null, 8, ["items"])
      ])) : bt("", !0),
      s.value !== null ? (we(), $e("div", XAe, [
        oe("div", JAe, [
          oe("button", {
            class: "flex flex-grow-0",
            onClick: f
          }, [
            xe(De(jH), { class: "icon" })
          ]),
          oe("div", QAe, [
            oe("h1", ZAe, gt(s.value.splitA) + ":" + gt(s.value.splitB), 1),
            oe("div", null, gt(s.value.type), 1)
          ])
        ]),
        xe(WAe, {
          item: s.value
        }, null, 8, ["item"])
      ])) : bt("", !0)
    ]));
  }
}), rTe = { class: "z-10 absolute m-3" }, nTe = /* @__PURE__ */ oe("span", null, "Classes", -1), iTe = { class: "z-10 absolute bottom-2 left-2 text-sm bg-gray-50 dark:bg-gray-700 flex items-center gap-2" }, oTe = { class: "bg-light dark:bg-dark flex-grow flex items-center" }, sTe = {
  key: 0,
  class: "m-auto"
}, aTe = {
  key: 1,
  class: "section"
}, lTe = { class: "message is-danger" }, uTe = { class: "message-body" }, fTe = {
  name: "SpexMain"
}, cTe = /* @__PURE__ */ it({
  ...fTe,
  props: {
    settings: {}
  },
  emits: ["settingsChanged"],
  setup(e, { emit: t }) {
    const r = e, n = Ne(""), o = Ne(!1), s = co.getInstance(r.settings), a = Oe(() => p.value.length > 0);
    yr(() => r.settings, (H) => {
      var ge;
      (((ge = H.sparqlEndpoint) == null ? void 0 : ge.length) ?? 0) > 0 ? (l.value = !1, ce(H)) : l.value = !0;
    }), Dt(async () => {
      r.settings.sparqlEndpoint ? await ce(r.settings) : l.value = !0;
    });
    const l = Ne(!1), u = Ne(!1), f = Ne(!1), c = Ne(!1), d = Ne(!1), h = Ne(null), p = Ne([]), v = Ne(null), y = Ne(!1), w = Ne(null);
    function S() {
      o.value = !o.value;
    }
    function x() {
      o.value = !1;
    }
    function E(H) {
      if (typeof H > "u") {
        l.value = !l.value;
        return;
      }
      l.value = H;
    }
    function N(H) {
      C(H), p.value.push(H);
    }
    function C(H) {
      p.value = p.value.filter((ge) => ge.id !== H.id);
    }
    function j() {
      p.value = [];
    }
    function J(H) {
      H.isShown = !H.isShown;
    }
    function z(H) {
      var Ce, ue;
      const ge = H ? H.tables : new Set((Ce = v.value) == null ? void 0 : Ce.tables.map(({ id: ee }) => ee));
      (ue = v.value) == null || ue.tables.forEach((ee) => {
        ge.has(ee.id) ? ee.isShown = !0 : ee.isShown = !1;
      });
    }
    function $() {
      f.value = !0;
    }
    function G() {
      f.value = !1;
    }
    function I() {
      u.value = !1;
    }
    function W() {
      h.value = null, u.value = !1;
    }
    function k() {
      c.value = !0;
    }
    function U() {
      d.value = !0;
    }
    function Z(H) {
      v.value = H;
    }
    function Y() {
      c.value = !1;
    }
    function re() {
      d.value = !1;
    }
    async function ae() {
      W(), w.value = null, y.value = !0, v.value = null;
      try {
        v.value = await s.fetchDataModel();
      } catch (H) {
        w.value = H, E(!0), console.error(H);
      } finally {
        y.value = !1;
      }
    }
    async function ce(H) {
      s.applySettings(H), await ae();
    }
    function pe(H) {
      u.value = !0, h.value = H;
    }
    async function le(H) {
      const ge = s.dataModelToSHACL(v.value).namedNode(H.id).in(Pt.targetClass), Ce = ge.value, ue = ge.out(Pt.targetClass).value;
      let ee = `_:${Ce} a <http://www.w3.org/ns/shacl#NodeShape> ;`;
      ee += `
	<${Pt.targetClass.value}> <${ue}> ;`;
      const be = ge.out(Pt.property);
      be.values.length > 0 && (ee += `
	<${Pt.property.value}> `, be.toArray().forEach((Te, Pe) => {
        ee += `
		[`;
        const K = Te.out(Un.type).value, V = Te.out(Pt.path).value, b = Te.out(Pt.class).value, _ = Te.out(Pt.datatype).value, T = Te.out(Pt.or);
        let L = `			<${Un.type}> <${K}> ;
			<http://www.w3.org/ns/shacl#path> <${V}> ;
`;
        if (L += b ? `			<http://www.w3.org/ns/shacl#class> <${b}> ;
` : "", L += _ ? `			<http://www.w3.org/ns/shacl#datatype> <${_}> ;
` : "", T.values.length > 0) {
          let O = `			<http://www.w3.org/ns/shacl#shOr> (
`;
          const ie = T.list();
          (ie === null ? [] : [...ie]).forEach((se) => {
            const ve = [];
            se.dataset.match(se.term, null, null, null).filter((B) => !(B.predicate.equals(Un.last) || B.predicate.equals(Un.last) || B.predicate.equals(Un.nil))).forEach((B) => ve.push(`					<${B.predicate.value}> <${B.object.value}> ;`)), O += `				[
${ve.join(` 
`)}`, O += ` 
				]
`;
          }), L += `${O}`, L += `			) 
`;
        }
        ee += `
${L}		] ${Pe === be.values.length - 1 ? "." : ","}`;
      })), await navigator.clipboard.writeText(ee);
    }
    function ye(H) {
      t("settingsChanged", H);
    }
    return (H, ge) => (we(), xt(De(Yc), { class: "default-theme flex-grow overflow-hidden" }, {
      default: Ge(() => [
        xe(De(Hi), null, {
          default: Ge(() => [
            xe(De(Yc), {
              horizontal: "",
              class: "h-full"
            }, {
              default: Ge(() => [
                xe(De(Hi), { class: "flex flex-col bg-light dark:bg-dark" }, {
                  default: Ge(() => [
                    xe(uAe, {
                      isSettingsEditorShown: l.value,
                      sparqlEndpointUrl: De(s).sparqlEndpoint,
                      onToggleSettingsEditor: E,
                      onTogglePrefixHelp: S
                    }, null, 8, ["isSettingsEditorShown", "sparqlEndpointUrl"]),
                    v.value ? (we(), xt(De(Yc), {
                      key: 0,
                      vertical: "",
                      class: "overflow-hidden"
                    }, {
                      default: Ge(() => [
                        f.value ? (we(), xt(De(Hi), {
                          key: 0,
                          size: "30"
                        }, {
                          default: Ge(() => [
                            xe(ORe, {
                              datamodel: v.value,
                              onToggleTable: J,
                              onSelectViewport: z,
                              onClose: G
                            }, null, 8, ["datamodel"])
                          ]),
                          _: 1
                        })) : bt("", !0),
                        xe(De(Hi), { class: "relative h-full" }, {
                          default: Ge(() => [
                            oe("div", rTe, [
                              jr(oe("button", {
                                class: "button",
                                onClick: $
                              }, [
                                xe(De(UH), { class: "icon" }),
                                nTe
                              ], 512), [
                                [Ea, !f.value]
                              ])
                            ]),
                            xe(MEe, {
                              datamodel: v.value,
                              onExplore: pe,
                              onExport: le,
                              onToggleShape: J
                            }, {
                              default: Ge(() => [
                                jr(oe("p", iTe, [
                                  De(s) && !w.value ? (we(), $e("button", {
                                    key: 0,
                                    class: "button is-white is-small",
                                    onClick: k
                                  }, " SHACL ")) : bt("", !0)
                                ], 512), [
                                  [Ea, !(u.value || a.value)]
                                ])
                              ]),
                              _: 1
                            }, 8, ["datamodel"])
                          ]),
                          _: 1
                        }),
                        o.value ? (we(), xt(De(Hi), {
                          key: 1,
                          size: "30"
                        }, {
                          default: Ge(() => [
                            xe(tTe, {
                              onClose: x,
                              "search-string": n.value
                            }, null, 8, ["search-string"])
                          ]),
                          _: 1
                        })) : bt("", !0)
                      ]),
                      _: 1
                    })) : bt("", !0),
                    oe("div", oTe, [
                      y.value ? (we(), $e("div", sTe, [
                        xe(RA)
                      ])) : bt("", !0)
                    ]),
                    w.value ? (we(), $e("div", aTe, [
                      oe("div", lTe, [
                        oe("div", uTe, " Error loading data: " + gt(w.value), 1)
                      ])
                    ])) : bt("", !0)
                  ]),
                  _: 1
                }),
                u.value || a.value ? (we(), xt(De(Hi), { key: 0 }, {
                  default: Ge(() => [
                    xe(De(Yc), { vertical: "" }, {
                      default: Ge(() => [
                        u.value ? (we(), xt(De(Hi), { key: 0 }, {
                          default: Ge(() => [
                            xe(fRe, {
                              table: h.value,
                              onClose: I,
                              onExploreResource: N
                            }, null, 8, ["table"])
                          ]),
                          _: 1
                        })) : bt("", !0),
                        a.value ? (we(), xt(De(Hi), { key: 1 }, {
                          default: Ge(() => [
                            xe(rxe, {
                              resources: p.value,
                              onClose: j,
                              onExploreResource: N,
                              onUnexploreResource: C
                            }, null, 8, ["resources"])
                          ]),
                          _: 1
                        })) : bt("", !0)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })) : bt("", !0)
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        l.value ? (we(), xt(De(Hi), {
          key: 0,
          size: "30"
        }, {
          default: Ge(() => [
            xe(Uxe, {
              settings: H.settings,
              onSettingsChanged: ye,
              onClose: E
            }, null, 8, ["settings"])
          ]),
          _: 1
        })) : bt("", !0),
        c.value && v.value !== null ? (we(), xt(age, {
          key: 1,
          open: c.value,
          onClose: Y,
          endpoint: De(s),
          datamodel: v.value,
          onOpenLoadShacl: U
        }, null, 8, ["open", "endpoint", "datamodel"])) : bt("", !0),
        d.value ? (we(), xt(vge, {
          key: 2,
          open: d.value,
          onClose: re,
          endpoint: De(s),
          load: Z
        }, null, 8, ["open", "endpoint"])) : bt("", !0)
      ]),
      _: 1
    }));
  }
});
function r$e(e, t) {
  OH(cTe, { settings: t }).mount(e);
}
export {
  iY as S,
  cTe as _,
  Kt as a,
  ft as b,
  hTe as c,
  St as d,
  ur as e,
  Vl as f,
  Tn as g,
  C3 as h,
  _3 as i,
  hre as j,
  Gx as k,
  q1 as l,
  Ffe as m,
  r$e as n,
  te as p,
  M8 as r
};
//# sourceMappingURL=index-CbPxOOAJ.js.map
