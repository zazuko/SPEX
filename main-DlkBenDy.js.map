{"version":3,"file":"main-DlkBenDy.js","sources":["../node_modules/@graphy/content.xml.scribe/main.js"],"sourcesContent":["\n\n\nconst factory = require('@graphy/core.data.factory');\nconst Scribable = require('@graphy/core.class.scribable');\n\nconst {\n\tc1,\n\tnamedNode,\n\t$_PREFIX_CACHE,\n} = factory;\n\nconst R_XML_ESCAPES = /[&\"<>']/g;\nconst H_XML_ESCAPES = {\n\t'&': '&amp;',\n\t'<': '&lt;',\n\t'>': '&gt;',\n\t'\"': '&quot;',\n\t\"'\": '&apos;',\n};\n\nconst R_NS_XML = /^xml/i;\n\nconst escape_xml_text = s_text => s_text.replace(R_XML_ESCAPES, s => H_XML_ESCAPES[s]);\n\nconst R_XML_NAME_SIMPLE_EOS = /([A-Za-z_][A-Za-z_.0-9-]*)$/;\n\n\n\nconst R_XML_NAME_EXTENDED_EOS = /([A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u{10000}-\\u{EFFFF}][A-Za-z_.0-9\\-\\u00b7\\u203f-\\u2040\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u{10000}-\\u{EFFFF}]*$)/u;\n\nfunction XML_Serializer$pair(k_self, sx1_predicate, sx_arc, kt_object) {\n\t// named node\n\tif(kt_object.isNamedNode) {\n\t\tsx_arc += ' rdf:resource=\"'+escape_xml_text(kt_object.value)+'\"/>';\n\t}\n\t// literal\n\telse if(kt_object.isLiteral) {\n\t\t// languaged\n\t\tif(kt_object.isLanguaged) {\n\t\t\tsx_arc += ' xml:lang=\"'+kt_object.language+'\"';\n\t\t}\n\t\t// datatyped\n\t\telse if(kt_object.isDatatyped) {\n\t\t\tsx_arc += ' rdf:datatype=\"'+escape_xml_text(kt_object.datatype.value)+'\"';\n\t\t}\n\n\t\t// all literals\n\t\tsx_arc += '>'+escape_xml_text(kt_object.value)+'</'+sx1_predicate+'>';\n\t}\n\t// blank node\n\telse if(kt_object.isBlankNode) {\n\t\tsx_arc += ' rdf:nodeID=\"'+escape_xml_text(kt_object.value)+'\"/>';\n\t}\n\t// other\n\telse {\n\t\tthrow new Error(`Not allowed to serialize term type '${kt_object.termType}' as object in XML serializer.`);\n\t}\n\n\treturn sx_arc;\n}\n\nfunction XML_Serializer$predicate(k_self, kt_predicate) {\n\tlet h_prefixes = k_self._h_prefixes;\n\n\tlet p_predicate = kt_predicate.value;\n\n\t// split predicate\n\tlet p_edge_prefix_iri;\n\tlet s_edge_suffix;\n\t{\n\t\tlet m_edge_name = R_XML_NAME_SIMPLE_EOS.exec(p_predicate);\n\n\t\t// simple name\n\t\tif(m_edge_name) {\n\t\t\tp_edge_prefix_iri = p_predicate.slice(0, m_edge_name.index);\n\t\t\ts_edge_suffix = m_edge_name[1];\n\t\t}\n\t\t// not a simple name\n\t\telse {\n\t\t\tm_edge_name = R_XML_NAME_EXTENDED_EOS.exec(p_predicate);\n\n\t\t\t// extended name\n\t\t\tif(m_edge_name) {\n\t\t\t\tp_edge_prefix_iri = p_predicate.slice(0, m_edge_name.index);\n\t\t\t\ts_edge_suffix = m_edge_name[1];\n\t\t\t}\n\t\t\t// cannot serialize\n\t\t\telse {\n\t\t\t\tthrow new Error(`Cannot serialize predicate <${p_predicate}> into an XML qname`);\n\t\t\t}\n\t\t}\n\t}\n\n\t// predicate tag\n\tlet sx1_predicate;\n\tlet sx_arc;\n\n\tTEMPORARY_PREFIX:\n\tfor(;;) {\n\t\tPREFIX_LOOKUP:\n\t\tfor(;;) {\n\t\t\t// prefix cache\n\t\t\tif(h_prefixes[$_PREFIX_CACHE]) {\n\t\t\t\tlet h_inverse = h_prefixes[$_PREFIX_CACHE]._h_inverse;\n\n\t\t\t\t// prefix exists\n\t\t\t\tif(p_edge_prefix_iri in h_inverse) {\n\t\t\t\t\tlet si_prefix = h_inverse[p_edge_prefix_iri];\n\n\t\t\t\t\t// set predicate tag\n\t\t\t\t\tsx1_predicate = (si_prefix? si_prefix+':': '')+s_edge_suffix;\n\n\t\t\t\t\t// start arc\n\t\t\t\t\tsx_arc = '<'+sx1_predicate;\n\n\t\t\t\t\t// done\n\t\t\t\t\tbreak TEMPORARY_PREFIX;\n\t\t\t\t}\n\t\t\t\t// prefix does not exist\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// no cache\n\t\t\telse {\n\t\t\t\t// each prefix in hash\n\t\t\t\tfor(let si_prefix in h_prefixes) {\n\t\t\t\t\tlet p_prefix_iri = h_prefixes[si_prefix];\n\n\t\t\t\t\t// prefix matches\n\t\t\t\t\tif(p_prefix_iri === p_edge_prefix_iri) {\n\t\t\t\t\t\t// set predicate tag\n\t\t\t\t\t\tsx1_predicate = (si_prefix? si_prefix+':': '')+s_edge_suffix;\n\n\t\t\t\t\t\t// start arc\n\t\t\t\t\t\tsx_arc = '<'+sx1_predicate;\n\n\t\t\t\t\t\t// stop searching hash\n\t\t\t\t\t\tbreak PREFIX_LOOKUP;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// prefix not found\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// create temporary prefix\n\t\tlet si_prefix_tmp = '__g'+(k_self._c_prefixes_tmp++);\n\n\t\t// set predicate tag\n\t\tsx1_predicate = si_prefix_tmp+':'+s_edge_suffix;\n\n\t\t// start arc\n\t\tsx_arc = '<'+sx1_predicate+' xmlns:'+si_prefix_tmp+'=\"'+p_edge_prefix_iri+'\"';\n\n\t\t// done\n\t\tbreak;\n\t}\n\n\treturn [sx1_predicate, sx_arc];\n}\n\nclass XML_Scriber extends Scribable {\n\tconstructor(gc_scriber={}) {\n\t\t// special case, remove prefixes before forwarding to super\n\t\tlet h_prefixes = gc_scriber.prefixes;\n\t\tdelete gc_scriber.prefixes;\n\n\t\tsuper(gc_scriber);\n\n\t\t// whether or not we can still add prefixes\n\t\tthis._b_prefixes_open = true;\n\n\t\tthis._c_prefixes_tmp = 0;\n\n\t\tthis._kt_subject = null;\n// this._kt_predicate = null;\n\n\t\t// open xml document and root node\n\t\tlet sx_open = '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n<rdf:RDF'\n\t\t\t+'\\n\\txmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"';\n\n\t\t// force default prefix\n\t\tthis._update_prefixes({\n\t\t\trdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',\n\t\t});\n\n\t\t// prefixes given\n\t\tif(h_prefixes) {\n\t\t\t// update prefixes and push to output\n\t\t\tthis.push(sx_open+this._serialize_prefixes(h_prefixes));\n\t\t}\n\t\t// no prefixes\n\t\telse {\n\t\t\tthis.push(sx_open);\n\t\t}\n\t}\n\n\t_serialize_prefixes(h_prefixes_in, b_force_serialize=false) {\n\t\t// prefixes are frozen; reject prefix event\n\t\tif(!this._b_prefixes_open) return;\n\n\t\t// ref current prefixes\n\t\tlet h_prefixes = this._h_prefixes;\n\n\t\t// serialize new prefixes\n\t\tlet sx_prefixes = '';\n\t\tfor(let si_prefix in h_prefixes_in) {\n\t\t\t// prefix already exists\n\t\t\tif((si_prefix in h_prefixes)) {\n\t\t\t\t// and no change; skip\n\t\t\t\tif(h_prefixes_in[si_prefix] === h_prefixes[si_prefix] && !b_force_serialize) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// attempted change to prefix\n\t\t\t\telse {\n\t\t\t\t\tthrow new Error(`Cannot change prefixes in RDF/XML serializer. Attempted to modify '${si_prefix}' from <${h_prefixes[si_prefix]}> to <${h_prefixes_in[si_prefix]}>`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// prefix not allowed\n\t\t\tif(R_NS_XML.test(si_prefix)) {\n\t\t\t\tthrow new Error(`Cannot serialize prefix '${si_prefix}' since it is reserved under the blanket XML namespace.`);\n\t\t\t}\n\n\t\t\t// serialize prefix\n\t\t\tsx_prefixes += `\\n\\txmlns${si_prefix? ':'+si_prefix: ''}=\"${namedNode(h_prefixes_in[si_prefix]).value}\"`;\n\t\t}\n\n\t\t// change detected\n\t\tif(sx_prefixes) {\n\t\t\t// (re)cache prefixes\n\t\t\tthis._update_prefixes(h_prefixes_in, true);\n\t\t}\n\n\t\t// write prefixes\n\t\treturn sx_prefixes;\n\t}\n\n\n\t_serialize_c3r(hc3r_triples) {\n\t\t// string building\n\t\tlet sx_output = '';\n\n\t\t// no longer able to modify prefixes\n\t\tif(this._b_prefixes_open) {\n\t\t\tsx_output += '>';\n\t\t\tthis._b_prefixes_open = false;\n\t\t}\n\n\t\t// ref prefixes\n\t\tlet h_prefixes = this._h_prefixes;\n\n\t\t// hanging subject\n\t\tif(null !== this._kt_subject) {\n\t\t\t// close previous\n\t\t\tsx_output += '\\n\\t</rdf:Description>';\n\n\t\t\t// reset\n\t\t\tthis._kt_subject = null;\n\t\t}\n\n\t\tfor(let sc1_subject in hc3r_triples) {\n\t\t\tlet sx_triples = '';\n\n\t\t\t// interpret subject\n\t\t\tlet kt_subject = c1(sc1_subject, h_prefixes);\n\n\t\t\t// not a term; skip\n\t\t\tif(!kt_subject.termType) continue;\n\n\t\t\t// not a node\n\t\t\tif(!kt_subject.isNamedNode && !kt_subject.isBlankNode) {\n\t\t\t\tthrow new Error(`Cannot use ${kt_subject.termType} term type in subject position`);\n\t\t\t}\n\n\t\t\t// convert to xml\n\t\t\t{\n\t\t\t\t// named node\n\t\t\t\tif(kt_subject.isNamedNode) {\n\t\t\t\t\tsx_triples += '\\n\\n\\t<rdf:Description rdf:about=\"'+escape_xml_text(kt_subject.value)+'\">';\n\t\t\t\t}\n\t\t\t\t// named node\n\t\t\t\telse if(kt_subject.isBlankNode) {\n\t\t\t\t\tsx_triples += '\\n\\n\\t<rdf:Description rdf:nodeID=\"'+escape_xml_text(kt_subject.value)+'\">';\n\t\t\t\t}\n\t\t\t\t// other\n\t\t\t\telse {\n\t\t\t\t\tthrow new Error(`Not allowed to serialize term type '${kt_subject.termType}' as subject in XML serializer.`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet b_predicates = false;\n\n\t\t\t// each predicate\n\t\t\tlet hc2r_pairs = hc3r_triples[sc1_subject];\n\t\t\tfor(let sc1_predicate in hc2r_pairs) {\n\t\t\t\t// interpret predicate\n\t\t\t\tlet kt_predicate = c1(sc1_predicate, h_prefixes);\n\n\t\t\t\t// not a term; skip\n\t\t\t\tif(!kt_predicate.termType) continue;\n\n\t\t\t\t// not a node\n\t\t\t\tif(!kt_predicate.isNamedNode) {\n\t\t\t\t\tthrow new Error(`Cannot use ${kt_predicate.termType} term type in subject position`);\n\t\t\t\t}\n\n\t\t\t\t// convert to xml\n\t\t\t\tlet [sx1_predicate, sx_arc] = XML_Serializer$predicate(this, kt_predicate);\n\n\t\t\t\t// pairs\n\t\t\t\tlet sx_pairs = '';\n\n\t\t\t\t// each object\n\t\t\t\tfor(let sc1_object of hc2r_pairs[sc1_predicate]) {\n\t\t\t\t\t// interpret object\n\t\t\t\t\tlet kt_object = c1(sc1_object, h_prefixes);\n\n\t\t\t\t\t// not a term; skip\n\t\t\t\t\tif(!kt_object.termType) continue;\n\n\t\t\t\t\t// add object to pairs\n\t\t\t\t\tsx_pairs += '\\n\\t\\t'+XML_Serializer$pair(this, sx1_predicate, sx_arc, kt_object);\n\t\t\t\t}\n\n\t\t\t\t// objects written; add pairs to output\n\t\t\t\tif(sx_pairs) {\n\t\t\t\t\tsx_triples += sx_pairs;\n\t\t\t\t\tb_predicates = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// predicates written; add triples to output\n\t\t\tif(b_predicates) {\n\t\t\t\tsx_output += sx_triples+'\\n\\t</rdf:Description>';\n\t\t\t}\n\t\t}\n\n\t\treturn sx_output;\n\t}\n\n\t_serialize_quad(g_quad) {\n\t\t// normalize quad\n\t\tlet kq_quad = factory.from.quad(g_quad);\n\n\t\t// no longer able to modify prefixes\n\t\tif(this._b_prefixes_open) {\n\t\t\tthis._s_push += '>';\n\t\t\tthis._b_prefixes_open = false;\n\t\t}\n\n\t\tlet {\n\t\t\tsubject: kt_subject,\n\t\t\tpredicate: kt_predicate,\n\t\t\tobject: kt_object,\n\t\t} = kq_quad;\n\n\t\t// serialize predicate\n\t\tlet [sx1_predicate, sx_arc] = XML_Serializer$predicate(this, kt_predicate);\n\t\tlet sx_pair = '\\n\\t\\t'+XML_Serializer$pair(this, sx1_predicate, sx_arc, kt_object);\n\n\t\t// same subject\n\t\tif(kt_subject.equals(this._kt_subject)) {\n\t\t\tthis._s_push += sx_pair;\n\t\t}\n\t\t// subject not identical to previous\n\t\telse {\n\t\t\t// not a node\n\t\t\tif(!kt_subject.isNamedNode && !kt_subject.isBlankNode) {\n\t\t\t\tthrow new Error(`Cannot use ${kt_subject.termType} term type in subject position`);\n\t\t\t}\n\n\t\t\t// convert to xml\n\t\t\tlet sx_line;\n\t\t\t{\n\t\t\t\t// named node\n\t\t\t\tif(kt_subject.isNamedNode) {\n\t\t\t\t\tsx_line = '\\n\\n\\t<rdf:Description rdf:about=\"'+escape_xml_text(kt_subject.value)+'\">'+sx_pair;\n\t\t\t\t}\n\t\t\t\t// named node\n\t\t\t\telse if(kt_subject.isBlankNode) {\n\t\t\t\t\tsx_line = '\\n\\n\\t<rdf:Description rdf:nodeID=\"'+escape_xml_text(kt_subject.value)+'\">'+sx_pair;\n\t\t\t\t}\n\t\t\t\t// other\n\t\t\t\telse {\n\t\t\t\t\tthrow new Error(`Not allowed to serialize term type '${kt_subject.termType}' as subject in XML serializer.`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// different subject\n\t\t\tif(this._kt_subject) {\n\t\t\t\t// write triple\n\t\t\t\tthis._s_push += '\\n\\t</rdf:Description>'+sx_line;\n\t\t\t}\n\t\t\t// first subject\n\t\t\telse {\n\t\t\t\tthis._s_push += sx_line;\n\t\t\t}\n\n\t\t\t// save subject and predicate\n\t\t\tthis._kt_subject = kt_subject;\n\t\t// this._kt_predicate = kt_predicate;\n\t\t}\n\t}\n\n\t_flush() {\n\t\t// flush buffer\n\t\tXML_Scriber._flush_buffer(this);\n\n\t\t// no longer able to modify prefixes\n\t\tif(this._b_prefixes_open) {\n\t\t\tthis.push('>');\n\t\t\tthis._b_prefixes_open = false;\n\t\t}\n\n\t\t// triple needs closing\n\t\tif(this._kt_subject) {\n\t\t\tthis.push('\\n\\t</rdf:Description>\\n</rdf:RDF>\\n');\n\t\t}\n\t\t// just close document\n\t\telse {\n\t\t\tthis.push('\\n</rdf:RDF>\\n');\n\t\t}\n\n\t\t// eof\n\t\tthis.push(null);\n\t}\n}\n\nObject.assign(XML_Scriber, {\n\t_serialize_comment: Scribable.prototype._serialize_hash_comment,\n});\n\nmodule.exports = function(g_config) {\n\treturn new XML_Scriber(g_config);\n};\n"],"names":["factory","require$$0","Scribable","require$$1","c1","namedNode","$_PREFIX_CACHE","R_XML_ESCAPES","H_XML_ESCAPES","R_NS_XML","escape_xml_text","s_text","R_XML_NAME_SIMPLE_EOS","R_XML_NAME_EXTENDED_EOS","XML_Serializer$pair","k_self","sx1_predicate","sx_arc","kt_object","XML_Serializer$predicate","kt_predicate","h_prefixes","p_predicate","p_edge_prefix_iri","s_edge_suffix","m_edge_name","TEMPORARY_PREFIX","PREFIX_LOOKUP","h_inverse","si_prefix","si_prefix_tmp","XML_Scriber","gc_scriber","sx_open","h_prefixes_in","b_force_serialize","sx_prefixes","hc3r_triples","sx_output","sc1_subject","sx_triples","kt_subject","b_predicates","hc2r_pairs","sc1_predicate","sx_pairs","sc1_object","g_quad","kq_quad","sx_pair","sx_line","main","g_config"],"mappings":"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","x_google_ignoreList":[0]}