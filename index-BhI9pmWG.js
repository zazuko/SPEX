var hW = Object.defineProperty;
var pW = (e, t, r) => t in e ? hW(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var As = (e, t, r) => (pW(e, typeof t != "symbol" ? t + "" : t, r), r);
const TE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get _void() {
    return DV;
  },
  get acl() {
    return l9;
  },
  get as() {
    return f9;
  },
  get bibo() {
    return d9;
  },
  get cc() {
    return p9;
  },
  get cert() {
    return b9;
  },
  get cnt() {
    return m9;
  },
  get constant() {
    return w9;
  },
  get crm() {
    return S9;
  },
  get csvw() {
    return x9;
  },
  get ctag() {
    return A9;
  },
  get dash() {
    return k9;
  },
  get dashSparql() {
    return $9;
  },
  get dbo() {
    return M9;
  },
  get dc11() {
    return L9;
  },
  get dcam() {
    return P9;
  },
  get dcat() {
    return F9;
  },
  get dcmitype() {
    return B9;
  },
  get dcterms() {
    return W9;
  },
  get default() {
    return bD;
  },
  get dig() {
    return H9;
  },
  get discipline() {
    return G9;
  },
  get doap() {
    return K9;
  },
  get dpv() {
    return X9;
  },
  get dqv() {
    return Q9;
  },
  get dtype() {
    return ez;
  },
  get duv() {
    return rz;
  },
  get earl() {
    return iz;
  },
  get ebucore() {
    return sz;
  },
  get exif() {
    return lz;
  },
  get foaf() {
    return fz;
  },
  get frbr() {
    return dz;
  },
  get geo() {
    return pz;
  },
  get geof() {
    return bz;
  },
  get geor() {
    return mz;
  },
  get gml() {
    return wz;
  },
  get gn() {
    return Sz;
  },
  get gr() {
    return xz;
  },
  get grddl() {
    return Az;
  },
  get gs1() {
    return $z;
  },
  get gtfs() {
    return kz;
  },
  get http() {
    return Mz;
  },
  get hydra() {
    return Lz;
  },
  get ical() {
    return Pz;
  },
  get la() {
    return Fz;
  },
  get ldp() {
    return Bz;
  },
  get list() {
    return Wz;
  },
  get locn() {
    return Hz;
  },
  get log() {
    return Gz;
  },
  get lvont() {
    return Kz;
  },
  get m4i() {
    return Xz;
  },
  get ma() {
    return Qz;
  },
  get mads() {
    return eG;
  },
  get math() {
    return rG;
  },
  get oa() {
    return iG;
  },
  get og() {
    return sG;
  },
  get oidc() {
    return lG;
  },
  get org() {
    return fG;
  },
  get owl() {
    return dG;
  },
  get pim() {
    return pG;
  },
  get prefix() {
    return bG;
  },
  get prov() {
    return mG;
  },
  get qb() {
    return wG;
  },
  get qkdv() {
    return SG;
  },
  get quantitykind() {
    return xG;
  },
  get qudt() {
    return AG;
  },
  get rdau() {
    return $G;
  },
  get rdf() {
    return Bn;
  },
  get rdfa() {
    return IG;
  },
  get rdfs() {
    return NG;
  },
  get rev() {
    return OG;
  },
  get rico() {
    return DG;
  },
  get rif() {
    return XV;
  },
  get rr() {
    return jG;
  },
  get rss() {
    return qG;
  },
  get schema() {
    return UG;
  },
  get sd() {
    return zG;
  },
  get sdmx() {
    return VG;
  },
  get sem() {
    return YG;
  },
  get set() {
    return JG;
  },
  get sf() {
    return ZG;
  },
  get sh() {
    return tV;
  },
  get shex() {
    return nV;
  },
  get shsh() {
    return oV;
  },
  get sioc() {
    return aV;
  },
  get skos() {
    return uV;
  },
  get skosxl() {
    return cV;
  },
  get solid() {
    return hV;
  },
  get sosa() {
    return gV;
  },
  get sou() {
    return yV;
  },
  get ssn() {
    return vV;
  },
  get stat() {
    return _V;
  },
  get string() {
    return EV;
  },
  get test() {
    return RV;
  },
  get time() {
    return TV;
  },
  get unit() {
    return CV;
  },
  get v() {
    return QV;
  },
  get vaem() {
    return IV;
  },
  get vann() {
    return NV;
  },
  get vcard() {
    return OV;
  },
  get vs() {
    return jV;
  },
  get wdr() {
    return eK;
  },
  get wdrs() {
    return qV;
  },
  get wgs() {
    return UV;
  },
  get xhv() {
    return zV;
  },
  get xkos() {
    return VV;
  },
  get xml() {
    return rK;
  },
  get xsd() {
    return yf;
  }
}, Symbol.toStringTag, { value: "Module" }));
function bs(e, t) {
  const r = /* @__PURE__ */ Object.create(null), n = e.split(",");
  for (let o = 0; o < n.length; o++)
    r[n[o]] = !0;
  return t ? (o) => !!r[o.toLowerCase()] : (o) => !!r[o];
}
const xt = Object.freeze({}), Tl = Object.freeze([]), jr = () => {
}, QP = () => !1, gW = /^on[^a-z]/, cc = (e) => gW.test(e), th = (e) => e.startsWith("onUpdate:"), It = Object.assign, $E = (e, t) => {
  const r = e.indexOf(t);
  r > -1 && e.splice(r, 1);
}, bW = Object.prototype.hasOwnProperty, at = (e, t) => bW.call(e, t), qe = Array.isArray, na = (e) => tp(e) === "[object Map]", ZP = (e) => tp(e) === "[object Set]", Xe = (e) => typeof e == "function", Lt = (e) => typeof e == "string", CE = (e) => typeof e == "symbol", vt = (e) => e !== null && typeof e == "object", kE = (e) => vt(e) && Xe(e.then) && Xe(e.catch), e3 = Object.prototype.toString, tp = (e) => e3.call(e), IE = (e) => tp(e).slice(8, -1), t3 = (e) => tp(e) === "[object Object]", ME = (e) => Lt(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, Id = /* @__PURE__ */ bs(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), yW = /* @__PURE__ */ bs(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), rp = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (r) => t[r] || (t[r] = e(r));
}, mW = /-(\w)/g, Ri = rp((e) => e.replace(mW, (t, r) => r ? r.toUpperCase() : "")), vW = /\B([A-Z])/g, is = rp(
  (e) => e.replace(vW, "-$1").toLowerCase()
), _a = rp(
  (e) => e.charAt(0).toUpperCase() + e.slice(1)
), Fs = rp(
  (e) => e ? `on${_a(e)}` : ""
), Lf = (e, t) => !Object.is(e, t), dl = (e, t) => {
  for (let r = 0; r < e.length; r++)
    e[r](t);
}, rh = (e, t, r) => {
  Object.defineProperty(e, t, {
    configurable: !0,
    enumerable: !1,
    value: r
  });
}, c1 = (e) => {
  const t = parseFloat(e);
  return isNaN(t) ? e : t;
}, wW = (e) => {
  const t = Lt(e) ? Number(e) : NaN;
  return isNaN(t) ? e : t;
};
let CA;
const nh = () => CA || (CA = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" || typeof window < "u" ? window : {});
function np(e) {
  if (qe(e)) {
    const t = {};
    for (let r = 0; r < e.length; r++) {
      const n = e[r], o = Lt(n) ? xW(n) : np(n);
      if (o)
        for (const s in o)
          t[s] = o[s];
    }
    return t;
  } else {
    if (Lt(e))
      return e;
    if (vt(e))
      return e;
  }
}
const _W = /;(?![^(]*\))/g, SW = /:([^]+)/, EW = /\/\*[^]*?\*\//g;
function xW(e) {
  const t = {};
  return e.replace(EW, "").split(_W).forEach((r) => {
    if (r) {
      const n = r.split(SW);
      n.length > 1 && (t[n[0].trim()] = n[1].trim());
    }
  }), t;
}
function lr(e) {
  let t = "";
  if (Lt(e))
    t = e;
  else if (qe(e))
    for (let r = 0; r < e.length; r++) {
      const n = lr(e[r]);
      n && (t += n + " ");
    }
  else if (vt(e))
    for (const r in e)
      e[r] && (t += r + " ");
  return t.trim();
}
const RW = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", AW = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", TW = /* @__PURE__ */ bs(RW), $W = /* @__PURE__ */ bs(AW), CW = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", kW = /* @__PURE__ */ bs(CW);
function r3(e) {
  return !!e || e === "";
}
const pt = (e) => Lt(e) ? e : e == null ? "" : qe(e) || vt(e) && (e.toString === e3 || !Xe(e.toString)) ? JSON.stringify(e, n3, 2) : String(e), n3 = (e, t) => t && t.__v_isRef ? n3(e, t.value) : na(t) ? {
  [`Map(${t.size})`]: [...t.entries()].reduce((r, [n, o]) => (r[`${n} =>`] = o, r), {})
} : ZP(t) ? {
  [`Set(${t.size})`]: [...t.values()]
} : vt(t) && !qe(t) && !t3(t) ? String(t) : t;
var IW = { NODE_ENV: '"production"' };
function d1(e, ...t) {
  console.warn(`[Vue warn] ${e}`, ...t);
}
let Fn;
class MW {
  constructor(t = !1) {
    this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Fn, !t && Fn && (this.index = (Fn.scopes || (Fn.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  run(t) {
    if (this._active) {
      const r = Fn;
      try {
        return Fn = this, t();
      } finally {
        Fn = r;
      }
    } else
      d1("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    Fn = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    Fn = this.parent;
  }
  stop(t) {
    if (this._active) {
      let r, n;
      for (r = 0, n = this.effects.length; r < n; r++)
        this.effects[r].stop();
      for (r = 0, n = this.cleanups.length; r < n; r++)
        this.cleanups[r]();
      if (this.scopes)
        for (r = 0, n = this.scopes.length; r < n; r++)
          this.scopes[r].stop(!0);
      if (!this.detached && this.parent && !t) {
        const o = this.parent.scopes.pop();
        o && o !== this && (this.parent.scopes[this.index] = o, o.index = this.index);
      }
      this.parent = void 0, this._active = !1;
    }
  }
}
function NW(e, t = Fn) {
  t && t.active && t.effects.push(e);
}
function LW() {
  return Fn;
}
const NE = (e) => {
  const t = new Set(e);
  return t.w = 0, t.n = 0, t;
}, i3 = (e) => (e.w & os) > 0, o3 = (e) => (e.n & os) > 0, OW = ({ deps: e }) => {
  if (e.length)
    for (let t = 0; t < e.length; t++)
      e[t].w |= os;
}, PW = (e) => {
  const { deps: t } = e;
  if (t.length) {
    let r = 0;
    for (let n = 0; n < t.length; n++) {
      const o = t[n];
      i3(o) && !o3(o) ? o.delete(e) : t[r++] = o, o.w &= ~os, o.n &= ~os;
    }
    t.length = r;
  }
}, h1 = /* @__PURE__ */ new WeakMap();
let Uu = 0, os = 1;
const p1 = 30;
let Dr;
const ia = Symbol("iterate"), g1 = Symbol("Map key iterate");
class LE {
  constructor(t, r = null, n) {
    this.fn = t, this.scheduler = r, this.active = !0, this.deps = [], this.parent = void 0, NW(this, n);
  }
  run() {
    if (!this.active)
      return this.fn();
    let t = Dr, r = Zo;
    for (; t; ) {
      if (t === this)
        return;
      t = t.parent;
    }
    try {
      return this.parent = Dr, Dr = this, Zo = !0, os = 1 << ++Uu, Uu <= p1 ? OW(this) : kA(this), this.fn();
    } finally {
      Uu <= p1 && PW(this), os = 1 << --Uu, Dr = this.parent, Zo = r, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    Dr === this ? this.deferStop = !0 : this.active && (kA(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function kA(e) {
  const { deps: t } = e;
  if (t.length) {
    for (let r = 0; r < t.length; r++)
      t[r].delete(e);
    t.length = 0;
  }
}
let Zo = !0;
const s3 = [];
function Pa() {
  s3.push(Zo), Zo = !1;
}
function Da() {
  const e = s3.pop();
  Zo = e === void 0 ? !0 : e;
}
function Cr(e, t, r) {
  if (Zo && Dr) {
    let n = h1.get(e);
    n || h1.set(e, n = /* @__PURE__ */ new Map());
    let o = n.get(r);
    o || n.set(r, o = NE()), a3(o, { effect: Dr, target: e, type: t, key: r });
  }
}
function a3(e, t) {
  let r = !1;
  Uu <= p1 ? o3(e) || (e.n |= os, r = !i3(e)) : r = !e.has(Dr), r && (e.add(Dr), Dr.deps.push(e), Dr.onTrack && Dr.onTrack(
    It(
      {
        effect: Dr
      },
      t
    )
  ));
}
function Ai(e, t, r, n, o, s) {
  const a = h1.get(e);
  if (!a)
    return;
  let l = [];
  if (t === "clear")
    l = [...a.values()];
  else if (r === "length" && qe(e)) {
    const f = Number(n);
    a.forEach((c, d) => {
      (d === "length" || d >= f) && l.push(c);
    });
  } else
    switch (r !== void 0 && l.push(a.get(r)), t) {
      case "add":
        qe(e) ? ME(r) && l.push(a.get("length")) : (l.push(a.get(ia)), na(e) && l.push(a.get(g1)));
        break;
      case "delete":
        qe(e) || (l.push(a.get(ia)), na(e) && l.push(a.get(g1)));
        break;
      case "set":
        na(e) && l.push(a.get(ia));
        break;
    }
  const u = { target: e, type: t, key: r, newValue: n, oldValue: o, oldTarget: s };
  if (l.length === 1)
    l[0] && b1(l[0], u);
  else {
    const f = [];
    for (const c of l)
      c && f.push(...c);
    b1(NE(f), u);
  }
}
function b1(e, t) {
  const r = qe(e) ? e : [...e];
  for (const n of r)
    n.computed && IA(n, t);
  for (const n of r)
    n.computed || IA(n, t);
}
function IA(e, t) {
  (e !== Dr || e.allowRecurse) && (e.onTrigger && e.onTrigger(It({ effect: e }, t)), e.scheduler ? e.scheduler() : e.run());
}
const DW = /* @__PURE__ */ bs("__proto__,__v_isRef,__isVue"), l3 = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(CE)
), FW = /* @__PURE__ */ ip(), jW = /* @__PURE__ */ ip(!1, !0), BW = /* @__PURE__ */ ip(!0), qW = /* @__PURE__ */ ip(!0, !0), MA = /* @__PURE__ */ WW();
function WW() {
  const e = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((t) => {
    e[t] = function(...r) {
      const n = Fe(this);
      for (let s = 0, a = this.length; s < a; s++)
        Cr(n, "get", s + "");
      const o = n[t](...r);
      return o === -1 || o === !1 ? n[t](...r.map(Fe)) : o;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((t) => {
    e[t] = function(...r) {
      Pa();
      const n = Fe(this)[t].apply(this, r);
      return Da(), n;
    };
  }), e;
}
function UW(e) {
  const t = Fe(this);
  return Cr(t, "has", e), t.hasOwnProperty(e);
}
function ip(e = !1, t = !1) {
  return function(n, o, s) {
    if (o === "__v_isReactive")
      return !e;
    if (o === "__v_isReadonly")
      return e;
    if (o === "__v_isShallow")
      return t;
    if (o === "__v_raw" && s === (e ? t ? b3 : g3 : t ? p3 : h3).get(n))
      return n;
    const a = qe(n);
    if (!e) {
      if (a && at(MA, o))
        return Reflect.get(MA, o, s);
      if (o === "hasOwnProperty")
        return UW;
    }
    const l = Reflect.get(n, o, s);
    return (CE(o) ? l3.has(o) : DW(o)) || (e || Cr(n, "get", o), t) ? l : rr(l) ? a && ME(o) ? l : l.value : vt(l) ? e ? y3(l) : ap(l) : l;
  };
}
const HW = /* @__PURE__ */ u3(), zW = /* @__PURE__ */ u3(!0);
function u3(e = !1) {
  return function(r, n, o, s) {
    let a = r[n];
    if (ss(a) && rr(a) && !rr(o))
      return !1;
    if (!e && (!ih(o) && !ss(o) && (a = Fe(a), o = Fe(o)), !qe(r) && rr(a) && !rr(o)))
      return a.value = o, !0;
    const l = qe(r) && ME(n) ? Number(n) < r.length : at(r, n), u = Reflect.set(r, n, o, s);
    return r === Fe(s) && (l ? Lf(o, a) && Ai(r, "set", n, o, a) : Ai(r, "add", n, o)), u;
  };
}
function GW(e, t) {
  const r = at(e, t), n = e[t], o = Reflect.deleteProperty(e, t);
  return o && r && Ai(e, "delete", t, void 0, n), o;
}
function VW(e, t) {
  const r = Reflect.has(e, t);
  return (!CE(t) || !l3.has(t)) && Cr(e, "has", t), r;
}
function KW(e) {
  return Cr(e, "iterate", qe(e) ? "length" : ia), Reflect.ownKeys(e);
}
const f3 = {
  get: FW,
  set: HW,
  deleteProperty: GW,
  has: VW,
  ownKeys: KW
}, c3 = {
  get: BW,
  set(e, t) {
    return d1(
      `Set operation on key "${String(t)}" failed: target is readonly.`,
      e
    ), !0;
  },
  deleteProperty(e, t) {
    return d1(
      `Delete operation on key "${String(t)}" failed: target is readonly.`,
      e
    ), !0;
  }
}, YW = /* @__PURE__ */ It(
  {},
  f3,
  {
    get: jW,
    set: zW
  }
), XW = /* @__PURE__ */ It(
  {},
  c3,
  {
    get: qW
  }
), OE = (e) => e, op = (e) => Reflect.getPrototypeOf(e);
function jc(e, t, r = !1, n = !1) {
  e = e.__v_raw;
  const o = Fe(e), s = Fe(t);
  r || (t !== s && Cr(o, "get", t), Cr(o, "get", s));
  const { has: a } = op(o), l = n ? OE : r ? PE : Of;
  if (a.call(o, t))
    return l(e.get(t));
  if (a.call(o, s))
    return l(e.get(s));
  e !== o && e.get(t);
}
function Bc(e, t = !1) {
  const r = this.__v_raw, n = Fe(r), o = Fe(e);
  return t || (e !== o && Cr(n, "has", e), Cr(n, "has", o)), e === o ? r.has(e) : r.has(e) || r.has(o);
}
function qc(e, t = !1) {
  return e = e.__v_raw, !t && Cr(Fe(e), "iterate", ia), Reflect.get(e, "size", e);
}
function NA(e) {
  e = Fe(e);
  const t = Fe(this);
  return op(t).has.call(t, e) || (t.add(e), Ai(t, "add", e, e)), this;
}
function LA(e, t) {
  t = Fe(t);
  const r = Fe(this), { has: n, get: o } = op(r);
  let s = n.call(r, e);
  s ? d3(r, n, e) : (e = Fe(e), s = n.call(r, e));
  const a = o.call(r, e);
  return r.set(e, t), s ? Lf(t, a) && Ai(r, "set", e, t, a) : Ai(r, "add", e, t), this;
}
function OA(e) {
  const t = Fe(this), { has: r, get: n } = op(t);
  let o = r.call(t, e);
  o ? d3(t, r, e) : (e = Fe(e), o = r.call(t, e));
  const s = n ? n.call(t, e) : void 0, a = t.delete(e);
  return o && Ai(t, "delete", e, void 0, s), a;
}
function PA() {
  const e = Fe(this), t = e.size !== 0, r = na(e) ? new Map(e) : new Set(e), n = e.clear();
  return t && Ai(e, "clear", void 0, void 0, r), n;
}
function Wc(e, t) {
  return function(n, o) {
    const s = this, a = s.__v_raw, l = Fe(a), u = t ? OE : e ? PE : Of;
    return !e && Cr(l, "iterate", ia), a.forEach((f, c) => n.call(o, u(f), u(c), s));
  };
}
function Uc(e, t, r) {
  return function(...n) {
    const o = this.__v_raw, s = Fe(o), a = na(s), l = e === "entries" || e === Symbol.iterator && a, u = e === "keys" && a, f = o[e](...n), c = r ? OE : t ? PE : Of;
    return !t && Cr(
      s,
      "iterate",
      u ? g1 : ia
    ), {
      // iterator protocol
      next() {
        const { value: d, done: h } = f.next();
        return h ? { value: d, done: h } : {
          value: l ? [c(d[0]), c(d[1])] : c(d),
          done: h
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Io(e) {
  return function(...t) {
    {
      const r = t[0] ? `on key "${t[0]}" ` : "";
      console.warn(
        `${_a(e)} operation ${r}failed: target is readonly.`,
        Fe(this)
      );
    }
    return e === "delete" ? !1 : this;
  };
}
function JW() {
  const e = {
    get(s) {
      return jc(this, s);
    },
    get size() {
      return qc(this);
    },
    has: Bc,
    add: NA,
    set: LA,
    delete: OA,
    clear: PA,
    forEach: Wc(!1, !1)
  }, t = {
    get(s) {
      return jc(this, s, !1, !0);
    },
    get size() {
      return qc(this);
    },
    has: Bc,
    add: NA,
    set: LA,
    delete: OA,
    clear: PA,
    forEach: Wc(!1, !0)
  }, r = {
    get(s) {
      return jc(this, s, !0);
    },
    get size() {
      return qc(this, !0);
    },
    has(s) {
      return Bc.call(this, s, !0);
    },
    add: Io("add"),
    set: Io("set"),
    delete: Io("delete"),
    clear: Io("clear"),
    forEach: Wc(!0, !1)
  }, n = {
    get(s) {
      return jc(this, s, !0, !0);
    },
    get size() {
      return qc(this, !0);
    },
    has(s) {
      return Bc.call(this, s, !0);
    },
    add: Io("add"),
    set: Io("set"),
    delete: Io("delete"),
    clear: Io("clear"),
    forEach: Wc(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((s) => {
    e[s] = Uc(
      s,
      !1,
      !1
    ), r[s] = Uc(
      s,
      !0,
      !1
    ), t[s] = Uc(
      s,
      !1,
      !0
    ), n[s] = Uc(
      s,
      !0,
      !0
    );
  }), [
    e,
    r,
    t,
    n
  ];
}
const [
  QW,
  ZW,
  e4,
  t4
] = /* @__PURE__ */ JW();
function sp(e, t) {
  const r = t ? e ? t4 : e4 : e ? ZW : QW;
  return (n, o, s) => o === "__v_isReactive" ? !e : o === "__v_isReadonly" ? e : o === "__v_raw" ? n : Reflect.get(
    at(r, o) && o in n ? r : n,
    o,
    s
  );
}
const r4 = {
  get: /* @__PURE__ */ sp(!1, !1)
}, n4 = {
  get: /* @__PURE__ */ sp(!1, !0)
}, i4 = {
  get: /* @__PURE__ */ sp(!0, !1)
}, o4 = {
  get: /* @__PURE__ */ sp(!0, !0)
};
function d3(e, t, r) {
  const n = Fe(r);
  if (n !== r && t.call(e, n)) {
    const o = IE(e);
    console.warn(
      `Reactive ${o} contains both the raw and reactive versions of the same object${o === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const h3 = /* @__PURE__ */ new WeakMap(), p3 = /* @__PURE__ */ new WeakMap(), g3 = /* @__PURE__ */ new WeakMap(), b3 = /* @__PURE__ */ new WeakMap();
function s4(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function a4(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : s4(IE(e));
}
function ap(e) {
  return ss(e) ? e : lp(
    e,
    !1,
    f3,
    r4,
    h3
  );
}
function l4(e) {
  return lp(
    e,
    !1,
    YW,
    n4,
    p3
  );
}
function y3(e) {
  return lp(
    e,
    !0,
    c3,
    i4,
    g3
  );
}
function Hu(e) {
  return lp(
    e,
    !0,
    XW,
    o4,
    b3
  );
}
function lp(e, t, r, n, o) {
  if (!vt(e))
    return console.warn(`value cannot be made reactive: ${String(e)}`), e;
  if (e.__v_raw && !(t && e.__v_isReactive))
    return e;
  const s = o.get(e);
  if (s)
    return s;
  const a = a4(e);
  if (a === 0)
    return e;
  const l = new Proxy(
    e,
    a === 2 ? n : r
  );
  return o.set(e, l), l;
}
function oa(e) {
  return ss(e) ? oa(e.__v_raw) : !!(e && e.__v_isReactive);
}
function ss(e) {
  return !!(e && e.__v_isReadonly);
}
function ih(e) {
  return !!(e && e.__v_isShallow);
}
function y1(e) {
  return oa(e) || ss(e);
}
function Fe(e) {
  const t = e && e.__v_raw;
  return t ? Fe(t) : e;
}
function m3(e) {
  return rh(e, "__v_skip", !0), e;
}
const Of = (e) => vt(e) ? ap(e) : e, PE = (e) => vt(e) ? y3(e) : e;
function v3(e) {
  Zo && Dr && (e = Fe(e), a3(e.dep || (e.dep = NE()), {
    target: e,
    type: "get",
    key: "value"
  }));
}
function w3(e, t) {
  e = Fe(e);
  const r = e.dep;
  r && b1(r, {
    target: e,
    type: "set",
    key: "value",
    newValue: t
  });
}
function rr(e) {
  return !!(e && e.__v_isRef === !0);
}
function $e(e) {
  return _3(e, !1);
}
function u4(e) {
  return _3(e, !0);
}
function _3(e, t) {
  return rr(e) ? e : new f4(e, t);
}
class f4 {
  constructor(t, r) {
    this.__v_isShallow = r, this.dep = void 0, this.__v_isRef = !0, this._rawValue = r ? t : Fe(t), this._value = r ? t : Of(t);
  }
  get value() {
    return v3(this), this._value;
  }
  set value(t) {
    const r = this.__v_isShallow || ih(t) || ss(t);
    t = r ? t : Fe(t), Lf(t, this._rawValue) && (this._rawValue = t, this._value = r ? t : Of(t), w3(this, t));
  }
}
function Pe(e) {
  return rr(e) ? e.value : e;
}
const c4 = {
  get: (e, t, r) => Pe(Reflect.get(e, t, r)),
  set: (e, t, r, n) => {
    const o = e[t];
    return rr(o) && !rr(r) ? (o.value = r, !0) : Reflect.set(e, t, r, n);
  }
};
function S3(e) {
  return oa(e) ? e : new Proxy(e, c4);
}
class d4 {
  constructor(t, r, n, o) {
    this._setter = r, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new LE(t, () => {
      this._dirty || (this._dirty = !0, w3(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !o, this.__v_isReadonly = n;
  }
  get value() {
    const t = Fe(this);
    return v3(t), (t._dirty || !t._cacheable) && (t._dirty = !1, t._value = t.effect.run()), t._value;
  }
  set value(t) {
    this._setter(t);
  }
}
function h4(e, t, r = !1) {
  let n, o;
  const s = Xe(e);
  s ? (n = e, o = IW.NODE_ENV !== "production" ? () => {
    console.warn("Write operation failed: computed value is readonly");
  } : jr) : (n = e.get, o = e.set);
  const a = new d4(n, o, s || !o, r);
  return t && !r && (a.effect.onTrack = t.onTrack, a.effect.onTrigger = t.onTrigger), a;
}
var oh = { NODE_ENV: '"production"' };
const sa = [];
function Md(e) {
  sa.push(e);
}
function Nd() {
  sa.pop();
}
function xe(e, ...t) {
  Pa();
  const r = sa.length ? sa[sa.length - 1].component : null, n = r && r.appContext.config.warnHandler, o = p4();
  if (n)
    ro(
      n,
      r,
      11,
      [
        e + t.join(""),
        r && r.proxy,
        o.map(
          ({ vnode: s }) => `at <${bp(r, s.type)}>`
        ).join(`
`),
        o
      ]
    );
  else {
    const s = [`[Vue warn]: ${e}`, ...t];
    o.length && s.push(`
`, ...g4(o)), console.warn(...s);
  }
  Da();
}
function p4() {
  let e = sa[sa.length - 1];
  if (!e)
    return [];
  const t = [];
  for (; e; ) {
    const r = t[0];
    r && r.vnode === e ? r.recurseCount++ : t.push({
      vnode: e,
      recurseCount: 0
    });
    const n = e.component && e.component.parent;
    e = n && n.vnode;
  }
  return t;
}
function g4(e) {
  const t = [];
  return e.forEach((r, n) => {
    t.push(...n === 0 ? [] : [`
`], ...b4(r));
  }), t;
}
function b4({ vnode: e, recurseCount: t }) {
  const r = t > 0 ? `... (${t} recursive calls)` : "", n = e.component ? e.component.parent == null : !1, o = ` at <${bp(
    e.component,
    e.type,
    n
  )}`, s = ">" + r;
  return e.props ? [o, ...y4(e.props), s] : [o + s];
}
function y4(e) {
  const t = [], r = Object.keys(e);
  return r.slice(0, 3).forEach((n) => {
    t.push(...E3(n, e[n]));
  }), r.length > 3 && t.push(" ..."), t;
}
function E3(e, t, r) {
  return Lt(t) ? (t = JSON.stringify(t), r ? t : [`${e}=${t}`]) : typeof t == "number" || typeof t == "boolean" || t == null ? r ? t : [`${e}=${t}`] : rr(t) ? (t = E3(e, Fe(t.value), !0), r ? t : [`${e}=Ref<`, t, ">"]) : Xe(t) ? [`${e}=fn${t.name ? `<${t.name}>` : ""}`] : (t = Fe(t), r ? t : [`${e}=`, t]);
}
function m4(e, t) {
  e !== void 0 && (typeof e != "number" ? xe(`${t} is not a valid number - got ${JSON.stringify(e)}.`) : isNaN(e) && xe(`${t} is NaN - the duration expression might be incorrect.`));
}
const DE = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function ro(e, t, r, n) {
  let o;
  try {
    o = n ? e(...n) : e();
  } catch (s) {
    up(s, t, r);
  }
  return o;
}
function Sn(e, t, r, n) {
  if (Xe(e)) {
    const s = ro(e, t, r, n);
    return s && kE(s) && s.catch((a) => {
      up(a, t, r);
    }), s;
  }
  const o = [];
  for (let s = 0; s < e.length; s++)
    o.push(Sn(e[s], t, r, n));
  return o;
}
function up(e, t, r, n = !0) {
  const o = t ? t.vnode : null;
  if (t) {
    let s = t.parent;
    const a = t.proxy, l = DE[r];
    for (; s; ) {
      const f = s.ec;
      if (f) {
        for (let c = 0; c < f.length; c++)
          if (f[c](e, a, l) === !1)
            return;
      }
      s = s.parent;
    }
    const u = t.appContext.config.errorHandler;
    if (u) {
      ro(
        u,
        null,
        10,
        [e, a, l]
      );
      return;
    }
  }
  v4(e, r, o, n);
}
function v4(e, t, r, n = !0) {
  {
    const o = DE[t];
    if (r && Md(r), xe(`Unhandled error${o ? ` during execution of ${o}` : ""}`), r && Nd(), n)
      throw e;
    console.error(e);
  }
}
let Pf = !1, m1 = !1;
const Ar = [];
let pi = 0;
const $l = [];
let ui = null, Po = 0;
const x3 = /* @__PURE__ */ Promise.resolve();
let FE = null;
const w4 = 100;
function gr(e) {
  const t = FE || x3;
  return e ? t.then(this ? e.bind(this) : e) : t;
}
function _4(e) {
  let t = pi + 1, r = Ar.length;
  for (; t < r; ) {
    const n = t + r >>> 1;
    Df(Ar[n]) < e ? t = n + 1 : r = n;
  }
  return t;
}
function fp(e) {
  (!Ar.length || !Ar.includes(
    e,
    Pf && e.allowRecurse ? pi + 1 : pi
  )) && (e.id == null ? Ar.push(e) : Ar.splice(_4(e.id), 0, e), R3());
}
function R3() {
  !Pf && !m1 && (m1 = !0, FE = x3.then($3));
}
function S4(e) {
  const t = Ar.indexOf(e);
  t > pi && Ar.splice(t, 1);
}
function A3(e) {
  qe(e) ? $l.push(...e) : (!ui || !ui.includes(
    e,
    e.allowRecurse ? Po + 1 : Po
  )) && $l.push(e), R3();
}
function DA(e, t = Pf ? pi + 1 : 0) {
  for (e = e || /* @__PURE__ */ new Map(); t < Ar.length; t++) {
    const r = Ar[t];
    if (r && r.pre) {
      if (jE(e, r))
        continue;
      Ar.splice(t, 1), t--, r();
    }
  }
}
function T3(e) {
  if ($l.length) {
    const t = [...new Set($l)];
    if ($l.length = 0, ui) {
      ui.push(...t);
      return;
    }
    for (ui = t, e = e || /* @__PURE__ */ new Map(), ui.sort((r, n) => Df(r) - Df(n)), Po = 0; Po < ui.length; Po++)
      jE(e, ui[Po]) || ui[Po]();
    ui = null, Po = 0;
  }
}
const Df = (e) => e.id == null ? 1 / 0 : e.id, E4 = (e, t) => {
  const r = Df(e) - Df(t);
  if (r === 0) {
    if (e.pre && !t.pre)
      return -1;
    if (t.pre && !e.pre)
      return 1;
  }
  return r;
};
function $3(e) {
  m1 = !1, Pf = !0, e = e || /* @__PURE__ */ new Map(), Ar.sort(E4);
  const t = (r) => jE(e, r);
  try {
    for (pi = 0; pi < Ar.length; pi++) {
      const r = Ar[pi];
      if (r && r.active !== !1) {
        if (oh.NODE_ENV !== "production" && t(r))
          continue;
        ro(r, null, 14);
      }
    }
  } finally {
    pi = 0, Ar.length = 0, T3(e), Pf = !1, FE = null, (Ar.length || $l.length) && $3(e);
  }
}
function jE(e, t) {
  if (!e.has(t))
    e.set(t, 1);
  else {
    const r = e.get(t);
    if (r > w4) {
      const n = t.ownerInstance, o = n && VE(n.type);
      return xe(
        `Maximum recursive updates exceeded${o ? ` in component <${o}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`
      ), !0;
    } else
      e.set(t, r + 1);
  }
}
let es = !1;
const hl = /* @__PURE__ */ new Set();
nh().__VUE_HMR_RUNTIME__ = {
  createRecord: hb(C3),
  rerender: hb(A4),
  reload: hb(T4)
};
const Sa = /* @__PURE__ */ new Map();
function x4(e) {
  const t = e.type.__hmrId;
  let r = Sa.get(t);
  r || (C3(t, e.type), r = Sa.get(t)), r.instances.add(e);
}
function R4(e) {
  Sa.get(e.type.__hmrId).instances.delete(e);
}
function C3(e, t) {
  return Sa.has(e) ? !1 : (Sa.set(e, {
    initialDef: hf(t),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function hf(e) {
  return oD(e) ? e.__vccOpts : e;
}
function A4(e, t) {
  const r = Sa.get(e);
  r && (r.initialDef.render = t, [...r.instances].forEach((n) => {
    t && (n.render = t, hf(n.type).render = t), n.renderCache = [], es = !0, n.update(), es = !1;
  }));
}
function T4(e, t) {
  const r = Sa.get(e);
  if (!r)
    return;
  t = hf(t), FA(r.initialDef, t);
  const n = [...r.instances];
  for (const o of n) {
    const s = hf(o.type);
    hl.has(s) || (s !== r.initialDef && FA(s, t), hl.add(s)), o.appContext.propsCache.delete(o.type), o.appContext.emitsCache.delete(o.type), o.appContext.optionsCache.delete(o.type), o.ceReload ? (hl.add(s), o.ceReload(t.styles), hl.delete(s)) : o.parent ? fp(o.parent.update) : o.appContext.reload ? o.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    );
  }
  A3(() => {
    for (const o of n)
      hl.delete(
        hf(o.type)
      );
  });
}
function FA(e, t) {
  It(e, t);
  for (const r in e)
    r !== "__file" && !(r in t) && delete e[r];
}
function hb(e) {
  return (t, r) => {
    try {
      return e(t, r);
    } catch (n) {
      console.error(n), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
let gi, zu = [], v1 = !1;
function dc(e, ...t) {
  gi ? gi.emit(e, ...t) : v1 || zu.push({ event: e, args: t });
}
function k3(e, t) {
  var r, n;
  gi = e, gi ? (gi.enabled = !0, zu.forEach(({ event: o, args: s }) => gi.emit(o, ...s)), zu = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  !((n = (r = window.navigator) == null ? void 0 : r.userAgent) != null && n.includes("jsdom")) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((s) => {
    k3(s, t);
  }), setTimeout(() => {
    gi || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, v1 = !0, zu = []);
  }, 3e3)) : (v1 = !0, zu = []);
}
function $4(e, t) {
  dc("app:init", e, t, {
    Fragment: lt,
    Text: pc,
    Comment: ar,
    Static: gf
  });
}
function C4(e) {
  dc("app:unmount", e);
}
const k4 = /* @__PURE__ */ BE(
  "component:added"
  /* COMPONENT_ADDED */
), I3 = /* @__PURE__ */ BE(
  "component:updated"
  /* COMPONENT_UPDATED */
), I4 = /* @__PURE__ */ BE(
  "component:removed"
  /* COMPONENT_REMOVED */
), M4 = (e) => {
  gi && typeof gi.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !gi.cleanupBuffer(e) && I4(e);
};
function BE(e) {
  return (t) => {
    dc(
      e,
      t.appContext.app,
      t.uid,
      t.parent ? t.parent.uid : void 0,
      t
    );
  };
}
const N4 = /* @__PURE__ */ M3(
  "perf:start"
  /* PERFORMANCE_START */
), L4 = /* @__PURE__ */ M3(
  "perf:end"
  /* PERFORMANCE_END */
);
function M3(e) {
  return (t, r, n) => {
    dc(e, t.appContext.app, t.uid, t, r, n);
  };
}
function O4(e, t, r) {
  dc(
    "component:emit",
    e.appContext.app,
    e,
    t,
    r
  );
}
function P4(e, t, ...r) {
  if (e.isUnmounted)
    return;
  const n = e.vnode.props || xt;
  {
    const {
      emitsOptions: c,
      propsOptions: [d]
    } = e;
    if (c)
      if (!(t in c))
        (!d || !(Fs(t) in d)) && xe(
          `Component emitted event "${t}" but it is neither declared in the emits option nor as an "${Fs(t)}" prop.`
        );
      else {
        const h = c[t];
        Xe(h) && (h(...r) || xe(
          `Invalid event arguments: event validation failed for event "${t}".`
        ));
      }
  }
  let o = r;
  const s = t.startsWith("update:"), a = s && t.slice(7);
  if (a && a in n) {
    const c = `${a === "modelValue" ? "model" : a}Modifiers`, { number: d, trim: h } = n[c] || xt;
    h && (o = r.map((p) => Lt(p) ? p.trim() : p)), d && (o = r.map(c1));
  }
  O4(e, t, o);
  {
    const c = t.toLowerCase();
    c !== t && n[Fs(c)] && xe(
      `Event "${c}" is emitted in component ${bp(
        e,
        e.type
      )} but the handler is registered for "${t}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${is(t)}" instead of "${t}".`
    );
  }
  let l, u = n[l = Fs(t)] || // also try camelCase event handler (#2249)
  n[l = Fs(Ri(t))];
  !u && s && (u = n[l = Fs(is(t))]), u && Sn(
    u,
    e,
    6,
    o
  );
  const f = n[l + "Once"];
  if (f) {
    if (!e.emitted)
      e.emitted = {};
    else if (e.emitted[l])
      return;
    e.emitted[l] = !0, Sn(
      f,
      e,
      6,
      o
    );
  }
}
function N3(e, t, r = !1) {
  const n = t.emitsCache, o = n.get(e);
  if (o !== void 0)
    return o;
  const s = e.emits;
  let a = {}, l = !1;
  if (!Xe(e)) {
    const u = (f) => {
      const c = N3(f, t, !0);
      c && (l = !0, It(a, c));
    };
    !r && t.mixins.length && t.mixins.forEach(u), e.extends && u(e.extends), e.mixins && e.mixins.forEach(u);
  }
  return !s && !l ? (vt(e) && n.set(e, null), null) : (qe(s) ? s.forEach((u) => a[u] = null) : It(a, s), vt(e) && n.set(e, a), a);
}
function cp(e, t) {
  return !e || !cc(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), at(e, t[0].toLowerCase() + t.slice(1)) || at(e, is(t)) || at(e, t));
}
let nr = null, dp = null;
function sh(e) {
  const t = nr;
  return nr = e, dp = e && e.type.__scopeId || null, t;
}
function D4(e) {
  dp = e;
}
function F4() {
  dp = null;
}
function Ge(e, t = nr, r) {
  if (!t || e._n)
    return e;
  const n = (...o) => {
    n._d && ZA(-1);
    const s = sh(t);
    let a;
    try {
      a = e(...o);
    } finally {
      sh(s), n._d && ZA(1);
    }
    return I3(t), a;
  };
  return n._n = !0, n._c = !0, n._d = !0, n;
}
let w1 = !1;
function ah() {
  w1 = !0;
}
function pb(e) {
  const {
    type: t,
    vnode: r,
    proxy: n,
    withProxy: o,
    props: s,
    propsOptions: [a],
    slots: l,
    attrs: u,
    emit: f,
    render: c,
    renderCache: d,
    data: h,
    setupState: p,
    ctx: m,
    inheritAttrs: y
  } = e;
  let _, S;
  const x = sh(e);
  w1 = !1;
  try {
    if (r.shapeFlag & 4) {
      const I = o || n;
      _ = Wn(
        c.call(
          I,
          I,
          d,
          s,
          p,
          h,
          m
        )
      ), S = u;
    } else {
      const I = t;
      oh.NODE_ENV !== "production" && u === s && ah(), _ = Wn(
        I.length > 1 ? I(
          s,
          oh.NODE_ENV !== "production" ? {
            get attrs() {
              return ah(), u;
            },
            slots: l,
            emit: f
          } : { attrs: u, slots: l, emit: f }
        ) : I(
          s,
          null
          /* we know it doesn't need it */
        )
      ), S = t.props ? u : B4(u);
    }
  } catch (I) {
    bf.length = 0, up(I, e, 1), _ = Ee(ar);
  }
  let E = _, C;
  if (_.patchFlag > 0 && _.patchFlag & 2048 && ([E, C] = j4(_)), S && y !== !1) {
    const I = Object.keys(S), { shapeFlag: j } = E;
    if (I.length) {
      if (j & 7)
        a && I.some(th) && (S = q4(
          S,
          a
        )), E = Xn(E, S);
      else if (!w1 && E.type !== ar) {
        const J = Object.keys(u), G = [], $ = [];
        for (let V = 0, M = J.length; V < M; V++) {
          const W = J[V];
          cc(W) ? th(W) || G.push(W[2].toLowerCase() + W.slice(3)) : $.push(W);
        }
        $.length && xe(
          `Extraneous non-props attributes (${$.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`
        ), G.length && xe(
          `Extraneous non-emits event listeners (${G.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
        );
      }
    }
  }
  return r.dirs && (jA(E) || xe(
    "Runtime directive used on component with non-element root node. The directives will not function as intended."
  ), E = Xn(E), E.dirs = E.dirs ? E.dirs.concat(r.dirs) : r.dirs), r.transition && (jA(E) || xe(
    "Component inside <Transition> renders non-element root node that cannot be animated."
  ), E.transition = r.transition), C ? C(E) : _ = E, sh(x), _;
}
const j4 = (e) => {
  const t = e.children, r = e.dynamicChildren, n = L3(t);
  if (!n)
    return [e, void 0];
  const o = t.indexOf(n), s = r ? r.indexOf(n) : -1, a = (l) => {
    t[o] = l, r && (s > -1 ? r[s] = l : l.patchFlag > 0 && (e.dynamicChildren = [...r, l]));
  };
  return [Wn(n), a];
};
function L3(e) {
  let t;
  for (let r = 0; r < e.length; r++) {
    const n = e[r];
    if (Wl(n)) {
      if (n.type !== ar || n.children === "v-if") {
        if (t)
          return;
        t = n;
      }
    } else
      return;
  }
  return t;
}
const B4 = (e) => {
  let t;
  for (const r in e)
    (r === "class" || r === "style" || cc(r)) && ((t || (t = {}))[r] = e[r]);
  return t;
}, q4 = (e, t) => {
  const r = {};
  for (const n in e)
    (!th(n) || !(n.slice(9) in t)) && (r[n] = e[n]);
  return r;
}, jA = (e) => e.shapeFlag & 7 || e.type === ar;
function W4(e, t, r) {
  const { props: n, children: o, component: s } = e, { props: a, children: l, patchFlag: u } = t, f = s.emitsOptions;
  if ((o || l) && es || t.dirs || t.transition)
    return !0;
  if (r && u >= 0) {
    if (u & 1024)
      return !0;
    if (u & 16)
      return n ? BA(n, a, f) : !!a;
    if (u & 8) {
      const c = t.dynamicProps;
      for (let d = 0; d < c.length; d++) {
        const h = c[d];
        if (a[h] !== n[h] && !cp(f, h))
          return !0;
      }
    }
  } else
    return (o || l) && (!l || !l.$stable) ? !0 : n === a ? !1 : n ? a ? BA(n, a, f) : !0 : !!a;
  return !1;
}
function BA(e, t, r) {
  const n = Object.keys(t);
  if (n.length !== Object.keys(e).length)
    return !0;
  for (let o = 0; o < n.length; o++) {
    const s = n[o];
    if (t[s] !== e[s] && !cp(r, s))
      return !0;
  }
  return !1;
}
function U4({ vnode: e, parent: t }, r) {
  for (; t && t.subTree === e; )
    (e = t.vnode).el = r, t = t.parent;
}
const H4 = (e) => e.__isSuspense;
function z4(e, t) {
  t && t.pendingBranch ? qe(e) ? t.effects.push(...e) : t.effects.push(e) : A3(e);
}
function Qn(e, t) {
  return qE(e, null, t);
}
const Hc = {};
function br(e, t, r) {
  return Xe(t) || xe(
    "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
  ), qE(e, t, r);
}
function qE(e, t, { immediate: r, deep: n, flush: o, onTrack: s, onTrigger: a } = xt) {
  var l;
  t || (r !== void 0 && xe(
    'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
  ), n !== void 0 && xe(
    'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
  ));
  const u = (I) => {
    xe(
      "Invalid watch source: ",
      I,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  }, f = LW() === ((l = Zt) == null ? void 0 : l.scope) ? Zt : null;
  let c, d = !1, h = !1;
  if (rr(e) ? (c = () => e.value, d = ih(e)) : oa(e) ? (c = () => e, n = !0) : qe(e) ? (h = !0, d = e.some((I) => oa(I) || ih(I)), c = () => e.map((I) => {
    if (rr(I))
      return I.value;
    if (oa(I))
      return Ys(I);
    if (Xe(I))
      return ro(I, f, 2);
    u(I);
  })) : Xe(e) ? t ? c = () => ro(e, f, 2) : c = () => {
    if (!(f && f.isUnmounted))
      return p && p(), Sn(
        e,
        f,
        3,
        [m]
      );
  } : (c = jr, u(e)), t && n) {
    const I = c;
    c = () => Ys(I());
  }
  let p, m = (I) => {
    p = E.onStop = () => {
      ro(I, f, 4);
    };
  }, y;
  if (jf)
    if (m = jr, t ? r && Sn(t, f, 3, [
      c(),
      h ? [] : void 0,
      m
    ]) : c(), o === "sync") {
      const I = nH();
      y = I.__watcherHandles || (I.__watcherHandles = []);
    } else
      return jr;
  let _ = h ? new Array(e.length).fill(Hc) : Hc;
  const S = () => {
    if (E.active)
      if (t) {
        const I = E.run();
        (n || d || (h ? I.some(
          (j, J) => Lf(j, _[J])
        ) : Lf(I, _))) && (p && p(), Sn(t, f, 3, [
          I,
          // pass undefined as the old value when it's changed for the first time
          _ === Hc ? void 0 : h && _[0] === Hc ? [] : _,
          m
        ]), _ = I);
      } else
        E.run();
  };
  S.allowRecurse = !!t;
  let x;
  o === "sync" ? x = S : o === "post" ? x = () => Xr(S, f && f.suspense) : (S.pre = !0, f && (S.id = f.uid), x = () => fp(S));
  const E = new LE(c, x);
  E.onTrack = s, E.onTrigger = a, t ? r ? S() : _ = E.run() : o === "post" ? Xr(
    E.run.bind(E),
    f && f.suspense
  ) : E.run();
  const C = () => {
    E.stop(), f && f.scope && $E(f.scope.effects, E);
  };
  return y && y.push(C), C;
}
function G4(e, t, r) {
  const n = this.proxy, o = Lt(e) ? e.includes(".") ? O3(n, e) : () => n[e] : e.bind(n, n);
  let s;
  Xe(t) ? s = t : (s = t.handler, r = t);
  const a = Zt;
  Ul(this);
  const l = qE(o, s.bind(n), r);
  return a ? Ul(a) : la(), l;
}
function O3(e, t) {
  const r = t.split(".");
  return () => {
    let n = e;
    for (let o = 0; o < r.length && n; o++)
      n = n[r[o]];
    return n;
  };
}
function Ys(e, t) {
  if (!vt(e) || e.__v_skip || (t = t || /* @__PURE__ */ new Set(), t.has(e)))
    return e;
  if (t.add(e), rr(e))
    Ys(e.value, t);
  else if (qe(e))
    for (let r = 0; r < e.length; r++)
      Ys(e[r], t);
  else if (ZP(e) || na(e))
    e.forEach((r) => {
      Ys(r, t);
    });
  else if (t3(e))
    for (const r in e)
      Ys(e[r], t);
  return e;
}
function P3(e) {
  yW(e) && xe("Do not use built-in directive ids as custom directive id: " + e);
}
function Fr(e, t) {
  const r = nr;
  if (r === null)
    return xe("withDirectives can only be used inside render functions."), e;
  const n = gp(r) || r.proxy, o = e.dirs || (e.dirs = []);
  for (let s = 0; s < t.length; s++) {
    let [a, l, u, f = xt] = t[s];
    a && (Xe(a) && (a = {
      mounted: a,
      updated: a
    }), a.deep && Ys(l), o.push({
      dir: a,
      instance: n,
      value: l,
      oldValue: void 0,
      arg: u,
      modifiers: f
    }));
  }
  return e;
}
function Ts(e, t, r, n) {
  const o = e.dirs, s = t && t.dirs;
  for (let a = 0; a < o.length; a++) {
    const l = o[a];
    s && (l.oldValue = s[a].value);
    let u = l.dir[n];
    u && (Pa(), Sn(u, r, 8, [
      e.el,
      l,
      e,
      t
    ]), Da());
  }
}
function V4() {
  const e = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return Dt(() => {
    e.isMounted = !0;
  }), q3(() => {
    e.isUnmounting = !0;
  }), e;
}
const mn = [Function, Array], D3 = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: mn,
  onEnter: mn,
  onAfterEnter: mn,
  onEnterCancelled: mn,
  // leave
  onBeforeLeave: mn,
  onLeave: mn,
  onAfterLeave: mn,
  onLeaveCancelled: mn,
  // appear
  onBeforeAppear: mn,
  onAppear: mn,
  onAfterAppear: mn,
  onAppearCancelled: mn
}, K4 = {
  name: "BaseTransition",
  props: D3,
  setup(e, { slots: t }) {
    const r = GU(), n = V4();
    let o;
    return () => {
      const s = t.default && j3(t.default(), !0);
      if (!s || !s.length)
        return;
      let a = s[0];
      if (s.length > 1) {
        let y = !1;
        for (const _ of s)
          if (_.type !== ar) {
            if (y) {
              xe(
                "<transition> can only be used on a single element or component. Use <transition-group> for lists."
              );
              break;
            }
            a = _, y = !0;
          }
      }
      const l = Fe(e), { mode: u } = l;
      if (u && u !== "in-out" && u !== "out-in" && u !== "default" && xe(`invalid <transition> mode: ${u}`), n.isLeaving)
        return gb(a);
      const f = qA(a);
      if (!f)
        return gb(a);
      const c = _1(
        f,
        l,
        n,
        r
      );
      S1(f, c);
      const d = r.subTree, h = d && qA(d);
      let p = !1;
      const { getTransitionKey: m } = f.type;
      if (m) {
        const y = m();
        o === void 0 ? o = y : y !== o && (o = y, p = !0);
      }
      if (h && h.type !== ar && (!Gs(f, h) || p)) {
        const y = _1(
          h,
          l,
          n,
          r
        );
        if (S1(h, y), u === "out-in")
          return n.isLeaving = !0, y.afterLeave = () => {
            n.isLeaving = !1, r.update.active !== !1 && r.update();
          }, gb(a);
        u === "in-out" && f.type !== ar && (y.delayLeave = (_, S, x) => {
          const E = F3(
            n,
            h
          );
          E[String(h.key)] = h, _._leaveCb = () => {
            S(), _._leaveCb = void 0, delete c.delayedLeave;
          }, c.delayedLeave = x;
        });
      }
      return a;
    };
  }
}, Y4 = K4;
function F3(e, t) {
  const { leavingVNodes: r } = e;
  let n = r.get(t.type);
  return n || (n = /* @__PURE__ */ Object.create(null), r.set(t.type, n)), n;
}
function _1(e, t, r, n) {
  const {
    appear: o,
    mode: s,
    persisted: a = !1,
    onBeforeEnter: l,
    onEnter: u,
    onAfterEnter: f,
    onEnterCancelled: c,
    onBeforeLeave: d,
    onLeave: h,
    onAfterLeave: p,
    onLeaveCancelled: m,
    onBeforeAppear: y,
    onAppear: _,
    onAfterAppear: S,
    onAppearCancelled: x
  } = t, E = String(e.key), C = F3(r, e), I = (G, $) => {
    G && Sn(
      G,
      n,
      9,
      $
    );
  }, j = (G, $) => {
    const V = $[1];
    I(G, $), qe(G) ? G.every((M) => M.length <= 1) && V() : G.length <= 1 && V();
  }, J = {
    mode: s,
    persisted: a,
    beforeEnter(G) {
      let $ = l;
      if (!r.isMounted)
        if (o)
          $ = y || l;
        else
          return;
      G._leaveCb && G._leaveCb(
        !0
        /* cancelled */
      );
      const V = C[E];
      V && Gs(e, V) && V.el._leaveCb && V.el._leaveCb(), I($, [G]);
    },
    enter(G) {
      let $ = u, V = f, M = c;
      if (!r.isMounted)
        if (o)
          $ = _ || u, V = S || f, M = x || c;
        else
          return;
      let W = !1;
      const k = G._enterCb = (U) => {
        W || (W = !0, U ? I(M, [G]) : I(V, [G]), J.delayedLeave && J.delayedLeave(), G._enterCb = void 0);
      };
      $ ? j($, [G, k]) : k();
    },
    leave(G, $) {
      const V = String(e.key);
      if (G._enterCb && G._enterCb(
        !0
        /* cancelled */
      ), r.isUnmounting)
        return $();
      I(d, [G]);
      let M = !1;
      const W = G._leaveCb = (k) => {
        M || (M = !0, $(), k ? I(m, [G]) : I(p, [G]), G._leaveCb = void 0, C[V] === e && delete C[V]);
      };
      C[V] = e, h ? j(h, [G, W]) : W();
    },
    clone(G) {
      return _1(G, t, r, n);
    }
  };
  return J;
}
function gb(e) {
  if (hc(e))
    return e = Xn(e), e.children = null, e;
}
function qA(e) {
  return hc(e) ? e.children ? e.children[0] : void 0 : e;
}
function S1(e, t) {
  e.shapeFlag & 6 && e.component ? S1(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t;
}
function j3(e, t = !1, r) {
  let n = [], o = 0;
  for (let s = 0; s < e.length; s++) {
    let a = e[s];
    const l = r == null ? a.key : String(r) + String(a.key != null ? a.key : s);
    a.type === lt ? (a.patchFlag & 128 && o++, n = n.concat(
      j3(a.children, t, l)
    )) : (t || a.type !== ar) && n.push(l != null ? Xn(a, { key: l }) : a);
  }
  if (o > 1)
    for (let s = 0; s < n.length; s++)
      n[s].patchFlag = -2;
  return n;
}
function nt(e, t) {
  return Xe(e) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    It({ name: e.name }, t, { setup: e })
  ) : e;
}
const pf = (e) => !!e.type.__asyncLoader, hc = (e) => e.type.__isKeepAlive;
function X4(e, t) {
  B3(e, "a", t);
}
function J4(e, t) {
  B3(e, "da", t);
}
function B3(e, t, r = Zt) {
  const n = e.__wdc || (e.__wdc = () => {
    let o = r;
    for (; o; ) {
      if (o.isDeactivated)
        return;
      o = o.parent;
    }
    return e();
  });
  if (hp(t, n, r), r) {
    let o = r.parent;
    for (; o && o.parent; )
      hc(o.parent.vnode) && Q4(n, t, r, o), o = o.parent;
  }
}
function Q4(e, t, r, n) {
  const o = hp(
    t,
    e,
    n,
    !0
    /* prepend */
  );
  xn(() => {
    $E(n[t], o);
  }, r);
}
function hp(e, t, r = Zt, n = !1) {
  if (r) {
    const o = r[e] || (r[e] = []), s = t.__weh || (t.__weh = (...a) => {
      if (r.isUnmounted)
        return;
      Pa(), Ul(r);
      const l = Sn(t, r, e, a);
      return la(), Da(), l;
    });
    return n ? o.unshift(s) : o.push(s), s;
  } else {
    const o = Fs(DE[e].replace(/ hook$/, ""));
    xe(
      `${o} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
const So = (e) => (t, r = Zt) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!jf || e === "sp") && hp(e, (...n) => t(...n), r)
), Z4 = So("bm"), Dt = So("m"), eU = So("bu"), tU = So("u"), q3 = So("bum"), xn = So("um"), rU = So("sp"), nU = So(
  "rtg"
), iU = So(
  "rtc"
);
function oU(e, t = Zt) {
  hp("ec", e, t);
}
const E1 = "components";
function x1(e, t) {
  return aU(E1, e, !0, t) || e;
}
const sU = Symbol.for("v-ndc");
function aU(e, t, r = !0, n = !1) {
  const o = nr || Zt;
  if (o) {
    const s = o.type;
    if (e === E1) {
      const l = VE(
        s,
        !1
        /* do not include inferred name to avoid breaking existing code */
      );
      if (l && (l === t || l === Ri(t) || l === _a(Ri(t))))
        return s;
    }
    const a = (
      // local registration
      // check instance[type] first which is resolved for options API
      WA(o[e] || s[e], t) || // global registration
      WA(o.appContext[e], t)
    );
    if (!a && n)
      return s;
    if (r && !a) {
      const l = e === E1 ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
      xe(`Failed to resolve ${e.slice(0, -1)}: ${t}${l}`);
    }
    return a;
  } else
    xe(
      `resolve${_a(e.slice(0, -1))} can only be used in render() or setup().`
    );
}
function WA(e, t) {
  return e && (e[t] || e[Ri(t)] || e[_a(Ri(t))]);
}
function pr(e, t, r, n) {
  let o;
  const s = r && r[n];
  if (qe(e) || Lt(e)) {
    o = new Array(e.length);
    for (let a = 0, l = e.length; a < l; a++)
      o[a] = t(e[a], a, void 0, s && s[a]);
  } else if (typeof e == "number") {
    Number.isInteger(e) || xe(`The v-for range expect an integer value but got ${e}.`), o = new Array(e);
    for (let a = 0; a < e; a++)
      o[a] = t(a + 1, a, void 0, s && s[a]);
  } else if (vt(e))
    if (e[Symbol.iterator])
      o = Array.from(
        e,
        (a, l) => t(a, l, void 0, s && s[l])
      );
    else {
      const a = Object.keys(e);
      o = new Array(a.length);
      for (let l = 0, u = a.length; l < u; l++) {
        const f = a[l];
        o[l] = t(e[f], f, l, s && s[l]);
      }
    }
  else
    o = [];
  return r && (r[n] = o), o;
}
function io(e, t, r = {}, n, o) {
  if (nr.isCE || nr.parent && pf(nr.parent) && nr.parent.isCE)
    return t !== "default" && (r.name = t), Ee("slot", r, n && n());
  let s = e[t];
  s && s.length > 1 && (xe(
    "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
  ), s = () => []), s && s._c && (s._d = !1), we();
  const a = s && W3(s(r)), l = Et(
    lt,
    {
      key: r.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      a && a.key || `_${t}`
    },
    a || (n ? n() : []),
    a && e._ === 1 ? 64 : -2
  );
  return !o && l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]), s && s._c && (s._d = !0), l;
}
function W3(e) {
  return e.some((t) => Wl(t) ? !(t.type === ar || t.type === lt && !W3(t.children)) : !0) ? e : null;
}
const R1 = (e) => e ? nD(e) ? gp(e) || e.proxy : R1(e.parent) : null, aa = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ It(/* @__PURE__ */ Object.create(null), {
    $: (e) => e,
    $el: (e) => e.vnode.el,
    $data: (e) => e.data,
    $props: (e) => Hu(e.props),
    $attrs: (e) => Hu(e.attrs),
    $slots: (e) => Hu(e.slots),
    $refs: (e) => Hu(e.refs),
    $parent: (e) => R1(e.parent),
    $root: (e) => R1(e.root),
    $emit: (e) => e.emit,
    $options: (e) => UE(e),
    $forceUpdate: (e) => e.f || (e.f = () => fp(e.update)),
    $nextTick: (e) => e.n || (e.n = gr.bind(e.proxy)),
    $watch: (e) => G4.bind(e)
  })
), WE = (e) => e === "_" || e === "$", bb = (e, t) => e !== xt && !e.__isScriptSetup && at(e, t), U3 = {
  get({ _: e }, t) {
    const { ctx: r, setupState: n, data: o, props: s, accessCache: a, type: l, appContext: u } = e;
    if (t === "__isVue")
      return !0;
    let f;
    if (t[0] !== "$") {
      const p = a[t];
      if (p !== void 0)
        switch (p) {
          case 1:
            return n[t];
          case 2:
            return o[t];
          case 4:
            return r[t];
          case 3:
            return s[t];
        }
      else {
        if (bb(n, t))
          return a[t] = 1, n[t];
        if (o !== xt && at(o, t))
          return a[t] = 2, o[t];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (f = e.propsOptions[0]) && at(f, t)
        )
          return a[t] = 3, s[t];
        if (r !== xt && at(r, t))
          return a[t] = 4, r[t];
        A1 && (a[t] = 0);
      }
    }
    const c = aa[t];
    let d, h;
    if (c)
      return t === "$attrs" ? (Cr(e, "get", t), ah()) : t === "$slots" && Cr(e, "get", t), c(e);
    if (
      // css module (injected by vue-loader)
      (d = l.__cssModules) && (d = d[t])
    )
      return d;
    if (r !== xt && at(r, t))
      return a[t] = 4, r[t];
    if (
      // global properties
      h = u.config.globalProperties, at(h, t)
    )
      return h[t];
    nr && (!Lt(t) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    t.indexOf("__v") !== 0) && (o !== xt && WE(t[0]) && at(o, t) ? xe(
      `Property ${JSON.stringify(
        t
      )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
    ) : e === nr && xe(
      `Property ${JSON.stringify(t)} was accessed during render but is not defined on instance.`
    ));
  },
  set({ _: e }, t, r) {
    const { data: n, setupState: o, ctx: s } = e;
    return bb(o, t) ? (o[t] = r, !0) : o.__isScriptSetup && at(o, t) ? (xe(`Cannot mutate <script setup> binding "${t}" from Options API.`), !1) : n !== xt && at(n, t) ? (n[t] = r, !0) : at(e.props, t) ? (xe(`Attempting to mutate prop "${t}". Props are readonly.`), !1) : t[0] === "$" && t.slice(1) in e ? (xe(
      `Attempting to mutate public property "${t}". Properties starting with $ are reserved and readonly.`
    ), !1) : (t in e.appContext.config.globalProperties ? Object.defineProperty(s, t, {
      enumerable: !0,
      configurable: !0,
      value: r
    }) : s[t] = r, !0);
  },
  has({
    _: { data: e, setupState: t, accessCache: r, ctx: n, appContext: o, propsOptions: s }
  }, a) {
    let l;
    return !!r[a] || e !== xt && at(e, a) || bb(t, a) || (l = s[0]) && at(l, a) || at(n, a) || at(aa, a) || at(o.config.globalProperties, a);
  },
  defineProperty(e, t, r) {
    return r.get != null ? e._.accessCache[t] = 0 : at(r, "value") && this.set(e, t, r.value, null), Reflect.defineProperty(e, t, r);
  }
};
U3.ownKeys = (e) => (xe(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(e));
function lU(e) {
  const t = {};
  return Object.defineProperty(t, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => e
  }), Object.keys(aa).forEach((r) => {
    Object.defineProperty(t, r, {
      configurable: !0,
      enumerable: !1,
      get: () => aa[r](e),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: jr
    });
  }), t;
}
function uU(e) {
  const {
    ctx: t,
    propsOptions: [r]
  } = e;
  r && Object.keys(r).forEach((n) => {
    Object.defineProperty(t, n, {
      enumerable: !0,
      configurable: !0,
      get: () => e.props[n],
      set: jr
    });
  });
}
function fU(e) {
  const { ctx: t, setupState: r } = e;
  Object.keys(Fe(r)).forEach((n) => {
    if (!r.__isScriptSetup) {
      if (WE(n[0])) {
        xe(
          `setup() return property ${JSON.stringify(
            n
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(t, n, {
        enumerable: !0,
        configurable: !0,
        get: () => r[n],
        set: jr
      });
    }
  });
}
function UA(e) {
  return qe(e) ? e.reduce(
    (t, r) => (t[r] = null, t),
    {}
  ) : e;
}
function cU() {
  const e = /* @__PURE__ */ Object.create(null);
  return (t, r) => {
    e[r] ? xe(`${t} property "${r}" is already defined in ${e[r]}.`) : e[r] = t;
  };
}
let A1 = !0;
function dU(e) {
  const t = UE(e), r = e.proxy, n = e.ctx;
  A1 = !1, t.beforeCreate && HA(t.beforeCreate, e, "bc");
  const {
    // state
    data: o,
    computed: s,
    methods: a,
    watch: l,
    provide: u,
    inject: f,
    // lifecycle
    created: c,
    beforeMount: d,
    mounted: h,
    beforeUpdate: p,
    updated: m,
    activated: y,
    deactivated: _,
    beforeDestroy: S,
    beforeUnmount: x,
    destroyed: E,
    unmounted: C,
    render: I,
    renderTracked: j,
    renderTriggered: J,
    errorCaptured: G,
    serverPrefetch: $,
    // public API
    expose: V,
    inheritAttrs: M,
    // assets
    components: W,
    directives: k,
    filters: U
  } = t, Z = cU();
  {
    const [te] = e.propsOptions;
    if (te)
      for (const se in te)
        Z("Props", se);
  }
  if (f && hU(f, n, Z), a)
    for (const te in a) {
      const se = a[te];
      Xe(se) ? (Object.defineProperty(n, te, {
        value: se.bind(r),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }), Z("Methods", te)) : xe(
        `Method "${te}" has type "${typeof se}" in the component definition. Did you reference the function correctly?`
      );
    }
  if (o) {
    Xe(o) || xe(
      "The data option must be a function. Plain object usage is no longer supported."
    );
    const te = o.call(r, r);
    if (kE(te) && xe(
      "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
    ), !vt(te))
      xe("data() should return an object.");
    else {
      e.data = ap(te);
      for (const se in te)
        Z("Data", se), WE(se[0]) || Object.defineProperty(n, se, {
          configurable: !0,
          enumerable: !0,
          get: () => te[se],
          set: jr
        });
    }
  }
  if (A1 = !0, s)
    for (const te in s) {
      const se = s[te], fe = Xe(se) ? se.bind(r, r) : Xe(se.get) ? se.get.bind(r, r) : jr;
      fe === jr && xe(`Computed property "${te}" has no getter.`);
      const he = !Xe(se) && Xe(se.set) ? se.set.bind(r) : () => {
        xe(
          `Write operation failed: computed property "${te}" is readonly.`
        );
      }, ae = Ne({
        get: fe,
        set: he
      });
      Object.defineProperty(n, te, {
        enumerable: !0,
        configurable: !0,
        get: () => ae.value,
        set: (be) => ae.value = be
      }), Z("Computed", te);
    }
  if (l)
    for (const te in l)
      H3(l[te], n, r, te);
  if (u) {
    const te = Xe(u) ? u.call(r) : u;
    Reflect.ownKeys(te).forEach((se) => {
      Tn(se, te[se]);
    });
  }
  c && HA(c, e, "c");
  function Y(te, se) {
    qe(se) ? se.forEach((fe) => te(fe.bind(r))) : se && te(se.bind(r));
  }
  if (Y(Z4, d), Y(Dt, h), Y(eU, p), Y(tU, m), Y(X4, y), Y(J4, _), Y(oU, G), Y(iU, j), Y(nU, J), Y(q3, x), Y(xn, C), Y(rU, $), qe(V))
    if (V.length) {
      const te = e.exposed || (e.exposed = {});
      V.forEach((se) => {
        Object.defineProperty(te, se, {
          get: () => r[se],
          set: (fe) => r[se] = fe
        });
      });
    } else
      e.exposed || (e.exposed = {});
  I && e.render === jr && (e.render = I), M != null && (e.inheritAttrs = M), W && (e.components = W), k && (e.directives = k);
}
function hU(e, t, r = jr) {
  qe(e) && (e = T1(e));
  for (const n in e) {
    const o = e[n];
    let s;
    vt(o) ? "default" in o ? s = yr(
      o.from || n,
      o.default,
      !0
      /* treat default function as factory */
    ) : s = yr(o.from || n) : s = yr(o), rr(s) ? Object.defineProperty(t, n, {
      enumerable: !0,
      configurable: !0,
      get: () => s.value,
      set: (a) => s.value = a
    }) : t[n] = s, r("Inject", n);
  }
}
function HA(e, t, r) {
  Sn(
    qe(e) ? e.map((n) => n.bind(t.proxy)) : e.bind(t.proxy),
    t,
    r
  );
}
function H3(e, t, r, n) {
  const o = n.includes(".") ? O3(r, n) : () => r[n];
  if (Lt(e)) {
    const s = t[e];
    Xe(s) ? br(o, s) : xe(`Invalid watch handler specified by key "${e}"`, s);
  } else if (Xe(e))
    br(o, e.bind(r));
  else if (vt(e))
    if (qe(e))
      e.forEach((s) => H3(s, t, r, n));
    else {
      const s = Xe(e.handler) ? e.handler.bind(r) : t[e.handler];
      Xe(s) ? br(o, s, e) : xe(`Invalid watch handler specified by key "${e.handler}"`, s);
    }
  else
    xe(`Invalid watch option: "${n}"`, e);
}
function UE(e) {
  const t = e.type, { mixins: r, extends: n } = t, {
    mixins: o,
    optionsCache: s,
    config: { optionMergeStrategies: a }
  } = e.appContext, l = s.get(t);
  let u;
  return l ? u = l : !o.length && !r && !n ? u = t : (u = {}, o.length && o.forEach(
    (f) => lh(u, f, a, !0)
  ), lh(u, t, a)), vt(t) && s.set(t, u), u;
}
function lh(e, t, r, n = !1) {
  const { mixins: o, extends: s } = t;
  s && lh(e, s, r, !0), o && o.forEach(
    (a) => lh(e, a, r, !0)
  );
  for (const a in t)
    if (n && a === "expose")
      xe(
        '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
      );
    else {
      const l = pU[a] || r && r[a];
      e[a] = l ? l(e[a], t[a]) : t[a];
    }
  return e;
}
const pU = {
  data: zA,
  props: GA,
  emits: GA,
  // objects
  methods: Gu,
  computed: Gu,
  // lifecycle
  beforeCreate: Pr,
  created: Pr,
  beforeMount: Pr,
  mounted: Pr,
  beforeUpdate: Pr,
  updated: Pr,
  beforeDestroy: Pr,
  beforeUnmount: Pr,
  destroyed: Pr,
  unmounted: Pr,
  activated: Pr,
  deactivated: Pr,
  errorCaptured: Pr,
  serverPrefetch: Pr,
  // assets
  components: Gu,
  directives: Gu,
  // watch
  watch: bU,
  // provide / inject
  provide: zA,
  inject: gU
};
function zA(e, t) {
  return t ? e ? function() {
    return It(
      Xe(e) ? e.call(this, this) : e,
      Xe(t) ? t.call(this, this) : t
    );
  } : t : e;
}
function gU(e, t) {
  return Gu(T1(e), T1(t));
}
function T1(e) {
  if (qe(e)) {
    const t = {};
    for (let r = 0; r < e.length; r++)
      t[e[r]] = e[r];
    return t;
  }
  return e;
}
function Pr(e, t) {
  return e ? [...new Set([].concat(e, t))] : t;
}
function Gu(e, t) {
  return e ? It(/* @__PURE__ */ Object.create(null), e, t) : t;
}
function GA(e, t) {
  return e ? qe(e) && qe(t) ? [.../* @__PURE__ */ new Set([...e, ...t])] : It(
    /* @__PURE__ */ Object.create(null),
    UA(e),
    UA(t ?? {})
  ) : t;
}
function bU(e, t) {
  if (!e)
    return t;
  if (!t)
    return e;
  const r = It(/* @__PURE__ */ Object.create(null), e);
  for (const n in t)
    r[n] = Pr(e[n], t[n]);
  return r;
}
function z3() {
  return {
    app: null,
    config: {
      isNativeTag: QP,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let yU = 0;
function mU(e, t) {
  return function(n, o = null) {
    Xe(n) || (n = It({}, n)), o != null && !vt(o) && (xe("root props passed to app.mount() must be an object."), o = null);
    const s = z3();
    Object.defineProperty(s.config, "unwrapInjectedRef", {
      get() {
        return !0;
      },
      set() {
        xe(
          "app.config.unwrapInjectedRef has been deprecated. 3.3 now alawys unwraps injected refs in Options API."
        );
      }
    });
    const a = /* @__PURE__ */ new Set();
    let l = !1;
    const u = s.app = {
      _uid: yU++,
      _component: n,
      _props: o,
      _container: null,
      _context: s,
      _instance: null,
      version: rT,
      get config() {
        return s.config;
      },
      set config(f) {
        xe(
          "app.config cannot be replaced. Modify individual options instead."
        );
      },
      use(f, ...c) {
        return a.has(f) ? xe("Plugin has already been applied to target app.") : f && Xe(f.install) ? (a.add(f), f.install(u, ...c)) : Xe(f) ? (a.add(f), f(u, ...c)) : xe(
          'A plugin must either be a function or an object with an "install" function.'
        ), u;
      },
      mixin(f) {
        return s.mixins.includes(f) ? xe(
          "Mixin has already been applied to target app" + (f.name ? `: ${f.name}` : "")
        ) : s.mixins.push(f), u;
      },
      component(f, c) {
        return M1(f, s.config), c ? (s.components[f] && xe(`Component "${f}" has already been registered in target app.`), s.components[f] = c, u) : s.components[f];
      },
      directive(f, c) {
        return P3(f), c ? (s.directives[f] && xe(`Directive "${f}" has already been registered in target app.`), s.directives[f] = c, u) : s.directives[f];
      },
      mount(f, c, d) {
        if (l)
          xe(
            "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
          );
        else {
          f.__vue_app__ && xe(
            "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
          );
          const h = Ee(
            n,
            o
          );
          return h.appContext = s, s.reload = () => {
            e(Xn(h), f, d);
          }, c && t ? t(h, f) : e(h, f, d), l = !0, u._container = f, f.__vue_app__ = u, u._instance = h.component, $4(u, rT), gp(h.component) || h.component.proxy;
        }
      },
      unmount() {
        l ? (e(null, u._container), u._instance = null, C4(u), delete u._container.__vue_app__) : xe("Cannot unmount an app that is not mounted.");
      },
      provide(f, c) {
        return f in s.provides && xe(
          `App already provides property with key "${String(f)}". It will be overwritten with the new value.`
        ), s.provides[f] = c, u;
      },
      runWithContext(f) {
        uh = u;
        try {
          return f();
        } finally {
          uh = null;
        }
      }
    };
    return u;
  };
}
let uh = null;
function Tn(e, t) {
  if (!Zt)
    xe("provide() can only be used inside setup().");
  else {
    let r = Zt.provides;
    const n = Zt.parent && Zt.parent.provides;
    n === r && (r = Zt.provides = Object.create(n)), r[e] = t;
  }
}
function yr(e, t, r = !1) {
  const n = Zt || nr;
  if (n || uh) {
    const o = n ? n.parent == null ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides : uh._context.provides;
    if (o && e in o)
      return o[e];
    if (arguments.length > 1)
      return r && Xe(t) ? t.call(n && n.proxy) : t;
    xe(`injection "${String(e)}" not found.`);
  } else
    xe("inject() can only be used inside setup() or functional components.");
}
function vU(e, t, r, n = !1) {
  const o = {}, s = {};
  rh(s, pp, 1), e.propsDefaults = /* @__PURE__ */ Object.create(null), G3(e, t, o, s);
  for (const a in e.propsOptions[0])
    a in o || (o[a] = void 0);
  K3(t || {}, o, e), r ? e.props = n ? o : l4(o) : e.type.props ? e.props = o : e.props = s, e.attrs = s;
}
function wU(e) {
  for (; e; ) {
    if (e.type.__hmrId)
      return !0;
    e = e.parent;
  }
}
function _U(e, t, r, n) {
  const {
    props: o,
    attrs: s,
    vnode: { patchFlag: a }
  } = e, l = Fe(o), [u] = e.propsOptions;
  let f = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !wU(e) && (n || a > 0) && !(a & 16)
  ) {
    if (a & 8) {
      const c = e.vnode.dynamicProps;
      for (let d = 0; d < c.length; d++) {
        let h = c[d];
        if (cp(e.emitsOptions, h))
          continue;
        const p = t[h];
        if (u)
          if (at(s, h))
            p !== s[h] && (s[h] = p, f = !0);
          else {
            const m = Ri(h);
            o[m] = $1(
              u,
              l,
              m,
              p,
              e,
              !1
              /* isAbsent */
            );
          }
        else
          p !== s[h] && (s[h] = p, f = !0);
      }
    }
  } else {
    G3(e, t, o, s) && (f = !0);
    let c;
    for (const d in l)
      (!t || // for camelCase
      !at(t, d) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((c = is(d)) === d || !at(t, c))) && (u ? r && // for camelCase
      (r[d] !== void 0 || // for kebab-case
      r[c] !== void 0) && (o[d] = $1(
        u,
        l,
        d,
        void 0,
        e,
        !0
        /* isAbsent */
      )) : delete o[d]);
    if (s !== l)
      for (const d in s)
        (!t || !at(t, d)) && (delete s[d], f = !0);
  }
  f && Ai(e, "set", "$attrs"), K3(t || {}, o, e);
}
function G3(e, t, r, n) {
  const [o, s] = e.propsOptions;
  let a = !1, l;
  if (t)
    for (let u in t) {
      if (Id(u))
        continue;
      const f = t[u];
      let c;
      o && at(o, c = Ri(u)) ? !s || !s.includes(c) ? r[c] = f : (l || (l = {}))[c] = f : cp(e.emitsOptions, u) || (!(u in n) || f !== n[u]) && (n[u] = f, a = !0);
    }
  if (s) {
    const u = Fe(r), f = l || xt;
    for (let c = 0; c < s.length; c++) {
      const d = s[c];
      r[d] = $1(
        o,
        u,
        d,
        f[d],
        e,
        !at(f, d)
      );
    }
  }
  return a;
}
function $1(e, t, r, n, o, s) {
  const a = e[r];
  if (a != null) {
    const l = at(a, "default");
    if (l && n === void 0) {
      const u = a.default;
      if (a.type !== Function && !a.skipFactory && Xe(u)) {
        const { propsDefaults: f } = o;
        r in f ? n = f[r] : (Ul(o), n = f[r] = u.call(
          null,
          t
        ), la());
      } else
        n = u;
    }
    a[
      0
      /* shouldCast */
    ] && (s && !l ? n = !1 : a[
      1
      /* shouldCastTrue */
    ] && (n === "" || n === is(r)) && (n = !0));
  }
  return n;
}
function V3(e, t, r = !1) {
  const n = t.propsCache, o = n.get(e);
  if (o)
    return o;
  const s = e.props, a = {}, l = [];
  let u = !1;
  if (!Xe(e)) {
    const c = (d) => {
      u = !0;
      const [h, p] = V3(d, t, !0);
      It(a, h), p && l.push(...p);
    };
    !r && t.mixins.length && t.mixins.forEach(c), e.extends && c(e.extends), e.mixins && e.mixins.forEach(c);
  }
  if (!s && !u)
    return vt(e) && n.set(e, Tl), Tl;
  if (qe(s))
    for (let c = 0; c < s.length; c++) {
      Lt(s[c]) || xe("props must be strings when using array syntax.", s[c]);
      const d = Ri(s[c]);
      VA(d) && (a[d] = xt);
    }
  else if (s) {
    vt(s) || xe("invalid props options", s);
    for (const c in s) {
      const d = Ri(c);
      if (VA(d)) {
        const h = s[c], p = a[d] = qe(h) || Xe(h) ? { type: h } : It({}, h);
        if (p) {
          const m = YA(Boolean, p.type), y = YA(String, p.type);
          p[
            0
            /* shouldCast */
          ] = m > -1, p[
            1
            /* shouldCastTrue */
          ] = y < 0 || m < y, (m > -1 || at(p, "default")) && l.push(d);
        }
      }
    }
  }
  const f = [a, l];
  return vt(e) && n.set(e, f), f;
}
function VA(e) {
  return e[0] !== "$" ? !0 : (xe(`Invalid prop name: "${e}" is a reserved property.`), !1);
}
function C1(e) {
  const t = e && e.toString().match(/^\s*(function|class) (\w+)/);
  return t ? t[2] : e === null ? "null" : "";
}
function KA(e, t) {
  return C1(e) === C1(t);
}
function YA(e, t) {
  return qe(t) ? t.findIndex((r) => KA(r, e)) : Xe(t) && KA(t, e) ? 0 : -1;
}
function K3(e, t, r) {
  const n = Fe(t), o = r.propsOptions[0];
  for (const s in o) {
    let a = o[s];
    a != null && SU(
      s,
      n[s],
      a,
      !at(e, s) && !at(e, is(s))
    );
  }
}
function SU(e, t, r, n) {
  const { type: o, required: s, validator: a, skipCheck: l } = r;
  if (s && n) {
    xe('Missing required prop: "' + e + '"');
    return;
  }
  if (!(t == null && !s)) {
    if (o != null && o !== !0 && !l) {
      let u = !1;
      const f = qe(o) ? o : [o], c = [];
      for (let d = 0; d < f.length && !u; d++) {
        const { valid: h, expectedType: p } = xU(t, f[d]);
        c.push(p || ""), u = h;
      }
      if (!u) {
        xe(RU(e, t, c));
        return;
      }
    }
    a && !a(t) && xe('Invalid prop: custom validator check failed for prop "' + e + '".');
  }
}
const EU = /* @__PURE__ */ bs(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function xU(e, t) {
  let r;
  const n = C1(t);
  if (EU(n)) {
    const o = typeof e;
    r = o === n.toLowerCase(), !r && o === "object" && (r = e instanceof t);
  } else
    n === "Object" ? r = vt(e) : n === "Array" ? r = qe(e) : n === "null" ? r = e === null : r = e instanceof t;
  return {
    valid: r,
    expectedType: n
  };
}
function RU(e, t, r) {
  let n = `Invalid prop: type check failed for prop "${e}". Expected ${r.map(_a).join(" | ")}`;
  const o = r[0], s = IE(t), a = XA(t, o), l = XA(t, s);
  return r.length === 1 && JA(o) && !AU(o, s) && (n += ` with value ${a}`), n += `, got ${s} `, JA(s) && (n += `with value ${l}.`), n;
}
function XA(e, t) {
  return t === "String" ? `"${e}"` : t === "Number" ? `${Number(e)}` : `${e}`;
}
function JA(e) {
  return ["string", "number", "boolean"].some((r) => e.toLowerCase() === r);
}
function AU(...e) {
  return e.some((t) => t.toLowerCase() === "boolean");
}
const Y3 = (e) => e[0] === "_" || e === "$stable", HE = (e) => qe(e) ? e.map(Wn) : [Wn(e)], TU = (e, t, r) => {
  if (t._n)
    return t;
  const n = Ge((...o) => (oh.NODE_ENV !== "production" && Zt && xe(
    `Slot "${e}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
  ), HE(t(...o))), r);
  return n._c = !1, n;
}, X3 = (e, t, r) => {
  const n = e._ctx;
  for (const o in e) {
    if (Y3(o))
      continue;
    const s = e[o];
    if (Xe(s))
      t[o] = TU(o, s, n);
    else if (s != null) {
      xe(
        `Non-function value encountered for slot "${o}". Prefer function slots for better performance.`
      );
      const a = HE(s);
      t[o] = () => a;
    }
  }
}, J3 = (e, t) => {
  hc(e.vnode) || xe(
    "Non-function value encountered for default slot. Prefer function slots for better performance."
  );
  const r = HE(t);
  e.slots.default = () => r;
}, $U = (e, t) => {
  if (e.vnode.shapeFlag & 32) {
    const r = t._;
    r ? (e.slots = Fe(t), rh(t, "_", r)) : X3(
      t,
      e.slots = {}
    );
  } else
    e.slots = {}, t && J3(e, t);
  rh(e.slots, pp, 1);
}, CU = (e, t, r) => {
  const { vnode: n, slots: o } = e;
  let s = !0, a = xt;
  if (n.shapeFlag & 32) {
    const l = t._;
    l ? es ? (It(o, t), Ai(e, "set", "$slots")) : r && l === 1 ? s = !1 : (It(o, t), !r && l === 1 && delete o._) : (s = !t.$stable, X3(t, o)), a = t;
  } else
    t && (J3(e, t), a = { default: 1 });
  if (s)
    for (const l in o)
      !Y3(l) && !(l in a) && delete o[l];
};
function k1(e, t, r, n, o = !1) {
  if (qe(e)) {
    e.forEach(
      (h, p) => k1(
        h,
        t && (qe(t) ? t[p] : t),
        r,
        n,
        o
      )
    );
    return;
  }
  if (pf(n) && !o)
    return;
  const s = n.shapeFlag & 4 ? gp(n.component) || n.component.proxy : n.el, a = o ? null : s, { i: l, r: u } = e;
  if (!l) {
    xe(
      "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
    );
    return;
  }
  const f = t && t.r, c = l.refs === xt ? l.refs = {} : l.refs, d = l.setupState;
  if (f != null && f !== u && (Lt(f) ? (c[f] = null, at(d, f) && (d[f] = null)) : rr(f) && (f.value = null)), Xe(u))
    ro(u, l, 12, [a, c]);
  else {
    const h = Lt(u), p = rr(u);
    if (h || p) {
      const m = () => {
        if (e.f) {
          const y = h ? at(d, u) ? d[u] : c[u] : u.value;
          o ? qe(y) && $E(y, s) : qe(y) ? y.includes(s) || y.push(s) : h ? (c[u] = [s], at(d, u) && (d[u] = c[u])) : (u.value = [s], e.k && (c[e.k] = u.value));
        } else
          h ? (c[u] = a, at(d, u) && (d[u] = a)) : p ? (u.value = a, e.k && (c[e.k] = a)) : xe("Invalid template ref type:", u, `(${typeof u})`);
      };
      a ? (m.id = -1, Xr(m, r)) : m();
    } else
      xe("Invalid template ref type:", u, `(${typeof u})`);
  }
}
let Cu, Ho;
function Ki(e, t) {
  e.appContext.config.performance && fh() && Ho.mark(`vue-${t}-${e.uid}`), N4(e, t, fh() ? Ho.now() : Date.now());
}
function Yi(e, t) {
  if (e.appContext.config.performance && fh()) {
    const r = `vue-${t}-${e.uid}`, n = r + ":end";
    Ho.mark(n), Ho.measure(
      `<${bp(e, e.type)}> ${t}`,
      r,
      n
    ), Ho.clearMarks(r), Ho.clearMarks(n);
  }
  L4(e, t, fh() ? Ho.now() : Date.now());
}
function fh() {
  return Cu !== void 0 || (typeof window < "u" && window.performance ? (Cu = !0, Ho = window.performance) : Cu = !1), Cu;
}
function kU() {
  const e = [];
  if (e.length) {
    const t = e.length > 1;
    console.warn(
      `Feature flag${t ? "s" : ""} ${e.join(", ")} ${t ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
const Xr = z4;
function IU(e) {
  return MU(e);
}
function MU(e, t) {
  kU();
  const r = nh();
  r.__VUE__ = !0, k3(r.__VUE_DEVTOOLS_GLOBAL_HOOK__, r);
  const {
    insert: n,
    remove: o,
    patchProp: s,
    createElement: a,
    createText: l,
    createComment: u,
    setText: f,
    setElementText: c,
    parentNode: d,
    nextSibling: h,
    setScopeId: p = jr,
    insertStaticContent: m
  } = e, y = (b, w, T, O = null, L = null, ne = null, ue = !1, oe = null, ye = es ? !1 : !!w.dynamicChildren) => {
    if (b === w)
      return;
    b && !Gs(b, w) && (O = ge(b), H(b, L, ne, !0), b = null), w.patchFlag === -2 && (ye = !1, w.dynamicChildren = null);
    const { type: B, ref: me, shapeFlag: Ce } = w;
    switch (B) {
      case pc:
        _(b, w, T, O);
        break;
      case ar:
        S(b, w, T, O);
        break;
      case gf:
        b == null ? x(w, T, O, ue) : E(b, w, T, ue);
        break;
      case lt:
        k(
          b,
          w,
          T,
          O,
          L,
          ne,
          ue,
          oe,
          ye
        );
        break;
      default:
        Ce & 1 ? j(
          b,
          w,
          T,
          O,
          L,
          ne,
          ue,
          oe,
          ye
        ) : Ce & 6 ? U(
          b,
          w,
          T,
          O,
          L,
          ne,
          ue,
          oe,
          ye
        ) : Ce & 64 || Ce & 128 ? B.process(
          b,
          w,
          T,
          O,
          L,
          ne,
          ue,
          oe,
          ye,
          Oe
        ) : xe("Invalid VNode type:", B, `(${typeof B})`);
    }
    me != null && L && k1(me, b && b.ref, ne, w || b, !w);
  }, _ = (b, w, T, O) => {
    if (b == null)
      n(
        w.el = l(w.children),
        T,
        O
      );
    else {
      const L = w.el = b.el;
      w.children !== b.children && f(L, w.children);
    }
  }, S = (b, w, T, O) => {
    b == null ? n(
      w.el = u(w.children || ""),
      T,
      O
    ) : w.el = b.el;
  }, x = (b, w, T, O) => {
    [b.el, b.anchor] = m(
      b.children,
      w,
      T,
      O,
      b.el,
      b.anchor
    );
  }, E = (b, w, T, O) => {
    if (w.children !== b.children) {
      const L = h(b.anchor);
      I(b), [w.el, w.anchor] = m(
        w.children,
        T,
        L,
        O
      );
    } else
      w.el = b.el, w.anchor = b.anchor;
  }, C = ({ el: b, anchor: w }, T, O) => {
    let L;
    for (; b && b !== w; )
      L = h(b), n(b, T, O), b = L;
    n(w, T, O);
  }, I = ({ el: b, anchor: w }) => {
    let T;
    for (; b && b !== w; )
      T = h(b), o(b), b = T;
    o(w);
  }, j = (b, w, T, O, L, ne, ue, oe, ye) => {
    ue = ue || w.type === "svg", b == null ? J(
      w,
      T,
      O,
      L,
      ne,
      ue,
      oe,
      ye
    ) : V(
      b,
      w,
      L,
      ne,
      ue,
      oe,
      ye
    );
  }, J = (b, w, T, O, L, ne, ue, oe) => {
    let ye, B;
    const { type: me, props: Ce, shapeFlag: Ie, transition: Me, dirs: N } = b;
    if (ye = b.el = a(
      b.type,
      ne,
      Ce && Ce.is,
      Ce
    ), Ie & 8 ? c(ye, b.children) : Ie & 16 && $(
      b.children,
      ye,
      null,
      O,
      L,
      ne && me !== "foreignObject",
      ue,
      oe
    ), N && Ts(b, null, O, "created"), G(ye, b, b.scopeId, ue, O), Ce) {
      for (const A in Ce)
        A !== "value" && !Id(A) && s(
          ye,
          A,
          null,
          Ce[A],
          ne,
          b.children,
          O,
          L,
          ee
        );
      "value" in Ce && s(ye, "value", null, Ce.value), (B = Ce.onVnodeBeforeMount) && li(B, O, b);
    }
    Object.defineProperty(ye, "__vnode", {
      value: b,
      enumerable: !1
    }), Object.defineProperty(ye, "__vueParentComponent", {
      value: O,
      enumerable: !1
    }), N && Ts(b, null, O, "beforeMount");
    const R = (!L || L && !L.pendingBranch) && Me && !Me.persisted;
    R && Me.beforeEnter(ye), n(ye, w, T), ((B = Ce && Ce.onVnodeMounted) || R || N) && Xr(() => {
      B && li(B, O, b), R && Me.enter(ye), N && Ts(b, null, O, "mounted");
    }, L);
  }, G = (b, w, T, O, L) => {
    if (T && p(b, T), O)
      for (let ne = 0; ne < O.length; ne++)
        p(b, O[ne]);
    if (L) {
      let ne = L.subTree;
      if (ne.patchFlag > 0 && ne.patchFlag & 2048 && (ne = L3(ne.children) || ne), w === ne) {
        const ue = L.vnode;
        G(
          b,
          ue,
          ue.scopeId,
          ue.slotScopeIds,
          L.parent
        );
      }
    }
  }, $ = (b, w, T, O, L, ne, ue, oe, ye = 0) => {
    for (let B = ye; B < b.length; B++) {
      const me = b[B] = oe ? Do(b[B]) : Wn(b[B]);
      y(
        null,
        me,
        w,
        T,
        O,
        L,
        ne,
        ue,
        oe
      );
    }
  }, V = (b, w, T, O, L, ne, ue) => {
    const oe = w.el = b.el;
    let { patchFlag: ye, dynamicChildren: B, dirs: me } = w;
    ye |= b.patchFlag & 16;
    const Ce = b.props || xt, Ie = w.props || xt;
    let Me;
    T && $s(T, !1), (Me = Ie.onVnodeBeforeUpdate) && li(Me, T, w, b), me && Ts(w, b, T, "beforeUpdate"), T && $s(T, !0), es && (ye = 0, ue = !1, B = null);
    const N = L && w.type !== "foreignObject";
    if (B ? (M(
      b.dynamicChildren,
      B,
      oe,
      T,
      O,
      N,
      ne
    ), ch(b, w)) : ue || fe(
      b,
      w,
      oe,
      null,
      T,
      O,
      N,
      ne,
      !1
    ), ye > 0) {
      if (ye & 16)
        W(
          oe,
          w,
          Ce,
          Ie,
          T,
          O,
          L
        );
      else if (ye & 2 && Ce.class !== Ie.class && s(oe, "class", null, Ie.class, L), ye & 4 && s(oe, "style", Ce.style, Ie.style, L), ye & 8) {
        const R = w.dynamicProps;
        for (let A = 0; A < R.length; A++) {
          const q = R[A], re = Ce[q], ce = Ie[q];
          (ce !== re || q === "value") && s(
            oe,
            q,
            re,
            ce,
            L,
            b.children,
            T,
            O,
            ee
          );
        }
      }
      ye & 1 && b.children !== w.children && c(oe, w.children);
    } else
      !ue && B == null && W(
        oe,
        w,
        Ce,
        Ie,
        T,
        O,
        L
      );
    ((Me = Ie.onVnodeUpdated) || me) && Xr(() => {
      Me && li(Me, T, w, b), me && Ts(w, b, T, "updated");
    }, O);
  }, M = (b, w, T, O, L, ne, ue) => {
    for (let oe = 0; oe < w.length; oe++) {
      const ye = b[oe], B = w[oe], me = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        ye.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (ye.type === lt || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !Gs(ye, B) || // - In the case of a component, it could contain anything.
        ye.shapeFlag & 70) ? d(ye.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          T
        )
      );
      y(
        ye,
        B,
        me,
        null,
        O,
        L,
        ne,
        ue,
        !0
      );
    }
  }, W = (b, w, T, O, L, ne, ue) => {
    if (T !== O) {
      if (T !== xt)
        for (const oe in T)
          !Id(oe) && !(oe in O) && s(
            b,
            oe,
            T[oe],
            null,
            ue,
            w.children,
            L,
            ne,
            ee
          );
      for (const oe in O) {
        if (Id(oe))
          continue;
        const ye = O[oe], B = T[oe];
        ye !== B && oe !== "value" && s(
          b,
          oe,
          B,
          ye,
          ue,
          w.children,
          L,
          ne,
          ee
        );
      }
      "value" in O && s(b, "value", T.value, O.value);
    }
  }, k = (b, w, T, O, L, ne, ue, oe, ye) => {
    const B = w.el = b ? b.el : l(""), me = w.anchor = b ? b.anchor : l("");
    let { patchFlag: Ce, dynamicChildren: Ie, slotScopeIds: Me } = w;
    // #5523 dev root fragment may inherit directives
    (es || Ce & 2048) && (Ce = 0, ye = !1, Ie = null), Me && (oe = oe ? oe.concat(Me) : Me), b == null ? (n(B, T, O), n(me, T, O), $(
      w.children,
      T,
      me,
      L,
      ne,
      ue,
      oe,
      ye
    )) : Ce > 0 && Ce & 64 && Ie && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    b.dynamicChildren ? (M(
      b.dynamicChildren,
      Ie,
      T,
      L,
      ne,
      ue,
      oe
    ), ch(b, w)) : fe(
      b,
      w,
      T,
      me,
      L,
      ne,
      ue,
      oe,
      ye
    );
  }, U = (b, w, T, O, L, ne, ue, oe, ye) => {
    w.slotScopeIds = oe, b == null ? w.shapeFlag & 512 ? L.ctx.activate(
      w,
      T,
      O,
      ue,
      ye
    ) : Z(
      w,
      T,
      O,
      L,
      ne,
      ue,
      ye
    ) : Y(b, w, ye);
  }, Z = (b, w, T, O, L, ne, ue) => {
    const oe = b.component = zU(
      b,
      O,
      L
    );
    if (oe.type.__hmrId && x4(oe), Md(b), Ki(oe, "mount"), hc(b) && (oe.ctx.renderer = Oe), Ki(oe, "init"), KU(oe), Yi(oe, "init"), oe.asyncDep) {
      if (L && L.registerDep(oe, te), !b.el) {
        const ye = oe.subTree = Ee(ar);
        S(null, ye, w, T);
      }
      return;
    }
    te(
      oe,
      b,
      w,
      T,
      L,
      ne,
      ue
    ), Nd(), Yi(oe, "mount");
  }, Y = (b, w, T) => {
    const O = w.component = b.component;
    if (W4(b, w, T))
      if (O.asyncDep && !O.asyncResolved) {
        Md(w), se(O, w, T), Nd();
        return;
      } else
        O.next = w, S4(O.update), O.update();
    else
      w.el = b.el, O.vnode = w;
  }, te = (b, w, T, O, L, ne, ue) => {
    const oe = () => {
      if (b.isMounted) {
        let { next: me, bu: Ce, u: Ie, parent: Me, vnode: N } = b, R = me, A;
        Md(me || b.vnode), $s(b, !1), me ? (me.el = N.el, se(b, me, ue)) : me = N, Ce && dl(Ce), (A = me.props && me.props.onVnodeBeforeUpdate) && li(A, Me, me, N), $s(b, !0), Ki(b, "render");
        const q = pb(b);
        Yi(b, "render");
        const re = b.subTree;
        b.subTree = q, Ki(b, "patch"), y(
          re,
          q,
          // parent may have changed if it's in a teleport
          d(re.el),
          // anchor may have changed if it's in a fragment
          ge(re),
          b,
          L,
          ne
        ), Yi(b, "patch"), me.el = q.el, R === null && U4(b, q.el), Ie && Xr(Ie, L), (A = me.props && me.props.onVnodeUpdated) && Xr(
          () => li(A, Me, me, N),
          L
        ), I3(b), Nd();
      } else {
        let me;
        const { el: Ce, props: Ie } = w, { bm: Me, m: N, parent: R } = b, A = pf(w);
        if ($s(b, !1), Me && dl(Me), !A && (me = Ie && Ie.onVnodeBeforeMount) && li(me, R, w), $s(b, !0), Ce && z) {
          const q = () => {
            Ki(b, "render"), b.subTree = pb(b), Yi(b, "render"), Ki(b, "hydrate"), z(
              Ce,
              b.subTree,
              b,
              L,
              null
            ), Yi(b, "hydrate");
          };
          A ? w.type.__asyncLoader().then(
            // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            () => !b.isUnmounted && q()
          ) : q();
        } else {
          Ki(b, "render");
          const q = b.subTree = pb(b);
          Yi(b, "render"), Ki(b, "patch"), y(
            null,
            q,
            T,
            O,
            b,
            L,
            ne
          ), Yi(b, "patch"), w.el = q.el;
        }
        if (N && Xr(N, L), !A && (me = Ie && Ie.onVnodeMounted)) {
          const q = w;
          Xr(
            () => li(me, R, q),
            L
          );
        }
        (w.shapeFlag & 256 || R && pf(R.vnode) && R.vnode.shapeFlag & 256) && b.a && Xr(b.a, L), b.isMounted = !0, k4(b), w = T = O = null;
      }
    }, ye = b.effect = new LE(
      oe,
      () => fp(B),
      b.scope
      // track it in component's effect scope
    ), B = b.update = () => ye.run();
    B.id = b.uid, $s(b, !0), ye.onTrack = b.rtc ? (me) => dl(b.rtc, me) : void 0, ye.onTrigger = b.rtg ? (me) => dl(b.rtg, me) : void 0, B.ownerInstance = b, B();
  }, se = (b, w, T) => {
    w.component = b;
    const O = b.vnode.props;
    b.vnode = w, b.next = null, _U(b, w.props, O, T), CU(b, w.children, T), Pa(), DA(), Da();
  }, fe = (b, w, T, O, L, ne, ue, oe, ye = !1) => {
    const B = b && b.children, me = b ? b.shapeFlag : 0, Ce = w.children, { patchFlag: Ie, shapeFlag: Me } = w;
    if (Ie > 0) {
      if (Ie & 128) {
        ae(
          B,
          Ce,
          T,
          O,
          L,
          ne,
          ue,
          oe,
          ye
        );
        return;
      } else if (Ie & 256) {
        he(
          B,
          Ce,
          T,
          O,
          L,
          ne,
          ue,
          oe,
          ye
        );
        return;
      }
    }
    Me & 8 ? (me & 16 && ee(B, L, ne), Ce !== B && c(T, Ce)) : me & 16 ? Me & 16 ? ae(
      B,
      Ce,
      T,
      O,
      L,
      ne,
      ue,
      oe,
      ye
    ) : ee(B, L, ne, !0) : (me & 8 && c(T, ""), Me & 16 && $(
      Ce,
      T,
      O,
      L,
      ne,
      ue,
      oe,
      ye
    ));
  }, he = (b, w, T, O, L, ne, ue, oe, ye) => {
    b = b || Tl, w = w || Tl;
    const B = b.length, me = w.length, Ce = Math.min(B, me);
    let Ie;
    for (Ie = 0; Ie < Ce; Ie++) {
      const Me = w[Ie] = ye ? Do(w[Ie]) : Wn(w[Ie]);
      y(
        b[Ie],
        Me,
        T,
        null,
        L,
        ne,
        ue,
        oe,
        ye
      );
    }
    B > me ? ee(
      b,
      L,
      ne,
      !0,
      !1,
      Ce
    ) : $(
      w,
      T,
      O,
      L,
      ne,
      ue,
      oe,
      ye,
      Ce
    );
  }, ae = (b, w, T, O, L, ne, ue, oe, ye) => {
    let B = 0;
    const me = w.length;
    let Ce = b.length - 1, Ie = me - 1;
    for (; B <= Ce && B <= Ie; ) {
      const Me = b[B], N = w[B] = ye ? Do(w[B]) : Wn(w[B]);
      if (Gs(Me, N))
        y(
          Me,
          N,
          T,
          null,
          L,
          ne,
          ue,
          oe,
          ye
        );
      else
        break;
      B++;
    }
    for (; B <= Ce && B <= Ie; ) {
      const Me = b[Ce], N = w[Ie] = ye ? Do(w[Ie]) : Wn(w[Ie]);
      if (Gs(Me, N))
        y(
          Me,
          N,
          T,
          null,
          L,
          ne,
          ue,
          oe,
          ye
        );
      else
        break;
      Ce--, Ie--;
    }
    if (B > Ce) {
      if (B <= Ie) {
        const Me = Ie + 1, N = Me < me ? w[Me].el : O;
        for (; B <= Ie; )
          y(
            null,
            w[B] = ye ? Do(w[B]) : Wn(w[B]),
            T,
            N,
            L,
            ne,
            ue,
            oe,
            ye
          ), B++;
      }
    } else if (B > Ie)
      for (; B <= Ce; )
        H(b[B], L, ne, !0), B++;
    else {
      const Me = B, N = B, R = /* @__PURE__ */ new Map();
      for (B = N; B <= Ie; B++) {
        const ze = w[B] = ye ? Do(w[B]) : Wn(w[B]);
        ze.key != null && (R.has(ze.key) && xe(
          "Duplicate keys found during update:",
          JSON.stringify(ze.key),
          "Make sure keys are unique."
        ), R.set(ze.key, B));
      }
      let A, q = 0;
      const re = Ie - N + 1;
      let ce = !1, de = 0;
      const De = new Array(re);
      for (B = 0; B < re; B++)
        De[B] = 0;
      for (B = Me; B <= Ce; B++) {
        const ze = b[B];
        if (q >= re) {
          H(ze, L, ne, !0);
          continue;
        }
        let Ve;
        if (ze.key != null)
          Ve = R.get(ze.key);
        else
          for (A = N; A <= Ie; A++)
            if (De[A - N] === 0 && Gs(ze, w[A])) {
              Ve = A;
              break;
            }
        Ve === void 0 ? H(ze, L, ne, !0) : (De[Ve - N] = B + 1, Ve >= de ? de = Ve : ce = !0, y(
          ze,
          w[Ve],
          T,
          null,
          L,
          ne,
          ue,
          oe,
          ye
        ), q++);
      }
      const it = ce ? NU(De) : Tl;
      for (A = it.length - 1, B = re - 1; B >= 0; B--) {
        const ze = N + B, Ve = w[ze], Ze = ze + 1 < me ? w[ze + 1].el : O;
        De[B] === 0 ? y(
          null,
          Ve,
          T,
          Ze,
          L,
          ne,
          ue,
          oe,
          ye
        ) : ce && (A < 0 || B !== it[A] ? be(Ve, T, Ze, 2) : A--);
      }
    }
  }, be = (b, w, T, O, L = null) => {
    const { el: ne, type: ue, transition: oe, children: ye, shapeFlag: B } = b;
    if (B & 6) {
      be(b.component.subTree, w, T, O);
      return;
    }
    if (B & 128) {
      b.suspense.move(w, T, O);
      return;
    }
    if (B & 64) {
      ue.move(b, w, T, Oe);
      return;
    }
    if (ue === lt) {
      n(ne, w, T);
      for (let Ce = 0; Ce < ye.length; Ce++)
        be(ye[Ce], w, T, O);
      n(b.anchor, w, T);
      return;
    }
    if (ue === gf) {
      C(b, w, T);
      return;
    }
    if (O !== 2 && B & 1 && oe)
      if (O === 0)
        oe.beforeEnter(ne), n(ne, w, T), Xr(() => oe.enter(ne), L);
      else {
        const { leave: Ce, delayLeave: Ie, afterLeave: Me } = oe, N = () => n(ne, w, T), R = () => {
          Ce(ne, () => {
            N(), Me && Me();
          });
        };
        Ie ? Ie(ne, N, R) : R();
      }
    else
      n(ne, w, T);
  }, H = (b, w, T, O = !1, L = !1) => {
    const {
      type: ne,
      props: ue,
      ref: oe,
      children: ye,
      dynamicChildren: B,
      shapeFlag: me,
      patchFlag: Ce,
      dirs: Ie
    } = b;
    if (oe != null && k1(oe, null, T, b, !0), me & 256) {
      w.ctx.deactivate(b);
      return;
    }
    const Me = me & 1 && Ie, N = !pf(b);
    let R;
    if (N && (R = ue && ue.onVnodeBeforeUnmount) && li(R, w, b), me & 6)
      le(b.component, T, O);
    else {
      if (me & 128) {
        b.suspense.unmount(T, O);
        return;
      }
      Me && Ts(b, null, w, "beforeUnmount"), me & 64 ? b.type.remove(
        b,
        w,
        T,
        L,
        Oe,
        O
      ) : B && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (ne !== lt || Ce > 0 && Ce & 64) ? ee(
        B,
        w,
        T,
        !1,
        !0
      ) : (ne === lt && Ce & 384 || !L && me & 16) && ee(ye, w, T), O && pe(b);
    }
    (N && (R = ue && ue.onVnodeUnmounted) || Me) && Xr(() => {
      R && li(R, w, b), Me && Ts(b, null, w, "unmounted");
    }, T);
  }, pe = (b) => {
    const { type: w, el: T, anchor: O, transition: L } = b;
    if (w === lt) {
      b.patchFlag > 0 && b.patchFlag & 2048 && L && !L.persisted ? b.children.forEach((ue) => {
        ue.type === ar ? o(ue.el) : pe(ue);
      }) : ke(T, O);
      return;
    }
    if (w === gf) {
      I(b);
      return;
    }
    const ne = () => {
      o(T), L && !L.persisted && L.afterLeave && L.afterLeave();
    };
    if (b.shapeFlag & 1 && L && !L.persisted) {
      const { leave: ue, delayLeave: oe } = L, ye = () => ue(T, ne);
      oe ? oe(b.el, ne, ye) : ye();
    } else
      ne();
  }, ke = (b, w) => {
    let T;
    for (; b !== w; )
      T = h(b), o(b), b = T;
    o(w);
  }, le = (b, w, T) => {
    b.type.__hmrId && R4(b);
    const { bum: O, scope: L, update: ne, subTree: ue, um: oe } = b;
    O && dl(O), L.stop(), ne && (ne.active = !1, H(ue, b, w, T)), oe && Xr(oe, w), Xr(() => {
      b.isUnmounted = !0;
    }, w), w && w.pendingBranch && !w.isUnmounted && b.asyncDep && !b.asyncResolved && b.suspenseId === w.pendingId && (w.deps--, w.deps === 0 && w.resolve()), M4(b);
  }, ee = (b, w, T, O = !1, L = !1, ne = 0) => {
    for (let ue = ne; ue < b.length; ue++)
      H(b[ue], w, T, O, L);
  }, ge = (b) => b.shapeFlag & 6 ? ge(b.component.subTree) : b.shapeFlag & 128 ? b.suspense.next() : h(b.anchor || b.el), Ae = (b, w, T) => {
    b == null ? w._vnode && H(w._vnode, null, null, !0) : y(w._vnode || null, b, w, null, null, null, T), DA(), T3(), w._vnode = b;
  }, Oe = {
    p: y,
    um: H,
    m: be,
    r: pe,
    mt: Z,
    mc: $,
    pc: fe,
    pbc: M,
    n: ge,
    o: e
  };
  let K, z;
  return t && ([K, z] = t(
    Oe
  )), {
    render: Ae,
    hydrate: K,
    createApp: mU(Ae, K)
  };
}
function $s({ effect: e, update: t }, r) {
  e.allowRecurse = t.allowRecurse = r;
}
function ch(e, t, r = !1) {
  const n = e.children, o = t.children;
  if (qe(n) && qe(o))
    for (let s = 0; s < n.length; s++) {
      const a = n[s];
      let l = o[s];
      l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = o[s] = Do(o[s]), l.el = a.el), r || ch(a, l)), l.type === pc && (l.el = a.el), l.type === ar && !l.el && (l.el = a.el);
    }
}
function NU(e) {
  const t = e.slice(), r = [0];
  let n, o, s, a, l;
  const u = e.length;
  for (n = 0; n < u; n++) {
    const f = e[n];
    if (f !== 0) {
      if (o = r[r.length - 1], e[o] < f) {
        t[n] = o, r.push(n);
        continue;
      }
      for (s = 0, a = r.length - 1; s < a; )
        l = s + a >> 1, e[r[l]] < f ? s = l + 1 : a = l;
      f < e[r[s]] && (s > 0 && (t[n] = r[s - 1]), r[s] = n);
    }
  }
  for (s = r.length, a = r[s - 1]; s-- > 0; )
    r[s] = a, a = t[a];
  return r;
}
const LU = (e) => e.__isTeleport, Cl = (e) => e && (e.disabled || e.disabled === ""), QA = (e) => typeof SVGElement < "u" && e instanceof SVGElement, I1 = (e, t) => {
  const r = e && e.to;
  if (Lt(r))
    if (t) {
      const n = t(r);
      return n || xe(
        `Failed to locate Teleport target with selector "${r}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
      ), n;
    } else
      return xe(
        "Current renderer does not support string target for Teleports. (missing querySelector renderer option)"
      ), null;
  else
    return !r && !Cl(e) && xe(`Invalid Teleport target: ${r}`), r;
}, OU = {
  __isTeleport: !0,
  process(e, t, r, n, o, s, a, l, u, f) {
    const {
      mc: c,
      pc: d,
      pbc: h,
      o: { insert: p, querySelector: m, createText: y, createComment: _ }
    } = f, S = Cl(t.props);
    let { shapeFlag: x, children: E, dynamicChildren: C } = t;
    if (es && (u = !1, C = null), e == null) {
      const I = t.el = _("teleport start"), j = t.anchor = _("teleport end");
      p(I, r, n), p(j, r, n);
      const J = t.target = I1(t.props, m), G = t.targetAnchor = y("");
      J ? (p(G, J), a = a || QA(J)) : S || xe("Invalid Teleport target on mount:", J, `(${typeof J})`);
      const $ = (V, M) => {
        x & 16 && c(
          E,
          V,
          M,
          o,
          s,
          a,
          l,
          u
        );
      };
      S ? $(r, j) : J && $(J, G);
    } else {
      t.el = e.el;
      const I = t.anchor = e.anchor, j = t.target = e.target, J = t.targetAnchor = e.targetAnchor, G = Cl(e.props), $ = G ? r : j, V = G ? I : J;
      if (a = a || QA(j), C ? (h(
        e.dynamicChildren,
        C,
        $,
        o,
        s,
        a,
        l
      ), ch(e, t, !0)) : u || d(
        e,
        t,
        $,
        V,
        o,
        s,
        a,
        l,
        !1
      ), S)
        G || zc(
          t,
          r,
          I,
          f,
          1
        );
      else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
        const M = t.target = I1(
          t.props,
          m
        );
        M ? zc(
          t,
          M,
          null,
          f,
          0
        ) : xe(
          "Invalid Teleport target on update:",
          j,
          `(${typeof j})`
        );
      } else
        G && zc(
          t,
          j,
          J,
          f,
          1
        );
    }
    Q3(t);
  },
  remove(e, t, r, n, { um: o, o: { remove: s } }, a) {
    const { shapeFlag: l, children: u, anchor: f, targetAnchor: c, target: d, props: h } = e;
    if (d && s(c), (a || !Cl(h)) && (s(f), l & 16))
      for (let p = 0; p < u.length; p++) {
        const m = u[p];
        o(
          m,
          t,
          r,
          !0,
          !!m.dynamicChildren
        );
      }
  },
  move: zc,
  hydrate: PU
};
function zc(e, t, r, { o: { insert: n }, m: o }, s = 2) {
  s === 0 && n(e.targetAnchor, t, r);
  const { el: a, anchor: l, shapeFlag: u, children: f, props: c } = e, d = s === 2;
  if (d && n(a, t, r), (!d || Cl(c)) && u & 16)
    for (let h = 0; h < f.length; h++)
      o(
        f[h],
        t,
        r,
        2
      );
  d && n(l, t, r);
}
function PU(e, t, r, n, o, s, {
  o: { nextSibling: a, parentNode: l, querySelector: u }
}, f) {
  const c = t.target = I1(
    t.props,
    u
  );
  if (c) {
    const d = c._lpa || c.firstChild;
    if (t.shapeFlag & 16)
      if (Cl(t.props))
        t.anchor = f(
          a(e),
          t,
          l(e),
          r,
          n,
          o,
          s
        ), t.targetAnchor = d;
      else {
        t.anchor = a(e);
        let h = d;
        for (; h; )
          if (h = a(h), h && h.nodeType === 8 && h.data === "teleport anchor") {
            t.targetAnchor = h, c._lpa = t.targetAnchor && a(t.targetAnchor);
            break;
          }
        f(
          d,
          t,
          c,
          r,
          n,
          o,
          s
        );
      }
    Q3(t);
  }
  return t.anchor && a(t.anchor);
}
const DU = OU;
function Q3(e) {
  const t = e.ctx;
  if (t && t.ut) {
    let r = e.children[0].el;
    for (; r !== e.targetAnchor; )
      r.nodeType === 1 && r.setAttribute("data-v-owner", t.uid), r = r.nextSibling;
    t.ut();
  }
}
const lt = Symbol.for("v-fgt"), pc = Symbol.for("v-txt"), ar = Symbol.for("v-cmt"), gf = Symbol.for("v-stc"), bf = [];
let zn = null;
function we(e = !1) {
  bf.push(zn = e ? null : []);
}
function FU() {
  bf.pop(), zn = bf[bf.length - 1] || null;
}
let Ff = 1;
function ZA(e) {
  Ff += e;
}
function Z3(e) {
  return e.dynamicChildren = Ff > 0 ? zn || Tl : null, FU(), Ff > 0 && zn && zn.push(e), e;
}
function Te(e, t, r, n, o, s) {
  return Z3(
    ie(
      e,
      t,
      r,
      n,
      o,
      s,
      !0
      /* isBlock */
    )
  );
}
function Et(e, t, r, n, o) {
  return Z3(
    Ee(
      e,
      t,
      r,
      n,
      o,
      !0
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function Wl(e) {
  return e ? e.__v_isVNode === !0 : !1;
}
function Gs(e, t) {
  return t.shapeFlag & 6 && hl.has(t.type) ? (e.shapeFlag &= -257, t.shapeFlag &= -513, !1) : e.type === t.type && e.key === t.key;
}
const jU = (...e) => BU(
  ...e
), pp = "__vInternal", eD = ({ key: e }) => e ?? null, Ld = ({
  ref: e,
  ref_key: t,
  ref_for: r
}) => (typeof e == "number" && (e = "" + e), e != null ? Lt(e) || rr(e) || Xe(e) ? { i: nr, r: e, k: t, f: !!r } : e : null);
function ie(e, t = null, r = null, n = 0, o = null, s = e === lt ? 0 : 1, a = !1, l = !1) {
  const u = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && eD(t),
    ref: t && Ld(t),
    scopeId: dp,
    slotScopeIds: null,
    children: r,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: s,
    patchFlag: n,
    dynamicProps: o,
    dynamicChildren: null,
    appContext: null,
    ctx: nr
  };
  return l ? (zE(u, r), s & 128 && e.normalize(u)) : r && (u.shapeFlag |= Lt(r) ? 8 : 16), u.key !== u.key && xe("VNode created with invalid key (NaN). VNode type:", u.type), Ff > 0 && // avoid a block node from tracking itself
  !a && // has current parent block
  zn && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (u.patchFlag > 0 || s & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  u.patchFlag !== 32 && zn.push(u), u;
}
const Ee = jU;
function BU(e, t = null, r = null, n = 0, o = null, s = !1) {
  if ((!e || e === sU) && (e || xe(`Invalid vnode type when creating vnode: ${e}.`), e = ar), Wl(e)) {
    const l = Xn(
      e,
      t,
      !0
      /* mergeRef: true */
    );
    return r && zE(l, r), Ff > 0 && !s && zn && (l.shapeFlag & 6 ? zn[zn.indexOf(e)] = l : zn.push(l)), l.patchFlag |= -2, l;
  }
  if (oD(e) && (e = e.__vccOpts), t) {
    t = qU(t);
    let { class: l, style: u } = t;
    l && !Lt(l) && (t.class = lr(l)), vt(u) && (y1(u) && !qe(u) && (u = It({}, u)), t.style = np(u));
  }
  const a = Lt(e) ? 1 : H4(e) ? 128 : LU(e) ? 64 : vt(e) ? 4 : Xe(e) ? 2 : 0;
  return a & 4 && y1(e) && (e = Fe(e), xe(
    "Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    e
  )), ie(
    e,
    t,
    r,
    n,
    o,
    a,
    s,
    !0
  );
}
function qU(e) {
  return e ? y1(e) || pp in e ? It({}, e) : e : null;
}
function Xn(e, t, r = !1) {
  const { props: n, ref: o, patchFlag: s, children: a } = e, l = t ? WU(n || {}, t) : n;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e.type,
    props: l,
    key: l && eD(l),
    ref: t && t.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      r && o ? qe(o) ? o.concat(Ld(t)) : [o, Ld(t)] : Ld(t)
    ) : o,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: s === -1 && qe(a) ? a.map(tD) : a,
    target: e.target,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: t && e.type !== lt ? s === -1 ? 16 : s | 16 : s,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: e.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && Xn(e.ssContent),
    ssFallback: e.ssFallback && Xn(e.ssFallback),
    el: e.el,
    anchor: e.anchor,
    ctx: e.ctx,
    ce: e.ce
  };
}
function tD(e) {
  const t = Xn(e);
  return qe(e.children) && (t.children = e.children.map(tD)), t;
}
function tn(e = " ", t = 0) {
  return Ee(pc, null, e, t);
}
function rD(e, t) {
  const r = Ee(gf, null, e);
  return r.staticCount = t, r;
}
function gt(e = "", t = !1) {
  return t ? (we(), Et(ar, null, e)) : Ee(ar, null, e);
}
function Wn(e) {
  return e == null || typeof e == "boolean" ? Ee(ar) : qe(e) ? Ee(
    lt,
    null,
    // #3666, avoid reference pollution when reusing vnode
    e.slice()
  ) : typeof e == "object" ? Do(e) : Ee(pc, null, String(e));
}
function Do(e) {
  return e.el === null && e.patchFlag !== -1 || e.memo ? e : Xn(e);
}
function zE(e, t) {
  let r = 0;
  const { shapeFlag: n } = e;
  if (t == null)
    t = null;
  else if (qe(t))
    r = 16;
  else if (typeof t == "object")
    if (n & 65) {
      const o = t.default;
      o && (o._c && (o._d = !1), zE(e, o()), o._c && (o._d = !0));
      return;
    } else {
      r = 32;
      const o = t._;
      !o && !(pp in t) ? t._ctx = nr : o === 3 && nr && (nr.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024));
    }
  else
    Xe(t) ? (t = { default: t, _ctx: nr }, r = 32) : (t = String(t), n & 64 ? (r = 16, t = [tn(t)]) : r = 8);
  e.children = t, e.shapeFlag |= r;
}
function WU(...e) {
  const t = {};
  for (let r = 0; r < e.length; r++) {
    const n = e[r];
    for (const o in n)
      if (o === "class")
        t.class !== n.class && (t.class = lr([t.class, n.class]));
      else if (o === "style")
        t.style = np([t.style, n.style]);
      else if (cc(o)) {
        const s = t[o], a = n[o];
        a && s !== a && !(qe(s) && s.includes(a)) && (t[o] = s ? [].concat(s, a) : a);
      } else
        o !== "" && (t[o] = n[o]);
  }
  return t;
}
function li(e, t, r, n = null) {
  Sn(e, t, 7, [
    r,
    n
  ]);
}
const UU = z3();
let HU = 0;
function zU(e, t, r) {
  const n = e.type, o = (t ? t.appContext : e.appContext) || UU, s = {
    uid: HU++,
    vnode: e,
    type: n,
    parent: t,
    appContext: o,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new MW(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: t ? t.provides : Object.create(o.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: V3(n, o),
    emitsOptions: N3(n, o),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: xt,
    // inheritAttrs
    inheritAttrs: n.inheritAttrs,
    // state
    ctx: xt,
    data: xt,
    props: xt,
    attrs: xt,
    slots: xt,
    refs: xt,
    setupState: xt,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense: r,
    suspenseId: r ? r.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return s.ctx = lU(s), s.root = t ? t.root : s, s.emit = P4.bind(null, s), e.ce && e.ce(s), s;
}
let Zt = null;
const GU = () => Zt || nr;
let GE, ul, eT = "__VUE_INSTANCE_SETTERS__";
(ul = nh()[eT]) || (ul = nh()[eT] = []), ul.push((e) => Zt = e), GE = (e) => {
  ul.length > 1 ? ul.forEach((t) => t(e)) : ul[0](e);
};
const Ul = (e) => {
  GE(e), e.scope.on();
}, la = () => {
  Zt && Zt.scope.off(), GE(null);
}, VU = /* @__PURE__ */ bs("slot,component");
function M1(e, t) {
  const r = t.isNativeTag || QP;
  (VU(e) || r(e)) && xe(
    "Do not use built-in or reserved HTML elements as component id: " + e
  );
}
function nD(e) {
  return e.vnode.shapeFlag & 4;
}
let jf = !1;
function KU(e, t = !1) {
  jf = t;
  const { props: r, children: n } = e.vnode, o = nD(e);
  vU(e, r, o, t), $U(e, n);
  const s = o ? YU(e, t) : void 0;
  return jf = !1, s;
}
function YU(e, t) {
  var r;
  const n = e.type;
  {
    if (n.name && M1(n.name, e.appContext.config), n.components) {
      const s = Object.keys(n.components);
      for (let a = 0; a < s.length; a++)
        M1(s[a], e.appContext.config);
    }
    if (n.directives) {
      const s = Object.keys(n.directives);
      for (let a = 0; a < s.length; a++)
        P3(s[a]);
    }
    n.compilerOptions && XU() && xe(
      '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
    );
  }
  e.accessCache = /* @__PURE__ */ Object.create(null), e.proxy = m3(new Proxy(e.ctx, U3)), uU(e);
  const { setup: o } = n;
  if (o) {
    const s = e.setupContext = o.length > 1 ? ZU(e) : null;
    Ul(e), Pa();
    const a = ro(
      o,
      e,
      0,
      [Hu(e.props), s]
    );
    if (Da(), la(), kE(a)) {
      if (a.then(la, la), t)
        return a.then((l) => {
          tT(e, l, t);
        }).catch((l) => {
          up(l, e, 0);
        });
      if (e.asyncDep = a, !e.suspense) {
        const l = (r = n.name) != null ? r : "Anonymous";
        xe(
          `Component <${l}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
        );
      }
    } else
      tT(e, a, t);
  } else
    iD(e, t);
}
function tT(e, t, r) {
  Xe(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : vt(t) ? (Wl(t) && xe(
    "setup() should not return VNodes directly - return a render function instead."
  ), e.devtoolsRawSetupState = t, e.setupState = S3(t), fU(e)) : t !== void 0 && xe(
    `setup() should return an object. Received: ${t === null ? "null" : typeof t}`
  ), iD(e, r);
}
let N1;
const XU = () => !N1;
function iD(e, t, r) {
  const n = e.type;
  if (!e.render) {
    if (!t && N1 && !n.render) {
      const o = n.template || UE(e).template;
      if (o) {
        Ki(e, "compile");
        const { isCustomElement: s, compilerOptions: a } = e.appContext.config, { delimiters: l, compilerOptions: u } = n, f = It(
          It(
            {
              isCustomElement: s,
              delimiters: l
            },
            a
          ),
          u
        );
        n.render = N1(o, f), Yi(e, "compile");
      }
    }
    e.render = n.render || jr;
  }
  Ul(e), Pa(), dU(e), Da(), la(), !n.render && e.render === jr && !t && (n.template ? xe(
    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
    /* should not happen */
  ) : xe("Component is missing template or render function."));
}
function JU(e) {
  return e.attrsProxy || (e.attrsProxy = new Proxy(
    e.attrs,
    {
      get(t, r) {
        return ah(), Cr(e, "get", "$attrs"), t[r];
      },
      set() {
        return xe("setupContext.attrs is readonly."), !1;
      },
      deleteProperty() {
        return xe("setupContext.attrs is readonly."), !1;
      }
    }
  ));
}
function QU(e) {
  return e.slotsProxy || (e.slotsProxy = new Proxy(e.slots, {
    get(t, r) {
      return Cr(e, "get", "$slots"), t[r];
    }
  }));
}
function ZU(e) {
  return Object.freeze({
    get attrs() {
      return JU(e);
    },
    get slots() {
      return QU(e);
    },
    get emit() {
      return (r, ...n) => e.emit(r, ...n);
    },
    expose: (r) => {
      if (e.exposed && xe("expose() should be called only once per setup()."), r != null) {
        let n = typeof r;
        n === "object" && (qe(r) ? n = "array" : rr(r) && (n = "ref")), n !== "object" && xe(
          `expose() should be passed a plain object, received ${n}.`
        );
      }
      e.exposed = r || {};
    }
  });
}
function gp(e) {
  if (e.exposed)
    return e.exposeProxy || (e.exposeProxy = new Proxy(S3(m3(e.exposed)), {
      get(t, r) {
        if (r in t)
          return t[r];
        if (r in aa)
          return aa[r](e);
      },
      has(t, r) {
        return r in t || r in aa;
      }
    }));
}
const eH = /(?:^|[-_])(\w)/g, tH = (e) => e.replace(eH, (t) => t.toUpperCase()).replace(/[-_]/g, "");
function VE(e, t = !0) {
  return Xe(e) ? e.displayName || e.name : e.name || t && e.__name;
}
function bp(e, t, r = !1) {
  let n = VE(t);
  if (!n && t.__file) {
    const o = t.__file.match(/([^/\\]+)\.\w+$/);
    o && (n = o[1]);
  }
  if (!n && e && e.parent) {
    const o = (s) => {
      for (const a in s)
        if (s[a] === t)
          return a;
    };
    n = o(
      e.components || e.parent.type.components
    ) || o(e.appContext.components);
  }
  return n ? tH(n) : r ? "App" : "Anonymous";
}
function oD(e) {
  return Xe(e) && "__vccOpts" in e;
}
const Ne = (e, t) => h4(e, t, jf);
function Ut(e, t, r) {
  const n = arguments.length;
  return n === 2 ? vt(t) && !qe(t) ? Wl(t) ? Ee(e, null, [t]) : Ee(e, t) : Ee(e, null, t) : (n > 3 ? r = Array.prototype.slice.call(arguments, 2) : n === 3 && Wl(r) && (r = [r]), Ee(e, t, r));
}
const rH = Symbol.for("v-scx"), nH = () => {
  {
    const e = yr(rH);
    return e || xe(
      "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
    ), e;
  }
};
function yb(e) {
  return !!(e && e.__v_isShallow);
}
function iH() {
  if (typeof window > "u")
    return;
  const e = { style: "color:#3ba776" }, t = { style: "color:#0b1bc9" }, r = { style: "color:#b62e24" }, n = { style: "color:#9d288c" }, o = {
    header(d) {
      return vt(d) ? d.__isVue ? ["div", e, "VueInstance"] : rr(d) ? [
        "div",
        {},
        ["span", e, c(d)],
        "<",
        l(d.value),
        ">"
      ] : oa(d) ? [
        "div",
        {},
        ["span", e, yb(d) ? "ShallowReactive" : "Reactive"],
        "<",
        l(d),
        `>${ss(d) ? " (readonly)" : ""}`
      ] : ss(d) ? [
        "div",
        {},
        ["span", e, yb(d) ? "ShallowReadonly" : "Readonly"],
        "<",
        l(d),
        ">"
      ] : null : null;
    },
    hasBody(d) {
      return d && d.__isVue;
    },
    body(d) {
      if (d && d.__isVue)
        return [
          "div",
          {},
          ...s(d.$)
        ];
    }
  };
  function s(d) {
    const h = [];
    d.type.props && d.props && h.push(a("props", Fe(d.props))), d.setupState !== xt && h.push(a("setup", d.setupState)), d.data !== xt && h.push(a("data", Fe(d.data)));
    const p = u(d, "computed");
    p && h.push(a("computed", p));
    const m = u(d, "inject");
    return m && h.push(a("injected", m)), h.push([
      "div",
      {},
      [
        "span",
        {
          style: n.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: d }]
    ]), h;
  }
  function a(d, h) {
    return h = It({}, h), Object.keys(h).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        d
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(h).map((p) => [
          "div",
          {},
          ["span", n, p + ": "],
          l(h[p], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function l(d, h = !0) {
    return typeof d == "number" ? ["span", t, d] : typeof d == "string" ? ["span", r, JSON.stringify(d)] : typeof d == "boolean" ? ["span", n, d] : vt(d) ? ["object", { object: h ? Fe(d) : d }] : ["span", r, String(d)];
  }
  function u(d, h) {
    const p = d.type;
    if (Xe(p))
      return;
    const m = {};
    for (const y in d.ctx)
      f(p, y, h) && (m[y] = d.ctx[y]);
    return m;
  }
  function f(d, h, p) {
    const m = d[p];
    if (qe(m) && m.includes(h) || vt(m) && h in m || d.extends && f(d.extends, h, p) || d.mixins && d.mixins.some((y) => f(y, h, p)))
      return !0;
  }
  function c(d) {
    return yb(d) ? "ShallowRef" : d.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(o) : window.devtoolsFormatters = [o];
}
const rT = "3.3.4", oH = "http://www.w3.org/2000/svg", Vs = typeof document < "u" ? document : null, nT = Vs && /* @__PURE__ */ Vs.createElement("template"), sH = {
  insert: (e, t, r) => {
    t.insertBefore(e, r || null);
  },
  remove: (e) => {
    const t = e.parentNode;
    t && t.removeChild(e);
  },
  createElement: (e, t, r, n) => {
    const o = t ? Vs.createElementNS(oH, e) : Vs.createElement(e, r ? { is: r } : void 0);
    return e === "select" && n && n.multiple != null && o.setAttribute("multiple", n.multiple), o;
  },
  createText: (e) => Vs.createTextNode(e),
  createComment: (e) => Vs.createComment(e),
  setText: (e, t) => {
    e.nodeValue = t;
  },
  setElementText: (e, t) => {
    e.textContent = t;
  },
  parentNode: (e) => e.parentNode,
  nextSibling: (e) => e.nextSibling,
  querySelector: (e) => Vs.querySelector(e),
  setScopeId(e, t) {
    e.setAttribute(t, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(e, t, r, n, o, s) {
    const a = r ? r.previousSibling : t.lastChild;
    if (o && (o === s || o.nextSibling))
      for (; t.insertBefore(o.cloneNode(!0), r), !(o === s || !(o = o.nextSibling)); )
        ;
    else {
      nT.innerHTML = n ? `<svg>${e}</svg>` : e;
      const l = nT.content;
      if (n) {
        const u = l.firstChild;
        for (; u.firstChild; )
          l.appendChild(u.firstChild);
        l.removeChild(u);
      }
      t.insertBefore(l, r);
    }
    return [
      // first
      a ? a.nextSibling : t.firstChild,
      // last
      r ? r.previousSibling : t.lastChild
    ];
  }
};
function aH(e, t, r) {
  const n = e._vtc;
  n && (t = (t ? [t, ...n] : [...n]).join(" ")), t == null ? e.removeAttribute("class") : r ? e.setAttribute("class", t) : e.className = t;
}
function lH(e, t, r) {
  const n = e.style, o = Lt(r);
  if (r && !o) {
    if (t && !Lt(t))
      for (const s in t)
        r[s] == null && L1(n, s, "");
    for (const s in r)
      L1(n, s, r[s]);
  } else {
    const s = n.display;
    o ? t !== r && (n.cssText = r) : t && e.removeAttribute("style"), "_vod" in e && (n.display = s);
  }
}
const uH = /[^\\];\s*$/, iT = /\s*!important$/;
function L1(e, t, r) {
  if (qe(r))
    r.forEach((n) => L1(e, t, n));
  else if (r == null && (r = ""), uH.test(r) && xe(
    `Unexpected semicolon at the end of '${t}' style value: '${r}'`
  ), t.startsWith("--"))
    e.setProperty(t, r);
  else {
    const n = fH(e, t);
    iT.test(r) ? e.setProperty(
      is(n),
      r.replace(iT, ""),
      "important"
    ) : e[n] = r;
  }
}
const oT = ["Webkit", "Moz", "ms"], mb = {};
function fH(e, t) {
  const r = mb[t];
  if (r)
    return r;
  let n = Ri(t);
  if (n !== "filter" && n in e)
    return mb[t] = n;
  n = _a(n);
  for (let o = 0; o < oT.length; o++) {
    const s = oT[o] + n;
    if (s in e)
      return mb[t] = s;
  }
  return t;
}
const sT = "http://www.w3.org/1999/xlink";
function cH(e, t, r, n, o) {
  if (n && t.startsWith("xlink:"))
    r == null ? e.removeAttributeNS(sT, t.slice(6, t.length)) : e.setAttributeNS(sT, t, r);
  else {
    const s = kW(t);
    r == null || s && !r3(r) ? e.removeAttribute(t) : e.setAttribute(t, s ? "" : r);
  }
}
function dH(e, t, r, n, o, s, a) {
  if (t === "innerHTML" || t === "textContent") {
    n && a(n, o, s), e[t] = r ?? "";
    return;
  }
  const l = e.tagName;
  if (t === "value" && l !== "PROGRESS" && // custom elements may use _value internally
  !l.includes("-")) {
    e._value = r;
    const f = l === "OPTION" ? e.getAttribute("value") : e.value, c = r ?? "";
    f !== c && (e.value = c), r == null && e.removeAttribute(t);
    return;
  }
  let u = !1;
  if (r === "" || r == null) {
    const f = typeof e[t];
    f === "boolean" ? r = r3(r) : r == null && f === "string" ? (r = "", u = !0) : f === "number" && (r = 0, u = !0);
  }
  try {
    e[t] = r;
  } catch (f) {
    u || xe(
      `Failed setting prop "${t}" on <${l.toLowerCase()}>: value ${r} is invalid.`,
      f
    );
  }
  u && e.removeAttribute(t);
}
function pl(e, t, r, n) {
  e.addEventListener(t, r, n);
}
function hH(e, t, r, n) {
  e.removeEventListener(t, r, n);
}
function pH(e, t, r, n, o = null) {
  const s = e._vei || (e._vei = {}), a = s[t];
  if (n && a)
    a.value = n;
  else {
    const [l, u] = gH(t);
    if (n) {
      const f = s[t] = mH(n, o);
      pl(e, l, f, u);
    } else
      a && (hH(e, l, a, u), s[t] = void 0);
  }
}
const aT = /(?:Once|Passive|Capture)$/;
function gH(e) {
  let t;
  if (aT.test(e)) {
    t = {};
    let n;
    for (; n = e.match(aT); )
      e = e.slice(0, e.length - n[0].length), t[n[0].toLowerCase()] = !0;
  }
  return [e[2] === ":" ? e.slice(3) : is(e.slice(2)), t];
}
let vb = 0;
const bH = /* @__PURE__ */ Promise.resolve(), yH = () => vb || (bH.then(() => vb = 0), vb = Date.now());
function mH(e, t) {
  const r = (n) => {
    if (!n._vts)
      n._vts = Date.now();
    else if (n._vts <= r.attached)
      return;
    Sn(
      vH(n, r.value),
      t,
      5,
      [n]
    );
  };
  return r.value = e, r.attached = yH(), r;
}
function vH(e, t) {
  if (qe(t)) {
    const r = e.stopImmediatePropagation;
    return e.stopImmediatePropagation = () => {
      r.call(e), e._stopped = !0;
    }, t.map((n) => (o) => !o._stopped && n && n(o));
  } else
    return t;
}
const lT = /^on[a-z]/, wH = (e, t, r, n, o = !1, s, a, l, u) => {
  t === "class" ? aH(e, n, o) : t === "style" ? lH(e, r, n) : cc(t) ? th(t) || pH(e, t, r, n, a) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : _H(e, t, n, o)) ? dH(
    e,
    t,
    n,
    s,
    a,
    l,
    u
  ) : (t === "true-value" ? e._trueValue = n : t === "false-value" && (e._falseValue = n), cH(e, t, n, o));
};
function _H(e, t, r, n) {
  return n ? !!(t === "innerHTML" || t === "textContent" || t in e && lT.test(t) && Xe(r)) : t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA" || lT.test(t) && Lt(r) ? !1 : t in e;
}
const Mo = "transition", ku = "animation", yp = (e, { slots: t }) => Ut(Y4, SH(e), t);
yp.displayName = "Transition";
const sD = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
yp.props = /* @__PURE__ */ It(
  {},
  D3,
  sD
);
const Cs = (e, t = []) => {
  qe(e) ? e.forEach((r) => r(...t)) : e && e(...t);
}, uT = (e) => e ? qe(e) ? e.some((t) => t.length > 1) : e.length > 1 : !1;
function SH(e) {
  const t = {};
  for (const W in e)
    W in sD || (t[W] = e[W]);
  if (e.css === !1)
    return t;
  const {
    name: r = "v",
    type: n,
    duration: o,
    enterFromClass: s = `${r}-enter-from`,
    enterActiveClass: a = `${r}-enter-active`,
    enterToClass: l = `${r}-enter-to`,
    appearFromClass: u = s,
    appearActiveClass: f = a,
    appearToClass: c = l,
    leaveFromClass: d = `${r}-leave-from`,
    leaveActiveClass: h = `${r}-leave-active`,
    leaveToClass: p = `${r}-leave-to`
  } = e, m = EH(o), y = m && m[0], _ = m && m[1], {
    onBeforeEnter: S,
    onEnter: x,
    onEnterCancelled: E,
    onLeave: C,
    onLeaveCancelled: I,
    onBeforeAppear: j = S,
    onAppear: J = x,
    onAppearCancelled: G = E
  } = t, $ = (W, k, U) => {
    ks(W, k ? c : l), ks(W, k ? f : a), U && U();
  }, V = (W, k) => {
    W._isLeaving = !1, ks(W, d), ks(W, p), ks(W, h), k && k();
  }, M = (W) => (k, U) => {
    const Z = W ? J : x, Y = () => $(k, W, U);
    Cs(Z, [k, Y]), fT(() => {
      ks(k, W ? u : s), No(k, W ? c : l), uT(Z) || cT(k, n, y, Y);
    });
  };
  return It(t, {
    onBeforeEnter(W) {
      Cs(S, [W]), No(W, s), No(W, a);
    },
    onBeforeAppear(W) {
      Cs(j, [W]), No(W, u), No(W, f);
    },
    onEnter: M(!1),
    onAppear: M(!0),
    onLeave(W, k) {
      W._isLeaving = !0;
      const U = () => V(W, k);
      No(W, d), AH(), No(W, h), fT(() => {
        W._isLeaving && (ks(W, d), No(W, p), uT(C) || cT(W, n, _, U));
      }), Cs(C, [W, U]);
    },
    onEnterCancelled(W) {
      $(W, !1), Cs(E, [W]);
    },
    onAppearCancelled(W) {
      $(W, !0), Cs(G, [W]);
    },
    onLeaveCancelled(W) {
      V(W), Cs(I, [W]);
    }
  });
}
function EH(e) {
  if (e == null)
    return null;
  if (vt(e))
    return [wb(e.enter), wb(e.leave)];
  {
    const t = wb(e);
    return [t, t];
  }
}
function wb(e) {
  const t = wW(e);
  return m4(t, "<transition> explicit duration"), t;
}
function No(e, t) {
  t.split(/\s+/).forEach((r) => r && e.classList.add(r)), (e._vtc || (e._vtc = /* @__PURE__ */ new Set())).add(t);
}
function ks(e, t) {
  t.split(/\s+/).forEach((n) => n && e.classList.remove(n));
  const { _vtc: r } = e;
  r && (r.delete(t), r.size || (e._vtc = void 0));
}
function fT(e) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e);
  });
}
let xH = 0;
function cT(e, t, r, n) {
  const o = e._endId = ++xH, s = () => {
    o === e._endId && n();
  };
  if (r)
    return setTimeout(s, r);
  const { type: a, timeout: l, propCount: u } = RH(e, t);
  if (!a)
    return n();
  const f = a + "end";
  let c = 0;
  const d = () => {
    e.removeEventListener(f, h), s();
  }, h = (p) => {
    p.target === e && ++c >= u && d();
  };
  setTimeout(() => {
    c < u && d();
  }, l + 1), e.addEventListener(f, h);
}
function RH(e, t) {
  const r = window.getComputedStyle(e), n = (m) => (r[m] || "").split(", "), o = n(`${Mo}Delay`), s = n(`${Mo}Duration`), a = dT(o, s), l = n(`${ku}Delay`), u = n(`${ku}Duration`), f = dT(l, u);
  let c = null, d = 0, h = 0;
  t === Mo ? a > 0 && (c = Mo, d = a, h = s.length) : t === ku ? f > 0 && (c = ku, d = f, h = u.length) : (d = Math.max(a, f), c = d > 0 ? a > f ? Mo : ku : null, h = c ? c === Mo ? s.length : u.length : 0);
  const p = c === Mo && /\b(transform|all)(,|$)/.test(
    n(`${Mo}Property`).toString()
  );
  return {
    type: c,
    timeout: d,
    propCount: h,
    hasTransform: p
  };
}
function dT(e, t) {
  for (; e.length < t.length; )
    e = e.concat(e);
  return Math.max(...t.map((r, n) => hT(r) + hT(e[n])));
}
function hT(e) {
  return Number(e.slice(0, -1).replace(",", ".")) * 1e3;
}
function AH() {
  return document.body.offsetHeight;
}
const pT = (e) => {
  const t = e.props["onUpdate:modelValue"] || !1;
  return qe(t) ? (r) => dl(t, r) : t;
};
function TH(e) {
  e.target.composing = !0;
}
function gT(e) {
  const t = e.target;
  t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")));
}
const zo = {
  created(e, { modifiers: { lazy: t, trim: r, number: n } }, o) {
    e._assign = pT(o);
    const s = n || o.props && o.props.type === "number";
    pl(e, t ? "change" : "input", (a) => {
      if (a.target.composing)
        return;
      let l = e.value;
      r && (l = l.trim()), s && (l = c1(l)), e._assign(l);
    }), r && pl(e, "change", () => {
      e.value = e.value.trim();
    }), t || (pl(e, "compositionstart", TH), pl(e, "compositionend", gT), pl(e, "change", gT));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(e, { value: t }) {
    e.value = t ?? "";
  },
  beforeUpdate(e, { value: t, modifiers: { lazy: r, trim: n, number: o } }, s) {
    if (e._assign = pT(s), e.composing || document.activeElement === e && e.type !== "range" && (r || n && e.value.trim() === t || (o || e.type === "number") && c1(e.value) === t))
      return;
    const a = t ?? "";
    e.value !== a && (e.value = a);
  }
}, $H = ["ctrl", "shift", "alt", "meta"], CH = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, t) => $H.some((r) => e[`${r}Key`] && !t.includes(r))
}, kH = (e, t) => (r, ...n) => {
  for (let o = 0; o < t.length; o++) {
    const s = CH[t[o]];
    if (s && s(r, t))
      return;
  }
  return e(r, ...n);
}, Ea = {
  beforeMount(e, { value: t }, { transition: r }) {
    e._vod = e.style.display === "none" ? "" : e.style.display, r && t ? r.beforeEnter(e) : Iu(e, t);
  },
  mounted(e, { value: t }, { transition: r }) {
    r && t && r.enter(e);
  },
  updated(e, { value: t, oldValue: r }, { transition: n }) {
    !t != !r && (n ? t ? (n.beforeEnter(e), Iu(e, !0), n.enter(e)) : n.leave(e, () => {
      Iu(e, !1);
    }) : Iu(e, t));
  },
  beforeUnmount(e, { value: t }) {
    Iu(e, t);
  }
};
function Iu(e, t) {
  e.style.display = t ? e._vod : "none";
}
const IH = /* @__PURE__ */ It({ patchProp: wH }, sH);
let bT;
function MH() {
  return bT || (bT = IU(IH));
}
const NH = (...e) => {
  const t = MH().createApp(...e);
  LH(t), OH(t);
  const { mount: r } = t;
  return t.mount = (n) => {
    const o = PH(n);
    if (!o)
      return;
    const s = t._component;
    !Xe(s) && !s.render && !s.template && (s.template = o.innerHTML), o.innerHTML = "";
    const a = r(o, !1, o instanceof SVGElement);
    return o instanceof Element && (o.removeAttribute("v-cloak"), o.setAttribute("data-v-app", "")), a;
  }, t;
};
function LH(e) {
  Object.defineProperty(e.config, "isNativeTag", {
    value: (t) => TW(t) || $W(t),
    writable: !1
  });
}
function OH(e) {
  {
    const t = e.config.isCustomElement;
    Object.defineProperty(e.config, "isCustomElement", {
      get() {
        return t;
      },
      set() {
        xe(
          "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
        );
      }
    });
    const r = e.config.compilerOptions, n = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
    Object.defineProperty(e.config, "compilerOptions", {
      get() {
        return xe(n), r;
      },
      set() {
        xe(n);
      }
    });
  }
}
function PH(e) {
  if (Lt(e)) {
    const t = document.querySelector(e);
    return t || xe(
      `Failed to mount app: mount target selector "${e}" returned null.`
    ), t;
  }
  return window.ShadowRoot && e instanceof window.ShadowRoot && e.mode === "closed" && xe(
    'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
  ), e;
}
function DH() {
  iH();
}
DH();
function FH(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", {
      "fill-rule": "evenodd",
      d: "M11.03 3.97a.75.75 0 010 1.06l-6.22 6.22H21a.75.75 0 010 1.5H4.81l6.22 6.22a.75.75 0 11-1.06 1.06l-7.5-7.5a.75.75 0 010-1.06l7.5-7.5a.75.75 0 011.06 0z",
      "clip-rule": "evenodd"
    })
  ]);
}
function jH(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", {
      "fill-rule": "evenodd",
      d: "M4.755 10.059a7.5 7.5 0 0112.548-3.364l1.903 1.903h-3.183a.75.75 0 100 1.5h4.992a.75.75 0 00.75-.75V4.356a.75.75 0 00-1.5 0v3.18l-1.9-1.9A9 9 0 003.306 9.67a.75.75 0 101.45.388zm15.408 3.352a.75.75 0 00-.919.53 7.5 7.5 0 01-12.548 3.364l-1.902-1.903h3.183a.75.75 0 000-1.5H2.984a.75.75 0 00-.75.75v4.992a.75.75 0 001.5 0v-3.18l1.9 1.9a9 9 0 0015.059-4.035.75.75 0 00-.53-.918z",
      "clip-rule": "evenodd"
    })
  ]);
}
function BH(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", {
      "fill-rule": "evenodd",
      d: "M15.75 2.25H21a.75.75 0 01.75.75v5.25a.75.75 0 01-1.5 0V4.81L8.03 17.03a.75.75 0 01-1.06-1.06L19.19 3.75h-3.44a.75.75 0 010-1.5zm-10.5 4.5a1.5 1.5 0 00-1.5 1.5v10.5a1.5 1.5 0 001.5 1.5h10.5a1.5 1.5 0 001.5-1.5V10.5a.75.75 0 011.5 0v8.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V8.25a3 3 0 013-3h8.25a.75.75 0 010 1.5H5.25z",
      "clip-rule": "evenodd"
    })
  ]);
}
function qH(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", {
      "fill-rule": "evenodd",
      d: "M11.47 2.47a.75.75 0 011.06 0l4.5 4.5a.75.75 0 01-1.06 1.06l-3.22-3.22V16.5a.75.75 0 01-1.5 0V4.81L8.03 8.03a.75.75 0 01-1.06-1.06l4.5-4.5zM3 15.75a.75.75 0 01.75.75v2.25a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5V16.5a.75.75 0 011.5 0v2.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V16.5a.75.75 0 01.75-.75z",
      "clip-rule": "evenodd"
    })
  ]);
}
function WH(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", {
      "fill-rule": "evenodd",
      d: "M3 6.75A.75.75 0 013.75 6h16.5a.75.75 0 010 1.5H3.75A.75.75 0 013 6.75zM3 12a.75.75 0 01.75-.75h16.5a.75.75 0 010 1.5H3.75A.75.75 0 013 12zm0 5.25a.75.75 0 01.75-.75h16.5a.75.75 0 010 1.5H3.75a.75.75 0 01-.75-.75z",
      "clip-rule": "evenodd"
    })
  ]);
}
function UH(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", {
      "fill-rule": "evenodd",
      d: "M19.916 4.626a.75.75 0 01.208 1.04l-9 13.5a.75.75 0 01-1.154.114l-6-6a.75.75 0 011.06-1.06l5.353 5.353 8.493-12.739a.75.75 0 011.04-.208z",
      "clip-rule": "evenodd"
    })
  ]);
}
function HH(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", {
      "fill-rule": "evenodd",
      d: "M7.72 12.53a.75.75 0 010-1.06l7.5-7.5a.75.75 0 111.06 1.06L9.31 12l6.97 6.97a.75.75 0 11-1.06 1.06l-7.5-7.5z",
      "clip-rule": "evenodd"
    })
  ]);
}
function zH(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", {
      "fill-rule": "evenodd",
      d: "M16.28 11.47a.75.75 0 010 1.06l-7.5 7.5a.75.75 0 01-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 011.06-1.06l7.5 7.5z",
      "clip-rule": "evenodd"
    })
  ]);
}
function aD(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", {
      "fill-rule": "evenodd",
      d: "M17.663 3.118c.225.015.45.032.673.05C19.876 3.298 21 4.604 21 6.109v9.642a3 3 0 01-3 3V16.5c0-5.922-4.576-10.775-10.384-11.217.324-1.132 1.3-2.01 2.548-2.114.224-.019.448-.036.673-.051A3 3 0 0113.5 1.5H15a3 3 0 012.663 1.618zM12 4.5A1.5 1.5 0 0113.5 3H15a1.5 1.5 0 011.5 1.5H12z",
      "clip-rule": "evenodd"
    }),
    ie("path", { d: "M3 8.625c0-1.036.84-1.875 1.875-1.875h.375A3.75 3.75 0 019 10.5v1.875c0 1.036.84 1.875 1.875 1.875h1.875A3.75 3.75 0 0116.5 18v2.625c0 1.035-.84 1.875-1.875 1.875h-9.75A1.875 1.875 0 013 20.625v-12z" }),
    ie("path", { d: "M10.5 10.5a5.23 5.23 0 00-1.279-3.434 9.768 9.768 0 016.963 6.963 5.23 5.23 0 00-3.434-1.279h-1.875a.375.375 0 01-.375-.375V10.5z" })
  ]);
}
function GH(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", { d: "M17.004 10.407c.138.435-.216.842-.672.842h-3.465a.75.75 0 01-.65-.375l-1.732-3c-.229-.396-.053-.907.393-1.004a5.252 5.252 0 016.126 3.537zM8.12 8.464c.307-.338.838-.235 1.066.16l1.732 3a.75.75 0 010 .75l-1.732 3.001c-.229.396-.76.498-1.067.16A5.231 5.231 0 016.75 12c0-1.362.519-2.603 1.37-3.536zM10.878 17.13c-.447-.097-.623-.608-.394-1.003l1.733-3.003a.75.75 0 01.65-.375h3.465c.457 0 .81.408.672.843a5.252 5.252 0 01-6.126 3.538z" }),
    ie("path", {
      "fill-rule": "evenodd",
      d: "M21 12.75a.75.75 0 000-1.5h-.783a8.22 8.22 0 00-.237-1.357l.734-.267a.75.75 0 10-.513-1.41l-.735.268a8.24 8.24 0 00-.689-1.191l.6-.504a.75.75 0 10-.964-1.149l-.6.504a8.3 8.3 0 00-1.054-.885l.391-.678a.75.75 0 10-1.299-.75l-.39.677a8.188 8.188 0 00-1.295-.471l.136-.77a.75.75 0 00-1.477-.26l-.136.77a8.364 8.364 0 00-1.377 0l-.136-.77a.75.75 0 10-1.477.26l.136.77c-.448.121-.88.28-1.294.47l-.39-.676a.75.75 0 00-1.3.75l.392.678a8.29 8.29 0 00-1.054.885l-.6-.504a.75.75 0 00-.965 1.149l.6.503a8.243 8.243 0 00-.689 1.192L3.8 8.217a.75.75 0 10-.513 1.41l.735.267a8.222 8.222 0 00-.238 1.355h-.783a.75.75 0 000 1.5h.783c.042.464.122.917.238 1.356l-.735.268a.75.75 0 10.513 1.41l.735-.268c.197.417.428.816.69 1.192l-.6.504a.75.75 0 10.963 1.149l.601-.505c.326.323.679.62 1.054.885l-.392.68a.75.75 0 101.3.75l.39-.679c.414.192.847.35 1.294.471l-.136.771a.75.75 0 101.477.26l.137-.772a8.376 8.376 0 001.376 0l.136.773a.75.75 0 101.477-.26l-.136-.772a8.19 8.19 0 001.294-.47l.391.677a.75.75 0 101.3-.75l-.393-.679a8.282 8.282 0 001.054-.885l.601.504a.75.75 0 10.964-1.15l-.6-.503a8.24 8.24 0 00.69-1.191l.735.268a.75.75 0 10.512-1.41l-.734-.268c.115-.438.195-.892.237-1.356h.784zm-2.657-3.06a6.744 6.744 0 00-1.19-2.053 6.784 6.784 0 00-1.82-1.51A6.704 6.704 0 0012 5.25a6.801 6.801 0 00-1.225.111 6.7 6.7 0 00-2.15.792 6.784 6.784 0 00-2.952 3.489.758.758 0 01-.036.099A6.74 6.74 0 005.251 12a6.739 6.739 0 003.355 5.835l.01.006.01.005a6.706 6.706 0 002.203.802c.007 0 .014.002.021.004a6.792 6.792 0 002.301 0l.022-.004a6.707 6.707 0 002.228-.816 6.781 6.781 0 001.762-1.483l.009-.01.009-.012a6.744 6.744 0 001.18-2.064c.253-.708.39-1.47.39-2.264a6.74 6.74 0 00-.408-2.308z",
      "clip-rule": "evenodd"
    })
  ]);
}
function VH(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", {
      "fill-rule": "evenodd",
      d: "M10.5 6a1.5 1.5 0 113 0 1.5 1.5 0 01-3 0zm0 6a1.5 1.5 0 113 0 1.5 1.5 0 01-3 0zm0 6a1.5 1.5 0 113 0 1.5 1.5 0 01-3 0z",
      "clip-rule": "evenodd"
    })
  ]);
}
function lD(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", { d: "M3.53 2.47a.75.75 0 00-1.06 1.06l18 18a.75.75 0 101.06-1.06l-18-18zM22.676 12.553a11.249 11.249 0 01-2.631 4.31l-3.099-3.099a5.25 5.25 0 00-6.71-6.71L7.759 4.577a11.217 11.217 0 014.242-.827c4.97 0 9.185 3.223 10.675 7.69.12.362.12.752 0 1.113z" }),
    ie("path", { d: "M15.75 12c0 .18-.013.357-.037.53l-4.244-4.243A3.75 3.75 0 0115.75 12zM12.53 15.713l-4.243-4.244a3.75 3.75 0 004.243 4.243z" }),
    ie("path", { d: "M6.75 12c0-.619.107-1.213.304-1.764l-3.1-3.1a11.25 11.25 0 00-2.63 4.31c-.12.362-.12.752 0 1.114 1.489 4.467 5.704 7.69 10.675 7.69 1.5 0 2.933-.294 4.242-.827l-2.477-2.477A5.25 5.25 0 016.75 12z" })
  ]);
}
function KH(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", { d: "M12 15a3 3 0 100-6 3 3 0 000 6z" }),
    ie("path", {
      "fill-rule": "evenodd",
      d: "M1.323 11.447C2.811 6.976 7.028 3.75 12.001 3.75c4.97 0 9.185 3.223 10.675 7.69.12.362.12.752 0 1.113-1.487 4.471-5.705 7.697-10.677 7.697-4.97 0-9.186-3.223-10.675-7.69a1.762 1.762 0 010-1.113zM17.25 12a5.25 5.25 0 11-10.5 0 5.25 5.25 0 0110.5 0z",
      "clip-rule": "evenodd"
    })
  ]);
}
function YH(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", {
      "fill-rule": "evenodd",
      d: "M5.25 12a.75.75 0 01.75-.75h12a.75.75 0 010 1.5H6a.75.75 0 01-.75-.75z",
      "clip-rule": "evenodd"
    })
  ]);
}
function XH(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", {
      "fill-rule": "evenodd",
      d: "M12 5.25a.75.75 0 01.75.75v5.25H18a.75.75 0 010 1.5h-5.25V18a.75.75 0 01-1.5 0v-5.25H6a.75.75 0 010-1.5h5.25V6a.75.75 0 01.75-.75z",
      "clip-rule": "evenodd"
    })
  ]);
}
function JH(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", {
      "fill-rule": "evenodd",
      d: "M1.5 5.625c0-1.036.84-1.875 1.875-1.875h17.25c1.035 0 1.875.84 1.875 1.875v12.75c0 1.035-.84 1.875-1.875 1.875H3.375A1.875 1.875 0 011.5 18.375V5.625zM21 9.375A.375.375 0 0020.625 9h-7.5a.375.375 0 00-.375.375v1.5c0 .207.168.375.375.375h7.5a.375.375 0 00.375-.375v-1.5zm0 3.75a.375.375 0 00-.375-.375h-7.5a.375.375 0 00-.375.375v1.5c0 .207.168.375.375.375h7.5a.375.375 0 00.375-.375v-1.5zm0 3.75a.375.375 0 00-.375-.375h-7.5a.375.375 0 00-.375.375v1.5c0 .207.168.375.375.375h7.5a.375.375 0 00.375-.375v-1.5zM10.875 18.75a.375.375 0 00.375-.375v-1.5a.375.375 0 00-.375-.375h-7.5a.375.375 0 00-.375.375v1.5c0 .207.168.375.375.375h7.5zM3.375 15h7.5a.375.375 0 00.375-.375v-1.5a.375.375 0 00-.375-.375h-7.5a.375.375 0 00-.375.375v1.5c0 .207.168.375.375.375zm0-3.75h7.5a.375.375 0 00.375-.375v-1.5A.375.375 0 0010.875 9h-7.5A.375.375 0 003 9.375v1.5c0 .207.168.375.375.375z",
      "clip-rule": "evenodd"
    })
  ]);
}
function as(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", {
      "fill-rule": "evenodd",
      d: "M5.47 5.47a.75.75 0 011.06 0L12 10.94l5.47-5.47a.75.75 0 111.06 1.06L13.06 12l5.47 5.47a.75.75 0 11-1.06 1.06L12 13.06l-5.47 5.47a.75.75 0 01-1.06-1.06L10.94 12 5.47 6.53a.75.75 0 010-1.06z",
      "clip-rule": "evenodd"
    })
  ]);
}
const Gc = {
  name: "splitpanes",
  emits: ["ready", "resize", "resized", "pane-click", "pane-maximize", "pane-add", "pane-remove", "splitter-click"],
  props: {
    horizontal: { type: Boolean },
    pushOtherPanes: { type: Boolean, default: !0 },
    dblClickSplitter: { type: Boolean, default: !0 },
    rtl: { type: Boolean, default: !1 },
    firstSplitter: { type: Boolean }
  },
  provide() {
    return {
      requestUpdate: this.requestUpdate,
      onPaneAdd: this.onPaneAdd,
      onPaneRemove: this.onPaneRemove,
      onPaneClick: this.onPaneClick
    };
  },
  data: () => ({
    container: null,
    ready: !1,
    panes: [],
    touch: {
      mouseDown: !1,
      dragging: !1,
      activeSplitter: null
    },
    splitterTaps: {
      splitter: null,
      timeoutId: null
    }
  }),
  computed: {
    panesCount() {
      return this.panes.length;
    },
    indexedPanes() {
      return this.panes.reduce((e, t) => (e[t.id] = t) && e, {});
    }
  },
  methods: {
    updatePaneComponents() {
      this.panes.forEach((e) => {
        e.update && e.update({
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[e.id].size}%`
        });
      });
    },
    bindEvents() {
      document.addEventListener("mousemove", this.onMouseMove, { passive: !1 }), document.addEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.addEventListener("touchmove", this.onMouseMove, { passive: !1 }), document.addEventListener("touchend", this.onMouseUp));
    },
    unbindEvents() {
      document.removeEventListener("mousemove", this.onMouseMove, { passive: !1 }), document.removeEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.removeEventListener("touchmove", this.onMouseMove, { passive: !1 }), document.removeEventListener("touchend", this.onMouseUp));
    },
    onMouseDown(e, t) {
      this.bindEvents(), this.touch.mouseDown = !0, this.touch.activeSplitter = t;
    },
    onMouseMove(e) {
      this.touch.mouseDown && (e.preventDefault(), this.touch.dragging = !0, this.calculatePanesSize(this.getCurrentMouseDrag(e)), this.$emit("resize", this.panes.map((t) => ({ min: t.min, max: t.max, size: t.size }))));
    },
    onMouseUp() {
      this.touch.dragging && this.$emit("resized", this.panes.map((e) => ({ min: e.min, max: e.max, size: e.size }))), this.touch.mouseDown = !1, setTimeout(() => {
        this.touch.dragging = !1, this.unbindEvents();
      }, 100);
    },
    onSplitterClick(e, t) {
      "ontouchstart" in window && (e.preventDefault(), this.dblClickSplitter && (this.splitterTaps.splitter === t ? (clearTimeout(this.splitterTaps.timeoutId), this.splitterTaps.timeoutId = null, this.onSplitterDblClick(e, t), this.splitterTaps.splitter = null) : (this.splitterTaps.splitter = t, this.splitterTaps.timeoutId = setTimeout(() => {
        this.splitterTaps.splitter = null;
      }, 500)))), this.touch.dragging || this.$emit("splitter-click", this.panes[t]);
    },
    onSplitterDblClick(e, t) {
      let r = 0;
      this.panes = this.panes.map((n, o) => (n.size = o === t ? n.max : n.min, o !== t && (r += n.min), n)), this.panes[t].size -= r, this.$emit("pane-maximize", this.panes[t]), this.$emit("resized", this.panes.map((n) => ({ min: n.min, max: n.max, size: n.size })));
    },
    onPaneClick(e, t) {
      this.$emit("pane-click", this.indexedPanes[t]);
    },
    getCurrentMouseDrag(e) {
      const t = this.container.getBoundingClientRect(), { clientX: r, clientY: n } = "ontouchstart" in window && e.touches ? e.touches[0] : e;
      return {
        x: r - t.left,
        y: n - t.top
      };
    },
    getCurrentDragPercentage(e) {
      e = e[this.horizontal ? "y" : "x"];
      const t = this.container[this.horizontal ? "clientHeight" : "clientWidth"];
      return this.rtl && !this.horizontal && (e = t - e), e * 100 / t;
    },
    calculatePanesSize(e) {
      const t = this.touch.activeSplitter;
      let r = {
        prevPanesSize: this.sumPrevPanesSize(t),
        nextPanesSize: this.sumNextPanesSize(t),
        prevReachedMinPanes: 0,
        nextReachedMinPanes: 0
      };
      const n = 0 + (this.pushOtherPanes ? 0 : r.prevPanesSize), o = 100 - (this.pushOtherPanes ? 0 : r.nextPanesSize), s = Math.max(Math.min(this.getCurrentDragPercentage(e), o), n);
      let a = [t, t + 1], l = this.panes[a[0]] || null, u = this.panes[a[1]] || null;
      const f = l.max < 100 && s >= l.max + r.prevPanesSize, c = u.max < 100 && s <= 100 - (u.max + this.sumNextPanesSize(t + 1));
      if (f || c) {
        f ? (l.size = l.max, u.size = Math.max(100 - l.max - r.prevPanesSize - r.nextPanesSize, 0)) : (l.size = Math.max(100 - u.max - r.prevPanesSize - this.sumNextPanesSize(t + 1), 0), u.size = u.max);
        return;
      }
      if (this.pushOtherPanes) {
        const d = this.doPushOtherPanes(r, s);
        if (!d)
          return;
        ({ sums: r, panesToResize: a } = d), l = this.panes[a[0]] || null, u = this.panes[a[1]] || null;
      }
      l !== null && (l.size = Math.min(Math.max(s - r.prevPanesSize - r.prevReachedMinPanes, l.min), l.max)), u !== null && (u.size = Math.min(Math.max(100 - s - r.nextPanesSize - r.nextReachedMinPanes, u.min), u.max));
    },
    doPushOtherPanes(e, t) {
      const r = this.touch.activeSplitter, n = [r, r + 1];
      return t < e.prevPanesSize + this.panes[n[0]].min && (n[0] = this.findPrevExpandedPane(r).index, e.prevReachedMinPanes = 0, n[0] < r && this.panes.forEach((o, s) => {
        s > n[0] && s <= r && (o.size = o.min, e.prevReachedMinPanes += o.min);
      }), e.prevPanesSize = this.sumPrevPanesSize(n[0]), n[0] === void 0) ? (e.prevReachedMinPanes = 0, this.panes[0].size = this.panes[0].min, this.panes.forEach((o, s) => {
        s > 0 && s <= r && (o.size = o.min, e.prevReachedMinPanes += o.min);
      }), this.panes[n[1]].size = 100 - e.prevReachedMinPanes - this.panes[0].min - e.prevPanesSize - e.nextPanesSize, null) : t > 100 - e.nextPanesSize - this.panes[n[1]].min && (n[1] = this.findNextExpandedPane(r).index, e.nextReachedMinPanes = 0, n[1] > r + 1 && this.panes.forEach((o, s) => {
        s > r && s < n[1] && (o.size = o.min, e.nextReachedMinPanes += o.min);
      }), e.nextPanesSize = this.sumNextPanesSize(n[1] - 1), n[1] === void 0) ? (e.nextReachedMinPanes = 0, this.panes[this.panesCount - 1].size = this.panes[this.panesCount - 1].min, this.panes.forEach((o, s) => {
        s < this.panesCount - 1 && s >= r + 1 && (o.size = o.min, e.nextReachedMinPanes += o.min);
      }), this.panes[n[0]].size = 100 - e.prevPanesSize - e.nextReachedMinPanes - this.panes[this.panesCount - 1].min - e.nextPanesSize, null) : { sums: e, panesToResize: n };
    },
    sumPrevPanesSize(e) {
      return this.panes.reduce((t, r, n) => t + (n < e ? r.size : 0), 0);
    },
    sumNextPanesSize(e) {
      return this.panes.reduce((t, r, n) => t + (n > e + 1 ? r.size : 0), 0);
    },
    findPrevExpandedPane(e) {
      return [...this.panes].reverse().find((t) => t.index < e && t.size > t.min) || {};
    },
    findNextExpandedPane(e) {
      return this.panes.find((t) => t.index > e + 1 && t.size > t.min) || {};
    },
    checkSplitpanesNodes() {
      Array.from(this.container.children).forEach((e) => {
        const t = e.classList.contains("splitpanes__pane"), r = e.classList.contains("splitpanes__splitter");
        !t && !r && (e.parentNode.removeChild(e), console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed."));
      });
    },
    addSplitter(e, t, r = !1) {
      const n = e - 1, o = document.createElement("div");
      o.classList.add("splitpanes__splitter"), r || (o.onmousedown = (s) => this.onMouseDown(s, n), typeof window < "u" && "ontouchstart" in window && (o.ontouchstart = (s) => this.onMouseDown(s, n)), o.onclick = (s) => this.onSplitterClick(s, n + 1)), this.dblClickSplitter && (o.ondblclick = (s) => this.onSplitterDblClick(s, n + 1)), t.parentNode.insertBefore(o, t);
    },
    removeSplitter(e) {
      e.onmousedown = void 0, e.onclick = void 0, e.ondblclick = void 0, e.parentNode.removeChild(e);
    },
    redoSplitters() {
      const e = Array.from(this.container.children);
      e.forEach((r) => {
        r.className.includes("splitpanes__splitter") && this.removeSplitter(r);
      });
      let t = 0;
      e.forEach((r) => {
        r.className.includes("splitpanes__pane") && (!t && this.firstSplitter ? this.addSplitter(t, r, !0) : t && this.addSplitter(t, r), t++);
      });
    },
    requestUpdate({ target: e, ...t }) {
      const r = this.indexedPanes[e._.uid];
      Object.entries(t).forEach(([n, o]) => r[n] = o);
    },
    onPaneAdd(e) {
      let t = -1;
      Array.from(e.$el.parentNode.children).some((o) => (o.className.includes("splitpanes__pane") && t++, o === e.$el));
      const r = parseFloat(e.minSize), n = parseFloat(e.maxSize);
      this.panes.splice(t, 0, {
        id: e._.uid,
        index: t,
        min: isNaN(r) ? 0 : r,
        max: isNaN(n) ? 100 : n,
        size: e.size === null ? null : parseFloat(e.size),
        givenSize: e.size,
        update: e.update
      }), this.panes.forEach((o, s) => o.index = s), this.ready && this.$nextTick(() => {
        this.redoSplitters(), this.resetPaneSizes({ addedPane: this.panes[t] }), this.$emit("pane-add", { index: t, panes: this.panes.map((o) => ({ min: o.min, max: o.max, size: o.size })) });
      });
    },
    onPaneRemove(e) {
      const t = this.panes.findIndex((n) => n.id === e._.uid), r = this.panes.splice(t, 1)[0];
      this.panes.forEach((n, o) => n.index = o), this.$nextTick(() => {
        this.redoSplitters(), this.resetPaneSizes({ removedPane: { ...r, index: t } }), this.$emit("pane-remove", { removed: r, panes: this.panes.map((n) => ({ min: n.min, max: n.max, size: n.size })) });
      });
    },
    resetPaneSizes(e = {}) {
      !e.addedPane && !e.removedPane ? this.initialPanesSizing() : this.panes.some((t) => t.givenSize !== null || t.min || t.max < 100) ? this.equalizeAfterAddOrRemove(e) : this.equalize(), this.ready && this.$emit("resized", this.panes.map((t) => ({ min: t.min, max: t.max, size: t.size })));
    },
    equalize() {
      const e = 100 / this.panesCount;
      let t = 0;
      const r = [], n = [];
      this.panes.forEach((o) => {
        o.size = Math.max(Math.min(e, o.max), o.min), t -= o.size, o.size >= o.max && r.push(o.id), o.size <= o.min && n.push(o.id);
      }), t > 0.1 && this.readjustSizes(t, r, n);
    },
    initialPanesSizing() {
      let e = 100;
      const t = [], r = [];
      let n = 0;
      this.panes.forEach((s) => {
        e -= s.size, s.size !== null && n++, s.size >= s.max && t.push(s.id), s.size <= s.min && r.push(s.id);
      });
      let o = 100;
      e > 0.1 && (this.panes.forEach((s) => {
        s.size === null && (s.size = Math.max(Math.min(e / (this.panesCount - n), s.max), s.min)), o -= s.size;
      }), o > 0.1 && this.readjustSizes(e, t, r));
    },
    equalizeAfterAddOrRemove({ addedPane: e, removedPane: t } = {}) {
      let r = 100 / this.panesCount, n = 0;
      const o = [], s = [];
      e && e.givenSize !== null && (r = (100 - e.givenSize) / (this.panesCount - 1)), this.panes.forEach((a) => {
        n -= a.size, a.size >= a.max && o.push(a.id), a.size <= a.min && s.push(a.id);
      }), !(Math.abs(n) < 0.1) && (this.panes.forEach((a) => {
        e && e.givenSize !== null && e.id === a.id || (a.size = Math.max(Math.min(r, a.max), a.min)), n -= a.size, a.size >= a.max && o.push(a.id), a.size <= a.min && s.push(a.id);
      }), n > 0.1 && this.readjustSizes(n, o, s));
    },
    readjustSizes(e, t, r) {
      let n;
      e > 0 ? n = e / (this.panesCount - t.length) : n = e / (this.panesCount - r.length), this.panes.forEach((o, s) => {
        if (e > 0 && !t.includes(o.id)) {
          const a = Math.max(Math.min(o.size + n, o.max), o.min), l = a - o.size;
          e -= l, o.size = a;
        } else if (!r.includes(o.id)) {
          const a = Math.max(Math.min(o.size + n, o.max), o.min), l = a - o.size;
          e -= l, o.size = a;
        }
        o.update({
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[o.id].size}%`
        });
      }), Math.abs(e) > 0.1 && this.$nextTick(() => {
        this.ready && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
      });
    }
  },
  watch: {
    panes: {
      deep: !0,
      immediate: !1,
      handler() {
        this.updatePaneComponents();
      }
    },
    horizontal() {
      this.updatePaneComponents();
    },
    firstSplitter() {
      this.redoSplitters();
    },
    dblClickSplitter(e) {
      [...this.container.querySelectorAll(".splitpanes__splitter")].forEach((t, r) => {
        t.ondblclick = e ? (n) => this.onSplitterDblClick(n, r) : void 0;
      });
    }
  },
  beforeUnmount() {
    this.ready = !1;
  },
  mounted() {
    this.container = this.$refs.container, this.checkSplitpanesNodes(), this.redoSplitters(), this.resetPaneSizes(), this.$emit("ready"), this.ready = !0;
  },
  render() {
    return Ut(
      "div",
      {
        ref: "container",
        class: [
          "splitpanes",
          `splitpanes--${this.horizontal ? "horizontal" : "vertical"}`,
          {
            "splitpanes--dragging": this.touch.dragging
          }
        ]
      },
      this.$slots.default()
    );
  }
}, QH = (e, t) => {
  const r = e.__vccOpts || e;
  for (const [n, o] of t)
    r[n] = o;
  return r;
}, ZH = {
  name: "pane",
  inject: ["requestUpdate", "onPaneAdd", "onPaneRemove", "onPaneClick"],
  props: {
    size: { type: [Number, String], default: null },
    minSize: { type: [Number, String], default: 0 },
    maxSize: { type: [Number, String], default: 100 }
  },
  data: () => ({
    style: {}
  }),
  mounted() {
    this.onPaneAdd(this);
  },
  beforeUnmount() {
    this.onPaneRemove(this);
  },
  methods: {
    update(e) {
      this.style = e;
    }
  },
  computed: {
    sizeNumber() {
      return this.size || this.size === 0 ? parseFloat(this.size) : null;
    },
    minSizeNumber() {
      return parseFloat(this.minSize);
    },
    maxSizeNumber() {
      return parseFloat(this.maxSize);
    }
  },
  watch: {
    sizeNumber(e) {
      this.requestUpdate({ target: this, size: e });
    },
    minSizeNumber(e) {
      this.requestUpdate({ target: this, min: e });
    },
    maxSizeNumber(e) {
      this.requestUpdate({ target: this, max: e });
    }
  }
};
function e9(e, t, r, n, o, s) {
  return we(), Te("div", {
    class: "splitpanes__pane",
    onClick: t[0] || (t[0] = (a) => s.onPaneClick(a, e._.uid)),
    style: np(e.style)
  }, [
    io(e.$slots, "default")
  ], 4);
}
const Hi = /* @__PURE__ */ QH(ZH, [["render", e9]]), t9 = {
  rif: "http://www.w3.org/2007/rif#",
  v: "http://rdf.data-vocabulary.org/#",
  wdr: "http://www.w3.org/2007/05/powder#",
  xml: "http://www.w3.org/XML/1998/namespace/"
}, r9 = {
  acl: "http://www.w3.org/ns/auth/acl#",
  as: "https://www.w3.org/ns/activitystreams#",
  bibo: "http://purl.org/ontology/bibo/",
  cc: "http://creativecommons.org/ns#",
  cert: "http://www.w3.org/ns/auth/cert#",
  cnt: "http://www.w3.org/2011/content#",
  constant: "http://qudt.org/vocab/constant/",
  crm: "http://www.cidoc-crm.org/cidoc-crm/",
  csvw: "http://www.w3.org/ns/csvw#",
  ctag: "http://commontag.org/ns#",
  "dash-sparql": "http://datashapes.org/sparql#",
  dash: "http://datashapes.org/dash#",
  dbo: "http://dbpedia.org/ontology/",
  dc11: "http://purl.org/dc/elements/1.1/",
  dcam: "http://purl.org/dc/dcam/",
  dcat: "http://www.w3.org/ns/dcat#",
  dcmitype: "http://purl.org/dc/dcmitype/",
  dcterms: "http://purl.org/dc/terms/",
  dig: "http://www.ics.forth.gr/isl/CRMdig/",
  discipline: "http://qudt.org/vocab/discipline/",
  doap: "http://usefulinc.com/ns/doap#",
  dpv: "http://www.w3.org/ns/dpv#",
  dqv: "http://www.w3.org/ns/dqv#",
  dtype: "http://www.linkedmodel.org/schema/dtype#",
  duv: "http://www.w3.org/ns/duv#",
  earl: "http://www.w3.org/ns/earl#",
  ebucore: "http://www.ebu.ch/metadata/ontologies/ebucore/ebucore#",
  exif: "http://www.w3.org/2003/12/exif/ns#",
  foaf: "http://xmlns.com/foaf/0.1/",
  frbr: "http://purl.org/vocab/frbr/core#",
  geo: "http://www.opengis.net/ont/geosparql#",
  geof: "http://www.opengis.net/def/function/geosparql/",
  geor: "http://www.opengis.net/def/rule/geosparql/",
  gml: "http://www.opengis.net/ont/gml#",
  gn: "http://www.geonames.org/ontology#",
  gr: "http://purl.org/goodrelations/v1#",
  grddl: "http://www.w3.org/2003/g/data-view#",
  gs1: "https://gs1.org/voc/",
  gtfs: "http://vocab.gtfs.org/terms#",
  http: "http://www.w3.org/2011/http#",
  hydra: "http://www.w3.org/ns/hydra/core#",
  ical: "http://www.w3.org/2002/12/cal/icaltzd#",
  la: "https://linked.art/ns/terms/",
  ldp: "http://www.w3.org/ns/ldp#",
  list: "http://www.w3.org/2000/10/swap/list#",
  locn: "http://www.w3.org/ns/locn#",
  log: "http://www.w3.org/2000/10/swap/log#",
  lvont: "http://lexvo.org/ontology#",
  m4i: "http://w3id.org/nfdi4ing/metadata4ing#",
  ma: "http://www.w3.org/ns/ma-ont#",
  mads: "http://www.loc.gov/mads/rdf/v1#",
  math: "http://www.w3.org/2000/10/swap/math#",
  oa: "http://www.w3.org/ns/oa#",
  og: "http://ogp.me/ns#",
  oidc: "http://www.w3.org/ns/solid/oidc#",
  org: "http://www.w3.org/ns/org#",
  owl: "http://www.w3.org/2002/07/owl#",
  pim: "http://www.w3.org/ns/pim/space#",
  prefix: "http://qudt.org/vocab/prefix/",
  prov: "http://www.w3.org/ns/prov#",
  qb: "http://purl.org/linked-data/cube#",
  qkdv: "http://qudt.org/vocab/dimensionvector/",
  quantitykind: "http://qudt.org/vocab/quantitykind/",
  qudt: "http://qudt.org/schema/qudt/",
  rdau: "http://rdaregistry.info/Elements/u/",
  rdf: "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
  rdfa: "http://www.w3.org/ns/rdfa#",
  rdfs: "http://www.w3.org/2000/01/rdf-schema#",
  rev: "http://purl.org/stuff/rev#",
  rico: "https://www.ica.org/standards/RiC/ontology#",
  rr: "http://www.w3.org/ns/r2rml#",
  rss: "http://purl.org/rss/1.0/",
  schema: "http://schema.org/",
  sd: "http://www.w3.org/ns/sparql-service-description#",
  sdmx: "http://purl.org/linked-data/sdmx#",
  sem: "http://semanticweb.cs.vu.nl/2009/11/sem/",
  set: "http://www.w3.org/2000/10/swap/set#",
  sf: "http://www.opengis.net/ont/sf#",
  sh: "http://www.w3.org/ns/shacl#",
  shex: "http://www.w3.org/ns/shex#",
  shsh: "http://www.w3.org/ns/shacl-shacl#",
  sioc: "http://rdfs.org/sioc/ns#",
  skos: "http://www.w3.org/2004/02/skos/core#",
  skosxl: "http://www.w3.org/2008/05/skos-xl#",
  solid: "http://www.w3.org/ns/solid/terms#",
  sosa: "http://www.w3.org/ns/sosa/",
  sou: "http://qudt.org/vocab/sou/",
  ssn: "http://www.w3.org/ns/ssn/",
  stat: "http://www.w3.org/ns/posix/stat#",
  string: "http://www.w3.org/2000/10/swap/string#",
  test: "http://www.w3.org/2006/03/test-description#",
  time: "http://www.w3.org/2006/time#",
  unit: "http://qudt.org/vocab/unit/",
  vaem: "http://www.linkedmodel.org/schema/vaem#",
  vann: "http://purl.org/vocab/vann/",
  vcard: "http://www.w3.org/2006/vcard/ns#",
  void: "http://rdfs.org/ns/void#",
  vs: "http://www.w3.org/2003/06/sw-vocab-status/ns#",
  vso: "http://purl.org/vso/ns#",
  wdrs: "http://www.w3.org/2007/05/powder-s#",
  wgs: "http://www.w3.org/2003/01/geo/wgs84_pos#",
  xhv: "http://www.w3.org/1999/xhtml/vocab#",
  xkos: "http://rdf-vocabulary.ddialliance.org/xkos#",
  xsd: "http://www.w3.org/2001/XMLSchema#"
}, mi = {
  ...r9,
  ...t9
};
function uD(e, t = {}) {
  const r = { ...mi, ...t }, n = Array.from(Object.entries(r)).filter(([, o]) => e.startsWith(o));
  if (n.length) {
    n.sort(([, s], [, a]) => a.length - s.length);
    const o = n[0];
    return e.replace(new RegExp(`^${o[1]}`), `${o[0]}:`);
  }
  return "";
}
const n9 = (e) => class {
  constructor() {
    As(this, "dataset");
  }
  init() {
    const r = e(this);
    this.dataset = (n = []) => new r([...n]), this.dataset.Class = r;
  }
};
let mp = class fD {
  constructor(t, { bind: r = !1 } = {}) {
    this._factories = t.slice();
    for (const n of this._factories) {
      typeof n.prototype.init == "function" && n.prototype.init.call(this);
      for (const o of n.exports || [])
        r ? this[o] = n.prototype[o].bind(this) : this[o] = n.prototype[o];
    }
  }
  clone() {
    const t = new fD(this._factories);
    for (const r of t._factories)
      typeof r.prototype.clone == "function" && r.prototype.clone.call(t, this);
    return t;
  }
};
function yT({ parent: e, child: t }) {
  return new Proxy({}, {
    get(n, o) {
      return t[o] || e[o];
    },
    set(n, o, s) {
      return t[o] = s, !0;
    },
    has(n, o) {
      return o in t || o in e;
    },
    ownKeys() {
      const n = Object.getOwnPropertyNames(e), o = Object.getOwnPropertyNames(t);
      return [...(/* @__PURE__ */ new Set([...n, ...o])).values()];
    },
    getOwnPropertyDescriptor(n, o) {
      return {
        enumerable: !o.toString().startsWith("_"),
        configurable: !0
      };
    }
  });
}
class Bf {
  constructor(t, { parent: r, bind: n = !1 } = {}) {
    if (this._parent = r, t instanceof mp || t instanceof Bf)
      return yT({ parent: r, child: t });
    this._factories = t.slice();
    const o = r ? yT({ parent: r, child: this }) : this;
    for (const s of this._factories) {
      typeof s.prototype.init == "function" && s.prototype.init.call(o);
      for (const a of s.exports || [])
        n ? this[a] = s.prototype[a].bind(o) : this[a] = s.prototype[a];
    }
    return o;
  }
  clone() {
    const t = new Bf(this._factories, this._parent);
    for (const r of t._factories)
      typeof r.prototype.clone == "function" && r.prototype.clone.call(t, this);
    return t;
  }
}
let cD = class {
  constructor(t) {
    this.value = t;
  }
  equals(t) {
    return !!t && t.termType === this.termType && t.value === this.value;
  }
};
cD.prototype.termType = "BlankNode";
let KE = class {
  equals(t) {
    return !!t && t.termType === this.termType;
  }
};
KE.prototype.termType = "DefaultGraph";
KE.prototype.value = "";
function mT(e, t) {
  if (!t)
    return null;
  if (t.termType === "BlankNode")
    return e.blankNode(t.value);
  if (t.termType === "DefaultGraph")
    return e.defaultGraph();
  if (t.termType === "Literal")
    return e.literal(t.value, t.language || e.namedNode(t.datatype.value));
  if (t.termType === "NamedNode")
    return e.namedNode(t.value);
  if (t.termType === "Quad") {
    const r = e.fromTerm(t.subject), n = e.fromTerm(t.predicate), o = e.fromTerm(t.object), s = e.fromTerm(t.graph);
    return e.quad(r, n, o, s);
  }
  if (t.termType === "Variable")
    return e.variable(t.value);
  throw new Error(`unknown termType ${t.termType}`);
}
let O1 = class {
  constructor(t, r, n) {
    this.value = t, this.language = r, this.datatype = n;
  }
  equals(t) {
    return !!t && t.termType === this.termType && t.value === this.value && t.language === this.language && t.datatype.equals(this.datatype);
  }
};
O1.prototype.termType = "Literal";
let vp = class {
  constructor(t) {
    this.value = t;
  }
  equals(t) {
    return !!t && t.termType === this.termType && t.value === this.value;
  }
};
vp.prototype.termType = "NamedNode";
let YE = class {
  constructor(t, r, n, o) {
    this.subject = t, this.predicate = r, this.object = n, this.graph = o;
  }
  equals(t) {
    return !!t && (t.termType === "Quad" || !t.termType) && t.subject.equals(this.subject) && t.predicate.equals(this.predicate) && t.object.equals(this.object) && t.graph.equals(this.graph);
  }
};
YE.prototype.termType = "Quad";
YE.prototype.value = "";
let dD = class {
  constructor(t) {
    this.value = t;
  }
  equals(t) {
    return !!t && t.termType === this.termType && t.value === this.value;
  }
};
dD.prototype.termType = "Variable";
const i9 = new vp("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString"), o9 = new vp("http://www.w3.org/2001/XMLSchema#string");
let lu = class {
  constructor() {
    this.init();
  }
  init() {
    this._data = {
      blankNodeCounter: 0,
      defaultGraph: new KE()
    };
  }
  namedNode(t) {
    return new vp(t);
  }
  blankNode(t) {
    return t = t || "b" + ++this._data.blankNodeCounter, new cD(t);
  }
  literal(t, r) {
    return typeof r == "string" ? new O1(t, r, i9) : new O1(t, "", r || o9);
  }
  variable(t) {
    return new dD(t);
  }
  defaultGraph() {
    return this._data.defaultGraph;
  }
  quad(t, r, n, o = this.defaultGraph()) {
    return new YE(t, r, n, o);
  }
  fromTerm(t) {
    return mT(this, t);
  }
  fromQuad(t) {
    return mT(this, t);
  }
};
lu.exports = [
  "blankNode",
  "defaultGraph",
  "fromQuad",
  "fromTerm",
  "literal",
  "namedNode",
  "quad",
  "variable"
];
class dh extends Map {
  import(t, r, n) {
    const o = this.get(t);
    return o ? o.import(r, n) : null;
  }
}
class hD {
  constructor({ factory: t }) {
    this.factory = t, this.parsers = new dh(), this.serializers = new dh();
  }
  import(t) {
    if (t.parsers)
      for (const [r, n] of t.parsers)
        this.parsers.set(r, new n.constructor({ factory: this.factory }));
    if (t.serializers)
      for (const [r, n] of t.serializers)
        this.serializers.set(r, new n.constructor({ factory: this.factory }));
    return this;
  }
}
let pD = class {
  init() {
    this.formats = new hD({ factory: this });
  }
  clone(t) {
    this.formats.import(t.formats);
  }
};
const gD = new lu(), s9 = {
  apply: (e, t, r) => e(r[0]),
  get: (e, t) => e(t)
};
function _e(e, { factory: t = gD } = {}) {
  const r = (n = "") => t.namedNode(`${e}${n.raw || n}`);
  return typeof Proxy > "u" ? r : new Proxy(r, s9);
}
let XE = class {
  namespace(t) {
    return _e(t, { factory: this });
  }
};
XE.exports = ["namespace"];
class bD {
  init() {
    this.ns = TE;
  }
}
const a9 = _e("http://www.w3.org/ns/auth/acl#"), l9 = a9, u9 = _e("https://www.w3.org/ns/activitystreams#"), f9 = u9, c9 = _e("http://purl.org/ontology/bibo/"), d9 = c9, h9 = _e("http://creativecommons.org/ns#"), p9 = h9, g9 = _e("http://www.w3.org/ns/auth/cert#"), b9 = g9, y9 = _e("http://www.w3.org/2011/content#"), m9 = y9, v9 = _e("http://qudt.org/vocab/constant/"), w9 = v9, _9 = _e("http://www.cidoc-crm.org/cidoc-crm/"), S9 = _9, E9 = _e("http://www.w3.org/ns/csvw#"), x9 = E9, R9 = _e("http://commontag.org/ns#"), A9 = R9, T9 = _e("http://datashapes.org/sparql#"), $9 = T9, C9 = _e("http://datashapes.org/dash#"), k9 = C9, I9 = _e("http://dbpedia.org/ontology/"), M9 = I9, N9 = _e("http://purl.org/dc/elements/1.1/"), L9 = N9, O9 = _e("http://purl.org/dc/dcam/"), P9 = O9, D9 = _e("http://www.w3.org/ns/dcat#"), F9 = D9, j9 = _e("http://purl.org/dc/dcmitype/"), B9 = j9, q9 = _e("http://purl.org/dc/terms/"), W9 = q9, U9 = _e("http://www.ics.forth.gr/isl/CRMdig/"), H9 = U9, z9 = _e("http://qudt.org/vocab/discipline/"), G9 = z9, V9 = _e("http://usefulinc.com/ns/doap#"), K9 = V9, Y9 = _e("http://www.w3.org/ns/dpv#"), X9 = Y9, J9 = _e("http://www.w3.org/ns/dqv#"), Q9 = J9, Z9 = _e("http://www.linkedmodel.org/schema/dtype#"), ez = Z9, tz = _e("http://www.w3.org/ns/duv#"), rz = tz, nz = _e("http://www.w3.org/ns/earl#"), iz = nz, oz = _e("http://www.ebu.ch/metadata/ontologies/ebucore/ebucore#"), sz = oz, az = _e("http://www.w3.org/2003/12/exif/ns#"), lz = az, uz = _e("http://xmlns.com/foaf/0.1/"), fz = uz, cz = _e("http://purl.org/vocab/frbr/core#"), dz = cz, hz = _e("http://www.opengis.net/ont/geosparql#"), pz = hz, gz = _e("http://www.opengis.net/def/function/geosparql/"), bz = gz, yz = _e("http://www.opengis.net/def/rule/geosparql/"), mz = yz, vz = _e("http://www.opengis.net/ont/gml#"), wz = vz, _z = _e("http://www.geonames.org/ontology#"), Sz = _z, Ez = _e("http://purl.org/goodrelations/v1#"), xz = Ez, Rz = _e("http://www.w3.org/2003/g/data-view#"), Az = Rz, Tz = _e("https://gs1.org/voc/"), $z = Tz, Cz = _e("http://vocab.gtfs.org/terms#"), kz = Cz, Iz = _e("http://www.w3.org/2011/http#"), Mz = Iz, Nz = _e("http://www.w3.org/ns/hydra/core#"), Lz = Nz, Oz = _e("http://www.w3.org/2002/12/cal/icaltzd#"), Pz = Oz, Dz = _e("https://linked.art/ns/terms/"), Fz = Dz, jz = _e("http://www.w3.org/ns/ldp#"), Bz = jz, qz = _e("http://www.w3.org/2000/10/swap/list#"), Wz = qz, Uz = _e("http://www.w3.org/ns/locn#"), Hz = Uz, zz = _e("http://www.w3.org/2000/10/swap/log#"), Gz = zz, Vz = _e("http://lexvo.org/ontology#"), Kz = Vz, Yz = _e("http://w3id.org/nfdi4ing/metadata4ing#"), Xz = Yz, Jz = _e("http://www.w3.org/ns/ma-ont#"), Qz = Jz, Zz = _e("http://www.loc.gov/mads/rdf/v1#"), eG = Zz, tG = _e("http://www.w3.org/2000/10/swap/math#"), rG = tG, nG = _e("http://www.w3.org/ns/oa#"), iG = nG, oG = _e("http://ogp.me/ns#"), sG = oG, aG = _e("http://www.w3.org/ns/solid/oidc#"), lG = aG, uG = _e("http://www.w3.org/ns/org#"), fG = uG, cG = _e("http://www.w3.org/2002/07/owl#"), dG = cG, hG = _e("http://www.w3.org/ns/pim/space#"), pG = hG, gG = _e("http://qudt.org/vocab/prefix/"), bG = gG, yG = _e("http://www.w3.org/ns/prov#"), mG = yG, vG = _e("http://purl.org/linked-data/cube#"), wG = vG, _G = _e("http://qudt.org/vocab/dimensionvector/"), SG = _G, EG = _e("http://qudt.org/vocab/quantitykind/"), xG = EG, RG = _e("http://qudt.org/schema/qudt/"), AG = RG, TG = _e("http://rdaregistry.info/Elements/u/"), $G = TG, CG = _e("http://www.w3.org/1999/02/22-rdf-syntax-ns#"), Bn = CG, kG = _e("http://www.w3.org/ns/rdfa#"), IG = kG, MG = _e("http://www.w3.org/2000/01/rdf-schema#"), NG = MG, LG = _e("http://purl.org/stuff/rev#"), OG = LG, PG = _e("https://www.ica.org/standards/RiC/ontology#"), DG = PG, FG = _e("http://www.w3.org/ns/r2rml#"), jG = FG, BG = _e("http://purl.org/rss/1.0/"), qG = BG, WG = _e("http://schema.org/"), UG = WG, HG = _e("http://www.w3.org/ns/sparql-service-description#"), zG = HG, GG = _e("http://purl.org/linked-data/sdmx#"), VG = GG, KG = _e("http://semanticweb.cs.vu.nl/2009/11/sem/"), YG = KG, XG = _e("http://www.w3.org/2000/10/swap/set#"), JG = XG, QG = _e("http://www.opengis.net/ont/sf#"), ZG = QG, eV = _e("http://www.w3.org/ns/shacl#"), tV = eV, rV = _e("http://www.w3.org/ns/shex#"), nV = rV, iV = _e("https://www.w3.org/ns/shacl-shacl#"), oV = iV, sV = _e("http://rdfs.org/sioc/ns#"), aV = sV, lV = _e("http://www.w3.org/2004/02/skos/core#"), uV = lV, fV = _e("http://www.w3.org/2008/05/skos-xl#"), cV = fV, dV = _e("http://www.w3.org/ns/solid/terms#"), hV = dV, pV = _e("http://www.w3.org/ns/sosa/"), gV = pV, bV = _e("http://qudt.org/vocab/sou/"), yV = bV, mV = _e("http://www.w3.org/ns/ssn/"), vV = mV, wV = _e("http://www.w3.org/ns/posix/stat#"), _V = wV, SV = _e("http://www.w3.org/2000/10/swap/string#"), EV = SV, xV = _e("http://www.w3.org/2006/03/test-description#"), RV = xV, AV = _e("http://www.w3.org/2006/time#"), TV = AV, $V = _e("http://qudt.org/vocab/unit/"), CV = $V, kV = _e("http://www.linkedmodel.org/schema/vaem#"), IV = kV, MV = _e("http://purl.org/vocab/vann/"), NV = MV, LV = _e("http://www.w3.org/2006/vcard/ns#"), OV = LV, PV = _e("http://rdfs.org/ns/void#"), DV = PV, FV = _e("http://www.w3.org/2003/06/sw-vocab-status/ns#"), jV = FV, BV = _e("http://www.w3.org/2007/05/powder-s#"), qV = BV, WV = _e("http://www.w3.org/2003/01/geo/wgs84_pos#"), UV = WV, HV = _e("http://www.w3.org/1999/xhtml/vocab#"), zV = HV, GV = _e("http://rdf-vocabulary.ddialliance.org/xkos#"), VV = GV, KV = _e("http://www.w3.org/2001/XMLSchema#"), yf = KV, YV = _e("http://www.w3.org/2007/rif#"), XV = YV, JV = _e("http://rdf.data-vocabulary.org/#"), QV = JV, ZV = _e("http://www.w3.org/2007/05/powder#"), eK = ZV, tK = _e("http://www.w3.org/XML/1998/namespace/"), rK = tK, JE = (e) => {
  const t = e.namespace("http://www.w3.org/2001/XMLSchema#"), r = e.namespace("http://www.w3.org/1999/02/22-rdf-syntax-ns#");
  return {
    first: r.first,
    nil: r.nil,
    rest: r.rest,
    langString: r.langString,
    xsd: t
  };
};
function Jr(e, t) {
  return typeof e > "u" || e === null ? t : Array.isArray(e) ? e : typeof e != "string" && e[Symbol.iterator] ? [...e] : [e];
}
const Fa = new mp([
  XE,
  lu
]), { xsd: P1 } = JE(Fa);
function nK(e, t = Fa) {
  return typeof e != "boolean" ? null : t.literal(e.toString(), P1("boolean"));
}
function iK(e, t = Fa) {
  return typeof e != "number" ? null : Number.isInteger(e) ? t.literal(e.toString(10), P1("integer")) : t.literal(e.toString(10), P1("double"));
}
function oK(e, t = Fa) {
  return typeof e != "string" ? null : t.literal(e);
}
function sK(e, t = Fa) {
  return nK(e, t) || iK(e, t) || oK(e, t);
}
function aK(e, t) {
  if (e && typeof e != "string")
    throw new Error("Blank node identifier must be a string");
  return t.blankNode(e);
}
function lK(e, t, r) {
  if (typeof e == "string")
    return t = t && (t.value || t.toString()), t && t.indexOf(":") !== -1 && (t = r.namedNode(t)), r.literal(e.toString(), t);
  const n = sK(e, r);
  if (!n)
    throw new Error("The value cannot be converted to a literal node");
  return n;
}
function vT(e, t) {
  if (typeof e != "string")
    throw new Error("Named node must be an IRI string");
  return t.namedNode(e);
}
function yD(e, t = "Literal", r, n) {
  if (e && typeof e == "object" && e.termType)
    return e;
  if (e && e.constructor.name === "URL")
    return vT(e.toString(), n);
  if (t === "BlankNode")
    return aK(e, n);
  if (!(e === null || typeof e > "u")) {
    if (t === "Literal")
      return lK(e, r, n);
    if (t === "NamedNode")
      return vT(e, n);
    throw new Error("unknown type");
  }
}
function uK(e, t, r, n) {
  return (typeof e > "u" || e === null) && !t ? e : (Jr(e) || [void 0]).reduce((o, s) => typeof s == "object" && s.terms ? o.concat(s.terms) : (o.push(yD(s, t, r, n)), o), []);
}
const wT = JE(Fa);
function fK(e, t) {
  const r = t.termType !== "Literal", n = wT.langString.equals(t.datatype) || wT.xsd.string.equals(t.datatype);
  if (r || !n)
    return e;
  const o = t.language.toLowerCase();
  return e.has(o) ? e.get(o).push(t) : e.set(o, [t]), e;
}
function cK(e) {
  const t = e.reduce(fK, /* @__PURE__ */ new Map()), r = [...t.entries()];
  return (n) => {
    const o = n.toLowerCase();
    if (o === "*")
      return r[0] && r[0][1];
    const s = t.get(o);
    if (s)
      return s;
    const a = r.find(([l]) => l.startsWith(o));
    return a && a[1];
  };
}
function dK(e, { language: t }) {
  const r = typeof t == "string" ? [t] : t, n = cK(e);
  return r.map(n).find(Boolean) || [];
}
let hK = class mD {
  constructor({ dataset: t, graph: r, value: n, factory: o, namespace: s }) {
    this.dataset = t, this.graph = r, this.factory = o, this.namespace = s, this.term = yD(n, void 0, void 0, o);
  }
  clone({ dataset: t = this.dataset, graph: r = this.graph, value: n, factory: o = this.factory, namespace: s = this.namespace }) {
    return new mD({ dataset: t, graph: r, value: n, factory: o, namespace: s });
  }
  has(t, r) {
    return this.matchProperty(Jr(this.term), t, r, Jr(this.graph), "subject").map((n) => this.clone({ value: n }));
  }
  in(t) {
    return this.matchProperty(null, t, Jr(this.term), Jr(this.graph), "subject").map((r) => this.clone({ value: r }));
  }
  out(t, { language: r } = {}) {
    let n = this.matchProperty(Jr(this.term), t, null, Jr(this.graph), "object");
    return typeof r < "u" && (n = dK(n, { language: r })), n.map((o) => this.clone({ value: o }));
  }
  addIn(t, r) {
    const n = [];
    return this.term && r.forEach((o) => {
      t.forEach((s) => {
        this.dataset.add(this.factory.quad(o, s, this.term, this.graph));
      }), n.push(this.clone({ value: o }));
    }), n;
  }
  addOut(t, r) {
    const n = [];
    return this.term && r.forEach((o) => {
      t.forEach((s) => {
        this.dataset.add(this.factory.quad(this.term, s, o, this.graph));
      }), n.push(this.clone({ value: o }));
    }), n;
  }
  addList(t, r) {
    this.term && t.forEach((n) => {
      const o = r.map(() => this.factory.blankNode());
      this.dataset.add(this.factory.quad(this.term, n, o[0] || this.namespace.nil, this.graph));
      for (let s = 0; s < o.length; s++)
        this.dataset.add(this.factory.quad(o[s], this.namespace.first, r[s], this.graph)), this.dataset.add(this.factory.quad(o[s], this.namespace.rest, o[s + 1] || this.namespace.nil, this.graph));
    });
  }
  deleteIn(t, r) {
    this.deleteMatch(r, t, Jr(this.term), Jr(this.graph));
  }
  deleteOut(t, r) {
    this.deleteMatch(Jr(this.term), t, r, Jr(this.graph));
  }
  deleteList(t) {
    t.forEach((r) => {
      for (const n of this.dataset.match(this.term, r))
        this.deleteItems(n);
    });
  }
  deleteItems(t) {
    let r = [t];
    for (; !r[r.length - 1].object.equals(this.namespace.nil); ) {
      const n = r[r.length - 1].object;
      r = r.concat([...this.dataset.match(n)]);
    }
    r.forEach((n) => {
      this.dataset.delete(n);
    });
  }
  match(t, r, n, o) {
    if (!t && !r && !n && !o)
      return [...this.dataset];
    t = t || [null], r = r || [null], n = n || [null], o = o || [null];
    const s = [];
    for (const a of o)
      for (const l of t)
        for (const u of r)
          for (const f of n)
            for (const c of this.dataset.match(l, u, f, a))
              s.push(c);
    return s;
  }
  matchProperty(t, r, n, o, s) {
    return this.match(t, r, n, o).map((a) => a[s]);
  }
  deleteMatch(t, r, n, o) {
    this.match(t, r, n, o).forEach((s) => {
      this.dataset.delete(s);
    });
  }
};
class Yr {
  constructor({ dataset: t, graph: r, term: n, value: o, factory: s, _context: a }) {
    if (this.factory = s, this.namespace = JE(s), a) {
      this._context = a;
      return;
    }
    const l = n && Jr(n) || o && Jr(o) || [null];
    this._context = l.map((u) => new hK({ dataset: t, graph: r, value: u, factory: this.factory, namespace: this.namespace }));
  }
  /**
   * Gets the current RDF/JS term or undefined if pointer has no context
   *
   * @returns {undefined|Term}
   */
  get term() {
    const t = this.terms;
    if (t.length === 1)
      return t[0];
  }
  /**
   * Gets the current terms or an empty array if the pointer has no context
   *
   * @returns {Term[]}
   */
  get terms() {
    return this._context.map((t) => t.term).filter(Boolean);
  }
  /**
   * Gets the string representation of term
   *
   * @returns {undefined|string}
   */
  get value() {
    const t = this.term;
    return t && t.value;
  }
  /**
   * Gets the string representation of terms
   *
   * @returns {string[]}
   */
  get values() {
    return this.terms.map((t) => t.value);
  }
  /**
   * Gets the current context's dataset, or undefined if there are multiple
   *
   * @returns {undefined|DatasetCore}
   */
  get dataset() {
    const t = this.datasets;
    if (t.length === 1)
      return t[0];
  }
  /**
   * Gets the current context's datasets
   *
   * @returns {DatasetCore[]}
   */
  get datasets() {
    return this._context.map((t) => t.dataset).filter(Boolean);
  }
  /**
   * Removes current pointers from the context and return an "any pointer".
   * The returned object can be used to find any nodes in the dataset
   *
   * @returns {Clownface}
   */
  any() {
    return Yr.fromContext(this._context.map((t) => t.clone({})), this);
  }
  /**
   * Returns true if the current term is a rdf:List
   *
   * @returns {boolean}
   */
  isList() {
    return this.term ? !!(this.term.equals(this.namespace.nil) || this.out(this.namespace.first).term) : !1;
  }
  /**
   * Creates an iterator which iterates and rdf:List of the current term
   *
   * @returns {Iterable | null}
   */
  list() {
    if (this.terms.length > 1)
      throw new Error("iterator over multiple terms is not supported");
    if (this.term && (this.term.termType !== "NamedNode" && this.term.termType !== "BlankNode" || !this.term.equals(this.namespace.nil) && !this.out(this.namespace.first).term))
      return null;
    let t = this;
    return {
      [Symbol.iterator]: () => ({
        next: () => {
          if (!t.term || t.term.equals(this.namespace.nil))
            return { done: !0 };
          const r = t.out(this.namespace.first);
          if (r.terms.length > 1)
            throw new Error(`Invalid list: multiple values for rdf:first on ${t.value}`);
          const n = t.out(this.namespace.rest);
          if (n.terms.length > 1)
            throw new Error(`Invalid list: multiple values for rdf:rest on ${t.value}`);
          return t = n, { done: !1, value: r };
        }
      })
    };
  }
  /**
   * Returns an array of graph pointers where each one has a single _context
   *
   * @returns {Clownface[]}
   */
  toArray() {
    return this._context.map((t) => Yr.fromContext(t, this)).filter((t) => t.terms.some(Boolean));
  }
  /**
   * Returns graph pointers which meet the condition specified in a callback function
   * @param {FilterCallback} callback
   * @returns {Clownface}
   */
  filter(t) {
    const r = this._context.map((n) => Yr.fromContext(n, this));
    return Yr.fromContext(this._context.filter((n, o) => t(Yr.fromContext(n, this), o, r)), this);
  }
  /**
   * Performs the specified action on every graph pointer
   * @param {ForEachCallback} callback
   * @returns {Clownface}
   */
  forEach(t) {
    return this.toArray().forEach(t), this;
  }
  /**
   * Calls a defined callback function on each graph pointer, and returns an array that contains the results.
   * @template T
   * @param {MapCallback<T>} callback
   * @returns {T[]}
   */
  map(t) {
    return this.toArray().map(t);
  }
  toString() {
    return this.values.join();
  }
  /**
   * Creates graph pointer to one or more node(s)
   *
   * Depending on the value creates pointers to:
   *
   * - blank node context for null `values`
   * - literal for string `values` and no `options` paramter
   * - matching RDF/JS term
   * - term created according to `options.type` parameter
   *
   * @param {null|string|string[]|Term|Term[]|Clownface|Clownface[]} values
   * @param {Object} [options]
   * @param {"NamedNode"|"BlankNode"|"Literal"} [options.type] explicit type for nodes
   * @param {string} [options.language] language tag of literals
   * @param {string} [options.datatype] datatype of literals
   * @returns {Clownface}
   */
  node(t, { type: r, datatype: n, language: o } = {}) {
    t = this._toTermArray(t, r, n || o) || [null];
    const s = t.reduce((a, l) => a.concat(this._context.reduce((u, f) => u.concat([f.clone({ value: l })]), [])), []);
    return Yr.fromContext(s, { factory: this.factory });
  }
  /**
   * Creates graph pointer to one or more blank nodes
   * @param {null|string|string[]|BlankNode|BlankNode[]|Clownface|Clownface[]} [values] blank node identifiers (generates it when falsy) or existing RDF/JS blank node(s)
   * @returns {Clownface}
   */
  blankNode(t) {
    return this.node(t, { type: "BlankNode" });
  }
  /**
   * Creates graph pointer to one or more literal nodes
   * @param {string|string[]|boolean|boolean[]|number|number[]|Literal|Literal[]|Clownface|Clownface[]} values literal values as JS objects or RDF/JS Literal(s)
   * @param {string|Term} [languageOrDatatype] a language tag string or datatype term
   * @returns {Clownface}
   */
  literal(t, r) {
    return this.node(t, { type: "Literal", datatype: r });
  }
  /**
   * Creates graph pointer to one or more named nodes
   * @param {string|string[]|NamedNode|NamedNode[]|Clownface|Clownface[]} values URI(s) or RDF/JS NamedNode(s)
   * @returns {Clownface}
   */
  namedNode(t) {
    return this.node(t, { type: "NamedNode" });
  }
  /**
   * Creates a graph pointer to nodes which are linked to the current pointer by `predicates`
   * @param {Term|Term[]|Clownface|Clownface[]} [predicates] one or more RDF/JS term identifying a property
   * @returns {Clownface}
   */
  in(t) {
    t = this._toTermArray(t);
    const r = this._context.reduce((n, o) => n.concat(o.in(t)), []);
    return Yr.fromContext(r, this);
  }
  /**
   * Creates a graph pointer to the result nodes after following a predicate, or after
   * following any predicates in an array, starting from the subject(s) (current graph pointer) to the objects.
   * @param {Term|Term[]|Clownface|Clownface[]} [predicates] any predicates to follow
   * @param {object} [options]
   * @param {string | string[] | undefined} [options.language]
   * @returns {Clownface}
   */
  out(t, r = {}) {
    t = this._toTermArray(t);
    const n = this._context.reduce((o, s) => o.concat(s.out(t, r)), []);
    return Yr.fromContext(n, this);
  }
  /**
   * Creates a graph pointer to nodes which are subjects of predicates, optionally also with specific objects
   *
   * If the current context is empty, will check all potential subjects
   *
   * @param {Term|Term[]|Clownface|Clownface[]} predicates RDF property identifiers
   * @param {*} [objects] object values to match
   * @returns {Clownface}
   */
  has(t, r) {
    t = this._toTermArray(t), r = this._toTermArray(r);
    const n = this._context.reduce((o, s) => o.concat(s.has(t, r)), []);
    return Yr.fromContext(n, this);
  }
  /**
   * Creates a new quad(s) in the dataset where the current context is the object
   *
   * @param {Term|Term[]|Clownface|Clownface[]} predicates
   * @param {NamedNode|NamedNode[]|Clownface|Clownface[]} subjects one or more nodes to use as subjects
   * @param {GraphPointerCallback} [callback] called for each object, with subject pointer as parameter
   * @returns {Clownface} current graph pointer
   */
  addIn(t, r, n) {
    if (!t)
      throw new Error("predicate parameter is required");
    typeof r == "function" && (n = r, r = null), t = this._toTermArray(t), r = this._toTermArray(r) || [this.factory.blankNode()];
    const o = this._context.map((s) => s.addIn(t, r));
    return n && Yr.fromContext(o, this).forEach(n), this;
  }
  /**
   * Creates a new quad(s) in the dataset where the current context is the subject
   *
   * @param {Term|Term[]|Clownface|Clownface[]} predicates
   * @param {*} objects one or more values to use for objects
   * @param {GraphPointerCallback} [callback] called for each subject, with object pointer as parameter
   * @returns {Clownface} current graph pointer
   */
  addOut(t, r, n) {
    if (!t)
      throw new Error("predicate parameter is required");
    typeof r == "function" && (n = r, r = null), t = this._toTermArray(t), r = this._toTermArray(r) || [this.factory.blankNode()];
    const o = this._context.map((s) => s.addOut(t, r));
    return n && Yr.fromContext(o, this).forEach(n), this;
  }
  /**
   * Creates a new RDF list or lists containing the given items
   *
   * @param {Term|Term[]|Clownface|Clownface[]} predicates
   * @param {*} items one or more values to use for subjects
   * @returns {Clownface} current graph pointer
   */
  addList(t, r) {
    if (!t || !r)
      throw new Error("predicate and items parameter is required");
    return t = this._toTermArray(t), r = this._toTermArray(r), this._context.forEach((n) => n.addList(t, r)), this;
  }
  /**
   * Deletes all quads where the current graph pointer contexts are the objects
   *
   * @param {Term|Term[]|Clownface|Clownface[]} [predicates]
   * @param {Term|Term[]|Clownface|Clownface[]} [subjects]
   * @returns {Clownface} current graph pointer
   */
  deleteIn(t, r) {
    return t = this._toTermArray(t), r = this._toTermArray(r), this._context.forEach((n) => n.deleteIn(t, r)), this;
  }
  /**
   * Deletes all quads where the current graph pointer contexts are the subjects
   *
   * @param {Term|Term[]|Clownface|Clownface[]} [predicates]
   * @param {Term|Term[]|Clownface|Clownface[]} [objects]
   * @returns {Clownface} current graph pointer
   */
  deleteOut(t, r) {
    return t = this._toTermArray(t), r = this._toTermArray(r), this._context.forEach((n) => n.deleteOut(t, r)), this;
  }
  /**
   * Deletes entire RDF lists where the current graph pointer is the subject
   *
   * @param {Term|Term[]|Clownface|Clownface[]} predicates
   * @returns {Clownface} current graph pointer
   */
  deleteList(t) {
    if (!t)
      throw new Error("predicate parameter is required");
    return t = this._toTermArray(t), this._context.forEach((r) => r.deleteList(t)), this;
  }
  _toTermArray(t, r, n) {
    return uK(t, r, n, this.factory);
  }
  static fromContext(t, { factory: r }) {
    return new Yr({ _context: Jr(t), factory: r });
  }
}
function pK({ dataset: e, graph: t, term: r, value: n, factory: o = Fa, _context: s }) {
  return new Yr({ dataset: e, graph: t, term: r, value: n, factory: o, _context: s });
}
class vD {
  clownface({ ...t } = {}) {
    return !t.dataset && typeof this.dataset == "function" && (t.dataset = this.dataset()), pK({ ...t, factory: this });
  }
}
vD.exports = ["clownface"];
var RTe = typeof globalThis < "u" ? globalThis : typeof window < "u" || typeof window < "u" ? window : typeof self < "u" ? self : {};
function $n(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function gK(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else
    r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var o = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(r, n, o.get ? o : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), r;
}
function bK(e) {
  return "_:" + e.value;
}
var yK = bK;
function mK(e, t) {
  return [...e].map((r) => t(r)).join(`
`) + `
`;
}
var vK = mK;
function wK() {
  return "";
}
var _K = wK;
function SK(e) {
  return "<" + e.value + ">";
}
var wD = SK;
const EK = wD, xK = /["\\\\\n\r]/, RK = /["\\\\\n\r]/g, AK = {
  '"': '\\"',
  "\\": "\\\\",
  "\n": "\\n",
  "\r": "\\r"
};
function TK(e) {
  return AK[e];
}
function $K(e) {
  return xK.test(e) ? e.replace(RK, TK) : e;
}
function CK(e) {
  const t = $K(e.value);
  return e.datatype.value === "http://www.w3.org/2001/XMLSchema#string" ? '"' + t + '"' : e.datatype.value === "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" ? '"' + t + '"@' + e.language : '"' + t + '"^^' + EK(e.datatype);
}
var kK = CK;
function IK(e, t) {
  const r = t(e.subject), n = t(e.predicate), o = t(e.object), s = t(e.graph);
  return `${r} ${n} ${o} ${s ? s + " " : ""}.`;
}
var MK = IK;
function NK(e) {
  return "?" + e.value;
}
var LK = NK;
const OK = yK, PK = vK, DK = _K, FK = kK, jK = wD, BK = MK, qK = LK;
function D1(e) {
  if (!e)
    return null;
  if (e.termType === "BlankNode")
    return OK(e);
  if (e.termType === "DefaultGraph")
    return DK();
  if (e.termType === "Literal")
    return FK(e);
  if (e.termType === "NamedNode")
    return jK(e);
  if (e.termType === "Quad" || e.subject && e.predicate && e.object && e.graph)
    return BK(e, D1);
  if (e.termType === "Variable")
    return qK(e);
  if (e[Symbol.iterator])
    return PK(e, D1);
  throw new Error(`unknown termType ${e.termType}`);
}
var WK = D1;
const Yo = /* @__PURE__ */ $n(WK);
class Vu {
  constructor(t) {
    if (this.index = /* @__PURE__ */ new Map(), t)
      for (const [r, n] of t)
        this.set(r, n);
  }
  get size() {
    return this.index.size;
  }
  clear() {
    this.index.clear();
  }
  delete(t) {
    return this.index.delete(Yo(t));
  }
  *entries() {
    for (const [, { term: t, value: r }] of this.index)
      yield [t, r];
  }
  forEach(t, r) {
    for (const n of this.entries())
      t.call(r, n[1], n[0], this);
  }
  get(t) {
    const r = this.index.get(Yo(t));
    return r && r.value;
  }
  has(t) {
    return this.index.has(Yo(t));
  }
  *keys() {
    for (const [, { term: t }] of this.index)
      yield t;
  }
  set(t, r) {
    const n = Yo(t);
    return this.index.set(n, { term: t, value: r }), this;
  }
  *values() {
    for (const [, { value: t }] of this.index)
      yield t;
  }
  [Symbol.iterator]() {
    return this.entries()[Symbol.iterator]();
  }
}
let _D = class {
  termMap(t) {
    return new Vu(t);
  }
};
_D.exports = ["termMap"];
function _T(e) {
  try {
    return Yo(e);
  } catch {
    return null;
  }
}
class UK {
  constructor(t) {
    if (this.index = /* @__PURE__ */ new Map(), t)
      for (const r of t)
        this.add(r);
  }
  get size() {
    return this.index.size;
  }
  add(t) {
    const r = Yo(t);
    return this.index.has(r) || this.index.set(r, t), this;
  }
  clear() {
    this.index.clear();
  }
  delete(t) {
    return t ? this.index.delete(_T(t)) : !1;
  }
  entries() {
    return this.values().entries();
  }
  forEach(t, r) {
    return this.values().forEach(t, r);
  }
  has(t) {
    return t ? this.index.has(_T(t)) : !1;
  }
  values() {
    return new Set(this.index.values());
  }
  keys() {
    return this.values();
  }
  [Symbol.iterator]() {
    return this.values()[Symbol.iterator]();
  }
}
let SD = class {
  termSet(t) {
    return new UK(t);
  }
};
SD.exports = ["termSet"];
class HK {
  constructor() {
    this.quadLevel = /* @__PURE__ */ new Map();
  }
  add(t, r) {
    this.quadLevel.set(Yo(t), r);
  }
  has(t, r) {
    const n = this.quadLevel.get(Yo(t));
    return n === void 0 ? !1 : n <= r;
  }
}
function _b({ backward: e, callback: t, dataset: r, filter: n, forward: o, term: s, visited: a = new HK() }) {
  const l = (u, f) => {
    const c = (d) => {
      for (const h of d) {
        if (a.has(h, f))
          continue;
        a.add(h, f);
        const p = { dataset: r, level: f, quad: h };
        n(p) && (t(p), o && l(h.object, f + 1), e && l(h.subject, f + 1));
      }
    };
    o && c(r.match(u)), e && c(r.match(null, null, u));
  };
  l(s, 0);
}
class zK {
  constructor(t, { backward: r = !1, factory: n, forward: o = !0 }) {
    this.backward = r, this.factory = n, this.filter = t, this.forward = o;
  }
  forEach({ term: t, dataset: r }, n) {
    _b({
      backward: this.backward,
      callback: n,
      dataset: r,
      filter: this.filter,
      forward: this.forward,
      term: t
    });
  }
  match({ term: t, dataset: r }) {
    const n = this.factory.dataset();
    return _b({
      backward: this.backward,
      callback: ({ quad: o }) => n.add(o),
      dataset: r,
      filter: this.filter,
      forward: this.forward,
      term: t
    }), n;
  }
  reduce({ term: t, dataset: r }, n, o) {
    let s = o;
    return _b({
      backward: this.backward,
      callback: (a) => {
        s = n(a, s);
      },
      dataset: r,
      filter: this.filter,
      forward: this.forward,
      term: t
    }), s;
  }
}
let ED = class {
  traverser(t, { backward: r = !1, forward: n = !0 } = {}) {
    return new zK(t, { backward: r, factory: this, forward: n });
  }
};
ED.exports = ["traverser"];
const GK = new Bf([
  lu,
  pD,
  XE,
  bD,
  vD,
  _D,
  SD,
  ED
]);
function Is(e) {
  return typeof e == "string" || e instanceof String;
}
const VK = "http://www.w3.org/2001/XMLSchema#string";
function Gt(e) {
  if (typeof e == "string")
    return e;
  if (!e)
    return "";
  if (typeof e.id < "u" && e.termType !== "Quad")
    return e.id;
  let t, r, n, o;
  switch (e.termType) {
    case "NamedNode":
      return e.value;
    case "BlankNode":
      return `_:${e.value}`;
    case "Variable":
      return `?${e.value}`;
    case "DefaultGraph":
      return "";
    case "Literal":
      return e.language ? `"${e.value}"@${e.language}` : `"${e.value}"${e.datatype && e.datatype.value !== VK ? `^^${e.datatype.value}` : ""}`;
    case "Quad":
      return t = Sb(Gt(e.subject)), r = Sb(Gt(e.predicate)), n = Sb(Gt(e.object)), o = e.graph.termType === "DefaultGraph" ? "" : ` ${Gt(e.graph)}`, `<<${t} ${r} ${n}${o}>>`;
    default:
      throw new Error(`Unexpected termType: ${e.termType}`);
  }
}
const KK = /^"(.*".*)(?="[^"]*$)/;
function Sb(e) {
  return e.replace(KK, (t, r) => `"${r.replace(/"/g, '""')}`);
}
class xD {
  constructor(t) {
    if (this._size = 0, this._graphs = /* @__PURE__ */ Object.create(null), this._id = 0, this._ids = /* @__PURE__ */ Object.create(null), this._ids["><"] = 0, this._entities = /* @__PURE__ */ Object.create(null), this._quads = /* @__PURE__ */ new Map(), t)
      for (const r of t)
        this.add(r);
  }
  get size() {
    let t = this._size;
    if (t !== null)
      return t;
    t = 0;
    const r = this._graphs;
    let n, o;
    for (const s in r)
      for (const a in n = r[s].subjects)
        for (const l in o = n[a])
          t += Object.keys(o[l]).length;
    return this._size = t, this._size;
  }
  add(t) {
    let r = Gt(t.subject), n = Gt(t.predicate), o = Gt(t.object);
    const s = Gt(t.graph);
    let a = this._graphs[s];
    a || (a = this._graphs[s] = { subjects: {}, predicates: {}, objects: {} }, Object.freeze(a));
    const l = this._ids, u = this._entities;
    return r = l[r] || (l[u[++this._id] = r] = this._id), n = l[n] || (l[u[++this._id] = n] = this._id), o = l[o] || (l[u[++this._id] = o] = this._id), this._addToIndex(a.subjects, r, n, o), this._addToIndex(a.predicates, n, o, r), this._addToIndex(a.objects, o, r, n), this._setQuad(r, n, o, s, t), this._size = null, this;
  }
  delete(t) {
    let r = Gt(t.subject), n = Gt(t.predicate), o = Gt(t.object);
    const s = Gt(t.graph), a = this._ids, l = this._graphs;
    let u, f, c;
    if (!(r = a[r]) || !(n = a[n]) || !(o = a[o]) || !(u = l[s]) || !(f = u.subjects[r]) || !(c = f[n]) || !(o in c))
      return this;
    this._removeFromIndex(u.subjects, r, n, o), this._removeFromIndex(u.predicates, n, o, r), this._removeFromIndex(u.objects, o, r, n), this._size !== null && this._size--, this._deleteQuad(r, n, o, s);
    for (r in u.subjects)
      return this;
    return delete l[s], this;
  }
  has(t) {
    const r = Gt(t.subject), n = Gt(t.predicate), o = Gt(t.object), s = Gt(t.graph), a = this._graphs[s];
    if (!a)
      return !1;
    const l = this._ids;
    let u, f, c;
    return Is(r) && !(u = l[r]) || Is(n) && !(f = l[n]) || Is(o) && !(c = l[o]) ? !1 : this._countInIndex(a.objects, c, u, f) === 1;
  }
  match(t, r, n, o) {
    return this._createDataset(this._match(t, r, n, o));
  }
  [Symbol.iterator]() {
    return this._match()[Symbol.iterator]();
  }
  // ## Private methods
  // ### `_addToIndex` adds a quad to a three-layered index.
  // Returns if the index has changed, if the entry did not already exist.
  _addToIndex(t, r, n, o) {
    const s = t[r] || (t[r] = {}), a = s[n] || (s[n] = {}), l = o in a;
    return l || (a[o] = null), !l;
  }
  // ### `_removeFromIndex` removes a quad from a three-layered index
  _removeFromIndex(t, r, n, o) {
    const s = t[r], a = s[n];
    delete a[o];
    for (const l in a)
      return;
    delete s[n];
    for (const l in s)
      return;
    delete t[r];
  }
  // ### `_findInIndex` finds a set of quads in a three-layered index.
  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.
  // Any of these keys can be undefined, which is interpreted as a wildcard.
  // `name0`, `name1`, and `name2` are the names of the keys at each level,
  // used when reconstructing the resulting quad
  // (for instance: _subject_, _predicate_, and _object_).
  // Finally, `graph` will be the graph of the created quads.
  // If `callback` is given, each result is passed through it
  // and iteration halts when it returns truthy for any quad.
  // If instead `array` is given, each result is added to the array.
  _findInIndex(t, r, n, o, s, a, l, u, f, c) {
    let d, h, p;
    r && ((d = t, t = {})[r] = d[r]);
    for (const m in t)
      if (h = t[m], h) {
        n && ((d = h, h = {})[n] = d[n]);
        for (const y in h)
          if (p = h[y], p) {
            const _ = o ? o in p ? [o] : [] : Object.keys(p);
            for (let S = 0; S < _.length; S++) {
              const x = {
                [s]: m,
                [a]: y,
                [l]: _[S]
              }, E = this._getQuad(x.subject, x.predicate, x.object, u);
              if (c)
                c.push(E);
              else if (f(E))
                return !0;
            }
          }
      }
    return c;
  }
  // ### `_countInIndex` counts matching quads in a three-layered index.
  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.
  // Any of these keys can be undefined, which is interpreted as a wildcard.
  _countInIndex(t, r, n, o) {
    let s = 0, a, l, u;
    r && ((a = t, t = {})[r] = a[r]);
    for (const f in t)
      if (l = t[f], l) {
        n && ((a = l, l = {})[n] = a[n]);
        for (const c in l)
          u = l[c], u && (o ? o in u && s++ : s += Object.keys(u).length);
      }
    return s;
  }
  // ### `_getGraphs` returns an array with the given graph,
  // or all graphs if the argument is null or undefined.
  _getGraphs(t) {
    return Is(t) ? {
      [t]: this._graphs[t]
    } : this._graphs;
  }
  _match(t, r, n, o) {
    t = t && Gt(t), r = r && Gt(r), n = n && Gt(n), o = o && Gt(o);
    const s = [], a = this._getGraphs(o), l = this._ids;
    let u, f, c, d;
    if (Is(t) && !(f = l[t]) || Is(r) && !(c = l[r]) || Is(n) && !(d = l[n]))
      return s;
    for (const h in a)
      u = a[h], u && (f ? d ? this._findInIndex(u.objects, d, f, c, "object", "subject", "predicate", h, null, s) : this._findInIndex(u.subjects, f, c, null, "subject", "predicate", "object", h, null, s) : c ? this._findInIndex(u.predicates, c, d, null, "predicate", "object", "subject", h, null, s) : d ? this._findInIndex(u.objects, d, null, null, "object", "subject", "predicate", h, null, s) : this._findInIndex(u.subjects, null, null, null, "subject", "predicate", "object", h, null, s));
    return s;
  }
  _getQuad(t, r, n, o) {
    return this._quads.get(this._toId(t, r, n, o));
  }
  _setQuad(t, r, n, o, s) {
    this._quads.set(this._toId(t, r, n, o), s);
  }
  _deleteQuad(t, r, n, o) {
    this._quads.delete(this._toId(t, r, n, o));
  }
  _createDataset(t) {
    return new this.constructor(t);
  }
  _toId(t, r, n, o) {
    return `${t}:${r}:${n}:${o}`;
  }
}
function YK(e, t) {
  for (const r of t)
    e.add(r);
  return e;
}
var XK = YK;
const ST = /* @__PURE__ */ $n(XK);
function JK(e, t, r, n, o) {
  const s = e.match(t, r, n, o);
  for (const a of s)
    e.delete(a);
  return e;
}
var QK = JK;
const ZK = /* @__PURE__ */ $n(QK);
function eY(e, t) {
  if (e.size !== t.size)
    return !1;
  for (const r of e)
    if (!t.has(r))
      return !1;
  return !0;
}
var tY = eY;
const rY = /* @__PURE__ */ $n(tY);
class mf extends xD {
  addAll(...[t]) {
    return ST(this, t);
  }
  deleteMatches(...t) {
    return ZK(this, ...t);
  }
  equals(...[t]) {
    return rY(this, t);
  }
  forEach(t) {
    Array.from(this).forEach((r) => t(r, this));
  }
  filter(t) {
    return new mf([...this].filter((r) => t(r, this)));
  }
  map(t) {
    return new mf([...this].map((r) => t(r, this)));
  }
  match(...t) {
    return super.match(...t);
  }
  merge(...[t]) {
    return ST(new mf([...this]), t);
  }
}
const Vt = new Bf([n9(() => mf)], { parent: GK });
class RD {
  dataset(t) {
    return new xD(t);
  }
}
RD.exports = ["dataset"];
function nY(e) {
  return !(!e || typeof e.dataset != "function");
}
async function F1(e) {
  const t = [];
  for await (const r of e)
    t.push(r);
  return t;
}
class iY {
  constructor(t, r) {
    this.Impl = t, this.options = r;
  }
  import(t, r) {
    const n = new this.Impl(t, { ...this.options, ...r });
    return t.on("end", () => {
      n.readable || n.emit("end");
    }), t.on("error", (o) => {
      n.emit("error", o);
    }), n;
  }
}
const Eb = /* @__PURE__ */ new Set(["_write", "_writableState", "writable"]);
function AD(e) {
  return new Proxy(e, {
    has(t, r) {
      return Eb.has(r) ? !1 : Reflect.has(...arguments);
    },
    get(t, r) {
      if (Eb.has(r))
        return;
      const n = Reflect.get(...arguments);
      return n && typeof n.bind == "function" ? n.bind(t) : n;
    },
    set(t, r, n) {
      if (!Eb.has(r))
        return Reflect.set(...arguments);
    }
  });
}
var ut = {}, wp = {};
wp.byteLength = aY;
wp.toByteArray = uY;
wp.fromByteArray = dY;
var bi = [], vn = [], oY = typeof Uint8Array < "u" ? Uint8Array : Array, xb = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var fl = 0, sY = xb.length; fl < sY; ++fl)
  bi[fl] = xb[fl], vn[xb.charCodeAt(fl)] = fl;
vn[45] = 62;
vn[95] = 63;
function TD(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var n = r === t ? 0 : 4 - r % 4;
  return [r, n];
}
function aY(e) {
  var t = TD(e), r = t[0], n = t[1];
  return (r + n) * 3 / 4 - n;
}
function lY(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function uY(e) {
  var t, r = TD(e), n = r[0], o = r[1], s = new oY(lY(e, n, o)), a = 0, l = o > 0 ? n - 4 : n, u;
  for (u = 0; u < l; u += 4)
    t = vn[e.charCodeAt(u)] << 18 | vn[e.charCodeAt(u + 1)] << 12 | vn[e.charCodeAt(u + 2)] << 6 | vn[e.charCodeAt(u + 3)], s[a++] = t >> 16 & 255, s[a++] = t >> 8 & 255, s[a++] = t & 255;
  return o === 2 && (t = vn[e.charCodeAt(u)] << 2 | vn[e.charCodeAt(u + 1)] >> 4, s[a++] = t & 255), o === 1 && (t = vn[e.charCodeAt(u)] << 10 | vn[e.charCodeAt(u + 1)] << 4 | vn[e.charCodeAt(u + 2)] >> 2, s[a++] = t >> 8 & 255, s[a++] = t & 255), s;
}
function fY(e) {
  return bi[e >> 18 & 63] + bi[e >> 12 & 63] + bi[e >> 6 & 63] + bi[e & 63];
}
function cY(e, t, r) {
  for (var n, o = [], s = t; s < r; s += 3)
    n = (e[s] << 16 & 16711680) + (e[s + 1] << 8 & 65280) + (e[s + 2] & 255), o.push(fY(n));
  return o.join("");
}
function dY(e) {
  for (var t, r = e.length, n = r % 3, o = [], s = 16383, a = 0, l = r - n; a < l; a += s)
    o.push(cY(e, a, a + s > l ? l : a + s));
  return n === 1 ? (t = e[r - 1], o.push(
    bi[t >> 2] + bi[t << 4 & 63] + "=="
  )) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], o.push(
    bi[t >> 10] + bi[t >> 4 & 63] + bi[t << 2 & 63] + "="
  )), o.join("");
}
var QE = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
QE.read = function(e, t, r, n, o) {
  var s, a, l = o * 8 - n - 1, u = (1 << l) - 1, f = u >> 1, c = -7, d = r ? o - 1 : 0, h = r ? -1 : 1, p = e[t + d];
  for (d += h, s = p & (1 << -c) - 1, p >>= -c, c += l; c > 0; s = s * 256 + e[t + d], d += h, c -= 8)
    ;
  for (a = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; a = a * 256 + e[t + d], d += h, c -= 8)
    ;
  if (s === 0)
    s = 1 - f;
  else {
    if (s === u)
      return a ? NaN : (p ? -1 : 1) * (1 / 0);
    a = a + Math.pow(2, n), s = s - f;
  }
  return (p ? -1 : 1) * a * Math.pow(2, s - n);
};
QE.write = function(e, t, r, n, o, s) {
  var a, l, u, f = s * 8 - o - 1, c = (1 << f) - 1, d = c >> 1, h = o === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = n ? 0 : s - 1, m = n ? 1 : -1, y = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (l = isNaN(t) ? 1 : 0, a = c) : (a = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -a)) < 1 && (a--, u *= 2), a + d >= 1 ? t += h / u : t += h * Math.pow(2, 1 - d), t * u >= 2 && (a++, u /= 2), a + d >= c ? (l = 0, a = c) : a + d >= 1 ? (l = (t * u - 1) * Math.pow(2, o), a = a + d) : (l = t * Math.pow(2, d - 1) * Math.pow(2, o), a = 0)); o >= 8; e[r + p] = l & 255, p += m, l /= 256, o -= 8)
    ;
  for (a = a << o | l, f += o; f > 0; e[r + p] = a & 255, p += m, a /= 256, f -= 8)
    ;
  e[r + p - m] |= y * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const t = wp, r = QE, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = l, e.SlowBuffer = x, e.INSPECT_MAX_BYTES = 50;
  const o = 2147483647;
  e.kMaxLength = o, l.TYPED_ARRAY_SUPPORT = s(), !l.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function s() {
    try {
      const N = new Uint8Array(1), R = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(R, Uint8Array.prototype), Object.setPrototypeOf(N, R), N.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(l.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (l.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(l.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (l.isBuffer(this))
        return this.byteOffset;
    }
  });
  function a(N) {
    if (N > o)
      throw new RangeError('The value "' + N + '" is invalid for option "size"');
    const R = new Uint8Array(N);
    return Object.setPrototypeOf(R, l.prototype), R;
  }
  function l(N, R, A) {
    if (typeof N == "number") {
      if (typeof R == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return d(N);
    }
    return u(N, R, A);
  }
  l.poolSize = 8192;
  function u(N, R, A) {
    if (typeof N == "string")
      return h(N, R);
    if (ArrayBuffer.isView(N))
      return m(N);
    if (N == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof N
      );
    if (B(N, ArrayBuffer) || N && B(N.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (B(N, SharedArrayBuffer) || N && B(N.buffer, SharedArrayBuffer)))
      return y(N, R, A);
    if (typeof N == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const q = N.valueOf && N.valueOf();
    if (q != null && q !== N)
      return l.from(q, R, A);
    const re = _(N);
    if (re)
      return re;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof N[Symbol.toPrimitive] == "function")
      return l.from(N[Symbol.toPrimitive]("string"), R, A);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof N
    );
  }
  l.from = function(N, R, A) {
    return u(N, R, A);
  }, Object.setPrototypeOf(l.prototype, Uint8Array.prototype), Object.setPrototypeOf(l, Uint8Array);
  function f(N) {
    if (typeof N != "number")
      throw new TypeError('"size" argument must be of type number');
    if (N < 0)
      throw new RangeError('The value "' + N + '" is invalid for option "size"');
  }
  function c(N, R, A) {
    return f(N), N <= 0 ? a(N) : R !== void 0 ? typeof A == "string" ? a(N).fill(R, A) : a(N).fill(R) : a(N);
  }
  l.alloc = function(N, R, A) {
    return c(N, R, A);
  };
  function d(N) {
    return f(N), a(N < 0 ? 0 : S(N) | 0);
  }
  l.allocUnsafe = function(N) {
    return d(N);
  }, l.allocUnsafeSlow = function(N) {
    return d(N);
  };
  function h(N, R) {
    if ((typeof R != "string" || R === "") && (R = "utf8"), !l.isEncoding(R))
      throw new TypeError("Unknown encoding: " + R);
    const A = E(N, R) | 0;
    let q = a(A);
    const re = q.write(N, R);
    return re !== A && (q = q.slice(0, re)), q;
  }
  function p(N) {
    const R = N.length < 0 ? 0 : S(N.length) | 0, A = a(R);
    for (let q = 0; q < R; q += 1)
      A[q] = N[q] & 255;
    return A;
  }
  function m(N) {
    if (B(N, Uint8Array)) {
      const R = new Uint8Array(N);
      return y(R.buffer, R.byteOffset, R.byteLength);
    }
    return p(N);
  }
  function y(N, R, A) {
    if (R < 0 || N.byteLength < R)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (N.byteLength < R + (A || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let q;
    return R === void 0 && A === void 0 ? q = new Uint8Array(N) : A === void 0 ? q = new Uint8Array(N, R) : q = new Uint8Array(N, R, A), Object.setPrototypeOf(q, l.prototype), q;
  }
  function _(N) {
    if (l.isBuffer(N)) {
      const R = S(N.length) | 0, A = a(R);
      return A.length === 0 || N.copy(A, 0, 0, R), A;
    }
    if (N.length !== void 0)
      return typeof N.length != "number" || me(N.length) ? a(0) : p(N);
    if (N.type === "Buffer" && Array.isArray(N.data))
      return p(N.data);
  }
  function S(N) {
    if (N >= o)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes");
    return N | 0;
  }
  function x(N) {
    return +N != N && (N = 0), l.alloc(+N);
  }
  l.isBuffer = function(R) {
    return R != null && R._isBuffer === !0 && R !== l.prototype;
  }, l.compare = function(R, A) {
    if (B(R, Uint8Array) && (R = l.from(R, R.offset, R.byteLength)), B(A, Uint8Array) && (A = l.from(A, A.offset, A.byteLength)), !l.isBuffer(R) || !l.isBuffer(A))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (R === A)
      return 0;
    let q = R.length, re = A.length;
    for (let ce = 0, de = Math.min(q, re); ce < de; ++ce)
      if (R[ce] !== A[ce]) {
        q = R[ce], re = A[ce];
        break;
      }
    return q < re ? -1 : re < q ? 1 : 0;
  }, l.isEncoding = function(R) {
    switch (String(R).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, l.concat = function(R, A) {
    if (!Array.isArray(R))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (R.length === 0)
      return l.alloc(0);
    let q;
    if (A === void 0)
      for (A = 0, q = 0; q < R.length; ++q)
        A += R[q].length;
    const re = l.allocUnsafe(A);
    let ce = 0;
    for (q = 0; q < R.length; ++q) {
      let de = R[q];
      if (B(de, Uint8Array))
        ce + de.length > re.length ? (l.isBuffer(de) || (de = l.from(de)), de.copy(re, ce)) : Uint8Array.prototype.set.call(
          re,
          de,
          ce
        );
      else if (l.isBuffer(de))
        de.copy(re, ce);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      ce += de.length;
    }
    return re;
  };
  function E(N, R) {
    if (l.isBuffer(N))
      return N.length;
    if (ArrayBuffer.isView(N) || B(N, ArrayBuffer))
      return N.byteLength;
    if (typeof N != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof N
      );
    const A = N.length, q = arguments.length > 2 && arguments[2] === !0;
    if (!q && A === 0)
      return 0;
    let re = !1;
    for (; ; )
      switch (R) {
        case "ascii":
        case "latin1":
        case "binary":
          return A;
        case "utf8":
        case "utf-8":
          return L(N).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return A * 2;
        case "hex":
          return A >>> 1;
        case "base64":
          return oe(N).length;
        default:
          if (re)
            return q ? -1 : L(N).length;
          R = ("" + R).toLowerCase(), re = !0;
      }
  }
  l.byteLength = E;
  function C(N, R, A) {
    let q = !1;
    if ((R === void 0 || R < 0) && (R = 0), R > this.length || ((A === void 0 || A > this.length) && (A = this.length), A <= 0) || (A >>>= 0, R >>>= 0, A <= R))
      return "";
    for (N || (N = "utf8"); ; )
      switch (N) {
        case "hex":
          return fe(this, R, A);
        case "utf8":
        case "utf-8":
          return U(this, R, A);
        case "ascii":
          return te(this, R, A);
        case "latin1":
        case "binary":
          return se(this, R, A);
        case "base64":
          return k(this, R, A);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return he(this, R, A);
        default:
          if (q)
            throw new TypeError("Unknown encoding: " + N);
          N = (N + "").toLowerCase(), q = !0;
      }
  }
  l.prototype._isBuffer = !0;
  function I(N, R, A) {
    const q = N[R];
    N[R] = N[A], N[A] = q;
  }
  l.prototype.swap16 = function() {
    const R = this.length;
    if (R % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let A = 0; A < R; A += 2)
      I(this, A, A + 1);
    return this;
  }, l.prototype.swap32 = function() {
    const R = this.length;
    if (R % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let A = 0; A < R; A += 4)
      I(this, A, A + 3), I(this, A + 1, A + 2);
    return this;
  }, l.prototype.swap64 = function() {
    const R = this.length;
    if (R % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let A = 0; A < R; A += 8)
      I(this, A, A + 7), I(this, A + 1, A + 6), I(this, A + 2, A + 5), I(this, A + 3, A + 4);
    return this;
  }, l.prototype.toString = function() {
    const R = this.length;
    return R === 0 ? "" : arguments.length === 0 ? U(this, 0, R) : C.apply(this, arguments);
  }, l.prototype.toLocaleString = l.prototype.toString, l.prototype.equals = function(R) {
    if (!l.isBuffer(R))
      throw new TypeError("Argument must be a Buffer");
    return this === R ? !0 : l.compare(this, R) === 0;
  }, l.prototype.inspect = function() {
    let R = "";
    const A = e.INSPECT_MAX_BYTES;
    return R = this.toString("hex", 0, A).replace(/(.{2})/g, "$1 ").trim(), this.length > A && (R += " ... "), "<Buffer " + R + ">";
  }, n && (l.prototype[n] = l.prototype.inspect), l.prototype.compare = function(R, A, q, re, ce) {
    if (B(R, Uint8Array) && (R = l.from(R, R.offset, R.byteLength)), !l.isBuffer(R))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof R
      );
    if (A === void 0 && (A = 0), q === void 0 && (q = R ? R.length : 0), re === void 0 && (re = 0), ce === void 0 && (ce = this.length), A < 0 || q > R.length || re < 0 || ce > this.length)
      throw new RangeError("out of range index");
    if (re >= ce && A >= q)
      return 0;
    if (re >= ce)
      return -1;
    if (A >= q)
      return 1;
    if (A >>>= 0, q >>>= 0, re >>>= 0, ce >>>= 0, this === R)
      return 0;
    let de = ce - re, De = q - A;
    const it = Math.min(de, De), ze = this.slice(re, ce), Ve = R.slice(A, q);
    for (let Ze = 0; Ze < it; ++Ze)
      if (ze[Ze] !== Ve[Ze]) {
        de = ze[Ze], De = Ve[Ze];
        break;
      }
    return de < De ? -1 : De < de ? 1 : 0;
  };
  function j(N, R, A, q, re) {
    if (N.length === 0)
      return -1;
    if (typeof A == "string" ? (q = A, A = 0) : A > 2147483647 ? A = 2147483647 : A < -2147483648 && (A = -2147483648), A = +A, me(A) && (A = re ? 0 : N.length - 1), A < 0 && (A = N.length + A), A >= N.length) {
      if (re)
        return -1;
      A = N.length - 1;
    } else if (A < 0)
      if (re)
        A = 0;
      else
        return -1;
    if (typeof R == "string" && (R = l.from(R, q)), l.isBuffer(R))
      return R.length === 0 ? -1 : J(N, R, A, q, re);
    if (typeof R == "number")
      return R = R & 255, typeof Uint8Array.prototype.indexOf == "function" ? re ? Uint8Array.prototype.indexOf.call(N, R, A) : Uint8Array.prototype.lastIndexOf.call(N, R, A) : J(N, [R], A, q, re);
    throw new TypeError("val must be string, number or Buffer");
  }
  function J(N, R, A, q, re) {
    let ce = 1, de = N.length, De = R.length;
    if (q !== void 0 && (q = String(q).toLowerCase(), q === "ucs2" || q === "ucs-2" || q === "utf16le" || q === "utf-16le")) {
      if (N.length < 2 || R.length < 2)
        return -1;
      ce = 2, de /= 2, De /= 2, A /= 2;
    }
    function it(Ve, Ze) {
      return ce === 1 ? Ve[Ze] : Ve.readUInt16BE(Ze * ce);
    }
    let ze;
    if (re) {
      let Ve = -1;
      for (ze = A; ze < de; ze++)
        if (it(N, ze) === it(R, Ve === -1 ? 0 : ze - Ve)) {
          if (Ve === -1 && (Ve = ze), ze - Ve + 1 === De)
            return Ve * ce;
        } else
          Ve !== -1 && (ze -= ze - Ve), Ve = -1;
    } else
      for (A + De > de && (A = de - De), ze = A; ze >= 0; ze--) {
        let Ve = !0;
        for (let Ze = 0; Ze < De; Ze++)
          if (it(N, ze + Ze) !== it(R, Ze)) {
            Ve = !1;
            break;
          }
        if (Ve)
          return ze;
      }
    return -1;
  }
  l.prototype.includes = function(R, A, q) {
    return this.indexOf(R, A, q) !== -1;
  }, l.prototype.indexOf = function(R, A, q) {
    return j(this, R, A, q, !0);
  }, l.prototype.lastIndexOf = function(R, A, q) {
    return j(this, R, A, q, !1);
  };
  function G(N, R, A, q) {
    A = Number(A) || 0;
    const re = N.length - A;
    q ? (q = Number(q), q > re && (q = re)) : q = re;
    const ce = R.length;
    q > ce / 2 && (q = ce / 2);
    let de;
    for (de = 0; de < q; ++de) {
      const De = parseInt(R.substr(de * 2, 2), 16);
      if (me(De))
        return de;
      N[A + de] = De;
    }
    return de;
  }
  function $(N, R, A, q) {
    return ye(L(R, N.length - A), N, A, q);
  }
  function V(N, R, A, q) {
    return ye(ne(R), N, A, q);
  }
  function M(N, R, A, q) {
    return ye(oe(R), N, A, q);
  }
  function W(N, R, A, q) {
    return ye(ue(R, N.length - A), N, A, q);
  }
  l.prototype.write = function(R, A, q, re) {
    if (A === void 0)
      re = "utf8", q = this.length, A = 0;
    else if (q === void 0 && typeof A == "string")
      re = A, q = this.length, A = 0;
    else if (isFinite(A))
      A = A >>> 0, isFinite(q) ? (q = q >>> 0, re === void 0 && (re = "utf8")) : (re = q, q = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const ce = this.length - A;
    if ((q === void 0 || q > ce) && (q = ce), R.length > 0 && (q < 0 || A < 0) || A > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    re || (re = "utf8");
    let de = !1;
    for (; ; )
      switch (re) {
        case "hex":
          return G(this, R, A, q);
        case "utf8":
        case "utf-8":
          return $(this, R, A, q);
        case "ascii":
        case "latin1":
        case "binary":
          return V(this, R, A, q);
        case "base64":
          return M(this, R, A, q);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return W(this, R, A, q);
        default:
          if (de)
            throw new TypeError("Unknown encoding: " + re);
          re = ("" + re).toLowerCase(), de = !0;
      }
  }, l.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function k(N, R, A) {
    return R === 0 && A === N.length ? t.fromByteArray(N) : t.fromByteArray(N.slice(R, A));
  }
  function U(N, R, A) {
    A = Math.min(N.length, A);
    const q = [];
    let re = R;
    for (; re < A; ) {
      const ce = N[re];
      let de = null, De = ce > 239 ? 4 : ce > 223 ? 3 : ce > 191 ? 2 : 1;
      if (re + De <= A) {
        let it, ze, Ve, Ze;
        switch (De) {
          case 1:
            ce < 128 && (de = ce);
            break;
          case 2:
            it = N[re + 1], (it & 192) === 128 && (Ze = (ce & 31) << 6 | it & 63, Ze > 127 && (de = Ze));
            break;
          case 3:
            it = N[re + 1], ze = N[re + 2], (it & 192) === 128 && (ze & 192) === 128 && (Ze = (ce & 15) << 12 | (it & 63) << 6 | ze & 63, Ze > 2047 && (Ze < 55296 || Ze > 57343) && (de = Ze));
            break;
          case 4:
            it = N[re + 1], ze = N[re + 2], Ve = N[re + 3], (it & 192) === 128 && (ze & 192) === 128 && (Ve & 192) === 128 && (Ze = (ce & 15) << 18 | (it & 63) << 12 | (ze & 63) << 6 | Ve & 63, Ze > 65535 && Ze < 1114112 && (de = Ze));
        }
      }
      de === null ? (de = 65533, De = 1) : de > 65535 && (de -= 65536, q.push(de >>> 10 & 1023 | 55296), de = 56320 | de & 1023), q.push(de), re += De;
    }
    return Y(q);
  }
  const Z = 4096;
  function Y(N) {
    const R = N.length;
    if (R <= Z)
      return String.fromCharCode.apply(String, N);
    let A = "", q = 0;
    for (; q < R; )
      A += String.fromCharCode.apply(
        String,
        N.slice(q, q += Z)
      );
    return A;
  }
  function te(N, R, A) {
    let q = "";
    A = Math.min(N.length, A);
    for (let re = R; re < A; ++re)
      q += String.fromCharCode(N[re] & 127);
    return q;
  }
  function se(N, R, A) {
    let q = "";
    A = Math.min(N.length, A);
    for (let re = R; re < A; ++re)
      q += String.fromCharCode(N[re]);
    return q;
  }
  function fe(N, R, A) {
    const q = N.length;
    (!R || R < 0) && (R = 0), (!A || A < 0 || A > q) && (A = q);
    let re = "";
    for (let ce = R; ce < A; ++ce)
      re += Ce[N[ce]];
    return re;
  }
  function he(N, R, A) {
    const q = N.slice(R, A);
    let re = "";
    for (let ce = 0; ce < q.length - 1; ce += 2)
      re += String.fromCharCode(q[ce] + q[ce + 1] * 256);
    return re;
  }
  l.prototype.slice = function(R, A) {
    const q = this.length;
    R = ~~R, A = A === void 0 ? q : ~~A, R < 0 ? (R += q, R < 0 && (R = 0)) : R > q && (R = q), A < 0 ? (A += q, A < 0 && (A = 0)) : A > q && (A = q), A < R && (A = R);
    const re = this.subarray(R, A);
    return Object.setPrototypeOf(re, l.prototype), re;
  };
  function ae(N, R, A) {
    if (N % 1 !== 0 || N < 0)
      throw new RangeError("offset is not uint");
    if (N + R > A)
      throw new RangeError("Trying to access beyond buffer length");
  }
  l.prototype.readUintLE = l.prototype.readUIntLE = function(R, A, q) {
    R = R >>> 0, A = A >>> 0, q || ae(R, A, this.length);
    let re = this[R], ce = 1, de = 0;
    for (; ++de < A && (ce *= 256); )
      re += this[R + de] * ce;
    return re;
  }, l.prototype.readUintBE = l.prototype.readUIntBE = function(R, A, q) {
    R = R >>> 0, A = A >>> 0, q || ae(R, A, this.length);
    let re = this[R + --A], ce = 1;
    for (; A > 0 && (ce *= 256); )
      re += this[R + --A] * ce;
    return re;
  }, l.prototype.readUint8 = l.prototype.readUInt8 = function(R, A) {
    return R = R >>> 0, A || ae(R, 1, this.length), this[R];
  }, l.prototype.readUint16LE = l.prototype.readUInt16LE = function(R, A) {
    return R = R >>> 0, A || ae(R, 2, this.length), this[R] | this[R + 1] << 8;
  }, l.prototype.readUint16BE = l.prototype.readUInt16BE = function(R, A) {
    return R = R >>> 0, A || ae(R, 2, this.length), this[R] << 8 | this[R + 1];
  }, l.prototype.readUint32LE = l.prototype.readUInt32LE = function(R, A) {
    return R = R >>> 0, A || ae(R, 4, this.length), (this[R] | this[R + 1] << 8 | this[R + 2] << 16) + this[R + 3] * 16777216;
  }, l.prototype.readUint32BE = l.prototype.readUInt32BE = function(R, A) {
    return R = R >>> 0, A || ae(R, 4, this.length), this[R] * 16777216 + (this[R + 1] << 16 | this[R + 2] << 8 | this[R + 3]);
  }, l.prototype.readBigUInt64LE = Ie(function(R) {
    R = R >>> 0, b(R, "offset");
    const A = this[R], q = this[R + 7];
    (A === void 0 || q === void 0) && w(R, this.length - 8);
    const re = A + this[++R] * 2 ** 8 + this[++R] * 2 ** 16 + this[++R] * 2 ** 24, ce = this[++R] + this[++R] * 2 ** 8 + this[++R] * 2 ** 16 + q * 2 ** 24;
    return BigInt(re) + (BigInt(ce) << BigInt(32));
  }), l.prototype.readBigUInt64BE = Ie(function(R) {
    R = R >>> 0, b(R, "offset");
    const A = this[R], q = this[R + 7];
    (A === void 0 || q === void 0) && w(R, this.length - 8);
    const re = A * 2 ** 24 + this[++R] * 2 ** 16 + this[++R] * 2 ** 8 + this[++R], ce = this[++R] * 2 ** 24 + this[++R] * 2 ** 16 + this[++R] * 2 ** 8 + q;
    return (BigInt(re) << BigInt(32)) + BigInt(ce);
  }), l.prototype.readIntLE = function(R, A, q) {
    R = R >>> 0, A = A >>> 0, q || ae(R, A, this.length);
    let re = this[R], ce = 1, de = 0;
    for (; ++de < A && (ce *= 256); )
      re += this[R + de] * ce;
    return ce *= 128, re >= ce && (re -= Math.pow(2, 8 * A)), re;
  }, l.prototype.readIntBE = function(R, A, q) {
    R = R >>> 0, A = A >>> 0, q || ae(R, A, this.length);
    let re = A, ce = 1, de = this[R + --re];
    for (; re > 0 && (ce *= 256); )
      de += this[R + --re] * ce;
    return ce *= 128, de >= ce && (de -= Math.pow(2, 8 * A)), de;
  }, l.prototype.readInt8 = function(R, A) {
    return R = R >>> 0, A || ae(R, 1, this.length), this[R] & 128 ? (255 - this[R] + 1) * -1 : this[R];
  }, l.prototype.readInt16LE = function(R, A) {
    R = R >>> 0, A || ae(R, 2, this.length);
    const q = this[R] | this[R + 1] << 8;
    return q & 32768 ? q | 4294901760 : q;
  }, l.prototype.readInt16BE = function(R, A) {
    R = R >>> 0, A || ae(R, 2, this.length);
    const q = this[R + 1] | this[R] << 8;
    return q & 32768 ? q | 4294901760 : q;
  }, l.prototype.readInt32LE = function(R, A) {
    return R = R >>> 0, A || ae(R, 4, this.length), this[R] | this[R + 1] << 8 | this[R + 2] << 16 | this[R + 3] << 24;
  }, l.prototype.readInt32BE = function(R, A) {
    return R = R >>> 0, A || ae(R, 4, this.length), this[R] << 24 | this[R + 1] << 16 | this[R + 2] << 8 | this[R + 3];
  }, l.prototype.readBigInt64LE = Ie(function(R) {
    R = R >>> 0, b(R, "offset");
    const A = this[R], q = this[R + 7];
    (A === void 0 || q === void 0) && w(R, this.length - 8);
    const re = this[R + 4] + this[R + 5] * 2 ** 8 + this[R + 6] * 2 ** 16 + (q << 24);
    return (BigInt(re) << BigInt(32)) + BigInt(A + this[++R] * 2 ** 8 + this[++R] * 2 ** 16 + this[++R] * 2 ** 24);
  }), l.prototype.readBigInt64BE = Ie(function(R) {
    R = R >>> 0, b(R, "offset");
    const A = this[R], q = this[R + 7];
    (A === void 0 || q === void 0) && w(R, this.length - 8);
    const re = (A << 24) + // Overflow
    this[++R] * 2 ** 16 + this[++R] * 2 ** 8 + this[++R];
    return (BigInt(re) << BigInt(32)) + BigInt(this[++R] * 2 ** 24 + this[++R] * 2 ** 16 + this[++R] * 2 ** 8 + q);
  }), l.prototype.readFloatLE = function(R, A) {
    return R = R >>> 0, A || ae(R, 4, this.length), r.read(this, R, !0, 23, 4);
  }, l.prototype.readFloatBE = function(R, A) {
    return R = R >>> 0, A || ae(R, 4, this.length), r.read(this, R, !1, 23, 4);
  }, l.prototype.readDoubleLE = function(R, A) {
    return R = R >>> 0, A || ae(R, 8, this.length), r.read(this, R, !0, 52, 8);
  }, l.prototype.readDoubleBE = function(R, A) {
    return R = R >>> 0, A || ae(R, 8, this.length), r.read(this, R, !1, 52, 8);
  };
  function be(N, R, A, q, re, ce) {
    if (!l.isBuffer(N))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (R > re || R < ce)
      throw new RangeError('"value" argument is out of bounds');
    if (A + q > N.length)
      throw new RangeError("Index out of range");
  }
  l.prototype.writeUintLE = l.prototype.writeUIntLE = function(R, A, q, re) {
    if (R = +R, A = A >>> 0, q = q >>> 0, !re) {
      const De = Math.pow(2, 8 * q) - 1;
      be(this, R, A, q, De, 0);
    }
    let ce = 1, de = 0;
    for (this[A] = R & 255; ++de < q && (ce *= 256); )
      this[A + de] = R / ce & 255;
    return A + q;
  }, l.prototype.writeUintBE = l.prototype.writeUIntBE = function(R, A, q, re) {
    if (R = +R, A = A >>> 0, q = q >>> 0, !re) {
      const De = Math.pow(2, 8 * q) - 1;
      be(this, R, A, q, De, 0);
    }
    let ce = q - 1, de = 1;
    for (this[A + ce] = R & 255; --ce >= 0 && (de *= 256); )
      this[A + ce] = R / de & 255;
    return A + q;
  }, l.prototype.writeUint8 = l.prototype.writeUInt8 = function(R, A, q) {
    return R = +R, A = A >>> 0, q || be(this, R, A, 1, 255, 0), this[A] = R & 255, A + 1;
  }, l.prototype.writeUint16LE = l.prototype.writeUInt16LE = function(R, A, q) {
    return R = +R, A = A >>> 0, q || be(this, R, A, 2, 65535, 0), this[A] = R & 255, this[A + 1] = R >>> 8, A + 2;
  }, l.prototype.writeUint16BE = l.prototype.writeUInt16BE = function(R, A, q) {
    return R = +R, A = A >>> 0, q || be(this, R, A, 2, 65535, 0), this[A] = R >>> 8, this[A + 1] = R & 255, A + 2;
  }, l.prototype.writeUint32LE = l.prototype.writeUInt32LE = function(R, A, q) {
    return R = +R, A = A >>> 0, q || be(this, R, A, 4, 4294967295, 0), this[A + 3] = R >>> 24, this[A + 2] = R >>> 16, this[A + 1] = R >>> 8, this[A] = R & 255, A + 4;
  }, l.prototype.writeUint32BE = l.prototype.writeUInt32BE = function(R, A, q) {
    return R = +R, A = A >>> 0, q || be(this, R, A, 4, 4294967295, 0), this[A] = R >>> 24, this[A + 1] = R >>> 16, this[A + 2] = R >>> 8, this[A + 3] = R & 255, A + 4;
  };
  function H(N, R, A, q, re) {
    z(R, q, re, N, A, 7);
    let ce = Number(R & BigInt(4294967295));
    N[A++] = ce, ce = ce >> 8, N[A++] = ce, ce = ce >> 8, N[A++] = ce, ce = ce >> 8, N[A++] = ce;
    let de = Number(R >> BigInt(32) & BigInt(4294967295));
    return N[A++] = de, de = de >> 8, N[A++] = de, de = de >> 8, N[A++] = de, de = de >> 8, N[A++] = de, A;
  }
  function pe(N, R, A, q, re) {
    z(R, q, re, N, A, 7);
    let ce = Number(R & BigInt(4294967295));
    N[A + 7] = ce, ce = ce >> 8, N[A + 6] = ce, ce = ce >> 8, N[A + 5] = ce, ce = ce >> 8, N[A + 4] = ce;
    let de = Number(R >> BigInt(32) & BigInt(4294967295));
    return N[A + 3] = de, de = de >> 8, N[A + 2] = de, de = de >> 8, N[A + 1] = de, de = de >> 8, N[A] = de, A + 8;
  }
  l.prototype.writeBigUInt64LE = Ie(function(R, A = 0) {
    return H(this, R, A, BigInt(0), BigInt("0xffffffffffffffff"));
  }), l.prototype.writeBigUInt64BE = Ie(function(R, A = 0) {
    return pe(this, R, A, BigInt(0), BigInt("0xffffffffffffffff"));
  }), l.prototype.writeIntLE = function(R, A, q, re) {
    if (R = +R, A = A >>> 0, !re) {
      const it = Math.pow(2, 8 * q - 1);
      be(this, R, A, q, it - 1, -it);
    }
    let ce = 0, de = 1, De = 0;
    for (this[A] = R & 255; ++ce < q && (de *= 256); )
      R < 0 && De === 0 && this[A + ce - 1] !== 0 && (De = 1), this[A + ce] = (R / de >> 0) - De & 255;
    return A + q;
  }, l.prototype.writeIntBE = function(R, A, q, re) {
    if (R = +R, A = A >>> 0, !re) {
      const it = Math.pow(2, 8 * q - 1);
      be(this, R, A, q, it - 1, -it);
    }
    let ce = q - 1, de = 1, De = 0;
    for (this[A + ce] = R & 255; --ce >= 0 && (de *= 256); )
      R < 0 && De === 0 && this[A + ce + 1] !== 0 && (De = 1), this[A + ce] = (R / de >> 0) - De & 255;
    return A + q;
  }, l.prototype.writeInt8 = function(R, A, q) {
    return R = +R, A = A >>> 0, q || be(this, R, A, 1, 127, -128), R < 0 && (R = 255 + R + 1), this[A] = R & 255, A + 1;
  }, l.prototype.writeInt16LE = function(R, A, q) {
    return R = +R, A = A >>> 0, q || be(this, R, A, 2, 32767, -32768), this[A] = R & 255, this[A + 1] = R >>> 8, A + 2;
  }, l.prototype.writeInt16BE = function(R, A, q) {
    return R = +R, A = A >>> 0, q || be(this, R, A, 2, 32767, -32768), this[A] = R >>> 8, this[A + 1] = R & 255, A + 2;
  }, l.prototype.writeInt32LE = function(R, A, q) {
    return R = +R, A = A >>> 0, q || be(this, R, A, 4, 2147483647, -2147483648), this[A] = R & 255, this[A + 1] = R >>> 8, this[A + 2] = R >>> 16, this[A + 3] = R >>> 24, A + 4;
  }, l.prototype.writeInt32BE = function(R, A, q) {
    return R = +R, A = A >>> 0, q || be(this, R, A, 4, 2147483647, -2147483648), R < 0 && (R = 4294967295 + R + 1), this[A] = R >>> 24, this[A + 1] = R >>> 16, this[A + 2] = R >>> 8, this[A + 3] = R & 255, A + 4;
  }, l.prototype.writeBigInt64LE = Ie(function(R, A = 0) {
    return H(this, R, A, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), l.prototype.writeBigInt64BE = Ie(function(R, A = 0) {
    return pe(this, R, A, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function ke(N, R, A, q, re, ce) {
    if (A + q > N.length)
      throw new RangeError("Index out of range");
    if (A < 0)
      throw new RangeError("Index out of range");
  }
  function le(N, R, A, q, re) {
    return R = +R, A = A >>> 0, re || ke(N, R, A, 4), r.write(N, R, A, q, 23, 4), A + 4;
  }
  l.prototype.writeFloatLE = function(R, A, q) {
    return le(this, R, A, !0, q);
  }, l.prototype.writeFloatBE = function(R, A, q) {
    return le(this, R, A, !1, q);
  };
  function ee(N, R, A, q, re) {
    return R = +R, A = A >>> 0, re || ke(N, R, A, 8), r.write(N, R, A, q, 52, 8), A + 8;
  }
  l.prototype.writeDoubleLE = function(R, A, q) {
    return ee(this, R, A, !0, q);
  }, l.prototype.writeDoubleBE = function(R, A, q) {
    return ee(this, R, A, !1, q);
  }, l.prototype.copy = function(R, A, q, re) {
    if (!l.isBuffer(R))
      throw new TypeError("argument should be a Buffer");
    if (q || (q = 0), !re && re !== 0 && (re = this.length), A >= R.length && (A = R.length), A || (A = 0), re > 0 && re < q && (re = q), re === q || R.length === 0 || this.length === 0)
      return 0;
    if (A < 0)
      throw new RangeError("targetStart out of bounds");
    if (q < 0 || q >= this.length)
      throw new RangeError("Index out of range");
    if (re < 0)
      throw new RangeError("sourceEnd out of bounds");
    re > this.length && (re = this.length), R.length - A < re - q && (re = R.length - A + q);
    const ce = re - q;
    return this === R && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(A, q, re) : Uint8Array.prototype.set.call(
      R,
      this.subarray(q, re),
      A
    ), ce;
  }, l.prototype.fill = function(R, A, q, re) {
    if (typeof R == "string") {
      if (typeof A == "string" ? (re = A, A = 0, q = this.length) : typeof q == "string" && (re = q, q = this.length), re !== void 0 && typeof re != "string")
        throw new TypeError("encoding must be a string");
      if (typeof re == "string" && !l.isEncoding(re))
        throw new TypeError("Unknown encoding: " + re);
      if (R.length === 1) {
        const de = R.charCodeAt(0);
        (re === "utf8" && de < 128 || re === "latin1") && (R = de);
      }
    } else
      typeof R == "number" ? R = R & 255 : typeof R == "boolean" && (R = Number(R));
    if (A < 0 || this.length < A || this.length < q)
      throw new RangeError("Out of range index");
    if (q <= A)
      return this;
    A = A >>> 0, q = q === void 0 ? this.length : q >>> 0, R || (R = 0);
    let ce;
    if (typeof R == "number")
      for (ce = A; ce < q; ++ce)
        this[ce] = R;
    else {
      const de = l.isBuffer(R) ? R : l.from(R, re), De = de.length;
      if (De === 0)
        throw new TypeError('The value "' + R + '" is invalid for argument "value"');
      for (ce = 0; ce < q - A; ++ce)
        this[ce + A] = de[ce % De];
    }
    return this;
  };
  const ge = {};
  function Ae(N, R, A) {
    ge[N] = class extends A {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: R.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${N}]`, this.stack, delete this.name;
      }
      get code() {
        return N;
      }
      set code(re) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: re,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${N}]: ${this.message}`;
      }
    };
  }
  Ae(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(N) {
      return N ? `${N} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Ae(
    "ERR_INVALID_ARG_TYPE",
    function(N, R) {
      return `The "${N}" argument must be of type number. Received type ${typeof R}`;
    },
    TypeError
  ), Ae(
    "ERR_OUT_OF_RANGE",
    function(N, R, A) {
      let q = `The value of "${N}" is out of range.`, re = A;
      return Number.isInteger(A) && Math.abs(A) > 2 ** 32 ? re = Oe(String(A)) : typeof A == "bigint" && (re = String(A), (A > BigInt(2) ** BigInt(32) || A < -(BigInt(2) ** BigInt(32))) && (re = Oe(re)), re += "n"), q += ` It must be ${R}. Received ${re}`, q;
    },
    RangeError
  );
  function Oe(N) {
    let R = "", A = N.length;
    const q = N[0] === "-" ? 1 : 0;
    for (; A >= q + 4; A -= 3)
      R = `_${N.slice(A - 3, A)}${R}`;
    return `${N.slice(0, A)}${R}`;
  }
  function K(N, R, A) {
    b(R, "offset"), (N[R] === void 0 || N[R + A] === void 0) && w(R, N.length - (A + 1));
  }
  function z(N, R, A, q, re, ce) {
    if (N > A || N < R) {
      const de = typeof R == "bigint" ? "n" : "";
      let De;
      throw ce > 3 ? R === 0 || R === BigInt(0) ? De = `>= 0${de} and < 2${de} ** ${(ce + 1) * 8}${de}` : De = `>= -(2${de} ** ${(ce + 1) * 8 - 1}${de}) and < 2 ** ${(ce + 1) * 8 - 1}${de}` : De = `>= ${R}${de} and <= ${A}${de}`, new ge.ERR_OUT_OF_RANGE("value", De, N);
    }
    K(q, re, ce);
  }
  function b(N, R) {
    if (typeof N != "number")
      throw new ge.ERR_INVALID_ARG_TYPE(R, "number", N);
  }
  function w(N, R, A) {
    throw Math.floor(N) !== N ? (b(N, A), new ge.ERR_OUT_OF_RANGE(A || "offset", "an integer", N)) : R < 0 ? new ge.ERR_BUFFER_OUT_OF_BOUNDS() : new ge.ERR_OUT_OF_RANGE(
      A || "offset",
      `>= ${A ? 1 : 0} and <= ${R}`,
      N
    );
  }
  const T = /[^+/0-9A-Za-z-_]/g;
  function O(N) {
    if (N = N.split("=")[0], N = N.trim().replace(T, ""), N.length < 2)
      return "";
    for (; N.length % 4 !== 0; )
      N = N + "=";
    return N;
  }
  function L(N, R) {
    R = R || 1 / 0;
    let A;
    const q = N.length;
    let re = null;
    const ce = [];
    for (let de = 0; de < q; ++de) {
      if (A = N.charCodeAt(de), A > 55295 && A < 57344) {
        if (!re) {
          if (A > 56319) {
            (R -= 3) > -1 && ce.push(239, 191, 189);
            continue;
          } else if (de + 1 === q) {
            (R -= 3) > -1 && ce.push(239, 191, 189);
            continue;
          }
          re = A;
          continue;
        }
        if (A < 56320) {
          (R -= 3) > -1 && ce.push(239, 191, 189), re = A;
          continue;
        }
        A = (re - 55296 << 10 | A - 56320) + 65536;
      } else
        re && (R -= 3) > -1 && ce.push(239, 191, 189);
      if (re = null, A < 128) {
        if ((R -= 1) < 0)
          break;
        ce.push(A);
      } else if (A < 2048) {
        if ((R -= 2) < 0)
          break;
        ce.push(
          A >> 6 | 192,
          A & 63 | 128
        );
      } else if (A < 65536) {
        if ((R -= 3) < 0)
          break;
        ce.push(
          A >> 12 | 224,
          A >> 6 & 63 | 128,
          A & 63 | 128
        );
      } else if (A < 1114112) {
        if ((R -= 4) < 0)
          break;
        ce.push(
          A >> 18 | 240,
          A >> 12 & 63 | 128,
          A >> 6 & 63 | 128,
          A & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return ce;
  }
  function ne(N) {
    const R = [];
    for (let A = 0; A < N.length; ++A)
      R.push(N.charCodeAt(A) & 255);
    return R;
  }
  function ue(N, R) {
    let A, q, re;
    const ce = [];
    for (let de = 0; de < N.length && !((R -= 2) < 0); ++de)
      A = N.charCodeAt(de), q = A >> 8, re = A % 256, ce.push(re), ce.push(q);
    return ce;
  }
  function oe(N) {
    return t.toByteArray(O(N));
  }
  function ye(N, R, A, q) {
    let re;
    for (re = 0; re < q && !(re + A >= R.length || re >= N.length); ++re)
      R[re + A] = N[re];
    return re;
  }
  function B(N, R) {
    return N instanceof R || N != null && N.constructor != null && N.constructor.name != null && N.constructor.name === R.name;
  }
  function me(N) {
    return N !== N;
  }
  const Ce = function() {
    const N = "0123456789abcdef", R = new Array(256);
    for (let A = 0; A < 16; ++A) {
      const q = A * 16;
      for (let re = 0; re < 16; ++re)
        R[q + re] = N[A] + N[re];
    }
    return R;
  }();
  function Ie(N) {
    return typeof BigInt > "u" ? Me : N;
  }
  function Me() {
    throw new Error("BigInt not supported");
  }
})(ut);
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let ET;
var hY = typeof queueMicrotask == "function" ? queueMicrotask.bind(window) : (e) => (ET || (ET = Promise.resolve())).then(e).catch((t) => setTimeout(() => {
  throw t;
}, 0));
const pY = /* @__PURE__ */ $n(hY), Mu = "http://www.w3.org/1999/02/22-rdf-syntax-ns#", Nu = "http://www.w3.org/2001/XMLSchema#", Rb = "http://www.w3.org/2000/10/swap/", fi = {
  xsd: {
    decimal: `${Nu}decimal`,
    boolean: `${Nu}boolean`,
    double: `${Nu}double`,
    integer: `${Nu}integer`,
    string: `${Nu}string`
  },
  rdf: {
    type: `${Mu}type`,
    nil: `${Mu}nil`,
    first: `${Mu}first`,
    rest: `${Mu}rest`,
    langString: `${Mu}langString`
  },
  owl: {
    sameAs: "http://www.w3.org/2002/07/owl#sameAs"
  },
  r: {
    forSome: `${Rb}reify#forSome`,
    forAll: `${Rb}reify#forAll`
  },
  log: {
    implies: `${Rb}log#implies`
  }
}, { xsd: Vc } = fi, gY = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\([^])/g, xT = {
  "\\": "\\",
  "'": "'",
  '"': '"',
  n: `
`,
  r: "\r",
  t: "	",
  f: "\f",
  b: "\b",
  _: "_",
  "~": "~",
  ".": ".",
  "-": "-",
  "!": "!",
  $: "$",
  "&": "&",
  "(": "(",
  ")": ")",
  "*": "*",
  "+": "+",
  ",": ",",
  ";": ";",
  "=": "=",
  "/": "/",
  "?": "?",
  "#": "#",
  "@": "@",
  "%": "%"
}, bY = /[\x00-\x20<>\\"\{\}\|\^\`]/, yY = {
  _iri: !0,
  _unescapedIri: !0,
  _simpleQuotedString: !0,
  _langcode: !0,
  _blank: !0,
  _newline: !0,
  _comment: !0,
  _whitespace: !0,
  _endOfFile: !0
}, mY = /$0^/;
class vY {
  constructor(t) {
    if (this._iri = /^<((?:[^ <>{}\\]|\\[uU])+)>[ \t]*/, this._unescapedIri = /^<([^\x00-\x20<>\\"\{\}\|\^\`]*)>[ \t]*/, this._simpleQuotedString = /^"([^"\\\r\n]*)"(?=[^"])/, this._simpleApostropheString = /^'([^'\\\r\n]*)'(?=[^'])/, this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\-])/i, this._prefix = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:(?=[#\s<])/, this._prefixed = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:((?:(?:[0-:A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])(?:(?:[\.\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])*(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~]))?)?)(?:[ \t]+|(?=\.?[,;!\^\s#()\[\]\{\}"'<>]))/, this._variable = /^\?(?:(?:[A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?=[.,;!\^\s#()\[\]\{\}"'<>])/, this._blank = /^_:((?:[0-9A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?:[ \t]+|(?=\.?[,;:\s#()\[\]\{\}"'<>]))/, this._number = /^[\-+]?(?:(\d+\.\d*|\.?\d+)[eE][\-+]?|\d*(\.)?)\d+(?=\.?[,;:\s#()\[\]\{\}"'<>])/, this._boolean = /^(?:true|false)(?=[.,;\s#()\[\]\{\}"'<>])/, this._keyword = /^@[a-z]+(?=[\s#<:])/i, this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\s#<])/i, this._shortPredicates = /^a(?=[\s#()\[\]\{\}"'<>])/, this._newline = /^[ \t]*(?:#[^\n\r]*)?(?:\r\n|\n|\r)[ \t]*/, this._comment = /#([^\n\r]*)/, this._whitespace = /^[ \t]+/, this._endOfFile = /^(?:#[^\n\r]*)?$/, t = t || {}, this._lineMode = !!t.lineMode) {
      this._n3Mode = !1;
      for (const r in this)
        !(r in yY) && this[r] instanceof RegExp && (this[r] = mY);
    } else
      this._n3Mode = t.n3 !== !1;
    this._comments = !!t.comments, this._literalClosingPos = 0;
  }
  // ## Private methods
  // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback
  _tokenizeToEnd(t, r) {
    let n = this._input, o = n.length;
    for (; ; ) {
      let l, u;
      for (; l = this._newline.exec(n); )
        this._comments && (u = this._comment.exec(l[0])) && s("comment", u[1], "", this._line, l[0].length), n = n.substr(l[0].length, n.length), o = n.length, this._line++;
      if (!l && (l = this._whitespace.exec(n)) && (n = n.substr(l[0].length, n.length)), this._endOfFile.test(n))
        return r && (this._comments && (u = this._comment.exec(n)) && s("comment", u[1], "", this._line, n.length), n = null, s("eof", "", "", this._line, 0)), this._input = n;
      const f = this._line, c = n[0];
      let d = "", h = "", p = "", m = null, y = 0, _ = !1;
      switch (c) {
        case "^":
          if (n.length < 3)
            break;
          if (n[1] === "^") {
            if (this._previousMarker = "^^", n = n.substr(2), n[0] !== "<") {
              _ = !0;
              break;
            }
          } else {
            this._n3Mode && (y = 1, d = "^");
            break;
          }
        case "<":
          if (m = this._unescapedIri.exec(n))
            d = "IRI", h = m[1];
          else if (m = this._iri.exec(n)) {
            if (h = this._unescape(m[1]), h === null || bY.test(h))
              return a(this);
            d = "IRI";
          } else
            n.length > 1 && n[1] === "<" ? (d = "<<", y = 2) : this._n3Mode && n.length > 1 && n[1] === "=" && (d = "inverse", y = 2, h = ">");
          break;
        case ">":
          n.length > 1 && n[1] === ">" && (d = ">>", y = 2);
          break;
        case "_":
          ((m = this._blank.exec(n)) || r && (m = this._blank.exec(`${n} `))) && (d = "blank", p = "_", h = m[1]);
          break;
        case '"':
          if (m = this._simpleQuotedString.exec(n))
            h = m[1];
          else if ({ value: h, matchLength: y } = this._parseLiteral(n), h === null)
            return a(this);
          (m !== null || y !== 0) && (d = "literal", this._literalClosingPos = 0);
          break;
        case "'":
          if (!this._lineMode) {
            if (m = this._simpleApostropheString.exec(n))
              h = m[1];
            else if ({ value: h, matchLength: y } = this._parseLiteral(n), h === null)
              return a(this);
            (m !== null || y !== 0) && (d = "literal", this._literalClosingPos = 0);
          }
          break;
        case "?":
          this._n3Mode && (m = this._variable.exec(n)) && (d = "var", h = m[0]);
          break;
        case "@":
          this._previousMarker === "literal" && (m = this._langcode.exec(n)) ? (d = "langcode", h = m[1]) : (m = this._keyword.exec(n)) && (d = m[0]);
          break;
        case ".":
          if (n.length === 1 ? r : n[1] < "0" || n[1] > "9") {
            d = ".", y = 1;
            break;
          }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        case "+":
        case "-":
          (m = this._number.exec(n) || r && (m = this._number.exec(`${n} `))) && (d = "literal", h = m[0], p = typeof m[1] == "string" ? Vc.double : typeof m[2] == "string" ? Vc.decimal : Vc.integer);
          break;
        case "B":
        case "b":
        case "p":
        case "P":
        case "G":
        case "g":
          (m = this._sparqlKeyword.exec(n)) ? d = m[0].toUpperCase() : _ = !0;
          break;
        case "f":
        case "t":
          (m = this._boolean.exec(n)) ? (d = "literal", h = m[0], p = Vc.boolean) : _ = !0;
          break;
        case "a":
          (m = this._shortPredicates.exec(n)) ? (d = "abbreviation", h = "a") : _ = !0;
          break;
        case "=":
          this._n3Mode && n.length > 1 && (d = "abbreviation", n[1] !== ">" ? (y = 1, h = "=") : (y = 2, h = ">"));
          break;
        case "!":
          if (!this._n3Mode)
            break;
        case ",":
        case ";":
        case "[":
        case "]":
        case "(":
        case ")":
        case "}":
          this._lineMode || (y = 1, d = c);
          break;
        case "{":
          !this._lineMode && n.length >= 2 && (n[1] === "|" ? (d = "{|", y = 2) : (d = c, y = 1));
          break;
        case "|":
          n.length >= 2 && n[1] === "}" && (d = "|}", y = 2);
          break;
        default:
          _ = !0;
      }
      if (_ && ((this._previousMarker === "@prefix" || this._previousMarker === "PREFIX") && (m = this._prefix.exec(n)) ? (d = "prefix", h = m[1] || "") : ((m = this._prefixed.exec(n)) || r && (m = this._prefixed.exec(`${n} `))) && (d = "prefixed", p = m[1] || "", h = this._unescape(m[2]))), this._previousMarker === "^^")
        switch (d) {
          case "prefixed":
            d = "type";
            break;
          case "IRI":
            d = "typeIRI";
            break;
          default:
            d = "";
        }
      if (!d)
        return r || !/^'''|^"""/.test(n) && /\n|\r/.test(n) ? a(this) : this._input = n;
      const S = y || m[0].length, x = s(d, h, p, f, S);
      this.previousToken = x, this._previousMarker = d, n = n.substr(S, n.length);
    }
    function s(l, u, f, c, d) {
      const h = n ? o - n.length : o, p = h + d, m = { type: l, value: u, prefix: f, line: c, start: h, end: p };
      return t(null, m), m;
    }
    function a(l) {
      t(l._syntaxError(/^\S*/.exec(n)[0]));
    }
  }
  // ### `_unescape` replaces N3 escape codes by their corresponding characters
  _unescape(t) {
    let r = !1;
    const n = t.replace(gY, (o, s, a, l) => {
      if (typeof s == "string")
        return String.fromCharCode(Number.parseInt(s, 16));
      if (typeof a == "string") {
        let u = Number.parseInt(a, 16);
        return u <= 65535 ? String.fromCharCode(Number.parseInt(a, 16)) : String.fromCharCode(55296 + ((u -= 65536) >> 10), 56320 + (u & 1023));
      }
      return l in xT ? xT[l] : (r = !0, "");
    });
    return r ? null : n;
  }
  // ### `_parseLiteral` parses a literal into an unescaped value
  _parseLiteral(t) {
    if (t.length >= 3) {
      const r = t.match(/^(?:"""|"|'''|'|)/)[0], n = r.length;
      let o = Math.max(this._literalClosingPos, n);
      for (; (o = t.indexOf(r, o)) > 0; ) {
        let s = 0;
        for (; t[o - s - 1] === "\\"; )
          s++;
        if (s % 2 === 0) {
          const a = t.substring(n, o), l = a.split(/\r\n|\r|\n/).length - 1, u = o + n;
          if (n === 1 && l !== 0 || n === 3 && this._lineMode)
            break;
          return this._line += l, { value: this._unescape(a), matchLength: u };
        }
        o++;
      }
      this._literalClosingPos = t.length - n + 1;
    }
    return { value: "", matchLength: 0 };
  }
  // ### `_syntaxError` creates a syntax error for the given issue
  _syntaxError(t) {
    this._input = null;
    const r = new Error(`Unexpected "${t}" on line ${this._line}.`);
    return r.context = {
      token: void 0,
      line: this._line,
      previousToken: this.previousToken
    }, r;
  }
  // ### Strips off any starting UTF BOM mark.
  _readStartingBom(t) {
    return t.startsWith("\uFEFF") ? t.substr(1) : t;
  }
  // ## Public methods
  // ### `tokenize` starts the transformation of an N3 document into an array of tokens.
  // The input can be a string or a stream.
  tokenize(t, r) {
    if (this._line = 1, typeof t == "string")
      if (this._input = this._readStartingBom(t), typeof r == "function")
        pY(() => this._tokenizeToEnd(r, !0));
      else {
        const n = [];
        let o;
        if (this._tokenizeToEnd((s, a) => s ? o = s : n.push(a), !0), o)
          throw o;
        return n;
      }
    else
      this._pendingBuffer = null, typeof t.setEncoding == "function" && t.setEncoding("utf8"), t.on("data", (n) => {
        this._input !== null && n.length !== 0 && (this._pendingBuffer && (n = ut.Buffer.concat([this._pendingBuffer, n]), this._pendingBuffer = null), n[n.length - 1] & 128 ? this._pendingBuffer = n : (typeof this._input > "u" ? this._input = this._readStartingBom(typeof n == "string" ? n : n.toString()) : this._input += n, this._tokenizeToEnd(r, !1)));
      }), t.on("end", () => {
        typeof this._input == "string" && this._tokenizeToEnd(r, !0);
      }), t.on("error", r);
  }
}
const { rdf: wY, xsd: gl } = fi;
let _p, _Y = 0;
const SY = {
  namedNode: $Y,
  blankNode: CY,
  variable: IY,
  literal: kY,
  defaultGraph: MY,
  quad: RT,
  triple: RT
}, EY = SY;
class ys {
  constructor(t) {
    this.id = t;
  }
  // ### The value of this term
  get value() {
    return this.id;
  }
  // ### Returns whether this object represents the same term as the other
  equals(t) {
    return t instanceof ys ? this.id === t.id : !!t && this.termType === t.termType && this.value === t.value;
  }
  // ### Implement hashCode for Immutable.js, since we implement `equals`
  // https://immutable-js.com/docs/v4.0.0/ValueObject/#hashCode()
  hashCode() {
    return 0;
  }
  // ### Returns a plain object representation of this term
  toJSON() {
    return {
      termType: this.termType,
      value: this.value
    };
  }
}
let $D = class extends ys {
  // ### The term type of this term
  get termType() {
    return "NamedNode";
  }
};
class vf extends ys {
  // ### The term type of this term
  get termType() {
    return "Literal";
  }
  // ### The text value of this literal
  get value() {
    return this.id.substring(1, this.id.lastIndexOf('"'));
  }
  // ### The language of this literal
  get language() {
    const t = this.id;
    let r = t.lastIndexOf('"') + 1;
    return r < t.length && t[r++] === "@" ? t.substr(r).toLowerCase() : "";
  }
  // ### The datatype IRI of this literal
  get datatype() {
    return new $D(this.datatypeString);
  }
  // ### The datatype string of this literal
  get datatypeString() {
    const t = this.id, r = t.lastIndexOf('"') + 1, n = r < t.length ? t[r] : "";
    return n === "^" ? t.substr(r + 2) : (
      // If "@" follows, return rdf:langString; xsd:string otherwise
      n !== "@" ? gl.string : wY.langString
    );
  }
  // ### Returns whether this object represents the same term as the other
  equals(t) {
    return t instanceof vf ? this.id === t.id : !!t && !!t.datatype && this.termType === t.termType && this.value === t.value && this.language === t.language && this.datatype.value === t.datatype.value;
  }
  toJSON() {
    return {
      termType: this.termType,
      value: this.value,
      language: this.language,
      datatype: { termType: "NamedNode", value: this.datatypeString }
    };
  }
}
let xY = class extends ys {
  constructor(t) {
    super(`_:${t}`);
  }
  // ### The term type of this term
  get termType() {
    return "BlankNode";
  }
  // ### The name of this blank node
  get value() {
    return this.id.substr(2);
  }
}, RY = class extends ys {
  constructor(t) {
    super(`?${t}`);
  }
  // ### The term type of this term
  get termType() {
    return "Variable";
  }
  // ### The name of this variable
  get value() {
    return this.id.substr(1);
  }
}, AY = class extends ys {
  constructor() {
    return super(""), _p || this;
  }
  // ### The term type of this term
  get termType() {
    return "DefaultGraph";
  }
  // ### Returns whether this object represents the same term as the other
  equals(t) {
    return this === t || !!t && this.termType === t.termType;
  }
};
_p = new AY();
let TY = class extends ys {
  constructor(t, r, n, o) {
    super(""), this._subject = t, this._predicate = r, this._object = n, this._graph = o || _p;
  }
  // ### The term type of this term
  get termType() {
    return "Quad";
  }
  get subject() {
    return this._subject;
  }
  get predicate() {
    return this._predicate;
  }
  get object() {
    return this._object;
  }
  get graph() {
    return this._graph;
  }
  // ### Returns a plain object representation of this quad
  toJSON() {
    return {
      termType: this.termType,
      subject: this._subject.toJSON(),
      predicate: this._predicate.toJSON(),
      object: this._object.toJSON(),
      graph: this._graph.toJSON()
    };
  }
  // ### Returns whether this object represents the same quad as the other
  equals(t) {
    return !!t && this._subject.equals(t.subject) && this._predicate.equals(t.predicate) && this._object.equals(t.object) && this._graph.equals(t.graph);
  }
};
function $Y(e) {
  return new $D(e);
}
function CY(e) {
  return new xY(e || `n3-${_Y++}`);
}
function kY(e, t) {
  if (typeof t == "string")
    return new vf(`"${e}"@${t.toLowerCase()}`);
  let r = t ? t.value : "";
  return r === "" && (typeof e == "boolean" ? r = gl.boolean : typeof e == "number" && (Number.isFinite(e) ? r = Number.isInteger(e) ? gl.integer : gl.double : (r = gl.double, Number.isNaN(e) || (e = e > 0 ? "INF" : "-INF")))), r === "" || r === gl.string ? new vf(`"${e}"`) : new vf(`"${e}"^^${r}`);
}
function IY(e) {
  return new RY(e);
}
function MY() {
  return _p;
}
function RT(e, t, r, n) {
  return new TY(e, t, r, n);
}
let AT = 0, CD = class {
  constructor(t) {
    this._contextStack = [], this._graph = null, t = t || {}, this._setBase(t.baseIRI), t.factory && kD(this, t.factory);
    const r = typeof t.format == "string" ? t.format.match(/\w*$/)[0].toLowerCase() : "", n = /turtle/.test(r), o = /trig/.test(r), s = /triple/.test(r), a = /quad/.test(r), l = this._n3Mode = /n3/.test(r), u = s || a;
    (this._supportsNamedGraphs = !(n || l)) || (this._readPredicateOrNamedGraph = this._readPredicate), this._supportsQuads = !(n || o || s || l), this._supportsRDFStar = r === "" || /star|\*$/.test(r), u && (this._resolveRelativeIRI = (f) => null), this._blankNodePrefix = typeof t.blankNodePrefix != "string" ? "" : t.blankNodePrefix.replace(/^(?!_:)/, "_:"), this._lexer = t.lexer || new vY({ lineMode: u, n3: l }), this._explicitQuantifiers = !!t.explicitQuantifiers;
  }
  // ## Static class methods
  // ### `_resetBlankNodePrefix` restarts blank node prefix identification
  static _resetBlankNodePrefix() {
    AT = 0;
  }
  // ## Private methods
  // ### `_setBase` sets the base IRI to resolve relative IRIs
  _setBase(t) {
    if (!t)
      this._base = "", this._basePath = "";
    else {
      const r = t.indexOf("#");
      r >= 0 && (t = t.substr(0, r)), this._base = t, this._basePath = t.indexOf("/") < 0 ? t : t.replace(/[^\/?]*(?:\?.*)?$/, ""), t = t.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\/\/[^\/]*)?/i), this._baseRoot = t[0], this._baseScheme = t[1];
    }
  }
  // ### `_saveContext` stores the current parsing context
  // when entering a new scope (list, blank node, formula)
  _saveContext(t, r, n, o, s) {
    const a = this._n3Mode;
    this._contextStack.push({
      type: t,
      subject: n,
      predicate: o,
      object: s,
      graph: r,
      inverse: a ? this._inversePredicate : !1,
      blankPrefix: a ? this._prefixes._ : "",
      quantified: a ? this._quantified : null
    }), a && (this._inversePredicate = !1, this._prefixes._ = this._graph ? `${this._graph.value}.` : ".", this._quantified = Object.create(this._quantified));
  }
  // ### `_restoreContext` restores the parent context
  // when leaving a scope (list, blank node, formula)
  _restoreContext(t, r) {
    const n = this._contextStack.pop();
    if (!n || n.type !== t)
      return this._error(`Unexpected ${r.type}`, r);
    this._subject = n.subject, this._predicate = n.predicate, this._object = n.object, this._graph = n.graph, this._n3Mode && (this._inversePredicate = n.inverse, this._prefixes._ = n.blankPrefix, this._quantified = n.quantified);
  }
  // ### `_readInTopContext` reads a token when in the top context
  _readInTopContext(t) {
    switch (t.type) {
      case "eof":
        return this._graph !== null ? this._error("Unclosed graph", t) : (delete this._prefixes._, this._callback(null, null, this._prefixes));
      case "PREFIX":
        this._sparqlStyle = !0;
      case "@prefix":
        return this._readPrefix;
      case "BASE":
        this._sparqlStyle = !0;
      case "@base":
        return this._readBaseIRI;
      case "{":
        if (this._supportsNamedGraphs)
          return this._graph = "", this._subject = null, this._readSubject;
      case "GRAPH":
        if (this._supportsNamedGraphs)
          return this._readNamedGraphLabel;
      default:
        return this._readSubject(t);
    }
  }
  // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable
  _readEntity(t, r) {
    let n;
    switch (t.type) {
      case "IRI":
      case "typeIRI":
        const o = this._resolveIRI(t.value);
        if (o === null)
          return this._error("Invalid IRI", t);
        n = this._namedNode(o);
        break;
      case "type":
      case "prefixed":
        const s = this._prefixes[t.prefix];
        if (s === void 0)
          return this._error(`Undefined prefix "${t.prefix}:"`, t);
        n = this._namedNode(s + t.value);
        break;
      case "blank":
        n = this._blankNode(this._prefixes[t.prefix] + t.value);
        break;
      case "var":
        n = this._variable(t.value.substr(1));
        break;
      default:
        return this._error(`Expected entity but got ${t.type}`, t);
    }
    return !r && this._n3Mode && n.id in this._quantified && (n = this._quantified[n.id]), n;
  }
  // ### `_readSubject` reads a quad's subject
  _readSubject(t) {
    switch (this._predicate = null, t.type) {
      case "[":
        return this._saveContext(
          "blank",
          this._graph,
          this._subject = this._blankNode(),
          null,
          null
        ), this._readBlankNodeHead;
      case "(":
        return this._saveContext("list", this._graph, this.RDF_NIL, null, null), this._subject = null, this._readListItem;
      case "{":
        return this._n3Mode ? (this._saveContext(
          "formula",
          this._graph,
          this._graph = this._blankNode(),
          null,
          null
        ), this._readSubject) : this._error("Unexpected graph", t);
      case "}":
        return this._readPunctuation(t);
      case "@forSome":
        return this._n3Mode ? (this._subject = null, this._predicate = this.N3_FORSOME, this._quantifier = this._blankNode, this._readQuantifierList) : this._error('Unexpected "@forSome"', t);
      case "@forAll":
        return this._n3Mode ? (this._subject = null, this._predicate = this.N3_FORALL, this._quantifier = this._variable, this._readQuantifierList) : this._error('Unexpected "@forAll"', t);
      case "literal":
        if (!this._n3Mode)
          return this._error("Unexpected literal", t);
        if (t.prefix.length === 0)
          return this._literalValue = t.value, this._completeSubjectLiteral;
        this._subject = this._literal(t.value, this._namedNode(t.prefix));
        break;
      case "<<":
        return this._supportsRDFStar ? (this._saveContext("<<", this._graph, null, null, null), this._graph = null, this._readSubject) : this._error("Unexpected RDF* syntax", t);
      default:
        if ((this._subject = this._readEntity(t)) === void 0)
          return;
        if (this._n3Mode)
          return this._getPathReader(this._readPredicateOrNamedGraph);
    }
    return this._readPredicateOrNamedGraph;
  }
  // ### `_readPredicate` reads a quad's predicate
  _readPredicate(t) {
    const r = t.type;
    switch (r) {
      case "inverse":
        this._inversePredicate = !0;
      case "abbreviation":
        this._predicate = this.ABBREVIATIONS[t.value];
        break;
      case ".":
      case "]":
      case "}":
        return this._predicate === null ? this._error(`Unexpected ${r}`, t) : (this._subject = null, r === "]" ? this._readBlankNodeTail(t) : this._readPunctuation(t));
      case ";":
        return this._predicate !== null ? this._readPredicate : this._error("Expected predicate but got ;", t);
      case "[":
        if (this._n3Mode)
          return this._saveContext(
            "blank",
            this._graph,
            this._subject,
            this._subject = this._blankNode(),
            null
          ), this._readBlankNodeHead;
      case "blank":
        if (!this._n3Mode)
          return this._error("Disallowed blank node as predicate", t);
      default:
        if ((this._predicate = this._readEntity(t)) === void 0)
          return;
    }
    return this._readObject;
  }
  // ### `_readObject` reads a quad's object
  _readObject(t) {
    switch (t.type) {
      case "literal":
        if (t.prefix.length === 0)
          return this._literalValue = t.value, this._readDataTypeOrLang;
        this._object = this._literal(t.value, this._namedNode(t.prefix));
        break;
      case "[":
        return this._saveContext(
          "blank",
          this._graph,
          this._subject,
          this._predicate,
          this._subject = this._blankNode()
        ), this._readBlankNodeHead;
      case "(":
        return this._saveContext("list", this._graph, this._subject, this._predicate, this.RDF_NIL), this._subject = null, this._readListItem;
      case "{":
        return this._n3Mode ? (this._saveContext(
          "formula",
          this._graph,
          this._subject,
          this._predicate,
          this._graph = this._blankNode()
        ), this._readSubject) : this._error("Unexpected graph", t);
      case "<<":
        return this._supportsRDFStar ? (this._saveContext("<<", this._graph, this._subject, this._predicate, null), this._graph = null, this._readSubject) : this._error("Unexpected RDF* syntax", t);
      default:
        if ((this._object = this._readEntity(t)) === void 0)
          return;
        if (this._n3Mode)
          return this._getPathReader(this._getContextEndReader());
    }
    return this._getContextEndReader();
  }
  // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph
  _readPredicateOrNamedGraph(t) {
    return t.type === "{" ? this._readGraph(t) : this._readPredicate(t);
  }
  // ### `_readGraph` reads a graph
  _readGraph(t) {
    return t.type !== "{" ? this._error(`Expected graph but got ${t.type}`, t) : (this._graph = this._subject, this._subject = null, this._readSubject);
  }
  // ### `_readBlankNodeHead` reads the head of a blank node
  _readBlankNodeHead(t) {
    return t.type === "]" ? (this._subject = null, this._readBlankNodeTail(t)) : (this._predicate = null, this._readPredicate(t));
  }
  // ### `_readBlankNodeTail` reads the end of a blank node
  _readBlankNodeTail(t) {
    if (t.type !== "]")
      return this._readBlankNodePunctuation(t);
    this._subject !== null && this._emit(this._subject, this._predicate, this._object, this._graph);
    const r = this._predicate === null;
    return this._restoreContext("blank", t), this._object !== null ? this._getContextEndReader() : this._predicate !== null ? this._readObject : r ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank;
  }
  // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node
  _readPredicateAfterBlank(t) {
    switch (t.type) {
      case ".":
      case "}":
        return this._subject = null, this._readPunctuation(t);
      default:
        return this._readPredicate(t);
    }
  }
  // ### `_readListItem` reads items from a list
  _readListItem(t) {
    let r = null, n = null, o = this._readListItem;
    const s = this._subject, a = this._contextStack, l = a[a.length - 1];
    switch (t.type) {
      case "[":
        this._saveContext(
          "blank",
          this._graph,
          n = this._blankNode(),
          this.RDF_FIRST,
          this._subject = r = this._blankNode()
        ), o = this._readBlankNodeHead;
        break;
      case "(":
        this._saveContext(
          "list",
          this._graph,
          n = this._blankNode(),
          this.RDF_FIRST,
          this.RDF_NIL
        ), this._subject = null;
        break;
      case ")":
        if (this._restoreContext("list", t), a.length !== 0 && a[a.length - 1].type === "list" && this._emit(this._subject, this._predicate, this._object, this._graph), this._predicate === null) {
          if (o = this._readPredicate, this._subject === this.RDF_NIL)
            return o;
        } else if (o = this._getContextEndReader(), this._object === this.RDF_NIL)
          return o;
        n = this.RDF_NIL;
        break;
      case "literal":
        t.prefix.length === 0 ? (this._literalValue = t.value, o = this._readListItemDataTypeOrLang) : (r = this._literal(t.value, this._namedNode(t.prefix)), o = this._getContextEndReader());
        break;
      case "{":
        return this._n3Mode ? (this._saveContext(
          "formula",
          this._graph,
          this._subject,
          this._predicate,
          this._graph = this._blankNode()
        ), this._readSubject) : this._error("Unexpected graph", t);
      default:
        if ((r = this._readEntity(t)) === void 0)
          return;
    }
    if (n === null && (this._subject = n = this._blankNode()), s === null ? l.predicate === null ? l.subject = n : l.object = n : this._emit(s, this.RDF_REST, n, this._graph), r !== null) {
      if (this._n3Mode && (t.type === "IRI" || t.type === "prefixed"))
        return this._saveContext("item", this._graph, n, this.RDF_FIRST, r), this._subject = r, this._predicate = null, this._getPathReader(this._readListItem);
      this._emit(n, this.RDF_FIRST, r, this._graph);
    }
    return o;
  }
  // ### `_readDataTypeOrLang` reads an _optional_ datatype or language
  _readDataTypeOrLang(t) {
    return this._completeObjectLiteral(t, !1);
  }
  // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list
  _readListItemDataTypeOrLang(t) {
    return this._completeObjectLiteral(t, !0);
  }
  // ### `_completeLiteral` completes a literal with an optional datatype or language
  _completeLiteral(t) {
    let r = this._literal(this._literalValue);
    switch (t.type) {
      case "type":
      case "typeIRI":
        const n = this._readEntity(t);
        if (n === void 0)
          return;
        r = this._literal(this._literalValue, n), t = null;
        break;
      case "langcode":
        r = this._literal(this._literalValue, t.value), t = null;
        break;
    }
    return { token: t, literal: r };
  }
  // Completes a literal in subject position
  _completeSubjectLiteral(t) {
    return this._subject = this._completeLiteral(t).literal, this._readPredicateOrNamedGraph;
  }
  // Completes a literal in object position
  _completeObjectLiteral(t, r) {
    const n = this._completeLiteral(t);
    if (n)
      return this._object = n.literal, r && this._emit(this._subject, this.RDF_FIRST, this._object, this._graph), n.token === null ? this._getContextEndReader() : (this._readCallback = this._getContextEndReader(), this._readCallback(n.token));
  }
  // ### `_readFormulaTail` reads the end of a formula
  _readFormulaTail(t) {
    return t.type !== "}" ? this._readPunctuation(t) : (this._subject !== null && this._emit(this._subject, this._predicate, this._object, this._graph), this._restoreContext("formula", t), this._object === null ? this._readPredicate : this._getContextEndReader());
  }
  // ### `_readPunctuation` reads punctuation between quads or quad parts
  _readPunctuation(t) {
    let r, n = this._graph;
    const o = this._subject, s = this._inversePredicate;
    switch (t.type) {
      case "}":
        if (this._graph === null)
          return this._error("Unexpected graph closing", t);
        if (this._n3Mode)
          return this._readFormulaTail(t);
        this._graph = null;
      case ".":
        this._subject = null, r = this._contextStack.length ? this._readSubject : this._readInTopContext, s && (this._inversePredicate = !1);
        break;
      case ";":
        r = this._readPredicate;
        break;
      case ",":
        r = this._readObject;
        break;
      case "{|":
        if (!this._supportsRDFStar)
          return this._error("Unexpected RDF* syntax", t);
        const a = this._predicate, l = this._object;
        this._subject = this._quad(o, a, l, this.DEFAULTGRAPH), r = this._readPredicate;
        break;
      case "|}":
        if (this._subject.termType !== "Quad")
          return this._error("Unexpected asserted triple closing", t);
        this._subject = null, r = this._readPunctuation;
        break;
      default:
        if (this._supportsQuads && this._graph === null && (n = this._readEntity(t)) !== void 0) {
          r = this._readQuadPunctuation;
          break;
        }
        return this._error(`Expected punctuation to follow "${this._object.id}"`, t);
    }
    if (o !== null) {
      const a = this._predicate, l = this._object;
      s ? this._emit(l, a, o, n) : this._emit(o, a, l, n);
    }
    return r;
  }
  // ### `_readBlankNodePunctuation` reads punctuation in a blank node
  _readBlankNodePunctuation(t) {
    let r;
    switch (t.type) {
      case ";":
        r = this._readPredicate;
        break;
      case ",":
        r = this._readObject;
        break;
      default:
        return this._error(`Expected punctuation to follow "${this._object.id}"`, t);
    }
    return this._emit(this._subject, this._predicate, this._object, this._graph), r;
  }
  // ### `_readQuadPunctuation` reads punctuation after a quad
  _readQuadPunctuation(t) {
    return t.type !== "." ? this._error("Expected dot to follow quad", t) : this._readInTopContext;
  }
  // ### `_readPrefix` reads the prefix of a prefix declaration
  _readPrefix(t) {
    return t.type !== "prefix" ? this._error("Expected prefix to follow @prefix", t) : (this._prefix = t.value, this._readPrefixIRI);
  }
  // ### `_readPrefixIRI` reads the IRI of a prefix declaration
  _readPrefixIRI(t) {
    if (t.type !== "IRI")
      return this._error(`Expected IRI to follow prefix "${this._prefix}:"`, t);
    const r = this._readEntity(t);
    return this._prefixes[this._prefix] = r.value, this._prefixCallback(this._prefix, r), this._readDeclarationPunctuation;
  }
  // ### `_readBaseIRI` reads the IRI of a base declaration
  _readBaseIRI(t) {
    const r = t.type === "IRI" && this._resolveIRI(t.value);
    return r ? (this._setBase(r), this._readDeclarationPunctuation) : this._error("Expected valid IRI to follow base declaration", t);
  }
  // ### `_readNamedGraphLabel` reads the label of a named graph
  _readNamedGraphLabel(t) {
    switch (t.type) {
      case "IRI":
      case "blank":
      case "prefixed":
        return this._readSubject(t), this._readGraph;
      case "[":
        return this._readNamedGraphBlankLabel;
      default:
        return this._error("Invalid graph label", t);
    }
  }
  // ### `_readNamedGraphLabel` reads a blank node label of a named graph
  _readNamedGraphBlankLabel(t) {
    return t.type !== "]" ? this._error("Invalid graph label", t) : (this._subject = this._blankNode(), this._readGraph);
  }
  // ### `_readDeclarationPunctuation` reads the punctuation of a declaration
  _readDeclarationPunctuation(t) {
    return this._sparqlStyle ? (this._sparqlStyle = !1, this._readInTopContext(t)) : t.type !== "." ? this._error("Expected declaration to end with a dot", t) : this._readInTopContext;
  }
  // Reads a list of quantified symbols from a @forSome or @forAll statement
  _readQuantifierList(t) {
    let r;
    switch (t.type) {
      case "IRI":
      case "prefixed":
        if ((r = this._readEntity(t, !0)) !== void 0)
          break;
      default:
        return this._error(`Unexpected ${t.type}`, t);
    }
    return this._explicitQuantifiers ? (this._subject === null ? this._emit(
      this._graph || this.DEFAULTGRAPH,
      this._predicate,
      this._subject = this._blankNode(),
      this.QUANTIFIERS_GRAPH
    ) : this._emit(
      this._subject,
      this.RDF_REST,
      this._subject = this._blankNode(),
      this.QUANTIFIERS_GRAPH
    ), this._emit(this._subject, this.RDF_FIRST, r, this.QUANTIFIERS_GRAPH)) : this._quantified[r.id] = this._quantifier(this._blankNode().value), this._readQuantifierPunctuation;
  }
  // Reads punctuation from a @forSome or @forAll statement
  _readQuantifierPunctuation(t) {
    return t.type === "," ? this._readQuantifierList : (this._explicitQuantifiers && (this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH), this._subject = null), this._readCallback = this._getContextEndReader(), this._readCallback(t));
  }
  // ### `_getPathReader` reads a potential path and then resumes with the given function
  _getPathReader(t) {
    return this._afterPath = t, this._readPath;
  }
  // ### `_readPath` reads a potential path
  _readPath(t) {
    switch (t.type) {
      case "!":
        return this._readForwardPath;
      case "^":
        return this._readBackwardPath;
      default:
        const r = this._contextStack, n = r.length && r[r.length - 1];
        if (n && n.type === "item") {
          const o = this._subject;
          this._restoreContext("item", t), this._emit(this._subject, this.RDF_FIRST, o, this._graph);
        }
        return this._afterPath(t);
    }
  }
  // ### `_readForwardPath` reads a '!' path
  _readForwardPath(t) {
    let r, n;
    const o = this._blankNode();
    if ((n = this._readEntity(t)) !== void 0)
      return this._predicate === null ? (r = this._subject, this._subject = o) : (r = this._object, this._object = o), this._emit(r, n, o, this._graph), this._readPath;
  }
  // ### `_readBackwardPath` reads a '^' path
  _readBackwardPath(t) {
    const r = this._blankNode();
    let n, o;
    if ((n = this._readEntity(t)) !== void 0)
      return this._predicate === null ? (o = this._subject, this._subject = r) : (o = this._object, this._object = r), this._emit(r, n, o, this._graph), this._readPath;
  }
  // ### `_readRDFStarTailOrGraph` reads the graph of a nested RDF* quad or the end of a nested RDF* triple
  _readRDFStarTailOrGraph(t) {
    return t.type !== ">>" ? this._supportsQuads && this._graph === null && (this._graph = this._readEntity(t)) !== void 0 ? this._readRDFStarTail : this._error(`Expected >> to follow "${this._object.id}"`, t) : this._readRDFStarTail(t);
  }
  // ### `_readRDFStarTail` reads the end of a nested RDF* triple
  _readRDFStarTail(t) {
    if (t.type !== ">>")
      return this._error(`Expected >> but got ${t.type}`, t);
    const r = this._quad(
      this._subject,
      this._predicate,
      this._object,
      this._graph || this.DEFAULTGRAPH
    );
    return this._restoreContext("<<", t), this._subject === null ? (this._subject = r, this._readPredicate) : (this._object = r, this._getContextEndReader());
  }
  // ### `_getContextEndReader` gets the next reader function at the end of a context
  _getContextEndReader() {
    const t = this._contextStack;
    if (!t.length)
      return this._readPunctuation;
    switch (t[t.length - 1].type) {
      case "blank":
        return this._readBlankNodeTail;
      case "list":
        return this._readListItem;
      case "formula":
        return this._readFormulaTail;
      case "<<":
        return this._readRDFStarTailOrGraph;
    }
  }
  // ### `_emit` sends a quad through the callback
  _emit(t, r, n, o) {
    this._callback(null, this._quad(t, r, n, o || this.DEFAULTGRAPH));
  }
  // ### `_error` emits an error message through the callback
  _error(t, r) {
    const n = new Error(`${t} on line ${r.line}.`);
    n.context = {
      token: r,
      line: r.line,
      previousToken: this._lexer.previousToken
    }, this._callback(n), this._callback = Ab;
  }
  // ### `_resolveIRI` resolves an IRI against the base path
  _resolveIRI(t) {
    return /^[a-z][a-z0-9+.-]*:/i.test(t) ? t : this._resolveRelativeIRI(t);
  }
  // ### `_resolveRelativeIRI` resolves an IRI against the base path,
  // assuming that a base path has been set and that the IRI is indeed relative
  _resolveRelativeIRI(t) {
    if (!t.length)
      return this._base;
    switch (t[0]) {
      case "#":
        return this._base + t;
      case "?":
        return this._base.replace(/(?:\?.*)?$/, t);
      case "/":
        return (t[1] === "/" ? this._baseScheme : this._baseRoot) + this._removeDotSegments(t);
      default:
        return /^[^/:]*:/.test(t) ? null : this._removeDotSegments(this._basePath + t);
    }
  }
  // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986
  _removeDotSegments(t) {
    if (!/(^|\/)\.\.?($|[/#?])/.test(t))
      return t;
    const r = t.length;
    let n = "", o = -1, s = -1, a = 0, l = "/";
    for (; o < r; ) {
      switch (l) {
        case ":":
          if (s < 0 && t[++o] === "/" && t[++o] === "/")
            for (; (s = o + 1) < r && t[s] !== "/"; )
              o = s;
          break;
        case "?":
        case "#":
          o = r;
          break;
        case "/":
          if (t[o + 1] === ".")
            switch (l = t[++o + 1], l) {
              case "/":
                n += t.substring(a, o - 1), a = o + 1;
                break;
              case void 0:
              case "?":
              case "#":
                return n + t.substring(a, o) + t.substr(o + 1);
              case ".":
                if (l = t[++o + 1], l === void 0 || l === "/" || l === "?" || l === "#") {
                  if (n += t.substring(a, o - 2), (a = n.lastIndexOf("/")) >= s && (n = n.substr(0, a)), l !== "/")
                    return `${n}/${t.substr(o + 1)}`;
                  a = o + 1;
                }
            }
      }
      l = t[++o];
    }
    return n + t.substring(a);
  }
  // ## Public methods
  // ### `parse` parses the N3 input and emits each parsed quad through the callback
  parse(t, r, n) {
    if (this._readCallback = this._readInTopContext, this._sparqlStyle = !1, this._prefixes = /* @__PURE__ */ Object.create(null), this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2) : `b${AT++}_`, this._prefixCallback = n || Ab, this._inversePredicate = !1, this._quantified = /* @__PURE__ */ Object.create(null), !r) {
      const o = [];
      let s;
      if (this._callback = (a, l) => {
        a ? s = a : l && o.push(l);
      }, this._lexer.tokenize(t).every((a) => this._readCallback = this._readCallback(a)), s)
        throw s;
      return o;
    }
    this._callback = r, this._lexer.tokenize(t, (o, s) => {
      o !== null ? (this._callback(o), this._callback = Ab) : this._readCallback && (this._readCallback = this._readCallback(s));
    });
  }
};
function Ab() {
}
function kD(e, t) {
  const r = t.namedNode;
  e._namedNode = r, e._blankNode = t.blankNode, e._literal = t.literal, e._variable = t.variable, e._quad = t.quad, e.DEFAULTGRAPH = t.defaultGraph(), e.RDF_FIRST = r(fi.rdf.first), e.RDF_REST = r(fi.rdf.rest), e.RDF_NIL = r(fi.rdf.nil), e.N3_FORALL = r(fi.r.forAll), e.N3_FORSOME = r(fi.r.forSome), e.ABBREVIATIONS = {
    a: r(fi.rdf.type),
    "=": r(fi.owl.sameAs),
    ">": r(fi.log.implies)
  }, e.QUANTIFIERS_GRAPH = r("urn:n3:quantifiers");
}
kD(CD.prototype, EY);
var ID = { exports: {} }, Tb = { exports: {} }, Ft = {
  ArrayIsArray(e) {
    return Array.isArray(e);
  },
  ArrayPrototypeIncludes(e, t) {
    return e.includes(t);
  },
  ArrayPrototypeIndexOf(e, t) {
    return e.indexOf(t);
  },
  ArrayPrototypeJoin(e, t) {
    return e.join(t);
  },
  ArrayPrototypeMap(e, t) {
    return e.map(t);
  },
  ArrayPrototypePop(e, t) {
    return e.pop(t);
  },
  ArrayPrototypePush(e, t) {
    return e.push(t);
  },
  ArrayPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  Error,
  FunctionPrototypeCall(e, t, ...r) {
    return e.call(t, ...r);
  },
  FunctionPrototypeSymbolHasInstance(e, t) {
    return Function.prototype[Symbol.hasInstance].call(e, t);
  },
  MathFloor: Math.floor,
  Number,
  NumberIsInteger: Number.isInteger,
  NumberIsNaN: Number.isNaN,
  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
  NumberParseInt: Number.parseInt,
  ObjectDefineProperties(e, t) {
    return Object.defineProperties(e, t);
  },
  ObjectDefineProperty(e, t, r) {
    return Object.defineProperty(e, t, r);
  },
  ObjectGetOwnPropertyDescriptor(e, t) {
    return Object.getOwnPropertyDescriptor(e, t);
  },
  ObjectKeys(e) {
    return Object.keys(e);
  },
  ObjectSetPrototypeOf(e, t) {
    return Object.setPrototypeOf(e, t);
  },
  Promise,
  PromisePrototypeCatch(e, t) {
    return e.catch(t);
  },
  PromisePrototypeThen(e, t, r) {
    return e.then(t, r);
  },
  PromiseReject(e) {
    return Promise.reject(e);
  },
  PromiseResolve(e) {
    return Promise.resolve(e);
  },
  ReflectApply: Reflect.apply,
  RegExpPrototypeTest(e, t) {
    return e.test(t);
  },
  SafeSet: Set,
  String,
  StringPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  StringPrototypeToLowerCase(e) {
    return e.toLowerCase();
  },
  StringPrototypeToUpperCase(e) {
    return e.toUpperCase();
  },
  StringPrototypeTrim(e) {
    return e.trim();
  },
  Symbol,
  SymbolFor: Symbol.for,
  SymbolAsyncIterator: Symbol.asyncIterator,
  SymbolHasInstance: Symbol.hasInstance,
  SymbolIterator: Symbol.iterator,
  SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
  SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
  TypedArrayPrototypeSet(e, t, r) {
    return e.set(t, r);
  },
  Boolean,
  Uint8Array
}, MD = { exports: {} }, Lu = { exports: {} }, TT;
function Kt() {
  if (TT)
    return Lu.exports;
  TT = 1;
  const { AbortController: e, AbortSignal: t } = typeof self < "u" ? self : typeof window < "u" ? window : (
    /* otherwise */
    void 0
  );
  return Lu.exports = e, Lu.exports.AbortSignal = t, Lu.exports.default = e, Lu.exports;
}
var ZE = { exports: {} }, kl = typeof Reflect == "object" ? Reflect : null, $T = kl && typeof kl.apply == "function" ? kl.apply : function(t, r, n) {
  return Function.prototype.apply.call(t, r, n);
}, Od;
kl && typeof kl.ownKeys == "function" ? Od = kl.ownKeys : Object.getOwnPropertySymbols ? Od = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : Od = function(t) {
  return Object.getOwnPropertyNames(t);
};
function NY(e) {
  console && console.warn && console.warn(e);
}
var ND = Number.isNaN || function(t) {
  return t !== t;
};
function Rt() {
  Rt.init.call(this);
}
ZE.exports = Rt;
ZE.exports.once = DY;
Rt.EventEmitter = Rt;
Rt.prototype._events = void 0;
Rt.prototype._eventsCount = 0;
Rt.prototype._maxListeners = void 0;
var CT = 10;
function Sp(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(Rt, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return CT;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || ND(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    CT = e;
  }
});
Rt.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Rt.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || ND(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function LD(e) {
  return e._maxListeners === void 0 ? Rt.defaultMaxListeners : e._maxListeners;
}
Rt.prototype.getMaxListeners = function() {
  return LD(this);
};
Rt.prototype.emit = function(t) {
  for (var r = [], n = 1; n < arguments.length; n++)
    r.push(arguments[n]);
  var o = t === "error", s = this._events;
  if (s !== void 0)
    o = o && s.error === void 0;
  else if (!o)
    return !1;
  if (o) {
    var a;
    if (r.length > 0 && (a = r[0]), a instanceof Error)
      throw a;
    var l = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
    throw l.context = a, l;
  }
  var u = s[t];
  if (u === void 0)
    return !1;
  if (typeof u == "function")
    $T(u, this, r);
  else
    for (var f = u.length, c = jD(u, f), n = 0; n < f; ++n)
      $T(c[n], this, r);
  return !0;
};
function OD(e, t, r, n) {
  var o, s, a;
  if (Sp(r), s = e._events, s === void 0 ? (s = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (s.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    r.listener ? r.listener : r
  ), s = e._events), a = s[t]), a === void 0)
    a = s[t] = r, ++e._eventsCount;
  else if (typeof a == "function" ? a = s[t] = n ? [r, a] : [a, r] : n ? a.unshift(r) : a.push(r), o = LD(e), o > 0 && a.length > o && !a.warned) {
    a.warned = !0;
    var l = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    l.name = "MaxListenersExceededWarning", l.emitter = e, l.type = t, l.count = a.length, NY(l);
  }
  return e;
}
Rt.prototype.addListener = function(t, r) {
  return OD(this, t, r, !1);
};
Rt.prototype.on = Rt.prototype.addListener;
Rt.prototype.prependListener = function(t, r) {
  return OD(this, t, r, !0);
};
function LY() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function PD(e, t, r) {
  var n = { fired: !1, wrapFn: void 0, target: e, type: t, listener: r }, o = LY.bind(n);
  return o.listener = r, n.wrapFn = o, o;
}
Rt.prototype.once = function(t, r) {
  return Sp(r), this.on(t, PD(this, t, r)), this;
};
Rt.prototype.prependOnceListener = function(t, r) {
  return Sp(r), this.prependListener(t, PD(this, t, r)), this;
};
Rt.prototype.removeListener = function(t, r) {
  var n, o, s, a, l;
  if (Sp(r), o = this._events, o === void 0)
    return this;
  if (n = o[t], n === void 0)
    return this;
  if (n === r || n.listener === r)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete o[t], o.removeListener && this.emit("removeListener", t, n.listener || r));
  else if (typeof n != "function") {
    for (s = -1, a = n.length - 1; a >= 0; a--)
      if (n[a] === r || n[a].listener === r) {
        l = n[a].listener, s = a;
        break;
      }
    if (s < 0)
      return this;
    s === 0 ? n.shift() : OY(n, s), n.length === 1 && (o[t] = n[0]), o.removeListener !== void 0 && this.emit("removeListener", t, l || r);
  }
  return this;
};
Rt.prototype.off = Rt.prototype.removeListener;
Rt.prototype.removeAllListeners = function(t) {
  var r, n, o;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[t]), this;
  if (arguments.length === 0) {
    var s = Object.keys(n), a;
    for (o = 0; o < s.length; ++o)
      a = s[o], a !== "removeListener" && this.removeAllListeners(a);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r = n[t], typeof r == "function")
    this.removeListener(t, r);
  else if (r !== void 0)
    for (o = r.length - 1; o >= 0; o--)
      this.removeListener(t, r[o]);
  return this;
};
function DD(e, t, r) {
  var n = e._events;
  if (n === void 0)
    return [];
  var o = n[t];
  return o === void 0 ? [] : typeof o == "function" ? r ? [o.listener || o] : [o] : r ? PY(o) : jD(o, o.length);
}
Rt.prototype.listeners = function(t) {
  return DD(this, t, !0);
};
Rt.prototype.rawListeners = function(t) {
  return DD(this, t, !1);
};
Rt.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : FD.call(e, t);
};
Rt.prototype.listenerCount = FD;
function FD(e) {
  var t = this._events;
  if (t !== void 0) {
    var r = t[e];
    if (typeof r == "function")
      return 1;
    if (r !== void 0)
      return r.length;
  }
  return 0;
}
Rt.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Od(this._events) : [];
};
function jD(e, t) {
  for (var r = new Array(t), n = 0; n < t; ++n)
    r[n] = e[n];
  return r;
}
function OY(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function PY(e) {
  for (var t = new Array(e.length), r = 0; r < t.length; ++r)
    t[r] = e[r].listener || e[r];
  return t;
}
function DY(e, t) {
  return new Promise(function(r, n) {
    function o(a) {
      e.removeListener(t, s), n(a);
    }
    function s() {
      typeof e.removeListener == "function" && e.removeListener("error", o), r([].slice.call(arguments));
    }
    BD(e, t, s, { once: !0 }), t !== "error" && FY(e, o, { once: !0 });
  });
}
function FY(e, t, r) {
  typeof e.on == "function" && BD(e, "error", t, r);
}
function BD(e, t, r, n) {
  if (typeof e.on == "function")
    n.once ? e.once(t, r) : e.on(t, r);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function o(s) {
      n.once && e.removeEventListener(t, o), r(s);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var ur = ZE.exports;
(function(e) {
  const t = ut, { kResistStopPropagation: r, SymbolDispose: n } = Ft, o = globalThis.AbortSignal || Kt().AbortSignal, s = globalThis.AbortController || Kt().AbortController, a = Object.getPrototypeOf(async function() {
  }).constructor, l = globalThis.Blob || t.Blob, u = typeof l < "u" ? function(p) {
    return p instanceof l;
  } : function(p) {
    return !1;
  }, f = (h, p) => {
    if (h !== void 0 && (h === null || typeof h != "object" || !("aborted" in h)))
      throw new ERR_INVALID_ARG_TYPE(p, "AbortSignal", h);
  }, c = (h, p) => {
    if (typeof h != "function")
      throw new ERR_INVALID_ARG_TYPE(p, "Function", h);
  };
  class d extends Error {
    constructor(p) {
      if (!Array.isArray(p))
        throw new TypeError(`Expected input to be an Array, got ${typeof p}`);
      let m = "";
      for (let y = 0; y < p.length; y++)
        m += `    ${p[y].stack}
`;
      super(m), this.name = "AggregateError", this.errors = p;
    }
  }
  e.exports = {
    AggregateError: d,
    kEmptyObject: Object.freeze({}),
    once(h) {
      let p = !1;
      return function(...m) {
        p || (p = !0, h.apply(this, m));
      };
    },
    createDeferredPromise: function() {
      let h, p;
      return {
        promise: new Promise((y, _) => {
          h = y, p = _;
        }),
        resolve: h,
        reject: p
      };
    },
    promisify(h) {
      return new Promise((p, m) => {
        h((y, ..._) => y ? m(y) : p(..._));
      });
    },
    debuglog() {
      return function() {
      };
    },
    format(h, ...p) {
      return h.replace(/%([sdifj])/g, function(...[m, y]) {
        const _ = p.shift();
        return y === "f" ? _.toFixed(6) : y === "j" ? JSON.stringify(_) : y === "s" && typeof _ == "object" ? `${_.constructor !== Object ? _.constructor.name : ""} {}`.trim() : _.toString();
      });
    },
    inspect(h) {
      switch (typeof h) {
        case "string":
          if (h.includes("'"))
            if (h.includes('"')) {
              if (!h.includes("`") && !h.includes("${"))
                return `\`${h}\``;
            } else
              return `"${h}"`;
          return `'${h}'`;
        case "number":
          return isNaN(h) ? "NaN" : Object.is(h, -0) ? String(h) : h;
        case "bigint":
          return `${String(h)}n`;
        case "boolean":
        case "undefined":
          return String(h);
        case "object":
          return "{}";
      }
    },
    types: {
      isAsyncFunction(h) {
        return h instanceof a;
      },
      isArrayBufferView(h) {
        return ArrayBuffer.isView(h);
      }
    },
    isBlob: u,
    deprecate(h, p) {
      return h;
    },
    addAbortListener: ur.addAbortListener || function(p, m) {
      if (p === void 0)
        throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", p);
      f(p, "signal"), c(m, "listener");
      let y;
      return p.aborted ? queueMicrotask(() => m()) : (p.addEventListener("abort", m, {
        __proto__: null,
        once: !0,
        [r]: !0
      }), y = () => {
        p.removeEventListener("abort", m);
      }), {
        __proto__: null,
        [n]() {
          var _;
          (_ = y) === null || _ === void 0 || _();
        }
      };
    },
    AbortSignalAny: o.any || function(p) {
      if (p.length === 1)
        return p[0];
      const m = new s(), y = () => m.abort();
      return p.forEach((_) => {
        f(_, "signals"), _.addEventListener("abort", y, {
          once: !0
        });
      }), m.signal.addEventListener(
        "abort",
        () => {
          p.forEach((_) => _.removeEventListener("abort", y));
        },
        {
          once: !0
        }
      ), m.signal;
    }
  }, e.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
})(MD);
var Ur = MD.exports, ex = {};
const { format: jY, inspect: hh, AggregateError: BY } = Ur, qY = globalThis.AggregateError || BY, WY = Symbol("kIsNodeError"), UY = [
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
], HY = /^([A-Z][a-z0-9]*)+$/, zY = "__node_internal_", Ep = {};
function ua(e, t) {
  if (!e)
    throw new Ep.ERR_INTERNAL_ASSERTION(t);
}
function kT(e) {
  let t = "", r = e.length;
  const n = e[0] === "-" ? 1 : 0;
  for (; r >= n + 4; r -= 3)
    t = `_${e.slice(r - 3, r)}${t}`;
  return `${e.slice(0, r)}${t}`;
}
function GY(e, t, r) {
  if (typeof t == "function")
    return ua(
      t.length <= r.length,
      // Default options do not count.
      `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${t.length}).`
    ), t(...r);
  const n = (t.match(/%[dfijoOs]/g) || []).length;
  return ua(
    n === r.length,
    `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${n}).`
  ), r.length === 0 ? t : jY(t, ...r);
}
function vr(e, t, r) {
  r || (r = Error);
  class n extends r {
    constructor(...s) {
      super(GY(e, t, s));
    }
    toString() {
      return `${this.name} [${e}]: ${this.message}`;
    }
  }
  Object.defineProperties(n.prototype, {
    name: {
      value: r.name,
      writable: !0,
      enumerable: !1,
      configurable: !0
    },
    toString: {
      value() {
        return `${this.name} [${e}]: ${this.message}`;
      },
      writable: !0,
      enumerable: !1,
      configurable: !0
    }
  }), n.prototype.code = e, n.prototype[WY] = !0, Ep[e] = n;
}
function IT(e) {
  const t = zY + e.name;
  return Object.defineProperty(e, "name", {
    value: t
  }), e;
}
function VY(e, t) {
  if (e && t && e !== t) {
    if (Array.isArray(t.errors))
      return t.errors.push(e), t;
    const r = new qY([t, e], t.message);
    return r.code = t.code, r;
  }
  return e || t;
}
let KY = class extends Error {
  constructor(t = "The operation was aborted", r = void 0) {
    if (r !== void 0 && typeof r != "object")
      throw new Ep.ERR_INVALID_ARG_TYPE("options", "Object", r);
    super(t, r), this.code = "ABORT_ERR", this.name = "AbortError";
  }
};
vr("ERR_ASSERTION", "%s", Error);
vr(
  "ERR_INVALID_ARG_TYPE",
  (e, t, r) => {
    ua(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
    let n = "The ";
    e.endsWith(" argument") ? n += `${e} ` : n += `"${e}" ${e.includes(".") ? "property" : "argument"} `, n += "must be ";
    const o = [], s = [], a = [];
    for (const u of t)
      ua(typeof u == "string", "All expected entries have to be of type string"), UY.includes(u) ? o.push(u.toLowerCase()) : HY.test(u) ? s.push(u) : (ua(u !== "object", 'The value "object" should be written as "Object"'), a.push(u));
    if (s.length > 0) {
      const u = o.indexOf("object");
      u !== -1 && (o.splice(o, u, 1), s.push("Object"));
    }
    if (o.length > 0) {
      switch (o.length) {
        case 1:
          n += `of type ${o[0]}`;
          break;
        case 2:
          n += `one of type ${o[0]} or ${o[1]}`;
          break;
        default: {
          const u = o.pop();
          n += `one of type ${o.join(", ")}, or ${u}`;
        }
      }
      (s.length > 0 || a.length > 0) && (n += " or ");
    }
    if (s.length > 0) {
      switch (s.length) {
        case 1:
          n += `an instance of ${s[0]}`;
          break;
        case 2:
          n += `an instance of ${s[0]} or ${s[1]}`;
          break;
        default: {
          const u = s.pop();
          n += `an instance of ${s.join(", ")}, or ${u}`;
        }
      }
      a.length > 0 && (n += " or ");
    }
    switch (a.length) {
      case 0:
        break;
      case 1:
        a[0].toLowerCase() !== a[0] && (n += "an "), n += `${a[0]}`;
        break;
      case 2:
        n += `one of ${a[0]} or ${a[1]}`;
        break;
      default: {
        const u = a.pop();
        n += `one of ${a.join(", ")}, or ${u}`;
      }
    }
    if (r == null)
      n += `. Received ${r}`;
    else if (typeof r == "function" && r.name)
      n += `. Received function ${r.name}`;
    else if (typeof r == "object") {
      var l;
      if ((l = r.constructor) !== null && l !== void 0 && l.name)
        n += `. Received an instance of ${r.constructor.name}`;
      else {
        const u = hh(r, {
          depth: -1
        });
        n += `. Received ${u}`;
      }
    } else {
      let u = hh(r, {
        colors: !1
      });
      u.length > 25 && (u = `${u.slice(0, 25)}...`), n += `. Received type ${typeof r} (${u})`;
    }
    return n;
  },
  TypeError
);
vr(
  "ERR_INVALID_ARG_VALUE",
  (e, t, r = "is invalid") => {
    let n = hh(t);
    return n.length > 128 && (n = n.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${n}`;
  },
  TypeError
);
vr(
  "ERR_INVALID_RETURN_VALUE",
  (e, t, r) => {
    var n;
    const o = r != null && (n = r.constructor) !== null && n !== void 0 && n.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
    return `Expected ${e} to be returned from the "${t}" function but got ${o}.`;
  },
  TypeError
);
vr(
  "ERR_MISSING_ARGS",
  (...e) => {
    ua(e.length > 0, "At least one arg needs to be specified");
    let t;
    const r = e.length;
    switch (e = (Array.isArray(e) ? e : [e]).map((n) => `"${n}"`).join(" or "), r) {
      case 1:
        t += `The ${e[0]} argument`;
        break;
      case 2:
        t += `The ${e[0]} and ${e[1]} arguments`;
        break;
      default:
        {
          const n = e.pop();
          t += `The ${e.join(", ")}, and ${n} arguments`;
        }
        break;
    }
    return `${t} must be specified`;
  },
  TypeError
);
vr(
  "ERR_OUT_OF_RANGE",
  (e, t, r) => {
    ua(t, 'Missing "range" argument');
    let n;
    return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? n = kT(String(r)) : typeof r == "bigint" ? (n = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (n = kT(n)), n += "n") : n = hh(r), `The value of "${e}" is out of range. It must be ${t}. Received ${n}`;
  },
  RangeError
);
vr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
vr("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
vr("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
vr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
vr("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
vr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
vr("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
vr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
vr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
vr("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
vr("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
var nn = {
  AbortError: KY,
  aggregateTwoErrors: IT(VY),
  hideStackFrames: IT,
  codes: Ep
};
const {
  ArrayIsArray: tx,
  ArrayPrototypeIncludes: qD,
  ArrayPrototypeJoin: WD,
  ArrayPrototypeMap: YY,
  NumberIsInteger: rx,
  NumberIsNaN: XY,
  NumberMAX_SAFE_INTEGER: JY,
  NumberMIN_SAFE_INTEGER: QY,
  NumberParseInt: ZY,
  ObjectPrototypeHasOwnProperty: eX,
  RegExpPrototypeExec: UD,
  String: tX,
  StringPrototypeToUpperCase: rX,
  StringPrototypeTrim: nX
} = Ft, {
  hideStackFrames: Cn,
  codes: { ERR_SOCKET_BAD_PORT: iX, ERR_INVALID_ARG_TYPE: kr, ERR_INVALID_ARG_VALUE: uu, ERR_OUT_OF_RANGE: xa, ERR_UNKNOWN_SIGNAL: MT }
} = nn, { normalizeEncoding: oX } = Ur, { isAsyncFunction: sX, isArrayBufferView: aX } = Ur.types, NT = {};
function lX(e) {
  return e === (e | 0);
}
function uX(e) {
  return e === e >>> 0;
}
const fX = /^[0-7]+$/, cX = "must be a 32-bit unsigned integer or an octal string";
function dX(e, t, r) {
  if (typeof e > "u" && (e = r), typeof e == "string") {
    if (UD(fX, e) === null)
      throw new uu(t, e, cX);
    e = ZY(e, 8);
  }
  return HD(e, t), e;
}
const hX = Cn((e, t, r = QY, n = JY) => {
  if (typeof e != "number")
    throw new kr(t, "number", e);
  if (!rx(e))
    throw new xa(t, "an integer", e);
  if (e < r || e > n)
    throw new xa(t, `>= ${r} && <= ${n}`, e);
}), pX = Cn((e, t, r = -2147483648, n = 2147483647) => {
  if (typeof e != "number")
    throw new kr(t, "number", e);
  if (!rx(e))
    throw new xa(t, "an integer", e);
  if (e < r || e > n)
    throw new xa(t, `>= ${r} && <= ${n}`, e);
}), HD = Cn((e, t, r = !1) => {
  if (typeof e != "number")
    throw new kr(t, "number", e);
  if (!rx(e))
    throw new xa(t, "an integer", e);
  const n = r ? 1 : 0, o = 4294967295;
  if (e < n || e > o)
    throw new xa(t, `>= ${n} && <= ${o}`, e);
});
function nx(e, t) {
  if (typeof e != "string")
    throw new kr(t, "string", e);
}
function gX(e, t, r = void 0, n) {
  if (typeof e != "number")
    throw new kr(t, "number", e);
  if (r != null && e < r || n != null && e > n || (r != null || n != null) && XY(e))
    throw new xa(
      t,
      `${r != null ? `>= ${r}` : ""}${r != null && n != null ? " && " : ""}${n != null ? `<= ${n}` : ""}`,
      e
    );
}
const bX = Cn((e, t, r) => {
  if (!qD(r, e)) {
    const o = "must be one of: " + WD(
      YY(r, (s) => typeof s == "string" ? `'${s}'` : tX(s)),
      ", "
    );
    throw new uu(t, e, o);
  }
});
function zD(e, t) {
  if (typeof e != "boolean")
    throw new kr(t, "boolean", e);
}
function $b(e, t, r) {
  return e == null || !eX(e, t) ? r : e[t];
}
const yX = Cn((e, t, r = null) => {
  const n = $b(r, "allowArray", !1), o = $b(r, "allowFunction", !1);
  if (!$b(r, "nullable", !1) && e === null || !n && tx(e) || typeof e != "object" && (!o || typeof e != "function"))
    throw new kr(t, "Object", e);
}), mX = Cn((e, t) => {
  if (e != null && typeof e != "object" && typeof e != "function")
    throw new kr(t, "a dictionary", e);
}), xp = Cn((e, t, r = 0) => {
  if (!tx(e))
    throw new kr(t, "Array", e);
  if (e.length < r) {
    const n = `must be longer than ${r}`;
    throw new uu(t, e, n);
  }
});
function vX(e, t) {
  xp(e, t);
  for (let r = 0; r < e.length; r++)
    nx(e[r], `${t}[${r}]`);
}
function wX(e, t) {
  xp(e, t);
  for (let r = 0; r < e.length; r++)
    zD(e[r], `${t}[${r}]`);
}
function _X(e, t) {
  xp(e, t);
  for (let r = 0; r < e.length; r++) {
    const n = e[r], o = `${t}[${r}]`;
    if (n == null)
      throw new kr(o, "AbortSignal", n);
    GD(n, o);
  }
}
function SX(e, t = "signal") {
  if (nx(e, t), NT[e] === void 0)
    throw NT[rX(e)] !== void 0 ? new MT(e + " (signals must use all capital letters)") : new MT(e);
}
const EX = Cn((e, t = "buffer") => {
  if (!aX(e))
    throw new kr(t, ["Buffer", "TypedArray", "DataView"], e);
});
function xX(e, t) {
  const r = oX(t), n = e.length;
  if (r === "hex" && n % 2 !== 0)
    throw new uu("encoding", t, `is invalid for data of length ${n}`);
}
function RX(e, t = "Port", r = !0) {
  if (typeof e != "number" && typeof e != "string" || typeof e == "string" && nX(e).length === 0 || +e !== +e >>> 0 || e > 65535 || e === 0 && !r)
    throw new iX(t, e, r);
  return e | 0;
}
const GD = Cn((e, t) => {
  if (e !== void 0 && (e === null || typeof e != "object" || !("aborted" in e)))
    throw new kr(t, "AbortSignal", e);
}), AX = Cn((e, t) => {
  if (typeof e != "function")
    throw new kr(t, "Function", e);
}), TX = Cn((e, t) => {
  if (typeof e != "function" || sX(e))
    throw new kr(t, "Function", e);
}), $X = Cn((e, t) => {
  if (e !== void 0)
    throw new kr(t, "undefined", e);
});
function CX(e, t, r) {
  if (!qD(r, e))
    throw new kr(t, `('${WD(r, "|")}')`, e);
}
const kX = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
function LT(e, t) {
  if (typeof e > "u" || !UD(kX, e))
    throw new uu(
      t,
      e,
      'must be an array or string of format "</styles.css>; rel=preload; as=style"'
    );
}
function IX(e) {
  if (typeof e == "string")
    return LT(e, "hints"), e;
  if (tx(e)) {
    const t = e.length;
    let r = "";
    if (t === 0)
      return r;
    for (let n = 0; n < t; n++) {
      const o = e[n];
      LT(o, "hints"), r += o, n !== t - 1 && (r += ", ");
    }
    return r;
  }
  throw new uu(
    "hints",
    e,
    'must be an array or string of format "</styles.css>; rel=preload; as=style"'
  );
}
var gc = {
  isInt32: lX,
  isUint32: uX,
  parseFileMode: dX,
  validateArray: xp,
  validateStringArray: vX,
  validateBooleanArray: wX,
  validateAbortSignalArray: _X,
  validateBoolean: zD,
  validateBuffer: EX,
  validateDictionary: mX,
  validateEncoding: xX,
  validateFunction: AX,
  validateInt32: pX,
  validateInteger: hX,
  validateNumber: gX,
  validateObject: yX,
  validateOneOf: bX,
  validatePlainFunction: TX,
  validatePort: RX,
  validateSignalName: SX,
  validateString: nx,
  validateUint32: HD,
  validateUndefined: $X,
  validateUnion: CX,
  validateAbortSignal: GD,
  validateLinkHeaderValue: IX
}, ix = { exports: {} }, VD = { exports: {} }, zt = VD.exports = {}, ci, di;
function j1() {
  throw new Error("setTimeout has not been defined");
}
function B1() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? ci = setTimeout : ci = j1;
  } catch {
    ci = j1;
  }
  try {
    typeof clearTimeout == "function" ? di = clearTimeout : di = B1;
  } catch {
    di = B1;
  }
})();
function KD(e) {
  if (ci === setTimeout)
    return setTimeout(e, 0);
  if ((ci === j1 || !ci) && setTimeout)
    return ci = setTimeout, setTimeout(e, 0);
  try {
    return ci(e, 0);
  } catch {
    try {
      return ci.call(null, e, 0);
    } catch {
      return ci.call(this, e, 0);
    }
  }
}
function MX(e) {
  if (di === clearTimeout)
    return clearTimeout(e);
  if ((di === B1 || !di) && clearTimeout)
    return di = clearTimeout, clearTimeout(e);
  try {
    return di(e);
  } catch {
    try {
      return di.call(null, e);
    } catch {
      return di.call(this, e);
    }
  }
}
var Ji = [], Il = !1, Xs, Pd = -1;
function NX() {
  !Il || !Xs || (Il = !1, Xs.length ? Ji = Xs.concat(Ji) : Pd = -1, Ji.length && YD());
}
function YD() {
  if (!Il) {
    var e = KD(NX);
    Il = !0;
    for (var t = Ji.length; t; ) {
      for (Xs = Ji, Ji = []; ++Pd < t; )
        Xs && Xs[Pd].run();
      Pd = -1, t = Ji.length;
    }
    Xs = null, Il = !1, MX(e);
  }
}
zt.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
  Ji.push(new XD(e, t)), Ji.length === 1 && !Il && KD(YD);
};
function XD(e, t) {
  this.fun = e, this.array = t;
}
XD.prototype.run = function() {
  this.fun.apply(null, this.array);
};
zt.title = "browser";
zt.browser = !0;
zt.env = {};
zt.argv = [];
zt.version = "";
zt.versions = {};
function Eo() {
}
zt.on = Eo;
zt.addListener = Eo;
zt.once = Eo;
zt.off = Eo;
zt.removeListener = Eo;
zt.removeAllListeners = Eo;
zt.emit = Eo;
zt.prependListener = Eo;
zt.prependOnceListener = Eo;
zt.listeners = function(e) {
  return [];
};
zt.binding = function(e) {
  throw new Error("process.binding is not supported");
};
zt.cwd = function() {
  return "/";
};
zt.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
zt.umask = function() {
  return 0;
};
var _t = VD.exports;
const $t = /* @__PURE__ */ $n(_t), { SymbolAsyncIterator: OT, SymbolIterator: PT, SymbolFor: ja } = Ft, JD = ja("nodejs.stream.destroyed"), QD = ja("nodejs.stream.errored"), q1 = ja("nodejs.stream.readable"), W1 = ja("nodejs.stream.writable"), ZD = ja("nodejs.stream.disturbed"), LX = ja("nodejs.webstream.isClosedPromise"), OX = ja("nodejs.webstream.controllerErrorFunction");
function Rp(e, t = !1) {
  var r;
  return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((r = e._readableState) === null || r === void 0 ? void 0 : r.readable) !== !1) && // Duplex
  (!e._writableState || e._readableState));
}
function Ap(e) {
  var t;
  return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === void 0 ? void 0 : t.writable) !== !1));
}
function PX(e) {
  return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
}
function Pi(e) {
  return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
}
function e5(e) {
  return !!(e && !Pi(e) && typeof e.pipeThrough == "function" && typeof e.getReader == "function" && typeof e.cancel == "function");
}
function t5(e) {
  return !!(e && !Pi(e) && typeof e.getWriter == "function" && typeof e.abort == "function");
}
function r5(e) {
  return !!(e && !Pi(e) && typeof e.readable == "object" && typeof e.writable == "object");
}
function DX(e) {
  return e5(e) || t5(e) || r5(e);
}
function FX(e, t) {
  return e == null ? !1 : t === !0 ? typeof e[OT] == "function" : t === !1 ? typeof e[PT] == "function" : typeof e[OT] == "function" || typeof e[PT] == "function";
}
function Tp(e) {
  if (!Pi(e))
    return null;
  const t = e._writableState, r = e._readableState, n = t || r;
  return !!(e.destroyed || e[JD] || n != null && n.destroyed);
}
function n5(e) {
  if (!Ap(e))
    return null;
  if (e.writableEnded === !0)
    return !0;
  const t = e._writableState;
  return t != null && t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function jX(e, t) {
  if (!Ap(e))
    return null;
  if (e.writableFinished === !0)
    return !0;
  const r = e._writableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.finished) != "boolean" ? null : !!(r.finished || t === !1 && r.ended === !0 && r.length === 0);
}
function BX(e) {
  if (!Rp(e))
    return null;
  if (e.readableEnded === !0)
    return !0;
  const t = e._readableState;
  return !t || t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function i5(e, t) {
  if (!Rp(e))
    return null;
  const r = e._readableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.endEmitted) != "boolean" ? null : !!(r.endEmitted || t === !1 && r.ended === !0 && r.length === 0);
}
function o5(e) {
  return e && e[q1] != null ? e[q1] : typeof (e == null ? void 0 : e.readable) != "boolean" ? null : Tp(e) ? !1 : Rp(e) && e.readable && !i5(e);
}
function s5(e) {
  return e && e[W1] != null ? e[W1] : typeof (e == null ? void 0 : e.writable) != "boolean" ? null : Tp(e) ? !1 : Ap(e) && e.writable && !n5(e);
}
function qX(e, t) {
  return Pi(e) ? Tp(e) ? !0 : !((t == null ? void 0 : t.readable) !== !1 && o5(e) || (t == null ? void 0 : t.writable) !== !1 && s5(e)) : null;
}
function WX(e) {
  var t, r;
  return Pi(e) ? e.writableErrored ? e.writableErrored : (t = (r = e._writableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function UX(e) {
  var t, r;
  return Pi(e) ? e.readableErrored ? e.readableErrored : (t = (r = e._readableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function HX(e) {
  if (!Pi(e))
    return null;
  if (typeof e.closed == "boolean")
    return e.closed;
  const t = e._writableState, r = e._readableState;
  return typeof (t == null ? void 0 : t.closed) == "boolean" || typeof (r == null ? void 0 : r.closed) == "boolean" ? (t == null ? void 0 : t.closed) || (r == null ? void 0 : r.closed) : typeof e._closed == "boolean" && a5(e) ? e._closed : null;
}
function a5(e) {
  return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
}
function l5(e) {
  return typeof e._sent100 == "boolean" && a5(e);
}
function zX(e) {
  var t;
  return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === void 0 ? void 0 : t.upgradeOrConnect) === void 0;
}
function GX(e) {
  if (!Pi(e))
    return null;
  const t = e._writableState, r = e._readableState, n = t || r;
  return !n && l5(e) || !!(n && n.autoDestroy && n.emitClose && n.closed === !1);
}
function VX(e) {
  var t;
  return !!(e && ((t = e[ZD]) !== null && t !== void 0 ? t : e.readableDidRead || e.readableAborted));
}
function KX(e) {
  var t, r, n, o, s, a, l, u, f, c;
  return !!(e && ((t = (r = (n = (o = (s = (a = e[QD]) !== null && a !== void 0 ? a : e.readableErrored) !== null && s !== void 0 ? s : e.writableErrored) !== null && o !== void 0 ? o : (l = e._readableState) === null || l === void 0 ? void 0 : l.errorEmitted) !== null && n !== void 0 ? n : (u = e._writableState) === null || u === void 0 ? void 0 : u.errorEmitted) !== null && r !== void 0 ? r : (f = e._readableState) === null || f === void 0 ? void 0 : f.errored) !== null && t !== void 0 ? t : !((c = e._writableState) === null || c === void 0) && c.errored));
}
var xo = {
  isDestroyed: Tp,
  kIsDestroyed: JD,
  isDisturbed: VX,
  kIsDisturbed: ZD,
  isErrored: KX,
  kIsErrored: QD,
  isReadable: o5,
  kIsReadable: q1,
  kIsClosedPromise: LX,
  kControllerErrorFunction: OX,
  kIsWritable: W1,
  isClosed: HX,
  isDuplexNodeStream: PX,
  isFinished: qX,
  isIterable: FX,
  isReadableNodeStream: Rp,
  isReadableStream: e5,
  isReadableEnded: BX,
  isReadableFinished: i5,
  isReadableErrored: UX,
  isNodeStream: Pi,
  isWebStream: DX,
  isWritable: s5,
  isWritableNodeStream: Ap,
  isWritableStream: t5,
  isWritableEnded: n5,
  isWritableFinished: jX,
  isWritableErrored: WX,
  isServerRequest: zX,
  isServerResponse: l5,
  willEmitClose: GX,
  isTransformStream: r5
};
const Fo = _t, { AbortError: u5, codes: YX } = nn, { ERR_INVALID_ARG_TYPE: XX, ERR_STREAM_PREMATURE_CLOSE: DT } = YX, { kEmptyObject: U1, once: H1 } = Ur, { validateAbortSignal: JX, validateFunction: QX, validateObject: ZX, validateBoolean: eJ } = gc, { Promise: tJ, PromisePrototypeThen: rJ, SymbolDispose: f5 } = Ft, {
  isClosed: nJ,
  isReadable: FT,
  isReadableNodeStream: Cb,
  isReadableStream: iJ,
  isReadableFinished: jT,
  isReadableErrored: BT,
  isWritable: qT,
  isWritableNodeStream: WT,
  isWritableStream: oJ,
  isWritableFinished: UT,
  isWritableErrored: HT,
  isNodeStream: sJ,
  willEmitClose: aJ,
  kIsClosedPromise: lJ
} = xo;
let Ml;
function uJ(e) {
  return e.setHeader && typeof e.abort == "function";
}
const z1 = () => {
};
function c5(e, t, r) {
  var n, o;
  if (arguments.length === 2 ? (r = t, t = U1) : t == null ? t = U1 : ZX(t, "options"), QX(r, "callback"), JX(t.signal, "options.signal"), r = H1(r), iJ(e) || oJ(e))
    return fJ(e, t, r);
  if (!sJ(e))
    throw new XX("stream", ["ReadableStream", "WritableStream", "Stream"], e);
  const s = (n = t.readable) !== null && n !== void 0 ? n : Cb(e), a = (o = t.writable) !== null && o !== void 0 ? o : WT(e), l = e._writableState, u = e._readableState, f = () => {
    e.writable || h();
  };
  let c = aJ(e) && Cb(e) === s && WT(e) === a, d = UT(e, !1);
  const h = () => {
    d = !0, e.destroyed && (c = !1), !(c && (!e.readable || s)) && (!s || p) && r.call(e);
  };
  let p = jT(e, !1);
  const m = () => {
    p = !0, e.destroyed && (c = !1), !(c && (!e.writable || a)) && (!a || d) && r.call(e);
  }, y = (I) => {
    r.call(e, I);
  };
  let _ = nJ(e);
  const S = () => {
    _ = !0;
    const I = HT(e) || BT(e);
    if (I && typeof I != "boolean")
      return r.call(e, I);
    if (s && !p && Cb(e, !0) && !jT(e, !1))
      return r.call(e, new DT());
    if (a && !d && !UT(e, !1))
      return r.call(e, new DT());
    r.call(e);
  }, x = () => {
    _ = !0;
    const I = HT(e) || BT(e);
    if (I && typeof I != "boolean")
      return r.call(e, I);
    r.call(e);
  }, E = () => {
    e.req.on("finish", h);
  };
  uJ(e) ? (e.on("complete", h), c || e.on("abort", S), e.req ? E() : e.on("request", E)) : a && !l && (e.on("end", f), e.on("close", f)), !c && typeof e.aborted == "boolean" && e.on("aborted", S), e.on("end", m), e.on("finish", h), t.error !== !1 && e.on("error", y), e.on("close", S), _ ? Fo.nextTick(S) : l != null && l.errorEmitted || u != null && u.errorEmitted ? c || Fo.nextTick(x) : (!s && (!c || FT(e)) && (d || qT(e) === !1) || !a && (!c || qT(e)) && (p || FT(e) === !1) || u && e.req && e.aborted) && Fo.nextTick(x);
  const C = () => {
    r = z1, e.removeListener("aborted", S), e.removeListener("complete", h), e.removeListener("abort", S), e.removeListener("request", E), e.req && e.req.removeListener("finish", h), e.removeListener("end", f), e.removeListener("close", f), e.removeListener("finish", h), e.removeListener("end", m), e.removeListener("error", y), e.removeListener("close", S);
  };
  if (t.signal && !_) {
    const I = () => {
      const j = r;
      C(), j.call(
        e,
        new u5(void 0, {
          cause: t.signal.reason
        })
      );
    };
    if (t.signal.aborted)
      Fo.nextTick(I);
    else {
      Ml = Ml || Ur.addAbortListener;
      const j = Ml(t.signal, I), J = r;
      r = H1((...G) => {
        j[f5](), J.apply(e, G);
      });
    }
  }
  return C;
}
function fJ(e, t, r) {
  let n = !1, o = z1;
  if (t.signal)
    if (o = () => {
      n = !0, r.call(
        e,
        new u5(void 0, {
          cause: t.signal.reason
        })
      );
    }, t.signal.aborted)
      Fo.nextTick(o);
    else {
      Ml = Ml || Ur.addAbortListener;
      const a = Ml(t.signal, o), l = r;
      r = H1((...u) => {
        a[f5](), l.apply(e, u);
      });
    }
  const s = (...a) => {
    n || Fo.nextTick(() => r.apply(e, a));
  };
  return rJ(e[lJ].promise, s, s), z1;
}
function cJ(e, t) {
  var r;
  let n = !1;
  return t === null && (t = U1), (r = t) !== null && r !== void 0 && r.cleanup && (eJ(t.cleanup, "cleanup"), n = t.cleanup), new tJ((o, s) => {
    const a = c5(e, t, (l) => {
      n && a(), l ? s(l) : o();
    });
  });
}
ix.exports = c5;
ix.exports.finished = cJ;
var ms = ix.exports;
const vi = _t, {
  aggregateTwoErrors: dJ,
  codes: { ERR_MULTIPLE_CALLBACK: hJ },
  AbortError: pJ
} = nn, { Symbol: d5 } = Ft, { kIsDestroyed: gJ, isDestroyed: bJ, isFinished: yJ, isServerRequest: mJ } = xo, h5 = d5("kDestroy"), G1 = d5("kConstruct");
function p5(e, t, r) {
  e && (e.stack, t && !t.errored && (t.errored = e), r && !r.errored && (r.errored = e));
}
function vJ(e, t) {
  const r = this._readableState, n = this._writableState, o = n || r;
  return n != null && n.destroyed || r != null && r.destroyed ? (typeof t == "function" && t(), this) : (p5(e, n, r), n && (n.destroyed = !0), r && (r.destroyed = !0), o.constructed ? zT(this, e, t) : this.once(h5, function(s) {
    zT(this, dJ(s, e), t);
  }), this);
}
function zT(e, t, r) {
  let n = !1;
  function o(s) {
    if (n)
      return;
    n = !0;
    const a = e._readableState, l = e._writableState;
    p5(s, l, a), l && (l.closed = !0), a && (a.closed = !0), typeof r == "function" && r(s), s ? vi.nextTick(wJ, e, s) : vi.nextTick(g5, e);
  }
  try {
    e._destroy(t || null, o);
  } catch (s) {
    o(s);
  }
}
function wJ(e, t) {
  V1(e, t), g5(e);
}
function g5(e) {
  const t = e._readableState, r = e._writableState;
  r && (r.closeEmitted = !0), t && (t.closeEmitted = !0), (r != null && r.emitClose || t != null && t.emitClose) && e.emit("close");
}
function V1(e, t) {
  const r = e._readableState, n = e._writableState;
  n != null && n.errorEmitted || r != null && r.errorEmitted || (n && (n.errorEmitted = !0), r && (r.errorEmitted = !0), e.emit("error", t));
}
function _J() {
  const e = this._readableState, t = this._writableState;
  e && (e.constructed = !0, e.closed = !1, e.closeEmitted = !1, e.destroyed = !1, e.errored = null, e.errorEmitted = !1, e.reading = !1, e.ended = e.readable === !1, e.endEmitted = e.readable === !1), t && (t.constructed = !0, t.destroyed = !1, t.closed = !1, t.closeEmitted = !1, t.errored = null, t.errorEmitted = !1, t.finalCalled = !1, t.prefinished = !1, t.ended = t.writable === !1, t.ending = t.writable === !1, t.finished = t.writable === !1);
}
function K1(e, t, r) {
  const n = e._readableState, o = e._writableState;
  if (o != null && o.destroyed || n != null && n.destroyed)
    return this;
  n != null && n.autoDestroy || o != null && o.autoDestroy ? e.destroy(t) : t && (t.stack, o && !o.errored && (o.errored = t), n && !n.errored && (n.errored = t), r ? vi.nextTick(V1, e, t) : V1(e, t));
}
function SJ(e, t) {
  if (typeof e._construct != "function")
    return;
  const r = e._readableState, n = e._writableState;
  r && (r.constructed = !1), n && (n.constructed = !1), e.once(G1, t), !(e.listenerCount(G1) > 1) && vi.nextTick(EJ, e);
}
function EJ(e) {
  let t = !1;
  function r(n) {
    if (t) {
      K1(e, n ?? new hJ());
      return;
    }
    t = !0;
    const o = e._readableState, s = e._writableState, a = s || o;
    o && (o.constructed = !0), s && (s.constructed = !0), a.destroyed ? e.emit(h5, n) : n ? K1(e, n, !0) : vi.nextTick(xJ, e);
  }
  try {
    e._construct((n) => {
      vi.nextTick(r, n);
    });
  } catch (n) {
    vi.nextTick(r, n);
  }
}
function xJ(e) {
  e.emit(G1);
}
function GT(e) {
  return (e == null ? void 0 : e.setHeader) && typeof e.abort == "function";
}
function b5(e) {
  e.emit("close");
}
function RJ(e, t) {
  e.emit("error", t), vi.nextTick(b5, e);
}
function AJ(e, t) {
  !e || bJ(e) || (!t && !yJ(e) && (t = new pJ()), mJ(e) ? (e.socket = null, e.destroy(t)) : GT(e) ? e.abort() : GT(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? vi.nextTick(RJ, e, t) : vi.nextTick(b5, e), e.destroyed || (e[gJ] = !0));
}
var fu = {
  construct: SJ,
  destroyer: AJ,
  destroy: vJ,
  undestroy: _J,
  errorOrDestroy: K1
};
const { ArrayIsArray: TJ, ObjectSetPrototypeOf: y5 } = Ft, { EventEmitter: $p } = ur;
function Cp(e) {
  $p.call(this, e);
}
y5(Cp.prototype, $p.prototype);
y5(Cp, $p);
Cp.prototype.pipe = function(e, t) {
  const r = this;
  function n(c) {
    e.writable && e.write(c) === !1 && r.pause && r.pause();
  }
  r.on("data", n);
  function o() {
    r.readable && r.resume && r.resume();
  }
  e.on("drain", o), !e._isStdio && (!t || t.end !== !1) && (r.on("end", a), r.on("close", l));
  let s = !1;
  function a() {
    s || (s = !0, e.end());
  }
  function l() {
    s || (s = !0, typeof e.destroy == "function" && e.destroy());
  }
  function u(c) {
    f(), $p.listenerCount(this, "error") === 0 && this.emit("error", c);
  }
  Y1(r, "error", u), Y1(e, "error", u);
  function f() {
    r.removeListener("data", n), e.removeListener("drain", o), r.removeListener("end", a), r.removeListener("close", l), r.removeListener("error", u), e.removeListener("error", u), r.removeListener("end", f), r.removeListener("close", f), e.removeListener("close", f);
  }
  return r.on("end", f), r.on("close", f), e.on("close", f), e.emit("pipe", r), e;
};
function Y1(e, t, r) {
  if (typeof e.prependListener == "function")
    return e.prependListener(t, r);
  !e._events || !e._events[t] ? e.on(t, r) : TJ(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
}
var ox = {
  Stream: Cp,
  prependListener: Y1
}, m5 = { exports: {} };
(function(e) {
  const { SymbolDispose: t } = Ft, { AbortError: r, codes: n } = nn, { isNodeStream: o, isWebStream: s, kControllerErrorFunction: a } = xo, l = ms, { ERR_INVALID_ARG_TYPE: u } = n;
  let f;
  const c = (d, h) => {
    if (typeof d != "object" || !("aborted" in d))
      throw new u(h, "AbortSignal", d);
  };
  e.exports.addAbortSignal = function(h, p) {
    if (c(h, "signal"), !o(p) && !s(p))
      throw new u("stream", ["ReadableStream", "WritableStream", "Stream"], p);
    return e.exports.addAbortSignalNoValidate(h, p);
  }, e.exports.addAbortSignalNoValidate = function(d, h) {
    if (typeof d != "object" || !("aborted" in d))
      return h;
    const p = o(h) ? () => {
      h.destroy(
        new r(void 0, {
          cause: d.reason
        })
      );
    } : () => {
      h[a](
        new r(void 0, {
          cause: d.reason
        })
      );
    };
    if (d.aborted)
      p();
    else {
      f = f || Ur.addAbortListener;
      const m = f(d, p);
      l(h, m[t]);
    }
    return h;
  };
})(m5);
var kp = m5.exports;
const { StringPrototypeSlice: VT, SymbolIterator: $J, TypedArrayPrototypeSet: Kc, Uint8Array: CJ } = Ft, { Buffer: kb } = ut, { inspect: kJ } = Ur;
var IJ = class {
  constructor() {
    this.head = null, this.tail = null, this.length = 0;
  }
  push(t) {
    const r = {
      data: t,
      next: null
    };
    this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
  }
  unshift(t) {
    const r = {
      data: t,
      next: this.head
    };
    this.length === 0 && (this.tail = r), this.head = r, ++this.length;
  }
  shift() {
    if (this.length === 0)
      return;
    const t = this.head.data;
    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
  }
  clear() {
    this.head = this.tail = null, this.length = 0;
  }
  join(t) {
    if (this.length === 0)
      return "";
    let r = this.head, n = "" + r.data;
    for (; (r = r.next) !== null; )
      n += t + r.data;
    return n;
  }
  concat(t) {
    if (this.length === 0)
      return kb.alloc(0);
    const r = kb.allocUnsafe(t >>> 0);
    let n = this.head, o = 0;
    for (; n; )
      Kc(r, n.data, o), o += n.data.length, n = n.next;
    return r;
  }
  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(t, r) {
    const n = this.head.data;
    if (t < n.length) {
      const o = n.slice(0, t);
      return this.head.data = n.slice(t), o;
    }
    return t === n.length ? this.shift() : r ? this._getString(t) : this._getBuffer(t);
  }
  first() {
    return this.head.data;
  }
  *[$J]() {
    for (let t = this.head; t; t = t.next)
      yield t.data;
  }
  // Consumes a specified amount of characters from the buffered data.
  _getString(t) {
    let r = "", n = this.head, o = 0;
    do {
      const s = n.data;
      if (t > s.length)
        r += s, t -= s.length;
      else {
        t === s.length ? (r += s, ++o, n.next ? this.head = n.next : this.head = this.tail = null) : (r += VT(s, 0, t), this.head = n, n.data = VT(s, t));
        break;
      }
      ++o;
    } while ((n = n.next) !== null);
    return this.length -= o, r;
  }
  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(t) {
    const r = kb.allocUnsafe(t), n = t;
    let o = this.head, s = 0;
    do {
      const a = o.data;
      if (t > a.length)
        Kc(r, a, n - t), t -= a.length;
      else {
        t === a.length ? (Kc(r, a, n - t), ++s, o.next ? this.head = o.next : this.head = this.tail = null) : (Kc(r, new CJ(a.buffer, a.byteOffset, t), n - t), this.head = o, o.data = a.slice(t));
        break;
      }
      ++s;
    } while ((o = o.next) !== null);
    return this.length -= s, r;
  }
  // Make sure the linked list only shows the minimal necessary information.
  [Symbol.for("nodejs.util.inspect.custom")](t, r) {
    return kJ(this, {
      ...r,
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: !1
    });
  }
};
const { MathFloor: MJ, NumberIsInteger: NJ } = Ft, { validateInteger: LJ } = gc, { ERR_INVALID_ARG_VALUE: OJ } = nn.codes;
let v5 = 16 * 1024, w5 = 16;
function PJ(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function _5(e) {
  return e ? w5 : v5;
}
function DJ(e, t) {
  LJ(t, "value", 0), e ? w5 = t : v5 = t;
}
function FJ(e, t, r, n) {
  const o = PJ(t, n, r);
  if (o != null) {
    if (!NJ(o) || o < 0) {
      const s = n ? `options.${r}` : "options.highWaterMark";
      throw new OJ(s, o);
    }
    return MJ(o);
  }
  return _5(e.objectMode);
}
var Ip = {
  getHighWaterMark: FJ,
  getDefaultHighWaterMark: _5,
  setDefaultHighWaterMark: DJ
}, Ib = {}, Yc = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var KT;
function jJ() {
  return KT || (KT = 1, function(e, t) {
    var r = ut, n = r.Buffer;
    function o(a, l) {
      for (var u in a)
        l[u] = a[u];
    }
    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? e.exports = r : (o(r, t), t.Buffer = s);
    function s(a, l, u) {
      return n(a, l, u);
    }
    s.prototype = Object.create(n.prototype), o(n, s), s.from = function(a, l, u) {
      if (typeof a == "number")
        throw new TypeError("Argument must not be a number");
      return n(a, l, u);
    }, s.alloc = function(a, l, u) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      var f = n(a);
      return l !== void 0 ? typeof u == "string" ? f.fill(l, u) : f.fill(l) : f.fill(0), f;
    }, s.allocUnsafe = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return n(a);
    }, s.allocUnsafeSlow = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(a);
    };
  }(Yc, Yc.exports)), Yc.exports;
}
var YT;
function Hl() {
  if (YT)
    return Ib;
  YT = 1;
  var e = jJ().Buffer, t = e.isEncoding || function(S) {
    switch (S = "" + S, S && S.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function r(S) {
    if (!S)
      return "utf8";
    for (var x; ; )
      switch (S) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return S;
        default:
          if (x)
            return;
          S = ("" + S).toLowerCase(), x = !0;
      }
  }
  function n(S) {
    var x = r(S);
    if (typeof x != "string" && (e.isEncoding === t || !t(S)))
      throw new Error("Unknown encoding: " + S);
    return x || S;
  }
  Ib.StringDecoder = o;
  function o(S) {
    this.encoding = n(S);
    var x;
    switch (this.encoding) {
      case "utf16le":
        this.text = d, this.end = h, x = 4;
        break;
      case "utf8":
        this.fillLast = u, x = 4;
        break;
      case "base64":
        this.text = p, this.end = m, x = 3;
        break;
      default:
        this.write = y, this.end = _;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(x);
  }
  o.prototype.write = function(S) {
    if (S.length === 0)
      return "";
    var x, E;
    if (this.lastNeed) {
      if (x = this.fillLast(S), x === void 0)
        return "";
      E = this.lastNeed, this.lastNeed = 0;
    } else
      E = 0;
    return E < S.length ? x ? x + this.text(S, E) : this.text(S, E) : x || "";
  }, o.prototype.end = c, o.prototype.text = f, o.prototype.fillLast = function(S) {
    if (this.lastNeed <= S.length)
      return S.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    S.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, S.length), this.lastNeed -= S.length;
  };
  function s(S) {
    return S <= 127 ? 0 : S >> 5 === 6 ? 2 : S >> 4 === 14 ? 3 : S >> 3 === 30 ? 4 : S >> 6 === 2 ? -1 : -2;
  }
  function a(S, x, E) {
    var C = x.length - 1;
    if (C < E)
      return 0;
    var I = s(x[C]);
    return I >= 0 ? (I > 0 && (S.lastNeed = I - 1), I) : --C < E || I === -2 ? 0 : (I = s(x[C]), I >= 0 ? (I > 0 && (S.lastNeed = I - 2), I) : --C < E || I === -2 ? 0 : (I = s(x[C]), I >= 0 ? (I > 0 && (I === 2 ? I = 0 : S.lastNeed = I - 3), I) : 0));
  }
  function l(S, x, E) {
    if ((x[0] & 192) !== 128)
      return S.lastNeed = 0, "";
    if (S.lastNeed > 1 && x.length > 1) {
      if ((x[1] & 192) !== 128)
        return S.lastNeed = 1, "";
      if (S.lastNeed > 2 && x.length > 2 && (x[2] & 192) !== 128)
        return S.lastNeed = 2, "";
    }
  }
  function u(S) {
    var x = this.lastTotal - this.lastNeed, E = l(this, S);
    if (E !== void 0)
      return E;
    if (this.lastNeed <= S.length)
      return S.copy(this.lastChar, x, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    S.copy(this.lastChar, x, 0, S.length), this.lastNeed -= S.length;
  }
  function f(S, x) {
    var E = a(this, S, x);
    if (!this.lastNeed)
      return S.toString("utf8", x);
    this.lastTotal = E;
    var C = S.length - (E - this.lastNeed);
    return S.copy(this.lastChar, 0, C), S.toString("utf8", x, C);
  }
  function c(S) {
    var x = S && S.length ? this.write(S) : "";
    return this.lastNeed ? x + "" : x;
  }
  function d(S, x) {
    if ((S.length - x) % 2 === 0) {
      var E = S.toString("utf16le", x);
      if (E) {
        var C = E.charCodeAt(E.length - 1);
        if (C >= 55296 && C <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = S[S.length - 2], this.lastChar[1] = S[S.length - 1], E.slice(0, -1);
      }
      return E;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = S[S.length - 1], S.toString("utf16le", x, S.length - 1);
  }
  function h(S) {
    var x = S && S.length ? this.write(S) : "";
    if (this.lastNeed) {
      var E = this.lastTotal - this.lastNeed;
      return x + this.lastChar.toString("utf16le", 0, E);
    }
    return x;
  }
  function p(S, x) {
    var E = (S.length - x) % 3;
    return E === 0 ? S.toString("base64", x) : (this.lastNeed = 3 - E, this.lastTotal = 3, E === 1 ? this.lastChar[0] = S[S.length - 1] : (this.lastChar[0] = S[S.length - 2], this.lastChar[1] = S[S.length - 1]), S.toString("base64", x, S.length - E));
  }
  function m(S) {
    var x = S && S.length ? this.write(S) : "";
    return this.lastNeed ? x + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : x;
  }
  function y(S) {
    return S.toString(this.encoding);
  }
  function _(S) {
    return S && S.length ? this.write(S) : "";
  }
  return Ib;
}
const XT = _t, { PromisePrototypeThen: BJ, SymbolAsyncIterator: JT, SymbolIterator: QT } = Ft, { Buffer: qJ } = ut, { ERR_INVALID_ARG_TYPE: WJ, ERR_STREAM_NULL_VALUES: UJ } = nn.codes;
function HJ(e, t, r) {
  let n;
  if (typeof t == "string" || t instanceof qJ)
    return new e({
      objectMode: !0,
      ...r,
      read() {
        this.push(t), this.push(null);
      }
    });
  let o;
  if (t && t[JT])
    o = !0, n = t[JT]();
  else if (t && t[QT])
    o = !1, n = t[QT]();
  else
    throw new WJ("iterable", ["Iterable"], t);
  const s = new e({
    objectMode: !0,
    highWaterMark: 1,
    // TODO(ronag): What options should be allowed?
    ...r
  });
  let a = !1;
  s._read = function() {
    a || (a = !0, u());
  }, s._destroy = function(f, c) {
    BJ(
      l(f),
      () => XT.nextTick(c, f),
      // nextTick is here in case cb throws
      (d) => XT.nextTick(c, d || f)
    );
  };
  async function l(f) {
    const c = f != null, d = typeof n.throw == "function";
    if (c && d) {
      const { value: h, done: p } = await n.throw(f);
      if (await h, p)
        return;
    }
    if (typeof n.return == "function") {
      const { value: h } = await n.return();
      await h;
    }
  }
  async function u() {
    for (; ; ) {
      try {
        const { value: f, done: c } = o ? await n.next() : n.next();
        if (c)
          s.push(null);
        else {
          const d = f && typeof f.then == "function" ? await f : f;
          if (d === null)
            throw a = !1, new UJ();
          if (s.push(d))
            continue;
          a = !1;
        }
      } catch (f) {
        s.destroy(f);
      }
      break;
    }
  }
  return s;
}
var S5 = HJ, Mb, ZT;
function Mp() {
  if (ZT)
    return Mb;
  ZT = 1;
  const e = _t, {
    ArrayPrototypeIndexOf: t,
    NumberIsInteger: r,
    NumberIsNaN: n,
    NumberParseInt: o,
    ObjectDefineProperties: s,
    ObjectKeys: a,
    ObjectSetPrototypeOf: l,
    Promise: u,
    SafeSet: f,
    SymbolAsyncDispose: c,
    SymbolAsyncIterator: d,
    Symbol: h
  } = Ft;
  Mb = B, B.ReadableState = ye;
  const { EventEmitter: p } = ur, { Stream: m, prependListener: y } = ox, { Buffer: _ } = ut, { addAbortSignal: S } = kp, x = ms;
  let E = Ur.debuglog("stream", (g) => {
    E = g;
  });
  const C = IJ, I = fu, { getHighWaterMark: j, getDefaultHighWaterMark: J } = Ip, {
    aggregateTwoErrors: G,
    codes: {
      ERR_INVALID_ARG_TYPE: $,
      ERR_METHOD_NOT_IMPLEMENTED: V,
      ERR_OUT_OF_RANGE: M,
      ERR_STREAM_PUSH_AFTER_EOF: W,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT: k
    },
    AbortError: U
  } = nn, { validateObject: Z } = gc, Y = h("kPaused"), { StringDecoder: te } = Hl(), se = S5;
  l(B.prototype, m.prototype), l(B, m);
  const fe = () => {
  }, { errorOrDestroy: he } = I, ae = 1, be = 2, H = 4, pe = 8, ke = 16, le = 32, ee = 64, ge = 128, Ae = 256, Oe = 512, K = 1024, z = 2048, b = 4096, w = 8192, T = 16384, O = 32768, L = 65536, ne = 1 << 17, ue = 1 << 18;
  function oe(g) {
    return {
      enumerable: !1,
      get() {
        return (this.state & g) !== 0;
      },
      set(v) {
        v ? this.state |= g : this.state &= ~g;
      }
    };
  }
  s(ye.prototype, {
    objectMode: oe(ae),
    ended: oe(be),
    endEmitted: oe(H),
    reading: oe(pe),
    // Stream is still being constructed and cannot be
    // destroyed until construction finished or failed.
    // Async construction is opt in, therefore we start as
    // constructed.
    constructed: oe(ke),
    // A flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    sync: oe(le),
    // Whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    needReadable: oe(ee),
    emittedReadable: oe(ge),
    readableListening: oe(Ae),
    resumeScheduled: oe(Oe),
    // True if the error was already emitted and should not be thrown again.
    errorEmitted: oe(K),
    emitClose: oe(z),
    autoDestroy: oe(b),
    // Has it been destroyed.
    destroyed: oe(w),
    // Indicates whether the stream has finished destroying.
    closed: oe(T),
    // True if close has been emitted or would have been emitted
    // depending on emitClose.
    closeEmitted: oe(O),
    multiAwaitDrain: oe(L),
    // If true, a maybeReadMore has been scheduled.
    readingMore: oe(ne),
    dataEmitted: oe(ue)
  });
  function ye(g, v, F) {
    typeof F != "boolean" && (F = v instanceof oo()), this.state = z | b | ke | le, g && g.objectMode && (this.state |= ae), F && g && g.readableObjectMode && (this.state |= ae), this.highWaterMark = g ? j(this, g, "readableHighWaterMark", F) : J(!1), this.buffer = new C(), this.length = 0, this.pipes = [], this.flowing = null, this[Y] = null, g && g.emitClose === !1 && (this.state &= ~z), g && g.autoDestroy === !1 && (this.state &= ~b), this.errored = null, this.defaultEncoding = g && g.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, g && g.encoding && (this.decoder = new te(g.encoding), this.encoding = g.encoding);
  }
  function B(g) {
    if (!(this instanceof B))
      return new B(g);
    const v = this instanceof oo();
    this._readableState = new ye(g, this, v), g && (typeof g.read == "function" && (this._read = g.read), typeof g.destroy == "function" && (this._destroy = g.destroy), typeof g.construct == "function" && (this._construct = g.construct), g.signal && !v && S(g.signal, this)), m.call(this, g), I.construct(this, () => {
      this._readableState.needReadable && re(this, this._readableState);
    });
  }
  B.prototype.destroy = I.destroy, B.prototype._undestroy = I.undestroy, B.prototype._destroy = function(g, v) {
    v(g);
  }, B.prototype[p.captureRejectionSymbol] = function(g) {
    this.destroy(g);
  }, B.prototype[c] = function() {
    let g;
    return this.destroyed || (g = this.readableEnded ? null : new U(), this.destroy(g)), new u((v, F) => x(this, (D) => D && D !== g ? F(D) : v(null)));
  }, B.prototype.push = function(g, v) {
    return me(this, g, v, !1);
  }, B.prototype.unshift = function(g, v) {
    return me(this, g, v, !0);
  };
  function me(g, v, F, D) {
    E("readableAddChunk", v);
    const X = g._readableState;
    let Le;
    if (X.state & ae || (typeof v == "string" ? (F = F || X.defaultEncoding, X.encoding !== F && (D && X.encoding ? v = _.from(v, F).toString(X.encoding) : (v = _.from(v, F), F = ""))) : v instanceof _ ? F = "" : m._isUint8Array(v) ? (v = m._uint8ArrayToBuffer(v), F = "") : v != null && (Le = new $("chunk", ["string", "Buffer", "Uint8Array"], v))), Le)
      he(g, Le);
    else if (v === null)
      X.state &= ~pe, R(g, X);
    else if (X.state & ae || v && v.length > 0)
      if (D)
        if (X.state & H)
          he(g, new k());
        else {
          if (X.destroyed || X.errored)
            return !1;
          Ce(g, X, v, !0);
        }
      else if (X.ended)
        he(g, new W());
      else {
        if (X.destroyed || X.errored)
          return !1;
        X.state &= ~pe, X.decoder && !F ? (v = X.decoder.write(v), X.objectMode || v.length !== 0 ? Ce(g, X, v, !1) : re(g, X)) : Ce(g, X, v, !1);
      }
    else
      D || (X.state &= ~pe, re(g, X));
    return !X.ended && (X.length < X.highWaterMark || X.length === 0);
  }
  function Ce(g, v, F, D) {
    v.flowing && v.length === 0 && !v.sync && g.listenerCount("data") > 0 ? (v.state & L ? v.awaitDrainWriters.clear() : v.awaitDrainWriters = null, v.dataEmitted = !0, g.emit("data", F)) : (v.length += v.objectMode ? 1 : F.length, D ? v.buffer.unshift(F) : v.buffer.push(F), v.state & ee && A(g)), re(g, v);
  }
  B.prototype.isPaused = function() {
    const g = this._readableState;
    return g[Y] === !0 || g.flowing === !1;
  }, B.prototype.setEncoding = function(g) {
    const v = new te(g);
    this._readableState.decoder = v, this._readableState.encoding = this._readableState.decoder.encoding;
    const F = this._readableState.buffer;
    let D = "";
    for (const X of F)
      D += v.write(X);
    return F.clear(), D !== "" && F.push(D), this._readableState.length = D.length, this;
  };
  const Ie = 1073741824;
  function Me(g) {
    if (g > Ie)
      throw new M("size", "<= 1GiB", g);
    return g--, g |= g >>> 1, g |= g >>> 2, g |= g >>> 4, g |= g >>> 8, g |= g >>> 16, g++, g;
  }
  function N(g, v) {
    return g <= 0 || v.length === 0 && v.ended ? 0 : v.state & ae ? 1 : n(g) ? v.flowing && v.length ? v.buffer.first().length : v.length : g <= v.length ? g : v.ended ? v.length : 0;
  }
  B.prototype.read = function(g) {
    E("read", g), g === void 0 ? g = NaN : r(g) || (g = o(g, 10));
    const v = this._readableState, F = g;
    if (g > v.highWaterMark && (v.highWaterMark = Me(g)), g !== 0 && (v.state &= ~ge), g === 0 && v.needReadable && ((v.highWaterMark !== 0 ? v.length >= v.highWaterMark : v.length > 0) || v.ended))
      return E("read: emitReadable", v.length, v.ended), v.length === 0 && v.ended ? At(this) : A(this), null;
    if (g = N(g, v), g === 0 && v.ended)
      return v.length === 0 && At(this), null;
    let D = (v.state & ee) !== 0;
    if (E("need readable", D), (v.length === 0 || v.length - g < v.highWaterMark) && (D = !0, E("length less than watermark", D)), v.ended || v.reading || v.destroyed || v.errored || !v.constructed)
      D = !1, E("reading, ended or constructing", D);
    else if (D) {
      E("do read"), v.state |= pe | le, v.length === 0 && (v.state |= ee);
      try {
        this._read(v.highWaterMark);
      } catch (Le) {
        he(this, Le);
      }
      v.state &= ~le, v.reading || (g = N(F, v));
    }
    let X;
    return g > 0 ? X = Lr(g, v) : X = null, X === null ? (v.needReadable = v.length <= v.highWaterMark, g = 0) : (v.length -= g, v.multiAwaitDrain ? v.awaitDrainWriters.clear() : v.awaitDrainWriters = null), v.length === 0 && (v.ended || (v.needReadable = !0), F !== g && v.ended && At(this)), X !== null && !v.errorEmitted && !v.closeEmitted && (v.dataEmitted = !0, this.emit("data", X)), X;
  };
  function R(g, v) {
    if (E("onEofChunk"), !v.ended) {
      if (v.decoder) {
        const F = v.decoder.end();
        F && F.length && (v.buffer.push(F), v.length += v.objectMode ? 1 : F.length);
      }
      v.ended = !0, v.sync ? A(g) : (v.needReadable = !1, v.emittedReadable = !0, q(g));
    }
  }
  function A(g) {
    const v = g._readableState;
    E("emitReadable", v.needReadable, v.emittedReadable), v.needReadable = !1, v.emittedReadable || (E("emitReadable", v.flowing), v.emittedReadable = !0, e.nextTick(q, g));
  }
  function q(g) {
    const v = g._readableState;
    E("emitReadable_", v.destroyed, v.length, v.ended), !v.destroyed && !v.errored && (v.length || v.ended) && (g.emit("readable"), v.emittedReadable = !1), v.needReadable = !v.flowing && !v.ended && v.length <= v.highWaterMark, Ze(g);
  }
  function re(g, v) {
    !v.readingMore && v.constructed && (v.readingMore = !0, e.nextTick(ce, g, v));
  }
  function ce(g, v) {
    for (; !v.reading && !v.ended && (v.length < v.highWaterMark || v.flowing && v.length === 0); ) {
      const F = v.length;
      if (E("maybeReadMore read 0"), g.read(0), F === v.length)
        break;
    }
    v.readingMore = !1;
  }
  B.prototype._read = function(g) {
    throw new V("_read()");
  }, B.prototype.pipe = function(g, v) {
    const F = this, D = this._readableState;
    D.pipes.length === 1 && (D.multiAwaitDrain || (D.multiAwaitDrain = !0, D.awaitDrainWriters = new f(D.awaitDrainWriters ? [D.awaitDrainWriters] : []))), D.pipes.push(g), E("pipe count=%d opts=%j", D.pipes.length, v);
    const Le = (!v || v.end !== !1) && g !== e.stdout && g !== e.stderr ? Xt : St;
    D.endEmitted ? e.nextTick(Le) : F.once("end", Le), g.on("unpipe", We);
    function We(ft, rt) {
      E("onunpipe"), ft === F && rt && rt.hasUnpiped === !1 && (rt.hasUnpiped = !0, yn());
    }
    function Xt() {
      E("onend"), g.end();
    }
    let dt, Kr = !1;
    function yn() {
      E("cleanup"), g.removeListener("close", or), g.removeListener("finish", dr), dt && g.removeListener("drain", dt), g.removeListener("error", cr), g.removeListener("unpipe", We), F.removeListener("end", Xt), F.removeListener("end", St), F.removeListener("data", xr), Kr = !0, dt && D.awaitDrainWriters && (!g._writableState || g._writableState.needDrain) && dt();
    }
    function Wt() {
      Kr || (D.pipes.length === 1 && D.pipes[0] === g ? (E("false write response, pause", 0), D.awaitDrainWriters = g, D.multiAwaitDrain = !1) : D.pipes.length > 1 && D.pipes.includes(g) && (E("false write response, pause", D.awaitDrainWriters.size), D.awaitDrainWriters.add(g)), F.pause()), dt || (dt = de(F, g), g.on("drain", dt));
    }
    F.on("data", xr);
    function xr(ft) {
      E("ondata");
      const rt = g.write(ft);
      E("dest.write", rt), rt === !1 && Wt();
    }
    function cr(ft) {
      if (E("onerror", ft), St(), g.removeListener("error", cr), g.listenerCount("error") === 0) {
        const rt = g._writableState || g._readableState;
        rt && !rt.errorEmitted ? he(g, ft) : g.emit("error", ft);
      }
    }
    y(g, "error", cr);
    function or() {
      g.removeListener("finish", dr), St();
    }
    g.once("close", or);
    function dr() {
      E("onfinish"), g.removeListener("close", or), St();
    }
    g.once("finish", dr);
    function St() {
      E("unpipe"), F.unpipe(g);
    }
    return g.emit("pipe", F), g.writableNeedDrain === !0 ? Wt() : D.flowing || (E("pipe resume"), F.resume()), g;
  };
  function de(g, v) {
    return function() {
      const D = g._readableState;
      D.awaitDrainWriters === v ? (E("pipeOnDrain", 1), D.awaitDrainWriters = null) : D.multiAwaitDrain && (E("pipeOnDrain", D.awaitDrainWriters.size), D.awaitDrainWriters.delete(v)), (!D.awaitDrainWriters || D.awaitDrainWriters.size === 0) && g.listenerCount("data") && g.resume();
    };
  }
  B.prototype.unpipe = function(g) {
    const v = this._readableState, F = {
      hasUnpiped: !1
    };
    if (v.pipes.length === 0)
      return this;
    if (!g) {
      const X = v.pipes;
      v.pipes = [], this.pause();
      for (let Le = 0; Le < X.length; Le++)
        X[Le].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    const D = t(v.pipes, g);
    return D === -1 ? this : (v.pipes.splice(D, 1), v.pipes.length === 0 && this.pause(), g.emit("unpipe", this, F), this);
  }, B.prototype.on = function(g, v) {
    const F = m.prototype.on.call(this, g, v), D = this._readableState;
    return g === "data" ? (D.readableListening = this.listenerCount("readable") > 0, D.flowing !== !1 && this.resume()) : g === "readable" && !D.endEmitted && !D.readableListening && (D.readableListening = D.needReadable = !0, D.flowing = !1, D.emittedReadable = !1, E("on readable", D.length, D.reading), D.length ? A(this) : D.reading || e.nextTick(it, this)), F;
  }, B.prototype.addListener = B.prototype.on, B.prototype.removeListener = function(g, v) {
    const F = m.prototype.removeListener.call(this, g, v);
    return g === "readable" && e.nextTick(De, this), F;
  }, B.prototype.off = B.prototype.removeListener, B.prototype.removeAllListeners = function(g) {
    const v = m.prototype.removeAllListeners.apply(this, arguments);
    return (g === "readable" || g === void 0) && e.nextTick(De, this), v;
  };
  function De(g) {
    const v = g._readableState;
    v.readableListening = g.listenerCount("readable") > 0, v.resumeScheduled && v[Y] === !1 ? v.flowing = !0 : g.listenerCount("data") > 0 ? g.resume() : v.readableListening || (v.flowing = null);
  }
  function it(g) {
    E("readable nexttick read 0"), g.read(0);
  }
  B.prototype.resume = function() {
    const g = this._readableState;
    return g.flowing || (E("resume"), g.flowing = !g.readableListening, ze(this, g)), g[Y] = !1, this;
  };
  function ze(g, v) {
    v.resumeScheduled || (v.resumeScheduled = !0, e.nextTick(Ve, g, v));
  }
  function Ve(g, v) {
    E("resume", v.reading), v.reading || g.read(0), v.resumeScheduled = !1, g.emit("resume"), Ze(g), v.flowing && !v.reading && g.read(0);
  }
  B.prototype.pause = function() {
    return E("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (E("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState[Y] = !0, this;
  };
  function Ze(g) {
    const v = g._readableState;
    for (E("flow", v.flowing); v.flowing && g.read() !== null; )
      ;
  }
  B.prototype.wrap = function(g) {
    let v = !1;
    g.on("data", (D) => {
      !this.push(D) && g.pause && (v = !0, g.pause());
    }), g.on("end", () => {
      this.push(null);
    }), g.on("error", (D) => {
      he(this, D);
    }), g.on("close", () => {
      this.destroy();
    }), g.on("destroy", () => {
      this.destroy();
    }), this._read = () => {
      v && g.resume && (v = !1, g.resume());
    };
    const F = a(g);
    for (let D = 1; D < F.length; D++) {
      const X = F[D];
      this[X] === void 0 && typeof g[X] == "function" && (this[X] = g[X].bind(g));
    }
    return this;
  }, B.prototype[d] = function() {
    return Er(this);
  }, B.prototype.iterator = function(g) {
    return g !== void 0 && Z(g, "options"), Er(this, g);
  };
  function Er(g, v) {
    typeof g.read != "function" && (g = B.wrap(g, {
      objectMode: !0
    }));
    const F = Wi(g, v);
    return F.stream = g, F;
  }
  async function* Wi(g, v) {
    let F = fe;
    function D(We) {
      this === g ? (F(), F = fe) : F = We;
    }
    g.on("readable", D);
    let X;
    const Le = x(
      g,
      {
        writable: !1
      },
      (We) => {
        X = We ? G(X, We) : null, F(), F = fe;
      }
    );
    try {
      for (; ; ) {
        const We = g.destroyed ? null : g.read();
        if (We !== null)
          yield We;
        else {
          if (X)
            throw X;
          if (X === null)
            return;
          await new u(D);
        }
      }
    } catch (We) {
      throw X = G(X, We), X;
    } finally {
      (X || (v == null ? void 0 : v.destroyOnReturn) !== !1) && (X === void 0 || g._readableState.autoDestroy) ? I.destroyer(g, null) : (g.off("readable", D), Le());
    }
  }
  s(B.prototype, {
    readable: {
      __proto__: null,
      get() {
        const g = this._readableState;
        return !!g && g.readable !== !1 && !g.destroyed && !g.errorEmitted && !g.endEmitted;
      },
      set(g) {
        this._readableState && (this._readableState.readable = !!g);
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(g) {
        this._readableState && (this._readableState.flowing = g);
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.objectMode : !1;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.destroyed : !1;
      },
      set(g) {
        this._readableState && (this._readableState.destroyed = g);
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.endEmitted : !1;
      }
    }
  }), s(ye.prototype, {
    // Legacy getter for `pipesCount`.
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    // Legacy property for `paused`.
    paused: {
      __proto__: null,
      get() {
        return this[Y] !== !1;
      },
      set(g) {
        this[Y] = !!g;
      }
    }
  }), B._fromList = Lr;
  function Lr(g, v) {
    if (v.length === 0)
      return null;
    let F;
    return v.objectMode ? F = v.buffer.shift() : !g || g >= v.length ? (v.decoder ? F = v.buffer.join("") : v.buffer.length === 1 ? F = v.buffer.first() : F = v.buffer.concat(v.length), v.buffer.clear()) : F = v.buffer.consume(g, v.decoder), F;
  }
  function At(g) {
    const v = g._readableState;
    E("endReadable", v.endEmitted), v.endEmitted || (v.ended = !0, e.nextTick(si, v, g));
  }
  function si(g, v) {
    if (E("endReadableNT", g.endEmitted, g.length), !g.errored && !g.closeEmitted && !g.endEmitted && g.length === 0) {
      if (g.endEmitted = !0, v.emit("end"), v.writable && v.allowHalfOpen === !1)
        e.nextTick(Ui, v);
      else if (g.autoDestroy) {
        const F = v._writableState;
        (!F || F.autoDestroy && // We don't expect the writable to ever 'finish'
        // if writable is explicitly set to false.
        (F.finished || F.writable === !1)) && v.destroy();
      }
    }
  }
  function Ui(g) {
    g.writable && !g.writableEnded && !g.destroyed && g.end();
  }
  B.from = function(g, v) {
    return se(B, g, v);
  };
  let Nt;
  function ln() {
    return Nt === void 0 && (Nt = {}), Nt;
  }
  return B.fromWeb = function(g, v) {
    return ln().newStreamReadableFromReadableStream(g, v);
  }, B.toWeb = function(g, v) {
    return ln().newReadableStreamFromStreamReadable(g, v);
  }, B.wrap = function(g, v) {
    var F, D;
    return new B({
      objectMode: (F = (D = g.readableObjectMode) !== null && D !== void 0 ? D : g.objectMode) !== null && F !== void 0 ? F : !0,
      ...v,
      destroy(X, Le) {
        I.destroyer(g, X), Le(X);
      }
    }).wrap(g);
  }, Mb;
}
var Nb, e$;
function sx() {
  if (e$)
    return Nb;
  e$ = 1;
  const e = _t, {
    ArrayPrototypeSlice: t,
    Error: r,
    FunctionPrototypeSymbolHasInstance: n,
    ObjectDefineProperty: o,
    ObjectDefineProperties: s,
    ObjectSetPrototypeOf: a,
    StringPrototypeToLowerCase: l,
    Symbol: u,
    SymbolHasInstance: f
  } = Ft;
  Nb = Z, Z.WritableState = k;
  const { EventEmitter: c } = ur, d = ox.Stream, { Buffer: h } = ut, p = fu, { addAbortSignal: m } = kp, { getHighWaterMark: y, getDefaultHighWaterMark: _ } = Ip, {
    ERR_INVALID_ARG_TYPE: S,
    ERR_METHOD_NOT_IMPLEMENTED: x,
    ERR_MULTIPLE_CALLBACK: E,
    ERR_STREAM_CANNOT_PIPE: C,
    ERR_STREAM_DESTROYED: I,
    ERR_STREAM_ALREADY_FINISHED: j,
    ERR_STREAM_NULL_VALUES: J,
    ERR_STREAM_WRITE_AFTER_END: G,
    ERR_UNKNOWN_ENCODING: $
  } = nn.codes, { errorOrDestroy: V } = p;
  a(Z.prototype, d.prototype), a(Z, d);
  function M() {
  }
  const W = u("kOnFinished");
  function k(b, w, T) {
    typeof T != "boolean" && (T = w instanceof oo()), this.objectMode = !!(b && b.objectMode), T && (this.objectMode = this.objectMode || !!(b && b.writableObjectMode)), this.highWaterMark = b ? y(this, b, "writableHighWaterMark", T) : _(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    const O = !!(b && b.decodeStrings === !1);
    this.decodeStrings = !O, this.defaultEncoding = b && b.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = he.bind(void 0, w), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, U(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !b || b.emitClose !== !1, this.autoDestroy = !b || b.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[W] = [];
  }
  function U(b) {
    b.buffered = [], b.bufferedIndex = 0, b.allBuffers = !0, b.allNoop = !0;
  }
  k.prototype.getBuffer = function() {
    return t(this.buffered, this.bufferedIndex);
  }, o(k.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function Z(b) {
    const w = this instanceof oo();
    if (!w && !n(Z, this))
      return new Z(b);
    this._writableState = new k(b, this, w), b && (typeof b.write == "function" && (this._write = b.write), typeof b.writev == "function" && (this._writev = b.writev), typeof b.destroy == "function" && (this._destroy = b.destroy), typeof b.final == "function" && (this._final = b.final), typeof b.construct == "function" && (this._construct = b.construct), b.signal && m(b.signal, this)), d.call(this, b), p.construct(this, () => {
      const T = this._writableState;
      T.writing || pe(this, T), ge(this, T);
    });
  }
  o(Z, f, {
    __proto__: null,
    value: function(b) {
      return n(this, b) ? !0 : this !== Z ? !1 : b && b._writableState instanceof k;
    }
  }), Z.prototype.pipe = function() {
    V(this, new C());
  };
  function Y(b, w, T, O) {
    const L = b._writableState;
    if (typeof T == "function")
      O = T, T = L.defaultEncoding;
    else {
      if (!T)
        T = L.defaultEncoding;
      else if (T !== "buffer" && !h.isEncoding(T))
        throw new $(T);
      typeof O != "function" && (O = M);
    }
    if (w === null)
      throw new J();
    if (!L.objectMode)
      if (typeof w == "string")
        L.decodeStrings !== !1 && (w = h.from(w, T), T = "buffer");
      else if (w instanceof h)
        T = "buffer";
      else if (d._isUint8Array(w))
        w = d._uint8ArrayToBuffer(w), T = "buffer";
      else
        throw new S("chunk", ["string", "Buffer", "Uint8Array"], w);
    let ne;
    return L.ending ? ne = new G() : L.destroyed && (ne = new I("write")), ne ? (e.nextTick(O, ne), V(b, ne, !0), ne) : (L.pendingcb++, te(b, L, w, T, O));
  }
  Z.prototype.write = function(b, w, T) {
    return Y(this, b, w, T) === !0;
  }, Z.prototype.cork = function() {
    this._writableState.corked++;
  }, Z.prototype.uncork = function() {
    const b = this._writableState;
    b.corked && (b.corked--, b.writing || pe(this, b));
  }, Z.prototype.setDefaultEncoding = function(w) {
    if (typeof w == "string" && (w = l(w)), !h.isEncoding(w))
      throw new $(w);
    return this._writableState.defaultEncoding = w, this;
  };
  function te(b, w, T, O, L) {
    const ne = w.objectMode ? 1 : T.length;
    w.length += ne;
    const ue = w.length < w.highWaterMark;
    return ue || (w.needDrain = !0), w.writing || w.corked || w.errored || !w.constructed ? (w.buffered.push({
      chunk: T,
      encoding: O,
      callback: L
    }), w.allBuffers && O !== "buffer" && (w.allBuffers = !1), w.allNoop && L !== M && (w.allNoop = !1)) : (w.writelen = ne, w.writecb = L, w.writing = !0, w.sync = !0, b._write(T, O, w.onwrite), w.sync = !1), ue && !w.errored && !w.destroyed;
  }
  function se(b, w, T, O, L, ne, ue) {
    w.writelen = O, w.writecb = ue, w.writing = !0, w.sync = !0, w.destroyed ? w.onwrite(new I("write")) : T ? b._writev(L, w.onwrite) : b._write(L, ne, w.onwrite), w.sync = !1;
  }
  function fe(b, w, T, O) {
    --w.pendingcb, O(T), H(w), V(b, T);
  }
  function he(b, w) {
    const T = b._writableState, O = T.sync, L = T.writecb;
    if (typeof L != "function") {
      V(b, new E());
      return;
    }
    T.writing = !1, T.writecb = null, T.length -= T.writelen, T.writelen = 0, w ? (w.stack, T.errored || (T.errored = w), b._readableState && !b._readableState.errored && (b._readableState.errored = w), O ? e.nextTick(fe, b, T, w, L) : fe(b, T, w, L)) : (T.buffered.length > T.bufferedIndex && pe(b, T), O ? T.afterWriteTickInfo !== null && T.afterWriteTickInfo.cb === L ? T.afterWriteTickInfo.count++ : (T.afterWriteTickInfo = {
      count: 1,
      cb: L,
      stream: b,
      state: T
    }, e.nextTick(ae, T.afterWriteTickInfo)) : be(b, T, 1, L));
  }
  function ae({ stream: b, state: w, count: T, cb: O }) {
    return w.afterWriteTickInfo = null, be(b, w, T, O);
  }
  function be(b, w, T, O) {
    for (!w.ending && !b.destroyed && w.length === 0 && w.needDrain && (w.needDrain = !1, b.emit("drain")); T-- > 0; )
      w.pendingcb--, O();
    w.destroyed && H(w), ge(b, w);
  }
  function H(b) {
    if (b.writing)
      return;
    for (let L = b.bufferedIndex; L < b.buffered.length; ++L) {
      var w;
      const { chunk: ne, callback: ue } = b.buffered[L], oe = b.objectMode ? 1 : ne.length;
      b.length -= oe, ue(
        (w = b.errored) !== null && w !== void 0 ? w : new I("write")
      );
    }
    const T = b[W].splice(0);
    for (let L = 0; L < T.length; L++) {
      var O;
      T[L](
        (O = b.errored) !== null && O !== void 0 ? O : new I("end")
      );
    }
    U(b);
  }
  function pe(b, w) {
    if (w.corked || w.bufferProcessing || w.destroyed || !w.constructed)
      return;
    const { buffered: T, bufferedIndex: O, objectMode: L } = w, ne = T.length - O;
    if (!ne)
      return;
    let ue = O;
    if (w.bufferProcessing = !0, ne > 1 && b._writev) {
      w.pendingcb -= ne - 1;
      const oe = w.allNoop ? M : (B) => {
        for (let me = ue; me < T.length; ++me)
          T[me].callback(B);
      }, ye = w.allNoop && ue === 0 ? T : t(T, ue);
      ye.allBuffers = w.allBuffers, se(b, w, !0, w.length, ye, "", oe), U(w);
    } else {
      do {
        const { chunk: oe, encoding: ye, callback: B } = T[ue];
        T[ue++] = null;
        const me = L ? 1 : oe.length;
        se(b, w, !1, me, oe, ye, B);
      } while (ue < T.length && !w.writing);
      ue === T.length ? U(w) : ue > 256 ? (T.splice(0, ue), w.bufferedIndex = 0) : w.bufferedIndex = ue;
    }
    w.bufferProcessing = !1;
  }
  Z.prototype._write = function(b, w, T) {
    if (this._writev)
      this._writev(
        [
          {
            chunk: b,
            encoding: w
          }
        ],
        T
      );
    else
      throw new x("_write()");
  }, Z.prototype._writev = null, Z.prototype.end = function(b, w, T) {
    const O = this._writableState;
    typeof b == "function" ? (T = b, b = null, w = null) : typeof w == "function" && (T = w, w = null);
    let L;
    if (b != null) {
      const ne = Y(this, b, w);
      ne instanceof r && (L = ne);
    }
    return O.corked && (O.corked = 1, this.uncork()), L || (!O.errored && !O.ending ? (O.ending = !0, ge(this, O, !0), O.ended = !0) : O.finished ? L = new j("end") : O.destroyed && (L = new I("end"))), typeof T == "function" && (L || O.finished ? e.nextTick(T, L) : O[W].push(T)), this;
  };
  function ke(b) {
    return b.ending && !b.destroyed && b.constructed && b.length === 0 && !b.errored && b.buffered.length === 0 && !b.finished && !b.writing && !b.errorEmitted && !b.closeEmitted;
  }
  function le(b, w) {
    let T = !1;
    function O(L) {
      if (T) {
        V(b, L ?? E());
        return;
      }
      if (T = !0, w.pendingcb--, L) {
        const ne = w[W].splice(0);
        for (let ue = 0; ue < ne.length; ue++)
          ne[ue](L);
        V(b, L, w.sync);
      } else
        ke(w) && (w.prefinished = !0, b.emit("prefinish"), w.pendingcb++, e.nextTick(Ae, b, w));
    }
    w.sync = !0, w.pendingcb++;
    try {
      b._final(O);
    } catch (L) {
      O(L);
    }
    w.sync = !1;
  }
  function ee(b, w) {
    !w.prefinished && !w.finalCalled && (typeof b._final == "function" && !w.destroyed ? (w.finalCalled = !0, le(b, w)) : (w.prefinished = !0, b.emit("prefinish")));
  }
  function ge(b, w, T) {
    ke(w) && (ee(b, w), w.pendingcb === 0 && (T ? (w.pendingcb++, e.nextTick(
      (O, L) => {
        ke(L) ? Ae(O, L) : L.pendingcb--;
      },
      b,
      w
    )) : ke(w) && (w.pendingcb++, Ae(b, w))));
  }
  function Ae(b, w) {
    w.pendingcb--, w.finished = !0;
    const T = w[W].splice(0);
    for (let O = 0; O < T.length; O++)
      T[O]();
    if (b.emit("finish"), w.autoDestroy) {
      const O = b._readableState;
      (!O || O.autoDestroy && // We don't expect the readable to ever 'end'
      // if readable is explicitly set to false.
      (O.endEmitted || O.readable === !1)) && b.destroy();
    }
  }
  s(Z.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : !1;
      },
      set(b) {
        this._writableState && (this._writableState.destroyed = b);
      }
    },
    writable: {
      __proto__: null,
      get() {
        const b = this._writableState;
        return !!b && b.writable !== !1 && !b.destroyed && !b.errored && !b.ending && !b.ended;
      },
      set(b) {
        this._writableState && (this._writableState.writable = !!b);
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : !1;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : !1;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : !1;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const b = this._writableState;
        return b ? !b.destroyed && !b.ending && b.needDrain : !1;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  const Oe = p.destroy;
  Z.prototype.destroy = function(b, w) {
    const T = this._writableState;
    return !T.destroyed && (T.bufferedIndex < T.buffered.length || T[W].length) && e.nextTick(H, T), Oe.call(this, b, w), this;
  }, Z.prototype._undestroy = p.undestroy, Z.prototype._destroy = function(b, w) {
    w(b);
  }, Z.prototype[c.captureRejectionSymbol] = function(b) {
    this.destroy(b);
  };
  let K;
  function z() {
    return K === void 0 && (K = {}), K;
  }
  return Z.fromWeb = function(b, w) {
    return z().newStreamWritableFromWritableStream(b, w);
  }, Z.toWeb = function(b) {
    return z().newWritableStreamFromStreamWritable(b);
  }, Nb;
}
var Lb, t$;
function zJ() {
  if (t$)
    return Lb;
  t$ = 1;
  const e = _t, t = ut, {
    isReadable: r,
    isWritable: n,
    isIterable: o,
    isNodeStream: s,
    isReadableNodeStream: a,
    isWritableNodeStream: l,
    isDuplexNodeStream: u,
    isReadableStream: f,
    isWritableStream: c
  } = xo, d = ms, {
    AbortError: h,
    codes: { ERR_INVALID_ARG_TYPE: p, ERR_INVALID_RETURN_VALUE: m }
  } = nn, { destroyer: y } = fu, _ = oo(), S = Mp(), x = sx(), { createDeferredPromise: E } = Ur, C = S5, I = globalThis.Blob || t.Blob, j = typeof I < "u" ? function(k) {
    return k instanceof I;
  } : function(k) {
    return !1;
  }, J = globalThis.AbortController || Kt().AbortController, { FunctionPrototypeCall: G } = Ft;
  class $ extends _ {
    constructor(k) {
      super(k), (k == null ? void 0 : k.readable) === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), (k == null ? void 0 : k.writable) === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0);
    }
  }
  Lb = function W(k, U) {
    if (u(k))
      return k;
    if (a(k))
      return M({
        readable: k
      });
    if (l(k))
      return M({
        writable: k
      });
    if (s(k))
      return M({
        writable: !1,
        readable: !1
      });
    if (f(k))
      return M({
        readable: S.fromWeb(k)
      });
    if (c(k))
      return M({
        writable: x.fromWeb(k)
      });
    if (typeof k == "function") {
      const { value: Y, write: te, final: se, destroy: fe } = V(k);
      if (o(Y))
        return C($, Y, {
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          write: te,
          final: se,
          destroy: fe
        });
      const he = Y == null ? void 0 : Y.then;
      if (typeof he == "function") {
        let ae;
        const be = G(
          he,
          Y,
          (H) => {
            if (H != null)
              throw new m("nully", "body", H);
          },
          (H) => {
            y(ae, H);
          }
        );
        return ae = new $({
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          readable: !1,
          write: te,
          final(H) {
            se(async () => {
              try {
                await be, e.nextTick(H, null);
              } catch (pe) {
                e.nextTick(H, pe);
              }
            });
          },
          destroy: fe
        });
      }
      throw new m("Iterable, AsyncIterable or AsyncFunction", U, Y);
    }
    if (j(k))
      return W(k.arrayBuffer());
    if (o(k))
      return C($, k, {
        // TODO (ronag): highWaterMark?
        objectMode: !0,
        writable: !1
      });
    if (f(k == null ? void 0 : k.readable) && c(k == null ? void 0 : k.writable))
      return $.fromWeb(k);
    if (typeof (k == null ? void 0 : k.writable) == "object" || typeof (k == null ? void 0 : k.readable) == "object") {
      const Y = k != null && k.readable ? a(k == null ? void 0 : k.readable) ? k == null ? void 0 : k.readable : W(k.readable) : void 0, te = k != null && k.writable ? l(k == null ? void 0 : k.writable) ? k == null ? void 0 : k.writable : W(k.writable) : void 0;
      return M({
        readable: Y,
        writable: te
      });
    }
    const Z = k == null ? void 0 : k.then;
    if (typeof Z == "function") {
      let Y;
      return G(
        Z,
        k,
        (te) => {
          te != null && Y.push(te), Y.push(null);
        },
        (te) => {
          y(Y, te);
        }
      ), Y = new $({
        objectMode: !0,
        writable: !1,
        read() {
        }
      });
    }
    throw new p(
      U,
      [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise"
      ],
      k
    );
  };
  function V(W) {
    let { promise: k, resolve: U } = E();
    const Z = new J(), Y = Z.signal;
    return {
      value: W(
        async function* () {
          for (; ; ) {
            const se = k;
            k = null;
            const { chunk: fe, done: he, cb: ae } = await se;
            if (e.nextTick(ae), he)
              return;
            if (Y.aborted)
              throw new h(void 0, {
                cause: Y.reason
              });
            ({ promise: k, resolve: U } = E()), yield fe;
          }
        }(),
        {
          signal: Y
        }
      ),
      write(se, fe, he) {
        const ae = U;
        U = null, ae({
          chunk: se,
          done: !1,
          cb: he
        });
      },
      final(se) {
        const fe = U;
        U = null, fe({
          done: !0,
          cb: se
        });
      },
      destroy(se, fe) {
        Z.abort(), fe(se);
      }
    };
  }
  function M(W) {
    const k = W.readable && typeof W.readable.read != "function" ? S.wrap(W.readable) : W.readable, U = W.writable;
    let Z = !!r(k), Y = !!n(U), te, se, fe, he, ae;
    function be(H) {
      const pe = he;
      he = null, pe ? pe(H) : H && ae.destroy(H);
    }
    return ae = new $({
      // TODO (ronag): highWaterMark?
      readableObjectMode: !!(k != null && k.readableObjectMode),
      writableObjectMode: !!(U != null && U.writableObjectMode),
      readable: Z,
      writable: Y
    }), Y && (d(U, (H) => {
      Y = !1, H && y(k, H), be(H);
    }), ae._write = function(H, pe, ke) {
      U.write(H, pe) ? ke() : te = ke;
    }, ae._final = function(H) {
      U.end(), se = H;
    }, U.on("drain", function() {
      if (te) {
        const H = te;
        te = null, H();
      }
    }), U.on("finish", function() {
      if (se) {
        const H = se;
        se = null, H();
      }
    })), Z && (d(k, (H) => {
      Z = !1, H && y(k, H), be(H);
    }), k.on("readable", function() {
      if (fe) {
        const H = fe;
        fe = null, H();
      }
    }), k.on("end", function() {
      ae.push(null);
    }), ae._read = function() {
      for (; ; ) {
        const H = k.read();
        if (H === null) {
          fe = ae._read;
          return;
        }
        if (!ae.push(H))
          return;
      }
    }), ae._destroy = function(H, pe) {
      !H && he !== null && (H = new h()), fe = null, te = null, se = null, he === null ? pe(H) : (he = pe, y(U, H), y(k, H));
    }, ae;
  }
  return Lb;
}
var Ob, r$;
function oo() {
  if (r$)
    return Ob;
  r$ = 1;
  const {
    ObjectDefineProperties: e,
    ObjectGetOwnPropertyDescriptor: t,
    ObjectKeys: r,
    ObjectSetPrototypeOf: n
  } = Ft;
  Ob = a;
  const o = Mp(), s = sx();
  n(a.prototype, o.prototype), n(a, o);
  {
    const c = r(s.prototype);
    for (let d = 0; d < c.length; d++) {
      const h = c[d];
      a.prototype[h] || (a.prototype[h] = s.prototype[h]);
    }
  }
  function a(c) {
    if (!(this instanceof a))
      return new a(c);
    o.call(this, c), s.call(this, c), c ? (this.allowHalfOpen = c.allowHalfOpen !== !1, c.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), c.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0)) : this.allowHalfOpen = !0;
  }
  e(a.prototype, {
    writable: {
      __proto__: null,
      ...t(s.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...t(s.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...t(s.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...t(s.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...t(s.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...t(s.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...t(s.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...t(s.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...t(s.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
      },
      set(c) {
        this._readableState && this._writableState && (this._readableState.destroyed = c, this._writableState.destroyed = c);
      }
    }
  });
  let l;
  function u() {
    return l === void 0 && (l = {}), l;
  }
  a.fromWeb = function(c, d) {
    return u().newStreamDuplexFromReadableWritablePair(c, d);
  }, a.toWeb = function(c) {
    return u().newReadableWritablePairFromDuplex(c);
  };
  let f;
  return a.from = function(c) {
    return f || (f = zJ()), f(c, "body");
  }, Ob;
}
const { ObjectSetPrototypeOf: E5, Symbol: GJ } = Ft;
var x5 = so;
const { ERR_METHOD_NOT_IMPLEMENTED: VJ } = nn.codes, ax = oo(), { getHighWaterMark: KJ } = Ip;
E5(so.prototype, ax.prototype);
E5(so, ax);
const wf = GJ("kCallback");
function so(e) {
  if (!(this instanceof so))
    return new so(e);
  const t = e ? KJ(this, e, "readableHighWaterMark", !0) : null;
  t === 0 && (e = {
    ...e,
    highWaterMark: null,
    readableHighWaterMark: t,
    // TODO (ronag): 0 is not optimal since we have
    // a "bug" where we check needDrain before calling _write and not after.
    // Refs: https://github.com/nodejs/node/pull/32887
    // Refs: https://github.com/nodejs/node/pull/35941
    writableHighWaterMark: e.writableHighWaterMark || 0
  }), ax.call(this, e), this._readableState.sync = !1, this[wf] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", YJ);
}
function X1(e) {
  typeof this._flush == "function" && !this.destroyed ? this._flush((t, r) => {
    if (t) {
      e ? e(t) : this.destroy(t);
      return;
    }
    r != null && this.push(r), this.push(null), e && e();
  }) : (this.push(null), e && e());
}
function YJ() {
  this._final !== X1 && X1.call(this);
}
so.prototype._final = X1;
so.prototype._transform = function(e, t, r) {
  throw new VJ("_transform()");
};
so.prototype._write = function(e, t, r) {
  const n = this._readableState, o = this._writableState, s = n.length;
  this._transform(e, t, (a, l) => {
    if (a) {
      r(a);
      return;
    }
    l != null && this.push(l), o.ended || // Backwards compat.
    s === n.length || // Backwards compat.
    n.length < n.highWaterMark ? r() : this[wf] = r;
  });
};
so.prototype._read = function() {
  if (this[wf]) {
    const e = this[wf];
    this[wf] = null, e();
  }
};
const { ObjectSetPrototypeOf: R5 } = Ft;
var A5 = zl;
const lx = x5;
R5(zl.prototype, lx.prototype);
R5(zl, lx);
function zl(e) {
  if (!(this instanceof zl))
    return new zl(e);
  lx.call(this, e);
}
zl.prototype._transform = function(e, t, r) {
  r(null, e);
};
const Ku = _t, { ArrayIsArray: XJ, Promise: JJ, SymbolAsyncIterator: QJ, SymbolDispose: ZJ } = Ft, ph = ms, { once: eQ } = Ur, tQ = fu, n$ = oo(), {
  aggregateTwoErrors: rQ,
  codes: {
    ERR_INVALID_ARG_TYPE: J1,
    ERR_INVALID_RETURN_VALUE: Pb,
    ERR_MISSING_ARGS: nQ,
    ERR_STREAM_DESTROYED: iQ,
    ERR_STREAM_PREMATURE_CLOSE: oQ
  },
  AbortError: sQ
} = nn, { validateFunction: aQ, validateAbortSignal: lQ } = gc, {
  isIterable: js,
  isReadable: Db,
  isReadableNodeStream: Dd,
  isNodeStream: i$,
  isTransformStream: bl,
  isWebStream: uQ,
  isReadableStream: Fb,
  isReadableFinished: fQ
} = xo, cQ = globalThis.AbortController || Kt().AbortController;
let jb, Bb, qb;
function o$(e, t, r) {
  let n = !1;
  e.on("close", () => {
    n = !0;
  });
  const o = ph(
    e,
    {
      readable: t,
      writable: r
    },
    (s) => {
      n = !s;
    }
  );
  return {
    destroy: (s) => {
      n || (n = !0, tQ.destroyer(e, s || new iQ("pipe")));
    },
    cleanup: o
  };
}
function dQ(e) {
  return aQ(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
}
function Wb(e) {
  if (js(e))
    return e;
  if (Dd(e))
    return hQ(e);
  throw new J1("val", ["Readable", "Iterable", "AsyncIterable"], e);
}
async function* hQ(e) {
  Bb || (Bb = Mp()), yield* Bb.prototype[QJ].call(e);
}
async function Xc(e, t, r, { end: n }) {
  let o, s = null;
  const a = (f) => {
    if (f && (o = f), s) {
      const c = s;
      s = null, c();
    }
  }, l = () => new JJ((f, c) => {
    o ? c(o) : s = () => {
      o ? c(o) : f();
    };
  });
  t.on("drain", a);
  const u = ph(
    t,
    {
      readable: !1
    },
    a
  );
  try {
    t.writableNeedDrain && await l();
    for await (const f of e)
      t.write(f) || await l();
    n && (t.end(), await l()), r();
  } catch (f) {
    r(o !== f ? rQ(o, f) : f);
  } finally {
    u(), t.off("drain", a);
  }
}
async function Ub(e, t, r, { end: n }) {
  bl(t) && (t = t.writable);
  const o = t.getWriter();
  try {
    for await (const s of e)
      await o.ready, o.write(s).catch(() => {
      });
    await o.ready, n && await o.close(), r();
  } catch (s) {
    try {
      await o.abort(s), r(s);
    } catch (a) {
      r(a);
    }
  }
}
function pQ(...e) {
  return T5(e, eQ(dQ(e)));
}
function T5(e, t, r) {
  if (e.length === 1 && XJ(e[0]) && (e = e[0]), e.length < 2)
    throw new nQ("streams");
  const n = new cQ(), o = n.signal, s = r == null ? void 0 : r.signal, a = [];
  lQ(s, "options.signal");
  function l() {
    m(new sQ());
  }
  qb = qb || Ur.addAbortListener;
  let u;
  s && (u = qb(s, l));
  let f, c;
  const d = [];
  let h = 0;
  function p(x) {
    m(x, --h === 0);
  }
  function m(x, E) {
    var C;
    if (x && (!f || f.code === "ERR_STREAM_PREMATURE_CLOSE") && (f = x), !(!f && !E)) {
      for (; d.length; )
        d.shift()(f);
      (C = u) === null || C === void 0 || C[ZJ](), n.abort(), E && (f || a.forEach((I) => I()), Ku.nextTick(t, f, c));
    }
  }
  let y;
  for (let x = 0; x < e.length; x++) {
    const E = e[x], C = x < e.length - 1, I = x > 0, j = C || (r == null ? void 0 : r.end) !== !1, J = x === e.length - 1;
    if (i$(E)) {
      let G = function($) {
        $ && $.name !== "AbortError" && $.code !== "ERR_STREAM_PREMATURE_CLOSE" && p($);
      };
      if (j) {
        const { destroy: $, cleanup: V } = o$(E, C, I);
        d.push($), Db(E) && J && a.push(V);
      }
      E.on("error", G), Db(E) && J && a.push(() => {
        E.removeListener("error", G);
      });
    }
    if (x === 0)
      if (typeof E == "function") {
        if (y = E({
          signal: o
        }), !js(y))
          throw new Pb("Iterable, AsyncIterable or Stream", "source", y);
      } else
        js(E) || Dd(E) || bl(E) ? y = E : y = n$.from(E);
    else if (typeof E == "function") {
      if (bl(y)) {
        var _;
        y = Wb((_ = y) === null || _ === void 0 ? void 0 : _.readable);
      } else
        y = Wb(y);
      if (y = E(y, {
        signal: o
      }), C) {
        if (!js(y, !0))
          throw new Pb("AsyncIterable", `transform[${x - 1}]`, y);
      } else {
        var S;
        jb || (jb = A5);
        const G = new jb({
          objectMode: !0
        }), $ = (S = y) === null || S === void 0 ? void 0 : S.then;
        if (typeof $ == "function")
          h++, $.call(
            y,
            (W) => {
              c = W, W != null && G.write(W), j && G.end(), Ku.nextTick(p);
            },
            (W) => {
              G.destroy(W), Ku.nextTick(p, W);
            }
          );
        else if (js(y, !0))
          h++, Xc(y, G, p, {
            end: j
          });
        else if (Fb(y) || bl(y)) {
          const W = y.readable || y;
          h++, Xc(W, G, p, {
            end: j
          });
        } else
          throw new Pb("AsyncIterable or Promise", "destination", y);
        y = G;
        const { destroy: V, cleanup: M } = o$(y, !1, !0);
        d.push(V), J && a.push(M);
      }
    } else if (i$(E)) {
      if (Dd(y)) {
        h += 2;
        const G = gQ(y, E, p, {
          end: j
        });
        Db(E) && J && a.push(G);
      } else if (bl(y) || Fb(y)) {
        const G = y.readable || y;
        h++, Xc(G, E, p, {
          end: j
        });
      } else if (js(y))
        h++, Xc(y, E, p, {
          end: j
        });
      else
        throw new J1(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          y
        );
      y = E;
    } else if (uQ(E)) {
      if (Dd(y))
        h++, Ub(Wb(y), E, p, {
          end: j
        });
      else if (Fb(y) || js(y))
        h++, Ub(y, E, p, {
          end: j
        });
      else if (bl(y))
        h++, Ub(y.readable, E, p, {
          end: j
        });
      else
        throw new J1(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          y
        );
      y = E;
    } else
      y = n$.from(E);
  }
  return (o != null && o.aborted || s != null && s.aborted) && Ku.nextTick(l), y;
}
function gQ(e, t, r, { end: n }) {
  let o = !1;
  if (t.on("close", () => {
    o || r(new oQ());
  }), e.pipe(t, {
    end: !1
  }), n) {
    let s = function() {
      o = !0, t.end();
    };
    fQ(e) ? Ku.nextTick(s) : e.once("end", s);
  } else
    r();
  return ph(
    e,
    {
      readable: !0,
      writable: !1
    },
    (s) => {
      const a = e._readableState;
      s && s.code === "ERR_STREAM_PREMATURE_CLOSE" && a && a.ended && !a.errored && !a.errorEmitted ? e.once("end", r).once("error", r) : r(s);
    }
  ), ph(
    t,
    {
      readable: !1,
      writable: !0
    },
    r
  );
}
var ux = {
  pipelineImpl: T5,
  pipeline: pQ
};
const { pipeline: bQ } = ux, Jc = oo(), { destroyer: yQ } = fu, {
  isNodeStream: Qc,
  isReadable: s$,
  isWritable: a$,
  isWebStream: Hb,
  isTransformStream: Ms,
  isWritableStream: l$,
  isReadableStream: u$
} = xo, {
  AbortError: mQ,
  codes: { ERR_INVALID_ARG_VALUE: f$, ERR_MISSING_ARGS: vQ }
} = nn, wQ = ms;
var $5 = function(...t) {
  if (t.length === 0)
    throw new vQ("streams");
  if (t.length === 1)
    return Jc.from(t[0]);
  const r = [...t];
  if (typeof t[0] == "function" && (t[0] = Jc.from(t[0])), typeof t[t.length - 1] == "function") {
    const p = t.length - 1;
    t[p] = Jc.from(t[p]);
  }
  for (let p = 0; p < t.length; ++p)
    if (!(!Qc(t[p]) && !Hb(t[p]))) {
      if (p < t.length - 1 && !(s$(t[p]) || u$(t[p]) || Ms(t[p])))
        throw new f$(`streams[${p}]`, r[p], "must be readable");
      if (p > 0 && !(a$(t[p]) || l$(t[p]) || Ms(t[p])))
        throw new f$(`streams[${p}]`, r[p], "must be writable");
    }
  let n, o, s, a, l;
  function u(p) {
    const m = a;
    a = null, m ? m(p) : p ? l.destroy(p) : !h && !d && l.destroy();
  }
  const f = t[0], c = bQ(t, u), d = !!(a$(f) || l$(f) || Ms(f)), h = !!(s$(c) || u$(c) || Ms(c));
  if (l = new Jc({
    // TODO (ronag): highWaterMark?
    writableObjectMode: !!(f != null && f.writableObjectMode),
    readableObjectMode: !!(c != null && c.readableObjectMode),
    writable: d,
    readable: h
  }), d) {
    if (Qc(f))
      l._write = function(m, y, _) {
        f.write(m, y) ? _() : n = _;
      }, l._final = function(m) {
        f.end(), o = m;
      }, f.on("drain", function() {
        if (n) {
          const m = n;
          n = null, m();
        }
      });
    else if (Hb(f)) {
      const y = (Ms(f) ? f.writable : f).getWriter();
      l._write = async function(_, S, x) {
        try {
          await y.ready, y.write(_).catch(() => {
          }), x();
        } catch (E) {
          x(E);
        }
      }, l._final = async function(_) {
        try {
          await y.ready, y.close().catch(() => {
          }), o = _;
        } catch (S) {
          _(S);
        }
      };
    }
    const p = Ms(c) ? c.readable : c;
    wQ(p, () => {
      if (o) {
        const m = o;
        o = null, m();
      }
    });
  }
  if (h) {
    if (Qc(c))
      c.on("readable", function() {
        if (s) {
          const p = s;
          s = null, p();
        }
      }), c.on("end", function() {
        l.push(null);
      }), l._read = function() {
        for (; ; ) {
          const p = c.read();
          if (p === null) {
            s = l._read;
            return;
          }
          if (!l.push(p))
            return;
        }
      };
    else if (Hb(c)) {
      const m = (Ms(c) ? c.readable : c).getReader();
      l._read = async function() {
        for (; ; )
          try {
            const { value: y, done: _ } = await m.read();
            if (!l.push(y))
              return;
            if (_) {
              l.push(null);
              return;
            }
          } catch {
            return;
          }
      };
    }
  }
  return l._destroy = function(p, m) {
    !p && a !== null && (p = new mQ()), s = null, n = null, o = null, a === null ? m(p) : (a = m, Qc(c) && yQ(c, p));
  }, l;
};
const _Q = globalThis.AbortController || Kt().AbortController, {
  codes: { ERR_INVALID_ARG_VALUE: SQ, ERR_INVALID_ARG_TYPE: bc, ERR_MISSING_ARGS: EQ, ERR_OUT_OF_RANGE: xQ },
  AbortError: Ti
} = nn, { validateAbortSignal: Ba, validateInteger: c$, validateObject: qa } = gc, RQ = Ft.Symbol("kWeak"), AQ = Ft.Symbol("kResistStopPropagation"), { finished: TQ } = ms, $Q = $5, { addAbortSignalNoValidate: CQ } = kp, { isWritable: kQ, isNodeStream: IQ } = xo, { deprecate: MQ } = Ur, {
  ArrayPrototypePush: NQ,
  Boolean: LQ,
  MathFloor: d$,
  Number: OQ,
  NumberIsNaN: PQ,
  Promise: h$,
  PromiseReject: p$,
  PromiseResolve: DQ,
  PromisePrototypeThen: g$,
  Symbol: C5
} = Ft, gh = C5("kEmpty"), b$ = C5("kEof");
function FQ(e, t) {
  if (t != null && qa(t, "options"), (t == null ? void 0 : t.signal) != null && Ba(t.signal, "options.signal"), IQ(e) && !kQ(e))
    throw new SQ("stream", e, "must be writable");
  const r = $Q(this, e);
  return t != null && t.signal && CQ(t.signal, r), r;
}
function Np(e, t) {
  if (typeof e != "function")
    throw new bc("fn", ["Function", "AsyncFunction"], e);
  t != null && qa(t, "options"), (t == null ? void 0 : t.signal) != null && Ba(t.signal, "options.signal");
  let r = 1;
  (t == null ? void 0 : t.concurrency) != null && (r = d$(t.concurrency));
  let n = r - 1;
  return (t == null ? void 0 : t.highWaterMark) != null && (n = d$(t.highWaterMark)), c$(r, "options.concurrency", 1), c$(n, "options.highWaterMark", 0), n += r, (async function* () {
    const s = Ur.AbortSignalAny(
      [t == null ? void 0 : t.signal].filter(LQ)
    ), a = this, l = [], u = {
      signal: s
    };
    let f, c, d = !1, h = 0;
    function p() {
      d = !0, m();
    }
    function m() {
      h -= 1, y();
    }
    function y() {
      c && !d && h < r && l.length < n && (c(), c = null);
    }
    async function _() {
      try {
        for await (let S of a) {
          if (d)
            return;
          if (s.aborted)
            throw new Ti();
          try {
            if (S = e(S, u), S === gh)
              continue;
            S = DQ(S);
          } catch (x) {
            S = p$(x);
          }
          h += 1, g$(S, m, p), l.push(S), f && (f(), f = null), !d && (l.length >= n || h >= r) && await new h$((x) => {
            c = x;
          });
        }
        l.push(b$);
      } catch (S) {
        const x = p$(S);
        g$(x, m, p), l.push(x);
      } finally {
        d = !0, f && (f(), f = null);
      }
    }
    _();
    try {
      for (; ; ) {
        for (; l.length > 0; ) {
          const S = await l[0];
          if (S === b$)
            return;
          if (s.aborted)
            throw new Ti();
          S !== gh && (yield S), l.shift(), y();
        }
        await new h$((S) => {
          f = S;
        });
      }
    } finally {
      d = !0, c && (c(), c = null);
    }
  }).call(this);
}
function jQ(e = void 0) {
  return e != null && qa(e, "options"), (e == null ? void 0 : e.signal) != null && Ba(e.signal, "options.signal"), (async function* () {
    let r = 0;
    for await (const o of this) {
      var n;
      if (e != null && (n = e.signal) !== null && n !== void 0 && n.aborted)
        throw new Ti({
          cause: e.signal.reason
        });
      yield [r++, o];
    }
  }).call(this);
}
async function k5(e, t = void 0) {
  for await (const r of fx.call(this, e, t))
    return !0;
  return !1;
}
async function BQ(e, t = void 0) {
  if (typeof e != "function")
    throw new bc("fn", ["Function", "AsyncFunction"], e);
  return !await k5.call(
    this,
    async (...r) => !await e(...r),
    t
  );
}
async function qQ(e, t) {
  for await (const r of fx.call(this, e, t))
    return r;
}
async function WQ(e, t) {
  if (typeof e != "function")
    throw new bc("fn", ["Function", "AsyncFunction"], e);
  async function r(n, o) {
    return await e(n, o), gh;
  }
  for await (const n of Np.call(this, r, t))
    ;
}
function fx(e, t) {
  if (typeof e != "function")
    throw new bc("fn", ["Function", "AsyncFunction"], e);
  async function r(n, o) {
    return await e(n, o) ? n : gh;
  }
  return Np.call(this, r, t);
}
let UQ = class extends EQ {
  constructor() {
    super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
  }
};
async function HQ(e, t, r) {
  var n;
  if (typeof e != "function")
    throw new bc("reducer", ["Function", "AsyncFunction"], e);
  r != null && qa(r, "options"), (r == null ? void 0 : r.signal) != null && Ba(r.signal, "options.signal");
  let o = arguments.length > 1;
  if (r != null && (n = r.signal) !== null && n !== void 0 && n.aborted) {
    const f = new Ti(void 0, {
      cause: r.signal.reason
    });
    throw this.once("error", () => {
    }), await TQ(this.destroy(f)), f;
  }
  const s = new _Q(), a = s.signal;
  if (r != null && r.signal) {
    const f = {
      once: !0,
      [RQ]: this,
      [AQ]: !0
    };
    r.signal.addEventListener("abort", () => s.abort(), f);
  }
  let l = !1;
  try {
    for await (const f of this) {
      var u;
      if (l = !0, r != null && (u = r.signal) !== null && u !== void 0 && u.aborted)
        throw new Ti();
      o ? t = await e(t, f, {
        signal: a
      }) : (t = f, o = !0);
    }
    if (!l && !o)
      throw new UQ();
  } finally {
    s.abort();
  }
  return t;
}
async function zQ(e) {
  e != null && qa(e, "options"), (e == null ? void 0 : e.signal) != null && Ba(e.signal, "options.signal");
  const t = [];
  for await (const n of this) {
    var r;
    if (e != null && (r = e.signal) !== null && r !== void 0 && r.aborted)
      throw new Ti(void 0, {
        cause: e.signal.reason
      });
    NQ(t, n);
  }
  return t;
}
function GQ(e, t) {
  const r = Np.call(this, e, t);
  return (async function* () {
    for await (const o of r)
      yield* o;
  }).call(this);
}
function I5(e) {
  if (e = OQ(e), PQ(e))
    return 0;
  if (e < 0)
    throw new xQ("number", ">= 0", e);
  return e;
}
function VQ(e, t = void 0) {
  return t != null && qa(t, "options"), (t == null ? void 0 : t.signal) != null && Ba(t.signal, "options.signal"), e = I5(e), (async function* () {
    var n;
    if (t != null && (n = t.signal) !== null && n !== void 0 && n.aborted)
      throw new Ti();
    for await (const s of this) {
      var o;
      if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
        throw new Ti();
      e-- <= 0 && (yield s);
    }
  }).call(this);
}
function KQ(e, t = void 0) {
  return t != null && qa(t, "options"), (t == null ? void 0 : t.signal) != null && Ba(t.signal, "options.signal"), e = I5(e), (async function* () {
    var n;
    if (t != null && (n = t.signal) !== null && n !== void 0 && n.aborted)
      throw new Ti();
    for await (const s of this) {
      var o;
      if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
        throw new Ti();
      if (e-- > 0 && (yield s), e <= 0)
        return;
    }
  }).call(this);
}
ex.streamReturningOperators = {
  asIndexedPairs: MQ(jQ, "readable.asIndexedPairs will be removed in a future version."),
  drop: VQ,
  filter: fx,
  flatMap: GQ,
  map: Np,
  take: KQ,
  compose: FQ
};
ex.promiseReturningOperators = {
  every: BQ,
  forEach: WQ,
  reduce: HQ,
  toArray: zQ,
  some: k5,
  find: qQ
};
var zb, y$;
function M5() {
  if (y$)
    return zb;
  y$ = 1;
  const { ArrayPrototypePop: e, Promise: t } = Ft, { isIterable: r, isNodeStream: n, isWebStream: o } = xo, { pipelineImpl: s } = ux, { finished: a } = ms;
  N5();
  function l(...u) {
    return new t((f, c) => {
      let d, h;
      const p = u[u.length - 1];
      if (p && typeof p == "object" && !n(p) && !r(p) && !o(p)) {
        const m = e(u);
        d = m.signal, h = m.end;
      }
      s(
        u,
        (m, y) => {
          m ? c(m) : f(y);
        },
        {
          signal: d,
          end: h
        }
      );
    });
  }
  return zb = {
    finished: a,
    pipeline: l
  }, zb;
}
var m$;
function N5() {
  if (m$)
    return Tb.exports;
  m$ = 1;
  const { Buffer: e } = ut, { ObjectDefineProperty: t, ObjectKeys: r, ReflectApply: n } = Ft, {
    promisify: { custom: o }
  } = Ur, { streamReturningOperators: s, promiseReturningOperators: a } = ex, {
    codes: { ERR_ILLEGAL_CONSTRUCTOR: l }
  } = nn, u = $5, { setDefaultHighWaterMark: f, getDefaultHighWaterMark: c } = Ip, { pipeline: d } = ux, { destroyer: h } = fu, p = ms, m = M5(), y = xo, _ = Tb.exports = ox.Stream;
  _.isDestroyed = y.isDestroyed, _.isDisturbed = y.isDisturbed, _.isErrored = y.isErrored, _.isReadable = y.isReadable, _.isWritable = y.isWritable, _.Readable = Mp();
  for (const x of r(s)) {
    let C = function(...I) {
      if (new.target)
        throw l();
      return _.Readable.from(n(E, this, I));
    };
    const E = s[x];
    t(C, "name", {
      __proto__: null,
      value: E.name
    }), t(C, "length", {
      __proto__: null,
      value: E.length
    }), t(_.Readable.prototype, x, {
      __proto__: null,
      value: C,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  for (const x of r(a)) {
    let C = function(...I) {
      if (new.target)
        throw l();
      return n(E, this, I);
    };
    const E = a[x];
    t(C, "name", {
      __proto__: null,
      value: E.name
    }), t(C, "length", {
      __proto__: null,
      value: E.length
    }), t(_.Readable.prototype, x, {
      __proto__: null,
      value: C,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  _.Writable = sx(), _.Duplex = oo(), _.Transform = x5, _.PassThrough = A5, _.pipeline = d;
  const { addAbortSignal: S } = kp;
  return _.addAbortSignal = S, _.finished = p, _.destroy = h, _.compose = u, _.setDefaultHighWaterMark = f, _.getDefaultHighWaterMark = c, t(_, "promises", {
    __proto__: null,
    configurable: !0,
    enumerable: !0,
    get() {
      return m;
    }
  }), t(d, o, {
    __proto__: null,
    enumerable: !0,
    get() {
      return m.pipeline;
    }
  }), t(p, o, {
    __proto__: null,
    enumerable: !0,
    get() {
      return m.finished;
    }
  }), _.Stream = _, _._isUint8Array = function(E) {
    return E instanceof Uint8Array;
  }, _._uint8ArrayToBuffer = function(E) {
    return e.from(E.buffer, E.byteOffset, E.byteLength);
  }, Tb.exports;
}
(function(e) {
  const t = N5(), r = M5(), n = t.Readable.destroy;
  e.exports = t.Readable, e.exports._uint8ArrayToBuffer = t._uint8ArrayToBuffer, e.exports._isUint8Array = t._isUint8Array, e.exports.isDisturbed = t.isDisturbed, e.exports.isErrored = t.isErrored, e.exports.isReadable = t.isReadable, e.exports.Readable = t.Readable, e.exports.Writable = t.Writable, e.exports.Duplex = t.Duplex, e.exports.Transform = t.Transform, e.exports.PassThrough = t.PassThrough, e.exports.addAbortSignal = t.addAbortSignal, e.exports.finished = t.finished, e.exports.destroy = t.destroy, e.exports.destroy = n, e.exports.pipeline = t.pipeline, e.exports.compose = t.compose, Object.defineProperty(t, "promises", {
    configurable: !0,
    enumerable: !0,
    get() {
      return r;
    }
  }), e.exports.Stream = t.Stream, e.exports.default = e.exports;
})(ID);
var YQ = ID.exports;
class XQ extends YQ.Transform {
  constructor(t) {
    super({ decodeStrings: !0 }), this._readableState.objectMode = !0;
    const r = new CD(t);
    let n, o;
    r.parse(
      {
        on: (s, a) => {
          switch (s) {
            case "data":
              n = a;
              break;
            case "end":
              o = a;
              break;
          }
        }
      },
      // Handle quads by pushing them down the pipeline
      (s, a) => {
        s && this.emit("error", s) || a && this.push(a);
      },
      // Emit prefixes through the `prefix` event
      (s, a) => {
        this.emit("prefix", s, a);
      }
    ), this._transform = (s, a, l) => {
      n(s), l();
    }, this._flush = (s) => {
      o(), s();
    };
  }
  // ### Parses a stream of strings
  import(t) {
    return t.on("data", (r) => {
      this.write(r);
    }), t.on("end", () => {
      this.end();
    }), t.on("error", (r) => {
      this.emit("error", r);
    }), this;
  }
}
class JQ {
  constructor(t, { baseIRI: r = "", factory: n = gD, ...o } = {}) {
    const s = {
      blankNode: n.blankNode.bind(n),
      defaultGraph: n.defaultGraph.bind(n),
      literal: n.literal.bind(n),
      namedNode: n.namedNode.bind(n),
      quad: n.quad.bind(n)
    }, a = new XQ({ baseIRI: r, factory: s, ...o });
    return t.pipe(a), AD(a);
  }
}
let L5 = class extends iY {
  constructor(t) {
    super(JQ, t);
  }
};
const QQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: L5
}, Symbol.toStringTag, { value: "Module" }));
var O5 = { exports: {} }, Gb = { exports: {} }, jt = {
  ArrayIsArray(e) {
    return Array.isArray(e);
  },
  ArrayPrototypeIncludes(e, t) {
    return e.includes(t);
  },
  ArrayPrototypeIndexOf(e, t) {
    return e.indexOf(t);
  },
  ArrayPrototypeJoin(e, t) {
    return e.join(t);
  },
  ArrayPrototypeMap(e, t) {
    return e.map(t);
  },
  ArrayPrototypePop(e, t) {
    return e.pop(t);
  },
  ArrayPrototypePush(e, t) {
    return e.push(t);
  },
  ArrayPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  Error,
  FunctionPrototypeCall(e, t, ...r) {
    return e.call(t, ...r);
  },
  FunctionPrototypeSymbolHasInstance(e, t) {
    return Function.prototype[Symbol.hasInstance].call(e, t);
  },
  MathFloor: Math.floor,
  Number,
  NumberIsInteger: Number.isInteger,
  NumberIsNaN: Number.isNaN,
  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
  NumberParseInt: Number.parseInt,
  ObjectDefineProperties(e, t) {
    return Object.defineProperties(e, t);
  },
  ObjectDefineProperty(e, t, r) {
    return Object.defineProperty(e, t, r);
  },
  ObjectGetOwnPropertyDescriptor(e, t) {
    return Object.getOwnPropertyDescriptor(e, t);
  },
  ObjectKeys(e) {
    return Object.keys(e);
  },
  ObjectSetPrototypeOf(e, t) {
    return Object.setPrototypeOf(e, t);
  },
  Promise,
  PromisePrototypeCatch(e, t) {
    return e.catch(t);
  },
  PromisePrototypeThen(e, t, r) {
    return e.then(t, r);
  },
  PromiseReject(e) {
    return Promise.reject(e);
  },
  PromiseResolve(e) {
    return Promise.resolve(e);
  },
  ReflectApply: Reflect.apply,
  RegExpPrototypeTest(e, t) {
    return e.test(t);
  },
  SafeSet: Set,
  String,
  StringPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  StringPrototypeToLowerCase(e) {
    return e.toLowerCase();
  },
  StringPrototypeToUpperCase(e) {
    return e.toUpperCase();
  },
  StringPrototypeTrim(e) {
    return e.trim();
  },
  Symbol,
  SymbolFor: Symbol.for,
  SymbolAsyncIterator: Symbol.asyncIterator,
  SymbolHasInstance: Symbol.hasInstance,
  SymbolIterator: Symbol.iterator,
  SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
  SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
  TypedArrayPrototypeSet(e, t, r) {
    return e.set(t, r);
  },
  Boolean,
  Uint8Array
}, P5 = { exports: {} };
(function(e) {
  const t = ut, { kResistStopPropagation: r, SymbolDispose: n } = jt, o = globalThis.AbortSignal || Kt().AbortSignal, s = globalThis.AbortController || Kt().AbortController, a = Object.getPrototypeOf(async function() {
  }).constructor, l = globalThis.Blob || t.Blob, u = typeof l < "u" ? function(p) {
    return p instanceof l;
  } : function(p) {
    return !1;
  }, f = (h, p) => {
    if (h !== void 0 && (h === null || typeof h != "object" || !("aborted" in h)))
      throw new ERR_INVALID_ARG_TYPE(p, "AbortSignal", h);
  }, c = (h, p) => {
    if (typeof h != "function")
      throw new ERR_INVALID_ARG_TYPE(p, "Function", h);
  };
  class d extends Error {
    constructor(p) {
      if (!Array.isArray(p))
        throw new TypeError(`Expected input to be an Array, got ${typeof p}`);
      let m = "";
      for (let y = 0; y < p.length; y++)
        m += `    ${p[y].stack}
`;
      super(m), this.name = "AggregateError", this.errors = p;
    }
  }
  e.exports = {
    AggregateError: d,
    kEmptyObject: Object.freeze({}),
    once(h) {
      let p = !1;
      return function(...m) {
        p || (p = !0, h.apply(this, m));
      };
    },
    createDeferredPromise: function() {
      let h, p;
      return {
        promise: new Promise((y, _) => {
          h = y, p = _;
        }),
        resolve: h,
        reject: p
      };
    },
    promisify(h) {
      return new Promise((p, m) => {
        h((y, ..._) => y ? m(y) : p(..._));
      });
    },
    debuglog() {
      return function() {
      };
    },
    format(h, ...p) {
      return h.replace(/%([sdifj])/g, function(...[m, y]) {
        const _ = p.shift();
        return y === "f" ? _.toFixed(6) : y === "j" ? JSON.stringify(_) : y === "s" && typeof _ == "object" ? `${_.constructor !== Object ? _.constructor.name : ""} {}`.trim() : _.toString();
      });
    },
    inspect(h) {
      switch (typeof h) {
        case "string":
          if (h.includes("'"))
            if (h.includes('"')) {
              if (!h.includes("`") && !h.includes("${"))
                return `\`${h}\``;
            } else
              return `"${h}"`;
          return `'${h}'`;
        case "number":
          return isNaN(h) ? "NaN" : Object.is(h, -0) ? String(h) : h;
        case "bigint":
          return `${String(h)}n`;
        case "boolean":
        case "undefined":
          return String(h);
        case "object":
          return "{}";
      }
    },
    types: {
      isAsyncFunction(h) {
        return h instanceof a;
      },
      isArrayBufferView(h) {
        return ArrayBuffer.isView(h);
      }
    },
    isBlob: u,
    deprecate(h, p) {
      return h;
    },
    addAbortListener: ur.addAbortListener || function(p, m) {
      if (p === void 0)
        throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", p);
      f(p, "signal"), c(m, "listener");
      let y;
      return p.aborted ? queueMicrotask(() => m()) : (p.addEventListener("abort", m, {
        __proto__: null,
        once: !0,
        [r]: !0
      }), y = () => {
        p.removeEventListener("abort", m);
      }), {
        __proto__: null,
        [n]() {
          var _;
          (_ = y) === null || _ === void 0 || _();
        }
      };
    },
    AbortSignalAny: o.any || function(p) {
      if (p.length === 1)
        return p[0];
      const m = new s(), y = () => m.abort();
      return p.forEach((_) => {
        f(_, "signals"), _.addEventListener("abort", y, {
          once: !0
        });
      }), m.signal.addEventListener(
        "abort",
        () => {
          p.forEach((_) => _.removeEventListener("abort", y));
        },
        {
          once: !0
        }
      ), m.signal;
    }
  }, e.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
})(P5);
var Hr = P5.exports, cx = {};
const { format: ZQ, inspect: bh, AggregateError: eZ } = Hr, tZ = globalThis.AggregateError || eZ, rZ = Symbol("kIsNodeError"), nZ = [
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
], iZ = /^([A-Z][a-z0-9]*)+$/, oZ = "__node_internal_", Lp = {};
function fa(e, t) {
  if (!e)
    throw new Lp.ERR_INTERNAL_ASSERTION(t);
}
function v$(e) {
  let t = "", r = e.length;
  const n = e[0] === "-" ? 1 : 0;
  for (; r >= n + 4; r -= 3)
    t = `_${e.slice(r - 3, r)}${t}`;
  return `${e.slice(0, r)}${t}`;
}
function sZ(e, t, r) {
  if (typeof t == "function")
    return fa(
      t.length <= r.length,
      // Default options do not count.
      `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${t.length}).`
    ), t(...r);
  const n = (t.match(/%[dfijoOs]/g) || []).length;
  return fa(
    n === r.length,
    `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${n}).`
  ), r.length === 0 ? t : ZQ(t, ...r);
}
function wr(e, t, r) {
  r || (r = Error);
  class n extends r {
    constructor(...s) {
      super(sZ(e, t, s));
    }
    toString() {
      return `${this.name} [${e}]: ${this.message}`;
    }
  }
  Object.defineProperties(n.prototype, {
    name: {
      value: r.name,
      writable: !0,
      enumerable: !1,
      configurable: !0
    },
    toString: {
      value() {
        return `${this.name} [${e}]: ${this.message}`;
      },
      writable: !0,
      enumerable: !1,
      configurable: !0
    }
  }), n.prototype.code = e, n.prototype[rZ] = !0, Lp[e] = n;
}
function w$(e) {
  const t = oZ + e.name;
  return Object.defineProperty(e, "name", {
    value: t
  }), e;
}
function aZ(e, t) {
  if (e && t && e !== t) {
    if (Array.isArray(t.errors))
      return t.errors.push(e), t;
    const r = new tZ([t, e], t.message);
    return r.code = t.code, r;
  }
  return e || t;
}
let lZ = class extends Error {
  constructor(t = "The operation was aborted", r = void 0) {
    if (r !== void 0 && typeof r != "object")
      throw new Lp.ERR_INVALID_ARG_TYPE("options", "Object", r);
    super(t, r), this.code = "ABORT_ERR", this.name = "AbortError";
  }
};
wr("ERR_ASSERTION", "%s", Error);
wr(
  "ERR_INVALID_ARG_TYPE",
  (e, t, r) => {
    fa(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
    let n = "The ";
    e.endsWith(" argument") ? n += `${e} ` : n += `"${e}" ${e.includes(".") ? "property" : "argument"} `, n += "must be ";
    const o = [], s = [], a = [];
    for (const u of t)
      fa(typeof u == "string", "All expected entries have to be of type string"), nZ.includes(u) ? o.push(u.toLowerCase()) : iZ.test(u) ? s.push(u) : (fa(u !== "object", 'The value "object" should be written as "Object"'), a.push(u));
    if (s.length > 0) {
      const u = o.indexOf("object");
      u !== -1 && (o.splice(o, u, 1), s.push("Object"));
    }
    if (o.length > 0) {
      switch (o.length) {
        case 1:
          n += `of type ${o[0]}`;
          break;
        case 2:
          n += `one of type ${o[0]} or ${o[1]}`;
          break;
        default: {
          const u = o.pop();
          n += `one of type ${o.join(", ")}, or ${u}`;
        }
      }
      (s.length > 0 || a.length > 0) && (n += " or ");
    }
    if (s.length > 0) {
      switch (s.length) {
        case 1:
          n += `an instance of ${s[0]}`;
          break;
        case 2:
          n += `an instance of ${s[0]} or ${s[1]}`;
          break;
        default: {
          const u = s.pop();
          n += `an instance of ${s.join(", ")}, or ${u}`;
        }
      }
      a.length > 0 && (n += " or ");
    }
    switch (a.length) {
      case 0:
        break;
      case 1:
        a[0].toLowerCase() !== a[0] && (n += "an "), n += `${a[0]}`;
        break;
      case 2:
        n += `one of ${a[0]} or ${a[1]}`;
        break;
      default: {
        const u = a.pop();
        n += `one of ${a.join(", ")}, or ${u}`;
      }
    }
    if (r == null)
      n += `. Received ${r}`;
    else if (typeof r == "function" && r.name)
      n += `. Received function ${r.name}`;
    else if (typeof r == "object") {
      var l;
      if ((l = r.constructor) !== null && l !== void 0 && l.name)
        n += `. Received an instance of ${r.constructor.name}`;
      else {
        const u = bh(r, {
          depth: -1
        });
        n += `. Received ${u}`;
      }
    } else {
      let u = bh(r, {
        colors: !1
      });
      u.length > 25 && (u = `${u.slice(0, 25)}...`), n += `. Received type ${typeof r} (${u})`;
    }
    return n;
  },
  TypeError
);
wr(
  "ERR_INVALID_ARG_VALUE",
  (e, t, r = "is invalid") => {
    let n = bh(t);
    return n.length > 128 && (n = n.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${n}`;
  },
  TypeError
);
wr(
  "ERR_INVALID_RETURN_VALUE",
  (e, t, r) => {
    var n;
    const o = r != null && (n = r.constructor) !== null && n !== void 0 && n.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
    return `Expected ${e} to be returned from the "${t}" function but got ${o}.`;
  },
  TypeError
);
wr(
  "ERR_MISSING_ARGS",
  (...e) => {
    fa(e.length > 0, "At least one arg needs to be specified");
    let t;
    const r = e.length;
    switch (e = (Array.isArray(e) ? e : [e]).map((n) => `"${n}"`).join(" or "), r) {
      case 1:
        t += `The ${e[0]} argument`;
        break;
      case 2:
        t += `The ${e[0]} and ${e[1]} arguments`;
        break;
      default:
        {
          const n = e.pop();
          t += `The ${e.join(", ")}, and ${n} arguments`;
        }
        break;
    }
    return `${t} must be specified`;
  },
  TypeError
);
wr(
  "ERR_OUT_OF_RANGE",
  (e, t, r) => {
    fa(t, 'Missing "range" argument');
    let n;
    return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? n = v$(String(r)) : typeof r == "bigint" ? (n = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (n = v$(n)), n += "n") : n = bh(r), `The value of "${e}" is out of range. It must be ${t}. Received ${n}`;
  },
  RangeError
);
wr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
wr("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
wr("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
wr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
wr("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
wr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
wr("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
wr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
wr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
wr("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
wr("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
var on = {
  AbortError: lZ,
  aggregateTwoErrors: w$(aZ),
  hideStackFrames: w$,
  codes: Lp
};
const {
  ArrayIsArray: dx,
  ArrayPrototypeIncludes: D5,
  ArrayPrototypeJoin: F5,
  ArrayPrototypeMap: uZ,
  NumberIsInteger: hx,
  NumberIsNaN: fZ,
  NumberMAX_SAFE_INTEGER: cZ,
  NumberMIN_SAFE_INTEGER: dZ,
  NumberParseInt: hZ,
  ObjectPrototypeHasOwnProperty: pZ,
  RegExpPrototypeExec: j5,
  String: gZ,
  StringPrototypeToUpperCase: bZ,
  StringPrototypeTrim: yZ
} = jt, {
  hideStackFrames: kn,
  codes: { ERR_SOCKET_BAD_PORT: mZ, ERR_INVALID_ARG_TYPE: Ir, ERR_INVALID_ARG_VALUE: cu, ERR_OUT_OF_RANGE: Ra, ERR_UNKNOWN_SIGNAL: _$ }
} = on, { normalizeEncoding: vZ } = Hr, { isAsyncFunction: wZ, isArrayBufferView: _Z } = Hr.types, S$ = {};
function SZ(e) {
  return e === (e | 0);
}
function EZ(e) {
  return e === e >>> 0;
}
const xZ = /^[0-7]+$/, RZ = "must be a 32-bit unsigned integer or an octal string";
function AZ(e, t, r) {
  if (typeof e > "u" && (e = r), typeof e == "string") {
    if (j5(xZ, e) === null)
      throw new cu(t, e, RZ);
    e = hZ(e, 8);
  }
  return B5(e, t), e;
}
const TZ = kn((e, t, r = dZ, n = cZ) => {
  if (typeof e != "number")
    throw new Ir(t, "number", e);
  if (!hx(e))
    throw new Ra(t, "an integer", e);
  if (e < r || e > n)
    throw new Ra(t, `>= ${r} && <= ${n}`, e);
}), $Z = kn((e, t, r = -2147483648, n = 2147483647) => {
  if (typeof e != "number")
    throw new Ir(t, "number", e);
  if (!hx(e))
    throw new Ra(t, "an integer", e);
  if (e < r || e > n)
    throw new Ra(t, `>= ${r} && <= ${n}`, e);
}), B5 = kn((e, t, r = !1) => {
  if (typeof e != "number")
    throw new Ir(t, "number", e);
  if (!hx(e))
    throw new Ra(t, "an integer", e);
  const n = r ? 1 : 0, o = 4294967295;
  if (e < n || e > o)
    throw new Ra(t, `>= ${n} && <= ${o}`, e);
});
function px(e, t) {
  if (typeof e != "string")
    throw new Ir(t, "string", e);
}
function CZ(e, t, r = void 0, n) {
  if (typeof e != "number")
    throw new Ir(t, "number", e);
  if (r != null && e < r || n != null && e > n || (r != null || n != null) && fZ(e))
    throw new Ra(
      t,
      `${r != null ? `>= ${r}` : ""}${r != null && n != null ? " && " : ""}${n != null ? `<= ${n}` : ""}`,
      e
    );
}
const kZ = kn((e, t, r) => {
  if (!D5(r, e)) {
    const o = "must be one of: " + F5(
      uZ(r, (s) => typeof s == "string" ? `'${s}'` : gZ(s)),
      ", "
    );
    throw new cu(t, e, o);
  }
});
function q5(e, t) {
  if (typeof e != "boolean")
    throw new Ir(t, "boolean", e);
}
function Vb(e, t, r) {
  return e == null || !pZ(e, t) ? r : e[t];
}
const IZ = kn((e, t, r = null) => {
  const n = Vb(r, "allowArray", !1), o = Vb(r, "allowFunction", !1);
  if (!Vb(r, "nullable", !1) && e === null || !n && dx(e) || typeof e != "object" && (!o || typeof e != "function"))
    throw new Ir(t, "Object", e);
}), MZ = kn((e, t) => {
  if (e != null && typeof e != "object" && typeof e != "function")
    throw new Ir(t, "a dictionary", e);
}), Op = kn((e, t, r = 0) => {
  if (!dx(e))
    throw new Ir(t, "Array", e);
  if (e.length < r) {
    const n = `must be longer than ${r}`;
    throw new cu(t, e, n);
  }
});
function NZ(e, t) {
  Op(e, t);
  for (let r = 0; r < e.length; r++)
    px(e[r], `${t}[${r}]`);
}
function LZ(e, t) {
  Op(e, t);
  for (let r = 0; r < e.length; r++)
    q5(e[r], `${t}[${r}]`);
}
function OZ(e, t) {
  Op(e, t);
  for (let r = 0; r < e.length; r++) {
    const n = e[r], o = `${t}[${r}]`;
    if (n == null)
      throw new Ir(o, "AbortSignal", n);
    W5(n, o);
  }
}
function PZ(e, t = "signal") {
  if (px(e, t), S$[e] === void 0)
    throw S$[bZ(e)] !== void 0 ? new _$(e + " (signals must use all capital letters)") : new _$(e);
}
const DZ = kn((e, t = "buffer") => {
  if (!_Z(e))
    throw new Ir(t, ["Buffer", "TypedArray", "DataView"], e);
});
function FZ(e, t) {
  const r = vZ(t), n = e.length;
  if (r === "hex" && n % 2 !== 0)
    throw new cu("encoding", t, `is invalid for data of length ${n}`);
}
function jZ(e, t = "Port", r = !0) {
  if (typeof e != "number" && typeof e != "string" || typeof e == "string" && yZ(e).length === 0 || +e !== +e >>> 0 || e > 65535 || e === 0 && !r)
    throw new mZ(t, e, r);
  return e | 0;
}
const W5 = kn((e, t) => {
  if (e !== void 0 && (e === null || typeof e != "object" || !("aborted" in e)))
    throw new Ir(t, "AbortSignal", e);
}), BZ = kn((e, t) => {
  if (typeof e != "function")
    throw new Ir(t, "Function", e);
}), qZ = kn((e, t) => {
  if (typeof e != "function" || wZ(e))
    throw new Ir(t, "Function", e);
}), WZ = kn((e, t) => {
  if (e !== void 0)
    throw new Ir(t, "undefined", e);
});
function UZ(e, t, r) {
  if (!D5(r, e))
    throw new Ir(t, `('${F5(r, "|")}')`, e);
}
const HZ = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
function E$(e, t) {
  if (typeof e > "u" || !j5(HZ, e))
    throw new cu(
      t,
      e,
      'must be an array or string of format "</styles.css>; rel=preload; as=style"'
    );
}
function zZ(e) {
  if (typeof e == "string")
    return E$(e, "hints"), e;
  if (dx(e)) {
    const t = e.length;
    let r = "";
    if (t === 0)
      return r;
    for (let n = 0; n < t; n++) {
      const o = e[n];
      E$(o, "hints"), r += o, n !== t - 1 && (r += ", ");
    }
    return r;
  }
  throw new cu(
    "hints",
    e,
    'must be an array or string of format "</styles.css>; rel=preload; as=style"'
  );
}
var yc = {
  isInt32: SZ,
  isUint32: EZ,
  parseFileMode: AZ,
  validateArray: Op,
  validateStringArray: NZ,
  validateBooleanArray: LZ,
  validateAbortSignalArray: OZ,
  validateBoolean: q5,
  validateBuffer: DZ,
  validateDictionary: MZ,
  validateEncoding: FZ,
  validateFunction: BZ,
  validateInt32: $Z,
  validateInteger: TZ,
  validateNumber: CZ,
  validateObject: IZ,
  validateOneOf: kZ,
  validatePlainFunction: qZ,
  validatePort: jZ,
  validateSignalName: PZ,
  validateString: px,
  validateUint32: B5,
  validateUndefined: WZ,
  validateUnion: UZ,
  validateAbortSignal: W5,
  validateLinkHeaderValue: zZ
}, gx = { exports: {} };
const { SymbolAsyncIterator: x$, SymbolIterator: R$, SymbolFor: Wa } = jt, U5 = Wa("nodejs.stream.destroyed"), H5 = Wa("nodejs.stream.errored"), Q1 = Wa("nodejs.stream.readable"), Z1 = Wa("nodejs.stream.writable"), z5 = Wa("nodejs.stream.disturbed"), GZ = Wa("nodejs.webstream.isClosedPromise"), VZ = Wa("nodejs.webstream.controllerErrorFunction");
function Pp(e, t = !1) {
  var r;
  return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((r = e._readableState) === null || r === void 0 ? void 0 : r.readable) !== !1) && // Duplex
  (!e._writableState || e._readableState));
}
function Dp(e) {
  var t;
  return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === void 0 ? void 0 : t.writable) !== !1));
}
function KZ(e) {
  return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
}
function Di(e) {
  return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
}
function G5(e) {
  return !!(e && !Di(e) && typeof e.pipeThrough == "function" && typeof e.getReader == "function" && typeof e.cancel == "function");
}
function V5(e) {
  return !!(e && !Di(e) && typeof e.getWriter == "function" && typeof e.abort == "function");
}
function K5(e) {
  return !!(e && !Di(e) && typeof e.readable == "object" && typeof e.writable == "object");
}
function YZ(e) {
  return G5(e) || V5(e) || K5(e);
}
function XZ(e, t) {
  return e == null ? !1 : t === !0 ? typeof e[x$] == "function" : t === !1 ? typeof e[R$] == "function" : typeof e[x$] == "function" || typeof e[R$] == "function";
}
function Fp(e) {
  if (!Di(e))
    return null;
  const t = e._writableState, r = e._readableState, n = t || r;
  return !!(e.destroyed || e[U5] || n != null && n.destroyed);
}
function Y5(e) {
  if (!Dp(e))
    return null;
  if (e.writableEnded === !0)
    return !0;
  const t = e._writableState;
  return t != null && t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function JZ(e, t) {
  if (!Dp(e))
    return null;
  if (e.writableFinished === !0)
    return !0;
  const r = e._writableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.finished) != "boolean" ? null : !!(r.finished || t === !1 && r.ended === !0 && r.length === 0);
}
function QZ(e) {
  if (!Pp(e))
    return null;
  if (e.readableEnded === !0)
    return !0;
  const t = e._readableState;
  return !t || t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function X5(e, t) {
  if (!Pp(e))
    return null;
  const r = e._readableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.endEmitted) != "boolean" ? null : !!(r.endEmitted || t === !1 && r.ended === !0 && r.length === 0);
}
function J5(e) {
  return e && e[Q1] != null ? e[Q1] : typeof (e == null ? void 0 : e.readable) != "boolean" ? null : Fp(e) ? !1 : Pp(e) && e.readable && !X5(e);
}
function Q5(e) {
  return e && e[Z1] != null ? e[Z1] : typeof (e == null ? void 0 : e.writable) != "boolean" ? null : Fp(e) ? !1 : Dp(e) && e.writable && !Y5(e);
}
function ZZ(e, t) {
  return Di(e) ? Fp(e) ? !0 : !((t == null ? void 0 : t.readable) !== !1 && J5(e) || (t == null ? void 0 : t.writable) !== !1 && Q5(e)) : null;
}
function eee(e) {
  var t, r;
  return Di(e) ? e.writableErrored ? e.writableErrored : (t = (r = e._writableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function tee(e) {
  var t, r;
  return Di(e) ? e.readableErrored ? e.readableErrored : (t = (r = e._readableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function ree(e) {
  if (!Di(e))
    return null;
  if (typeof e.closed == "boolean")
    return e.closed;
  const t = e._writableState, r = e._readableState;
  return typeof (t == null ? void 0 : t.closed) == "boolean" || typeof (r == null ? void 0 : r.closed) == "boolean" ? (t == null ? void 0 : t.closed) || (r == null ? void 0 : r.closed) : typeof e._closed == "boolean" && Z5(e) ? e._closed : null;
}
function Z5(e) {
  return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
}
function eF(e) {
  return typeof e._sent100 == "boolean" && Z5(e);
}
function nee(e) {
  var t;
  return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === void 0 ? void 0 : t.upgradeOrConnect) === void 0;
}
function iee(e) {
  if (!Di(e))
    return null;
  const t = e._writableState, r = e._readableState, n = t || r;
  return !n && eF(e) || !!(n && n.autoDestroy && n.emitClose && n.closed === !1);
}
function oee(e) {
  var t;
  return !!(e && ((t = e[z5]) !== null && t !== void 0 ? t : e.readableDidRead || e.readableAborted));
}
function see(e) {
  var t, r, n, o, s, a, l, u, f, c;
  return !!(e && ((t = (r = (n = (o = (s = (a = e[H5]) !== null && a !== void 0 ? a : e.readableErrored) !== null && s !== void 0 ? s : e.writableErrored) !== null && o !== void 0 ? o : (l = e._readableState) === null || l === void 0 ? void 0 : l.errorEmitted) !== null && n !== void 0 ? n : (u = e._writableState) === null || u === void 0 ? void 0 : u.errorEmitted) !== null && r !== void 0 ? r : (f = e._readableState) === null || f === void 0 ? void 0 : f.errored) !== null && t !== void 0 ? t : !((c = e._writableState) === null || c === void 0) && c.errored));
}
var Ro = {
  isDestroyed: Fp,
  kIsDestroyed: U5,
  isDisturbed: oee,
  kIsDisturbed: z5,
  isErrored: see,
  kIsErrored: H5,
  isReadable: J5,
  kIsReadable: Q1,
  kIsClosedPromise: GZ,
  kControllerErrorFunction: VZ,
  kIsWritable: Z1,
  isClosed: ree,
  isDuplexNodeStream: KZ,
  isFinished: ZZ,
  isIterable: XZ,
  isReadableNodeStream: Pp,
  isReadableStream: G5,
  isReadableEnded: QZ,
  isReadableFinished: X5,
  isReadableErrored: tee,
  isNodeStream: Di,
  isWebStream: YZ,
  isWritable: Q5,
  isWritableNodeStream: Dp,
  isWritableStream: V5,
  isWritableEnded: Y5,
  isWritableFinished: JZ,
  isWritableErrored: eee,
  isServerRequest: nee,
  isServerResponse: eF,
  willEmitClose: iee,
  isTransformStream: K5
};
const jo = _t, { AbortError: tF, codes: aee } = on, { ERR_INVALID_ARG_TYPE: lee, ERR_STREAM_PREMATURE_CLOSE: A$ } = aee, { kEmptyObject: eS, once: tS } = Hr, { validateAbortSignal: uee, validateFunction: fee, validateObject: cee, validateBoolean: dee } = yc, { Promise: hee, PromisePrototypeThen: pee, SymbolDispose: rF } = jt, {
  isClosed: gee,
  isReadable: T$,
  isReadableNodeStream: Kb,
  isReadableStream: bee,
  isReadableFinished: $$,
  isReadableErrored: C$,
  isWritable: k$,
  isWritableNodeStream: I$,
  isWritableStream: yee,
  isWritableFinished: M$,
  isWritableErrored: N$,
  isNodeStream: mee,
  willEmitClose: vee,
  kIsClosedPromise: wee
} = Ro;
let Nl;
function _ee(e) {
  return e.setHeader && typeof e.abort == "function";
}
const rS = () => {
};
function nF(e, t, r) {
  var n, o;
  if (arguments.length === 2 ? (r = t, t = eS) : t == null ? t = eS : cee(t, "options"), fee(r, "callback"), uee(t.signal, "options.signal"), r = tS(r), bee(e) || yee(e))
    return See(e, t, r);
  if (!mee(e))
    throw new lee("stream", ["ReadableStream", "WritableStream", "Stream"], e);
  const s = (n = t.readable) !== null && n !== void 0 ? n : Kb(e), a = (o = t.writable) !== null && o !== void 0 ? o : I$(e), l = e._writableState, u = e._readableState, f = () => {
    e.writable || h();
  };
  let c = vee(e) && Kb(e) === s && I$(e) === a, d = M$(e, !1);
  const h = () => {
    d = !0, e.destroyed && (c = !1), !(c && (!e.readable || s)) && (!s || p) && r.call(e);
  };
  let p = $$(e, !1);
  const m = () => {
    p = !0, e.destroyed && (c = !1), !(c && (!e.writable || a)) && (!a || d) && r.call(e);
  }, y = (I) => {
    r.call(e, I);
  };
  let _ = gee(e);
  const S = () => {
    _ = !0;
    const I = N$(e) || C$(e);
    if (I && typeof I != "boolean")
      return r.call(e, I);
    if (s && !p && Kb(e, !0) && !$$(e, !1))
      return r.call(e, new A$());
    if (a && !d && !M$(e, !1))
      return r.call(e, new A$());
    r.call(e);
  }, x = () => {
    _ = !0;
    const I = N$(e) || C$(e);
    if (I && typeof I != "boolean")
      return r.call(e, I);
    r.call(e);
  }, E = () => {
    e.req.on("finish", h);
  };
  _ee(e) ? (e.on("complete", h), c || e.on("abort", S), e.req ? E() : e.on("request", E)) : a && !l && (e.on("end", f), e.on("close", f)), !c && typeof e.aborted == "boolean" && e.on("aborted", S), e.on("end", m), e.on("finish", h), t.error !== !1 && e.on("error", y), e.on("close", S), _ ? jo.nextTick(S) : l != null && l.errorEmitted || u != null && u.errorEmitted ? c || jo.nextTick(x) : (!s && (!c || T$(e)) && (d || k$(e) === !1) || !a && (!c || k$(e)) && (p || T$(e) === !1) || u && e.req && e.aborted) && jo.nextTick(x);
  const C = () => {
    r = rS, e.removeListener("aborted", S), e.removeListener("complete", h), e.removeListener("abort", S), e.removeListener("request", E), e.req && e.req.removeListener("finish", h), e.removeListener("end", f), e.removeListener("close", f), e.removeListener("finish", h), e.removeListener("end", m), e.removeListener("error", y), e.removeListener("close", S);
  };
  if (t.signal && !_) {
    const I = () => {
      const j = r;
      C(), j.call(
        e,
        new tF(void 0, {
          cause: t.signal.reason
        })
      );
    };
    if (t.signal.aborted)
      jo.nextTick(I);
    else {
      Nl = Nl || Hr.addAbortListener;
      const j = Nl(t.signal, I), J = r;
      r = tS((...G) => {
        j[rF](), J.apply(e, G);
      });
    }
  }
  return C;
}
function See(e, t, r) {
  let n = !1, o = rS;
  if (t.signal)
    if (o = () => {
      n = !0, r.call(
        e,
        new tF(void 0, {
          cause: t.signal.reason
        })
      );
    }, t.signal.aborted)
      jo.nextTick(o);
    else {
      Nl = Nl || Hr.addAbortListener;
      const a = Nl(t.signal, o), l = r;
      r = tS((...u) => {
        a[rF](), l.apply(e, u);
      });
    }
  const s = (...a) => {
    n || jo.nextTick(() => r.apply(e, a));
  };
  return pee(e[wee].promise, s, s), rS;
}
function Eee(e, t) {
  var r;
  let n = !1;
  return t === null && (t = eS), (r = t) !== null && r !== void 0 && r.cleanup && (dee(t.cleanup, "cleanup"), n = t.cleanup), new hee((o, s) => {
    const a = nF(e, t, (l) => {
      n && a(), l ? s(l) : o();
    });
  });
}
gx.exports = nF;
gx.exports.finished = Eee;
var vs = gx.exports;
const wi = _t, {
  aggregateTwoErrors: xee,
  codes: { ERR_MULTIPLE_CALLBACK: Ree },
  AbortError: Aee
} = on, { Symbol: iF } = jt, { kIsDestroyed: Tee, isDestroyed: $ee, isFinished: Cee, isServerRequest: kee } = Ro, oF = iF("kDestroy"), nS = iF("kConstruct");
function sF(e, t, r) {
  e && (e.stack, t && !t.errored && (t.errored = e), r && !r.errored && (r.errored = e));
}
function Iee(e, t) {
  const r = this._readableState, n = this._writableState, o = n || r;
  return n != null && n.destroyed || r != null && r.destroyed ? (typeof t == "function" && t(), this) : (sF(e, n, r), n && (n.destroyed = !0), r && (r.destroyed = !0), o.constructed ? L$(this, e, t) : this.once(oF, function(s) {
    L$(this, xee(s, e), t);
  }), this);
}
function L$(e, t, r) {
  let n = !1;
  function o(s) {
    if (n)
      return;
    n = !0;
    const a = e._readableState, l = e._writableState;
    sF(s, l, a), l && (l.closed = !0), a && (a.closed = !0), typeof r == "function" && r(s), s ? wi.nextTick(Mee, e, s) : wi.nextTick(aF, e);
  }
  try {
    e._destroy(t || null, o);
  } catch (s) {
    o(s);
  }
}
function Mee(e, t) {
  iS(e, t), aF(e);
}
function aF(e) {
  const t = e._readableState, r = e._writableState;
  r && (r.closeEmitted = !0), t && (t.closeEmitted = !0), (r != null && r.emitClose || t != null && t.emitClose) && e.emit("close");
}
function iS(e, t) {
  const r = e._readableState, n = e._writableState;
  n != null && n.errorEmitted || r != null && r.errorEmitted || (n && (n.errorEmitted = !0), r && (r.errorEmitted = !0), e.emit("error", t));
}
function Nee() {
  const e = this._readableState, t = this._writableState;
  e && (e.constructed = !0, e.closed = !1, e.closeEmitted = !1, e.destroyed = !1, e.errored = null, e.errorEmitted = !1, e.reading = !1, e.ended = e.readable === !1, e.endEmitted = e.readable === !1), t && (t.constructed = !0, t.destroyed = !1, t.closed = !1, t.closeEmitted = !1, t.errored = null, t.errorEmitted = !1, t.finalCalled = !1, t.prefinished = !1, t.ended = t.writable === !1, t.ending = t.writable === !1, t.finished = t.writable === !1);
}
function oS(e, t, r) {
  const n = e._readableState, o = e._writableState;
  if (o != null && o.destroyed || n != null && n.destroyed)
    return this;
  n != null && n.autoDestroy || o != null && o.autoDestroy ? e.destroy(t) : t && (t.stack, o && !o.errored && (o.errored = t), n && !n.errored && (n.errored = t), r ? wi.nextTick(iS, e, t) : iS(e, t));
}
function Lee(e, t) {
  if (typeof e._construct != "function")
    return;
  const r = e._readableState, n = e._writableState;
  r && (r.constructed = !1), n && (n.constructed = !1), e.once(nS, t), !(e.listenerCount(nS) > 1) && wi.nextTick(Oee, e);
}
function Oee(e) {
  let t = !1;
  function r(n) {
    if (t) {
      oS(e, n ?? new Ree());
      return;
    }
    t = !0;
    const o = e._readableState, s = e._writableState, a = s || o;
    o && (o.constructed = !0), s && (s.constructed = !0), a.destroyed ? e.emit(oF, n) : n ? oS(e, n, !0) : wi.nextTick(Pee, e);
  }
  try {
    e._construct((n) => {
      wi.nextTick(r, n);
    });
  } catch (n) {
    wi.nextTick(r, n);
  }
}
function Pee(e) {
  e.emit(nS);
}
function O$(e) {
  return (e == null ? void 0 : e.setHeader) && typeof e.abort == "function";
}
function lF(e) {
  e.emit("close");
}
function Dee(e, t) {
  e.emit("error", t), wi.nextTick(lF, e);
}
function Fee(e, t) {
  !e || $ee(e) || (!t && !Cee(e) && (t = new Aee()), kee(e) ? (e.socket = null, e.destroy(t)) : O$(e) ? e.abort() : O$(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? wi.nextTick(Dee, e, t) : wi.nextTick(lF, e), e.destroyed || (e[Tee] = !0));
}
var du = {
  construct: Lee,
  destroyer: Fee,
  destroy: Iee,
  undestroy: Nee,
  errorOrDestroy: oS
};
const { ArrayIsArray: jee, ObjectSetPrototypeOf: uF } = jt, { EventEmitter: jp } = ur;
function Bp(e) {
  jp.call(this, e);
}
uF(Bp.prototype, jp.prototype);
uF(Bp, jp);
Bp.prototype.pipe = function(e, t) {
  const r = this;
  function n(c) {
    e.writable && e.write(c) === !1 && r.pause && r.pause();
  }
  r.on("data", n);
  function o() {
    r.readable && r.resume && r.resume();
  }
  e.on("drain", o), !e._isStdio && (!t || t.end !== !1) && (r.on("end", a), r.on("close", l));
  let s = !1;
  function a() {
    s || (s = !0, e.end());
  }
  function l() {
    s || (s = !0, typeof e.destroy == "function" && e.destroy());
  }
  function u(c) {
    f(), jp.listenerCount(this, "error") === 0 && this.emit("error", c);
  }
  sS(r, "error", u), sS(e, "error", u);
  function f() {
    r.removeListener("data", n), e.removeListener("drain", o), r.removeListener("end", a), r.removeListener("close", l), r.removeListener("error", u), e.removeListener("error", u), r.removeListener("end", f), r.removeListener("close", f), e.removeListener("close", f);
  }
  return r.on("end", f), r.on("close", f), e.on("close", f), e.emit("pipe", r), e;
};
function sS(e, t, r) {
  if (typeof e.prependListener == "function")
    return e.prependListener(t, r);
  !e._events || !e._events[t] ? e.on(t, r) : jee(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
}
var bx = {
  Stream: Bp,
  prependListener: sS
}, fF = { exports: {} };
(function(e) {
  const { SymbolDispose: t } = jt, { AbortError: r, codes: n } = on, { isNodeStream: o, isWebStream: s, kControllerErrorFunction: a } = Ro, l = vs, { ERR_INVALID_ARG_TYPE: u } = n;
  let f;
  const c = (d, h) => {
    if (typeof d != "object" || !("aborted" in d))
      throw new u(h, "AbortSignal", d);
  };
  e.exports.addAbortSignal = function(h, p) {
    if (c(h, "signal"), !o(p) && !s(p))
      throw new u("stream", ["ReadableStream", "WritableStream", "Stream"], p);
    return e.exports.addAbortSignalNoValidate(h, p);
  }, e.exports.addAbortSignalNoValidate = function(d, h) {
    if (typeof d != "object" || !("aborted" in d))
      return h;
    const p = o(h) ? () => {
      h.destroy(
        new r(void 0, {
          cause: d.reason
        })
      );
    } : () => {
      h[a](
        new r(void 0, {
          cause: d.reason
        })
      );
    };
    if (d.aborted)
      p();
    else {
      f = f || Hr.addAbortListener;
      const m = f(d, p);
      l(h, m[t]);
    }
    return h;
  };
})(fF);
var qp = fF.exports;
const { StringPrototypeSlice: P$, SymbolIterator: Bee, TypedArrayPrototypeSet: Zc, Uint8Array: qee } = jt, { Buffer: Yb } = ut, { inspect: Wee } = Hr;
var Uee = class {
  constructor() {
    this.head = null, this.tail = null, this.length = 0;
  }
  push(t) {
    const r = {
      data: t,
      next: null
    };
    this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
  }
  unshift(t) {
    const r = {
      data: t,
      next: this.head
    };
    this.length === 0 && (this.tail = r), this.head = r, ++this.length;
  }
  shift() {
    if (this.length === 0)
      return;
    const t = this.head.data;
    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
  }
  clear() {
    this.head = this.tail = null, this.length = 0;
  }
  join(t) {
    if (this.length === 0)
      return "";
    let r = this.head, n = "" + r.data;
    for (; (r = r.next) !== null; )
      n += t + r.data;
    return n;
  }
  concat(t) {
    if (this.length === 0)
      return Yb.alloc(0);
    const r = Yb.allocUnsafe(t >>> 0);
    let n = this.head, o = 0;
    for (; n; )
      Zc(r, n.data, o), o += n.data.length, n = n.next;
    return r;
  }
  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(t, r) {
    const n = this.head.data;
    if (t < n.length) {
      const o = n.slice(0, t);
      return this.head.data = n.slice(t), o;
    }
    return t === n.length ? this.shift() : r ? this._getString(t) : this._getBuffer(t);
  }
  first() {
    return this.head.data;
  }
  *[Bee]() {
    for (let t = this.head; t; t = t.next)
      yield t.data;
  }
  // Consumes a specified amount of characters from the buffered data.
  _getString(t) {
    let r = "", n = this.head, o = 0;
    do {
      const s = n.data;
      if (t > s.length)
        r += s, t -= s.length;
      else {
        t === s.length ? (r += s, ++o, n.next ? this.head = n.next : this.head = this.tail = null) : (r += P$(s, 0, t), this.head = n, n.data = P$(s, t));
        break;
      }
      ++o;
    } while ((n = n.next) !== null);
    return this.length -= o, r;
  }
  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(t) {
    const r = Yb.allocUnsafe(t), n = t;
    let o = this.head, s = 0;
    do {
      const a = o.data;
      if (t > a.length)
        Zc(r, a, n - t), t -= a.length;
      else {
        t === a.length ? (Zc(r, a, n - t), ++s, o.next ? this.head = o.next : this.head = this.tail = null) : (Zc(r, new qee(a.buffer, a.byteOffset, t), n - t), this.head = o, o.data = a.slice(t));
        break;
      }
      ++s;
    } while ((o = o.next) !== null);
    return this.length -= s, r;
  }
  // Make sure the linked list only shows the minimal necessary information.
  [Symbol.for("nodejs.util.inspect.custom")](t, r) {
    return Wee(this, {
      ...r,
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: !1
    });
  }
};
const { MathFloor: Hee, NumberIsInteger: zee } = jt, { validateInteger: Gee } = yc, { ERR_INVALID_ARG_VALUE: Vee } = on.codes;
let cF = 16 * 1024, dF = 16;
function Kee(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function hF(e) {
  return e ? dF : cF;
}
function Yee(e, t) {
  Gee(t, "value", 0), e ? dF = t : cF = t;
}
function Xee(e, t, r, n) {
  const o = Kee(t, n, r);
  if (o != null) {
    if (!zee(o) || o < 0) {
      const s = n ? `options.${r}` : "options.highWaterMark";
      throw new Vee(s, o);
    }
    return Hee(o);
  }
  return hF(e.objectMode);
}
var Wp = {
  getHighWaterMark: Xee,
  getDefaultHighWaterMark: hF,
  setDefaultHighWaterMark: Yee
};
const D$ = _t, { PromisePrototypeThen: Jee, SymbolAsyncIterator: F$, SymbolIterator: j$ } = jt, { Buffer: Qee } = ut, { ERR_INVALID_ARG_TYPE: Zee, ERR_STREAM_NULL_VALUES: ete } = on.codes;
function tte(e, t, r) {
  let n;
  if (typeof t == "string" || t instanceof Qee)
    return new e({
      objectMode: !0,
      ...r,
      read() {
        this.push(t), this.push(null);
      }
    });
  let o;
  if (t && t[F$])
    o = !0, n = t[F$]();
  else if (t && t[j$])
    o = !1, n = t[j$]();
  else
    throw new Zee("iterable", ["Iterable"], t);
  const s = new e({
    objectMode: !0,
    highWaterMark: 1,
    // TODO(ronag): What options should be allowed?
    ...r
  });
  let a = !1;
  s._read = function() {
    a || (a = !0, u());
  }, s._destroy = function(f, c) {
    Jee(
      l(f),
      () => D$.nextTick(c, f),
      // nextTick is here in case cb throws
      (d) => D$.nextTick(c, d || f)
    );
  };
  async function l(f) {
    const c = f != null, d = typeof n.throw == "function";
    if (c && d) {
      const { value: h, done: p } = await n.throw(f);
      if (await h, p)
        return;
    }
    if (typeof n.return == "function") {
      const { value: h } = await n.return();
      await h;
    }
  }
  async function u() {
    for (; ; ) {
      try {
        const { value: f, done: c } = o ? await n.next() : n.next();
        if (c)
          s.push(null);
        else {
          const d = f && typeof f.then == "function" ? await f : f;
          if (d === null)
            throw a = !1, new ete();
          if (s.push(d))
            continue;
          a = !1;
        }
      } catch (f) {
        s.destroy(f);
      }
      break;
    }
  }
  return s;
}
var pF = tte, Xb, B$;
function Up() {
  if (B$)
    return Xb;
  B$ = 1;
  const e = _t, {
    ArrayPrototypeIndexOf: t,
    NumberIsInteger: r,
    NumberIsNaN: n,
    NumberParseInt: o,
    ObjectDefineProperties: s,
    ObjectKeys: a,
    ObjectSetPrototypeOf: l,
    Promise: u,
    SafeSet: f,
    SymbolAsyncDispose: c,
    SymbolAsyncIterator: d,
    Symbol: h
  } = jt;
  Xb = B, B.ReadableState = ye;
  const { EventEmitter: p } = ur, { Stream: m, prependListener: y } = bx, { Buffer: _ } = ut, { addAbortSignal: S } = qp, x = vs;
  let E = Hr.debuglog("stream", (g) => {
    E = g;
  });
  const C = Uee, I = du, { getHighWaterMark: j, getDefaultHighWaterMark: J } = Wp, {
    aggregateTwoErrors: G,
    codes: {
      ERR_INVALID_ARG_TYPE: $,
      ERR_METHOD_NOT_IMPLEMENTED: V,
      ERR_OUT_OF_RANGE: M,
      ERR_STREAM_PUSH_AFTER_EOF: W,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT: k
    },
    AbortError: U
  } = on, { validateObject: Z } = yc, Y = h("kPaused"), { StringDecoder: te } = Hl(), se = pF;
  l(B.prototype, m.prototype), l(B, m);
  const fe = () => {
  }, { errorOrDestroy: he } = I, ae = 1, be = 2, H = 4, pe = 8, ke = 16, le = 32, ee = 64, ge = 128, Ae = 256, Oe = 512, K = 1024, z = 2048, b = 4096, w = 8192, T = 16384, O = 32768, L = 65536, ne = 1 << 17, ue = 1 << 18;
  function oe(g) {
    return {
      enumerable: !1,
      get() {
        return (this.state & g) !== 0;
      },
      set(v) {
        v ? this.state |= g : this.state &= ~g;
      }
    };
  }
  s(ye.prototype, {
    objectMode: oe(ae),
    ended: oe(be),
    endEmitted: oe(H),
    reading: oe(pe),
    // Stream is still being constructed and cannot be
    // destroyed until construction finished or failed.
    // Async construction is opt in, therefore we start as
    // constructed.
    constructed: oe(ke),
    // A flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    sync: oe(le),
    // Whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    needReadable: oe(ee),
    emittedReadable: oe(ge),
    readableListening: oe(Ae),
    resumeScheduled: oe(Oe),
    // True if the error was already emitted and should not be thrown again.
    errorEmitted: oe(K),
    emitClose: oe(z),
    autoDestroy: oe(b),
    // Has it been destroyed.
    destroyed: oe(w),
    // Indicates whether the stream has finished destroying.
    closed: oe(T),
    // True if close has been emitted or would have been emitted
    // depending on emitClose.
    closeEmitted: oe(O),
    multiAwaitDrain: oe(L),
    // If true, a maybeReadMore has been scheduled.
    readingMore: oe(ne),
    dataEmitted: oe(ue)
  });
  function ye(g, v, F) {
    typeof F != "boolean" && (F = v instanceof ao()), this.state = z | b | ke | le, g && g.objectMode && (this.state |= ae), F && g && g.readableObjectMode && (this.state |= ae), this.highWaterMark = g ? j(this, g, "readableHighWaterMark", F) : J(!1), this.buffer = new C(), this.length = 0, this.pipes = [], this.flowing = null, this[Y] = null, g && g.emitClose === !1 && (this.state &= ~z), g && g.autoDestroy === !1 && (this.state &= ~b), this.errored = null, this.defaultEncoding = g && g.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, g && g.encoding && (this.decoder = new te(g.encoding), this.encoding = g.encoding);
  }
  function B(g) {
    if (!(this instanceof B))
      return new B(g);
    const v = this instanceof ao();
    this._readableState = new ye(g, this, v), g && (typeof g.read == "function" && (this._read = g.read), typeof g.destroy == "function" && (this._destroy = g.destroy), typeof g.construct == "function" && (this._construct = g.construct), g.signal && !v && S(g.signal, this)), m.call(this, g), I.construct(this, () => {
      this._readableState.needReadable && re(this, this._readableState);
    });
  }
  B.prototype.destroy = I.destroy, B.prototype._undestroy = I.undestroy, B.prototype._destroy = function(g, v) {
    v(g);
  }, B.prototype[p.captureRejectionSymbol] = function(g) {
    this.destroy(g);
  }, B.prototype[c] = function() {
    let g;
    return this.destroyed || (g = this.readableEnded ? null : new U(), this.destroy(g)), new u((v, F) => x(this, (D) => D && D !== g ? F(D) : v(null)));
  }, B.prototype.push = function(g, v) {
    return me(this, g, v, !1);
  }, B.prototype.unshift = function(g, v) {
    return me(this, g, v, !0);
  };
  function me(g, v, F, D) {
    E("readableAddChunk", v);
    const X = g._readableState;
    let Le;
    if (X.state & ae || (typeof v == "string" ? (F = F || X.defaultEncoding, X.encoding !== F && (D && X.encoding ? v = _.from(v, F).toString(X.encoding) : (v = _.from(v, F), F = ""))) : v instanceof _ ? F = "" : m._isUint8Array(v) ? (v = m._uint8ArrayToBuffer(v), F = "") : v != null && (Le = new $("chunk", ["string", "Buffer", "Uint8Array"], v))), Le)
      he(g, Le);
    else if (v === null)
      X.state &= ~pe, R(g, X);
    else if (X.state & ae || v && v.length > 0)
      if (D)
        if (X.state & H)
          he(g, new k());
        else {
          if (X.destroyed || X.errored)
            return !1;
          Ce(g, X, v, !0);
        }
      else if (X.ended)
        he(g, new W());
      else {
        if (X.destroyed || X.errored)
          return !1;
        X.state &= ~pe, X.decoder && !F ? (v = X.decoder.write(v), X.objectMode || v.length !== 0 ? Ce(g, X, v, !1) : re(g, X)) : Ce(g, X, v, !1);
      }
    else
      D || (X.state &= ~pe, re(g, X));
    return !X.ended && (X.length < X.highWaterMark || X.length === 0);
  }
  function Ce(g, v, F, D) {
    v.flowing && v.length === 0 && !v.sync && g.listenerCount("data") > 0 ? (v.state & L ? v.awaitDrainWriters.clear() : v.awaitDrainWriters = null, v.dataEmitted = !0, g.emit("data", F)) : (v.length += v.objectMode ? 1 : F.length, D ? v.buffer.unshift(F) : v.buffer.push(F), v.state & ee && A(g)), re(g, v);
  }
  B.prototype.isPaused = function() {
    const g = this._readableState;
    return g[Y] === !0 || g.flowing === !1;
  }, B.prototype.setEncoding = function(g) {
    const v = new te(g);
    this._readableState.decoder = v, this._readableState.encoding = this._readableState.decoder.encoding;
    const F = this._readableState.buffer;
    let D = "";
    for (const X of F)
      D += v.write(X);
    return F.clear(), D !== "" && F.push(D), this._readableState.length = D.length, this;
  };
  const Ie = 1073741824;
  function Me(g) {
    if (g > Ie)
      throw new M("size", "<= 1GiB", g);
    return g--, g |= g >>> 1, g |= g >>> 2, g |= g >>> 4, g |= g >>> 8, g |= g >>> 16, g++, g;
  }
  function N(g, v) {
    return g <= 0 || v.length === 0 && v.ended ? 0 : v.state & ae ? 1 : n(g) ? v.flowing && v.length ? v.buffer.first().length : v.length : g <= v.length ? g : v.ended ? v.length : 0;
  }
  B.prototype.read = function(g) {
    E("read", g), g === void 0 ? g = NaN : r(g) || (g = o(g, 10));
    const v = this._readableState, F = g;
    if (g > v.highWaterMark && (v.highWaterMark = Me(g)), g !== 0 && (v.state &= ~ge), g === 0 && v.needReadable && ((v.highWaterMark !== 0 ? v.length >= v.highWaterMark : v.length > 0) || v.ended))
      return E("read: emitReadable", v.length, v.ended), v.length === 0 && v.ended ? At(this) : A(this), null;
    if (g = N(g, v), g === 0 && v.ended)
      return v.length === 0 && At(this), null;
    let D = (v.state & ee) !== 0;
    if (E("need readable", D), (v.length === 0 || v.length - g < v.highWaterMark) && (D = !0, E("length less than watermark", D)), v.ended || v.reading || v.destroyed || v.errored || !v.constructed)
      D = !1, E("reading, ended or constructing", D);
    else if (D) {
      E("do read"), v.state |= pe | le, v.length === 0 && (v.state |= ee);
      try {
        this._read(v.highWaterMark);
      } catch (Le) {
        he(this, Le);
      }
      v.state &= ~le, v.reading || (g = N(F, v));
    }
    let X;
    return g > 0 ? X = Lr(g, v) : X = null, X === null ? (v.needReadable = v.length <= v.highWaterMark, g = 0) : (v.length -= g, v.multiAwaitDrain ? v.awaitDrainWriters.clear() : v.awaitDrainWriters = null), v.length === 0 && (v.ended || (v.needReadable = !0), F !== g && v.ended && At(this)), X !== null && !v.errorEmitted && !v.closeEmitted && (v.dataEmitted = !0, this.emit("data", X)), X;
  };
  function R(g, v) {
    if (E("onEofChunk"), !v.ended) {
      if (v.decoder) {
        const F = v.decoder.end();
        F && F.length && (v.buffer.push(F), v.length += v.objectMode ? 1 : F.length);
      }
      v.ended = !0, v.sync ? A(g) : (v.needReadable = !1, v.emittedReadable = !0, q(g));
    }
  }
  function A(g) {
    const v = g._readableState;
    E("emitReadable", v.needReadable, v.emittedReadable), v.needReadable = !1, v.emittedReadable || (E("emitReadable", v.flowing), v.emittedReadable = !0, e.nextTick(q, g));
  }
  function q(g) {
    const v = g._readableState;
    E("emitReadable_", v.destroyed, v.length, v.ended), !v.destroyed && !v.errored && (v.length || v.ended) && (g.emit("readable"), v.emittedReadable = !1), v.needReadable = !v.flowing && !v.ended && v.length <= v.highWaterMark, Ze(g);
  }
  function re(g, v) {
    !v.readingMore && v.constructed && (v.readingMore = !0, e.nextTick(ce, g, v));
  }
  function ce(g, v) {
    for (; !v.reading && !v.ended && (v.length < v.highWaterMark || v.flowing && v.length === 0); ) {
      const F = v.length;
      if (E("maybeReadMore read 0"), g.read(0), F === v.length)
        break;
    }
    v.readingMore = !1;
  }
  B.prototype._read = function(g) {
    throw new V("_read()");
  }, B.prototype.pipe = function(g, v) {
    const F = this, D = this._readableState;
    D.pipes.length === 1 && (D.multiAwaitDrain || (D.multiAwaitDrain = !0, D.awaitDrainWriters = new f(D.awaitDrainWriters ? [D.awaitDrainWriters] : []))), D.pipes.push(g), E("pipe count=%d opts=%j", D.pipes.length, v);
    const Le = (!v || v.end !== !1) && g !== e.stdout && g !== e.stderr ? Xt : St;
    D.endEmitted ? e.nextTick(Le) : F.once("end", Le), g.on("unpipe", We);
    function We(ft, rt) {
      E("onunpipe"), ft === F && rt && rt.hasUnpiped === !1 && (rt.hasUnpiped = !0, yn());
    }
    function Xt() {
      E("onend"), g.end();
    }
    let dt, Kr = !1;
    function yn() {
      E("cleanup"), g.removeListener("close", or), g.removeListener("finish", dr), dt && g.removeListener("drain", dt), g.removeListener("error", cr), g.removeListener("unpipe", We), F.removeListener("end", Xt), F.removeListener("end", St), F.removeListener("data", xr), Kr = !0, dt && D.awaitDrainWriters && (!g._writableState || g._writableState.needDrain) && dt();
    }
    function Wt() {
      Kr || (D.pipes.length === 1 && D.pipes[0] === g ? (E("false write response, pause", 0), D.awaitDrainWriters = g, D.multiAwaitDrain = !1) : D.pipes.length > 1 && D.pipes.includes(g) && (E("false write response, pause", D.awaitDrainWriters.size), D.awaitDrainWriters.add(g)), F.pause()), dt || (dt = de(F, g), g.on("drain", dt));
    }
    F.on("data", xr);
    function xr(ft) {
      E("ondata");
      const rt = g.write(ft);
      E("dest.write", rt), rt === !1 && Wt();
    }
    function cr(ft) {
      if (E("onerror", ft), St(), g.removeListener("error", cr), g.listenerCount("error") === 0) {
        const rt = g._writableState || g._readableState;
        rt && !rt.errorEmitted ? he(g, ft) : g.emit("error", ft);
      }
    }
    y(g, "error", cr);
    function or() {
      g.removeListener("finish", dr), St();
    }
    g.once("close", or);
    function dr() {
      E("onfinish"), g.removeListener("close", or), St();
    }
    g.once("finish", dr);
    function St() {
      E("unpipe"), F.unpipe(g);
    }
    return g.emit("pipe", F), g.writableNeedDrain === !0 ? Wt() : D.flowing || (E("pipe resume"), F.resume()), g;
  };
  function de(g, v) {
    return function() {
      const D = g._readableState;
      D.awaitDrainWriters === v ? (E("pipeOnDrain", 1), D.awaitDrainWriters = null) : D.multiAwaitDrain && (E("pipeOnDrain", D.awaitDrainWriters.size), D.awaitDrainWriters.delete(v)), (!D.awaitDrainWriters || D.awaitDrainWriters.size === 0) && g.listenerCount("data") && g.resume();
    };
  }
  B.prototype.unpipe = function(g) {
    const v = this._readableState, F = {
      hasUnpiped: !1
    };
    if (v.pipes.length === 0)
      return this;
    if (!g) {
      const X = v.pipes;
      v.pipes = [], this.pause();
      for (let Le = 0; Le < X.length; Le++)
        X[Le].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    const D = t(v.pipes, g);
    return D === -1 ? this : (v.pipes.splice(D, 1), v.pipes.length === 0 && this.pause(), g.emit("unpipe", this, F), this);
  }, B.prototype.on = function(g, v) {
    const F = m.prototype.on.call(this, g, v), D = this._readableState;
    return g === "data" ? (D.readableListening = this.listenerCount("readable") > 0, D.flowing !== !1 && this.resume()) : g === "readable" && !D.endEmitted && !D.readableListening && (D.readableListening = D.needReadable = !0, D.flowing = !1, D.emittedReadable = !1, E("on readable", D.length, D.reading), D.length ? A(this) : D.reading || e.nextTick(it, this)), F;
  }, B.prototype.addListener = B.prototype.on, B.prototype.removeListener = function(g, v) {
    const F = m.prototype.removeListener.call(this, g, v);
    return g === "readable" && e.nextTick(De, this), F;
  }, B.prototype.off = B.prototype.removeListener, B.prototype.removeAllListeners = function(g) {
    const v = m.prototype.removeAllListeners.apply(this, arguments);
    return (g === "readable" || g === void 0) && e.nextTick(De, this), v;
  };
  function De(g) {
    const v = g._readableState;
    v.readableListening = g.listenerCount("readable") > 0, v.resumeScheduled && v[Y] === !1 ? v.flowing = !0 : g.listenerCount("data") > 0 ? g.resume() : v.readableListening || (v.flowing = null);
  }
  function it(g) {
    E("readable nexttick read 0"), g.read(0);
  }
  B.prototype.resume = function() {
    const g = this._readableState;
    return g.flowing || (E("resume"), g.flowing = !g.readableListening, ze(this, g)), g[Y] = !1, this;
  };
  function ze(g, v) {
    v.resumeScheduled || (v.resumeScheduled = !0, e.nextTick(Ve, g, v));
  }
  function Ve(g, v) {
    E("resume", v.reading), v.reading || g.read(0), v.resumeScheduled = !1, g.emit("resume"), Ze(g), v.flowing && !v.reading && g.read(0);
  }
  B.prototype.pause = function() {
    return E("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (E("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState[Y] = !0, this;
  };
  function Ze(g) {
    const v = g._readableState;
    for (E("flow", v.flowing); v.flowing && g.read() !== null; )
      ;
  }
  B.prototype.wrap = function(g) {
    let v = !1;
    g.on("data", (D) => {
      !this.push(D) && g.pause && (v = !0, g.pause());
    }), g.on("end", () => {
      this.push(null);
    }), g.on("error", (D) => {
      he(this, D);
    }), g.on("close", () => {
      this.destroy();
    }), g.on("destroy", () => {
      this.destroy();
    }), this._read = () => {
      v && g.resume && (v = !1, g.resume());
    };
    const F = a(g);
    for (let D = 1; D < F.length; D++) {
      const X = F[D];
      this[X] === void 0 && typeof g[X] == "function" && (this[X] = g[X].bind(g));
    }
    return this;
  }, B.prototype[d] = function() {
    return Er(this);
  }, B.prototype.iterator = function(g) {
    return g !== void 0 && Z(g, "options"), Er(this, g);
  };
  function Er(g, v) {
    typeof g.read != "function" && (g = B.wrap(g, {
      objectMode: !0
    }));
    const F = Wi(g, v);
    return F.stream = g, F;
  }
  async function* Wi(g, v) {
    let F = fe;
    function D(We) {
      this === g ? (F(), F = fe) : F = We;
    }
    g.on("readable", D);
    let X;
    const Le = x(
      g,
      {
        writable: !1
      },
      (We) => {
        X = We ? G(X, We) : null, F(), F = fe;
      }
    );
    try {
      for (; ; ) {
        const We = g.destroyed ? null : g.read();
        if (We !== null)
          yield We;
        else {
          if (X)
            throw X;
          if (X === null)
            return;
          await new u(D);
        }
      }
    } catch (We) {
      throw X = G(X, We), X;
    } finally {
      (X || (v == null ? void 0 : v.destroyOnReturn) !== !1) && (X === void 0 || g._readableState.autoDestroy) ? I.destroyer(g, null) : (g.off("readable", D), Le());
    }
  }
  s(B.prototype, {
    readable: {
      __proto__: null,
      get() {
        const g = this._readableState;
        return !!g && g.readable !== !1 && !g.destroyed && !g.errorEmitted && !g.endEmitted;
      },
      set(g) {
        this._readableState && (this._readableState.readable = !!g);
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(g) {
        this._readableState && (this._readableState.flowing = g);
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.objectMode : !1;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.destroyed : !1;
      },
      set(g) {
        this._readableState && (this._readableState.destroyed = g);
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.endEmitted : !1;
      }
    }
  }), s(ye.prototype, {
    // Legacy getter for `pipesCount`.
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    // Legacy property for `paused`.
    paused: {
      __proto__: null,
      get() {
        return this[Y] !== !1;
      },
      set(g) {
        this[Y] = !!g;
      }
    }
  }), B._fromList = Lr;
  function Lr(g, v) {
    if (v.length === 0)
      return null;
    let F;
    return v.objectMode ? F = v.buffer.shift() : !g || g >= v.length ? (v.decoder ? F = v.buffer.join("") : v.buffer.length === 1 ? F = v.buffer.first() : F = v.buffer.concat(v.length), v.buffer.clear()) : F = v.buffer.consume(g, v.decoder), F;
  }
  function At(g) {
    const v = g._readableState;
    E("endReadable", v.endEmitted), v.endEmitted || (v.ended = !0, e.nextTick(si, v, g));
  }
  function si(g, v) {
    if (E("endReadableNT", g.endEmitted, g.length), !g.errored && !g.closeEmitted && !g.endEmitted && g.length === 0) {
      if (g.endEmitted = !0, v.emit("end"), v.writable && v.allowHalfOpen === !1)
        e.nextTick(Ui, v);
      else if (g.autoDestroy) {
        const F = v._writableState;
        (!F || F.autoDestroy && // We don't expect the writable to ever 'finish'
        // if writable is explicitly set to false.
        (F.finished || F.writable === !1)) && v.destroy();
      }
    }
  }
  function Ui(g) {
    g.writable && !g.writableEnded && !g.destroyed && g.end();
  }
  B.from = function(g, v) {
    return se(B, g, v);
  };
  let Nt;
  function ln() {
    return Nt === void 0 && (Nt = {}), Nt;
  }
  return B.fromWeb = function(g, v) {
    return ln().newStreamReadableFromReadableStream(g, v);
  }, B.toWeb = function(g, v) {
    return ln().newReadableStreamFromStreamReadable(g, v);
  }, B.wrap = function(g, v) {
    var F, D;
    return new B({
      objectMode: (F = (D = g.readableObjectMode) !== null && D !== void 0 ? D : g.objectMode) !== null && F !== void 0 ? F : !0,
      ...v,
      destroy(X, Le) {
        I.destroyer(g, X), Le(X);
      }
    }).wrap(g);
  }, Xb;
}
var Jb, q$;
function yx() {
  if (q$)
    return Jb;
  q$ = 1;
  const e = _t, {
    ArrayPrototypeSlice: t,
    Error: r,
    FunctionPrototypeSymbolHasInstance: n,
    ObjectDefineProperty: o,
    ObjectDefineProperties: s,
    ObjectSetPrototypeOf: a,
    StringPrototypeToLowerCase: l,
    Symbol: u,
    SymbolHasInstance: f
  } = jt;
  Jb = Z, Z.WritableState = k;
  const { EventEmitter: c } = ur, d = bx.Stream, { Buffer: h } = ut, p = du, { addAbortSignal: m } = qp, { getHighWaterMark: y, getDefaultHighWaterMark: _ } = Wp, {
    ERR_INVALID_ARG_TYPE: S,
    ERR_METHOD_NOT_IMPLEMENTED: x,
    ERR_MULTIPLE_CALLBACK: E,
    ERR_STREAM_CANNOT_PIPE: C,
    ERR_STREAM_DESTROYED: I,
    ERR_STREAM_ALREADY_FINISHED: j,
    ERR_STREAM_NULL_VALUES: J,
    ERR_STREAM_WRITE_AFTER_END: G,
    ERR_UNKNOWN_ENCODING: $
  } = on.codes, { errorOrDestroy: V } = p;
  a(Z.prototype, d.prototype), a(Z, d);
  function M() {
  }
  const W = u("kOnFinished");
  function k(b, w, T) {
    typeof T != "boolean" && (T = w instanceof ao()), this.objectMode = !!(b && b.objectMode), T && (this.objectMode = this.objectMode || !!(b && b.writableObjectMode)), this.highWaterMark = b ? y(this, b, "writableHighWaterMark", T) : _(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    const O = !!(b && b.decodeStrings === !1);
    this.decodeStrings = !O, this.defaultEncoding = b && b.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = he.bind(void 0, w), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, U(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !b || b.emitClose !== !1, this.autoDestroy = !b || b.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[W] = [];
  }
  function U(b) {
    b.buffered = [], b.bufferedIndex = 0, b.allBuffers = !0, b.allNoop = !0;
  }
  k.prototype.getBuffer = function() {
    return t(this.buffered, this.bufferedIndex);
  }, o(k.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function Z(b) {
    const w = this instanceof ao();
    if (!w && !n(Z, this))
      return new Z(b);
    this._writableState = new k(b, this, w), b && (typeof b.write == "function" && (this._write = b.write), typeof b.writev == "function" && (this._writev = b.writev), typeof b.destroy == "function" && (this._destroy = b.destroy), typeof b.final == "function" && (this._final = b.final), typeof b.construct == "function" && (this._construct = b.construct), b.signal && m(b.signal, this)), d.call(this, b), p.construct(this, () => {
      const T = this._writableState;
      T.writing || pe(this, T), ge(this, T);
    });
  }
  o(Z, f, {
    __proto__: null,
    value: function(b) {
      return n(this, b) ? !0 : this !== Z ? !1 : b && b._writableState instanceof k;
    }
  }), Z.prototype.pipe = function() {
    V(this, new C());
  };
  function Y(b, w, T, O) {
    const L = b._writableState;
    if (typeof T == "function")
      O = T, T = L.defaultEncoding;
    else {
      if (!T)
        T = L.defaultEncoding;
      else if (T !== "buffer" && !h.isEncoding(T))
        throw new $(T);
      typeof O != "function" && (O = M);
    }
    if (w === null)
      throw new J();
    if (!L.objectMode)
      if (typeof w == "string")
        L.decodeStrings !== !1 && (w = h.from(w, T), T = "buffer");
      else if (w instanceof h)
        T = "buffer";
      else if (d._isUint8Array(w))
        w = d._uint8ArrayToBuffer(w), T = "buffer";
      else
        throw new S("chunk", ["string", "Buffer", "Uint8Array"], w);
    let ne;
    return L.ending ? ne = new G() : L.destroyed && (ne = new I("write")), ne ? (e.nextTick(O, ne), V(b, ne, !0), ne) : (L.pendingcb++, te(b, L, w, T, O));
  }
  Z.prototype.write = function(b, w, T) {
    return Y(this, b, w, T) === !0;
  }, Z.prototype.cork = function() {
    this._writableState.corked++;
  }, Z.prototype.uncork = function() {
    const b = this._writableState;
    b.corked && (b.corked--, b.writing || pe(this, b));
  }, Z.prototype.setDefaultEncoding = function(w) {
    if (typeof w == "string" && (w = l(w)), !h.isEncoding(w))
      throw new $(w);
    return this._writableState.defaultEncoding = w, this;
  };
  function te(b, w, T, O, L) {
    const ne = w.objectMode ? 1 : T.length;
    w.length += ne;
    const ue = w.length < w.highWaterMark;
    return ue || (w.needDrain = !0), w.writing || w.corked || w.errored || !w.constructed ? (w.buffered.push({
      chunk: T,
      encoding: O,
      callback: L
    }), w.allBuffers && O !== "buffer" && (w.allBuffers = !1), w.allNoop && L !== M && (w.allNoop = !1)) : (w.writelen = ne, w.writecb = L, w.writing = !0, w.sync = !0, b._write(T, O, w.onwrite), w.sync = !1), ue && !w.errored && !w.destroyed;
  }
  function se(b, w, T, O, L, ne, ue) {
    w.writelen = O, w.writecb = ue, w.writing = !0, w.sync = !0, w.destroyed ? w.onwrite(new I("write")) : T ? b._writev(L, w.onwrite) : b._write(L, ne, w.onwrite), w.sync = !1;
  }
  function fe(b, w, T, O) {
    --w.pendingcb, O(T), H(w), V(b, T);
  }
  function he(b, w) {
    const T = b._writableState, O = T.sync, L = T.writecb;
    if (typeof L != "function") {
      V(b, new E());
      return;
    }
    T.writing = !1, T.writecb = null, T.length -= T.writelen, T.writelen = 0, w ? (w.stack, T.errored || (T.errored = w), b._readableState && !b._readableState.errored && (b._readableState.errored = w), O ? e.nextTick(fe, b, T, w, L) : fe(b, T, w, L)) : (T.buffered.length > T.bufferedIndex && pe(b, T), O ? T.afterWriteTickInfo !== null && T.afterWriteTickInfo.cb === L ? T.afterWriteTickInfo.count++ : (T.afterWriteTickInfo = {
      count: 1,
      cb: L,
      stream: b,
      state: T
    }, e.nextTick(ae, T.afterWriteTickInfo)) : be(b, T, 1, L));
  }
  function ae({ stream: b, state: w, count: T, cb: O }) {
    return w.afterWriteTickInfo = null, be(b, w, T, O);
  }
  function be(b, w, T, O) {
    for (!w.ending && !b.destroyed && w.length === 0 && w.needDrain && (w.needDrain = !1, b.emit("drain")); T-- > 0; )
      w.pendingcb--, O();
    w.destroyed && H(w), ge(b, w);
  }
  function H(b) {
    if (b.writing)
      return;
    for (let L = b.bufferedIndex; L < b.buffered.length; ++L) {
      var w;
      const { chunk: ne, callback: ue } = b.buffered[L], oe = b.objectMode ? 1 : ne.length;
      b.length -= oe, ue(
        (w = b.errored) !== null && w !== void 0 ? w : new I("write")
      );
    }
    const T = b[W].splice(0);
    for (let L = 0; L < T.length; L++) {
      var O;
      T[L](
        (O = b.errored) !== null && O !== void 0 ? O : new I("end")
      );
    }
    U(b);
  }
  function pe(b, w) {
    if (w.corked || w.bufferProcessing || w.destroyed || !w.constructed)
      return;
    const { buffered: T, bufferedIndex: O, objectMode: L } = w, ne = T.length - O;
    if (!ne)
      return;
    let ue = O;
    if (w.bufferProcessing = !0, ne > 1 && b._writev) {
      w.pendingcb -= ne - 1;
      const oe = w.allNoop ? M : (B) => {
        for (let me = ue; me < T.length; ++me)
          T[me].callback(B);
      }, ye = w.allNoop && ue === 0 ? T : t(T, ue);
      ye.allBuffers = w.allBuffers, se(b, w, !0, w.length, ye, "", oe), U(w);
    } else {
      do {
        const { chunk: oe, encoding: ye, callback: B } = T[ue];
        T[ue++] = null;
        const me = L ? 1 : oe.length;
        se(b, w, !1, me, oe, ye, B);
      } while (ue < T.length && !w.writing);
      ue === T.length ? U(w) : ue > 256 ? (T.splice(0, ue), w.bufferedIndex = 0) : w.bufferedIndex = ue;
    }
    w.bufferProcessing = !1;
  }
  Z.prototype._write = function(b, w, T) {
    if (this._writev)
      this._writev(
        [
          {
            chunk: b,
            encoding: w
          }
        ],
        T
      );
    else
      throw new x("_write()");
  }, Z.prototype._writev = null, Z.prototype.end = function(b, w, T) {
    const O = this._writableState;
    typeof b == "function" ? (T = b, b = null, w = null) : typeof w == "function" && (T = w, w = null);
    let L;
    if (b != null) {
      const ne = Y(this, b, w);
      ne instanceof r && (L = ne);
    }
    return O.corked && (O.corked = 1, this.uncork()), L || (!O.errored && !O.ending ? (O.ending = !0, ge(this, O, !0), O.ended = !0) : O.finished ? L = new j("end") : O.destroyed && (L = new I("end"))), typeof T == "function" && (L || O.finished ? e.nextTick(T, L) : O[W].push(T)), this;
  };
  function ke(b) {
    return b.ending && !b.destroyed && b.constructed && b.length === 0 && !b.errored && b.buffered.length === 0 && !b.finished && !b.writing && !b.errorEmitted && !b.closeEmitted;
  }
  function le(b, w) {
    let T = !1;
    function O(L) {
      if (T) {
        V(b, L ?? E());
        return;
      }
      if (T = !0, w.pendingcb--, L) {
        const ne = w[W].splice(0);
        for (let ue = 0; ue < ne.length; ue++)
          ne[ue](L);
        V(b, L, w.sync);
      } else
        ke(w) && (w.prefinished = !0, b.emit("prefinish"), w.pendingcb++, e.nextTick(Ae, b, w));
    }
    w.sync = !0, w.pendingcb++;
    try {
      b._final(O);
    } catch (L) {
      O(L);
    }
    w.sync = !1;
  }
  function ee(b, w) {
    !w.prefinished && !w.finalCalled && (typeof b._final == "function" && !w.destroyed ? (w.finalCalled = !0, le(b, w)) : (w.prefinished = !0, b.emit("prefinish")));
  }
  function ge(b, w, T) {
    ke(w) && (ee(b, w), w.pendingcb === 0 && (T ? (w.pendingcb++, e.nextTick(
      (O, L) => {
        ke(L) ? Ae(O, L) : L.pendingcb--;
      },
      b,
      w
    )) : ke(w) && (w.pendingcb++, Ae(b, w))));
  }
  function Ae(b, w) {
    w.pendingcb--, w.finished = !0;
    const T = w[W].splice(0);
    for (let O = 0; O < T.length; O++)
      T[O]();
    if (b.emit("finish"), w.autoDestroy) {
      const O = b._readableState;
      (!O || O.autoDestroy && // We don't expect the readable to ever 'end'
      // if readable is explicitly set to false.
      (O.endEmitted || O.readable === !1)) && b.destroy();
    }
  }
  s(Z.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : !1;
      },
      set(b) {
        this._writableState && (this._writableState.destroyed = b);
      }
    },
    writable: {
      __proto__: null,
      get() {
        const b = this._writableState;
        return !!b && b.writable !== !1 && !b.destroyed && !b.errored && !b.ending && !b.ended;
      },
      set(b) {
        this._writableState && (this._writableState.writable = !!b);
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : !1;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : !1;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : !1;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const b = this._writableState;
        return b ? !b.destroyed && !b.ending && b.needDrain : !1;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  const Oe = p.destroy;
  Z.prototype.destroy = function(b, w) {
    const T = this._writableState;
    return !T.destroyed && (T.bufferedIndex < T.buffered.length || T[W].length) && e.nextTick(H, T), Oe.call(this, b, w), this;
  }, Z.prototype._undestroy = p.undestroy, Z.prototype._destroy = function(b, w) {
    w(b);
  }, Z.prototype[c.captureRejectionSymbol] = function(b) {
    this.destroy(b);
  };
  let K;
  function z() {
    return K === void 0 && (K = {}), K;
  }
  return Z.fromWeb = function(b, w) {
    return z().newStreamWritableFromWritableStream(b, w);
  }, Z.toWeb = function(b) {
    return z().newWritableStreamFromStreamWritable(b);
  }, Jb;
}
var Qb, W$;
function rte() {
  if (W$)
    return Qb;
  W$ = 1;
  const e = _t, t = ut, {
    isReadable: r,
    isWritable: n,
    isIterable: o,
    isNodeStream: s,
    isReadableNodeStream: a,
    isWritableNodeStream: l,
    isDuplexNodeStream: u,
    isReadableStream: f,
    isWritableStream: c
  } = Ro, d = vs, {
    AbortError: h,
    codes: { ERR_INVALID_ARG_TYPE: p, ERR_INVALID_RETURN_VALUE: m }
  } = on, { destroyer: y } = du, _ = ao(), S = Up(), x = yx(), { createDeferredPromise: E } = Hr, C = pF, I = globalThis.Blob || t.Blob, j = typeof I < "u" ? function(k) {
    return k instanceof I;
  } : function(k) {
    return !1;
  }, J = globalThis.AbortController || Kt().AbortController, { FunctionPrototypeCall: G } = jt;
  class $ extends _ {
    constructor(k) {
      super(k), (k == null ? void 0 : k.readable) === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), (k == null ? void 0 : k.writable) === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0);
    }
  }
  Qb = function W(k, U) {
    if (u(k))
      return k;
    if (a(k))
      return M({
        readable: k
      });
    if (l(k))
      return M({
        writable: k
      });
    if (s(k))
      return M({
        writable: !1,
        readable: !1
      });
    if (f(k))
      return M({
        readable: S.fromWeb(k)
      });
    if (c(k))
      return M({
        writable: x.fromWeb(k)
      });
    if (typeof k == "function") {
      const { value: Y, write: te, final: se, destroy: fe } = V(k);
      if (o(Y))
        return C($, Y, {
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          write: te,
          final: se,
          destroy: fe
        });
      const he = Y == null ? void 0 : Y.then;
      if (typeof he == "function") {
        let ae;
        const be = G(
          he,
          Y,
          (H) => {
            if (H != null)
              throw new m("nully", "body", H);
          },
          (H) => {
            y(ae, H);
          }
        );
        return ae = new $({
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          readable: !1,
          write: te,
          final(H) {
            se(async () => {
              try {
                await be, e.nextTick(H, null);
              } catch (pe) {
                e.nextTick(H, pe);
              }
            });
          },
          destroy: fe
        });
      }
      throw new m("Iterable, AsyncIterable or AsyncFunction", U, Y);
    }
    if (j(k))
      return W(k.arrayBuffer());
    if (o(k))
      return C($, k, {
        // TODO (ronag): highWaterMark?
        objectMode: !0,
        writable: !1
      });
    if (f(k == null ? void 0 : k.readable) && c(k == null ? void 0 : k.writable))
      return $.fromWeb(k);
    if (typeof (k == null ? void 0 : k.writable) == "object" || typeof (k == null ? void 0 : k.readable) == "object") {
      const Y = k != null && k.readable ? a(k == null ? void 0 : k.readable) ? k == null ? void 0 : k.readable : W(k.readable) : void 0, te = k != null && k.writable ? l(k == null ? void 0 : k.writable) ? k == null ? void 0 : k.writable : W(k.writable) : void 0;
      return M({
        readable: Y,
        writable: te
      });
    }
    const Z = k == null ? void 0 : k.then;
    if (typeof Z == "function") {
      let Y;
      return G(
        Z,
        k,
        (te) => {
          te != null && Y.push(te), Y.push(null);
        },
        (te) => {
          y(Y, te);
        }
      ), Y = new $({
        objectMode: !0,
        writable: !1,
        read() {
        }
      });
    }
    throw new p(
      U,
      [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise"
      ],
      k
    );
  };
  function V(W) {
    let { promise: k, resolve: U } = E();
    const Z = new J(), Y = Z.signal;
    return {
      value: W(
        async function* () {
          for (; ; ) {
            const se = k;
            k = null;
            const { chunk: fe, done: he, cb: ae } = await se;
            if (e.nextTick(ae), he)
              return;
            if (Y.aborted)
              throw new h(void 0, {
                cause: Y.reason
              });
            ({ promise: k, resolve: U } = E()), yield fe;
          }
        }(),
        {
          signal: Y
        }
      ),
      write(se, fe, he) {
        const ae = U;
        U = null, ae({
          chunk: se,
          done: !1,
          cb: he
        });
      },
      final(se) {
        const fe = U;
        U = null, fe({
          done: !0,
          cb: se
        });
      },
      destroy(se, fe) {
        Z.abort(), fe(se);
      }
    };
  }
  function M(W) {
    const k = W.readable && typeof W.readable.read != "function" ? S.wrap(W.readable) : W.readable, U = W.writable;
    let Z = !!r(k), Y = !!n(U), te, se, fe, he, ae;
    function be(H) {
      const pe = he;
      he = null, pe ? pe(H) : H && ae.destroy(H);
    }
    return ae = new $({
      // TODO (ronag): highWaterMark?
      readableObjectMode: !!(k != null && k.readableObjectMode),
      writableObjectMode: !!(U != null && U.writableObjectMode),
      readable: Z,
      writable: Y
    }), Y && (d(U, (H) => {
      Y = !1, H && y(k, H), be(H);
    }), ae._write = function(H, pe, ke) {
      U.write(H, pe) ? ke() : te = ke;
    }, ae._final = function(H) {
      U.end(), se = H;
    }, U.on("drain", function() {
      if (te) {
        const H = te;
        te = null, H();
      }
    }), U.on("finish", function() {
      if (se) {
        const H = se;
        se = null, H();
      }
    })), Z && (d(k, (H) => {
      Z = !1, H && y(k, H), be(H);
    }), k.on("readable", function() {
      if (fe) {
        const H = fe;
        fe = null, H();
      }
    }), k.on("end", function() {
      ae.push(null);
    }), ae._read = function() {
      for (; ; ) {
        const H = k.read();
        if (H === null) {
          fe = ae._read;
          return;
        }
        if (!ae.push(H))
          return;
      }
    }), ae._destroy = function(H, pe) {
      !H && he !== null && (H = new h()), fe = null, te = null, se = null, he === null ? pe(H) : (he = pe, y(U, H), y(k, H));
    }, ae;
  }
  return Qb;
}
var Zb, U$;
function ao() {
  if (U$)
    return Zb;
  U$ = 1;
  const {
    ObjectDefineProperties: e,
    ObjectGetOwnPropertyDescriptor: t,
    ObjectKeys: r,
    ObjectSetPrototypeOf: n
  } = jt;
  Zb = a;
  const o = Up(), s = yx();
  n(a.prototype, o.prototype), n(a, o);
  {
    const c = r(s.prototype);
    for (let d = 0; d < c.length; d++) {
      const h = c[d];
      a.prototype[h] || (a.prototype[h] = s.prototype[h]);
    }
  }
  function a(c) {
    if (!(this instanceof a))
      return new a(c);
    o.call(this, c), s.call(this, c), c ? (this.allowHalfOpen = c.allowHalfOpen !== !1, c.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), c.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0)) : this.allowHalfOpen = !0;
  }
  e(a.prototype, {
    writable: {
      __proto__: null,
      ...t(s.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...t(s.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...t(s.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...t(s.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...t(s.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...t(s.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...t(s.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...t(s.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...t(s.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
      },
      set(c) {
        this._readableState && this._writableState && (this._readableState.destroyed = c, this._writableState.destroyed = c);
      }
    }
  });
  let l;
  function u() {
    return l === void 0 && (l = {}), l;
  }
  a.fromWeb = function(c, d) {
    return u().newStreamDuplexFromReadableWritablePair(c, d);
  }, a.toWeb = function(c) {
    return u().newReadableWritablePairFromDuplex(c);
  };
  let f;
  return a.from = function(c) {
    return f || (f = rte()), f(c, "body");
  }, Zb;
}
const { ObjectSetPrototypeOf: gF, Symbol: nte } = jt;
var bF = lo;
const { ERR_METHOD_NOT_IMPLEMENTED: ite } = on.codes, mx = ao(), { getHighWaterMark: ote } = Wp;
gF(lo.prototype, mx.prototype);
gF(lo, mx);
const _f = nte("kCallback");
function lo(e) {
  if (!(this instanceof lo))
    return new lo(e);
  const t = e ? ote(this, e, "readableHighWaterMark", !0) : null;
  t === 0 && (e = {
    ...e,
    highWaterMark: null,
    readableHighWaterMark: t,
    // TODO (ronag): 0 is not optimal since we have
    // a "bug" where we check needDrain before calling _write and not after.
    // Refs: https://github.com/nodejs/node/pull/32887
    // Refs: https://github.com/nodejs/node/pull/35941
    writableHighWaterMark: e.writableHighWaterMark || 0
  }), mx.call(this, e), this._readableState.sync = !1, this[_f] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", ste);
}
function aS(e) {
  typeof this._flush == "function" && !this.destroyed ? this._flush((t, r) => {
    if (t) {
      e ? e(t) : this.destroy(t);
      return;
    }
    r != null && this.push(r), this.push(null), e && e();
  }) : (this.push(null), e && e());
}
function ste() {
  this._final !== aS && aS.call(this);
}
lo.prototype._final = aS;
lo.prototype._transform = function(e, t, r) {
  throw new ite("_transform()");
};
lo.prototype._write = function(e, t, r) {
  const n = this._readableState, o = this._writableState, s = n.length;
  this._transform(e, t, (a, l) => {
    if (a) {
      r(a);
      return;
    }
    l != null && this.push(l), o.ended || // Backwards compat.
    s === n.length || // Backwards compat.
    n.length < n.highWaterMark ? r() : this[_f] = r;
  });
};
lo.prototype._read = function() {
  if (this[_f]) {
    const e = this[_f];
    this[_f] = null, e();
  }
};
const { ObjectSetPrototypeOf: yF } = jt;
var mF = Gl;
const vx = bF;
yF(Gl.prototype, vx.prototype);
yF(Gl, vx);
function Gl(e) {
  if (!(this instanceof Gl))
    return new Gl(e);
  vx.call(this, e);
}
Gl.prototype._transform = function(e, t, r) {
  r(null, e);
};
const Yu = _t, { ArrayIsArray: ate, Promise: lte, SymbolAsyncIterator: ute, SymbolDispose: fte } = jt, yh = vs, { once: cte } = Hr, dte = du, H$ = ao(), {
  aggregateTwoErrors: hte,
  codes: {
    ERR_INVALID_ARG_TYPE: lS,
    ERR_INVALID_RETURN_VALUE: ey,
    ERR_MISSING_ARGS: pte,
    ERR_STREAM_DESTROYED: gte,
    ERR_STREAM_PREMATURE_CLOSE: bte
  },
  AbortError: yte
} = on, { validateFunction: mte, validateAbortSignal: vte } = yc, {
  isIterable: Bs,
  isReadable: ty,
  isReadableNodeStream: Fd,
  isNodeStream: z$,
  isTransformStream: yl,
  isWebStream: wte,
  isReadableStream: ry,
  isReadableFinished: _te
} = Ro, Ste = globalThis.AbortController || Kt().AbortController;
let ny, iy, oy;
function G$(e, t, r) {
  let n = !1;
  e.on("close", () => {
    n = !0;
  });
  const o = yh(
    e,
    {
      readable: t,
      writable: r
    },
    (s) => {
      n = !s;
    }
  );
  return {
    destroy: (s) => {
      n || (n = !0, dte.destroyer(e, s || new gte("pipe")));
    },
    cleanup: o
  };
}
function Ete(e) {
  return mte(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
}
function sy(e) {
  if (Bs(e))
    return e;
  if (Fd(e))
    return xte(e);
  throw new lS("val", ["Readable", "Iterable", "AsyncIterable"], e);
}
async function* xte(e) {
  iy || (iy = Up()), yield* iy.prototype[ute].call(e);
}
async function ed(e, t, r, { end: n }) {
  let o, s = null;
  const a = (f) => {
    if (f && (o = f), s) {
      const c = s;
      s = null, c();
    }
  }, l = () => new lte((f, c) => {
    o ? c(o) : s = () => {
      o ? c(o) : f();
    };
  });
  t.on("drain", a);
  const u = yh(
    t,
    {
      readable: !1
    },
    a
  );
  try {
    t.writableNeedDrain && await l();
    for await (const f of e)
      t.write(f) || await l();
    n && (t.end(), await l()), r();
  } catch (f) {
    r(o !== f ? hte(o, f) : f);
  } finally {
    u(), t.off("drain", a);
  }
}
async function ay(e, t, r, { end: n }) {
  yl(t) && (t = t.writable);
  const o = t.getWriter();
  try {
    for await (const s of e)
      await o.ready, o.write(s).catch(() => {
      });
    await o.ready, n && await o.close(), r();
  } catch (s) {
    try {
      await o.abort(s), r(s);
    } catch (a) {
      r(a);
    }
  }
}
function Rte(...e) {
  return vF(e, cte(Ete(e)));
}
function vF(e, t, r) {
  if (e.length === 1 && ate(e[0]) && (e = e[0]), e.length < 2)
    throw new pte("streams");
  const n = new Ste(), o = n.signal, s = r == null ? void 0 : r.signal, a = [];
  vte(s, "options.signal");
  function l() {
    m(new yte());
  }
  oy = oy || Hr.addAbortListener;
  let u;
  s && (u = oy(s, l));
  let f, c;
  const d = [];
  let h = 0;
  function p(x) {
    m(x, --h === 0);
  }
  function m(x, E) {
    var C;
    if (x && (!f || f.code === "ERR_STREAM_PREMATURE_CLOSE") && (f = x), !(!f && !E)) {
      for (; d.length; )
        d.shift()(f);
      (C = u) === null || C === void 0 || C[fte](), n.abort(), E && (f || a.forEach((I) => I()), Yu.nextTick(t, f, c));
    }
  }
  let y;
  for (let x = 0; x < e.length; x++) {
    const E = e[x], C = x < e.length - 1, I = x > 0, j = C || (r == null ? void 0 : r.end) !== !1, J = x === e.length - 1;
    if (z$(E)) {
      let G = function($) {
        $ && $.name !== "AbortError" && $.code !== "ERR_STREAM_PREMATURE_CLOSE" && p($);
      };
      if (j) {
        const { destroy: $, cleanup: V } = G$(E, C, I);
        d.push($), ty(E) && J && a.push(V);
      }
      E.on("error", G), ty(E) && J && a.push(() => {
        E.removeListener("error", G);
      });
    }
    if (x === 0)
      if (typeof E == "function") {
        if (y = E({
          signal: o
        }), !Bs(y))
          throw new ey("Iterable, AsyncIterable or Stream", "source", y);
      } else
        Bs(E) || Fd(E) || yl(E) ? y = E : y = H$.from(E);
    else if (typeof E == "function") {
      if (yl(y)) {
        var _;
        y = sy((_ = y) === null || _ === void 0 ? void 0 : _.readable);
      } else
        y = sy(y);
      if (y = E(y, {
        signal: o
      }), C) {
        if (!Bs(y, !0))
          throw new ey("AsyncIterable", `transform[${x - 1}]`, y);
      } else {
        var S;
        ny || (ny = mF);
        const G = new ny({
          objectMode: !0
        }), $ = (S = y) === null || S === void 0 ? void 0 : S.then;
        if (typeof $ == "function")
          h++, $.call(
            y,
            (W) => {
              c = W, W != null && G.write(W), j && G.end(), Yu.nextTick(p);
            },
            (W) => {
              G.destroy(W), Yu.nextTick(p, W);
            }
          );
        else if (Bs(y, !0))
          h++, ed(y, G, p, {
            end: j
          });
        else if (ry(y) || yl(y)) {
          const W = y.readable || y;
          h++, ed(W, G, p, {
            end: j
          });
        } else
          throw new ey("AsyncIterable or Promise", "destination", y);
        y = G;
        const { destroy: V, cleanup: M } = G$(y, !1, !0);
        d.push(V), J && a.push(M);
      }
    } else if (z$(E)) {
      if (Fd(y)) {
        h += 2;
        const G = Ate(y, E, p, {
          end: j
        });
        ty(E) && J && a.push(G);
      } else if (yl(y) || ry(y)) {
        const G = y.readable || y;
        h++, ed(G, E, p, {
          end: j
        });
      } else if (Bs(y))
        h++, ed(y, E, p, {
          end: j
        });
      else
        throw new lS(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          y
        );
      y = E;
    } else if (wte(E)) {
      if (Fd(y))
        h++, ay(sy(y), E, p, {
          end: j
        });
      else if (ry(y) || Bs(y))
        h++, ay(y, E, p, {
          end: j
        });
      else if (yl(y))
        h++, ay(y.readable, E, p, {
          end: j
        });
      else
        throw new lS(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          y
        );
      y = E;
    } else
      y = H$.from(E);
  }
  return (o != null && o.aborted || s != null && s.aborted) && Yu.nextTick(l), y;
}
function Ate(e, t, r, { end: n }) {
  let o = !1;
  if (t.on("close", () => {
    o || r(new bte());
  }), e.pipe(t, {
    end: !1
  }), n) {
    let s = function() {
      o = !0, t.end();
    };
    _te(e) ? Yu.nextTick(s) : e.once("end", s);
  } else
    r();
  return yh(
    e,
    {
      readable: !0,
      writable: !1
    },
    (s) => {
      const a = e._readableState;
      s && s.code === "ERR_STREAM_PREMATURE_CLOSE" && a && a.ended && !a.errored && !a.errorEmitted ? e.once("end", r).once("error", r) : r(s);
    }
  ), yh(
    t,
    {
      readable: !1,
      writable: !0
    },
    r
  );
}
var wx = {
  pipelineImpl: vF,
  pipeline: Rte
};
const { pipeline: Tte } = wx, td = ao(), { destroyer: $te } = du, {
  isNodeStream: rd,
  isReadable: V$,
  isWritable: K$,
  isWebStream: ly,
  isTransformStream: Ns,
  isWritableStream: Y$,
  isReadableStream: X$
} = Ro, {
  AbortError: Cte,
  codes: { ERR_INVALID_ARG_VALUE: J$, ERR_MISSING_ARGS: kte }
} = on, Ite = vs;
var wF = function(...t) {
  if (t.length === 0)
    throw new kte("streams");
  if (t.length === 1)
    return td.from(t[0]);
  const r = [...t];
  if (typeof t[0] == "function" && (t[0] = td.from(t[0])), typeof t[t.length - 1] == "function") {
    const p = t.length - 1;
    t[p] = td.from(t[p]);
  }
  for (let p = 0; p < t.length; ++p)
    if (!(!rd(t[p]) && !ly(t[p]))) {
      if (p < t.length - 1 && !(V$(t[p]) || X$(t[p]) || Ns(t[p])))
        throw new J$(`streams[${p}]`, r[p], "must be readable");
      if (p > 0 && !(K$(t[p]) || Y$(t[p]) || Ns(t[p])))
        throw new J$(`streams[${p}]`, r[p], "must be writable");
    }
  let n, o, s, a, l;
  function u(p) {
    const m = a;
    a = null, m ? m(p) : p ? l.destroy(p) : !h && !d && l.destroy();
  }
  const f = t[0], c = Tte(t, u), d = !!(K$(f) || Y$(f) || Ns(f)), h = !!(V$(c) || X$(c) || Ns(c));
  if (l = new td({
    // TODO (ronag): highWaterMark?
    writableObjectMode: !!(f != null && f.writableObjectMode),
    readableObjectMode: !!(c != null && c.readableObjectMode),
    writable: d,
    readable: h
  }), d) {
    if (rd(f))
      l._write = function(m, y, _) {
        f.write(m, y) ? _() : n = _;
      }, l._final = function(m) {
        f.end(), o = m;
      }, f.on("drain", function() {
        if (n) {
          const m = n;
          n = null, m();
        }
      });
    else if (ly(f)) {
      const y = (Ns(f) ? f.writable : f).getWriter();
      l._write = async function(_, S, x) {
        try {
          await y.ready, y.write(_).catch(() => {
          }), x();
        } catch (E) {
          x(E);
        }
      }, l._final = async function(_) {
        try {
          await y.ready, y.close().catch(() => {
          }), o = _;
        } catch (S) {
          _(S);
        }
      };
    }
    const p = Ns(c) ? c.readable : c;
    Ite(p, () => {
      if (o) {
        const m = o;
        o = null, m();
      }
    });
  }
  if (h) {
    if (rd(c))
      c.on("readable", function() {
        if (s) {
          const p = s;
          s = null, p();
        }
      }), c.on("end", function() {
        l.push(null);
      }), l._read = function() {
        for (; ; ) {
          const p = c.read();
          if (p === null) {
            s = l._read;
            return;
          }
          if (!l.push(p))
            return;
        }
      };
    else if (ly(c)) {
      const m = (Ns(c) ? c.readable : c).getReader();
      l._read = async function() {
        for (; ; )
          try {
            const { value: y, done: _ } = await m.read();
            if (!l.push(y))
              return;
            if (_) {
              l.push(null);
              return;
            }
          } catch {
            return;
          }
      };
    }
  }
  return l._destroy = function(p, m) {
    !p && a !== null && (p = new Cte()), s = null, n = null, o = null, a === null ? m(p) : (a = m, rd(c) && $te(c, p));
  }, l;
};
const Mte = globalThis.AbortController || Kt().AbortController, {
  codes: { ERR_INVALID_ARG_VALUE: Nte, ERR_INVALID_ARG_TYPE: mc, ERR_MISSING_ARGS: Lte, ERR_OUT_OF_RANGE: Ote },
  AbortError: $i
} = on, { validateAbortSignal: Ua, validateInteger: Q$, validateObject: Ha } = yc, Pte = jt.Symbol("kWeak"), Dte = jt.Symbol("kResistStopPropagation"), { finished: Fte } = vs, jte = wF, { addAbortSignalNoValidate: Bte } = qp, { isWritable: qte, isNodeStream: Wte } = Ro, { deprecate: Ute } = Hr, {
  ArrayPrototypePush: Hte,
  Boolean: zte,
  MathFloor: Z$,
  Number: Gte,
  NumberIsNaN: Vte,
  Promise: eC,
  PromiseReject: tC,
  PromiseResolve: Kte,
  PromisePrototypeThen: rC,
  Symbol: _F
} = jt, mh = _F("kEmpty"), nC = _F("kEof");
function Yte(e, t) {
  if (t != null && Ha(t, "options"), (t == null ? void 0 : t.signal) != null && Ua(t.signal, "options.signal"), Wte(e) && !qte(e))
    throw new Nte("stream", e, "must be writable");
  const r = jte(this, e);
  return t != null && t.signal && Bte(t.signal, r), r;
}
function Hp(e, t) {
  if (typeof e != "function")
    throw new mc("fn", ["Function", "AsyncFunction"], e);
  t != null && Ha(t, "options"), (t == null ? void 0 : t.signal) != null && Ua(t.signal, "options.signal");
  let r = 1;
  (t == null ? void 0 : t.concurrency) != null && (r = Z$(t.concurrency));
  let n = r - 1;
  return (t == null ? void 0 : t.highWaterMark) != null && (n = Z$(t.highWaterMark)), Q$(r, "options.concurrency", 1), Q$(n, "options.highWaterMark", 0), n += r, (async function* () {
    const s = Hr.AbortSignalAny(
      [t == null ? void 0 : t.signal].filter(zte)
    ), a = this, l = [], u = {
      signal: s
    };
    let f, c, d = !1, h = 0;
    function p() {
      d = !0, m();
    }
    function m() {
      h -= 1, y();
    }
    function y() {
      c && !d && h < r && l.length < n && (c(), c = null);
    }
    async function _() {
      try {
        for await (let S of a) {
          if (d)
            return;
          if (s.aborted)
            throw new $i();
          try {
            if (S = e(S, u), S === mh)
              continue;
            S = Kte(S);
          } catch (x) {
            S = tC(x);
          }
          h += 1, rC(S, m, p), l.push(S), f && (f(), f = null), !d && (l.length >= n || h >= r) && await new eC((x) => {
            c = x;
          });
        }
        l.push(nC);
      } catch (S) {
        const x = tC(S);
        rC(x, m, p), l.push(x);
      } finally {
        d = !0, f && (f(), f = null);
      }
    }
    _();
    try {
      for (; ; ) {
        for (; l.length > 0; ) {
          const S = await l[0];
          if (S === nC)
            return;
          if (s.aborted)
            throw new $i();
          S !== mh && (yield S), l.shift(), y();
        }
        await new eC((S) => {
          f = S;
        });
      }
    } finally {
      d = !0, c && (c(), c = null);
    }
  }).call(this);
}
function Xte(e = void 0) {
  return e != null && Ha(e, "options"), (e == null ? void 0 : e.signal) != null && Ua(e.signal, "options.signal"), (async function* () {
    let r = 0;
    for await (const o of this) {
      var n;
      if (e != null && (n = e.signal) !== null && n !== void 0 && n.aborted)
        throw new $i({
          cause: e.signal.reason
        });
      yield [r++, o];
    }
  }).call(this);
}
async function SF(e, t = void 0) {
  for await (const r of _x.call(this, e, t))
    return !0;
  return !1;
}
async function Jte(e, t = void 0) {
  if (typeof e != "function")
    throw new mc("fn", ["Function", "AsyncFunction"], e);
  return !await SF.call(
    this,
    async (...r) => !await e(...r),
    t
  );
}
async function Qte(e, t) {
  for await (const r of _x.call(this, e, t))
    return r;
}
async function Zte(e, t) {
  if (typeof e != "function")
    throw new mc("fn", ["Function", "AsyncFunction"], e);
  async function r(n, o) {
    return await e(n, o), mh;
  }
  for await (const n of Hp.call(this, r, t))
    ;
}
function _x(e, t) {
  if (typeof e != "function")
    throw new mc("fn", ["Function", "AsyncFunction"], e);
  async function r(n, o) {
    return await e(n, o) ? n : mh;
  }
  return Hp.call(this, r, t);
}
let ere = class extends Lte {
  constructor() {
    super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
  }
};
async function tre(e, t, r) {
  var n;
  if (typeof e != "function")
    throw new mc("reducer", ["Function", "AsyncFunction"], e);
  r != null && Ha(r, "options"), (r == null ? void 0 : r.signal) != null && Ua(r.signal, "options.signal");
  let o = arguments.length > 1;
  if (r != null && (n = r.signal) !== null && n !== void 0 && n.aborted) {
    const f = new $i(void 0, {
      cause: r.signal.reason
    });
    throw this.once("error", () => {
    }), await Fte(this.destroy(f)), f;
  }
  const s = new Mte(), a = s.signal;
  if (r != null && r.signal) {
    const f = {
      once: !0,
      [Pte]: this,
      [Dte]: !0
    };
    r.signal.addEventListener("abort", () => s.abort(), f);
  }
  let l = !1;
  try {
    for await (const f of this) {
      var u;
      if (l = !0, r != null && (u = r.signal) !== null && u !== void 0 && u.aborted)
        throw new $i();
      o ? t = await e(t, f, {
        signal: a
      }) : (t = f, o = !0);
    }
    if (!l && !o)
      throw new ere();
  } finally {
    s.abort();
  }
  return t;
}
async function rre(e) {
  e != null && Ha(e, "options"), (e == null ? void 0 : e.signal) != null && Ua(e.signal, "options.signal");
  const t = [];
  for await (const n of this) {
    var r;
    if (e != null && (r = e.signal) !== null && r !== void 0 && r.aborted)
      throw new $i(void 0, {
        cause: e.signal.reason
      });
    Hte(t, n);
  }
  return t;
}
function nre(e, t) {
  const r = Hp.call(this, e, t);
  return (async function* () {
    for await (const o of r)
      yield* o;
  }).call(this);
}
function EF(e) {
  if (e = Gte(e), Vte(e))
    return 0;
  if (e < 0)
    throw new Ote("number", ">= 0", e);
  return e;
}
function ire(e, t = void 0) {
  return t != null && Ha(t, "options"), (t == null ? void 0 : t.signal) != null && Ua(t.signal, "options.signal"), e = EF(e), (async function* () {
    var n;
    if (t != null && (n = t.signal) !== null && n !== void 0 && n.aborted)
      throw new $i();
    for await (const s of this) {
      var o;
      if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
        throw new $i();
      e-- <= 0 && (yield s);
    }
  }).call(this);
}
function ore(e, t = void 0) {
  return t != null && Ha(t, "options"), (t == null ? void 0 : t.signal) != null && Ua(t.signal, "options.signal"), e = EF(e), (async function* () {
    var n;
    if (t != null && (n = t.signal) !== null && n !== void 0 && n.aborted)
      throw new $i();
    for await (const s of this) {
      var o;
      if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
        throw new $i();
      if (e-- > 0 && (yield s), e <= 0)
        return;
    }
  }).call(this);
}
cx.streamReturningOperators = {
  asIndexedPairs: Ute(Xte, "readable.asIndexedPairs will be removed in a future version."),
  drop: ire,
  filter: _x,
  flatMap: nre,
  map: Hp,
  take: ore,
  compose: Yte
};
cx.promiseReturningOperators = {
  every: Jte,
  forEach: Zte,
  reduce: tre,
  toArray: rre,
  some: SF,
  find: Qte
};
var uy, iC;
function xF() {
  if (iC)
    return uy;
  iC = 1;
  const { ArrayPrototypePop: e, Promise: t } = jt, { isIterable: r, isNodeStream: n, isWebStream: o } = Ro, { pipelineImpl: s } = wx, { finished: a } = vs;
  RF();
  function l(...u) {
    return new t((f, c) => {
      let d, h;
      const p = u[u.length - 1];
      if (p && typeof p == "object" && !n(p) && !r(p) && !o(p)) {
        const m = e(u);
        d = m.signal, h = m.end;
      }
      s(
        u,
        (m, y) => {
          m ? c(m) : f(y);
        },
        {
          signal: d,
          end: h
        }
      );
    });
  }
  return uy = {
    finished: a,
    pipeline: l
  }, uy;
}
var oC;
function RF() {
  if (oC)
    return Gb.exports;
  oC = 1;
  const { Buffer: e } = ut, { ObjectDefineProperty: t, ObjectKeys: r, ReflectApply: n } = jt, {
    promisify: { custom: o }
  } = Hr, { streamReturningOperators: s, promiseReturningOperators: a } = cx, {
    codes: { ERR_ILLEGAL_CONSTRUCTOR: l }
  } = on, u = wF, { setDefaultHighWaterMark: f, getDefaultHighWaterMark: c } = Wp, { pipeline: d } = wx, { destroyer: h } = du, p = vs, m = xF(), y = Ro, _ = Gb.exports = bx.Stream;
  _.isDestroyed = y.isDestroyed, _.isDisturbed = y.isDisturbed, _.isErrored = y.isErrored, _.isReadable = y.isReadable, _.isWritable = y.isWritable, _.Readable = Up();
  for (const x of r(s)) {
    let C = function(...I) {
      if (new.target)
        throw l();
      return _.Readable.from(n(E, this, I));
    };
    const E = s[x];
    t(C, "name", {
      __proto__: null,
      value: E.name
    }), t(C, "length", {
      __proto__: null,
      value: E.length
    }), t(_.Readable.prototype, x, {
      __proto__: null,
      value: C,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  for (const x of r(a)) {
    let C = function(...I) {
      if (new.target)
        throw l();
      return n(E, this, I);
    };
    const E = a[x];
    t(C, "name", {
      __proto__: null,
      value: E.name
    }), t(C, "length", {
      __proto__: null,
      value: E.length
    }), t(_.Readable.prototype, x, {
      __proto__: null,
      value: C,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  _.Writable = yx(), _.Duplex = ao(), _.Transform = bF, _.PassThrough = mF, _.pipeline = d;
  const { addAbortSignal: S } = qp;
  return _.addAbortSignal = S, _.finished = p, _.destroy = h, _.compose = u, _.setDefaultHighWaterMark = f, _.getDefaultHighWaterMark = c, t(_, "promises", {
    __proto__: null,
    configurable: !0,
    enumerable: !0,
    get() {
      return m;
    }
  }), t(d, o, {
    __proto__: null,
    enumerable: !0,
    get() {
      return m.pipeline;
    }
  }), t(p, o, {
    __proto__: null,
    enumerable: !0,
    get() {
      return m.finished;
    }
  }), _.Stream = _, _._isUint8Array = function(E) {
    return E instanceof Uint8Array;
  }, _._uint8ArrayToBuffer = function(E) {
    return e.from(E.buffer, E.byteOffset, E.byteLength);
  }, Gb.exports;
}
(function(e) {
  const t = RF(), r = xF(), n = t.Readable.destroy;
  e.exports = t.Readable, e.exports._uint8ArrayToBuffer = t._uint8ArrayToBuffer, e.exports._isUint8Array = t._isUint8Array, e.exports.isDisturbed = t.isDisturbed, e.exports.isErrored = t.isErrored, e.exports.isReadable = t.isReadable, e.exports.Readable = t.Readable, e.exports.Writable = t.Writable, e.exports.Duplex = t.Duplex, e.exports.Transform = t.Transform, e.exports.PassThrough = t.PassThrough, e.exports.addAbortSignal = t.addAbortSignal, e.exports.finished = t.finished, e.exports.destroy = t.destroy, e.exports.destroy = n, e.exports.pipeline = t.pipeline, e.exports.compose = t.compose, Object.defineProperty(t, "promises", {
    configurable: !0,
    enumerable: !0,
    get() {
      return r;
    }
  }), e.exports.Stream = t.Stream, e.exports.default = e.exports;
})(O5);
var AF = O5.exports;
function sC(e) {
  const t = new AF.PassThrough({ objectMode: !0 });
  return setTimeout(async () => {
    try {
      (await e()).pipe(t);
    } catch (r) {
      t.destroy(r);
    }
  }, 0), AD(t);
}
async function nd(e) {
  if (e.ok)
    return;
  const t = await e.text(), r = new Error(`${e.statusText} (${e.status}): ${t}`);
  throw r.status = e.status, r;
}
function Xo(...e) {
  const t = new Headers();
  for (const r of e) {
    if (!r)
      continue;
    const n = r.entries ? r.entries() : Object.entries(r);
    for (const [o, s] of n)
      t.set(o, s);
  }
  return t;
}
class TF {
  /**
   * @param {Object} options
   * @param {SimpleClient} options.client client that provides the HTTP I/O
   */
  constructor({ client: t }) {
    this.client = t;
  }
  /**
   * Sends a request for a ASK query
   *
   * @param {string} query ASK query
   * @param {Object} [options]
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='get'] SPARQL Protocol operation
   * @return {Promise<Response>}
   */
  async ask(t, { headers: r, operation: n = "get" } = {}) {
    return r = Xo(r), r.has("accept") || r.set("accept", "application/sparql-results+json"), this.client[n](t, { headers: r });
  }
  /**
   * Sends a request for a CONSTRUCT or DESCRIBE query
   *
   * @param {string} query CONSTRUCT or DESCRIBE query
   * @param {Object} [options]
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='get'] SPARQL Protocol operation
   * @return {Promise<Response>}
   */
  async construct(t, { headers: r, operation: n = "get" } = {}) {
    return r = Xo(r), r.has("accept") || r.set("accept", "application/n-triples"), this.client[n](t, { headers: r });
  }
  /**
   * Sends a request for a SELECT query
   *
   * @param {string} query SELECT query
   * @param {Object} [options]
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='get'] SPARQL Protocol operation
   * @return {Promise<Response>}
   */
  async select(t, { headers: r, operation: n = "get" } = {}) {
    return r = Xo(r), r.has("accept") || r.set("accept", "application/sparql-results+json"), this.client[n](t, { headers: r });
  }
  /**
   * Sends a request for an update query
   *
   * @param {string} query update query
   * @param {Object} [options]
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='postUrlencoded'] SPARQL Protocol operation
   * @return {Promise<Response>}
   */
  async update(t, { headers: r, operation: n = "postUrlencoded" } = {}) {
    return r = Xo(r), r.has("accept") || r.set("accept", "*/*"), this.client[n](t, { headers: r, update: !0 });
  }
}
var { Buffer: Go } = ut, st = {}, $F = st.LEFT_BRACE = 1, jd = st.RIGHT_BRACE = 2, CF = st.LEFT_BRACKET = 3, uS = st.RIGHT_BRACKET = 4, Bd = st.COLON = 5, vh = st.COMMA = 6, kF = st.TRUE = 7, IF = st.FALSE = 8, MF = st.NULL = 9, wh = st.STRING = 10, NF = st.NUMBER = 11, qs = st.START = 17, LF = st.STOP = 18, aC = st.TRUE1 = 33, lC = st.TRUE2 = 34, uC = st.TRUE3 = 35, fC = st.FALSE1 = 49, cC = st.FALSE2 = 50, dC = st.FALSE3 = 51, hC = st.FALSE4 = 52, pC = st.NULL1 = 65, gC = st.NULL2 = 66, bC = st.NULL3 = 67, yC = st.NUMBER1 = 81, fy = st.NUMBER3 = 83, Dn = st.STRING1 = 97, mC = st.STRING2 = 98, vC = st.STRING3 = 99, sre = st.STRING4 = 100, are = st.STRING5 = 101, wC = st.STRING6 = 102, El = st.VALUE = 113, cy = st.KEY = 114, id = st.OBJECT = 129, od = st.ARRAY = 130, lre = 92, ure = 47, fre = 8, cre = 12, dre = 10, hre = 13, pre = 9, Sx = 64 * 1024;
function sd(e) {
  return Go.alloc ? Go.alloc(e) : new Go(e);
}
function ls() {
  this.tState = qs, this.value = void 0, this.string = void 0, this.stringBuffer = sd(Sx), this.stringBufferOffset = 0, this.unicode = void 0, this.highSurrogate = void 0, this.key = void 0, this.mode = void 0, this.stack = [], this.state = El, this.bytes_remaining = 0, this.bytes_in_sequence = 0, this.temp_buffs = { 2: sd(2), 3: sd(3), 4: sd(4) }, this.offset = -1;
}
ls.toknam = function(e) {
  for (var t = Object.keys(st), r = 0, n = t.length; r < n; r++) {
    var o = t[r];
    if (st[o] === e)
      return o;
  }
  return e && "0x" + e.toString(16);
};
var gn = ls.prototype;
gn.onError = function(e) {
  throw e;
};
gn.charError = function(e, t) {
  this.tState = LF, this.onError(new Error("Unexpected " + JSON.stringify(String.fromCharCode(e[t])) + " at position " + t + " in state " + ls.toknam(this.tState)));
};
gn.appendStringChar = function(e) {
  this.stringBufferOffset >= Sx && (this.string += this.stringBuffer.toString("utf8"), this.stringBufferOffset = 0), this.stringBuffer[this.stringBufferOffset++] = e;
};
gn.appendStringBuf = function(e, t, r) {
  var n = e.length;
  typeof t == "number" && (typeof r == "number" ? r < 0 ? n = e.length - t + r : n = r - t : n = e.length - t), n < 0 && (n = 0), this.stringBufferOffset + n > Sx && (this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset), this.stringBufferOffset = 0), e.copy(this.stringBuffer, this.stringBufferOffset, t, r), this.stringBufferOffset += n;
};
gn.write = function(e) {
  typeof e == "string" && (e = new Go(e));
  for (var t, r = 0, n = e.length; r < n; r++)
    if (this.tState === qs) {
      if (t = e[r], this.offset++, t === 123)
        this.onToken($F, "{");
      else if (t === 125)
        this.onToken(jd, "}");
      else if (t === 91)
        this.onToken(CF, "[");
      else if (t === 93)
        this.onToken(uS, "]");
      else if (t === 58)
        this.onToken(Bd, ":");
      else if (t === 44)
        this.onToken(vh, ",");
      else if (t === 116)
        this.tState = aC;
      else if (t === 102)
        this.tState = fC;
      else if (t === 110)
        this.tState = pC;
      else if (t === 34)
        this.string = "", this.stringBufferOffset = 0, this.tState = Dn;
      else if (t === 45)
        this.string = "-", this.tState = yC;
      else if (t >= 48 && t < 64)
        this.string = String.fromCharCode(t), this.tState = fy;
      else if (!(t === 32 || t === 9 || t === 10 || t === 13))
        return this.charError(e, r);
    } else if (this.tState === Dn)
      if (t = e[r], this.bytes_remaining > 0) {
        for (var o = 0; o < this.bytes_remaining; o++)
          this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + o] = e[o];
        this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]), this.bytes_in_sequence = this.bytes_remaining = 0, r = r + o - 1;
      } else if (this.bytes_remaining === 0 && t >= 128) {
        if (t <= 193 || t > 244)
          return this.onError(new Error("Invalid UTF-8 character at position " + r + " in state " + ls.toknam(this.tState)));
        if (t >= 194 && t <= 223 && (this.bytes_in_sequence = 2), t >= 224 && t <= 239 && (this.bytes_in_sequence = 3), t >= 240 && t <= 244 && (this.bytes_in_sequence = 4), this.bytes_in_sequence + r > e.length) {
          for (var s = 0; s <= e.length - 1 - r; s++)
            this.temp_buffs[this.bytes_in_sequence][s] = e[r + s];
          this.bytes_remaining = r + this.bytes_in_sequence - e.length, r = e.length - 1;
        } else
          this.appendStringBuf(e, r, r + this.bytes_in_sequence), r = r + this.bytes_in_sequence - 1;
      } else if (t === 34)
        this.tState = qs, this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset), this.stringBufferOffset = 0, this.onToken(wh, this.string), this.offset += Go.byteLength(this.string, "utf8") + 1, this.string = void 0;
      else if (t === 92)
        this.tState = mC;
      else if (t >= 32)
        this.appendStringChar(t);
      else
        return this.charError(e, r);
    else if (this.tState === mC)
      if (t = e[r], t === 34)
        this.appendStringChar(t), this.tState = Dn;
      else if (t === 92)
        this.appendStringChar(lre), this.tState = Dn;
      else if (t === 47)
        this.appendStringChar(ure), this.tState = Dn;
      else if (t === 98)
        this.appendStringChar(fre), this.tState = Dn;
      else if (t === 102)
        this.appendStringChar(cre), this.tState = Dn;
      else if (t === 110)
        this.appendStringChar(dre), this.tState = Dn;
      else if (t === 114)
        this.appendStringChar(hre), this.tState = Dn;
      else if (t === 116)
        this.appendStringChar(pre), this.tState = Dn;
      else if (t === 117)
        this.unicode = "", this.tState = vC;
      else
        return this.charError(e, r);
    else if (this.tState === vC || this.tState === sre || this.tState === are || this.tState === wC)
      if (t = e[r], t >= 48 && t < 64 || t > 64 && t <= 70 || t > 96 && t <= 102) {
        if (this.unicode += String.fromCharCode(t), this.tState++ === wC) {
          var a = parseInt(this.unicode, 16);
          this.unicode = void 0, this.highSurrogate !== void 0 && a >= 56320 && a < 57344 ? (this.appendStringBuf(new Go(String.fromCharCode(this.highSurrogate, a))), this.highSurrogate = void 0) : this.highSurrogate === void 0 && a >= 55296 && a < 56320 ? this.highSurrogate = a : (this.highSurrogate !== void 0 && (this.appendStringBuf(new Go(String.fromCharCode(this.highSurrogate))), this.highSurrogate = void 0), this.appendStringBuf(new Go(String.fromCharCode(a)))), this.tState = Dn;
        }
      } else
        return this.charError(e, r);
    else if (this.tState === yC || this.tState === fy)
      switch (t = e[r], t) {
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 46:
        case 101:
        case 69:
        case 43:
        case 45:
          this.string += String.fromCharCode(t), this.tState = fy;
          break;
        default:
          this.tState = qs;
          var l = this.numberReviver(this.string);
          if (l)
            return l;
          this.offset += this.string.length - 1, this.string = void 0, r--;
          break;
      }
    else if (this.tState === aC)
      if (e[r] === 114)
        this.tState = lC;
      else
        return this.charError(e, r);
    else if (this.tState === lC)
      if (e[r] === 117)
        this.tState = uC;
      else
        return this.charError(e, r);
    else if (this.tState === uC)
      if (e[r] === 101)
        this.tState = qs, this.onToken(kF, !0), this.offset += 3;
      else
        return this.charError(e, r);
    else if (this.tState === fC)
      if (e[r] === 97)
        this.tState = cC;
      else
        return this.charError(e, r);
    else if (this.tState === cC)
      if (e[r] === 108)
        this.tState = dC;
      else
        return this.charError(e, r);
    else if (this.tState === dC)
      if (e[r] === 115)
        this.tState = hC;
      else
        return this.charError(e, r);
    else if (this.tState === hC)
      if (e[r] === 101)
        this.tState = qs, this.onToken(IF, !1), this.offset += 4;
      else
        return this.charError(e, r);
    else if (this.tState === pC)
      if (e[r] === 117)
        this.tState = gC;
      else
        return this.charError(e, r);
    else if (this.tState === gC)
      if (e[r] === 108)
        this.tState = bC;
      else
        return this.charError(e, r);
    else if (this.tState === bC)
      if (e[r] === 108)
        this.tState = qs, this.onToken(MF, null), this.offset += 3;
      else
        return this.charError(e, r);
};
gn.onToken = function(e, t) {
};
gn.parseError = function(e, t) {
  this.tState = LF, this.onError(new Error("Unexpected " + ls.toknam(e) + (t ? "(" + JSON.stringify(t) + ")" : "") + " in state " + ls.toknam(this.state)));
};
gn.push = function() {
  this.stack.push({ value: this.value, key: this.key, mode: this.mode });
};
gn.pop = function() {
  var e = this.value, t = this.stack.pop();
  this.value = t.value, this.key = t.key, this.mode = t.mode, this.emit(e), this.mode || (this.state = El);
};
gn.emit = function(e) {
  this.mode && (this.state = vh), this.onValue(e);
};
gn.onValue = function(e) {
};
gn.onToken = function(e, t) {
  if (this.state === El)
    if (e === wh || e === NF || e === kF || e === IF || e === MF)
      this.value && (this.value[this.key] = t), this.emit(t);
    else if (e === $F)
      this.push(), this.value ? this.value = this.value[this.key] = {} : this.value = {}, this.key = void 0, this.state = cy, this.mode = id;
    else if (e === CF)
      this.push(), this.value ? this.value = this.value[this.key] = [] : this.value = [], this.key = 0, this.mode = od, this.state = El;
    else if (e === jd)
      if (this.mode === id)
        this.pop();
      else
        return this.parseError(e, t);
    else if (e === uS)
      if (this.mode === od)
        this.pop();
      else
        return this.parseError(e, t);
    else
      return this.parseError(e, t);
  else if (this.state === cy)
    if (e === wh)
      this.key = t, this.state = Bd;
    else if (e === jd)
      this.pop();
    else
      return this.parseError(e, t);
  else if (this.state === Bd)
    if (e === Bd)
      this.state = El;
    else
      return this.parseError(e, t);
  else if (this.state === vh)
    if (e === vh)
      this.mode === od ? (this.key++, this.state = El) : this.mode === id && (this.state = cy);
    else if (e === uS && this.mode === od || e === jd && this.mode === id)
      this.pop();
    else
      return this.parseError(e, t);
  else
    return this.parseError(e, t);
};
gn.numberReviver = function(e) {
  var t = Number(e);
  if (isNaN(t))
    return this.charError(buffer, i);
  e.match(/[0-9]+/) == e && t.toString() != e ? this.onToken(wh, e) : this.onToken(NF, t);
};
ls.C = st;
var gre = ls;
const bre = /* @__PURE__ */ $n(gre);
class yre extends AF.Transform {
  /**
   * @param {Object} options
   * @param {DataFactory} options.factory RDF/JS DataFactory used to create the quads and terms
   */
  constructor({ factory: t }) {
    super({
      readableObjectMode: !0
    }), this.factory = t, this.jsonParser = new bre(), this.jsonParser.onError = (r) => this.destroy(r), this.jsonParser.onValue = (r) => this.onValue(r);
  }
  _write(t, r, n) {
    this.jsonParser.write(t), n();
  }
  onValue(t) {
    if (this.jsonParser.stack.length !== 3 || this.jsonParser.stack[1].key !== "results" || this.jsonParser.stack[2].key !== "bindings" || Object.keys(t).length === 0)
      return;
    const r = {};
    for (const [n, o] of Object.entries(t))
      r[n] = this.valueToTerm(o);
    this.push(r);
  }
  valueToTerm(t) {
    if (t.type === "uri")
      return this.factory.namedNode(t.value);
    if (t.type === "bnode")
      return this.factory.blankNode(t.value);
    if (t.type === "literal" || t.type === "typed-literal") {
      const r = t.datatype && this.factory.namedNode(t.datatype);
      return this.factory.literal(t.value, r || t["xml:lang"]);
    }
    return null;
  }
}
class mre extends TF {
  /**
   * Sends a request for a ASK query
   *
   * @param {string} query ASK query
   * @param {Object} [options]
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='get'] SPARQL Protocol operation
   * @return {Promise<boolean>}
   */
  async ask(t, { headers: r, operation: n } = {}) {
    const o = await super.ask(t, { headers: r, operation: n });
    return await nd(o), (await o.json()).boolean;
  }
  /**
   * Sends a request for a CONSTRUCT or DESCRIBE query
   *
   * @param {string} query CONSTRUCT or DESCRIBE query
   * @param {Object} [options]
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='get'] SPARQL Protocol operation
   * @return {Readable}
   */
  construct(t, { headers: r, operation: n } = {}) {
    return sC(async () => {
      r = Xo(r), r.has("accept") || r.set("accept", "application/n-triples, text/turtle");
      const o = await super.construct(t, { headers: r, operation: n });
      return await nd(o), new L5({ factory: this.client.factory }).import(o.body);
    });
  }
  /**
   * Sends a request for a SELECT query
   *
   * @param {string} query SELECT query
   * @param {Object} [options]
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='get'] SPARQL Protocol operation
   * @return {Readable}
   */
  select(t, { headers: r, operation: n } = {}) {
    return sC(async () => {
      const o = await super.select(t, { headers: r, operation: n });
      await nd(o);
      const s = new yre({ factory: this.client.factory });
      return o.body.pipe(s);
    });
  }
  /**
   * Sends a request for an update query
   *
   * @param {string} query update query
   * @param {Object} [options]
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='postUrlencoded'] SPARQL Protocol operation
   * @return {Promise<void>}
   */
  async update(t, { headers: r, operation: n } = {}) {
    const o = await super.update(t, { headers: r, operation: n });
    await nd(o);
  }
}
class vre extends mre {
  /**
   * Sends a request for a CONSTRUCT or DESCRIBE query
   *
   * @param {string} query CONSTRUCT or DESCRIBE query
   * @param {Object} options
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='get'] SPARQL Protocol operation
   * @return {Promise<DatasetCore>}
   */
  async construct(t, { headers: r, operation: n } = {}) {
    const o = await F1(await super.construct(t, { headers: r, operation: n }));
    return this.client.factory.dataset(o);
  }
  /**
   * Sends a request for a SELECT query
   *
   * @param {string} query SELECT query
   * @param {Object} [options]
   * @param {Headers} [options.headers] additional request headers
   * @param {'get'|'postUrlencoded'|'postDirect'} [options.operation='get'] SPARQL Protocol operation
   * @return {Promise<Array<Object.<string, Term>>>}
   */
  async select(t, { headers: r, operation: n } = {}) {
    return F1(await super.select(t, { headers: r, operation: n }));
  }
}
function wre(e) {
  const t = e.reduce((o, s) => o + s.length, 0), r = new Uint8Array(t);
  let n = 0;
  for (const o of e)
    r.set(o, n), n += o.length;
  return r;
}
async function _re(e = {}) {
  if (!e.body || !e.body.readable)
    return e;
  const t = await F1(e.body);
  return t.length > 0 ? t[0].BYTES_PER_ELEMENT === 1 ? e.body = wre(t) : e.body = t.join("") : e.body = "", e;
}
var OF = { exports: {} }, dy = { exports: {} }, Bt = {
  ArrayIsArray(e) {
    return Array.isArray(e);
  },
  ArrayPrototypeIncludes(e, t) {
    return e.includes(t);
  },
  ArrayPrototypeIndexOf(e, t) {
    return e.indexOf(t);
  },
  ArrayPrototypeJoin(e, t) {
    return e.join(t);
  },
  ArrayPrototypeMap(e, t) {
    return e.map(t);
  },
  ArrayPrototypePop(e, t) {
    return e.pop(t);
  },
  ArrayPrototypePush(e, t) {
    return e.push(t);
  },
  ArrayPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  Error,
  FunctionPrototypeCall(e, t, ...r) {
    return e.call(t, ...r);
  },
  FunctionPrototypeSymbolHasInstance(e, t) {
    return Function.prototype[Symbol.hasInstance].call(e, t);
  },
  MathFloor: Math.floor,
  Number,
  NumberIsInteger: Number.isInteger,
  NumberIsNaN: Number.isNaN,
  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
  NumberParseInt: Number.parseInt,
  ObjectDefineProperties(e, t) {
    return Object.defineProperties(e, t);
  },
  ObjectDefineProperty(e, t, r) {
    return Object.defineProperty(e, t, r);
  },
  ObjectGetOwnPropertyDescriptor(e, t) {
    return Object.getOwnPropertyDescriptor(e, t);
  },
  ObjectKeys(e) {
    return Object.keys(e);
  },
  ObjectSetPrototypeOf(e, t) {
    return Object.setPrototypeOf(e, t);
  },
  Promise,
  PromisePrototypeCatch(e, t) {
    return e.catch(t);
  },
  PromisePrototypeThen(e, t, r) {
    return e.then(t, r);
  },
  PromiseReject(e) {
    return Promise.reject(e);
  },
  PromiseResolve(e) {
    return Promise.resolve(e);
  },
  ReflectApply: Reflect.apply,
  RegExpPrototypeTest(e, t) {
    return e.test(t);
  },
  SafeSet: Set,
  String,
  StringPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  StringPrototypeToLowerCase(e) {
    return e.toLowerCase();
  },
  StringPrototypeToUpperCase(e) {
    return e.toUpperCase();
  },
  StringPrototypeTrim(e) {
    return e.trim();
  },
  Symbol,
  SymbolFor: Symbol.for,
  SymbolAsyncIterator: Symbol.asyncIterator,
  SymbolHasInstance: Symbol.hasInstance,
  SymbolIterator: Symbol.iterator,
  SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
  SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
  TypedArrayPrototypeSet(e, t, r) {
    return e.set(t, r);
  },
  Boolean,
  Uint8Array
}, PF = { exports: {} };
(function(e) {
  const t = ut, { kResistStopPropagation: r, SymbolDispose: n } = Bt, o = globalThis.AbortSignal || Kt().AbortSignal, s = globalThis.AbortController || Kt().AbortController, a = Object.getPrototypeOf(async function() {
  }).constructor, l = globalThis.Blob || t.Blob, u = typeof l < "u" ? function(p) {
    return p instanceof l;
  } : function(p) {
    return !1;
  }, f = (h, p) => {
    if (h !== void 0 && (h === null || typeof h != "object" || !("aborted" in h)))
      throw new ERR_INVALID_ARG_TYPE(p, "AbortSignal", h);
  }, c = (h, p) => {
    if (typeof h != "function")
      throw new ERR_INVALID_ARG_TYPE(p, "Function", h);
  };
  class d extends Error {
    constructor(p) {
      if (!Array.isArray(p))
        throw new TypeError(`Expected input to be an Array, got ${typeof p}`);
      let m = "";
      for (let y = 0; y < p.length; y++)
        m += `    ${p[y].stack}
`;
      super(m), this.name = "AggregateError", this.errors = p;
    }
  }
  e.exports = {
    AggregateError: d,
    kEmptyObject: Object.freeze({}),
    once(h) {
      let p = !1;
      return function(...m) {
        p || (p = !0, h.apply(this, m));
      };
    },
    createDeferredPromise: function() {
      let h, p;
      return {
        promise: new Promise((y, _) => {
          h = y, p = _;
        }),
        resolve: h,
        reject: p
      };
    },
    promisify(h) {
      return new Promise((p, m) => {
        h((y, ..._) => y ? m(y) : p(..._));
      });
    },
    debuglog() {
      return function() {
      };
    },
    format(h, ...p) {
      return h.replace(/%([sdifj])/g, function(...[m, y]) {
        const _ = p.shift();
        return y === "f" ? _.toFixed(6) : y === "j" ? JSON.stringify(_) : y === "s" && typeof _ == "object" ? `${_.constructor !== Object ? _.constructor.name : ""} {}`.trim() : _.toString();
      });
    },
    inspect(h) {
      switch (typeof h) {
        case "string":
          if (h.includes("'"))
            if (h.includes('"')) {
              if (!h.includes("`") && !h.includes("${"))
                return `\`${h}\``;
            } else
              return `"${h}"`;
          return `'${h}'`;
        case "number":
          return isNaN(h) ? "NaN" : Object.is(h, -0) ? String(h) : h;
        case "bigint":
          return `${String(h)}n`;
        case "boolean":
        case "undefined":
          return String(h);
        case "object":
          return "{}";
      }
    },
    types: {
      isAsyncFunction(h) {
        return h instanceof a;
      },
      isArrayBufferView(h) {
        return ArrayBuffer.isView(h);
      }
    },
    isBlob: u,
    deprecate(h, p) {
      return h;
    },
    addAbortListener: ur.addAbortListener || function(p, m) {
      if (p === void 0)
        throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", p);
      f(p, "signal"), c(m, "listener");
      let y;
      return p.aborted ? queueMicrotask(() => m()) : (p.addEventListener("abort", m, {
        __proto__: null,
        once: !0,
        [r]: !0
      }), y = () => {
        p.removeEventListener("abort", m);
      }), {
        __proto__: null,
        [n]() {
          var _;
          (_ = y) === null || _ === void 0 || _();
        }
      };
    },
    AbortSignalAny: o.any || function(p) {
      if (p.length === 1)
        return p[0];
      const m = new s(), y = () => m.abort();
      return p.forEach((_) => {
        f(_, "signals"), _.addEventListener("abort", y, {
          once: !0
        });
      }), m.signal.addEventListener(
        "abort",
        () => {
          p.forEach((_) => _.removeEventListener("abort", y));
        },
        {
          once: !0
        }
      ), m.signal;
    }
  }, e.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
})(PF);
var zr = PF.exports, Ex = {};
const { format: Sre, inspect: _h, AggregateError: Ere } = zr, xre = globalThis.AggregateError || Ere, Rre = Symbol("kIsNodeError"), Are = [
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
], Tre = /^([A-Z][a-z0-9]*)+$/, $re = "__node_internal_", zp = {};
function ca(e, t) {
  if (!e)
    throw new zp.ERR_INTERNAL_ASSERTION(t);
}
function _C(e) {
  let t = "", r = e.length;
  const n = e[0] === "-" ? 1 : 0;
  for (; r >= n + 4; r -= 3)
    t = `_${e.slice(r - 3, r)}${t}`;
  return `${e.slice(0, r)}${t}`;
}
function Cre(e, t, r) {
  if (typeof t == "function")
    return ca(
      t.length <= r.length,
      // Default options do not count.
      `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${t.length}).`
    ), t(...r);
  const n = (t.match(/%[dfijoOs]/g) || []).length;
  return ca(
    n === r.length,
    `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${n}).`
  ), r.length === 0 ? t : Sre(t, ...r);
}
function _r(e, t, r) {
  r || (r = Error);
  class n extends r {
    constructor(...s) {
      super(Cre(e, t, s));
    }
    toString() {
      return `${this.name} [${e}]: ${this.message}`;
    }
  }
  Object.defineProperties(n.prototype, {
    name: {
      value: r.name,
      writable: !0,
      enumerable: !1,
      configurable: !0
    },
    toString: {
      value() {
        return `${this.name} [${e}]: ${this.message}`;
      },
      writable: !0,
      enumerable: !1,
      configurable: !0
    }
  }), n.prototype.code = e, n.prototype[Rre] = !0, zp[e] = n;
}
function SC(e) {
  const t = $re + e.name;
  return Object.defineProperty(e, "name", {
    value: t
  }), e;
}
function kre(e, t) {
  if (e && t && e !== t) {
    if (Array.isArray(t.errors))
      return t.errors.push(e), t;
    const r = new xre([t, e], t.message);
    return r.code = t.code, r;
  }
  return e || t;
}
let Ire = class extends Error {
  constructor(t = "The operation was aborted", r = void 0) {
    if (r !== void 0 && typeof r != "object")
      throw new zp.ERR_INVALID_ARG_TYPE("options", "Object", r);
    super(t, r), this.code = "ABORT_ERR", this.name = "AbortError";
  }
};
_r("ERR_ASSERTION", "%s", Error);
_r(
  "ERR_INVALID_ARG_TYPE",
  (e, t, r) => {
    ca(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
    let n = "The ";
    e.endsWith(" argument") ? n += `${e} ` : n += `"${e}" ${e.includes(".") ? "property" : "argument"} `, n += "must be ";
    const o = [], s = [], a = [];
    for (const u of t)
      ca(typeof u == "string", "All expected entries have to be of type string"), Are.includes(u) ? o.push(u.toLowerCase()) : Tre.test(u) ? s.push(u) : (ca(u !== "object", 'The value "object" should be written as "Object"'), a.push(u));
    if (s.length > 0) {
      const u = o.indexOf("object");
      u !== -1 && (o.splice(o, u, 1), s.push("Object"));
    }
    if (o.length > 0) {
      switch (o.length) {
        case 1:
          n += `of type ${o[0]}`;
          break;
        case 2:
          n += `one of type ${o[0]} or ${o[1]}`;
          break;
        default: {
          const u = o.pop();
          n += `one of type ${o.join(", ")}, or ${u}`;
        }
      }
      (s.length > 0 || a.length > 0) && (n += " or ");
    }
    if (s.length > 0) {
      switch (s.length) {
        case 1:
          n += `an instance of ${s[0]}`;
          break;
        case 2:
          n += `an instance of ${s[0]} or ${s[1]}`;
          break;
        default: {
          const u = s.pop();
          n += `an instance of ${s.join(", ")}, or ${u}`;
        }
      }
      a.length > 0 && (n += " or ");
    }
    switch (a.length) {
      case 0:
        break;
      case 1:
        a[0].toLowerCase() !== a[0] && (n += "an "), n += `${a[0]}`;
        break;
      case 2:
        n += `one of ${a[0]} or ${a[1]}`;
        break;
      default: {
        const u = a.pop();
        n += `one of ${a.join(", ")}, or ${u}`;
      }
    }
    if (r == null)
      n += `. Received ${r}`;
    else if (typeof r == "function" && r.name)
      n += `. Received function ${r.name}`;
    else if (typeof r == "object") {
      var l;
      if ((l = r.constructor) !== null && l !== void 0 && l.name)
        n += `. Received an instance of ${r.constructor.name}`;
      else {
        const u = _h(r, {
          depth: -1
        });
        n += `. Received ${u}`;
      }
    } else {
      let u = _h(r, {
        colors: !1
      });
      u.length > 25 && (u = `${u.slice(0, 25)}...`), n += `. Received type ${typeof r} (${u})`;
    }
    return n;
  },
  TypeError
);
_r(
  "ERR_INVALID_ARG_VALUE",
  (e, t, r = "is invalid") => {
    let n = _h(t);
    return n.length > 128 && (n = n.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${n}`;
  },
  TypeError
);
_r(
  "ERR_INVALID_RETURN_VALUE",
  (e, t, r) => {
    var n;
    const o = r != null && (n = r.constructor) !== null && n !== void 0 && n.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
    return `Expected ${e} to be returned from the "${t}" function but got ${o}.`;
  },
  TypeError
);
_r(
  "ERR_MISSING_ARGS",
  (...e) => {
    ca(e.length > 0, "At least one arg needs to be specified");
    let t;
    const r = e.length;
    switch (e = (Array.isArray(e) ? e : [e]).map((n) => `"${n}"`).join(" or "), r) {
      case 1:
        t += `The ${e[0]} argument`;
        break;
      case 2:
        t += `The ${e[0]} and ${e[1]} arguments`;
        break;
      default:
        {
          const n = e.pop();
          t += `The ${e.join(", ")}, and ${n} arguments`;
        }
        break;
    }
    return `${t} must be specified`;
  },
  TypeError
);
_r(
  "ERR_OUT_OF_RANGE",
  (e, t, r) => {
    ca(t, 'Missing "range" argument');
    let n;
    return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? n = _C(String(r)) : typeof r == "bigint" ? (n = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (n = _C(n)), n += "n") : n = _h(r), `The value of "${e}" is out of range. It must be ${t}. Received ${n}`;
  },
  RangeError
);
_r("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
_r("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
_r("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
_r("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
_r("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
_r("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
_r("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
_r("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
_r("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
_r("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
_r("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
var sn = {
  AbortError: Ire,
  aggregateTwoErrors: SC(kre),
  hideStackFrames: SC,
  codes: zp
};
const {
  ArrayIsArray: xx,
  ArrayPrototypeIncludes: DF,
  ArrayPrototypeJoin: FF,
  ArrayPrototypeMap: Mre,
  NumberIsInteger: Rx,
  NumberIsNaN: Nre,
  NumberMAX_SAFE_INTEGER: Lre,
  NumberMIN_SAFE_INTEGER: Ore,
  NumberParseInt: Pre,
  ObjectPrototypeHasOwnProperty: Dre,
  RegExpPrototypeExec: jF,
  String: Fre,
  StringPrototypeToUpperCase: jre,
  StringPrototypeTrim: Bre
} = Bt, {
  hideStackFrames: In,
  codes: { ERR_SOCKET_BAD_PORT: qre, ERR_INVALID_ARG_TYPE: Mr, ERR_INVALID_ARG_VALUE: hu, ERR_OUT_OF_RANGE: Aa, ERR_UNKNOWN_SIGNAL: EC }
} = sn, { normalizeEncoding: Wre } = zr, { isAsyncFunction: Ure, isArrayBufferView: Hre } = zr.types, xC = {};
function zre(e) {
  return e === (e | 0);
}
function Gre(e) {
  return e === e >>> 0;
}
const Vre = /^[0-7]+$/, Kre = "must be a 32-bit unsigned integer or an octal string";
function Yre(e, t, r) {
  if (typeof e > "u" && (e = r), typeof e == "string") {
    if (jF(Vre, e) === null)
      throw new hu(t, e, Kre);
    e = Pre(e, 8);
  }
  return BF(e, t), e;
}
const Xre = In((e, t, r = Ore, n = Lre) => {
  if (typeof e != "number")
    throw new Mr(t, "number", e);
  if (!Rx(e))
    throw new Aa(t, "an integer", e);
  if (e < r || e > n)
    throw new Aa(t, `>= ${r} && <= ${n}`, e);
}), Jre = In((e, t, r = -2147483648, n = 2147483647) => {
  if (typeof e != "number")
    throw new Mr(t, "number", e);
  if (!Rx(e))
    throw new Aa(t, "an integer", e);
  if (e < r || e > n)
    throw new Aa(t, `>= ${r} && <= ${n}`, e);
}), BF = In((e, t, r = !1) => {
  if (typeof e != "number")
    throw new Mr(t, "number", e);
  if (!Rx(e))
    throw new Aa(t, "an integer", e);
  const n = r ? 1 : 0, o = 4294967295;
  if (e < n || e > o)
    throw new Aa(t, `>= ${n} && <= ${o}`, e);
});
function Ax(e, t) {
  if (typeof e != "string")
    throw new Mr(t, "string", e);
}
function Qre(e, t, r = void 0, n) {
  if (typeof e != "number")
    throw new Mr(t, "number", e);
  if (r != null && e < r || n != null && e > n || (r != null || n != null) && Nre(e))
    throw new Aa(
      t,
      `${r != null ? `>= ${r}` : ""}${r != null && n != null ? " && " : ""}${n != null ? `<= ${n}` : ""}`,
      e
    );
}
const Zre = In((e, t, r) => {
  if (!DF(r, e)) {
    const o = "must be one of: " + FF(
      Mre(r, (s) => typeof s == "string" ? `'${s}'` : Fre(s)),
      ", "
    );
    throw new hu(t, e, o);
  }
});
function qF(e, t) {
  if (typeof e != "boolean")
    throw new Mr(t, "boolean", e);
}
function hy(e, t, r) {
  return e == null || !Dre(e, t) ? r : e[t];
}
const ene = In((e, t, r = null) => {
  const n = hy(r, "allowArray", !1), o = hy(r, "allowFunction", !1);
  if (!hy(r, "nullable", !1) && e === null || !n && xx(e) || typeof e != "object" && (!o || typeof e != "function"))
    throw new Mr(t, "Object", e);
}), tne = In((e, t) => {
  if (e != null && typeof e != "object" && typeof e != "function")
    throw new Mr(t, "a dictionary", e);
}), Gp = In((e, t, r = 0) => {
  if (!xx(e))
    throw new Mr(t, "Array", e);
  if (e.length < r) {
    const n = `must be longer than ${r}`;
    throw new hu(t, e, n);
  }
});
function rne(e, t) {
  Gp(e, t);
  for (let r = 0; r < e.length; r++)
    Ax(e[r], `${t}[${r}]`);
}
function nne(e, t) {
  Gp(e, t);
  for (let r = 0; r < e.length; r++)
    qF(e[r], `${t}[${r}]`);
}
function ine(e, t) {
  Gp(e, t);
  for (let r = 0; r < e.length; r++) {
    const n = e[r], o = `${t}[${r}]`;
    if (n == null)
      throw new Mr(o, "AbortSignal", n);
    WF(n, o);
  }
}
function one(e, t = "signal") {
  if (Ax(e, t), xC[e] === void 0)
    throw xC[jre(e)] !== void 0 ? new EC(e + " (signals must use all capital letters)") : new EC(e);
}
const sne = In((e, t = "buffer") => {
  if (!Hre(e))
    throw new Mr(t, ["Buffer", "TypedArray", "DataView"], e);
});
function ane(e, t) {
  const r = Wre(t), n = e.length;
  if (r === "hex" && n % 2 !== 0)
    throw new hu("encoding", t, `is invalid for data of length ${n}`);
}
function lne(e, t = "Port", r = !0) {
  if (typeof e != "number" && typeof e != "string" || typeof e == "string" && Bre(e).length === 0 || +e !== +e >>> 0 || e > 65535 || e === 0 && !r)
    throw new qre(t, e, r);
  return e | 0;
}
const WF = In((e, t) => {
  if (e !== void 0 && (e === null || typeof e != "object" || !("aborted" in e)))
    throw new Mr(t, "AbortSignal", e);
}), une = In((e, t) => {
  if (typeof e != "function")
    throw new Mr(t, "Function", e);
}), fne = In((e, t) => {
  if (typeof e != "function" || Ure(e))
    throw new Mr(t, "Function", e);
}), cne = In((e, t) => {
  if (e !== void 0)
    throw new Mr(t, "undefined", e);
});
function dne(e, t, r) {
  if (!DF(r, e))
    throw new Mr(t, `('${FF(r, "|")}')`, e);
}
const hne = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
function RC(e, t) {
  if (typeof e > "u" || !jF(hne, e))
    throw new hu(
      t,
      e,
      'must be an array or string of format "</styles.css>; rel=preload; as=style"'
    );
}
function pne(e) {
  if (typeof e == "string")
    return RC(e, "hints"), e;
  if (xx(e)) {
    const t = e.length;
    let r = "";
    if (t === 0)
      return r;
    for (let n = 0; n < t; n++) {
      const o = e[n];
      RC(o, "hints"), r += o, n !== t - 1 && (r += ", ");
    }
    return r;
  }
  throw new hu(
    "hints",
    e,
    'must be an array or string of format "</styles.css>; rel=preload; as=style"'
  );
}
var vc = {
  isInt32: zre,
  isUint32: Gre,
  parseFileMode: Yre,
  validateArray: Gp,
  validateStringArray: rne,
  validateBooleanArray: nne,
  validateAbortSignalArray: ine,
  validateBoolean: qF,
  validateBuffer: sne,
  validateDictionary: tne,
  validateEncoding: ane,
  validateFunction: une,
  validateInt32: Jre,
  validateInteger: Xre,
  validateNumber: Qre,
  validateObject: ene,
  validateOneOf: Zre,
  validatePlainFunction: fne,
  validatePort: lne,
  validateSignalName: one,
  validateString: Ax,
  validateUint32: BF,
  validateUndefined: cne,
  validateUnion: dne,
  validateAbortSignal: WF,
  validateLinkHeaderValue: pne
}, Tx = { exports: {} };
const { SymbolAsyncIterator: AC, SymbolIterator: TC, SymbolFor: za } = Bt, UF = za("nodejs.stream.destroyed"), HF = za("nodejs.stream.errored"), fS = za("nodejs.stream.readable"), cS = za("nodejs.stream.writable"), zF = za("nodejs.stream.disturbed"), gne = za("nodejs.webstream.isClosedPromise"), bne = za("nodejs.webstream.controllerErrorFunction");
function Vp(e, t = !1) {
  var r;
  return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((r = e._readableState) === null || r === void 0 ? void 0 : r.readable) !== !1) && // Duplex
  (!e._writableState || e._readableState));
}
function Kp(e) {
  var t;
  return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === void 0 ? void 0 : t.writable) !== !1));
}
function yne(e) {
  return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
}
function Fi(e) {
  return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
}
function GF(e) {
  return !!(e && !Fi(e) && typeof e.pipeThrough == "function" && typeof e.getReader == "function" && typeof e.cancel == "function");
}
function VF(e) {
  return !!(e && !Fi(e) && typeof e.getWriter == "function" && typeof e.abort == "function");
}
function KF(e) {
  return !!(e && !Fi(e) && typeof e.readable == "object" && typeof e.writable == "object");
}
function mne(e) {
  return GF(e) || VF(e) || KF(e);
}
function vne(e, t) {
  return e == null ? !1 : t === !0 ? typeof e[AC] == "function" : t === !1 ? typeof e[TC] == "function" : typeof e[AC] == "function" || typeof e[TC] == "function";
}
function Yp(e) {
  if (!Fi(e))
    return null;
  const t = e._writableState, r = e._readableState, n = t || r;
  return !!(e.destroyed || e[UF] || n != null && n.destroyed);
}
function YF(e) {
  if (!Kp(e))
    return null;
  if (e.writableEnded === !0)
    return !0;
  const t = e._writableState;
  return t != null && t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function wne(e, t) {
  if (!Kp(e))
    return null;
  if (e.writableFinished === !0)
    return !0;
  const r = e._writableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.finished) != "boolean" ? null : !!(r.finished || t === !1 && r.ended === !0 && r.length === 0);
}
function _ne(e) {
  if (!Vp(e))
    return null;
  if (e.readableEnded === !0)
    return !0;
  const t = e._readableState;
  return !t || t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function XF(e, t) {
  if (!Vp(e))
    return null;
  const r = e._readableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.endEmitted) != "boolean" ? null : !!(r.endEmitted || t === !1 && r.ended === !0 && r.length === 0);
}
function JF(e) {
  return e && e[fS] != null ? e[fS] : typeof (e == null ? void 0 : e.readable) != "boolean" ? null : Yp(e) ? !1 : Vp(e) && e.readable && !XF(e);
}
function QF(e) {
  return e && e[cS] != null ? e[cS] : typeof (e == null ? void 0 : e.writable) != "boolean" ? null : Yp(e) ? !1 : Kp(e) && e.writable && !YF(e);
}
function Sne(e, t) {
  return Fi(e) ? Yp(e) ? !0 : !((t == null ? void 0 : t.readable) !== !1 && JF(e) || (t == null ? void 0 : t.writable) !== !1 && QF(e)) : null;
}
function Ene(e) {
  var t, r;
  return Fi(e) ? e.writableErrored ? e.writableErrored : (t = (r = e._writableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function xne(e) {
  var t, r;
  return Fi(e) ? e.readableErrored ? e.readableErrored : (t = (r = e._readableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function Rne(e) {
  if (!Fi(e))
    return null;
  if (typeof e.closed == "boolean")
    return e.closed;
  const t = e._writableState, r = e._readableState;
  return typeof (t == null ? void 0 : t.closed) == "boolean" || typeof (r == null ? void 0 : r.closed) == "boolean" ? (t == null ? void 0 : t.closed) || (r == null ? void 0 : r.closed) : typeof e._closed == "boolean" && ZF(e) ? e._closed : null;
}
function ZF(e) {
  return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
}
function e7(e) {
  return typeof e._sent100 == "boolean" && ZF(e);
}
function Ane(e) {
  var t;
  return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === void 0 ? void 0 : t.upgradeOrConnect) === void 0;
}
function Tne(e) {
  if (!Fi(e))
    return null;
  const t = e._writableState, r = e._readableState, n = t || r;
  return !n && e7(e) || !!(n && n.autoDestroy && n.emitClose && n.closed === !1);
}
function $ne(e) {
  var t;
  return !!(e && ((t = e[zF]) !== null && t !== void 0 ? t : e.readableDidRead || e.readableAborted));
}
function Cne(e) {
  var t, r, n, o, s, a, l, u, f, c;
  return !!(e && ((t = (r = (n = (o = (s = (a = e[HF]) !== null && a !== void 0 ? a : e.readableErrored) !== null && s !== void 0 ? s : e.writableErrored) !== null && o !== void 0 ? o : (l = e._readableState) === null || l === void 0 ? void 0 : l.errorEmitted) !== null && n !== void 0 ? n : (u = e._writableState) === null || u === void 0 ? void 0 : u.errorEmitted) !== null && r !== void 0 ? r : (f = e._readableState) === null || f === void 0 ? void 0 : f.errored) !== null && t !== void 0 ? t : !((c = e._writableState) === null || c === void 0) && c.errored));
}
var Ao = {
  isDestroyed: Yp,
  kIsDestroyed: UF,
  isDisturbed: $ne,
  kIsDisturbed: zF,
  isErrored: Cne,
  kIsErrored: HF,
  isReadable: JF,
  kIsReadable: fS,
  kIsClosedPromise: gne,
  kControllerErrorFunction: bne,
  kIsWritable: cS,
  isClosed: Rne,
  isDuplexNodeStream: yne,
  isFinished: Sne,
  isIterable: vne,
  isReadableNodeStream: Vp,
  isReadableStream: GF,
  isReadableEnded: _ne,
  isReadableFinished: XF,
  isReadableErrored: xne,
  isNodeStream: Fi,
  isWebStream: mne,
  isWritable: QF,
  isWritableNodeStream: Kp,
  isWritableStream: VF,
  isWritableEnded: YF,
  isWritableFinished: wne,
  isWritableErrored: Ene,
  isServerRequest: Ane,
  isServerResponse: e7,
  willEmitClose: Tne,
  isTransformStream: KF
};
const Bo = _t, { AbortError: t7, codes: kne } = sn, { ERR_INVALID_ARG_TYPE: Ine, ERR_STREAM_PREMATURE_CLOSE: $C } = kne, { kEmptyObject: dS, once: hS } = zr, { validateAbortSignal: Mne, validateFunction: Nne, validateObject: Lne, validateBoolean: One } = vc, { Promise: Pne, PromisePrototypeThen: Dne, SymbolDispose: r7 } = Bt, {
  isClosed: Fne,
  isReadable: CC,
  isReadableNodeStream: py,
  isReadableStream: jne,
  isReadableFinished: kC,
  isReadableErrored: IC,
  isWritable: MC,
  isWritableNodeStream: NC,
  isWritableStream: Bne,
  isWritableFinished: LC,
  isWritableErrored: OC,
  isNodeStream: qne,
  willEmitClose: Wne,
  kIsClosedPromise: Une
} = Ao;
let Ll;
function Hne(e) {
  return e.setHeader && typeof e.abort == "function";
}
const pS = () => {
};
function n7(e, t, r) {
  var n, o;
  if (arguments.length === 2 ? (r = t, t = dS) : t == null ? t = dS : Lne(t, "options"), Nne(r, "callback"), Mne(t.signal, "options.signal"), r = hS(r), jne(e) || Bne(e))
    return zne(e, t, r);
  if (!qne(e))
    throw new Ine("stream", ["ReadableStream", "WritableStream", "Stream"], e);
  const s = (n = t.readable) !== null && n !== void 0 ? n : py(e), a = (o = t.writable) !== null && o !== void 0 ? o : NC(e), l = e._writableState, u = e._readableState, f = () => {
    e.writable || h();
  };
  let c = Wne(e) && py(e) === s && NC(e) === a, d = LC(e, !1);
  const h = () => {
    d = !0, e.destroyed && (c = !1), !(c && (!e.readable || s)) && (!s || p) && r.call(e);
  };
  let p = kC(e, !1);
  const m = () => {
    p = !0, e.destroyed && (c = !1), !(c && (!e.writable || a)) && (!a || d) && r.call(e);
  }, y = (I) => {
    r.call(e, I);
  };
  let _ = Fne(e);
  const S = () => {
    _ = !0;
    const I = OC(e) || IC(e);
    if (I && typeof I != "boolean")
      return r.call(e, I);
    if (s && !p && py(e, !0) && !kC(e, !1))
      return r.call(e, new $C());
    if (a && !d && !LC(e, !1))
      return r.call(e, new $C());
    r.call(e);
  }, x = () => {
    _ = !0;
    const I = OC(e) || IC(e);
    if (I && typeof I != "boolean")
      return r.call(e, I);
    r.call(e);
  }, E = () => {
    e.req.on("finish", h);
  };
  Hne(e) ? (e.on("complete", h), c || e.on("abort", S), e.req ? E() : e.on("request", E)) : a && !l && (e.on("end", f), e.on("close", f)), !c && typeof e.aborted == "boolean" && e.on("aborted", S), e.on("end", m), e.on("finish", h), t.error !== !1 && e.on("error", y), e.on("close", S), _ ? Bo.nextTick(S) : l != null && l.errorEmitted || u != null && u.errorEmitted ? c || Bo.nextTick(x) : (!s && (!c || CC(e)) && (d || MC(e) === !1) || !a && (!c || MC(e)) && (p || CC(e) === !1) || u && e.req && e.aborted) && Bo.nextTick(x);
  const C = () => {
    r = pS, e.removeListener("aborted", S), e.removeListener("complete", h), e.removeListener("abort", S), e.removeListener("request", E), e.req && e.req.removeListener("finish", h), e.removeListener("end", f), e.removeListener("close", f), e.removeListener("finish", h), e.removeListener("end", m), e.removeListener("error", y), e.removeListener("close", S);
  };
  if (t.signal && !_) {
    const I = () => {
      const j = r;
      C(), j.call(
        e,
        new t7(void 0, {
          cause: t.signal.reason
        })
      );
    };
    if (t.signal.aborted)
      Bo.nextTick(I);
    else {
      Ll = Ll || zr.addAbortListener;
      const j = Ll(t.signal, I), J = r;
      r = hS((...G) => {
        j[r7](), J.apply(e, G);
      });
    }
  }
  return C;
}
function zne(e, t, r) {
  let n = !1, o = pS;
  if (t.signal)
    if (o = () => {
      n = !0, r.call(
        e,
        new t7(void 0, {
          cause: t.signal.reason
        })
      );
    }, t.signal.aborted)
      Bo.nextTick(o);
    else {
      Ll = Ll || zr.addAbortListener;
      const a = Ll(t.signal, o), l = r;
      r = hS((...u) => {
        a[r7](), l.apply(e, u);
      });
    }
  const s = (...a) => {
    n || Bo.nextTick(() => r.apply(e, a));
  };
  return Dne(e[Une].promise, s, s), pS;
}
function Gne(e, t) {
  var r;
  let n = !1;
  return t === null && (t = dS), (r = t) !== null && r !== void 0 && r.cleanup && (One(t.cleanup, "cleanup"), n = t.cleanup), new Pne((o, s) => {
    const a = n7(e, t, (l) => {
      n && a(), l ? s(l) : o();
    });
  });
}
Tx.exports = n7;
Tx.exports.finished = Gne;
var ws = Tx.exports;
const _i = _t, {
  aggregateTwoErrors: Vne,
  codes: { ERR_MULTIPLE_CALLBACK: Kne },
  AbortError: Yne
} = sn, { Symbol: i7 } = Bt, { kIsDestroyed: Xne, isDestroyed: Jne, isFinished: Qne, isServerRequest: Zne } = Ao, o7 = i7("kDestroy"), gS = i7("kConstruct");
function s7(e, t, r) {
  e && (e.stack, t && !t.errored && (t.errored = e), r && !r.errored && (r.errored = e));
}
function eie(e, t) {
  const r = this._readableState, n = this._writableState, o = n || r;
  return n != null && n.destroyed || r != null && r.destroyed ? (typeof t == "function" && t(), this) : (s7(e, n, r), n && (n.destroyed = !0), r && (r.destroyed = !0), o.constructed ? PC(this, e, t) : this.once(o7, function(s) {
    PC(this, Vne(s, e), t);
  }), this);
}
function PC(e, t, r) {
  let n = !1;
  function o(s) {
    if (n)
      return;
    n = !0;
    const a = e._readableState, l = e._writableState;
    s7(s, l, a), l && (l.closed = !0), a && (a.closed = !0), typeof r == "function" && r(s), s ? _i.nextTick(tie, e, s) : _i.nextTick(a7, e);
  }
  try {
    e._destroy(t || null, o);
  } catch (s) {
    o(s);
  }
}
function tie(e, t) {
  bS(e, t), a7(e);
}
function a7(e) {
  const t = e._readableState, r = e._writableState;
  r && (r.closeEmitted = !0), t && (t.closeEmitted = !0), (r != null && r.emitClose || t != null && t.emitClose) && e.emit("close");
}
function bS(e, t) {
  const r = e._readableState, n = e._writableState;
  n != null && n.errorEmitted || r != null && r.errorEmitted || (n && (n.errorEmitted = !0), r && (r.errorEmitted = !0), e.emit("error", t));
}
function rie() {
  const e = this._readableState, t = this._writableState;
  e && (e.constructed = !0, e.closed = !1, e.closeEmitted = !1, e.destroyed = !1, e.errored = null, e.errorEmitted = !1, e.reading = !1, e.ended = e.readable === !1, e.endEmitted = e.readable === !1), t && (t.constructed = !0, t.destroyed = !1, t.closed = !1, t.closeEmitted = !1, t.errored = null, t.errorEmitted = !1, t.finalCalled = !1, t.prefinished = !1, t.ended = t.writable === !1, t.ending = t.writable === !1, t.finished = t.writable === !1);
}
function yS(e, t, r) {
  const n = e._readableState, o = e._writableState;
  if (o != null && o.destroyed || n != null && n.destroyed)
    return this;
  n != null && n.autoDestroy || o != null && o.autoDestroy ? e.destroy(t) : t && (t.stack, o && !o.errored && (o.errored = t), n && !n.errored && (n.errored = t), r ? _i.nextTick(bS, e, t) : bS(e, t));
}
function nie(e, t) {
  if (typeof e._construct != "function")
    return;
  const r = e._readableState, n = e._writableState;
  r && (r.constructed = !1), n && (n.constructed = !1), e.once(gS, t), !(e.listenerCount(gS) > 1) && _i.nextTick(iie, e);
}
function iie(e) {
  let t = !1;
  function r(n) {
    if (t) {
      yS(e, n ?? new Kne());
      return;
    }
    t = !0;
    const o = e._readableState, s = e._writableState, a = s || o;
    o && (o.constructed = !0), s && (s.constructed = !0), a.destroyed ? e.emit(o7, n) : n ? yS(e, n, !0) : _i.nextTick(oie, e);
  }
  try {
    e._construct((n) => {
      _i.nextTick(r, n);
    });
  } catch (n) {
    _i.nextTick(r, n);
  }
}
function oie(e) {
  e.emit(gS);
}
function DC(e) {
  return (e == null ? void 0 : e.setHeader) && typeof e.abort == "function";
}
function l7(e) {
  e.emit("close");
}
function sie(e, t) {
  e.emit("error", t), _i.nextTick(l7, e);
}
function aie(e, t) {
  !e || Jne(e) || (!t && !Qne(e) && (t = new Yne()), Zne(e) ? (e.socket = null, e.destroy(t)) : DC(e) ? e.abort() : DC(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? _i.nextTick(sie, e, t) : _i.nextTick(l7, e), e.destroyed || (e[Xne] = !0));
}
var pu = {
  construct: nie,
  destroyer: aie,
  destroy: eie,
  undestroy: rie,
  errorOrDestroy: yS
};
const { ArrayIsArray: lie, ObjectSetPrototypeOf: u7 } = Bt, { EventEmitter: Xp } = ur;
function Jp(e) {
  Xp.call(this, e);
}
u7(Jp.prototype, Xp.prototype);
u7(Jp, Xp);
Jp.prototype.pipe = function(e, t) {
  const r = this;
  function n(c) {
    e.writable && e.write(c) === !1 && r.pause && r.pause();
  }
  r.on("data", n);
  function o() {
    r.readable && r.resume && r.resume();
  }
  e.on("drain", o), !e._isStdio && (!t || t.end !== !1) && (r.on("end", a), r.on("close", l));
  let s = !1;
  function a() {
    s || (s = !0, e.end());
  }
  function l() {
    s || (s = !0, typeof e.destroy == "function" && e.destroy());
  }
  function u(c) {
    f(), Xp.listenerCount(this, "error") === 0 && this.emit("error", c);
  }
  mS(r, "error", u), mS(e, "error", u);
  function f() {
    r.removeListener("data", n), e.removeListener("drain", o), r.removeListener("end", a), r.removeListener("close", l), r.removeListener("error", u), e.removeListener("error", u), r.removeListener("end", f), r.removeListener("close", f), e.removeListener("close", f);
  }
  return r.on("end", f), r.on("close", f), e.on("close", f), e.emit("pipe", r), e;
};
function mS(e, t, r) {
  if (typeof e.prependListener == "function")
    return e.prependListener(t, r);
  !e._events || !e._events[t] ? e.on(t, r) : lie(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
}
var $x = {
  Stream: Jp,
  prependListener: mS
}, f7 = { exports: {} };
(function(e) {
  const { SymbolDispose: t } = Bt, { AbortError: r, codes: n } = sn, { isNodeStream: o, isWebStream: s, kControllerErrorFunction: a } = Ao, l = ws, { ERR_INVALID_ARG_TYPE: u } = n;
  let f;
  const c = (d, h) => {
    if (typeof d != "object" || !("aborted" in d))
      throw new u(h, "AbortSignal", d);
  };
  e.exports.addAbortSignal = function(h, p) {
    if (c(h, "signal"), !o(p) && !s(p))
      throw new u("stream", ["ReadableStream", "WritableStream", "Stream"], p);
    return e.exports.addAbortSignalNoValidate(h, p);
  }, e.exports.addAbortSignalNoValidate = function(d, h) {
    if (typeof d != "object" || !("aborted" in d))
      return h;
    const p = o(h) ? () => {
      h.destroy(
        new r(void 0, {
          cause: d.reason
        })
      );
    } : () => {
      h[a](
        new r(void 0, {
          cause: d.reason
        })
      );
    };
    if (d.aborted)
      p();
    else {
      f = f || zr.addAbortListener;
      const m = f(d, p);
      l(h, m[t]);
    }
    return h;
  };
})(f7);
var Qp = f7.exports;
const { StringPrototypeSlice: FC, SymbolIterator: uie, TypedArrayPrototypeSet: ad, Uint8Array: fie } = Bt, { Buffer: gy } = ut, { inspect: cie } = zr;
var die = class {
  constructor() {
    this.head = null, this.tail = null, this.length = 0;
  }
  push(t) {
    const r = {
      data: t,
      next: null
    };
    this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
  }
  unshift(t) {
    const r = {
      data: t,
      next: this.head
    };
    this.length === 0 && (this.tail = r), this.head = r, ++this.length;
  }
  shift() {
    if (this.length === 0)
      return;
    const t = this.head.data;
    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
  }
  clear() {
    this.head = this.tail = null, this.length = 0;
  }
  join(t) {
    if (this.length === 0)
      return "";
    let r = this.head, n = "" + r.data;
    for (; (r = r.next) !== null; )
      n += t + r.data;
    return n;
  }
  concat(t) {
    if (this.length === 0)
      return gy.alloc(0);
    const r = gy.allocUnsafe(t >>> 0);
    let n = this.head, o = 0;
    for (; n; )
      ad(r, n.data, o), o += n.data.length, n = n.next;
    return r;
  }
  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(t, r) {
    const n = this.head.data;
    if (t < n.length) {
      const o = n.slice(0, t);
      return this.head.data = n.slice(t), o;
    }
    return t === n.length ? this.shift() : r ? this._getString(t) : this._getBuffer(t);
  }
  first() {
    return this.head.data;
  }
  *[uie]() {
    for (let t = this.head; t; t = t.next)
      yield t.data;
  }
  // Consumes a specified amount of characters from the buffered data.
  _getString(t) {
    let r = "", n = this.head, o = 0;
    do {
      const s = n.data;
      if (t > s.length)
        r += s, t -= s.length;
      else {
        t === s.length ? (r += s, ++o, n.next ? this.head = n.next : this.head = this.tail = null) : (r += FC(s, 0, t), this.head = n, n.data = FC(s, t));
        break;
      }
      ++o;
    } while ((n = n.next) !== null);
    return this.length -= o, r;
  }
  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(t) {
    const r = gy.allocUnsafe(t), n = t;
    let o = this.head, s = 0;
    do {
      const a = o.data;
      if (t > a.length)
        ad(r, a, n - t), t -= a.length;
      else {
        t === a.length ? (ad(r, a, n - t), ++s, o.next ? this.head = o.next : this.head = this.tail = null) : (ad(r, new fie(a.buffer, a.byteOffset, t), n - t), this.head = o, o.data = a.slice(t));
        break;
      }
      ++s;
    } while ((o = o.next) !== null);
    return this.length -= s, r;
  }
  // Make sure the linked list only shows the minimal necessary information.
  [Symbol.for("nodejs.util.inspect.custom")](t, r) {
    return cie(this, {
      ...r,
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: !1
    });
  }
};
const { MathFloor: hie, NumberIsInteger: pie } = Bt, { validateInteger: gie } = vc, { ERR_INVALID_ARG_VALUE: bie } = sn.codes;
let c7 = 16 * 1024, d7 = 16;
function yie(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function h7(e) {
  return e ? d7 : c7;
}
function mie(e, t) {
  gie(t, "value", 0), e ? d7 = t : c7 = t;
}
function vie(e, t, r, n) {
  const o = yie(t, n, r);
  if (o != null) {
    if (!pie(o) || o < 0) {
      const s = n ? `options.${r}` : "options.highWaterMark";
      throw new bie(s, o);
    }
    return hie(o);
  }
  return h7(e.objectMode);
}
var Zp = {
  getHighWaterMark: vie,
  getDefaultHighWaterMark: h7,
  setDefaultHighWaterMark: mie
};
const jC = _t, { PromisePrototypeThen: wie, SymbolAsyncIterator: BC, SymbolIterator: qC } = Bt, { Buffer: _ie } = ut, { ERR_INVALID_ARG_TYPE: Sie, ERR_STREAM_NULL_VALUES: Eie } = sn.codes;
function xie(e, t, r) {
  let n;
  if (typeof t == "string" || t instanceof _ie)
    return new e({
      objectMode: !0,
      ...r,
      read() {
        this.push(t), this.push(null);
      }
    });
  let o;
  if (t && t[BC])
    o = !0, n = t[BC]();
  else if (t && t[qC])
    o = !1, n = t[qC]();
  else
    throw new Sie("iterable", ["Iterable"], t);
  const s = new e({
    objectMode: !0,
    highWaterMark: 1,
    // TODO(ronag): What options should be allowed?
    ...r
  });
  let a = !1;
  s._read = function() {
    a || (a = !0, u());
  }, s._destroy = function(f, c) {
    wie(
      l(f),
      () => jC.nextTick(c, f),
      // nextTick is here in case cb throws
      (d) => jC.nextTick(c, d || f)
    );
  };
  async function l(f) {
    const c = f != null, d = typeof n.throw == "function";
    if (c && d) {
      const { value: h, done: p } = await n.throw(f);
      if (await h, p)
        return;
    }
    if (typeof n.return == "function") {
      const { value: h } = await n.return();
      await h;
    }
  }
  async function u() {
    for (; ; ) {
      try {
        const { value: f, done: c } = o ? await n.next() : n.next();
        if (c)
          s.push(null);
        else {
          const d = f && typeof f.then == "function" ? await f : f;
          if (d === null)
            throw a = !1, new Eie();
          if (s.push(d))
            continue;
          a = !1;
        }
      } catch (f) {
        s.destroy(f);
      }
      break;
    }
  }
  return s;
}
var p7 = xie, by, WC;
function eg() {
  if (WC)
    return by;
  WC = 1;
  const e = _t, {
    ArrayPrototypeIndexOf: t,
    NumberIsInteger: r,
    NumberIsNaN: n,
    NumberParseInt: o,
    ObjectDefineProperties: s,
    ObjectKeys: a,
    ObjectSetPrototypeOf: l,
    Promise: u,
    SafeSet: f,
    SymbolAsyncDispose: c,
    SymbolAsyncIterator: d,
    Symbol: h
  } = Bt;
  by = B, B.ReadableState = ye;
  const { EventEmitter: p } = ur, { Stream: m, prependListener: y } = $x, { Buffer: _ } = ut, { addAbortSignal: S } = Qp, x = ws;
  let E = zr.debuglog("stream", (g) => {
    E = g;
  });
  const C = die, I = pu, { getHighWaterMark: j, getDefaultHighWaterMark: J } = Zp, {
    aggregateTwoErrors: G,
    codes: {
      ERR_INVALID_ARG_TYPE: $,
      ERR_METHOD_NOT_IMPLEMENTED: V,
      ERR_OUT_OF_RANGE: M,
      ERR_STREAM_PUSH_AFTER_EOF: W,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT: k
    },
    AbortError: U
  } = sn, { validateObject: Z } = vc, Y = h("kPaused"), { StringDecoder: te } = Hl(), se = p7;
  l(B.prototype, m.prototype), l(B, m);
  const fe = () => {
  }, { errorOrDestroy: he } = I, ae = 1, be = 2, H = 4, pe = 8, ke = 16, le = 32, ee = 64, ge = 128, Ae = 256, Oe = 512, K = 1024, z = 2048, b = 4096, w = 8192, T = 16384, O = 32768, L = 65536, ne = 1 << 17, ue = 1 << 18;
  function oe(g) {
    return {
      enumerable: !1,
      get() {
        return (this.state & g) !== 0;
      },
      set(v) {
        v ? this.state |= g : this.state &= ~g;
      }
    };
  }
  s(ye.prototype, {
    objectMode: oe(ae),
    ended: oe(be),
    endEmitted: oe(H),
    reading: oe(pe),
    // Stream is still being constructed and cannot be
    // destroyed until construction finished or failed.
    // Async construction is opt in, therefore we start as
    // constructed.
    constructed: oe(ke),
    // A flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    sync: oe(le),
    // Whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    needReadable: oe(ee),
    emittedReadable: oe(ge),
    readableListening: oe(Ae),
    resumeScheduled: oe(Oe),
    // True if the error was already emitted and should not be thrown again.
    errorEmitted: oe(K),
    emitClose: oe(z),
    autoDestroy: oe(b),
    // Has it been destroyed.
    destroyed: oe(w),
    // Indicates whether the stream has finished destroying.
    closed: oe(T),
    // True if close has been emitted or would have been emitted
    // depending on emitClose.
    closeEmitted: oe(O),
    multiAwaitDrain: oe(L),
    // If true, a maybeReadMore has been scheduled.
    readingMore: oe(ne),
    dataEmitted: oe(ue)
  });
  function ye(g, v, F) {
    typeof F != "boolean" && (F = v instanceof uo()), this.state = z | b | ke | le, g && g.objectMode && (this.state |= ae), F && g && g.readableObjectMode && (this.state |= ae), this.highWaterMark = g ? j(this, g, "readableHighWaterMark", F) : J(!1), this.buffer = new C(), this.length = 0, this.pipes = [], this.flowing = null, this[Y] = null, g && g.emitClose === !1 && (this.state &= ~z), g && g.autoDestroy === !1 && (this.state &= ~b), this.errored = null, this.defaultEncoding = g && g.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, g && g.encoding && (this.decoder = new te(g.encoding), this.encoding = g.encoding);
  }
  function B(g) {
    if (!(this instanceof B))
      return new B(g);
    const v = this instanceof uo();
    this._readableState = new ye(g, this, v), g && (typeof g.read == "function" && (this._read = g.read), typeof g.destroy == "function" && (this._destroy = g.destroy), typeof g.construct == "function" && (this._construct = g.construct), g.signal && !v && S(g.signal, this)), m.call(this, g), I.construct(this, () => {
      this._readableState.needReadable && re(this, this._readableState);
    });
  }
  B.prototype.destroy = I.destroy, B.prototype._undestroy = I.undestroy, B.prototype._destroy = function(g, v) {
    v(g);
  }, B.prototype[p.captureRejectionSymbol] = function(g) {
    this.destroy(g);
  }, B.prototype[c] = function() {
    let g;
    return this.destroyed || (g = this.readableEnded ? null : new U(), this.destroy(g)), new u((v, F) => x(this, (D) => D && D !== g ? F(D) : v(null)));
  }, B.prototype.push = function(g, v) {
    return me(this, g, v, !1);
  }, B.prototype.unshift = function(g, v) {
    return me(this, g, v, !0);
  };
  function me(g, v, F, D) {
    E("readableAddChunk", v);
    const X = g._readableState;
    let Le;
    if (X.state & ae || (typeof v == "string" ? (F = F || X.defaultEncoding, X.encoding !== F && (D && X.encoding ? v = _.from(v, F).toString(X.encoding) : (v = _.from(v, F), F = ""))) : v instanceof _ ? F = "" : m._isUint8Array(v) ? (v = m._uint8ArrayToBuffer(v), F = "") : v != null && (Le = new $("chunk", ["string", "Buffer", "Uint8Array"], v))), Le)
      he(g, Le);
    else if (v === null)
      X.state &= ~pe, R(g, X);
    else if (X.state & ae || v && v.length > 0)
      if (D)
        if (X.state & H)
          he(g, new k());
        else {
          if (X.destroyed || X.errored)
            return !1;
          Ce(g, X, v, !0);
        }
      else if (X.ended)
        he(g, new W());
      else {
        if (X.destroyed || X.errored)
          return !1;
        X.state &= ~pe, X.decoder && !F ? (v = X.decoder.write(v), X.objectMode || v.length !== 0 ? Ce(g, X, v, !1) : re(g, X)) : Ce(g, X, v, !1);
      }
    else
      D || (X.state &= ~pe, re(g, X));
    return !X.ended && (X.length < X.highWaterMark || X.length === 0);
  }
  function Ce(g, v, F, D) {
    v.flowing && v.length === 0 && !v.sync && g.listenerCount("data") > 0 ? (v.state & L ? v.awaitDrainWriters.clear() : v.awaitDrainWriters = null, v.dataEmitted = !0, g.emit("data", F)) : (v.length += v.objectMode ? 1 : F.length, D ? v.buffer.unshift(F) : v.buffer.push(F), v.state & ee && A(g)), re(g, v);
  }
  B.prototype.isPaused = function() {
    const g = this._readableState;
    return g[Y] === !0 || g.flowing === !1;
  }, B.prototype.setEncoding = function(g) {
    const v = new te(g);
    this._readableState.decoder = v, this._readableState.encoding = this._readableState.decoder.encoding;
    const F = this._readableState.buffer;
    let D = "";
    for (const X of F)
      D += v.write(X);
    return F.clear(), D !== "" && F.push(D), this._readableState.length = D.length, this;
  };
  const Ie = 1073741824;
  function Me(g) {
    if (g > Ie)
      throw new M("size", "<= 1GiB", g);
    return g--, g |= g >>> 1, g |= g >>> 2, g |= g >>> 4, g |= g >>> 8, g |= g >>> 16, g++, g;
  }
  function N(g, v) {
    return g <= 0 || v.length === 0 && v.ended ? 0 : v.state & ae ? 1 : n(g) ? v.flowing && v.length ? v.buffer.first().length : v.length : g <= v.length ? g : v.ended ? v.length : 0;
  }
  B.prototype.read = function(g) {
    E("read", g), g === void 0 ? g = NaN : r(g) || (g = o(g, 10));
    const v = this._readableState, F = g;
    if (g > v.highWaterMark && (v.highWaterMark = Me(g)), g !== 0 && (v.state &= ~ge), g === 0 && v.needReadable && ((v.highWaterMark !== 0 ? v.length >= v.highWaterMark : v.length > 0) || v.ended))
      return E("read: emitReadable", v.length, v.ended), v.length === 0 && v.ended ? At(this) : A(this), null;
    if (g = N(g, v), g === 0 && v.ended)
      return v.length === 0 && At(this), null;
    let D = (v.state & ee) !== 0;
    if (E("need readable", D), (v.length === 0 || v.length - g < v.highWaterMark) && (D = !0, E("length less than watermark", D)), v.ended || v.reading || v.destroyed || v.errored || !v.constructed)
      D = !1, E("reading, ended or constructing", D);
    else if (D) {
      E("do read"), v.state |= pe | le, v.length === 0 && (v.state |= ee);
      try {
        this._read(v.highWaterMark);
      } catch (Le) {
        he(this, Le);
      }
      v.state &= ~le, v.reading || (g = N(F, v));
    }
    let X;
    return g > 0 ? X = Lr(g, v) : X = null, X === null ? (v.needReadable = v.length <= v.highWaterMark, g = 0) : (v.length -= g, v.multiAwaitDrain ? v.awaitDrainWriters.clear() : v.awaitDrainWriters = null), v.length === 0 && (v.ended || (v.needReadable = !0), F !== g && v.ended && At(this)), X !== null && !v.errorEmitted && !v.closeEmitted && (v.dataEmitted = !0, this.emit("data", X)), X;
  };
  function R(g, v) {
    if (E("onEofChunk"), !v.ended) {
      if (v.decoder) {
        const F = v.decoder.end();
        F && F.length && (v.buffer.push(F), v.length += v.objectMode ? 1 : F.length);
      }
      v.ended = !0, v.sync ? A(g) : (v.needReadable = !1, v.emittedReadable = !0, q(g));
    }
  }
  function A(g) {
    const v = g._readableState;
    E("emitReadable", v.needReadable, v.emittedReadable), v.needReadable = !1, v.emittedReadable || (E("emitReadable", v.flowing), v.emittedReadable = !0, e.nextTick(q, g));
  }
  function q(g) {
    const v = g._readableState;
    E("emitReadable_", v.destroyed, v.length, v.ended), !v.destroyed && !v.errored && (v.length || v.ended) && (g.emit("readable"), v.emittedReadable = !1), v.needReadable = !v.flowing && !v.ended && v.length <= v.highWaterMark, Ze(g);
  }
  function re(g, v) {
    !v.readingMore && v.constructed && (v.readingMore = !0, e.nextTick(ce, g, v));
  }
  function ce(g, v) {
    for (; !v.reading && !v.ended && (v.length < v.highWaterMark || v.flowing && v.length === 0); ) {
      const F = v.length;
      if (E("maybeReadMore read 0"), g.read(0), F === v.length)
        break;
    }
    v.readingMore = !1;
  }
  B.prototype._read = function(g) {
    throw new V("_read()");
  }, B.prototype.pipe = function(g, v) {
    const F = this, D = this._readableState;
    D.pipes.length === 1 && (D.multiAwaitDrain || (D.multiAwaitDrain = !0, D.awaitDrainWriters = new f(D.awaitDrainWriters ? [D.awaitDrainWriters] : []))), D.pipes.push(g), E("pipe count=%d opts=%j", D.pipes.length, v);
    const Le = (!v || v.end !== !1) && g !== e.stdout && g !== e.stderr ? Xt : St;
    D.endEmitted ? e.nextTick(Le) : F.once("end", Le), g.on("unpipe", We);
    function We(ft, rt) {
      E("onunpipe"), ft === F && rt && rt.hasUnpiped === !1 && (rt.hasUnpiped = !0, yn());
    }
    function Xt() {
      E("onend"), g.end();
    }
    let dt, Kr = !1;
    function yn() {
      E("cleanup"), g.removeListener("close", or), g.removeListener("finish", dr), dt && g.removeListener("drain", dt), g.removeListener("error", cr), g.removeListener("unpipe", We), F.removeListener("end", Xt), F.removeListener("end", St), F.removeListener("data", xr), Kr = !0, dt && D.awaitDrainWriters && (!g._writableState || g._writableState.needDrain) && dt();
    }
    function Wt() {
      Kr || (D.pipes.length === 1 && D.pipes[0] === g ? (E("false write response, pause", 0), D.awaitDrainWriters = g, D.multiAwaitDrain = !1) : D.pipes.length > 1 && D.pipes.includes(g) && (E("false write response, pause", D.awaitDrainWriters.size), D.awaitDrainWriters.add(g)), F.pause()), dt || (dt = de(F, g), g.on("drain", dt));
    }
    F.on("data", xr);
    function xr(ft) {
      E("ondata");
      const rt = g.write(ft);
      E("dest.write", rt), rt === !1 && Wt();
    }
    function cr(ft) {
      if (E("onerror", ft), St(), g.removeListener("error", cr), g.listenerCount("error") === 0) {
        const rt = g._writableState || g._readableState;
        rt && !rt.errorEmitted ? he(g, ft) : g.emit("error", ft);
      }
    }
    y(g, "error", cr);
    function or() {
      g.removeListener("finish", dr), St();
    }
    g.once("close", or);
    function dr() {
      E("onfinish"), g.removeListener("close", or), St();
    }
    g.once("finish", dr);
    function St() {
      E("unpipe"), F.unpipe(g);
    }
    return g.emit("pipe", F), g.writableNeedDrain === !0 ? Wt() : D.flowing || (E("pipe resume"), F.resume()), g;
  };
  function de(g, v) {
    return function() {
      const D = g._readableState;
      D.awaitDrainWriters === v ? (E("pipeOnDrain", 1), D.awaitDrainWriters = null) : D.multiAwaitDrain && (E("pipeOnDrain", D.awaitDrainWriters.size), D.awaitDrainWriters.delete(v)), (!D.awaitDrainWriters || D.awaitDrainWriters.size === 0) && g.listenerCount("data") && g.resume();
    };
  }
  B.prototype.unpipe = function(g) {
    const v = this._readableState, F = {
      hasUnpiped: !1
    };
    if (v.pipes.length === 0)
      return this;
    if (!g) {
      const X = v.pipes;
      v.pipes = [], this.pause();
      for (let Le = 0; Le < X.length; Le++)
        X[Le].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    const D = t(v.pipes, g);
    return D === -1 ? this : (v.pipes.splice(D, 1), v.pipes.length === 0 && this.pause(), g.emit("unpipe", this, F), this);
  }, B.prototype.on = function(g, v) {
    const F = m.prototype.on.call(this, g, v), D = this._readableState;
    return g === "data" ? (D.readableListening = this.listenerCount("readable") > 0, D.flowing !== !1 && this.resume()) : g === "readable" && !D.endEmitted && !D.readableListening && (D.readableListening = D.needReadable = !0, D.flowing = !1, D.emittedReadable = !1, E("on readable", D.length, D.reading), D.length ? A(this) : D.reading || e.nextTick(it, this)), F;
  }, B.prototype.addListener = B.prototype.on, B.prototype.removeListener = function(g, v) {
    const F = m.prototype.removeListener.call(this, g, v);
    return g === "readable" && e.nextTick(De, this), F;
  }, B.prototype.off = B.prototype.removeListener, B.prototype.removeAllListeners = function(g) {
    const v = m.prototype.removeAllListeners.apply(this, arguments);
    return (g === "readable" || g === void 0) && e.nextTick(De, this), v;
  };
  function De(g) {
    const v = g._readableState;
    v.readableListening = g.listenerCount("readable") > 0, v.resumeScheduled && v[Y] === !1 ? v.flowing = !0 : g.listenerCount("data") > 0 ? g.resume() : v.readableListening || (v.flowing = null);
  }
  function it(g) {
    E("readable nexttick read 0"), g.read(0);
  }
  B.prototype.resume = function() {
    const g = this._readableState;
    return g.flowing || (E("resume"), g.flowing = !g.readableListening, ze(this, g)), g[Y] = !1, this;
  };
  function ze(g, v) {
    v.resumeScheduled || (v.resumeScheduled = !0, e.nextTick(Ve, g, v));
  }
  function Ve(g, v) {
    E("resume", v.reading), v.reading || g.read(0), v.resumeScheduled = !1, g.emit("resume"), Ze(g), v.flowing && !v.reading && g.read(0);
  }
  B.prototype.pause = function() {
    return E("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (E("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState[Y] = !0, this;
  };
  function Ze(g) {
    const v = g._readableState;
    for (E("flow", v.flowing); v.flowing && g.read() !== null; )
      ;
  }
  B.prototype.wrap = function(g) {
    let v = !1;
    g.on("data", (D) => {
      !this.push(D) && g.pause && (v = !0, g.pause());
    }), g.on("end", () => {
      this.push(null);
    }), g.on("error", (D) => {
      he(this, D);
    }), g.on("close", () => {
      this.destroy();
    }), g.on("destroy", () => {
      this.destroy();
    }), this._read = () => {
      v && g.resume && (v = !1, g.resume());
    };
    const F = a(g);
    for (let D = 1; D < F.length; D++) {
      const X = F[D];
      this[X] === void 0 && typeof g[X] == "function" && (this[X] = g[X].bind(g));
    }
    return this;
  }, B.prototype[d] = function() {
    return Er(this);
  }, B.prototype.iterator = function(g) {
    return g !== void 0 && Z(g, "options"), Er(this, g);
  };
  function Er(g, v) {
    typeof g.read != "function" && (g = B.wrap(g, {
      objectMode: !0
    }));
    const F = Wi(g, v);
    return F.stream = g, F;
  }
  async function* Wi(g, v) {
    let F = fe;
    function D(We) {
      this === g ? (F(), F = fe) : F = We;
    }
    g.on("readable", D);
    let X;
    const Le = x(
      g,
      {
        writable: !1
      },
      (We) => {
        X = We ? G(X, We) : null, F(), F = fe;
      }
    );
    try {
      for (; ; ) {
        const We = g.destroyed ? null : g.read();
        if (We !== null)
          yield We;
        else {
          if (X)
            throw X;
          if (X === null)
            return;
          await new u(D);
        }
      }
    } catch (We) {
      throw X = G(X, We), X;
    } finally {
      (X || (v == null ? void 0 : v.destroyOnReturn) !== !1) && (X === void 0 || g._readableState.autoDestroy) ? I.destroyer(g, null) : (g.off("readable", D), Le());
    }
  }
  s(B.prototype, {
    readable: {
      __proto__: null,
      get() {
        const g = this._readableState;
        return !!g && g.readable !== !1 && !g.destroyed && !g.errorEmitted && !g.endEmitted;
      },
      set(g) {
        this._readableState && (this._readableState.readable = !!g);
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(g) {
        this._readableState && (this._readableState.flowing = g);
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.objectMode : !1;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.destroyed : !1;
      },
      set(g) {
        this._readableState && (this._readableState.destroyed = g);
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.endEmitted : !1;
      }
    }
  }), s(ye.prototype, {
    // Legacy getter for `pipesCount`.
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    // Legacy property for `paused`.
    paused: {
      __proto__: null,
      get() {
        return this[Y] !== !1;
      },
      set(g) {
        this[Y] = !!g;
      }
    }
  }), B._fromList = Lr;
  function Lr(g, v) {
    if (v.length === 0)
      return null;
    let F;
    return v.objectMode ? F = v.buffer.shift() : !g || g >= v.length ? (v.decoder ? F = v.buffer.join("") : v.buffer.length === 1 ? F = v.buffer.first() : F = v.buffer.concat(v.length), v.buffer.clear()) : F = v.buffer.consume(g, v.decoder), F;
  }
  function At(g) {
    const v = g._readableState;
    E("endReadable", v.endEmitted), v.endEmitted || (v.ended = !0, e.nextTick(si, v, g));
  }
  function si(g, v) {
    if (E("endReadableNT", g.endEmitted, g.length), !g.errored && !g.closeEmitted && !g.endEmitted && g.length === 0) {
      if (g.endEmitted = !0, v.emit("end"), v.writable && v.allowHalfOpen === !1)
        e.nextTick(Ui, v);
      else if (g.autoDestroy) {
        const F = v._writableState;
        (!F || F.autoDestroy && // We don't expect the writable to ever 'finish'
        // if writable is explicitly set to false.
        (F.finished || F.writable === !1)) && v.destroy();
      }
    }
  }
  function Ui(g) {
    g.writable && !g.writableEnded && !g.destroyed && g.end();
  }
  B.from = function(g, v) {
    return se(B, g, v);
  };
  let Nt;
  function ln() {
    return Nt === void 0 && (Nt = {}), Nt;
  }
  return B.fromWeb = function(g, v) {
    return ln().newStreamReadableFromReadableStream(g, v);
  }, B.toWeb = function(g, v) {
    return ln().newReadableStreamFromStreamReadable(g, v);
  }, B.wrap = function(g, v) {
    var F, D;
    return new B({
      objectMode: (F = (D = g.readableObjectMode) !== null && D !== void 0 ? D : g.objectMode) !== null && F !== void 0 ? F : !0,
      ...v,
      destroy(X, Le) {
        I.destroyer(g, X), Le(X);
      }
    }).wrap(g);
  }, by;
}
var yy, UC;
function Cx() {
  if (UC)
    return yy;
  UC = 1;
  const e = _t, {
    ArrayPrototypeSlice: t,
    Error: r,
    FunctionPrototypeSymbolHasInstance: n,
    ObjectDefineProperty: o,
    ObjectDefineProperties: s,
    ObjectSetPrototypeOf: a,
    StringPrototypeToLowerCase: l,
    Symbol: u,
    SymbolHasInstance: f
  } = Bt;
  yy = Z, Z.WritableState = k;
  const { EventEmitter: c } = ur, d = $x.Stream, { Buffer: h } = ut, p = pu, { addAbortSignal: m } = Qp, { getHighWaterMark: y, getDefaultHighWaterMark: _ } = Zp, {
    ERR_INVALID_ARG_TYPE: S,
    ERR_METHOD_NOT_IMPLEMENTED: x,
    ERR_MULTIPLE_CALLBACK: E,
    ERR_STREAM_CANNOT_PIPE: C,
    ERR_STREAM_DESTROYED: I,
    ERR_STREAM_ALREADY_FINISHED: j,
    ERR_STREAM_NULL_VALUES: J,
    ERR_STREAM_WRITE_AFTER_END: G,
    ERR_UNKNOWN_ENCODING: $
  } = sn.codes, { errorOrDestroy: V } = p;
  a(Z.prototype, d.prototype), a(Z, d);
  function M() {
  }
  const W = u("kOnFinished");
  function k(b, w, T) {
    typeof T != "boolean" && (T = w instanceof uo()), this.objectMode = !!(b && b.objectMode), T && (this.objectMode = this.objectMode || !!(b && b.writableObjectMode)), this.highWaterMark = b ? y(this, b, "writableHighWaterMark", T) : _(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    const O = !!(b && b.decodeStrings === !1);
    this.decodeStrings = !O, this.defaultEncoding = b && b.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = he.bind(void 0, w), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, U(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !b || b.emitClose !== !1, this.autoDestroy = !b || b.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[W] = [];
  }
  function U(b) {
    b.buffered = [], b.bufferedIndex = 0, b.allBuffers = !0, b.allNoop = !0;
  }
  k.prototype.getBuffer = function() {
    return t(this.buffered, this.bufferedIndex);
  }, o(k.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function Z(b) {
    const w = this instanceof uo();
    if (!w && !n(Z, this))
      return new Z(b);
    this._writableState = new k(b, this, w), b && (typeof b.write == "function" && (this._write = b.write), typeof b.writev == "function" && (this._writev = b.writev), typeof b.destroy == "function" && (this._destroy = b.destroy), typeof b.final == "function" && (this._final = b.final), typeof b.construct == "function" && (this._construct = b.construct), b.signal && m(b.signal, this)), d.call(this, b), p.construct(this, () => {
      const T = this._writableState;
      T.writing || pe(this, T), ge(this, T);
    });
  }
  o(Z, f, {
    __proto__: null,
    value: function(b) {
      return n(this, b) ? !0 : this !== Z ? !1 : b && b._writableState instanceof k;
    }
  }), Z.prototype.pipe = function() {
    V(this, new C());
  };
  function Y(b, w, T, O) {
    const L = b._writableState;
    if (typeof T == "function")
      O = T, T = L.defaultEncoding;
    else {
      if (!T)
        T = L.defaultEncoding;
      else if (T !== "buffer" && !h.isEncoding(T))
        throw new $(T);
      typeof O != "function" && (O = M);
    }
    if (w === null)
      throw new J();
    if (!L.objectMode)
      if (typeof w == "string")
        L.decodeStrings !== !1 && (w = h.from(w, T), T = "buffer");
      else if (w instanceof h)
        T = "buffer";
      else if (d._isUint8Array(w))
        w = d._uint8ArrayToBuffer(w), T = "buffer";
      else
        throw new S("chunk", ["string", "Buffer", "Uint8Array"], w);
    let ne;
    return L.ending ? ne = new G() : L.destroyed && (ne = new I("write")), ne ? (e.nextTick(O, ne), V(b, ne, !0), ne) : (L.pendingcb++, te(b, L, w, T, O));
  }
  Z.prototype.write = function(b, w, T) {
    return Y(this, b, w, T) === !0;
  }, Z.prototype.cork = function() {
    this._writableState.corked++;
  }, Z.prototype.uncork = function() {
    const b = this._writableState;
    b.corked && (b.corked--, b.writing || pe(this, b));
  }, Z.prototype.setDefaultEncoding = function(w) {
    if (typeof w == "string" && (w = l(w)), !h.isEncoding(w))
      throw new $(w);
    return this._writableState.defaultEncoding = w, this;
  };
  function te(b, w, T, O, L) {
    const ne = w.objectMode ? 1 : T.length;
    w.length += ne;
    const ue = w.length < w.highWaterMark;
    return ue || (w.needDrain = !0), w.writing || w.corked || w.errored || !w.constructed ? (w.buffered.push({
      chunk: T,
      encoding: O,
      callback: L
    }), w.allBuffers && O !== "buffer" && (w.allBuffers = !1), w.allNoop && L !== M && (w.allNoop = !1)) : (w.writelen = ne, w.writecb = L, w.writing = !0, w.sync = !0, b._write(T, O, w.onwrite), w.sync = !1), ue && !w.errored && !w.destroyed;
  }
  function se(b, w, T, O, L, ne, ue) {
    w.writelen = O, w.writecb = ue, w.writing = !0, w.sync = !0, w.destroyed ? w.onwrite(new I("write")) : T ? b._writev(L, w.onwrite) : b._write(L, ne, w.onwrite), w.sync = !1;
  }
  function fe(b, w, T, O) {
    --w.pendingcb, O(T), H(w), V(b, T);
  }
  function he(b, w) {
    const T = b._writableState, O = T.sync, L = T.writecb;
    if (typeof L != "function") {
      V(b, new E());
      return;
    }
    T.writing = !1, T.writecb = null, T.length -= T.writelen, T.writelen = 0, w ? (w.stack, T.errored || (T.errored = w), b._readableState && !b._readableState.errored && (b._readableState.errored = w), O ? e.nextTick(fe, b, T, w, L) : fe(b, T, w, L)) : (T.buffered.length > T.bufferedIndex && pe(b, T), O ? T.afterWriteTickInfo !== null && T.afterWriteTickInfo.cb === L ? T.afterWriteTickInfo.count++ : (T.afterWriteTickInfo = {
      count: 1,
      cb: L,
      stream: b,
      state: T
    }, e.nextTick(ae, T.afterWriteTickInfo)) : be(b, T, 1, L));
  }
  function ae({ stream: b, state: w, count: T, cb: O }) {
    return w.afterWriteTickInfo = null, be(b, w, T, O);
  }
  function be(b, w, T, O) {
    for (!w.ending && !b.destroyed && w.length === 0 && w.needDrain && (w.needDrain = !1, b.emit("drain")); T-- > 0; )
      w.pendingcb--, O();
    w.destroyed && H(w), ge(b, w);
  }
  function H(b) {
    if (b.writing)
      return;
    for (let L = b.bufferedIndex; L < b.buffered.length; ++L) {
      var w;
      const { chunk: ne, callback: ue } = b.buffered[L], oe = b.objectMode ? 1 : ne.length;
      b.length -= oe, ue(
        (w = b.errored) !== null && w !== void 0 ? w : new I("write")
      );
    }
    const T = b[W].splice(0);
    for (let L = 0; L < T.length; L++) {
      var O;
      T[L](
        (O = b.errored) !== null && O !== void 0 ? O : new I("end")
      );
    }
    U(b);
  }
  function pe(b, w) {
    if (w.corked || w.bufferProcessing || w.destroyed || !w.constructed)
      return;
    const { buffered: T, bufferedIndex: O, objectMode: L } = w, ne = T.length - O;
    if (!ne)
      return;
    let ue = O;
    if (w.bufferProcessing = !0, ne > 1 && b._writev) {
      w.pendingcb -= ne - 1;
      const oe = w.allNoop ? M : (B) => {
        for (let me = ue; me < T.length; ++me)
          T[me].callback(B);
      }, ye = w.allNoop && ue === 0 ? T : t(T, ue);
      ye.allBuffers = w.allBuffers, se(b, w, !0, w.length, ye, "", oe), U(w);
    } else {
      do {
        const { chunk: oe, encoding: ye, callback: B } = T[ue];
        T[ue++] = null;
        const me = L ? 1 : oe.length;
        se(b, w, !1, me, oe, ye, B);
      } while (ue < T.length && !w.writing);
      ue === T.length ? U(w) : ue > 256 ? (T.splice(0, ue), w.bufferedIndex = 0) : w.bufferedIndex = ue;
    }
    w.bufferProcessing = !1;
  }
  Z.prototype._write = function(b, w, T) {
    if (this._writev)
      this._writev(
        [
          {
            chunk: b,
            encoding: w
          }
        ],
        T
      );
    else
      throw new x("_write()");
  }, Z.prototype._writev = null, Z.prototype.end = function(b, w, T) {
    const O = this._writableState;
    typeof b == "function" ? (T = b, b = null, w = null) : typeof w == "function" && (T = w, w = null);
    let L;
    if (b != null) {
      const ne = Y(this, b, w);
      ne instanceof r && (L = ne);
    }
    return O.corked && (O.corked = 1, this.uncork()), L || (!O.errored && !O.ending ? (O.ending = !0, ge(this, O, !0), O.ended = !0) : O.finished ? L = new j("end") : O.destroyed && (L = new I("end"))), typeof T == "function" && (L || O.finished ? e.nextTick(T, L) : O[W].push(T)), this;
  };
  function ke(b) {
    return b.ending && !b.destroyed && b.constructed && b.length === 0 && !b.errored && b.buffered.length === 0 && !b.finished && !b.writing && !b.errorEmitted && !b.closeEmitted;
  }
  function le(b, w) {
    let T = !1;
    function O(L) {
      if (T) {
        V(b, L ?? E());
        return;
      }
      if (T = !0, w.pendingcb--, L) {
        const ne = w[W].splice(0);
        for (let ue = 0; ue < ne.length; ue++)
          ne[ue](L);
        V(b, L, w.sync);
      } else
        ke(w) && (w.prefinished = !0, b.emit("prefinish"), w.pendingcb++, e.nextTick(Ae, b, w));
    }
    w.sync = !0, w.pendingcb++;
    try {
      b._final(O);
    } catch (L) {
      O(L);
    }
    w.sync = !1;
  }
  function ee(b, w) {
    !w.prefinished && !w.finalCalled && (typeof b._final == "function" && !w.destroyed ? (w.finalCalled = !0, le(b, w)) : (w.prefinished = !0, b.emit("prefinish")));
  }
  function ge(b, w, T) {
    ke(w) && (ee(b, w), w.pendingcb === 0 && (T ? (w.pendingcb++, e.nextTick(
      (O, L) => {
        ke(L) ? Ae(O, L) : L.pendingcb--;
      },
      b,
      w
    )) : ke(w) && (w.pendingcb++, Ae(b, w))));
  }
  function Ae(b, w) {
    w.pendingcb--, w.finished = !0;
    const T = w[W].splice(0);
    for (let O = 0; O < T.length; O++)
      T[O]();
    if (b.emit("finish"), w.autoDestroy) {
      const O = b._readableState;
      (!O || O.autoDestroy && // We don't expect the readable to ever 'end'
      // if readable is explicitly set to false.
      (O.endEmitted || O.readable === !1)) && b.destroy();
    }
  }
  s(Z.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : !1;
      },
      set(b) {
        this._writableState && (this._writableState.destroyed = b);
      }
    },
    writable: {
      __proto__: null,
      get() {
        const b = this._writableState;
        return !!b && b.writable !== !1 && !b.destroyed && !b.errored && !b.ending && !b.ended;
      },
      set(b) {
        this._writableState && (this._writableState.writable = !!b);
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : !1;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : !1;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : !1;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const b = this._writableState;
        return b ? !b.destroyed && !b.ending && b.needDrain : !1;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  const Oe = p.destroy;
  Z.prototype.destroy = function(b, w) {
    const T = this._writableState;
    return !T.destroyed && (T.bufferedIndex < T.buffered.length || T[W].length) && e.nextTick(H, T), Oe.call(this, b, w), this;
  }, Z.prototype._undestroy = p.undestroy, Z.prototype._destroy = function(b, w) {
    w(b);
  }, Z.prototype[c.captureRejectionSymbol] = function(b) {
    this.destroy(b);
  };
  let K;
  function z() {
    return K === void 0 && (K = {}), K;
  }
  return Z.fromWeb = function(b, w) {
    return z().newStreamWritableFromWritableStream(b, w);
  }, Z.toWeb = function(b) {
    return z().newWritableStreamFromStreamWritable(b);
  }, yy;
}
var my, HC;
function Rie() {
  if (HC)
    return my;
  HC = 1;
  const e = _t, t = ut, {
    isReadable: r,
    isWritable: n,
    isIterable: o,
    isNodeStream: s,
    isReadableNodeStream: a,
    isWritableNodeStream: l,
    isDuplexNodeStream: u,
    isReadableStream: f,
    isWritableStream: c
  } = Ao, d = ws, {
    AbortError: h,
    codes: { ERR_INVALID_ARG_TYPE: p, ERR_INVALID_RETURN_VALUE: m }
  } = sn, { destroyer: y } = pu, _ = uo(), S = eg(), x = Cx(), { createDeferredPromise: E } = zr, C = p7, I = globalThis.Blob || t.Blob, j = typeof I < "u" ? function(k) {
    return k instanceof I;
  } : function(k) {
    return !1;
  }, J = globalThis.AbortController || Kt().AbortController, { FunctionPrototypeCall: G } = Bt;
  class $ extends _ {
    constructor(k) {
      super(k), (k == null ? void 0 : k.readable) === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), (k == null ? void 0 : k.writable) === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0);
    }
  }
  my = function W(k, U) {
    if (u(k))
      return k;
    if (a(k))
      return M({
        readable: k
      });
    if (l(k))
      return M({
        writable: k
      });
    if (s(k))
      return M({
        writable: !1,
        readable: !1
      });
    if (f(k))
      return M({
        readable: S.fromWeb(k)
      });
    if (c(k))
      return M({
        writable: x.fromWeb(k)
      });
    if (typeof k == "function") {
      const { value: Y, write: te, final: se, destroy: fe } = V(k);
      if (o(Y))
        return C($, Y, {
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          write: te,
          final: se,
          destroy: fe
        });
      const he = Y == null ? void 0 : Y.then;
      if (typeof he == "function") {
        let ae;
        const be = G(
          he,
          Y,
          (H) => {
            if (H != null)
              throw new m("nully", "body", H);
          },
          (H) => {
            y(ae, H);
          }
        );
        return ae = new $({
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          readable: !1,
          write: te,
          final(H) {
            se(async () => {
              try {
                await be, e.nextTick(H, null);
              } catch (pe) {
                e.nextTick(H, pe);
              }
            });
          },
          destroy: fe
        });
      }
      throw new m("Iterable, AsyncIterable or AsyncFunction", U, Y);
    }
    if (j(k))
      return W(k.arrayBuffer());
    if (o(k))
      return C($, k, {
        // TODO (ronag): highWaterMark?
        objectMode: !0,
        writable: !1
      });
    if (f(k == null ? void 0 : k.readable) && c(k == null ? void 0 : k.writable))
      return $.fromWeb(k);
    if (typeof (k == null ? void 0 : k.writable) == "object" || typeof (k == null ? void 0 : k.readable) == "object") {
      const Y = k != null && k.readable ? a(k == null ? void 0 : k.readable) ? k == null ? void 0 : k.readable : W(k.readable) : void 0, te = k != null && k.writable ? l(k == null ? void 0 : k.writable) ? k == null ? void 0 : k.writable : W(k.writable) : void 0;
      return M({
        readable: Y,
        writable: te
      });
    }
    const Z = k == null ? void 0 : k.then;
    if (typeof Z == "function") {
      let Y;
      return G(
        Z,
        k,
        (te) => {
          te != null && Y.push(te), Y.push(null);
        },
        (te) => {
          y(Y, te);
        }
      ), Y = new $({
        objectMode: !0,
        writable: !1,
        read() {
        }
      });
    }
    throw new p(
      U,
      [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise"
      ],
      k
    );
  };
  function V(W) {
    let { promise: k, resolve: U } = E();
    const Z = new J(), Y = Z.signal;
    return {
      value: W(
        async function* () {
          for (; ; ) {
            const se = k;
            k = null;
            const { chunk: fe, done: he, cb: ae } = await se;
            if (e.nextTick(ae), he)
              return;
            if (Y.aborted)
              throw new h(void 0, {
                cause: Y.reason
              });
            ({ promise: k, resolve: U } = E()), yield fe;
          }
        }(),
        {
          signal: Y
        }
      ),
      write(se, fe, he) {
        const ae = U;
        U = null, ae({
          chunk: se,
          done: !1,
          cb: he
        });
      },
      final(se) {
        const fe = U;
        U = null, fe({
          done: !0,
          cb: se
        });
      },
      destroy(se, fe) {
        Z.abort(), fe(se);
      }
    };
  }
  function M(W) {
    const k = W.readable && typeof W.readable.read != "function" ? S.wrap(W.readable) : W.readable, U = W.writable;
    let Z = !!r(k), Y = !!n(U), te, se, fe, he, ae;
    function be(H) {
      const pe = he;
      he = null, pe ? pe(H) : H && ae.destroy(H);
    }
    return ae = new $({
      // TODO (ronag): highWaterMark?
      readableObjectMode: !!(k != null && k.readableObjectMode),
      writableObjectMode: !!(U != null && U.writableObjectMode),
      readable: Z,
      writable: Y
    }), Y && (d(U, (H) => {
      Y = !1, H && y(k, H), be(H);
    }), ae._write = function(H, pe, ke) {
      U.write(H, pe) ? ke() : te = ke;
    }, ae._final = function(H) {
      U.end(), se = H;
    }, U.on("drain", function() {
      if (te) {
        const H = te;
        te = null, H();
      }
    }), U.on("finish", function() {
      if (se) {
        const H = se;
        se = null, H();
      }
    })), Z && (d(k, (H) => {
      Z = !1, H && y(k, H), be(H);
    }), k.on("readable", function() {
      if (fe) {
        const H = fe;
        fe = null, H();
      }
    }), k.on("end", function() {
      ae.push(null);
    }), ae._read = function() {
      for (; ; ) {
        const H = k.read();
        if (H === null) {
          fe = ae._read;
          return;
        }
        if (!ae.push(H))
          return;
      }
    }), ae._destroy = function(H, pe) {
      !H && he !== null && (H = new h()), fe = null, te = null, se = null, he === null ? pe(H) : (he = pe, y(U, H), y(k, H));
    }, ae;
  }
  return my;
}
var vy, zC;
function uo() {
  if (zC)
    return vy;
  zC = 1;
  const {
    ObjectDefineProperties: e,
    ObjectGetOwnPropertyDescriptor: t,
    ObjectKeys: r,
    ObjectSetPrototypeOf: n
  } = Bt;
  vy = a;
  const o = eg(), s = Cx();
  n(a.prototype, o.prototype), n(a, o);
  {
    const c = r(s.prototype);
    for (let d = 0; d < c.length; d++) {
      const h = c[d];
      a.prototype[h] || (a.prototype[h] = s.prototype[h]);
    }
  }
  function a(c) {
    if (!(this instanceof a))
      return new a(c);
    o.call(this, c), s.call(this, c), c ? (this.allowHalfOpen = c.allowHalfOpen !== !1, c.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), c.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0)) : this.allowHalfOpen = !0;
  }
  e(a.prototype, {
    writable: {
      __proto__: null,
      ...t(s.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...t(s.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...t(s.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...t(s.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...t(s.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...t(s.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...t(s.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...t(s.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...t(s.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
      },
      set(c) {
        this._readableState && this._writableState && (this._readableState.destroyed = c, this._writableState.destroyed = c);
      }
    }
  });
  let l;
  function u() {
    return l === void 0 && (l = {}), l;
  }
  a.fromWeb = function(c, d) {
    return u().newStreamDuplexFromReadableWritablePair(c, d);
  }, a.toWeb = function(c) {
    return u().newReadableWritablePairFromDuplex(c);
  };
  let f;
  return a.from = function(c) {
    return f || (f = Rie()), f(c, "body");
  }, vy;
}
const { ObjectSetPrototypeOf: g7, Symbol: Aie } = Bt;
var b7 = fo;
const { ERR_METHOD_NOT_IMPLEMENTED: Tie } = sn.codes, kx = uo(), { getHighWaterMark: $ie } = Zp;
g7(fo.prototype, kx.prototype);
g7(fo, kx);
const Sf = Aie("kCallback");
function fo(e) {
  if (!(this instanceof fo))
    return new fo(e);
  const t = e ? $ie(this, e, "readableHighWaterMark", !0) : null;
  t === 0 && (e = {
    ...e,
    highWaterMark: null,
    readableHighWaterMark: t,
    // TODO (ronag): 0 is not optimal since we have
    // a "bug" where we check needDrain before calling _write and not after.
    // Refs: https://github.com/nodejs/node/pull/32887
    // Refs: https://github.com/nodejs/node/pull/35941
    writableHighWaterMark: e.writableHighWaterMark || 0
  }), kx.call(this, e), this._readableState.sync = !1, this[Sf] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", Cie);
}
function vS(e) {
  typeof this._flush == "function" && !this.destroyed ? this._flush((t, r) => {
    if (t) {
      e ? e(t) : this.destroy(t);
      return;
    }
    r != null && this.push(r), this.push(null), e && e();
  }) : (this.push(null), e && e());
}
function Cie() {
  this._final !== vS && vS.call(this);
}
fo.prototype._final = vS;
fo.prototype._transform = function(e, t, r) {
  throw new Tie("_transform()");
};
fo.prototype._write = function(e, t, r) {
  const n = this._readableState, o = this._writableState, s = n.length;
  this._transform(e, t, (a, l) => {
    if (a) {
      r(a);
      return;
    }
    l != null && this.push(l), o.ended || // Backwards compat.
    s === n.length || // Backwards compat.
    n.length < n.highWaterMark ? r() : this[Sf] = r;
  });
};
fo.prototype._read = function() {
  if (this[Sf]) {
    const e = this[Sf];
    this[Sf] = null, e();
  }
};
const { ObjectSetPrototypeOf: y7 } = Bt;
var m7 = Vl;
const Ix = b7;
y7(Vl.prototype, Ix.prototype);
y7(Vl, Ix);
function Vl(e) {
  if (!(this instanceof Vl))
    return new Vl(e);
  Ix.call(this, e);
}
Vl.prototype._transform = function(e, t, r) {
  r(null, e);
};
const Xu = _t, { ArrayIsArray: kie, Promise: Iie, SymbolAsyncIterator: Mie, SymbolDispose: Nie } = Bt, Sh = ws, { once: Lie } = zr, Oie = pu, GC = uo(), {
  aggregateTwoErrors: Pie,
  codes: {
    ERR_INVALID_ARG_TYPE: wS,
    ERR_INVALID_RETURN_VALUE: wy,
    ERR_MISSING_ARGS: Die,
    ERR_STREAM_DESTROYED: Fie,
    ERR_STREAM_PREMATURE_CLOSE: jie
  },
  AbortError: Bie
} = sn, { validateFunction: qie, validateAbortSignal: Wie } = vc, {
  isIterable: Ws,
  isReadable: _y,
  isReadableNodeStream: qd,
  isNodeStream: VC,
  isTransformStream: ml,
  isWebStream: Uie,
  isReadableStream: Sy,
  isReadableFinished: Hie
} = Ao, zie = globalThis.AbortController || Kt().AbortController;
let Ey, xy, Ry;
function KC(e, t, r) {
  let n = !1;
  e.on("close", () => {
    n = !0;
  });
  const o = Sh(
    e,
    {
      readable: t,
      writable: r
    },
    (s) => {
      n = !s;
    }
  );
  return {
    destroy: (s) => {
      n || (n = !0, Oie.destroyer(e, s || new Fie("pipe")));
    },
    cleanup: o
  };
}
function Gie(e) {
  return qie(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
}
function Ay(e) {
  if (Ws(e))
    return e;
  if (qd(e))
    return Vie(e);
  throw new wS("val", ["Readable", "Iterable", "AsyncIterable"], e);
}
async function* Vie(e) {
  xy || (xy = eg()), yield* xy.prototype[Mie].call(e);
}
async function ld(e, t, r, { end: n }) {
  let o, s = null;
  const a = (f) => {
    if (f && (o = f), s) {
      const c = s;
      s = null, c();
    }
  }, l = () => new Iie((f, c) => {
    o ? c(o) : s = () => {
      o ? c(o) : f();
    };
  });
  t.on("drain", a);
  const u = Sh(
    t,
    {
      readable: !1
    },
    a
  );
  try {
    t.writableNeedDrain && await l();
    for await (const f of e)
      t.write(f) || await l();
    n && (t.end(), await l()), r();
  } catch (f) {
    r(o !== f ? Pie(o, f) : f);
  } finally {
    u(), t.off("drain", a);
  }
}
async function Ty(e, t, r, { end: n }) {
  ml(t) && (t = t.writable);
  const o = t.getWriter();
  try {
    for await (const s of e)
      await o.ready, o.write(s).catch(() => {
      });
    await o.ready, n && await o.close(), r();
  } catch (s) {
    try {
      await o.abort(s), r(s);
    } catch (a) {
      r(a);
    }
  }
}
function Kie(...e) {
  return v7(e, Lie(Gie(e)));
}
function v7(e, t, r) {
  if (e.length === 1 && kie(e[0]) && (e = e[0]), e.length < 2)
    throw new Die("streams");
  const n = new zie(), o = n.signal, s = r == null ? void 0 : r.signal, a = [];
  Wie(s, "options.signal");
  function l() {
    m(new Bie());
  }
  Ry = Ry || zr.addAbortListener;
  let u;
  s && (u = Ry(s, l));
  let f, c;
  const d = [];
  let h = 0;
  function p(x) {
    m(x, --h === 0);
  }
  function m(x, E) {
    var C;
    if (x && (!f || f.code === "ERR_STREAM_PREMATURE_CLOSE") && (f = x), !(!f && !E)) {
      for (; d.length; )
        d.shift()(f);
      (C = u) === null || C === void 0 || C[Nie](), n.abort(), E && (f || a.forEach((I) => I()), Xu.nextTick(t, f, c));
    }
  }
  let y;
  for (let x = 0; x < e.length; x++) {
    const E = e[x], C = x < e.length - 1, I = x > 0, j = C || (r == null ? void 0 : r.end) !== !1, J = x === e.length - 1;
    if (VC(E)) {
      let G = function($) {
        $ && $.name !== "AbortError" && $.code !== "ERR_STREAM_PREMATURE_CLOSE" && p($);
      };
      if (j) {
        const { destroy: $, cleanup: V } = KC(E, C, I);
        d.push($), _y(E) && J && a.push(V);
      }
      E.on("error", G), _y(E) && J && a.push(() => {
        E.removeListener("error", G);
      });
    }
    if (x === 0)
      if (typeof E == "function") {
        if (y = E({
          signal: o
        }), !Ws(y))
          throw new wy("Iterable, AsyncIterable or Stream", "source", y);
      } else
        Ws(E) || qd(E) || ml(E) ? y = E : y = GC.from(E);
    else if (typeof E == "function") {
      if (ml(y)) {
        var _;
        y = Ay((_ = y) === null || _ === void 0 ? void 0 : _.readable);
      } else
        y = Ay(y);
      if (y = E(y, {
        signal: o
      }), C) {
        if (!Ws(y, !0))
          throw new wy("AsyncIterable", `transform[${x - 1}]`, y);
      } else {
        var S;
        Ey || (Ey = m7);
        const G = new Ey({
          objectMode: !0
        }), $ = (S = y) === null || S === void 0 ? void 0 : S.then;
        if (typeof $ == "function")
          h++, $.call(
            y,
            (W) => {
              c = W, W != null && G.write(W), j && G.end(), Xu.nextTick(p);
            },
            (W) => {
              G.destroy(W), Xu.nextTick(p, W);
            }
          );
        else if (Ws(y, !0))
          h++, ld(y, G, p, {
            end: j
          });
        else if (Sy(y) || ml(y)) {
          const W = y.readable || y;
          h++, ld(W, G, p, {
            end: j
          });
        } else
          throw new wy("AsyncIterable or Promise", "destination", y);
        y = G;
        const { destroy: V, cleanup: M } = KC(y, !1, !0);
        d.push(V), J && a.push(M);
      }
    } else if (VC(E)) {
      if (qd(y)) {
        h += 2;
        const G = Yie(y, E, p, {
          end: j
        });
        _y(E) && J && a.push(G);
      } else if (ml(y) || Sy(y)) {
        const G = y.readable || y;
        h++, ld(G, E, p, {
          end: j
        });
      } else if (Ws(y))
        h++, ld(y, E, p, {
          end: j
        });
      else
        throw new wS(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          y
        );
      y = E;
    } else if (Uie(E)) {
      if (qd(y))
        h++, Ty(Ay(y), E, p, {
          end: j
        });
      else if (Sy(y) || Ws(y))
        h++, Ty(y, E, p, {
          end: j
        });
      else if (ml(y))
        h++, Ty(y.readable, E, p, {
          end: j
        });
      else
        throw new wS(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          y
        );
      y = E;
    } else
      y = GC.from(E);
  }
  return (o != null && o.aborted || s != null && s.aborted) && Xu.nextTick(l), y;
}
function Yie(e, t, r, { end: n }) {
  let o = !1;
  if (t.on("close", () => {
    o || r(new jie());
  }), e.pipe(t, {
    end: !1
  }), n) {
    let s = function() {
      o = !0, t.end();
    };
    Hie(e) ? Xu.nextTick(s) : e.once("end", s);
  } else
    r();
  return Sh(
    e,
    {
      readable: !0,
      writable: !1
    },
    (s) => {
      const a = e._readableState;
      s && s.code === "ERR_STREAM_PREMATURE_CLOSE" && a && a.ended && !a.errored && !a.errorEmitted ? e.once("end", r).once("error", r) : r(s);
    }
  ), Sh(
    t,
    {
      readable: !1,
      writable: !0
    },
    r
  );
}
var Mx = {
  pipelineImpl: v7,
  pipeline: Kie
};
const { pipeline: Xie } = Mx, ud = uo(), { destroyer: Jie } = pu, {
  isNodeStream: fd,
  isReadable: YC,
  isWritable: XC,
  isWebStream: $y,
  isTransformStream: Ls,
  isWritableStream: JC,
  isReadableStream: QC
} = Ao, {
  AbortError: Qie,
  codes: { ERR_INVALID_ARG_VALUE: ZC, ERR_MISSING_ARGS: Zie }
} = sn, eoe = ws;
var w7 = function(...t) {
  if (t.length === 0)
    throw new Zie("streams");
  if (t.length === 1)
    return ud.from(t[0]);
  const r = [...t];
  if (typeof t[0] == "function" && (t[0] = ud.from(t[0])), typeof t[t.length - 1] == "function") {
    const p = t.length - 1;
    t[p] = ud.from(t[p]);
  }
  for (let p = 0; p < t.length; ++p)
    if (!(!fd(t[p]) && !$y(t[p]))) {
      if (p < t.length - 1 && !(YC(t[p]) || QC(t[p]) || Ls(t[p])))
        throw new ZC(`streams[${p}]`, r[p], "must be readable");
      if (p > 0 && !(XC(t[p]) || JC(t[p]) || Ls(t[p])))
        throw new ZC(`streams[${p}]`, r[p], "must be writable");
    }
  let n, o, s, a, l;
  function u(p) {
    const m = a;
    a = null, m ? m(p) : p ? l.destroy(p) : !h && !d && l.destroy();
  }
  const f = t[0], c = Xie(t, u), d = !!(XC(f) || JC(f) || Ls(f)), h = !!(YC(c) || QC(c) || Ls(c));
  if (l = new ud({
    // TODO (ronag): highWaterMark?
    writableObjectMode: !!(f != null && f.writableObjectMode),
    readableObjectMode: !!(c != null && c.readableObjectMode),
    writable: d,
    readable: h
  }), d) {
    if (fd(f))
      l._write = function(m, y, _) {
        f.write(m, y) ? _() : n = _;
      }, l._final = function(m) {
        f.end(), o = m;
      }, f.on("drain", function() {
        if (n) {
          const m = n;
          n = null, m();
        }
      });
    else if ($y(f)) {
      const y = (Ls(f) ? f.writable : f).getWriter();
      l._write = async function(_, S, x) {
        try {
          await y.ready, y.write(_).catch(() => {
          }), x();
        } catch (E) {
          x(E);
        }
      }, l._final = async function(_) {
        try {
          await y.ready, y.close().catch(() => {
          }), o = _;
        } catch (S) {
          _(S);
        }
      };
    }
    const p = Ls(c) ? c.readable : c;
    eoe(p, () => {
      if (o) {
        const m = o;
        o = null, m();
      }
    });
  }
  if (h) {
    if (fd(c))
      c.on("readable", function() {
        if (s) {
          const p = s;
          s = null, p();
        }
      }), c.on("end", function() {
        l.push(null);
      }), l._read = function() {
        for (; ; ) {
          const p = c.read();
          if (p === null) {
            s = l._read;
            return;
          }
          if (!l.push(p))
            return;
        }
      };
    else if ($y(c)) {
      const m = (Ls(c) ? c.readable : c).getReader();
      l._read = async function() {
        for (; ; )
          try {
            const { value: y, done: _ } = await m.read();
            if (!l.push(y))
              return;
            if (_) {
              l.push(null);
              return;
            }
          } catch {
            return;
          }
      };
    }
  }
  return l._destroy = function(p, m) {
    !p && a !== null && (p = new Qie()), s = null, n = null, o = null, a === null ? m(p) : (a = m, fd(c) && Jie(c, p));
  }, l;
};
const toe = globalThis.AbortController || Kt().AbortController, {
  codes: { ERR_INVALID_ARG_VALUE: roe, ERR_INVALID_ARG_TYPE: wc, ERR_MISSING_ARGS: noe, ERR_OUT_OF_RANGE: ioe },
  AbortError: Ci
} = sn, { validateAbortSignal: Ga, validateInteger: ek, validateObject: Va } = vc, ooe = Bt.Symbol("kWeak"), soe = Bt.Symbol("kResistStopPropagation"), { finished: aoe } = ws, loe = w7, { addAbortSignalNoValidate: uoe } = Qp, { isWritable: foe, isNodeStream: coe } = Ao, { deprecate: doe } = zr, {
  ArrayPrototypePush: hoe,
  Boolean: poe,
  MathFloor: tk,
  Number: goe,
  NumberIsNaN: boe,
  Promise: rk,
  PromiseReject: nk,
  PromiseResolve: yoe,
  PromisePrototypeThen: ik,
  Symbol: _7
} = Bt, Eh = _7("kEmpty"), ok = _7("kEof");
function moe(e, t) {
  if (t != null && Va(t, "options"), (t == null ? void 0 : t.signal) != null && Ga(t.signal, "options.signal"), coe(e) && !foe(e))
    throw new roe("stream", e, "must be writable");
  const r = loe(this, e);
  return t != null && t.signal && uoe(t.signal, r), r;
}
function tg(e, t) {
  if (typeof e != "function")
    throw new wc("fn", ["Function", "AsyncFunction"], e);
  t != null && Va(t, "options"), (t == null ? void 0 : t.signal) != null && Ga(t.signal, "options.signal");
  let r = 1;
  (t == null ? void 0 : t.concurrency) != null && (r = tk(t.concurrency));
  let n = r - 1;
  return (t == null ? void 0 : t.highWaterMark) != null && (n = tk(t.highWaterMark)), ek(r, "options.concurrency", 1), ek(n, "options.highWaterMark", 0), n += r, (async function* () {
    const s = zr.AbortSignalAny(
      [t == null ? void 0 : t.signal].filter(poe)
    ), a = this, l = [], u = {
      signal: s
    };
    let f, c, d = !1, h = 0;
    function p() {
      d = !0, m();
    }
    function m() {
      h -= 1, y();
    }
    function y() {
      c && !d && h < r && l.length < n && (c(), c = null);
    }
    async function _() {
      try {
        for await (let S of a) {
          if (d)
            return;
          if (s.aborted)
            throw new Ci();
          try {
            if (S = e(S, u), S === Eh)
              continue;
            S = yoe(S);
          } catch (x) {
            S = nk(x);
          }
          h += 1, ik(S, m, p), l.push(S), f && (f(), f = null), !d && (l.length >= n || h >= r) && await new rk((x) => {
            c = x;
          });
        }
        l.push(ok);
      } catch (S) {
        const x = nk(S);
        ik(x, m, p), l.push(x);
      } finally {
        d = !0, f && (f(), f = null);
      }
    }
    _();
    try {
      for (; ; ) {
        for (; l.length > 0; ) {
          const S = await l[0];
          if (S === ok)
            return;
          if (s.aborted)
            throw new Ci();
          S !== Eh && (yield S), l.shift(), y();
        }
        await new rk((S) => {
          f = S;
        });
      }
    } finally {
      d = !0, c && (c(), c = null);
    }
  }).call(this);
}
function voe(e = void 0) {
  return e != null && Va(e, "options"), (e == null ? void 0 : e.signal) != null && Ga(e.signal, "options.signal"), (async function* () {
    let r = 0;
    for await (const o of this) {
      var n;
      if (e != null && (n = e.signal) !== null && n !== void 0 && n.aborted)
        throw new Ci({
          cause: e.signal.reason
        });
      yield [r++, o];
    }
  }).call(this);
}
async function S7(e, t = void 0) {
  for await (const r of Nx.call(this, e, t))
    return !0;
  return !1;
}
async function woe(e, t = void 0) {
  if (typeof e != "function")
    throw new wc("fn", ["Function", "AsyncFunction"], e);
  return !await S7.call(
    this,
    async (...r) => !await e(...r),
    t
  );
}
async function _oe(e, t) {
  for await (const r of Nx.call(this, e, t))
    return r;
}
async function Soe(e, t) {
  if (typeof e != "function")
    throw new wc("fn", ["Function", "AsyncFunction"], e);
  async function r(n, o) {
    return await e(n, o), Eh;
  }
  for await (const n of tg.call(this, r, t))
    ;
}
function Nx(e, t) {
  if (typeof e != "function")
    throw new wc("fn", ["Function", "AsyncFunction"], e);
  async function r(n, o) {
    return await e(n, o) ? n : Eh;
  }
  return tg.call(this, r, t);
}
let Eoe = class extends noe {
  constructor() {
    super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
  }
};
async function xoe(e, t, r) {
  var n;
  if (typeof e != "function")
    throw new wc("reducer", ["Function", "AsyncFunction"], e);
  r != null && Va(r, "options"), (r == null ? void 0 : r.signal) != null && Ga(r.signal, "options.signal");
  let o = arguments.length > 1;
  if (r != null && (n = r.signal) !== null && n !== void 0 && n.aborted) {
    const f = new Ci(void 0, {
      cause: r.signal.reason
    });
    throw this.once("error", () => {
    }), await aoe(this.destroy(f)), f;
  }
  const s = new toe(), a = s.signal;
  if (r != null && r.signal) {
    const f = {
      once: !0,
      [ooe]: this,
      [soe]: !0
    };
    r.signal.addEventListener("abort", () => s.abort(), f);
  }
  let l = !1;
  try {
    for await (const f of this) {
      var u;
      if (l = !0, r != null && (u = r.signal) !== null && u !== void 0 && u.aborted)
        throw new Ci();
      o ? t = await e(t, f, {
        signal: a
      }) : (t = f, o = !0);
    }
    if (!l && !o)
      throw new Eoe();
  } finally {
    s.abort();
  }
  return t;
}
async function Roe(e) {
  e != null && Va(e, "options"), (e == null ? void 0 : e.signal) != null && Ga(e.signal, "options.signal");
  const t = [];
  for await (const n of this) {
    var r;
    if (e != null && (r = e.signal) !== null && r !== void 0 && r.aborted)
      throw new Ci(void 0, {
        cause: e.signal.reason
      });
    hoe(t, n);
  }
  return t;
}
function Aoe(e, t) {
  const r = tg.call(this, e, t);
  return (async function* () {
    for await (const o of r)
      yield* o;
  }).call(this);
}
function E7(e) {
  if (e = goe(e), boe(e))
    return 0;
  if (e < 0)
    throw new ioe("number", ">= 0", e);
  return e;
}
function Toe(e, t = void 0) {
  return t != null && Va(t, "options"), (t == null ? void 0 : t.signal) != null && Ga(t.signal, "options.signal"), e = E7(e), (async function* () {
    var n;
    if (t != null && (n = t.signal) !== null && n !== void 0 && n.aborted)
      throw new Ci();
    for await (const s of this) {
      var o;
      if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
        throw new Ci();
      e-- <= 0 && (yield s);
    }
  }).call(this);
}
function $oe(e, t = void 0) {
  return t != null && Va(t, "options"), (t == null ? void 0 : t.signal) != null && Ga(t.signal, "options.signal"), e = E7(e), (async function* () {
    var n;
    if (t != null && (n = t.signal) !== null && n !== void 0 && n.aborted)
      throw new Ci();
    for await (const s of this) {
      var o;
      if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
        throw new Ci();
      if (e-- > 0 && (yield s), e <= 0)
        return;
    }
  }).call(this);
}
Ex.streamReturningOperators = {
  asIndexedPairs: doe(voe, "readable.asIndexedPairs will be removed in a future version."),
  drop: Toe,
  filter: Nx,
  flatMap: Aoe,
  map: tg,
  take: $oe,
  compose: moe
};
Ex.promiseReturningOperators = {
  every: woe,
  forEach: Soe,
  reduce: xoe,
  toArray: Roe,
  some: S7,
  find: _oe
};
var Cy, sk;
function x7() {
  if (sk)
    return Cy;
  sk = 1;
  const { ArrayPrototypePop: e, Promise: t } = Bt, { isIterable: r, isNodeStream: n, isWebStream: o } = Ao, { pipelineImpl: s } = Mx, { finished: a } = ws;
  R7();
  function l(...u) {
    return new t((f, c) => {
      let d, h;
      const p = u[u.length - 1];
      if (p && typeof p == "object" && !n(p) && !r(p) && !o(p)) {
        const m = e(u);
        d = m.signal, h = m.end;
      }
      s(
        u,
        (m, y) => {
          m ? c(m) : f(y);
        },
        {
          signal: d,
          end: h
        }
      );
    });
  }
  return Cy = {
    finished: a,
    pipeline: l
  }, Cy;
}
var ak;
function R7() {
  if (ak)
    return dy.exports;
  ak = 1;
  const { Buffer: e } = ut, { ObjectDefineProperty: t, ObjectKeys: r, ReflectApply: n } = Bt, {
    promisify: { custom: o }
  } = zr, { streamReturningOperators: s, promiseReturningOperators: a } = Ex, {
    codes: { ERR_ILLEGAL_CONSTRUCTOR: l }
  } = sn, u = w7, { setDefaultHighWaterMark: f, getDefaultHighWaterMark: c } = Zp, { pipeline: d } = Mx, { destroyer: h } = pu, p = ws, m = x7(), y = Ao, _ = dy.exports = $x.Stream;
  _.isDestroyed = y.isDestroyed, _.isDisturbed = y.isDisturbed, _.isErrored = y.isErrored, _.isReadable = y.isReadable, _.isWritable = y.isWritable, _.Readable = eg();
  for (const x of r(s)) {
    let C = function(...I) {
      if (new.target)
        throw l();
      return _.Readable.from(n(E, this, I));
    };
    const E = s[x];
    t(C, "name", {
      __proto__: null,
      value: E.name
    }), t(C, "length", {
      __proto__: null,
      value: E.length
    }), t(_.Readable.prototype, x, {
      __proto__: null,
      value: C,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  for (const x of r(a)) {
    let C = function(...I) {
      if (new.target)
        throw l();
      return n(E, this, I);
    };
    const E = a[x];
    t(C, "name", {
      __proto__: null,
      value: E.name
    }), t(C, "length", {
      __proto__: null,
      value: E.length
    }), t(_.Readable.prototype, x, {
      __proto__: null,
      value: C,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  _.Writable = Cx(), _.Duplex = uo(), _.Transform = b7, _.PassThrough = m7, _.pipeline = d;
  const { addAbortSignal: S } = Qp;
  return _.addAbortSignal = S, _.finished = p, _.destroy = h, _.compose = u, _.setDefaultHighWaterMark = f, _.getDefaultHighWaterMark = c, t(_, "promises", {
    __proto__: null,
    configurable: !0,
    enumerable: !0,
    get() {
      return m;
    }
  }), t(d, o, {
    __proto__: null,
    enumerable: !0,
    get() {
      return m.pipeline;
    }
  }), t(p, o, {
    __proto__: null,
    enumerable: !0,
    get() {
      return m.finished;
    }
  }), _.Stream = _, _._isUint8Array = function(E) {
    return E instanceof Uint8Array;
  }, _._uint8ArrayToBuffer = function(E) {
    return e.from(E.buffer, E.byteOffset, E.byteLength);
  }, dy.exports;
}
(function(e) {
  const t = R7(), r = x7(), n = t.Readable.destroy;
  e.exports = t.Readable, e.exports._uint8ArrayToBuffer = t._uint8ArrayToBuffer, e.exports._isUint8Array = t._isUint8Array, e.exports.isDisturbed = t.isDisturbed, e.exports.isErrored = t.isErrored, e.exports.isReadable = t.isReadable, e.exports.Readable = t.Readable, e.exports.Writable = t.Writable, e.exports.Duplex = t.Duplex, e.exports.Transform = t.Transform, e.exports.PassThrough = t.PassThrough, e.exports.addAbortSignal = t.addAbortSignal, e.exports.finished = t.finished, e.exports.destroy = t.destroy, e.exports.destroy = n, e.exports.pipeline = t.pipeline, e.exports.compose = t.compose, Object.defineProperty(t, "promises", {
    configurable: !0,
    enumerable: !0,
    get() {
      return r;
    }
  }), e.exports.Stream = t.Stream, e.exports.default = e.exports;
})(OF);
var Lx = OF.exports, Coe = /\s/;
function koe(e) {
  for (var t = e.length; t-- && Coe.test(e.charAt(t)); )
    ;
  return t;
}
var Ioe = koe, Moe = Ioe, Noe = /^\s+/;
function Loe(e) {
  return e && e.slice(0, Moe(e) + 1).replace(Noe, "");
}
var Ooe = Loe, ky, lk;
function Mn() {
  if (lk)
    return ky;
  lk = 1;
  function e(t) {
    var r = typeof t;
    return t != null && (r == "object" || r == "function");
  }
  return ky = e, ky;
}
var Iy, uk;
function A7() {
  if (uk)
    return Iy;
  uk = 1;
  var e = typeof window == "object" && window && window.Object === Object && window;
  return Iy = e, Iy;
}
var My, fk;
function Zn() {
  if (fk)
    return My;
  fk = 1;
  var e = A7(), t = typeof self == "object" && self && self.Object === Object && self, r = e || t || Function("return this")();
  return My = r, My;
}
var Ny, ck;
function gu() {
  if (ck)
    return Ny;
  ck = 1;
  var e = Zn(), t = e.Symbol;
  return Ny = t, Ny;
}
var Ly, dk;
function Poe() {
  if (dk)
    return Ly;
  dk = 1;
  var e = gu(), t = Object.prototype, r = t.hasOwnProperty, n = t.toString, o = e ? e.toStringTag : void 0;
  function s(a) {
    var l = r.call(a, o), u = a[o];
    try {
      a[o] = void 0;
      var f = !0;
    } catch {
    }
    var c = n.call(a);
    return f && (l ? a[o] = u : delete a[o]), c;
  }
  return Ly = s, Ly;
}
var Oy, hk;
function Doe() {
  if (hk)
    return Oy;
  hk = 1;
  var e = Object.prototype, t = e.toString;
  function r(n) {
    return t.call(n);
  }
  return Oy = r, Oy;
}
var Py, pk;
function Ka() {
  if (pk)
    return Py;
  pk = 1;
  var e = gu(), t = Poe(), r = Doe(), n = "[object Null]", o = "[object Undefined]", s = e ? e.toStringTag : void 0;
  function a(l) {
    return l == null ? l === void 0 ? o : n : s && s in Object(l) ? t(l) : r(l);
  }
  return Py = a, Py;
}
var Dy, gk;
function ji() {
  if (gk)
    return Dy;
  gk = 1;
  function e(t) {
    return t != null && typeof t == "object";
  }
  return Dy = e, Dy;
}
var Fy, bk;
function bu() {
  if (bk)
    return Fy;
  bk = 1;
  var e = Ka(), t = ji(), r = "[object Symbol]";
  function n(o) {
    return typeof o == "symbol" || t(o) && e(o) == r;
  }
  return Fy = n, Fy;
}
var Foe = Ooe, yk = Mn(), joe = bu(), mk = NaN, Boe = /^[-+]0x[0-9a-f]+$/i, qoe = /^0b[01]+$/i, Woe = /^0o[0-7]+$/i, Uoe = parseInt;
function Hoe(e) {
  if (typeof e == "number")
    return e;
  if (joe(e))
    return mk;
  if (yk(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = yk(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = Foe(e);
  var r = qoe.test(e);
  return r || Woe.test(e) ? Uoe(e.slice(2), r ? 2 : 8) : Boe.test(e) ? mk : +e;
}
var zoe = Hoe, Goe = zoe, vk = 1 / 0, Voe = 17976931348623157e292;
function Koe(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = Goe(e), e === vk || e === -vk) {
    var t = e < 0 ? -1 : 1;
    return t * Voe;
  }
  return e === e ? e : 0;
}
var T7 = Koe, Yoe = T7;
function Xoe(e) {
  var t = Yoe(e), r = t % 1;
  return t === t ? r ? t - r : t : 0;
}
var $7 = Xoe, Joe = $7, Qoe = "Expected a function";
function Zoe(e, t) {
  var r;
  if (typeof t != "function")
    throw new TypeError(Qoe);
  return e = Joe(e), function() {
    return --e > 0 && (r = t.apply(this, arguments)), e <= 1 && (t = void 0), r;
  };
}
var ese = Zoe, tse = ese;
function rse(e) {
  return tse(2, e);
}
var nse = rse;
const ise = /* @__PURE__ */ $n(nse);
function ose(e) {
  return new Lx.Readable({
    read: ise(async function() {
      try {
        this.push(new Uint8Array(await e())), this.push(null);
      } catch (t) {
        this.destroy(t);
      }
    })
  });
}
class Ox {
  constructor(t, r) {
    this.obj = t;
    for (const [n, o] of Object.entries(r))
      this[n] = o;
    for (const n of Ox.properties(t))
      n in this || (typeof this.obj[n] == "function" ? this[n] = (...o) => this.obj[n].call(t, o) : Object.defineProperty(this, n, {
        get: () => this.obj[n],
        set: (o) => {
          this.obj[n] = o;
        },
        enumerable: !0,
        configurable: !0
      }));
  }
  static properties(t) {
    return Object.getOwnPropertyNames(Object.getPrototypeOf(t));
  }
}
function sse(e) {
  return new Lx.Readable({
    read: async function() {
      try {
        let t, r;
        do
          t = await e.read(), t.done ? this.push(null) : r = !this.push(t.value);
        while (!t.done && !r);
      } catch (t) {
        this.destroy(t);
      }
    }
  });
}
function ase(e) {
  if (e.bodyUsed) {
    const t = new Lx.Readable({
      read: () => t.destroy(new Error("body already in use"))
    });
    return e.body = t, e;
  }
  return e.body && e.body.readable ? e : e.body && typeof e.body.getReader == "function" ? new Ox(e, {
    // ...and replace the body with a readable stream
    body: sse(e.body.getReader())
  }) : (e.body = ose(() => e.arrayBuffer()), e);
}
function lse(e, t) {
  return _re(t).then((r) => fetch(e, r).then((n) => ase(n)));
}
class use {
  /**
   * @param {Object} options
   * @param {string} [options.endpointUrl] SPARQL query endpoint URL
   * @param {factory} [options.factory] RDF/JS factory
   * @param {fetch} [options.fetch=nodeify-fetch] fetch implementation
   * @param {Headers} [options.headers] headers sent with every request
   * @param {string} [options.password] password used for basic authentication
   * @param {string} [options.storeUrl] SPARQL Graph Store URL
   * @param {string} [options.updateUrl] SPARQL update endpoint URL
   * @param {string} [options.user] user used for basic authentication
   * @param {Query} [options.Query] Constructor of a query implementation
   * @param {Store} [options.Store] Constructor of a store implementation
   */
  constructor({
    endpointUrl: t,
    factory: r,
    fetch: n = lse,
    headers: o,
    password: s,
    storeUrl: a,
    updateUrl: l,
    user: u,
    Query: f = TF,
    Store: c
  }) {
    if (!t && !a && !l)
      throw new Error("no endpointUrl, storeUrl, or updateUrl given");
    this.endpointUrl = t, this.factory = r, this.fetch = n, this.headers = new Headers(o), this.password = s, this.storeUrl = a, this.updateUrl = l, this.user = u, this.query = f ? new f({ client: this }) : null, this.store = c ? new c({ client: this }) : null, typeof u == "string" && typeof s == "string" && this.headers.set("authorization", `Basic ${btoa(`${u}:${s}`)}`);
  }
  /**
   * Sends a GET request as defined in the
   * {@link https://www.w3.org/TR/2013/REC-sparql11-protocol-20130321/#query-via-get SPARQL Protocol specification}.
   *
   * @param {string} query SPARQL query
   * @param {Object} options
   * @param {Headers} [options.headers] additional request headers
   * @param {boolean} [options.update=false] send the request to the updateUrl
   * @return {Promise<Response>}
   */
  async get(t, { headers: r, update: n = !1 } = {}) {
    let o = null;
    return n ? (o = new URL(this.updateUrl), o.searchParams.append("update", t)) : (o = new URL(this.endpointUrl), o.searchParams.append("query", t)), this.fetch(o.toString().replace(/\+/g, "%20"), {
      method: "GET",
      headers: Xo(this.headers, r)
    });
  }
  /**
   * Sends a POST directly request as defined in the
   * {@link https://www.w3.org/TR/2013/REC-sparql11-protocol-20130321/#query-via-post-direct SPARQL Protocol specification}.
   *
   *
   * @param {string} query SPARQL query
   * @param {Object} options
   * @param {Headers} [options.headers] additional request headers
   * @param {boolean} [options.update=false] send the request to the updateUrl
   * @return {Promise<Response>}
   */
  async postDirect(t, { headers: r, update: n = !1 } = {}) {
    let o = null;
    return n ? o = new URL(this.updateUrl) : o = new URL(this.endpointUrl), r = Xo(this.headers, r), r.has("content-type") || r.set("content-type", "application/sparql-query; charset=utf-8"), this.fetch(o, {
      method: "POST",
      headers: r,
      body: t
    });
  }
  /**
   * Sends a POST URL-encoded request as defined in the
   * {@link https://www.w3.org/TR/2013/REC-sparql11-protocol-20130321/#query-via-post-urlencoded SPARQL Protocol specification}.
   *
   * @param {string} query SPARQL query
   * @param {Object} options
   * @param {Headers} [options.headers] additional request headers
   * @param {boolean} [options.update=false] send the request to the updateUrl
   * @return {Promise<Response>}
   */
  async postUrlencoded(t, { headers: r, update: n = !1 } = {}) {
    let o = null, s = null;
    return n ? (o = new URL(this.updateUrl), s = `update=${encodeURIComponent(t)}`) : (o = new URL(this.endpointUrl), s = `query=${encodeURIComponent(t)}`), r = Xo(this.headers, r), r.has("content-type") || r.set("content-type", "application/x-www-form-urlencoded"), this.fetch(o, {
      method: "POST",
      headers: r,
      body: s
    });
  }
}
const fse = new mp([lu, RD]);
class cse extends use {
  /**
   * @param {Object} options
   * @param {string} [options.endpointUrl] SPARQL query endpoint URL
   * @param {factory} [options.factory] RDF/JS factory
   * @param {fetch} [options.fetch=nodeify-fetch] fetch implementation
   * @param {Headers} [options.headers] headers sent with every request
   * @param {string} [options.password] password used for basic authentication
   * @param {string} [options.storeUrl] SPARQL Graph Store URL
   * @param {string} [options.updateUrl] SPARQL update endpoint URL
   * @param {string} [options.user] user used for basic authentication
   */
  constructor({
    endpointUrl: t,
    factory: r = fse,
    fetch: n,
    headers: o,
    password: s,
    storeUrl: a,
    updateUrl: l,
    user: u
  }) {
    if (super({
      endpointUrl: t,
      factory: r,
      fetch: n,
      headers: o,
      password: s,
      storeUrl: a,
      updateUrl: l,
      user: u,
      Query: vre
    }), !nY(this.factory))
      throw new Error("the given factory doesn't implement the DatasetCoreFactory interface");
  }
}
mi.spex = "https://described.at/spex/";
const Un = Vt.namespace(mi.rdf), _S = Vt.namespace(mi.schema), Pt = Vt.namespace(mi.sh), Jo = Vt.namespace(mi.spex);
function dse(e, t, r) {
  const n = e.out(Jo.shape).has(Un.type, Jo.DefaultShapes), o = n.term ? hse(n.out(_S.hasPart), r) : [], s = e.out(Jo.viewport).map((a) => ({
    id: a.term.value,
    term: a.term,
    name: a.out(_S`name`, { language: t }).value,
    tables: new Set(a.out(Jo.includes).terms.map(({ value: l }) => l))
  }));
  return {
    tables: o,
    viewports: s,
    isIntrospected: !1
  };
}
function hse(e, t) {
  return e.toArray().flatMap((r) => {
    const n = r.out(Pt.targetClass).term;
    if (!n)
      return [];
    const o = n.value, s = r.out(Pt.property).toArray().flatMap((a) => {
      const l = a.out(Pt.path).term;
      if (!l)
        return [];
      const u = l.value, f = C7(a, t);
      return {
        id: u,
        name: t(u),
        values: f
      };
    });
    return {
      id: o,
      name: t(o),
      properties: s,
      isShown: !0
    };
  });
}
function C7(e, t) {
  const r = e.out(Pt.datatype).terms.map((a) => wk(a, t)), n = e.out(Pt.class).terms.map((a) => wk(a, t));
  let o = [];
  const s = e.out(Pt.or).list();
  return s !== null && (o = [...s].flatMap((a) => C7(a, t))), [
    ...r,
    ...n,
    ...o
  ];
}
function wk(e, t) {
  return {
    id: e.value,
    name: t(e.value),
    termType: e.termType
  };
}
function pse(e, t) {
  const r = Vt.clownface({
    dataset: Vt.dataset(),
    term: Vt.namedNode(t)
  });
  return r.addOut(Jo.shape, (n) => {
    n.addOut(Un.type, Jo.DefaultShapes), e.tables.forEach((o) => {
      n.addOut(_S.hasPart, (s) => {
        s.addOut(Un.type, Pt.NodeShape).addOut(Pt.targetClass, Vt.namedNode(o.id)), o.properties.forEach((a) => {
          s.addOut(Pt.property, (l) => {
            l.addOut(Un.type, Pt.PropertyShape).addOut(Pt.path, Vt.namedNode(a.id));
            const u = (f) => f.termType === "NamedNode" ? [Pt.class, Vt.namedNode(f.id)] : [Pt.datatype, Vt.namedNode(f.id)];
            if (a.values.length === 1) {
              const f = u(a.values[0]);
              l.addOut(f[0], f[1]);
            } else
              a.values.length > 1 && l.addList(Pt.or, a.values.map((f) => {
                const c = u(f);
                return l.blankNode().addOut(c[0], c[1]);
              }));
          });
        });
      });
    });
  }), r;
}
const gse = ".well-known/void", bse = [...Object.keys(mi)], yse = ["en", "*"], ep = class ep {
  constructor(t) {
    As(this, "_client");
    this._settings = t, this.applySettings(t);
  }
  /**
   * Get the instance of this class.
   * @param settings configuration for the endpoint
   * @returns The Endpoint instance (singleton)
   */
  static getInstance(t) {
    if (this._endpointInstance === null && t)
      return this._endpointInstance = new ep(t), this._endpointInstance;
    if (t && this._endpointInstance && this._endpointInstance.applySettings(t), this._endpointInstance === null)
      throw new Error("Endpoint Not Configured");
    return this._endpointInstance;
  }
  /**
  * Use new setting for SPARQL endpoint
  * @param _settings new Settings for SPARQL Endpoint
  */
  applySettings(t) {
    this._settings = t, this._settings.sparqlEndpoint && (this._client = new cse(
      {
        endpointUrl: this._settings.sparqlEndpoint,
        user: this._settings.username ?? void 0,
        password: this._settings.password ?? void 0
      }
    )), Object.keys(mi).forEach((r) => {
      bse.includes(r) || delete mi[r];
    }), this._settings.prefixes.forEach(({ prefix: r, namespace: n }) => {
      mi[r] = n;
    });
  }
  shrink(t) {
    return uD(t) || t;
  }
  /**
   * Fetch a list of graphs in the endpoint
   */
  async fetchGraphs(t) {
    const r = (t == null ? void 0 : t.offset) ?? 0, n = (t == null ? void 0 : t.limit) ?? null, o = `
      PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

      SELECT DISTINCT ?g
      WHERE {
        GRAPH ?g { ?s ?p ?o }
      }
      ORDER BY ?g
      OFFSET ${r}
      LIMIT ${n}
    `;
    return (await this._client.query.select(o)).map(({ g: { value: a } }) => a);
  }
  /**
   * Fetch data model, either by introspecting it or by querying the
   * pre-defined SHACL definition
   */
  async fetchDataModel() {
    if (this._settings.forceIntrospection)
      return this.fetchIntrospectDataModel();
    const t = await this.fetchPredefinedDataModel();
    return t !== null ? t : this.fetchIntrospectDataModel();
  }
  get datasetURI() {
    var t;
    return ((t = this._settings.sparqlEndpoint) == null ? void 0 : t.replace(/query\/?$/, gse)) ?? "";
  }
  get sparqlEndpoint() {
    return this._settings.sparqlEndpoint ?? "";
  }
  get prefixes() {
    return this._settings.prefixes;
  }
  /**
   * Fetch data model from pre-defined SHACL definition
   */
  async fetchPredefinedDataModel() {
    const t = this._settings.namedGraph ? `FROM <${this._settings.namedGraph}>` : "", r = `
      #pragma describe.strategy cbd
      DESCRIBE <${this.datasetURI}>
      ${t}
    `, n = await this._client.query.construct(r);
    if (n.size === 0)
      return null;
    const o = Vt.clownface({
      dataset: n,
      term: Vt.namedNode(this.datasetURI)
    });
    return this.dataModelFromSHACL(o);
  }
  dataModelFromSHACL(t) {
    return dse(t, yse, this.shrink);
  }
  dataModelToSHACL(t) {
    return pse(t, this.datasetURI);
  }
  /**
   * Fetch data model by introspecting the endpoint
   */
  async fetchIntrospectDataModel() {
    const n = [...(await this._fetchStructure()).reduce((s, { cls: a, property: l, linktype: u, datatype: f }) => {
      const c = s.get(a.value) ?? {
        id: a.value,
        name: this.shrink(a.value),
        properties: /* @__PURE__ */ new Map(),
        isShown: a.value !== "http://www.w3.org/2000/01/rdf-schema#Class"
      }, d = u && u.value || f && f.value || null, h = u ? "NamedNode" : f ? "Literal" : null, p = d && {
        id: d,
        name: this.shrink(d),
        termType: h
      };
      return c.properties.has(l.value) ? p && c.properties.get(l.value).values.push(p) : c.properties.set(l.value, {
        id: l.value,
        name: this.shrink(l.value),
        values: p ? [p] : []
      }), s.set(a.value, c), s;
    }, /* @__PURE__ */ new Map()).values()].map((s) => ({ ...s, properties: [...s.properties.values()] })), o = await this.countClasses();
    return n.forEach((s) => {
      s.count = o.get(s.id);
    }), {
      tables: n,
      viewports: [],
      isIntrospected: !0
    };
  }
  async _fetchStructure() {
    const r = `
      PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

      SELECT DISTINCT ?cls ?property ?linktype ?datatype
      ${this._settings.namedGraph ? `FROM <${this._settings.namedGraph}>` : ""}
      WHERE {
        ?subject a ?cls .
        ?subject ?property ?object .

        FILTER(?property != rdf:type)
        OPTIONAL {
          ?object a ?linktype .
        }

        BIND(DATATYPE(?object) AS ?datatype)
      }
    `;
    return this._client.query.select(r);
  }
  /**
   * Fetch a sample of the data of a given table
   */
  async fetchTableData(t, r) {
    const n = Vt.namedNode(t.id), o = (r == null ? void 0 : r.limit) ?? 10, s = (r == null ? void 0 : r.offset) ?? 0, l = `
      DESCRIBE ?subject {
        {
          SELECT ?subject
          WHERE {
            ${this._settings.namedGraph ? `GRAPH <${this._settings.namedGraph}>` : ""} {
              ?subject a <${t.id}>
            }
          }
          LIMIT ${o}
          OFFSET ${s}
        }
      }
    `, u = await this._client.query.construct(l), f = [...u.match(null, Un.type, n)], c = Vt.termMap(f.map(({ subject: d }) => [d, { id: d.value, term: d }]));
    return [...u].forEach(({ subject: d, predicate: { value: h }, object: p }) => {
      const m = c.get(d);
      m && (m[h] || (m[h] = Vt.termSet()), m[h].add(p), c.set(d, m));
    }), [...c.values()];
  }
  /**
   * Fetch triples related to a given resource.
   */
  async fetchResource(t) {
    const r = `
      DESCRIBE <${t}> {}
    `, o = [...await this._client.query.construct(r)].reduce((a, { predicate: l, object: u }) => {
      if (!a.has(l.value)) {
        const f = {
          id: l.value,
          term: l,
          name: this.shrink(l.value),
          values: Vt.termSet()
        };
        a.set(l.value, f);
      }
      return a.get(l.value).values.add(u), a;
    }, /* @__PURE__ */ new Map()), s = { value: t, termType: "NamedNode" };
    return {
      id: t,
      term: s,
      name: this.shrink(s.value),
      properties: [...o.values()]
    };
  }
  /**
   * You can use this function to the the connection.
   *
   * @returns Promise<boolean> true if the SPARQL endpoint returns a triple
   */
  async canFetchOne() {
    const t = `
      SELECT ?s WHERE {
        ?s ?p ?o
      } LIMIT 1
    `;
    try {
      return (await this._client.query.select(t)).length === 1;
    } catch {
      return !1;
    }
  }
  async countClasses() {
    const t = /* @__PURE__ */ new Map(), r = mse(this._settings.namedGraph);
    return (await this._client.query.select(r)).forEach((o) => {
      t.set(o.class.value, Number(o.count.value));
    }), t;
  }
};
// eslint-disable-next-line no-use-before-define
As(ep, "_endpointInstance", null);
let co = ep;
function mse(e) {
  return `
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

SELECT ?class (count(?x) as ?count) ${e ? `FROM <${e}>` : ""} WHERE {
  ?x a ?class .
} group by ?class
`;
}
function vse(e, t) {
  return class extends e {
    constructor() {
      super(), this.$rdf = t;
    }
  };
}
const wse = (e, t, r, n) => {
  if (r === "length" || r === "prototype" || r === "arguments" || r === "caller")
    return;
  const o = Object.getOwnPropertyDescriptor(e, r), s = Object.getOwnPropertyDescriptor(t, r);
  !_se(o, s) && n || Object.defineProperty(e, r, s);
}, _se = function(e, t) {
  return e === void 0 || e.configurable || e.writable === t.writable && e.enumerable === t.enumerable && e.configurable === t.configurable && (e.writable || e.value === t.value);
}, Sse = (e, t) => {
  const r = Object.getPrototypeOf(t);
  r !== Object.getPrototypeOf(e) && Object.setPrototypeOf(e, r);
}, Ese = (e, t) => `/* Wrapped ${e}*/
${t}`, xse = Object.getOwnPropertyDescriptor(Function.prototype, "toString"), Rse = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name"), Ase = (e, t, r) => {
  const n = r === "" ? "" : `with ${r.trim()}() `, o = Ese.bind(null, n, t.toString());
  Object.defineProperty(o, "name", Rse), Object.defineProperty(e, "toString", { ...xse, value: o });
};
function Tse(e, t, { ignoreNonConfigurable: r = !1 } = {}) {
  const { name: n } = e;
  for (const o of Reflect.ownKeys(t))
    wse(e, t, o, r);
  return Sse(e, t), Ase(e, t, n), e;
}
const xh = /* @__PURE__ */ new WeakMap(), k7 = (e, t = {}) => {
  if (typeof e != "function")
    throw new TypeError("Expected a function");
  let r, n = 0;
  const o = e.displayName || e.name || "<anonymous>", s = function(...a) {
    if (xh.set(s, ++n), n === 1)
      r = e.apply(this, a), e = null;
    else if (t.throw === !0)
      throw new Error(`Function \`${o}\` can only be called once`);
    return r;
  };
  return Tse(s, e), xh.set(s, n), s;
};
k7.callCount = (e) => {
  if (!xh.has(e))
    throw new Error(`The given function \`${e.name}\` is not wrapped by the \`onetime\` package`);
  return xh.get(e);
};
var I7 = { exports: {} }, jy = { exports: {} }, qt = {
  ArrayIsArray(e) {
    return Array.isArray(e);
  },
  ArrayPrototypeIncludes(e, t) {
    return e.includes(t);
  },
  ArrayPrototypeIndexOf(e, t) {
    return e.indexOf(t);
  },
  ArrayPrototypeJoin(e, t) {
    return e.join(t);
  },
  ArrayPrototypeMap(e, t) {
    return e.map(t);
  },
  ArrayPrototypePop(e, t) {
    return e.pop(t);
  },
  ArrayPrototypePush(e, t) {
    return e.push(t);
  },
  ArrayPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  Error,
  FunctionPrototypeCall(e, t, ...r) {
    return e.call(t, ...r);
  },
  FunctionPrototypeSymbolHasInstance(e, t) {
    return Function.prototype[Symbol.hasInstance].call(e, t);
  },
  MathFloor: Math.floor,
  Number,
  NumberIsInteger: Number.isInteger,
  NumberIsNaN: Number.isNaN,
  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
  NumberParseInt: Number.parseInt,
  ObjectDefineProperties(e, t) {
    return Object.defineProperties(e, t);
  },
  ObjectDefineProperty(e, t, r) {
    return Object.defineProperty(e, t, r);
  },
  ObjectGetOwnPropertyDescriptor(e, t) {
    return Object.getOwnPropertyDescriptor(e, t);
  },
  ObjectKeys(e) {
    return Object.keys(e);
  },
  ObjectSetPrototypeOf(e, t) {
    return Object.setPrototypeOf(e, t);
  },
  Promise,
  PromisePrototypeCatch(e, t) {
    return e.catch(t);
  },
  PromisePrototypeThen(e, t, r) {
    return e.then(t, r);
  },
  PromiseReject(e) {
    return Promise.reject(e);
  },
  PromiseResolve(e) {
    return Promise.resolve(e);
  },
  ReflectApply: Reflect.apply,
  RegExpPrototypeTest(e, t) {
    return e.test(t);
  },
  SafeSet: Set,
  String,
  StringPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  StringPrototypeToLowerCase(e) {
    return e.toLowerCase();
  },
  StringPrototypeToUpperCase(e) {
    return e.toUpperCase();
  },
  StringPrototypeTrim(e) {
    return e.trim();
  },
  Symbol,
  SymbolFor: Symbol.for,
  SymbolAsyncIterator: Symbol.asyncIterator,
  SymbolHasInstance: Symbol.hasInstance,
  SymbolIterator: Symbol.iterator,
  SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
  SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
  TypedArrayPrototypeSet(e, t, r) {
    return e.set(t, r);
  },
  Boolean,
  Uint8Array
}, M7 = { exports: {} };
(function(e) {
  const t = ut, { kResistStopPropagation: r, SymbolDispose: n } = qt, o = globalThis.AbortSignal || Kt().AbortSignal, s = globalThis.AbortController || Kt().AbortController, a = Object.getPrototypeOf(async function() {
  }).constructor, l = globalThis.Blob || t.Blob, u = typeof l < "u" ? function(p) {
    return p instanceof l;
  } : function(p) {
    return !1;
  }, f = (h, p) => {
    if (h !== void 0 && (h === null || typeof h != "object" || !("aborted" in h)))
      throw new ERR_INVALID_ARG_TYPE(p, "AbortSignal", h);
  }, c = (h, p) => {
    if (typeof h != "function")
      throw new ERR_INVALID_ARG_TYPE(p, "Function", h);
  };
  class d extends Error {
    constructor(p) {
      if (!Array.isArray(p))
        throw new TypeError(`Expected input to be an Array, got ${typeof p}`);
      let m = "";
      for (let y = 0; y < p.length; y++)
        m += `    ${p[y].stack}
`;
      super(m), this.name = "AggregateError", this.errors = p;
    }
  }
  e.exports = {
    AggregateError: d,
    kEmptyObject: Object.freeze({}),
    once(h) {
      let p = !1;
      return function(...m) {
        p || (p = !0, h.apply(this, m));
      };
    },
    createDeferredPromise: function() {
      let h, p;
      return {
        promise: new Promise((y, _) => {
          h = y, p = _;
        }),
        resolve: h,
        reject: p
      };
    },
    promisify(h) {
      return new Promise((p, m) => {
        h((y, ..._) => y ? m(y) : p(..._));
      });
    },
    debuglog() {
      return function() {
      };
    },
    format(h, ...p) {
      return h.replace(/%([sdifj])/g, function(...[m, y]) {
        const _ = p.shift();
        return y === "f" ? _.toFixed(6) : y === "j" ? JSON.stringify(_) : y === "s" && typeof _ == "object" ? `${_.constructor !== Object ? _.constructor.name : ""} {}`.trim() : _.toString();
      });
    },
    inspect(h) {
      switch (typeof h) {
        case "string":
          if (h.includes("'"))
            if (h.includes('"')) {
              if (!h.includes("`") && !h.includes("${"))
                return `\`${h}\``;
            } else
              return `"${h}"`;
          return `'${h}'`;
        case "number":
          return isNaN(h) ? "NaN" : Object.is(h, -0) ? String(h) : h;
        case "bigint":
          return `${String(h)}n`;
        case "boolean":
        case "undefined":
          return String(h);
        case "object":
          return "{}";
      }
    },
    types: {
      isAsyncFunction(h) {
        return h instanceof a;
      },
      isArrayBufferView(h) {
        return ArrayBuffer.isView(h);
      }
    },
    isBlob: u,
    deprecate(h, p) {
      return h;
    },
    addAbortListener: ur.addAbortListener || function(p, m) {
      if (p === void 0)
        throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", p);
      f(p, "signal"), c(m, "listener");
      let y;
      return p.aborted ? queueMicrotask(() => m()) : (p.addEventListener("abort", m, {
        __proto__: null,
        once: !0,
        [r]: !0
      }), y = () => {
        p.removeEventListener("abort", m);
      }), {
        __proto__: null,
        [n]() {
          var _;
          (_ = y) === null || _ === void 0 || _();
        }
      };
    },
    AbortSignalAny: o.any || function(p) {
      if (p.length === 1)
        return p[0];
      const m = new s(), y = () => m.abort();
      return p.forEach((_) => {
        f(_, "signals"), _.addEventListener("abort", y, {
          once: !0
        });
      }), m.signal.addEventListener(
        "abort",
        () => {
          p.forEach((_) => _.removeEventListener("abort", y));
        },
        {
          once: !0
        }
      ), m.signal;
    }
  }, e.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
})(M7);
var Gr = M7.exports, Px = {};
const { format: $se, inspect: Rh, AggregateError: Cse } = Gr, kse = globalThis.AggregateError || Cse, Ise = Symbol("kIsNodeError"), Mse = [
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
], Nse = /^([A-Z][a-z0-9]*)+$/, Lse = "__node_internal_", rg = {};
function da(e, t) {
  if (!e)
    throw new rg.ERR_INTERNAL_ASSERTION(t);
}
function _k(e) {
  let t = "", r = e.length;
  const n = e[0] === "-" ? 1 : 0;
  for (; r >= n + 4; r -= 3)
    t = `_${e.slice(r - 3, r)}${t}`;
  return `${e.slice(0, r)}${t}`;
}
function Ose(e, t, r) {
  if (typeof t == "function")
    return da(
      t.length <= r.length,
      // Default options do not count.
      `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${t.length}).`
    ), t(...r);
  const n = (t.match(/%[dfijoOs]/g) || []).length;
  return da(
    n === r.length,
    `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${n}).`
  ), r.length === 0 ? t : $se(t, ...r);
}
function Sr(e, t, r) {
  r || (r = Error);
  class n extends r {
    constructor(...s) {
      super(Ose(e, t, s));
    }
    toString() {
      return `${this.name} [${e}]: ${this.message}`;
    }
  }
  Object.defineProperties(n.prototype, {
    name: {
      value: r.name,
      writable: !0,
      enumerable: !1,
      configurable: !0
    },
    toString: {
      value() {
        return `${this.name} [${e}]: ${this.message}`;
      },
      writable: !0,
      enumerable: !1,
      configurable: !0
    }
  }), n.prototype.code = e, n.prototype[Ise] = !0, rg[e] = n;
}
function Sk(e) {
  const t = Lse + e.name;
  return Object.defineProperty(e, "name", {
    value: t
  }), e;
}
function Pse(e, t) {
  if (e && t && e !== t) {
    if (Array.isArray(t.errors))
      return t.errors.push(e), t;
    const r = new kse([t, e], t.message);
    return r.code = t.code, r;
  }
  return e || t;
}
let Dse = class extends Error {
  constructor(t = "The operation was aborted", r = void 0) {
    if (r !== void 0 && typeof r != "object")
      throw new rg.ERR_INVALID_ARG_TYPE("options", "Object", r);
    super(t, r), this.code = "ABORT_ERR", this.name = "AbortError";
  }
};
Sr("ERR_ASSERTION", "%s", Error);
Sr(
  "ERR_INVALID_ARG_TYPE",
  (e, t, r) => {
    da(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
    let n = "The ";
    e.endsWith(" argument") ? n += `${e} ` : n += `"${e}" ${e.includes(".") ? "property" : "argument"} `, n += "must be ";
    const o = [], s = [], a = [];
    for (const u of t)
      da(typeof u == "string", "All expected entries have to be of type string"), Mse.includes(u) ? o.push(u.toLowerCase()) : Nse.test(u) ? s.push(u) : (da(u !== "object", 'The value "object" should be written as "Object"'), a.push(u));
    if (s.length > 0) {
      const u = o.indexOf("object");
      u !== -1 && (o.splice(o, u, 1), s.push("Object"));
    }
    if (o.length > 0) {
      switch (o.length) {
        case 1:
          n += `of type ${o[0]}`;
          break;
        case 2:
          n += `one of type ${o[0]} or ${o[1]}`;
          break;
        default: {
          const u = o.pop();
          n += `one of type ${o.join(", ")}, or ${u}`;
        }
      }
      (s.length > 0 || a.length > 0) && (n += " or ");
    }
    if (s.length > 0) {
      switch (s.length) {
        case 1:
          n += `an instance of ${s[0]}`;
          break;
        case 2:
          n += `an instance of ${s[0]} or ${s[1]}`;
          break;
        default: {
          const u = s.pop();
          n += `an instance of ${s.join(", ")}, or ${u}`;
        }
      }
      a.length > 0 && (n += " or ");
    }
    switch (a.length) {
      case 0:
        break;
      case 1:
        a[0].toLowerCase() !== a[0] && (n += "an "), n += `${a[0]}`;
        break;
      case 2:
        n += `one of ${a[0]} or ${a[1]}`;
        break;
      default: {
        const u = a.pop();
        n += `one of ${a.join(", ")}, or ${u}`;
      }
    }
    if (r == null)
      n += `. Received ${r}`;
    else if (typeof r == "function" && r.name)
      n += `. Received function ${r.name}`;
    else if (typeof r == "object") {
      var l;
      if ((l = r.constructor) !== null && l !== void 0 && l.name)
        n += `. Received an instance of ${r.constructor.name}`;
      else {
        const u = Rh(r, {
          depth: -1
        });
        n += `. Received ${u}`;
      }
    } else {
      let u = Rh(r, {
        colors: !1
      });
      u.length > 25 && (u = `${u.slice(0, 25)}...`), n += `. Received type ${typeof r} (${u})`;
    }
    return n;
  },
  TypeError
);
Sr(
  "ERR_INVALID_ARG_VALUE",
  (e, t, r = "is invalid") => {
    let n = Rh(t);
    return n.length > 128 && (n = n.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${n}`;
  },
  TypeError
);
Sr(
  "ERR_INVALID_RETURN_VALUE",
  (e, t, r) => {
    var n;
    const o = r != null && (n = r.constructor) !== null && n !== void 0 && n.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
    return `Expected ${e} to be returned from the "${t}" function but got ${o}.`;
  },
  TypeError
);
Sr(
  "ERR_MISSING_ARGS",
  (...e) => {
    da(e.length > 0, "At least one arg needs to be specified");
    let t;
    const r = e.length;
    switch (e = (Array.isArray(e) ? e : [e]).map((n) => `"${n}"`).join(" or "), r) {
      case 1:
        t += `The ${e[0]} argument`;
        break;
      case 2:
        t += `The ${e[0]} and ${e[1]} arguments`;
        break;
      default:
        {
          const n = e.pop();
          t += `The ${e.join(", ")}, and ${n} arguments`;
        }
        break;
    }
    return `${t} must be specified`;
  },
  TypeError
);
Sr(
  "ERR_OUT_OF_RANGE",
  (e, t, r) => {
    da(t, 'Missing "range" argument');
    let n;
    return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? n = _k(String(r)) : typeof r == "bigint" ? (n = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (n = _k(n)), n += "n") : n = Rh(r), `The value of "${e}" is out of range. It must be ${t}. Received ${n}`;
  },
  RangeError
);
Sr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
Sr("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
Sr("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
Sr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
Sr("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
Sr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
Sr("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
Sr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
Sr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
Sr("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
Sr("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
var an = {
  AbortError: Dse,
  aggregateTwoErrors: Sk(Pse),
  hideStackFrames: Sk,
  codes: rg
};
const {
  ArrayIsArray: Dx,
  ArrayPrototypeIncludes: N7,
  ArrayPrototypeJoin: L7,
  ArrayPrototypeMap: Fse,
  NumberIsInteger: Fx,
  NumberIsNaN: jse,
  NumberMAX_SAFE_INTEGER: Bse,
  NumberMIN_SAFE_INTEGER: qse,
  NumberParseInt: Wse,
  ObjectPrototypeHasOwnProperty: Use,
  RegExpPrototypeExec: O7,
  String: Hse,
  StringPrototypeToUpperCase: zse,
  StringPrototypeTrim: Gse
} = qt, {
  hideStackFrames: Nn,
  codes: { ERR_SOCKET_BAD_PORT: Vse, ERR_INVALID_ARG_TYPE: Nr, ERR_INVALID_ARG_VALUE: yu, ERR_OUT_OF_RANGE: Ta, ERR_UNKNOWN_SIGNAL: Ek }
} = an, { normalizeEncoding: Kse } = Gr, { isAsyncFunction: Yse, isArrayBufferView: Xse } = Gr.types, xk = {};
function Jse(e) {
  return e === (e | 0);
}
function Qse(e) {
  return e === e >>> 0;
}
const Zse = /^[0-7]+$/, eae = "must be a 32-bit unsigned integer or an octal string";
function tae(e, t, r) {
  if (typeof e > "u" && (e = r), typeof e == "string") {
    if (O7(Zse, e) === null)
      throw new yu(t, e, eae);
    e = Wse(e, 8);
  }
  return P7(e, t), e;
}
const rae = Nn((e, t, r = qse, n = Bse) => {
  if (typeof e != "number")
    throw new Nr(t, "number", e);
  if (!Fx(e))
    throw new Ta(t, "an integer", e);
  if (e < r || e > n)
    throw new Ta(t, `>= ${r} && <= ${n}`, e);
}), nae = Nn((e, t, r = -2147483648, n = 2147483647) => {
  if (typeof e != "number")
    throw new Nr(t, "number", e);
  if (!Fx(e))
    throw new Ta(t, "an integer", e);
  if (e < r || e > n)
    throw new Ta(t, `>= ${r} && <= ${n}`, e);
}), P7 = Nn((e, t, r = !1) => {
  if (typeof e != "number")
    throw new Nr(t, "number", e);
  if (!Fx(e))
    throw new Ta(t, "an integer", e);
  const n = r ? 1 : 0, o = 4294967295;
  if (e < n || e > o)
    throw new Ta(t, `>= ${n} && <= ${o}`, e);
});
function jx(e, t) {
  if (typeof e != "string")
    throw new Nr(t, "string", e);
}
function iae(e, t, r = void 0, n) {
  if (typeof e != "number")
    throw new Nr(t, "number", e);
  if (r != null && e < r || n != null && e > n || (r != null || n != null) && jse(e))
    throw new Ta(
      t,
      `${r != null ? `>= ${r}` : ""}${r != null && n != null ? " && " : ""}${n != null ? `<= ${n}` : ""}`,
      e
    );
}
const oae = Nn((e, t, r) => {
  if (!N7(r, e)) {
    const o = "must be one of: " + L7(
      Fse(r, (s) => typeof s == "string" ? `'${s}'` : Hse(s)),
      ", "
    );
    throw new yu(t, e, o);
  }
});
function D7(e, t) {
  if (typeof e != "boolean")
    throw new Nr(t, "boolean", e);
}
function By(e, t, r) {
  return e == null || !Use(e, t) ? r : e[t];
}
const sae = Nn((e, t, r = null) => {
  const n = By(r, "allowArray", !1), o = By(r, "allowFunction", !1);
  if (!By(r, "nullable", !1) && e === null || !n && Dx(e) || typeof e != "object" && (!o || typeof e != "function"))
    throw new Nr(t, "Object", e);
}), aae = Nn((e, t) => {
  if (e != null && typeof e != "object" && typeof e != "function")
    throw new Nr(t, "a dictionary", e);
}), ng = Nn((e, t, r = 0) => {
  if (!Dx(e))
    throw new Nr(t, "Array", e);
  if (e.length < r) {
    const n = `must be longer than ${r}`;
    throw new yu(t, e, n);
  }
});
function lae(e, t) {
  ng(e, t);
  for (let r = 0; r < e.length; r++)
    jx(e[r], `${t}[${r}]`);
}
function uae(e, t) {
  ng(e, t);
  for (let r = 0; r < e.length; r++)
    D7(e[r], `${t}[${r}]`);
}
function fae(e, t) {
  ng(e, t);
  for (let r = 0; r < e.length; r++) {
    const n = e[r], o = `${t}[${r}]`;
    if (n == null)
      throw new Nr(o, "AbortSignal", n);
    F7(n, o);
  }
}
function cae(e, t = "signal") {
  if (jx(e, t), xk[e] === void 0)
    throw xk[zse(e)] !== void 0 ? new Ek(e + " (signals must use all capital letters)") : new Ek(e);
}
const dae = Nn((e, t = "buffer") => {
  if (!Xse(e))
    throw new Nr(t, ["Buffer", "TypedArray", "DataView"], e);
});
function hae(e, t) {
  const r = Kse(t), n = e.length;
  if (r === "hex" && n % 2 !== 0)
    throw new yu("encoding", t, `is invalid for data of length ${n}`);
}
function pae(e, t = "Port", r = !0) {
  if (typeof e != "number" && typeof e != "string" || typeof e == "string" && Gse(e).length === 0 || +e !== +e >>> 0 || e > 65535 || e === 0 && !r)
    throw new Vse(t, e, r);
  return e | 0;
}
const F7 = Nn((e, t) => {
  if (e !== void 0 && (e === null || typeof e != "object" || !("aborted" in e)))
    throw new Nr(t, "AbortSignal", e);
}), gae = Nn((e, t) => {
  if (typeof e != "function")
    throw new Nr(t, "Function", e);
}), bae = Nn((e, t) => {
  if (typeof e != "function" || Yse(e))
    throw new Nr(t, "Function", e);
}), yae = Nn((e, t) => {
  if (e !== void 0)
    throw new Nr(t, "undefined", e);
});
function mae(e, t, r) {
  if (!N7(r, e))
    throw new Nr(t, `('${L7(r, "|")}')`, e);
}
const vae = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
function Rk(e, t) {
  if (typeof e > "u" || !O7(vae, e))
    throw new yu(
      t,
      e,
      'must be an array or string of format "</styles.css>; rel=preload; as=style"'
    );
}
function wae(e) {
  if (typeof e == "string")
    return Rk(e, "hints"), e;
  if (Dx(e)) {
    const t = e.length;
    let r = "";
    if (t === 0)
      return r;
    for (let n = 0; n < t; n++) {
      const o = e[n];
      Rk(o, "hints"), r += o, n !== t - 1 && (r += ", ");
    }
    return r;
  }
  throw new yu(
    "hints",
    e,
    'must be an array or string of format "</styles.css>; rel=preload; as=style"'
  );
}
var _c = {
  isInt32: Jse,
  isUint32: Qse,
  parseFileMode: tae,
  validateArray: ng,
  validateStringArray: lae,
  validateBooleanArray: uae,
  validateAbortSignalArray: fae,
  validateBoolean: D7,
  validateBuffer: dae,
  validateDictionary: aae,
  validateEncoding: hae,
  validateFunction: gae,
  validateInt32: nae,
  validateInteger: rae,
  validateNumber: iae,
  validateObject: sae,
  validateOneOf: oae,
  validatePlainFunction: bae,
  validatePort: pae,
  validateSignalName: cae,
  validateString: jx,
  validateUint32: P7,
  validateUndefined: yae,
  validateUnion: mae,
  validateAbortSignal: F7,
  validateLinkHeaderValue: wae
}, Bx = { exports: {} };
const { SymbolAsyncIterator: Ak, SymbolIterator: Tk, SymbolFor: Ya } = qt, j7 = Ya("nodejs.stream.destroyed"), B7 = Ya("nodejs.stream.errored"), SS = Ya("nodejs.stream.readable"), ES = Ya("nodejs.stream.writable"), q7 = Ya("nodejs.stream.disturbed"), _ae = Ya("nodejs.webstream.isClosedPromise"), Sae = Ya("nodejs.webstream.controllerErrorFunction");
function ig(e, t = !1) {
  var r;
  return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((r = e._readableState) === null || r === void 0 ? void 0 : r.readable) !== !1) && // Duplex
  (!e._writableState || e._readableState));
}
function og(e) {
  var t;
  return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === void 0 ? void 0 : t.writable) !== !1));
}
function Eae(e) {
  return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
}
function Bi(e) {
  return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
}
function W7(e) {
  return !!(e && !Bi(e) && typeof e.pipeThrough == "function" && typeof e.getReader == "function" && typeof e.cancel == "function");
}
function U7(e) {
  return !!(e && !Bi(e) && typeof e.getWriter == "function" && typeof e.abort == "function");
}
function H7(e) {
  return !!(e && !Bi(e) && typeof e.readable == "object" && typeof e.writable == "object");
}
function xae(e) {
  return W7(e) || U7(e) || H7(e);
}
function Rae(e, t) {
  return e == null ? !1 : t === !0 ? typeof e[Ak] == "function" : t === !1 ? typeof e[Tk] == "function" : typeof e[Ak] == "function" || typeof e[Tk] == "function";
}
function sg(e) {
  if (!Bi(e))
    return null;
  const t = e._writableState, r = e._readableState, n = t || r;
  return !!(e.destroyed || e[j7] || n != null && n.destroyed);
}
function z7(e) {
  if (!og(e))
    return null;
  if (e.writableEnded === !0)
    return !0;
  const t = e._writableState;
  return t != null && t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function Aae(e, t) {
  if (!og(e))
    return null;
  if (e.writableFinished === !0)
    return !0;
  const r = e._writableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.finished) != "boolean" ? null : !!(r.finished || t === !1 && r.ended === !0 && r.length === 0);
}
function Tae(e) {
  if (!ig(e))
    return null;
  if (e.readableEnded === !0)
    return !0;
  const t = e._readableState;
  return !t || t.errored ? !1 : typeof (t == null ? void 0 : t.ended) != "boolean" ? null : t.ended;
}
function G7(e, t) {
  if (!ig(e))
    return null;
  const r = e._readableState;
  return r != null && r.errored ? !1 : typeof (r == null ? void 0 : r.endEmitted) != "boolean" ? null : !!(r.endEmitted || t === !1 && r.ended === !0 && r.length === 0);
}
function V7(e) {
  return e && e[SS] != null ? e[SS] : typeof (e == null ? void 0 : e.readable) != "boolean" ? null : sg(e) ? !1 : ig(e) && e.readable && !G7(e);
}
function K7(e) {
  return e && e[ES] != null ? e[ES] : typeof (e == null ? void 0 : e.writable) != "boolean" ? null : sg(e) ? !1 : og(e) && e.writable && !z7(e);
}
function $ae(e, t) {
  return Bi(e) ? sg(e) ? !0 : !((t == null ? void 0 : t.readable) !== !1 && V7(e) || (t == null ? void 0 : t.writable) !== !1 && K7(e)) : null;
}
function Cae(e) {
  var t, r;
  return Bi(e) ? e.writableErrored ? e.writableErrored : (t = (r = e._writableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function kae(e) {
  var t, r;
  return Bi(e) ? e.readableErrored ? e.readableErrored : (t = (r = e._readableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function Iae(e) {
  if (!Bi(e))
    return null;
  if (typeof e.closed == "boolean")
    return e.closed;
  const t = e._writableState, r = e._readableState;
  return typeof (t == null ? void 0 : t.closed) == "boolean" || typeof (r == null ? void 0 : r.closed) == "boolean" ? (t == null ? void 0 : t.closed) || (r == null ? void 0 : r.closed) : typeof e._closed == "boolean" && Y7(e) ? e._closed : null;
}
function Y7(e) {
  return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
}
function X7(e) {
  return typeof e._sent100 == "boolean" && Y7(e);
}
function Mae(e) {
  var t;
  return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === void 0 ? void 0 : t.upgradeOrConnect) === void 0;
}
function Nae(e) {
  if (!Bi(e))
    return null;
  const t = e._writableState, r = e._readableState, n = t || r;
  return !n && X7(e) || !!(n && n.autoDestroy && n.emitClose && n.closed === !1);
}
function Lae(e) {
  var t;
  return !!(e && ((t = e[q7]) !== null && t !== void 0 ? t : e.readableDidRead || e.readableAborted));
}
function Oae(e) {
  var t, r, n, o, s, a, l, u, f, c;
  return !!(e && ((t = (r = (n = (o = (s = (a = e[B7]) !== null && a !== void 0 ? a : e.readableErrored) !== null && s !== void 0 ? s : e.writableErrored) !== null && o !== void 0 ? o : (l = e._readableState) === null || l === void 0 ? void 0 : l.errorEmitted) !== null && n !== void 0 ? n : (u = e._writableState) === null || u === void 0 ? void 0 : u.errorEmitted) !== null && r !== void 0 ? r : (f = e._readableState) === null || f === void 0 ? void 0 : f.errored) !== null && t !== void 0 ? t : !((c = e._writableState) === null || c === void 0) && c.errored));
}
var To = {
  isDestroyed: sg,
  kIsDestroyed: j7,
  isDisturbed: Lae,
  kIsDisturbed: q7,
  isErrored: Oae,
  kIsErrored: B7,
  isReadable: V7,
  kIsReadable: SS,
  kIsClosedPromise: _ae,
  kControllerErrorFunction: Sae,
  kIsWritable: ES,
  isClosed: Iae,
  isDuplexNodeStream: Eae,
  isFinished: $ae,
  isIterable: Rae,
  isReadableNodeStream: ig,
  isReadableStream: W7,
  isReadableEnded: Tae,
  isReadableFinished: G7,
  isReadableErrored: kae,
  isNodeStream: Bi,
  isWebStream: xae,
  isWritable: K7,
  isWritableNodeStream: og,
  isWritableStream: U7,
  isWritableEnded: z7,
  isWritableFinished: Aae,
  isWritableErrored: Cae,
  isServerRequest: Mae,
  isServerResponse: X7,
  willEmitClose: Nae,
  isTransformStream: H7
};
const qo = _t, { AbortError: J7, codes: Pae } = an, { ERR_INVALID_ARG_TYPE: Dae, ERR_STREAM_PREMATURE_CLOSE: $k } = Pae, { kEmptyObject: xS, once: RS } = Gr, { validateAbortSignal: Fae, validateFunction: jae, validateObject: Bae, validateBoolean: qae } = _c, { Promise: Wae, PromisePrototypeThen: Uae, SymbolDispose: Q7 } = qt, {
  isClosed: Hae,
  isReadable: Ck,
  isReadableNodeStream: qy,
  isReadableStream: zae,
  isReadableFinished: kk,
  isReadableErrored: Ik,
  isWritable: Mk,
  isWritableNodeStream: Nk,
  isWritableStream: Gae,
  isWritableFinished: Lk,
  isWritableErrored: Ok,
  isNodeStream: Vae,
  willEmitClose: Kae,
  kIsClosedPromise: Yae
} = To;
let Ol;
function Xae(e) {
  return e.setHeader && typeof e.abort == "function";
}
const AS = () => {
};
function Z7(e, t, r) {
  var n, o;
  if (arguments.length === 2 ? (r = t, t = xS) : t == null ? t = xS : Bae(t, "options"), jae(r, "callback"), Fae(t.signal, "options.signal"), r = RS(r), zae(e) || Gae(e))
    return Jae(e, t, r);
  if (!Vae(e))
    throw new Dae("stream", ["ReadableStream", "WritableStream", "Stream"], e);
  const s = (n = t.readable) !== null && n !== void 0 ? n : qy(e), a = (o = t.writable) !== null && o !== void 0 ? o : Nk(e), l = e._writableState, u = e._readableState, f = () => {
    e.writable || h();
  };
  let c = Kae(e) && qy(e) === s && Nk(e) === a, d = Lk(e, !1);
  const h = () => {
    d = !0, e.destroyed && (c = !1), !(c && (!e.readable || s)) && (!s || p) && r.call(e);
  };
  let p = kk(e, !1);
  const m = () => {
    p = !0, e.destroyed && (c = !1), !(c && (!e.writable || a)) && (!a || d) && r.call(e);
  }, y = (I) => {
    r.call(e, I);
  };
  let _ = Hae(e);
  const S = () => {
    _ = !0;
    const I = Ok(e) || Ik(e);
    if (I && typeof I != "boolean")
      return r.call(e, I);
    if (s && !p && qy(e, !0) && !kk(e, !1))
      return r.call(e, new $k());
    if (a && !d && !Lk(e, !1))
      return r.call(e, new $k());
    r.call(e);
  }, x = () => {
    _ = !0;
    const I = Ok(e) || Ik(e);
    if (I && typeof I != "boolean")
      return r.call(e, I);
    r.call(e);
  }, E = () => {
    e.req.on("finish", h);
  };
  Xae(e) ? (e.on("complete", h), c || e.on("abort", S), e.req ? E() : e.on("request", E)) : a && !l && (e.on("end", f), e.on("close", f)), !c && typeof e.aborted == "boolean" && e.on("aborted", S), e.on("end", m), e.on("finish", h), t.error !== !1 && e.on("error", y), e.on("close", S), _ ? qo.nextTick(S) : l != null && l.errorEmitted || u != null && u.errorEmitted ? c || qo.nextTick(x) : (!s && (!c || Ck(e)) && (d || Mk(e) === !1) || !a && (!c || Mk(e)) && (p || Ck(e) === !1) || u && e.req && e.aborted) && qo.nextTick(x);
  const C = () => {
    r = AS, e.removeListener("aborted", S), e.removeListener("complete", h), e.removeListener("abort", S), e.removeListener("request", E), e.req && e.req.removeListener("finish", h), e.removeListener("end", f), e.removeListener("close", f), e.removeListener("finish", h), e.removeListener("end", m), e.removeListener("error", y), e.removeListener("close", S);
  };
  if (t.signal && !_) {
    const I = () => {
      const j = r;
      C(), j.call(
        e,
        new J7(void 0, {
          cause: t.signal.reason
        })
      );
    };
    if (t.signal.aborted)
      qo.nextTick(I);
    else {
      Ol = Ol || Gr.addAbortListener;
      const j = Ol(t.signal, I), J = r;
      r = RS((...G) => {
        j[Q7](), J.apply(e, G);
      });
    }
  }
  return C;
}
function Jae(e, t, r) {
  let n = !1, o = AS;
  if (t.signal)
    if (o = () => {
      n = !0, r.call(
        e,
        new J7(void 0, {
          cause: t.signal.reason
        })
      );
    }, t.signal.aborted)
      qo.nextTick(o);
    else {
      Ol = Ol || Gr.addAbortListener;
      const a = Ol(t.signal, o), l = r;
      r = RS((...u) => {
        a[Q7](), l.apply(e, u);
      });
    }
  const s = (...a) => {
    n || qo.nextTick(() => r.apply(e, a));
  };
  return Uae(e[Yae].promise, s, s), AS;
}
function Qae(e, t) {
  var r;
  let n = !1;
  return t === null && (t = xS), (r = t) !== null && r !== void 0 && r.cleanup && (qae(t.cleanup, "cleanup"), n = t.cleanup), new Wae((o, s) => {
    const a = Z7(e, t, (l) => {
      n && a(), l ? s(l) : o();
    });
  });
}
Bx.exports = Z7;
Bx.exports.finished = Qae;
var _s = Bx.exports;
const Si = _t, {
  aggregateTwoErrors: Zae,
  codes: { ERR_MULTIPLE_CALLBACK: ele },
  AbortError: tle
} = an, { Symbol: e8 } = qt, { kIsDestroyed: rle, isDestroyed: nle, isFinished: ile, isServerRequest: ole } = To, t8 = e8("kDestroy"), TS = e8("kConstruct");
function r8(e, t, r) {
  e && (e.stack, t && !t.errored && (t.errored = e), r && !r.errored && (r.errored = e));
}
function sle(e, t) {
  const r = this._readableState, n = this._writableState, o = n || r;
  return n != null && n.destroyed || r != null && r.destroyed ? (typeof t == "function" && t(), this) : (r8(e, n, r), n && (n.destroyed = !0), r && (r.destroyed = !0), o.constructed ? Pk(this, e, t) : this.once(t8, function(s) {
    Pk(this, Zae(s, e), t);
  }), this);
}
function Pk(e, t, r) {
  let n = !1;
  function o(s) {
    if (n)
      return;
    n = !0;
    const a = e._readableState, l = e._writableState;
    r8(s, l, a), l && (l.closed = !0), a && (a.closed = !0), typeof r == "function" && r(s), s ? Si.nextTick(ale, e, s) : Si.nextTick(n8, e);
  }
  try {
    e._destroy(t || null, o);
  } catch (s) {
    o(s);
  }
}
function ale(e, t) {
  $S(e, t), n8(e);
}
function n8(e) {
  const t = e._readableState, r = e._writableState;
  r && (r.closeEmitted = !0), t && (t.closeEmitted = !0), (r != null && r.emitClose || t != null && t.emitClose) && e.emit("close");
}
function $S(e, t) {
  const r = e._readableState, n = e._writableState;
  n != null && n.errorEmitted || r != null && r.errorEmitted || (n && (n.errorEmitted = !0), r && (r.errorEmitted = !0), e.emit("error", t));
}
function lle() {
  const e = this._readableState, t = this._writableState;
  e && (e.constructed = !0, e.closed = !1, e.closeEmitted = !1, e.destroyed = !1, e.errored = null, e.errorEmitted = !1, e.reading = !1, e.ended = e.readable === !1, e.endEmitted = e.readable === !1), t && (t.constructed = !0, t.destroyed = !1, t.closed = !1, t.closeEmitted = !1, t.errored = null, t.errorEmitted = !1, t.finalCalled = !1, t.prefinished = !1, t.ended = t.writable === !1, t.ending = t.writable === !1, t.finished = t.writable === !1);
}
function CS(e, t, r) {
  const n = e._readableState, o = e._writableState;
  if (o != null && o.destroyed || n != null && n.destroyed)
    return this;
  n != null && n.autoDestroy || o != null && o.autoDestroy ? e.destroy(t) : t && (t.stack, o && !o.errored && (o.errored = t), n && !n.errored && (n.errored = t), r ? Si.nextTick($S, e, t) : $S(e, t));
}
function ule(e, t) {
  if (typeof e._construct != "function")
    return;
  const r = e._readableState, n = e._writableState;
  r && (r.constructed = !1), n && (n.constructed = !1), e.once(TS, t), !(e.listenerCount(TS) > 1) && Si.nextTick(fle, e);
}
function fle(e) {
  let t = !1;
  function r(n) {
    if (t) {
      CS(e, n ?? new ele());
      return;
    }
    t = !0;
    const o = e._readableState, s = e._writableState, a = s || o;
    o && (o.constructed = !0), s && (s.constructed = !0), a.destroyed ? e.emit(t8, n) : n ? CS(e, n, !0) : Si.nextTick(cle, e);
  }
  try {
    e._construct((n) => {
      Si.nextTick(r, n);
    });
  } catch (n) {
    Si.nextTick(r, n);
  }
}
function cle(e) {
  e.emit(TS);
}
function Dk(e) {
  return (e == null ? void 0 : e.setHeader) && typeof e.abort == "function";
}
function i8(e) {
  e.emit("close");
}
function dle(e, t) {
  e.emit("error", t), Si.nextTick(i8, e);
}
function hle(e, t) {
  !e || nle(e) || (!t && !ile(e) && (t = new tle()), ole(e) ? (e.socket = null, e.destroy(t)) : Dk(e) ? e.abort() : Dk(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? Si.nextTick(dle, e, t) : Si.nextTick(i8, e), e.destroyed || (e[rle] = !0));
}
var mu = {
  construct: ule,
  destroyer: hle,
  destroy: sle,
  undestroy: lle,
  errorOrDestroy: CS
};
const { ArrayIsArray: ple, ObjectSetPrototypeOf: o8 } = qt, { EventEmitter: ag } = ur;
function lg(e) {
  ag.call(this, e);
}
o8(lg.prototype, ag.prototype);
o8(lg, ag);
lg.prototype.pipe = function(e, t) {
  const r = this;
  function n(c) {
    e.writable && e.write(c) === !1 && r.pause && r.pause();
  }
  r.on("data", n);
  function o() {
    r.readable && r.resume && r.resume();
  }
  e.on("drain", o), !e._isStdio && (!t || t.end !== !1) && (r.on("end", a), r.on("close", l));
  let s = !1;
  function a() {
    s || (s = !0, e.end());
  }
  function l() {
    s || (s = !0, typeof e.destroy == "function" && e.destroy());
  }
  function u(c) {
    f(), ag.listenerCount(this, "error") === 0 && this.emit("error", c);
  }
  kS(r, "error", u), kS(e, "error", u);
  function f() {
    r.removeListener("data", n), e.removeListener("drain", o), r.removeListener("end", a), r.removeListener("close", l), r.removeListener("error", u), e.removeListener("error", u), r.removeListener("end", f), r.removeListener("close", f), e.removeListener("close", f);
  }
  return r.on("end", f), r.on("close", f), e.on("close", f), e.emit("pipe", r), e;
};
function kS(e, t, r) {
  if (typeof e.prependListener == "function")
    return e.prependListener(t, r);
  !e._events || !e._events[t] ? e.on(t, r) : ple(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
}
var qx = {
  Stream: lg,
  prependListener: kS
}, s8 = { exports: {} };
(function(e) {
  const { SymbolDispose: t } = qt, { AbortError: r, codes: n } = an, { isNodeStream: o, isWebStream: s, kControllerErrorFunction: a } = To, l = _s, { ERR_INVALID_ARG_TYPE: u } = n;
  let f;
  const c = (d, h) => {
    if (typeof d != "object" || !("aborted" in d))
      throw new u(h, "AbortSignal", d);
  };
  e.exports.addAbortSignal = function(h, p) {
    if (c(h, "signal"), !o(p) && !s(p))
      throw new u("stream", ["ReadableStream", "WritableStream", "Stream"], p);
    return e.exports.addAbortSignalNoValidate(h, p);
  }, e.exports.addAbortSignalNoValidate = function(d, h) {
    if (typeof d != "object" || !("aborted" in d))
      return h;
    const p = o(h) ? () => {
      h.destroy(
        new r(void 0, {
          cause: d.reason
        })
      );
    } : () => {
      h[a](
        new r(void 0, {
          cause: d.reason
        })
      );
    };
    if (d.aborted)
      p();
    else {
      f = f || Gr.addAbortListener;
      const m = f(d, p);
      l(h, m[t]);
    }
    return h;
  };
})(s8);
var ug = s8.exports;
const { StringPrototypeSlice: Fk, SymbolIterator: gle, TypedArrayPrototypeSet: cd, Uint8Array: ble } = qt, { Buffer: Wy } = ut, { inspect: yle } = Gr;
var mle = class {
  constructor() {
    this.head = null, this.tail = null, this.length = 0;
  }
  push(t) {
    const r = {
      data: t,
      next: null
    };
    this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
  }
  unshift(t) {
    const r = {
      data: t,
      next: this.head
    };
    this.length === 0 && (this.tail = r), this.head = r, ++this.length;
  }
  shift() {
    if (this.length === 0)
      return;
    const t = this.head.data;
    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
  }
  clear() {
    this.head = this.tail = null, this.length = 0;
  }
  join(t) {
    if (this.length === 0)
      return "";
    let r = this.head, n = "" + r.data;
    for (; (r = r.next) !== null; )
      n += t + r.data;
    return n;
  }
  concat(t) {
    if (this.length === 0)
      return Wy.alloc(0);
    const r = Wy.allocUnsafe(t >>> 0);
    let n = this.head, o = 0;
    for (; n; )
      cd(r, n.data, o), o += n.data.length, n = n.next;
    return r;
  }
  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(t, r) {
    const n = this.head.data;
    if (t < n.length) {
      const o = n.slice(0, t);
      return this.head.data = n.slice(t), o;
    }
    return t === n.length ? this.shift() : r ? this._getString(t) : this._getBuffer(t);
  }
  first() {
    return this.head.data;
  }
  *[gle]() {
    for (let t = this.head; t; t = t.next)
      yield t.data;
  }
  // Consumes a specified amount of characters from the buffered data.
  _getString(t) {
    let r = "", n = this.head, o = 0;
    do {
      const s = n.data;
      if (t > s.length)
        r += s, t -= s.length;
      else {
        t === s.length ? (r += s, ++o, n.next ? this.head = n.next : this.head = this.tail = null) : (r += Fk(s, 0, t), this.head = n, n.data = Fk(s, t));
        break;
      }
      ++o;
    } while ((n = n.next) !== null);
    return this.length -= o, r;
  }
  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(t) {
    const r = Wy.allocUnsafe(t), n = t;
    let o = this.head, s = 0;
    do {
      const a = o.data;
      if (t > a.length)
        cd(r, a, n - t), t -= a.length;
      else {
        t === a.length ? (cd(r, a, n - t), ++s, o.next ? this.head = o.next : this.head = this.tail = null) : (cd(r, new ble(a.buffer, a.byteOffset, t), n - t), this.head = o, o.data = a.slice(t));
        break;
      }
      ++s;
    } while ((o = o.next) !== null);
    return this.length -= s, r;
  }
  // Make sure the linked list only shows the minimal necessary information.
  [Symbol.for("nodejs.util.inspect.custom")](t, r) {
    return yle(this, {
      ...r,
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: !1
    });
  }
};
const { MathFloor: vle, NumberIsInteger: wle } = qt, { validateInteger: _le } = _c, { ERR_INVALID_ARG_VALUE: Sle } = an.codes;
let a8 = 16 * 1024, l8 = 16;
function Ele(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function u8(e) {
  return e ? l8 : a8;
}
function xle(e, t) {
  _le(t, "value", 0), e ? l8 = t : a8 = t;
}
function Rle(e, t, r, n) {
  const o = Ele(t, n, r);
  if (o != null) {
    if (!wle(o) || o < 0) {
      const s = n ? `options.${r}` : "options.highWaterMark";
      throw new Sle(s, o);
    }
    return vle(o);
  }
  return u8(e.objectMode);
}
var fg = {
  getHighWaterMark: Rle,
  getDefaultHighWaterMark: u8,
  setDefaultHighWaterMark: xle
};
const jk = _t, { PromisePrototypeThen: Ale, SymbolAsyncIterator: Bk, SymbolIterator: qk } = qt, { Buffer: Tle } = ut, { ERR_INVALID_ARG_TYPE: $le, ERR_STREAM_NULL_VALUES: Cle } = an.codes;
function kle(e, t, r) {
  let n;
  if (typeof t == "string" || t instanceof Tle)
    return new e({
      objectMode: !0,
      ...r,
      read() {
        this.push(t), this.push(null);
      }
    });
  let o;
  if (t && t[Bk])
    o = !0, n = t[Bk]();
  else if (t && t[qk])
    o = !1, n = t[qk]();
  else
    throw new $le("iterable", ["Iterable"], t);
  const s = new e({
    objectMode: !0,
    highWaterMark: 1,
    // TODO(ronag): What options should be allowed?
    ...r
  });
  let a = !1;
  s._read = function() {
    a || (a = !0, u());
  }, s._destroy = function(f, c) {
    Ale(
      l(f),
      () => jk.nextTick(c, f),
      // nextTick is here in case cb throws
      (d) => jk.nextTick(c, d || f)
    );
  };
  async function l(f) {
    const c = f != null, d = typeof n.throw == "function";
    if (c && d) {
      const { value: h, done: p } = await n.throw(f);
      if (await h, p)
        return;
    }
    if (typeof n.return == "function") {
      const { value: h } = await n.return();
      await h;
    }
  }
  async function u() {
    for (; ; ) {
      try {
        const { value: f, done: c } = o ? await n.next() : n.next();
        if (c)
          s.push(null);
        else {
          const d = f && typeof f.then == "function" ? await f : f;
          if (d === null)
            throw a = !1, new Cle();
          if (s.push(d))
            continue;
          a = !1;
        }
      } catch (f) {
        s.destroy(f);
      }
      break;
    }
  }
  return s;
}
var f8 = kle, Uy, Wk;
function cg() {
  if (Wk)
    return Uy;
  Wk = 1;
  const e = _t, {
    ArrayPrototypeIndexOf: t,
    NumberIsInteger: r,
    NumberIsNaN: n,
    NumberParseInt: o,
    ObjectDefineProperties: s,
    ObjectKeys: a,
    ObjectSetPrototypeOf: l,
    Promise: u,
    SafeSet: f,
    SymbolAsyncDispose: c,
    SymbolAsyncIterator: d,
    Symbol: h
  } = qt;
  Uy = B, B.ReadableState = ye;
  const { EventEmitter: p } = ur, { Stream: m, prependListener: y } = qx, { Buffer: _ } = ut, { addAbortSignal: S } = ug, x = _s;
  let E = Gr.debuglog("stream", (g) => {
    E = g;
  });
  const C = mle, I = mu, { getHighWaterMark: j, getDefaultHighWaterMark: J } = fg, {
    aggregateTwoErrors: G,
    codes: {
      ERR_INVALID_ARG_TYPE: $,
      ERR_METHOD_NOT_IMPLEMENTED: V,
      ERR_OUT_OF_RANGE: M,
      ERR_STREAM_PUSH_AFTER_EOF: W,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT: k
    },
    AbortError: U
  } = an, { validateObject: Z } = _c, Y = h("kPaused"), { StringDecoder: te } = Hl(), se = f8;
  l(B.prototype, m.prototype), l(B, m);
  const fe = () => {
  }, { errorOrDestroy: he } = I, ae = 1, be = 2, H = 4, pe = 8, ke = 16, le = 32, ee = 64, ge = 128, Ae = 256, Oe = 512, K = 1024, z = 2048, b = 4096, w = 8192, T = 16384, O = 32768, L = 65536, ne = 1 << 17, ue = 1 << 18;
  function oe(g) {
    return {
      enumerable: !1,
      get() {
        return (this.state & g) !== 0;
      },
      set(v) {
        v ? this.state |= g : this.state &= ~g;
      }
    };
  }
  s(ye.prototype, {
    objectMode: oe(ae),
    ended: oe(be),
    endEmitted: oe(H),
    reading: oe(pe),
    // Stream is still being constructed and cannot be
    // destroyed until construction finished or failed.
    // Async construction is opt in, therefore we start as
    // constructed.
    constructed: oe(ke),
    // A flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    sync: oe(le),
    // Whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    needReadable: oe(ee),
    emittedReadable: oe(ge),
    readableListening: oe(Ae),
    resumeScheduled: oe(Oe),
    // True if the error was already emitted and should not be thrown again.
    errorEmitted: oe(K),
    emitClose: oe(z),
    autoDestroy: oe(b),
    // Has it been destroyed.
    destroyed: oe(w),
    // Indicates whether the stream has finished destroying.
    closed: oe(T),
    // True if close has been emitted or would have been emitted
    // depending on emitClose.
    closeEmitted: oe(O),
    multiAwaitDrain: oe(L),
    // If true, a maybeReadMore has been scheduled.
    readingMore: oe(ne),
    dataEmitted: oe(ue)
  });
  function ye(g, v, F) {
    typeof F != "boolean" && (F = v instanceof ho()), this.state = z | b | ke | le, g && g.objectMode && (this.state |= ae), F && g && g.readableObjectMode && (this.state |= ae), this.highWaterMark = g ? j(this, g, "readableHighWaterMark", F) : J(!1), this.buffer = new C(), this.length = 0, this.pipes = [], this.flowing = null, this[Y] = null, g && g.emitClose === !1 && (this.state &= ~z), g && g.autoDestroy === !1 && (this.state &= ~b), this.errored = null, this.defaultEncoding = g && g.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, g && g.encoding && (this.decoder = new te(g.encoding), this.encoding = g.encoding);
  }
  function B(g) {
    if (!(this instanceof B))
      return new B(g);
    const v = this instanceof ho();
    this._readableState = new ye(g, this, v), g && (typeof g.read == "function" && (this._read = g.read), typeof g.destroy == "function" && (this._destroy = g.destroy), typeof g.construct == "function" && (this._construct = g.construct), g.signal && !v && S(g.signal, this)), m.call(this, g), I.construct(this, () => {
      this._readableState.needReadable && re(this, this._readableState);
    });
  }
  B.prototype.destroy = I.destroy, B.prototype._undestroy = I.undestroy, B.prototype._destroy = function(g, v) {
    v(g);
  }, B.prototype[p.captureRejectionSymbol] = function(g) {
    this.destroy(g);
  }, B.prototype[c] = function() {
    let g;
    return this.destroyed || (g = this.readableEnded ? null : new U(), this.destroy(g)), new u((v, F) => x(this, (D) => D && D !== g ? F(D) : v(null)));
  }, B.prototype.push = function(g, v) {
    return me(this, g, v, !1);
  }, B.prototype.unshift = function(g, v) {
    return me(this, g, v, !0);
  };
  function me(g, v, F, D) {
    E("readableAddChunk", v);
    const X = g._readableState;
    let Le;
    if (X.state & ae || (typeof v == "string" ? (F = F || X.defaultEncoding, X.encoding !== F && (D && X.encoding ? v = _.from(v, F).toString(X.encoding) : (v = _.from(v, F), F = ""))) : v instanceof _ ? F = "" : m._isUint8Array(v) ? (v = m._uint8ArrayToBuffer(v), F = "") : v != null && (Le = new $("chunk", ["string", "Buffer", "Uint8Array"], v))), Le)
      he(g, Le);
    else if (v === null)
      X.state &= ~pe, R(g, X);
    else if (X.state & ae || v && v.length > 0)
      if (D)
        if (X.state & H)
          he(g, new k());
        else {
          if (X.destroyed || X.errored)
            return !1;
          Ce(g, X, v, !0);
        }
      else if (X.ended)
        he(g, new W());
      else {
        if (X.destroyed || X.errored)
          return !1;
        X.state &= ~pe, X.decoder && !F ? (v = X.decoder.write(v), X.objectMode || v.length !== 0 ? Ce(g, X, v, !1) : re(g, X)) : Ce(g, X, v, !1);
      }
    else
      D || (X.state &= ~pe, re(g, X));
    return !X.ended && (X.length < X.highWaterMark || X.length === 0);
  }
  function Ce(g, v, F, D) {
    v.flowing && v.length === 0 && !v.sync && g.listenerCount("data") > 0 ? (v.state & L ? v.awaitDrainWriters.clear() : v.awaitDrainWriters = null, v.dataEmitted = !0, g.emit("data", F)) : (v.length += v.objectMode ? 1 : F.length, D ? v.buffer.unshift(F) : v.buffer.push(F), v.state & ee && A(g)), re(g, v);
  }
  B.prototype.isPaused = function() {
    const g = this._readableState;
    return g[Y] === !0 || g.flowing === !1;
  }, B.prototype.setEncoding = function(g) {
    const v = new te(g);
    this._readableState.decoder = v, this._readableState.encoding = this._readableState.decoder.encoding;
    const F = this._readableState.buffer;
    let D = "";
    for (const X of F)
      D += v.write(X);
    return F.clear(), D !== "" && F.push(D), this._readableState.length = D.length, this;
  };
  const Ie = 1073741824;
  function Me(g) {
    if (g > Ie)
      throw new M("size", "<= 1GiB", g);
    return g--, g |= g >>> 1, g |= g >>> 2, g |= g >>> 4, g |= g >>> 8, g |= g >>> 16, g++, g;
  }
  function N(g, v) {
    return g <= 0 || v.length === 0 && v.ended ? 0 : v.state & ae ? 1 : n(g) ? v.flowing && v.length ? v.buffer.first().length : v.length : g <= v.length ? g : v.ended ? v.length : 0;
  }
  B.prototype.read = function(g) {
    E("read", g), g === void 0 ? g = NaN : r(g) || (g = o(g, 10));
    const v = this._readableState, F = g;
    if (g > v.highWaterMark && (v.highWaterMark = Me(g)), g !== 0 && (v.state &= ~ge), g === 0 && v.needReadable && ((v.highWaterMark !== 0 ? v.length >= v.highWaterMark : v.length > 0) || v.ended))
      return E("read: emitReadable", v.length, v.ended), v.length === 0 && v.ended ? At(this) : A(this), null;
    if (g = N(g, v), g === 0 && v.ended)
      return v.length === 0 && At(this), null;
    let D = (v.state & ee) !== 0;
    if (E("need readable", D), (v.length === 0 || v.length - g < v.highWaterMark) && (D = !0, E("length less than watermark", D)), v.ended || v.reading || v.destroyed || v.errored || !v.constructed)
      D = !1, E("reading, ended or constructing", D);
    else if (D) {
      E("do read"), v.state |= pe | le, v.length === 0 && (v.state |= ee);
      try {
        this._read(v.highWaterMark);
      } catch (Le) {
        he(this, Le);
      }
      v.state &= ~le, v.reading || (g = N(F, v));
    }
    let X;
    return g > 0 ? X = Lr(g, v) : X = null, X === null ? (v.needReadable = v.length <= v.highWaterMark, g = 0) : (v.length -= g, v.multiAwaitDrain ? v.awaitDrainWriters.clear() : v.awaitDrainWriters = null), v.length === 0 && (v.ended || (v.needReadable = !0), F !== g && v.ended && At(this)), X !== null && !v.errorEmitted && !v.closeEmitted && (v.dataEmitted = !0, this.emit("data", X)), X;
  };
  function R(g, v) {
    if (E("onEofChunk"), !v.ended) {
      if (v.decoder) {
        const F = v.decoder.end();
        F && F.length && (v.buffer.push(F), v.length += v.objectMode ? 1 : F.length);
      }
      v.ended = !0, v.sync ? A(g) : (v.needReadable = !1, v.emittedReadable = !0, q(g));
    }
  }
  function A(g) {
    const v = g._readableState;
    E("emitReadable", v.needReadable, v.emittedReadable), v.needReadable = !1, v.emittedReadable || (E("emitReadable", v.flowing), v.emittedReadable = !0, e.nextTick(q, g));
  }
  function q(g) {
    const v = g._readableState;
    E("emitReadable_", v.destroyed, v.length, v.ended), !v.destroyed && !v.errored && (v.length || v.ended) && (g.emit("readable"), v.emittedReadable = !1), v.needReadable = !v.flowing && !v.ended && v.length <= v.highWaterMark, Ze(g);
  }
  function re(g, v) {
    !v.readingMore && v.constructed && (v.readingMore = !0, e.nextTick(ce, g, v));
  }
  function ce(g, v) {
    for (; !v.reading && !v.ended && (v.length < v.highWaterMark || v.flowing && v.length === 0); ) {
      const F = v.length;
      if (E("maybeReadMore read 0"), g.read(0), F === v.length)
        break;
    }
    v.readingMore = !1;
  }
  B.prototype._read = function(g) {
    throw new V("_read()");
  }, B.prototype.pipe = function(g, v) {
    const F = this, D = this._readableState;
    D.pipes.length === 1 && (D.multiAwaitDrain || (D.multiAwaitDrain = !0, D.awaitDrainWriters = new f(D.awaitDrainWriters ? [D.awaitDrainWriters] : []))), D.pipes.push(g), E("pipe count=%d opts=%j", D.pipes.length, v);
    const Le = (!v || v.end !== !1) && g !== e.stdout && g !== e.stderr ? Xt : St;
    D.endEmitted ? e.nextTick(Le) : F.once("end", Le), g.on("unpipe", We);
    function We(ft, rt) {
      E("onunpipe"), ft === F && rt && rt.hasUnpiped === !1 && (rt.hasUnpiped = !0, yn());
    }
    function Xt() {
      E("onend"), g.end();
    }
    let dt, Kr = !1;
    function yn() {
      E("cleanup"), g.removeListener("close", or), g.removeListener("finish", dr), dt && g.removeListener("drain", dt), g.removeListener("error", cr), g.removeListener("unpipe", We), F.removeListener("end", Xt), F.removeListener("end", St), F.removeListener("data", xr), Kr = !0, dt && D.awaitDrainWriters && (!g._writableState || g._writableState.needDrain) && dt();
    }
    function Wt() {
      Kr || (D.pipes.length === 1 && D.pipes[0] === g ? (E("false write response, pause", 0), D.awaitDrainWriters = g, D.multiAwaitDrain = !1) : D.pipes.length > 1 && D.pipes.includes(g) && (E("false write response, pause", D.awaitDrainWriters.size), D.awaitDrainWriters.add(g)), F.pause()), dt || (dt = de(F, g), g.on("drain", dt));
    }
    F.on("data", xr);
    function xr(ft) {
      E("ondata");
      const rt = g.write(ft);
      E("dest.write", rt), rt === !1 && Wt();
    }
    function cr(ft) {
      if (E("onerror", ft), St(), g.removeListener("error", cr), g.listenerCount("error") === 0) {
        const rt = g._writableState || g._readableState;
        rt && !rt.errorEmitted ? he(g, ft) : g.emit("error", ft);
      }
    }
    y(g, "error", cr);
    function or() {
      g.removeListener("finish", dr), St();
    }
    g.once("close", or);
    function dr() {
      E("onfinish"), g.removeListener("close", or), St();
    }
    g.once("finish", dr);
    function St() {
      E("unpipe"), F.unpipe(g);
    }
    return g.emit("pipe", F), g.writableNeedDrain === !0 ? Wt() : D.flowing || (E("pipe resume"), F.resume()), g;
  };
  function de(g, v) {
    return function() {
      const D = g._readableState;
      D.awaitDrainWriters === v ? (E("pipeOnDrain", 1), D.awaitDrainWriters = null) : D.multiAwaitDrain && (E("pipeOnDrain", D.awaitDrainWriters.size), D.awaitDrainWriters.delete(v)), (!D.awaitDrainWriters || D.awaitDrainWriters.size === 0) && g.listenerCount("data") && g.resume();
    };
  }
  B.prototype.unpipe = function(g) {
    const v = this._readableState, F = {
      hasUnpiped: !1
    };
    if (v.pipes.length === 0)
      return this;
    if (!g) {
      const X = v.pipes;
      v.pipes = [], this.pause();
      for (let Le = 0; Le < X.length; Le++)
        X[Le].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    const D = t(v.pipes, g);
    return D === -1 ? this : (v.pipes.splice(D, 1), v.pipes.length === 0 && this.pause(), g.emit("unpipe", this, F), this);
  }, B.prototype.on = function(g, v) {
    const F = m.prototype.on.call(this, g, v), D = this._readableState;
    return g === "data" ? (D.readableListening = this.listenerCount("readable") > 0, D.flowing !== !1 && this.resume()) : g === "readable" && !D.endEmitted && !D.readableListening && (D.readableListening = D.needReadable = !0, D.flowing = !1, D.emittedReadable = !1, E("on readable", D.length, D.reading), D.length ? A(this) : D.reading || e.nextTick(it, this)), F;
  }, B.prototype.addListener = B.prototype.on, B.prototype.removeListener = function(g, v) {
    const F = m.prototype.removeListener.call(this, g, v);
    return g === "readable" && e.nextTick(De, this), F;
  }, B.prototype.off = B.prototype.removeListener, B.prototype.removeAllListeners = function(g) {
    const v = m.prototype.removeAllListeners.apply(this, arguments);
    return (g === "readable" || g === void 0) && e.nextTick(De, this), v;
  };
  function De(g) {
    const v = g._readableState;
    v.readableListening = g.listenerCount("readable") > 0, v.resumeScheduled && v[Y] === !1 ? v.flowing = !0 : g.listenerCount("data") > 0 ? g.resume() : v.readableListening || (v.flowing = null);
  }
  function it(g) {
    E("readable nexttick read 0"), g.read(0);
  }
  B.prototype.resume = function() {
    const g = this._readableState;
    return g.flowing || (E("resume"), g.flowing = !g.readableListening, ze(this, g)), g[Y] = !1, this;
  };
  function ze(g, v) {
    v.resumeScheduled || (v.resumeScheduled = !0, e.nextTick(Ve, g, v));
  }
  function Ve(g, v) {
    E("resume", v.reading), v.reading || g.read(0), v.resumeScheduled = !1, g.emit("resume"), Ze(g), v.flowing && !v.reading && g.read(0);
  }
  B.prototype.pause = function() {
    return E("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (E("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState[Y] = !0, this;
  };
  function Ze(g) {
    const v = g._readableState;
    for (E("flow", v.flowing); v.flowing && g.read() !== null; )
      ;
  }
  B.prototype.wrap = function(g) {
    let v = !1;
    g.on("data", (D) => {
      !this.push(D) && g.pause && (v = !0, g.pause());
    }), g.on("end", () => {
      this.push(null);
    }), g.on("error", (D) => {
      he(this, D);
    }), g.on("close", () => {
      this.destroy();
    }), g.on("destroy", () => {
      this.destroy();
    }), this._read = () => {
      v && g.resume && (v = !1, g.resume());
    };
    const F = a(g);
    for (let D = 1; D < F.length; D++) {
      const X = F[D];
      this[X] === void 0 && typeof g[X] == "function" && (this[X] = g[X].bind(g));
    }
    return this;
  }, B.prototype[d] = function() {
    return Er(this);
  }, B.prototype.iterator = function(g) {
    return g !== void 0 && Z(g, "options"), Er(this, g);
  };
  function Er(g, v) {
    typeof g.read != "function" && (g = B.wrap(g, {
      objectMode: !0
    }));
    const F = Wi(g, v);
    return F.stream = g, F;
  }
  async function* Wi(g, v) {
    let F = fe;
    function D(We) {
      this === g ? (F(), F = fe) : F = We;
    }
    g.on("readable", D);
    let X;
    const Le = x(
      g,
      {
        writable: !1
      },
      (We) => {
        X = We ? G(X, We) : null, F(), F = fe;
      }
    );
    try {
      for (; ; ) {
        const We = g.destroyed ? null : g.read();
        if (We !== null)
          yield We;
        else {
          if (X)
            throw X;
          if (X === null)
            return;
          await new u(D);
        }
      }
    } catch (We) {
      throw X = G(X, We), X;
    } finally {
      (X || (v == null ? void 0 : v.destroyOnReturn) !== !1) && (X === void 0 || g._readableState.autoDestroy) ? I.destroyer(g, null) : (g.off("readable", D), Le());
    }
  }
  s(B.prototype, {
    readable: {
      __proto__: null,
      get() {
        const g = this._readableState;
        return !!g && g.readable !== !1 && !g.destroyed && !g.errorEmitted && !g.endEmitted;
      },
      set(g) {
        this._readableState && (this._readableState.readable = !!g);
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(g) {
        this._readableState && (this._readableState.flowing = g);
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.objectMode : !1;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.destroyed : !1;
      },
      set(g) {
        this._readableState && (this._readableState.destroyed = g);
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.endEmitted : !1;
      }
    }
  }), s(ye.prototype, {
    // Legacy getter for `pipesCount`.
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    // Legacy property for `paused`.
    paused: {
      __proto__: null,
      get() {
        return this[Y] !== !1;
      },
      set(g) {
        this[Y] = !!g;
      }
    }
  }), B._fromList = Lr;
  function Lr(g, v) {
    if (v.length === 0)
      return null;
    let F;
    return v.objectMode ? F = v.buffer.shift() : !g || g >= v.length ? (v.decoder ? F = v.buffer.join("") : v.buffer.length === 1 ? F = v.buffer.first() : F = v.buffer.concat(v.length), v.buffer.clear()) : F = v.buffer.consume(g, v.decoder), F;
  }
  function At(g) {
    const v = g._readableState;
    E("endReadable", v.endEmitted), v.endEmitted || (v.ended = !0, e.nextTick(si, v, g));
  }
  function si(g, v) {
    if (E("endReadableNT", g.endEmitted, g.length), !g.errored && !g.closeEmitted && !g.endEmitted && g.length === 0) {
      if (g.endEmitted = !0, v.emit("end"), v.writable && v.allowHalfOpen === !1)
        e.nextTick(Ui, v);
      else if (g.autoDestroy) {
        const F = v._writableState;
        (!F || F.autoDestroy && // We don't expect the writable to ever 'finish'
        // if writable is explicitly set to false.
        (F.finished || F.writable === !1)) && v.destroy();
      }
    }
  }
  function Ui(g) {
    g.writable && !g.writableEnded && !g.destroyed && g.end();
  }
  B.from = function(g, v) {
    return se(B, g, v);
  };
  let Nt;
  function ln() {
    return Nt === void 0 && (Nt = {}), Nt;
  }
  return B.fromWeb = function(g, v) {
    return ln().newStreamReadableFromReadableStream(g, v);
  }, B.toWeb = function(g, v) {
    return ln().newReadableStreamFromStreamReadable(g, v);
  }, B.wrap = function(g, v) {
    var F, D;
    return new B({
      objectMode: (F = (D = g.readableObjectMode) !== null && D !== void 0 ? D : g.objectMode) !== null && F !== void 0 ? F : !0,
      ...v,
      destroy(X, Le) {
        I.destroyer(g, X), Le(X);
      }
    }).wrap(g);
  }, Uy;
}
var Hy, Uk;
function Wx() {
  if (Uk)
    return Hy;
  Uk = 1;
  const e = _t, {
    ArrayPrototypeSlice: t,
    Error: r,
    FunctionPrototypeSymbolHasInstance: n,
    ObjectDefineProperty: o,
    ObjectDefineProperties: s,
    ObjectSetPrototypeOf: a,
    StringPrototypeToLowerCase: l,
    Symbol: u,
    SymbolHasInstance: f
  } = qt;
  Hy = Z, Z.WritableState = k;
  const { EventEmitter: c } = ur, d = qx.Stream, { Buffer: h } = ut, p = mu, { addAbortSignal: m } = ug, { getHighWaterMark: y, getDefaultHighWaterMark: _ } = fg, {
    ERR_INVALID_ARG_TYPE: S,
    ERR_METHOD_NOT_IMPLEMENTED: x,
    ERR_MULTIPLE_CALLBACK: E,
    ERR_STREAM_CANNOT_PIPE: C,
    ERR_STREAM_DESTROYED: I,
    ERR_STREAM_ALREADY_FINISHED: j,
    ERR_STREAM_NULL_VALUES: J,
    ERR_STREAM_WRITE_AFTER_END: G,
    ERR_UNKNOWN_ENCODING: $
  } = an.codes, { errorOrDestroy: V } = p;
  a(Z.prototype, d.prototype), a(Z, d);
  function M() {
  }
  const W = u("kOnFinished");
  function k(b, w, T) {
    typeof T != "boolean" && (T = w instanceof ho()), this.objectMode = !!(b && b.objectMode), T && (this.objectMode = this.objectMode || !!(b && b.writableObjectMode)), this.highWaterMark = b ? y(this, b, "writableHighWaterMark", T) : _(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    const O = !!(b && b.decodeStrings === !1);
    this.decodeStrings = !O, this.defaultEncoding = b && b.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = he.bind(void 0, w), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, U(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !b || b.emitClose !== !1, this.autoDestroy = !b || b.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[W] = [];
  }
  function U(b) {
    b.buffered = [], b.bufferedIndex = 0, b.allBuffers = !0, b.allNoop = !0;
  }
  k.prototype.getBuffer = function() {
    return t(this.buffered, this.bufferedIndex);
  }, o(k.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function Z(b) {
    const w = this instanceof ho();
    if (!w && !n(Z, this))
      return new Z(b);
    this._writableState = new k(b, this, w), b && (typeof b.write == "function" && (this._write = b.write), typeof b.writev == "function" && (this._writev = b.writev), typeof b.destroy == "function" && (this._destroy = b.destroy), typeof b.final == "function" && (this._final = b.final), typeof b.construct == "function" && (this._construct = b.construct), b.signal && m(b.signal, this)), d.call(this, b), p.construct(this, () => {
      const T = this._writableState;
      T.writing || pe(this, T), ge(this, T);
    });
  }
  o(Z, f, {
    __proto__: null,
    value: function(b) {
      return n(this, b) ? !0 : this !== Z ? !1 : b && b._writableState instanceof k;
    }
  }), Z.prototype.pipe = function() {
    V(this, new C());
  };
  function Y(b, w, T, O) {
    const L = b._writableState;
    if (typeof T == "function")
      O = T, T = L.defaultEncoding;
    else {
      if (!T)
        T = L.defaultEncoding;
      else if (T !== "buffer" && !h.isEncoding(T))
        throw new $(T);
      typeof O != "function" && (O = M);
    }
    if (w === null)
      throw new J();
    if (!L.objectMode)
      if (typeof w == "string")
        L.decodeStrings !== !1 && (w = h.from(w, T), T = "buffer");
      else if (w instanceof h)
        T = "buffer";
      else if (d._isUint8Array(w))
        w = d._uint8ArrayToBuffer(w), T = "buffer";
      else
        throw new S("chunk", ["string", "Buffer", "Uint8Array"], w);
    let ne;
    return L.ending ? ne = new G() : L.destroyed && (ne = new I("write")), ne ? (e.nextTick(O, ne), V(b, ne, !0), ne) : (L.pendingcb++, te(b, L, w, T, O));
  }
  Z.prototype.write = function(b, w, T) {
    return Y(this, b, w, T) === !0;
  }, Z.prototype.cork = function() {
    this._writableState.corked++;
  }, Z.prototype.uncork = function() {
    const b = this._writableState;
    b.corked && (b.corked--, b.writing || pe(this, b));
  }, Z.prototype.setDefaultEncoding = function(w) {
    if (typeof w == "string" && (w = l(w)), !h.isEncoding(w))
      throw new $(w);
    return this._writableState.defaultEncoding = w, this;
  };
  function te(b, w, T, O, L) {
    const ne = w.objectMode ? 1 : T.length;
    w.length += ne;
    const ue = w.length < w.highWaterMark;
    return ue || (w.needDrain = !0), w.writing || w.corked || w.errored || !w.constructed ? (w.buffered.push({
      chunk: T,
      encoding: O,
      callback: L
    }), w.allBuffers && O !== "buffer" && (w.allBuffers = !1), w.allNoop && L !== M && (w.allNoop = !1)) : (w.writelen = ne, w.writecb = L, w.writing = !0, w.sync = !0, b._write(T, O, w.onwrite), w.sync = !1), ue && !w.errored && !w.destroyed;
  }
  function se(b, w, T, O, L, ne, ue) {
    w.writelen = O, w.writecb = ue, w.writing = !0, w.sync = !0, w.destroyed ? w.onwrite(new I("write")) : T ? b._writev(L, w.onwrite) : b._write(L, ne, w.onwrite), w.sync = !1;
  }
  function fe(b, w, T, O) {
    --w.pendingcb, O(T), H(w), V(b, T);
  }
  function he(b, w) {
    const T = b._writableState, O = T.sync, L = T.writecb;
    if (typeof L != "function") {
      V(b, new E());
      return;
    }
    T.writing = !1, T.writecb = null, T.length -= T.writelen, T.writelen = 0, w ? (w.stack, T.errored || (T.errored = w), b._readableState && !b._readableState.errored && (b._readableState.errored = w), O ? e.nextTick(fe, b, T, w, L) : fe(b, T, w, L)) : (T.buffered.length > T.bufferedIndex && pe(b, T), O ? T.afterWriteTickInfo !== null && T.afterWriteTickInfo.cb === L ? T.afterWriteTickInfo.count++ : (T.afterWriteTickInfo = {
      count: 1,
      cb: L,
      stream: b,
      state: T
    }, e.nextTick(ae, T.afterWriteTickInfo)) : be(b, T, 1, L));
  }
  function ae({ stream: b, state: w, count: T, cb: O }) {
    return w.afterWriteTickInfo = null, be(b, w, T, O);
  }
  function be(b, w, T, O) {
    for (!w.ending && !b.destroyed && w.length === 0 && w.needDrain && (w.needDrain = !1, b.emit("drain")); T-- > 0; )
      w.pendingcb--, O();
    w.destroyed && H(w), ge(b, w);
  }
  function H(b) {
    if (b.writing)
      return;
    for (let L = b.bufferedIndex; L < b.buffered.length; ++L) {
      var w;
      const { chunk: ne, callback: ue } = b.buffered[L], oe = b.objectMode ? 1 : ne.length;
      b.length -= oe, ue(
        (w = b.errored) !== null && w !== void 0 ? w : new I("write")
      );
    }
    const T = b[W].splice(0);
    for (let L = 0; L < T.length; L++) {
      var O;
      T[L](
        (O = b.errored) !== null && O !== void 0 ? O : new I("end")
      );
    }
    U(b);
  }
  function pe(b, w) {
    if (w.corked || w.bufferProcessing || w.destroyed || !w.constructed)
      return;
    const { buffered: T, bufferedIndex: O, objectMode: L } = w, ne = T.length - O;
    if (!ne)
      return;
    let ue = O;
    if (w.bufferProcessing = !0, ne > 1 && b._writev) {
      w.pendingcb -= ne - 1;
      const oe = w.allNoop ? M : (B) => {
        for (let me = ue; me < T.length; ++me)
          T[me].callback(B);
      }, ye = w.allNoop && ue === 0 ? T : t(T, ue);
      ye.allBuffers = w.allBuffers, se(b, w, !0, w.length, ye, "", oe), U(w);
    } else {
      do {
        const { chunk: oe, encoding: ye, callback: B } = T[ue];
        T[ue++] = null;
        const me = L ? 1 : oe.length;
        se(b, w, !1, me, oe, ye, B);
      } while (ue < T.length && !w.writing);
      ue === T.length ? U(w) : ue > 256 ? (T.splice(0, ue), w.bufferedIndex = 0) : w.bufferedIndex = ue;
    }
    w.bufferProcessing = !1;
  }
  Z.prototype._write = function(b, w, T) {
    if (this._writev)
      this._writev(
        [
          {
            chunk: b,
            encoding: w
          }
        ],
        T
      );
    else
      throw new x("_write()");
  }, Z.prototype._writev = null, Z.prototype.end = function(b, w, T) {
    const O = this._writableState;
    typeof b == "function" ? (T = b, b = null, w = null) : typeof w == "function" && (T = w, w = null);
    let L;
    if (b != null) {
      const ne = Y(this, b, w);
      ne instanceof r && (L = ne);
    }
    return O.corked && (O.corked = 1, this.uncork()), L || (!O.errored && !O.ending ? (O.ending = !0, ge(this, O, !0), O.ended = !0) : O.finished ? L = new j("end") : O.destroyed && (L = new I("end"))), typeof T == "function" && (L || O.finished ? e.nextTick(T, L) : O[W].push(T)), this;
  };
  function ke(b) {
    return b.ending && !b.destroyed && b.constructed && b.length === 0 && !b.errored && b.buffered.length === 0 && !b.finished && !b.writing && !b.errorEmitted && !b.closeEmitted;
  }
  function le(b, w) {
    let T = !1;
    function O(L) {
      if (T) {
        V(b, L ?? E());
        return;
      }
      if (T = !0, w.pendingcb--, L) {
        const ne = w[W].splice(0);
        for (let ue = 0; ue < ne.length; ue++)
          ne[ue](L);
        V(b, L, w.sync);
      } else
        ke(w) && (w.prefinished = !0, b.emit("prefinish"), w.pendingcb++, e.nextTick(Ae, b, w));
    }
    w.sync = !0, w.pendingcb++;
    try {
      b._final(O);
    } catch (L) {
      O(L);
    }
    w.sync = !1;
  }
  function ee(b, w) {
    !w.prefinished && !w.finalCalled && (typeof b._final == "function" && !w.destroyed ? (w.finalCalled = !0, le(b, w)) : (w.prefinished = !0, b.emit("prefinish")));
  }
  function ge(b, w, T) {
    ke(w) && (ee(b, w), w.pendingcb === 0 && (T ? (w.pendingcb++, e.nextTick(
      (O, L) => {
        ke(L) ? Ae(O, L) : L.pendingcb--;
      },
      b,
      w
    )) : ke(w) && (w.pendingcb++, Ae(b, w))));
  }
  function Ae(b, w) {
    w.pendingcb--, w.finished = !0;
    const T = w[W].splice(0);
    for (let O = 0; O < T.length; O++)
      T[O]();
    if (b.emit("finish"), w.autoDestroy) {
      const O = b._readableState;
      (!O || O.autoDestroy && // We don't expect the readable to ever 'end'
      // if readable is explicitly set to false.
      (O.endEmitted || O.readable === !1)) && b.destroy();
    }
  }
  s(Z.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : !1;
      },
      set(b) {
        this._writableState && (this._writableState.destroyed = b);
      }
    },
    writable: {
      __proto__: null,
      get() {
        const b = this._writableState;
        return !!b && b.writable !== !1 && !b.destroyed && !b.errored && !b.ending && !b.ended;
      },
      set(b) {
        this._writableState && (this._writableState.writable = !!b);
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : !1;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : !1;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : !1;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const b = this._writableState;
        return b ? !b.destroyed && !b.ending && b.needDrain : !1;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  const Oe = p.destroy;
  Z.prototype.destroy = function(b, w) {
    const T = this._writableState;
    return !T.destroyed && (T.bufferedIndex < T.buffered.length || T[W].length) && e.nextTick(H, T), Oe.call(this, b, w), this;
  }, Z.prototype._undestroy = p.undestroy, Z.prototype._destroy = function(b, w) {
    w(b);
  }, Z.prototype[c.captureRejectionSymbol] = function(b) {
    this.destroy(b);
  };
  let K;
  function z() {
    return K === void 0 && (K = {}), K;
  }
  return Z.fromWeb = function(b, w) {
    return z().newStreamWritableFromWritableStream(b, w);
  }, Z.toWeb = function(b) {
    return z().newWritableStreamFromStreamWritable(b);
  }, Hy;
}
var zy, Hk;
function Ile() {
  if (Hk)
    return zy;
  Hk = 1;
  const e = _t, t = ut, {
    isReadable: r,
    isWritable: n,
    isIterable: o,
    isNodeStream: s,
    isReadableNodeStream: a,
    isWritableNodeStream: l,
    isDuplexNodeStream: u,
    isReadableStream: f,
    isWritableStream: c
  } = To, d = _s, {
    AbortError: h,
    codes: { ERR_INVALID_ARG_TYPE: p, ERR_INVALID_RETURN_VALUE: m }
  } = an, { destroyer: y } = mu, _ = ho(), S = cg(), x = Wx(), { createDeferredPromise: E } = Gr, C = f8, I = globalThis.Blob || t.Blob, j = typeof I < "u" ? function(k) {
    return k instanceof I;
  } : function(k) {
    return !1;
  }, J = globalThis.AbortController || Kt().AbortController, { FunctionPrototypeCall: G } = qt;
  class $ extends _ {
    constructor(k) {
      super(k), (k == null ? void 0 : k.readable) === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), (k == null ? void 0 : k.writable) === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0);
    }
  }
  zy = function W(k, U) {
    if (u(k))
      return k;
    if (a(k))
      return M({
        readable: k
      });
    if (l(k))
      return M({
        writable: k
      });
    if (s(k))
      return M({
        writable: !1,
        readable: !1
      });
    if (f(k))
      return M({
        readable: S.fromWeb(k)
      });
    if (c(k))
      return M({
        writable: x.fromWeb(k)
      });
    if (typeof k == "function") {
      const { value: Y, write: te, final: se, destroy: fe } = V(k);
      if (o(Y))
        return C($, Y, {
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          write: te,
          final: se,
          destroy: fe
        });
      const he = Y == null ? void 0 : Y.then;
      if (typeof he == "function") {
        let ae;
        const be = G(
          he,
          Y,
          (H) => {
            if (H != null)
              throw new m("nully", "body", H);
          },
          (H) => {
            y(ae, H);
          }
        );
        return ae = new $({
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          readable: !1,
          write: te,
          final(H) {
            se(async () => {
              try {
                await be, e.nextTick(H, null);
              } catch (pe) {
                e.nextTick(H, pe);
              }
            });
          },
          destroy: fe
        });
      }
      throw new m("Iterable, AsyncIterable or AsyncFunction", U, Y);
    }
    if (j(k))
      return W(k.arrayBuffer());
    if (o(k))
      return C($, k, {
        // TODO (ronag): highWaterMark?
        objectMode: !0,
        writable: !1
      });
    if (f(k == null ? void 0 : k.readable) && c(k == null ? void 0 : k.writable))
      return $.fromWeb(k);
    if (typeof (k == null ? void 0 : k.writable) == "object" || typeof (k == null ? void 0 : k.readable) == "object") {
      const Y = k != null && k.readable ? a(k == null ? void 0 : k.readable) ? k == null ? void 0 : k.readable : W(k.readable) : void 0, te = k != null && k.writable ? l(k == null ? void 0 : k.writable) ? k == null ? void 0 : k.writable : W(k.writable) : void 0;
      return M({
        readable: Y,
        writable: te
      });
    }
    const Z = k == null ? void 0 : k.then;
    if (typeof Z == "function") {
      let Y;
      return G(
        Z,
        k,
        (te) => {
          te != null && Y.push(te), Y.push(null);
        },
        (te) => {
          y(Y, te);
        }
      ), Y = new $({
        objectMode: !0,
        writable: !1,
        read() {
        }
      });
    }
    throw new p(
      U,
      [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise"
      ],
      k
    );
  };
  function V(W) {
    let { promise: k, resolve: U } = E();
    const Z = new J(), Y = Z.signal;
    return {
      value: W(
        async function* () {
          for (; ; ) {
            const se = k;
            k = null;
            const { chunk: fe, done: he, cb: ae } = await se;
            if (e.nextTick(ae), he)
              return;
            if (Y.aborted)
              throw new h(void 0, {
                cause: Y.reason
              });
            ({ promise: k, resolve: U } = E()), yield fe;
          }
        }(),
        {
          signal: Y
        }
      ),
      write(se, fe, he) {
        const ae = U;
        U = null, ae({
          chunk: se,
          done: !1,
          cb: he
        });
      },
      final(se) {
        const fe = U;
        U = null, fe({
          done: !0,
          cb: se
        });
      },
      destroy(se, fe) {
        Z.abort(), fe(se);
      }
    };
  }
  function M(W) {
    const k = W.readable && typeof W.readable.read != "function" ? S.wrap(W.readable) : W.readable, U = W.writable;
    let Z = !!r(k), Y = !!n(U), te, se, fe, he, ae;
    function be(H) {
      const pe = he;
      he = null, pe ? pe(H) : H && ae.destroy(H);
    }
    return ae = new $({
      // TODO (ronag): highWaterMark?
      readableObjectMode: !!(k != null && k.readableObjectMode),
      writableObjectMode: !!(U != null && U.writableObjectMode),
      readable: Z,
      writable: Y
    }), Y && (d(U, (H) => {
      Y = !1, H && y(k, H), be(H);
    }), ae._write = function(H, pe, ke) {
      U.write(H, pe) ? ke() : te = ke;
    }, ae._final = function(H) {
      U.end(), se = H;
    }, U.on("drain", function() {
      if (te) {
        const H = te;
        te = null, H();
      }
    }), U.on("finish", function() {
      if (se) {
        const H = se;
        se = null, H();
      }
    })), Z && (d(k, (H) => {
      Z = !1, H && y(k, H), be(H);
    }), k.on("readable", function() {
      if (fe) {
        const H = fe;
        fe = null, H();
      }
    }), k.on("end", function() {
      ae.push(null);
    }), ae._read = function() {
      for (; ; ) {
        const H = k.read();
        if (H === null) {
          fe = ae._read;
          return;
        }
        if (!ae.push(H))
          return;
      }
    }), ae._destroy = function(H, pe) {
      !H && he !== null && (H = new h()), fe = null, te = null, se = null, he === null ? pe(H) : (he = pe, y(U, H), y(k, H));
    }, ae;
  }
  return zy;
}
var Gy, zk;
function ho() {
  if (zk)
    return Gy;
  zk = 1;
  const {
    ObjectDefineProperties: e,
    ObjectGetOwnPropertyDescriptor: t,
    ObjectKeys: r,
    ObjectSetPrototypeOf: n
  } = qt;
  Gy = a;
  const o = cg(), s = Wx();
  n(a.prototype, o.prototype), n(a, o);
  {
    const c = r(s.prototype);
    for (let d = 0; d < c.length; d++) {
      const h = c[d];
      a.prototype[h] || (a.prototype[h] = s.prototype[h]);
    }
  }
  function a(c) {
    if (!(this instanceof a))
      return new a(c);
    o.call(this, c), s.call(this, c), c ? (this.allowHalfOpen = c.allowHalfOpen !== !1, c.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), c.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0)) : this.allowHalfOpen = !0;
  }
  e(a.prototype, {
    writable: {
      __proto__: null,
      ...t(s.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...t(s.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...t(s.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...t(s.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...t(s.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...t(s.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...t(s.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...t(s.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...t(s.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
      },
      set(c) {
        this._readableState && this._writableState && (this._readableState.destroyed = c, this._writableState.destroyed = c);
      }
    }
  });
  let l;
  function u() {
    return l === void 0 && (l = {}), l;
  }
  a.fromWeb = function(c, d) {
    return u().newStreamDuplexFromReadableWritablePair(c, d);
  }, a.toWeb = function(c) {
    return u().newReadableWritablePairFromDuplex(c);
  };
  let f;
  return a.from = function(c) {
    return f || (f = Ile()), f(c, "body");
  }, Gy;
}
const { ObjectSetPrototypeOf: c8, Symbol: Mle } = qt;
var d8 = po;
const { ERR_METHOD_NOT_IMPLEMENTED: Nle } = an.codes, Ux = ho(), { getHighWaterMark: Lle } = fg;
c8(po.prototype, Ux.prototype);
c8(po, Ux);
const Ef = Mle("kCallback");
function po(e) {
  if (!(this instanceof po))
    return new po(e);
  const t = e ? Lle(this, e, "readableHighWaterMark", !0) : null;
  t === 0 && (e = {
    ...e,
    highWaterMark: null,
    readableHighWaterMark: t,
    // TODO (ronag): 0 is not optimal since we have
    // a "bug" where we check needDrain before calling _write and not after.
    // Refs: https://github.com/nodejs/node/pull/32887
    // Refs: https://github.com/nodejs/node/pull/35941
    writableHighWaterMark: e.writableHighWaterMark || 0
  }), Ux.call(this, e), this._readableState.sync = !1, this[Ef] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", Ole);
}
function IS(e) {
  typeof this._flush == "function" && !this.destroyed ? this._flush((t, r) => {
    if (t) {
      e ? e(t) : this.destroy(t);
      return;
    }
    r != null && this.push(r), this.push(null), e && e();
  }) : (this.push(null), e && e());
}
function Ole() {
  this._final !== IS && IS.call(this);
}
po.prototype._final = IS;
po.prototype._transform = function(e, t, r) {
  throw new Nle("_transform()");
};
po.prototype._write = function(e, t, r) {
  const n = this._readableState, o = this._writableState, s = n.length;
  this._transform(e, t, (a, l) => {
    if (a) {
      r(a);
      return;
    }
    l != null && this.push(l), o.ended || // Backwards compat.
    s === n.length || // Backwards compat.
    n.length < n.highWaterMark ? r() : this[Ef] = r;
  });
};
po.prototype._read = function() {
  if (this[Ef]) {
    const e = this[Ef];
    this[Ef] = null, e();
  }
};
const { ObjectSetPrototypeOf: h8 } = qt;
var p8 = Kl;
const Hx = d8;
h8(Kl.prototype, Hx.prototype);
h8(Kl, Hx);
function Kl(e) {
  if (!(this instanceof Kl))
    return new Kl(e);
  Hx.call(this, e);
}
Kl.prototype._transform = function(e, t, r) {
  r(null, e);
};
const Ju = _t, { ArrayIsArray: Ple, Promise: Dle, SymbolAsyncIterator: Fle, SymbolDispose: jle } = qt, Ah = _s, { once: Ble } = Gr, qle = mu, Gk = ho(), {
  aggregateTwoErrors: Wle,
  codes: {
    ERR_INVALID_ARG_TYPE: MS,
    ERR_INVALID_RETURN_VALUE: Vy,
    ERR_MISSING_ARGS: Ule,
    ERR_STREAM_DESTROYED: Hle,
    ERR_STREAM_PREMATURE_CLOSE: zle
  },
  AbortError: Gle
} = an, { validateFunction: Vle, validateAbortSignal: Kle } = _c, {
  isIterable: Us,
  isReadable: Ky,
  isReadableNodeStream: Wd,
  isNodeStream: Vk,
  isTransformStream: vl,
  isWebStream: Yle,
  isReadableStream: Yy,
  isReadableFinished: Xle
} = To, Jle = globalThis.AbortController || Kt().AbortController;
let Xy, Jy, Qy;
function Kk(e, t, r) {
  let n = !1;
  e.on("close", () => {
    n = !0;
  });
  const o = Ah(
    e,
    {
      readable: t,
      writable: r
    },
    (s) => {
      n = !s;
    }
  );
  return {
    destroy: (s) => {
      n || (n = !0, qle.destroyer(e, s || new Hle("pipe")));
    },
    cleanup: o
  };
}
function Qle(e) {
  return Vle(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
}
function Zy(e) {
  if (Us(e))
    return e;
  if (Wd(e))
    return Zle(e);
  throw new MS("val", ["Readable", "Iterable", "AsyncIterable"], e);
}
async function* Zle(e) {
  Jy || (Jy = cg()), yield* Jy.prototype[Fle].call(e);
}
async function dd(e, t, r, { end: n }) {
  let o, s = null;
  const a = (f) => {
    if (f && (o = f), s) {
      const c = s;
      s = null, c();
    }
  }, l = () => new Dle((f, c) => {
    o ? c(o) : s = () => {
      o ? c(o) : f();
    };
  });
  t.on("drain", a);
  const u = Ah(
    t,
    {
      readable: !1
    },
    a
  );
  try {
    t.writableNeedDrain && await l();
    for await (const f of e)
      t.write(f) || await l();
    n && (t.end(), await l()), r();
  } catch (f) {
    r(o !== f ? Wle(o, f) : f);
  } finally {
    u(), t.off("drain", a);
  }
}
async function e0(e, t, r, { end: n }) {
  vl(t) && (t = t.writable);
  const o = t.getWriter();
  try {
    for await (const s of e)
      await o.ready, o.write(s).catch(() => {
      });
    await o.ready, n && await o.close(), r();
  } catch (s) {
    try {
      await o.abort(s), r(s);
    } catch (a) {
      r(a);
    }
  }
}
function eue(...e) {
  return g8(e, Ble(Qle(e)));
}
function g8(e, t, r) {
  if (e.length === 1 && Ple(e[0]) && (e = e[0]), e.length < 2)
    throw new Ule("streams");
  const n = new Jle(), o = n.signal, s = r == null ? void 0 : r.signal, a = [];
  Kle(s, "options.signal");
  function l() {
    m(new Gle());
  }
  Qy = Qy || Gr.addAbortListener;
  let u;
  s && (u = Qy(s, l));
  let f, c;
  const d = [];
  let h = 0;
  function p(x) {
    m(x, --h === 0);
  }
  function m(x, E) {
    var C;
    if (x && (!f || f.code === "ERR_STREAM_PREMATURE_CLOSE") && (f = x), !(!f && !E)) {
      for (; d.length; )
        d.shift()(f);
      (C = u) === null || C === void 0 || C[jle](), n.abort(), E && (f || a.forEach((I) => I()), Ju.nextTick(t, f, c));
    }
  }
  let y;
  for (let x = 0; x < e.length; x++) {
    const E = e[x], C = x < e.length - 1, I = x > 0, j = C || (r == null ? void 0 : r.end) !== !1, J = x === e.length - 1;
    if (Vk(E)) {
      let G = function($) {
        $ && $.name !== "AbortError" && $.code !== "ERR_STREAM_PREMATURE_CLOSE" && p($);
      };
      if (j) {
        const { destroy: $, cleanup: V } = Kk(E, C, I);
        d.push($), Ky(E) && J && a.push(V);
      }
      E.on("error", G), Ky(E) && J && a.push(() => {
        E.removeListener("error", G);
      });
    }
    if (x === 0)
      if (typeof E == "function") {
        if (y = E({
          signal: o
        }), !Us(y))
          throw new Vy("Iterable, AsyncIterable or Stream", "source", y);
      } else
        Us(E) || Wd(E) || vl(E) ? y = E : y = Gk.from(E);
    else if (typeof E == "function") {
      if (vl(y)) {
        var _;
        y = Zy((_ = y) === null || _ === void 0 ? void 0 : _.readable);
      } else
        y = Zy(y);
      if (y = E(y, {
        signal: o
      }), C) {
        if (!Us(y, !0))
          throw new Vy("AsyncIterable", `transform[${x - 1}]`, y);
      } else {
        var S;
        Xy || (Xy = p8);
        const G = new Xy({
          objectMode: !0
        }), $ = (S = y) === null || S === void 0 ? void 0 : S.then;
        if (typeof $ == "function")
          h++, $.call(
            y,
            (W) => {
              c = W, W != null && G.write(W), j && G.end(), Ju.nextTick(p);
            },
            (W) => {
              G.destroy(W), Ju.nextTick(p, W);
            }
          );
        else if (Us(y, !0))
          h++, dd(y, G, p, {
            end: j
          });
        else if (Yy(y) || vl(y)) {
          const W = y.readable || y;
          h++, dd(W, G, p, {
            end: j
          });
        } else
          throw new Vy("AsyncIterable or Promise", "destination", y);
        y = G;
        const { destroy: V, cleanup: M } = Kk(y, !1, !0);
        d.push(V), J && a.push(M);
      }
    } else if (Vk(E)) {
      if (Wd(y)) {
        h += 2;
        const G = tue(y, E, p, {
          end: j
        });
        Ky(E) && J && a.push(G);
      } else if (vl(y) || Yy(y)) {
        const G = y.readable || y;
        h++, dd(G, E, p, {
          end: j
        });
      } else if (Us(y))
        h++, dd(y, E, p, {
          end: j
        });
      else
        throw new MS(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          y
        );
      y = E;
    } else if (Yle(E)) {
      if (Wd(y))
        h++, e0(Zy(y), E, p, {
          end: j
        });
      else if (Yy(y) || Us(y))
        h++, e0(y, E, p, {
          end: j
        });
      else if (vl(y))
        h++, e0(y.readable, E, p, {
          end: j
        });
      else
        throw new MS(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          y
        );
      y = E;
    } else
      y = Gk.from(E);
  }
  return (o != null && o.aborted || s != null && s.aborted) && Ju.nextTick(l), y;
}
function tue(e, t, r, { end: n }) {
  let o = !1;
  if (t.on("close", () => {
    o || r(new zle());
  }), e.pipe(t, {
    end: !1
  }), n) {
    let s = function() {
      o = !0, t.end();
    };
    Xle(e) ? Ju.nextTick(s) : e.once("end", s);
  } else
    r();
  return Ah(
    e,
    {
      readable: !0,
      writable: !1
    },
    (s) => {
      const a = e._readableState;
      s && s.code === "ERR_STREAM_PREMATURE_CLOSE" && a && a.ended && !a.errored && !a.errorEmitted ? e.once("end", r).once("error", r) : r(s);
    }
  ), Ah(
    t,
    {
      readable: !1,
      writable: !0
    },
    r
  );
}
var zx = {
  pipelineImpl: g8,
  pipeline: eue
};
const { pipeline: rue } = zx, hd = ho(), { destroyer: nue } = mu, {
  isNodeStream: pd,
  isReadable: Yk,
  isWritable: Xk,
  isWebStream: t0,
  isTransformStream: Os,
  isWritableStream: Jk,
  isReadableStream: Qk
} = To, {
  AbortError: iue,
  codes: { ERR_INVALID_ARG_VALUE: Zk, ERR_MISSING_ARGS: oue }
} = an, sue = _s;
var b8 = function(...t) {
  if (t.length === 0)
    throw new oue("streams");
  if (t.length === 1)
    return hd.from(t[0]);
  const r = [...t];
  if (typeof t[0] == "function" && (t[0] = hd.from(t[0])), typeof t[t.length - 1] == "function") {
    const p = t.length - 1;
    t[p] = hd.from(t[p]);
  }
  for (let p = 0; p < t.length; ++p)
    if (!(!pd(t[p]) && !t0(t[p]))) {
      if (p < t.length - 1 && !(Yk(t[p]) || Qk(t[p]) || Os(t[p])))
        throw new Zk(`streams[${p}]`, r[p], "must be readable");
      if (p > 0 && !(Xk(t[p]) || Jk(t[p]) || Os(t[p])))
        throw new Zk(`streams[${p}]`, r[p], "must be writable");
    }
  let n, o, s, a, l;
  function u(p) {
    const m = a;
    a = null, m ? m(p) : p ? l.destroy(p) : !h && !d && l.destroy();
  }
  const f = t[0], c = rue(t, u), d = !!(Xk(f) || Jk(f) || Os(f)), h = !!(Yk(c) || Qk(c) || Os(c));
  if (l = new hd({
    // TODO (ronag): highWaterMark?
    writableObjectMode: !!(f != null && f.writableObjectMode),
    readableObjectMode: !!(c != null && c.readableObjectMode),
    writable: d,
    readable: h
  }), d) {
    if (pd(f))
      l._write = function(m, y, _) {
        f.write(m, y) ? _() : n = _;
      }, l._final = function(m) {
        f.end(), o = m;
      }, f.on("drain", function() {
        if (n) {
          const m = n;
          n = null, m();
        }
      });
    else if (t0(f)) {
      const y = (Os(f) ? f.writable : f).getWriter();
      l._write = async function(_, S, x) {
        try {
          await y.ready, y.write(_).catch(() => {
          }), x();
        } catch (E) {
          x(E);
        }
      }, l._final = async function(_) {
        try {
          await y.ready, y.close().catch(() => {
          }), o = _;
        } catch (S) {
          _(S);
        }
      };
    }
    const p = Os(c) ? c.readable : c;
    sue(p, () => {
      if (o) {
        const m = o;
        o = null, m();
      }
    });
  }
  if (h) {
    if (pd(c))
      c.on("readable", function() {
        if (s) {
          const p = s;
          s = null, p();
        }
      }), c.on("end", function() {
        l.push(null);
      }), l._read = function() {
        for (; ; ) {
          const p = c.read();
          if (p === null) {
            s = l._read;
            return;
          }
          if (!l.push(p))
            return;
        }
      };
    else if (t0(c)) {
      const m = (Os(c) ? c.readable : c).getReader();
      l._read = async function() {
        for (; ; )
          try {
            const { value: y, done: _ } = await m.read();
            if (!l.push(y))
              return;
            if (_) {
              l.push(null);
              return;
            }
          } catch {
            return;
          }
      };
    }
  }
  return l._destroy = function(p, m) {
    !p && a !== null && (p = new iue()), s = null, n = null, o = null, a === null ? m(p) : (a = m, pd(c) && nue(c, p));
  }, l;
};
const aue = globalThis.AbortController || Kt().AbortController, {
  codes: { ERR_INVALID_ARG_VALUE: lue, ERR_INVALID_ARG_TYPE: Sc, ERR_MISSING_ARGS: uue, ERR_OUT_OF_RANGE: fue },
  AbortError: ki
} = an, { validateAbortSignal: Xa, validateInteger: eI, validateObject: Ja } = _c, cue = qt.Symbol("kWeak"), due = qt.Symbol("kResistStopPropagation"), { finished: hue } = _s, pue = b8, { addAbortSignalNoValidate: gue } = ug, { isWritable: bue, isNodeStream: yue } = To, { deprecate: mue } = Gr, {
  ArrayPrototypePush: vue,
  Boolean: wue,
  MathFloor: tI,
  Number: _ue,
  NumberIsNaN: Sue,
  Promise: rI,
  PromiseReject: nI,
  PromiseResolve: Eue,
  PromisePrototypeThen: iI,
  Symbol: y8
} = qt, Th = y8("kEmpty"), oI = y8("kEof");
function xue(e, t) {
  if (t != null && Ja(t, "options"), (t == null ? void 0 : t.signal) != null && Xa(t.signal, "options.signal"), yue(e) && !bue(e))
    throw new lue("stream", e, "must be writable");
  const r = pue(this, e);
  return t != null && t.signal && gue(t.signal, r), r;
}
function dg(e, t) {
  if (typeof e != "function")
    throw new Sc("fn", ["Function", "AsyncFunction"], e);
  t != null && Ja(t, "options"), (t == null ? void 0 : t.signal) != null && Xa(t.signal, "options.signal");
  let r = 1;
  (t == null ? void 0 : t.concurrency) != null && (r = tI(t.concurrency));
  let n = r - 1;
  return (t == null ? void 0 : t.highWaterMark) != null && (n = tI(t.highWaterMark)), eI(r, "options.concurrency", 1), eI(n, "options.highWaterMark", 0), n += r, (async function* () {
    const s = Gr.AbortSignalAny(
      [t == null ? void 0 : t.signal].filter(wue)
    ), a = this, l = [], u = {
      signal: s
    };
    let f, c, d = !1, h = 0;
    function p() {
      d = !0, m();
    }
    function m() {
      h -= 1, y();
    }
    function y() {
      c && !d && h < r && l.length < n && (c(), c = null);
    }
    async function _() {
      try {
        for await (let S of a) {
          if (d)
            return;
          if (s.aborted)
            throw new ki();
          try {
            if (S = e(S, u), S === Th)
              continue;
            S = Eue(S);
          } catch (x) {
            S = nI(x);
          }
          h += 1, iI(S, m, p), l.push(S), f && (f(), f = null), !d && (l.length >= n || h >= r) && await new rI((x) => {
            c = x;
          });
        }
        l.push(oI);
      } catch (S) {
        const x = nI(S);
        iI(x, m, p), l.push(x);
      } finally {
        d = !0, f && (f(), f = null);
      }
    }
    _();
    try {
      for (; ; ) {
        for (; l.length > 0; ) {
          const S = await l[0];
          if (S === oI)
            return;
          if (s.aborted)
            throw new ki();
          S !== Th && (yield S), l.shift(), y();
        }
        await new rI((S) => {
          f = S;
        });
      }
    } finally {
      d = !0, c && (c(), c = null);
    }
  }).call(this);
}
function Rue(e = void 0) {
  return e != null && Ja(e, "options"), (e == null ? void 0 : e.signal) != null && Xa(e.signal, "options.signal"), (async function* () {
    let r = 0;
    for await (const o of this) {
      var n;
      if (e != null && (n = e.signal) !== null && n !== void 0 && n.aborted)
        throw new ki({
          cause: e.signal.reason
        });
      yield [r++, o];
    }
  }).call(this);
}
async function m8(e, t = void 0) {
  for await (const r of Gx.call(this, e, t))
    return !0;
  return !1;
}
async function Aue(e, t = void 0) {
  if (typeof e != "function")
    throw new Sc("fn", ["Function", "AsyncFunction"], e);
  return !await m8.call(
    this,
    async (...r) => !await e(...r),
    t
  );
}
async function Tue(e, t) {
  for await (const r of Gx.call(this, e, t))
    return r;
}
async function $ue(e, t) {
  if (typeof e != "function")
    throw new Sc("fn", ["Function", "AsyncFunction"], e);
  async function r(n, o) {
    return await e(n, o), Th;
  }
  for await (const n of dg.call(this, r, t))
    ;
}
function Gx(e, t) {
  if (typeof e != "function")
    throw new Sc("fn", ["Function", "AsyncFunction"], e);
  async function r(n, o) {
    return await e(n, o) ? n : Th;
  }
  return dg.call(this, r, t);
}
class Cue extends uue {
  constructor() {
    super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
  }
}
async function kue(e, t, r) {
  var n;
  if (typeof e != "function")
    throw new Sc("reducer", ["Function", "AsyncFunction"], e);
  r != null && Ja(r, "options"), (r == null ? void 0 : r.signal) != null && Xa(r.signal, "options.signal");
  let o = arguments.length > 1;
  if (r != null && (n = r.signal) !== null && n !== void 0 && n.aborted) {
    const f = new ki(void 0, {
      cause: r.signal.reason
    });
    throw this.once("error", () => {
    }), await hue(this.destroy(f)), f;
  }
  const s = new aue(), a = s.signal;
  if (r != null && r.signal) {
    const f = {
      once: !0,
      [cue]: this,
      [due]: !0
    };
    r.signal.addEventListener("abort", () => s.abort(), f);
  }
  let l = !1;
  try {
    for await (const f of this) {
      var u;
      if (l = !0, r != null && (u = r.signal) !== null && u !== void 0 && u.aborted)
        throw new ki();
      o ? t = await e(t, f, {
        signal: a
      }) : (t = f, o = !0);
    }
    if (!l && !o)
      throw new Cue();
  } finally {
    s.abort();
  }
  return t;
}
async function Iue(e) {
  e != null && Ja(e, "options"), (e == null ? void 0 : e.signal) != null && Xa(e.signal, "options.signal");
  const t = [];
  for await (const n of this) {
    var r;
    if (e != null && (r = e.signal) !== null && r !== void 0 && r.aborted)
      throw new ki(void 0, {
        cause: e.signal.reason
      });
    vue(t, n);
  }
  return t;
}
function Mue(e, t) {
  const r = dg.call(this, e, t);
  return (async function* () {
    for await (const o of r)
      yield* o;
  }).call(this);
}
function v8(e) {
  if (e = _ue(e), Sue(e))
    return 0;
  if (e < 0)
    throw new fue("number", ">= 0", e);
  return e;
}
function Nue(e, t = void 0) {
  return t != null && Ja(t, "options"), (t == null ? void 0 : t.signal) != null && Xa(t.signal, "options.signal"), e = v8(e), (async function* () {
    var n;
    if (t != null && (n = t.signal) !== null && n !== void 0 && n.aborted)
      throw new ki();
    for await (const s of this) {
      var o;
      if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
        throw new ki();
      e-- <= 0 && (yield s);
    }
  }).call(this);
}
function Lue(e, t = void 0) {
  return t != null && Ja(t, "options"), (t == null ? void 0 : t.signal) != null && Xa(t.signal, "options.signal"), e = v8(e), (async function* () {
    var n;
    if (t != null && (n = t.signal) !== null && n !== void 0 && n.aborted)
      throw new ki();
    for await (const s of this) {
      var o;
      if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
        throw new ki();
      if (e-- > 0 && (yield s), e <= 0)
        return;
    }
  }).call(this);
}
Px.streamReturningOperators = {
  asIndexedPairs: mue(Rue, "readable.asIndexedPairs will be removed in a future version."),
  drop: Nue,
  filter: Gx,
  flatMap: Mue,
  map: dg,
  take: Lue,
  compose: xue
};
Px.promiseReturningOperators = {
  every: Aue,
  forEach: $ue,
  reduce: kue,
  toArray: Iue,
  some: m8,
  find: Tue
};
var r0, sI;
function w8() {
  if (sI)
    return r0;
  sI = 1;
  const { ArrayPrototypePop: e, Promise: t } = qt, { isIterable: r, isNodeStream: n, isWebStream: o } = To, { pipelineImpl: s } = zx, { finished: a } = _s;
  _8();
  function l(...u) {
    return new t((f, c) => {
      let d, h;
      const p = u[u.length - 1];
      if (p && typeof p == "object" && !n(p) && !r(p) && !o(p)) {
        const m = e(u);
        d = m.signal, h = m.end;
      }
      s(
        u,
        (m, y) => {
          m ? c(m) : f(y);
        },
        {
          signal: d,
          end: h
        }
      );
    });
  }
  return r0 = {
    finished: a,
    pipeline: l
  }, r0;
}
var aI;
function _8() {
  if (aI)
    return jy.exports;
  aI = 1;
  const { Buffer: e } = ut, { ObjectDefineProperty: t, ObjectKeys: r, ReflectApply: n } = qt, {
    promisify: { custom: o }
  } = Gr, { streamReturningOperators: s, promiseReturningOperators: a } = Px, {
    codes: { ERR_ILLEGAL_CONSTRUCTOR: l }
  } = an, u = b8, { setDefaultHighWaterMark: f, getDefaultHighWaterMark: c } = fg, { pipeline: d } = zx, { destroyer: h } = mu, p = _s, m = w8(), y = To, _ = jy.exports = qx.Stream;
  _.isDestroyed = y.isDestroyed, _.isDisturbed = y.isDisturbed, _.isErrored = y.isErrored, _.isReadable = y.isReadable, _.isWritable = y.isWritable, _.Readable = cg();
  for (const x of r(s)) {
    let C = function(...I) {
      if (new.target)
        throw l();
      return _.Readable.from(n(E, this, I));
    };
    const E = s[x];
    t(C, "name", {
      __proto__: null,
      value: E.name
    }), t(C, "length", {
      __proto__: null,
      value: E.length
    }), t(_.Readable.prototype, x, {
      __proto__: null,
      value: C,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  for (const x of r(a)) {
    let C = function(...I) {
      if (new.target)
        throw l();
      return n(E, this, I);
    };
    const E = a[x];
    t(C, "name", {
      __proto__: null,
      value: E.name
    }), t(C, "length", {
      __proto__: null,
      value: E.length
    }), t(_.Readable.prototype, x, {
      __proto__: null,
      value: C,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  _.Writable = Wx(), _.Duplex = ho(), _.Transform = d8, _.PassThrough = p8, _.pipeline = d;
  const { addAbortSignal: S } = ug;
  return _.addAbortSignal = S, _.finished = p, _.destroy = h, _.compose = u, _.setDefaultHighWaterMark = f, _.getDefaultHighWaterMark = c, t(_, "promises", {
    __proto__: null,
    configurable: !0,
    enumerable: !0,
    get() {
      return m;
    }
  }), t(d, o, {
    __proto__: null,
    enumerable: !0,
    get() {
      return m.pipeline;
    }
  }), t(p, o, {
    __proto__: null,
    enumerable: !0,
    get() {
      return m.finished;
    }
  }), _.Stream = _, _._isUint8Array = function(E) {
    return E instanceof Uint8Array;
  }, _._uint8ArrayToBuffer = function(E) {
    return e.from(E.buffer, E.byteOffset, E.byteLength);
  }, jy.exports;
}
(function(e) {
  const t = _8(), r = w8(), n = t.Readable.destroy;
  e.exports = t.Readable, e.exports._uint8ArrayToBuffer = t._uint8ArrayToBuffer, e.exports._isUint8Array = t._isUint8Array, e.exports.isDisturbed = t.isDisturbed, e.exports.isErrored = t.isErrored, e.exports.isReadable = t.isReadable, e.exports.Readable = t.Readable, e.exports.Writable = t.Writable, e.exports.Duplex = t.Duplex, e.exports.Transform = t.Transform, e.exports.PassThrough = t.PassThrough, e.exports.addAbortSignal = t.addAbortSignal, e.exports.finished = t.finished, e.exports.destroy = t.destroy, e.exports.destroy = n, e.exports.pipeline = t.pipeline, e.exports.compose = t.compose, Object.defineProperty(t, "promises", {
    configurable: !0,
    enumerable: !0,
    get() {
      return r;
    }
  }), e.exports.Stream = t.Stream, e.exports.default = e.exports;
})(I7);
var Oue = I7.exports;
class Pue {
  constructor(t, ...r) {
    this.load = k7(async () => {
      const n = await t();
      return new n(...r);
    });
  }
  import(t, r) {
    const n = new Oue.PassThrough({ objectMode: !0 });
    return Promise.resolve().then(async () => {
      const s = (await this.load()).import(t, r);
      s.on("prefix", (a, l) => {
        n.emit("prefix", a, l);
      }), s.on("error", (a) => {
        n.emit("error", a), n.emit("end");
      }), s.pipe(n);
    }), n;
  }
}
function ei(e) {
  return class extends Pue {
    constructor(...t) {
      super(e, ...t);
    }
  };
}
const Due = new dh(), Fue = new dh(), bn = {
  parsers: Due,
  serializers: Fue
}, jue = ei(async () => (await import("./index-DcZIc2ym.js")).default), Ec = ei(async () => (await Promise.resolve().then(() => QQ)).default), Bue = ei(async () => (await import("./CustomRdfXmlParser-LdRjZMs1.js")).default), hg = ei(async () => (await import("./index-DFvKpldj.js")).default), que = ei(async () => (await import("./CustomJsonLdSerializer-C4JMOI2T.js")).default);
bn.parsers.set("application/ld+json", new jue());
bn.parsers.set("application/trig", new Ec());
bn.parsers.set("application/n-quads", new Ec());
bn.parsers.set("application/n-triples", new Ec());
bn.parsers.set("text/n3", new Ec());
bn.parsers.set("text/turtle", new Ec());
bn.parsers.set("application/rdf+xml", new Bue());
bn.serializers.set("application/ld+json", new que());
bn.serializers.set("application/n-quads", new hg());
bn.serializers.set("application/n-triples", new hg());
bn.serializers.set("text/n3", new hg());
bn.serializers.set("text/turtle", new hg());
var NS = { exports: {} }, S8 = ur.EventEmitter;
const Wue = {}, Uue = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Wue
}, Symbol.toStringTag, { value: "Module" })), Vx = /* @__PURE__ */ gK(Uue);
var n0, lI;
function Hue() {
  if (lI)
    return n0;
  lI = 1;
  function e(m, y) {
    var _ = Object.keys(m);
    if (Object.getOwnPropertySymbols) {
      var S = Object.getOwnPropertySymbols(m);
      y && (S = S.filter(function(x) {
        return Object.getOwnPropertyDescriptor(m, x).enumerable;
      })), _.push.apply(_, S);
    }
    return _;
  }
  function t(m) {
    for (var y = 1; y < arguments.length; y++) {
      var _ = arguments[y] != null ? arguments[y] : {};
      y % 2 ? e(Object(_), !0).forEach(function(S) {
        r(m, S, _[S]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(m, Object.getOwnPropertyDescriptors(_)) : e(Object(_)).forEach(function(S) {
        Object.defineProperty(m, S, Object.getOwnPropertyDescriptor(_, S));
      });
    }
    return m;
  }
  function r(m, y, _) {
    return y = a(y), y in m ? Object.defineProperty(m, y, { value: _, enumerable: !0, configurable: !0, writable: !0 }) : m[y] = _, m;
  }
  function n(m, y) {
    if (!(m instanceof y))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(m, y) {
    for (var _ = 0; _ < y.length; _++) {
      var S = y[_];
      S.enumerable = S.enumerable || !1, S.configurable = !0, "value" in S && (S.writable = !0), Object.defineProperty(m, a(S.key), S);
    }
  }
  function s(m, y, _) {
    return y && o(m.prototype, y), _ && o(m, _), Object.defineProperty(m, "prototype", { writable: !1 }), m;
  }
  function a(m) {
    var y = l(m, "string");
    return typeof y == "symbol" ? y : String(y);
  }
  function l(m, y) {
    if (typeof m != "object" || m === null)
      return m;
    var _ = m[Symbol.toPrimitive];
    if (_ !== void 0) {
      var S = _.call(m, y || "default");
      if (typeof S != "object")
        return S;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (y === "string" ? String : Number)(m);
  }
  var u = ut, f = u.Buffer, c = Vx, d = c.inspect, h = d && d.custom || "inspect";
  function p(m, y, _) {
    f.prototype.copy.call(m, y, _);
  }
  return n0 = /* @__PURE__ */ function() {
    function m() {
      n(this, m), this.head = null, this.tail = null, this.length = 0;
    }
    return s(m, [{
      key: "push",
      value: function(_) {
        var S = {
          data: _,
          next: null
        };
        this.length > 0 ? this.tail.next = S : this.head = S, this.tail = S, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(_) {
        var S = {
          data: _,
          next: this.head
        };
        this.length === 0 && (this.tail = S), this.head = S, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var _ = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, _;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(_) {
        if (this.length === 0)
          return "";
        for (var S = this.head, x = "" + S.data; S = S.next; )
          x += _ + S.data;
        return x;
      }
    }, {
      key: "concat",
      value: function(_) {
        if (this.length === 0)
          return f.alloc(0);
        for (var S = f.allocUnsafe(_ >>> 0), x = this.head, E = 0; x; )
          p(x.data, S, E), E += x.data.length, x = x.next;
        return S;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(_, S) {
        var x;
        return _ < this.head.data.length ? (x = this.head.data.slice(0, _), this.head.data = this.head.data.slice(_)) : _ === this.head.data.length ? x = this.shift() : x = S ? this._getString(_) : this._getBuffer(_), x;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(_) {
        var S = this.head, x = 1, E = S.data;
        for (_ -= E.length; S = S.next; ) {
          var C = S.data, I = _ > C.length ? C.length : _;
          if (I === C.length ? E += C : E += C.slice(0, _), _ -= I, _ === 0) {
            I === C.length ? (++x, S.next ? this.head = S.next : this.head = this.tail = null) : (this.head = S, S.data = C.slice(I));
            break;
          }
          ++x;
        }
        return this.length -= x, E;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(_) {
        var S = f.allocUnsafe(_), x = this.head, E = 1;
        for (x.data.copy(S), _ -= x.data.length; x = x.next; ) {
          var C = x.data, I = _ > C.length ? C.length : _;
          if (C.copy(S, S.length - _, 0, I), _ -= I, _ === 0) {
            I === C.length ? (++E, x.next ? this.head = x.next : this.head = this.tail = null) : (this.head = x, x.data = C.slice(I));
            break;
          }
          ++E;
        }
        return this.length -= E, S;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: h,
      value: function(_, S) {
        return d(this, t(t({}, S), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), m;
  }(), n0;
}
function zue(e, t) {
  var r = this, n = this._readableState && this._readableState.destroyed, o = this._writableState && this._writableState.destroyed;
  return n || o ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, $t.nextTick(LS, this, e)) : $t.nextTick(LS, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(s) {
    !t && s ? r._writableState ? r._writableState.errorEmitted ? $t.nextTick(Ud, r) : (r._writableState.errorEmitted = !0, $t.nextTick(uI, r, s)) : $t.nextTick(uI, r, s) : t ? ($t.nextTick(Ud, r), t(s)) : $t.nextTick(Ud, r);
  }), this);
}
function uI(e, t) {
  LS(e, t), Ud(e);
}
function Ud(e) {
  e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
}
function Gue() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function LS(e, t) {
  e.emit("error", t);
}
function Vue(e, t) {
  var r = e._readableState, n = e._writableState;
  r && r.autoDestroy || n && n.autoDestroy ? e.destroy(t) : e.emit("error", t);
}
var E8 = {
  destroy: zue,
  undestroy: Gue,
  errorOrDestroy: Vue
}, Qa = {};
function Kue(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
}
var x8 = {};
function Ln(e, t, r) {
  r || (r = Error);
  function n(s, a, l) {
    return typeof t == "string" ? t : t(s, a, l);
  }
  var o = /* @__PURE__ */ function(s) {
    Kue(a, s);
    function a(l, u, f) {
      return s.call(this, n(l, u, f)) || this;
    }
    return a;
  }(r);
  o.prototype.name = r.name, o.prototype.code = e, x8[e] = o;
}
function fI(e, t) {
  if (Array.isArray(e)) {
    var r = e.length;
    return e = e.map(function(n) {
      return String(n);
    }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
  } else
    return "of ".concat(t, " ").concat(String(e));
}
function Yue(e, t, r) {
  return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
}
function Xue(e, t, r) {
  return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
}
function Jue(e, t, r) {
  return typeof r != "number" && (r = 0), r + t.length > e.length ? !1 : e.indexOf(t, r) !== -1;
}
Ln("ERR_INVALID_OPT_VALUE", function(e, t) {
  return 'The value "' + t + '" is invalid for option "' + e + '"';
}, TypeError);
Ln("ERR_INVALID_ARG_TYPE", function(e, t, r) {
  var n;
  typeof t == "string" && Yue(t, "not ") ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be";
  var o;
  if (Xue(e, " argument"))
    o = "The ".concat(e, " ").concat(n, " ").concat(fI(t, "type"));
  else {
    var s = Jue(e, ".") ? "property" : "argument";
    o = 'The "'.concat(e, '" ').concat(s, " ").concat(n, " ").concat(fI(t, "type"));
  }
  return o += ". Received type ".concat(typeof r), o;
}, TypeError);
Ln("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
Ln("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
  return "The " + e + " method is not implemented";
});
Ln("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
Ln("ERR_STREAM_DESTROYED", function(e) {
  return "Cannot call " + e + " after a stream was destroyed";
});
Ln("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
Ln("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
Ln("ERR_STREAM_WRITE_AFTER_END", "write after end");
Ln("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
Ln("ERR_UNKNOWN_ENCODING", function(e) {
  return "Unknown encoding: " + e;
}, TypeError);
Ln("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
Qa.codes = x8;
var Que = Qa.codes.ERR_INVALID_OPT_VALUE;
function Zue(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function efe(e, t, r, n) {
  var o = Zue(t, n, r);
  if (o != null) {
    if (!(isFinite(o) && Math.floor(o) === o) || o < 0) {
      var s = n ? r : "highWaterMark";
      throw new Que(s, o);
    }
    return Math.floor(o);
  }
  return e.objectMode ? 16 : 16 * 1024;
}
var R8 = {
  getHighWaterMark: efe
}, OS = { exports: {} };
typeof Object.create == "function" ? OS.exports = function(t, r) {
  r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : OS.exports = function(t, r) {
  if (r) {
    t.super_ = r;
    var n = function() {
    };
    n.prototype = r.prototype, t.prototype = new n(), t.prototype.constructor = t;
  }
};
var xc = OS.exports, tfe = rfe;
function rfe(e, t) {
  if (i0("noDeprecation"))
    return e;
  var r = !1;
  function n() {
    if (!r) {
      if (i0("throwDeprecation"))
        throw new Error(t);
      i0("traceDeprecation") ? console.trace(t) : console.warn(t), r = !0;
    }
    return e.apply(this, arguments);
  }
  return n;
}
function i0(e) {
  try {
    if (!window.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var t = window.localStorage[e];
  return t == null ? !1 : String(t).toLowerCase() === "true";
}
var o0, cI;
function A8() {
  if (cI)
    return o0;
  cI = 1, o0 = G;
  function e(le) {
    var ee = this;
    this.next = null, this.entry = null, this.finish = function() {
      ke(ee, le);
    };
  }
  var t;
  G.WritableState = j;
  var r = {
    deprecate: tfe
  }, n = S8, o = ut.Buffer, s = (typeof window < "u" || typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function a(le) {
    return o.from(le);
  }
  function l(le) {
    return o.isBuffer(le) || le instanceof s;
  }
  var u = E8, f = R8, c = f.getHighWaterMark, d = Qa.codes, h = d.ERR_INVALID_ARG_TYPE, p = d.ERR_METHOD_NOT_IMPLEMENTED, m = d.ERR_MULTIPLE_CALLBACK, y = d.ERR_STREAM_CANNOT_PIPE, _ = d.ERR_STREAM_DESTROYED, S = d.ERR_STREAM_NULL_VALUES, x = d.ERR_STREAM_WRITE_AFTER_END, E = d.ERR_UNKNOWN_ENCODING, C = u.errorOrDestroy;
  xc(G, n);
  function I() {
  }
  function j(le, ee, ge) {
    t = t || Yl(), le = le || {}, typeof ge != "boolean" && (ge = ee instanceof t), this.objectMode = !!le.objectMode, ge && (this.objectMode = this.objectMode || !!le.writableObjectMode), this.highWaterMark = c(this, le, "writableHighWaterMark", ge), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ae = le.decodeStrings === !1;
    this.decodeStrings = !Ae, this.defaultEncoding = le.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Oe) {
      Y(ee, Oe);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = le.emitClose !== !1, this.autoDestroy = !!le.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  j.prototype.getBuffer = function() {
    for (var ee = this.bufferedRequest, ge = []; ee; )
      ge.push(ee), ee = ee.next;
    return ge;
  }, function() {
    try {
      Object.defineProperty(j.prototype, "buffer", {
        get: r.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var J;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (J = Function.prototype[Symbol.hasInstance], Object.defineProperty(G, Symbol.hasInstance, {
    value: function(ee) {
      return J.call(this, ee) ? !0 : this !== G ? !1 : ee && ee._writableState instanceof j;
    }
  })) : J = function(ee) {
    return ee instanceof this;
  };
  function G(le) {
    t = t || Yl();
    var ee = this instanceof t;
    if (!ee && !J.call(G, this))
      return new G(le);
    this._writableState = new j(le, this, ee), this.writable = !0, le && (typeof le.write == "function" && (this._write = le.write), typeof le.writev == "function" && (this._writev = le.writev), typeof le.destroy == "function" && (this._destroy = le.destroy), typeof le.final == "function" && (this._final = le.final)), n.call(this);
  }
  G.prototype.pipe = function() {
    C(this, new y());
  };
  function $(le, ee) {
    var ge = new x();
    C(le, ge), $t.nextTick(ee, ge);
  }
  function V(le, ee, ge, Ae) {
    var Oe;
    return ge === null ? Oe = new S() : typeof ge != "string" && !ee.objectMode && (Oe = new h("chunk", ["string", "Buffer"], ge)), Oe ? (C(le, Oe), $t.nextTick(Ae, Oe), !1) : !0;
  }
  G.prototype.write = function(le, ee, ge) {
    var Ae = this._writableState, Oe = !1, K = !Ae.objectMode && l(le);
    return K && !o.isBuffer(le) && (le = a(le)), typeof ee == "function" && (ge = ee, ee = null), K ? ee = "buffer" : ee || (ee = Ae.defaultEncoding), typeof ge != "function" && (ge = I), Ae.ending ? $(this, ge) : (K || V(this, Ae, le, ge)) && (Ae.pendingcb++, Oe = W(this, Ae, K, le, ee, ge)), Oe;
  }, G.prototype.cork = function() {
    this._writableState.corked++;
  }, G.prototype.uncork = function() {
    var le = this._writableState;
    le.corked && (le.corked--, !le.writing && !le.corked && !le.bufferProcessing && le.bufferedRequest && fe(this, le));
  }, G.prototype.setDefaultEncoding = function(ee) {
    if (typeof ee == "string" && (ee = ee.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((ee + "").toLowerCase()) > -1))
      throw new E(ee);
    return this._writableState.defaultEncoding = ee, this;
  }, Object.defineProperty(G.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function M(le, ee, ge) {
    return !le.objectMode && le.decodeStrings !== !1 && typeof ee == "string" && (ee = o.from(ee, ge)), ee;
  }
  Object.defineProperty(G.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function W(le, ee, ge, Ae, Oe, K) {
    if (!ge) {
      var z = M(ee, Ae, Oe);
      Ae !== z && (ge = !0, Oe = "buffer", Ae = z);
    }
    var b = ee.objectMode ? 1 : Ae.length;
    ee.length += b;
    var w = ee.length < ee.highWaterMark;
    if (w || (ee.needDrain = !0), ee.writing || ee.corked) {
      var T = ee.lastBufferedRequest;
      ee.lastBufferedRequest = {
        chunk: Ae,
        encoding: Oe,
        isBuf: ge,
        callback: K,
        next: null
      }, T ? T.next = ee.lastBufferedRequest : ee.bufferedRequest = ee.lastBufferedRequest, ee.bufferedRequestCount += 1;
    } else
      k(le, ee, !1, b, Ae, Oe, K);
    return w;
  }
  function k(le, ee, ge, Ae, Oe, K, z) {
    ee.writelen = Ae, ee.writecb = z, ee.writing = !0, ee.sync = !0, ee.destroyed ? ee.onwrite(new _("write")) : ge ? le._writev(Oe, ee.onwrite) : le._write(Oe, K, ee.onwrite), ee.sync = !1;
  }
  function U(le, ee, ge, Ae, Oe) {
    --ee.pendingcb, ge ? ($t.nextTick(Oe, Ae), $t.nextTick(H, le, ee), le._writableState.errorEmitted = !0, C(le, Ae)) : (Oe(Ae), le._writableState.errorEmitted = !0, C(le, Ae), H(le, ee));
  }
  function Z(le) {
    le.writing = !1, le.writecb = null, le.length -= le.writelen, le.writelen = 0;
  }
  function Y(le, ee) {
    var ge = le._writableState, Ae = ge.sync, Oe = ge.writecb;
    if (typeof Oe != "function")
      throw new m();
    if (Z(ge), ee)
      U(le, ge, Ae, ee, Oe);
    else {
      var K = he(ge) || le.destroyed;
      !K && !ge.corked && !ge.bufferProcessing && ge.bufferedRequest && fe(le, ge), Ae ? $t.nextTick(te, le, ge, K, Oe) : te(le, ge, K, Oe);
    }
  }
  function te(le, ee, ge, Ae) {
    ge || se(le, ee), ee.pendingcb--, Ae(), H(le, ee);
  }
  function se(le, ee) {
    ee.length === 0 && ee.needDrain && (ee.needDrain = !1, le.emit("drain"));
  }
  function fe(le, ee) {
    ee.bufferProcessing = !0;
    var ge = ee.bufferedRequest;
    if (le._writev && ge && ge.next) {
      var Ae = ee.bufferedRequestCount, Oe = new Array(Ae), K = ee.corkedRequestsFree;
      K.entry = ge;
      for (var z = 0, b = !0; ge; )
        Oe[z] = ge, ge.isBuf || (b = !1), ge = ge.next, z += 1;
      Oe.allBuffers = b, k(le, ee, !0, ee.length, Oe, "", K.finish), ee.pendingcb++, ee.lastBufferedRequest = null, K.next ? (ee.corkedRequestsFree = K.next, K.next = null) : ee.corkedRequestsFree = new e(ee), ee.bufferedRequestCount = 0;
    } else {
      for (; ge; ) {
        var w = ge.chunk, T = ge.encoding, O = ge.callback, L = ee.objectMode ? 1 : w.length;
        if (k(le, ee, !1, L, w, T, O), ge = ge.next, ee.bufferedRequestCount--, ee.writing)
          break;
      }
      ge === null && (ee.lastBufferedRequest = null);
    }
    ee.bufferedRequest = ge, ee.bufferProcessing = !1;
  }
  G.prototype._write = function(le, ee, ge) {
    ge(new p("_write()"));
  }, G.prototype._writev = null, G.prototype.end = function(le, ee, ge) {
    var Ae = this._writableState;
    return typeof le == "function" ? (ge = le, le = null, ee = null) : typeof ee == "function" && (ge = ee, ee = null), le != null && this.write(le, ee), Ae.corked && (Ae.corked = 1, this.uncork()), Ae.ending || pe(this, Ae, ge), this;
  }, Object.defineProperty(G.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function he(le) {
    return le.ending && le.length === 0 && le.bufferedRequest === null && !le.finished && !le.writing;
  }
  function ae(le, ee) {
    le._final(function(ge) {
      ee.pendingcb--, ge && C(le, ge), ee.prefinished = !0, le.emit("prefinish"), H(le, ee);
    });
  }
  function be(le, ee) {
    !ee.prefinished && !ee.finalCalled && (typeof le._final == "function" && !ee.destroyed ? (ee.pendingcb++, ee.finalCalled = !0, $t.nextTick(ae, le, ee)) : (ee.prefinished = !0, le.emit("prefinish")));
  }
  function H(le, ee) {
    var ge = he(ee);
    if (ge && (be(le, ee), ee.pendingcb === 0 && (ee.finished = !0, le.emit("finish"), ee.autoDestroy))) {
      var Ae = le._readableState;
      (!Ae || Ae.autoDestroy && Ae.endEmitted) && le.destroy();
    }
    return ge;
  }
  function pe(le, ee, ge) {
    ee.ending = !0, H(le, ee), ge && (ee.finished ? $t.nextTick(ge) : le.once("finish", ge)), ee.ended = !0, le.writable = !1;
  }
  function ke(le, ee, ge) {
    var Ae = le.entry;
    for (le.entry = null; Ae; ) {
      var Oe = Ae.callback;
      ee.pendingcb--, Oe(ge), Ae = Ae.next;
    }
    ee.corkedRequestsFree.next = le;
  }
  return Object.defineProperty(G.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(ee) {
      this._writableState && (this._writableState.destroyed = ee);
    }
  }), G.prototype.destroy = u.destroy, G.prototype._undestroy = u.undestroy, G.prototype._destroy = function(le, ee) {
    ee(le);
  }, o0;
}
var s0, dI;
function Yl() {
  if (dI)
    return s0;
  dI = 1;
  var e = Object.keys || function(f) {
    var c = [];
    for (var d in f)
      c.push(d);
    return c;
  };
  s0 = a;
  var t = $8(), r = A8();
  xc(a, t);
  for (var n = e(r.prototype), o = 0; o < n.length; o++) {
    var s = n[o];
    a.prototype[s] || (a.prototype[s] = r.prototype[s]);
  }
  function a(f) {
    if (!(this instanceof a))
      return new a(f);
    t.call(this, f), r.call(this, f), this.allowHalfOpen = !0, f && (f.readable === !1 && (this.readable = !1), f.writable === !1 && (this.writable = !1), f.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", l)));
  }
  Object.defineProperty(a.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(a.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(a.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function l() {
    this._writableState.ended || $t.nextTick(u, this);
  }
  function u(f) {
    f.end();
  }
  return Object.defineProperty(a.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(c) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = c, this._writableState.destroyed = c);
    }
  }), s0;
}
var hI = Qa.codes.ERR_STREAM_PREMATURE_CLOSE;
function nfe(e) {
  var t = !1;
  return function() {
    if (!t) {
      t = !0;
      for (var r = arguments.length, n = new Array(r), o = 0; o < r; o++)
        n[o] = arguments[o];
      e.apply(this, n);
    }
  };
}
function ife() {
}
function ofe(e) {
  return e.setHeader && typeof e.abort == "function";
}
function T8(e, t, r) {
  if (typeof t == "function")
    return T8(e, null, t);
  t || (t = {}), r = nfe(r || ife);
  var n = t.readable || t.readable !== !1 && e.readable, o = t.writable || t.writable !== !1 && e.writable, s = function() {
    e.writable || l();
  }, a = e._writableState && e._writableState.finished, l = function() {
    o = !1, a = !0, n || r.call(e);
  }, u = e._readableState && e._readableState.endEmitted, f = function() {
    n = !1, u = !0, o || r.call(e);
  }, c = function(m) {
    r.call(e, m);
  }, d = function() {
    var m;
    if (n && !u)
      return (!e._readableState || !e._readableState.ended) && (m = new hI()), r.call(e, m);
    if (o && !a)
      return (!e._writableState || !e._writableState.ended) && (m = new hI()), r.call(e, m);
  }, h = function() {
    e.req.on("finish", l);
  };
  return ofe(e) ? (e.on("complete", l), e.on("abort", d), e.req ? h() : e.on("request", h)) : o && !e._writableState && (e.on("end", s), e.on("close", s)), e.on("end", f), e.on("finish", l), t.error !== !1 && e.on("error", c), e.on("close", d), function() {
    e.removeListener("complete", l), e.removeListener("abort", d), e.removeListener("request", h), e.req && e.req.removeListener("finish", l), e.removeListener("end", s), e.removeListener("close", s), e.removeListener("finish", l), e.removeListener("end", f), e.removeListener("error", c), e.removeListener("close", d);
  };
}
var Kx = T8, a0, pI;
function sfe() {
  if (pI)
    return a0;
  pI = 1;
  var e;
  function t(E, C, I) {
    return C = r(C), C in E ? Object.defineProperty(E, C, { value: I, enumerable: !0, configurable: !0, writable: !0 }) : E[C] = I, E;
  }
  function r(E) {
    var C = n(E, "string");
    return typeof C == "symbol" ? C : String(C);
  }
  function n(E, C) {
    if (typeof E != "object" || E === null)
      return E;
    var I = E[Symbol.toPrimitive];
    if (I !== void 0) {
      var j = I.call(E, C || "default");
      if (typeof j != "object")
        return j;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (C === "string" ? String : Number)(E);
  }
  var o = Kx, s = Symbol("lastResolve"), a = Symbol("lastReject"), l = Symbol("error"), u = Symbol("ended"), f = Symbol("lastPromise"), c = Symbol("handlePromise"), d = Symbol("stream");
  function h(E, C) {
    return {
      value: E,
      done: C
    };
  }
  function p(E) {
    var C = E[s];
    if (C !== null) {
      var I = E[d].read();
      I !== null && (E[f] = null, E[s] = null, E[a] = null, C(h(I, !1)));
    }
  }
  function m(E) {
    $t.nextTick(p, E);
  }
  function y(E, C) {
    return function(I, j) {
      E.then(function() {
        if (C[u]) {
          I(h(void 0, !0));
          return;
        }
        C[c](I, j);
      }, j);
    };
  }
  var _ = Object.getPrototypeOf(function() {
  }), S = Object.setPrototypeOf((e = {
    get stream() {
      return this[d];
    },
    next: function() {
      var C = this, I = this[l];
      if (I !== null)
        return Promise.reject(I);
      if (this[u])
        return Promise.resolve(h(void 0, !0));
      if (this[d].destroyed)
        return new Promise(function($, V) {
          $t.nextTick(function() {
            C[l] ? V(C[l]) : $(h(void 0, !0));
          });
        });
      var j = this[f], J;
      if (j)
        J = new Promise(y(j, this));
      else {
        var G = this[d].read();
        if (G !== null)
          return Promise.resolve(h(G, !1));
        J = new Promise(this[c]);
      }
      return this[f] = J, J;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var C = this;
    return new Promise(function(I, j) {
      C[d].destroy(null, function(J) {
        if (J) {
          j(J);
          return;
        }
        I(h(void 0, !0));
      });
    });
  }), e), _), x = function(C) {
    var I, j = Object.create(S, (I = {}, t(I, d, {
      value: C,
      writable: !0
    }), t(I, s, {
      value: null,
      writable: !0
    }), t(I, a, {
      value: null,
      writable: !0
    }), t(I, l, {
      value: null,
      writable: !0
    }), t(I, u, {
      value: C._readableState.endEmitted,
      writable: !0
    }), t(I, c, {
      value: function(G, $) {
        var V = j[d].read();
        V ? (j[f] = null, j[s] = null, j[a] = null, G(h(V, !1))) : (j[s] = G, j[a] = $);
      },
      writable: !0
    }), I));
    return j[f] = null, o(C, function(J) {
      if (J && J.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var G = j[a];
        G !== null && (j[f] = null, j[s] = null, j[a] = null, G(J)), j[l] = J;
        return;
      }
      var $ = j[s];
      $ !== null && (j[f] = null, j[s] = null, j[a] = null, $(h(void 0, !0))), j[u] = !0;
    }), C.on("readable", m.bind(null, j)), j;
  };
  return a0 = x, a0;
}
var l0, gI;
function afe() {
  return gI || (gI = 1, l0 = function() {
    throw new Error("Readable.from is not available in the browser");
  }), l0;
}
var u0, bI;
function $8() {
  if (bI)
    return u0;
  bI = 1, u0 = $;
  var e;
  $.ReadableState = G, ur.EventEmitter;
  var t = function(z, b) {
    return z.listeners(b).length;
  }, r = S8, n = ut.Buffer, o = (typeof window < "u" || typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function s(K) {
    return n.from(K);
  }
  function a(K) {
    return n.isBuffer(K) || K instanceof o;
  }
  var l = Vx, u;
  l && l.debuglog ? u = l.debuglog("stream") : u = function() {
  };
  var f = Hue(), c = E8, d = R8, h = d.getHighWaterMark, p = Qa.codes, m = p.ERR_INVALID_ARG_TYPE, y = p.ERR_STREAM_PUSH_AFTER_EOF, _ = p.ERR_METHOD_NOT_IMPLEMENTED, S = p.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, x, E, C;
  xc($, r);
  var I = c.errorOrDestroy, j = ["error", "close", "destroy", "pause", "resume"];
  function J(K, z, b) {
    if (typeof K.prependListener == "function")
      return K.prependListener(z, b);
    !K._events || !K._events[z] ? K.on(z, b) : Array.isArray(K._events[z]) ? K._events[z].unshift(b) : K._events[z] = [b, K._events[z]];
  }
  function G(K, z, b) {
    e = e || Yl(), K = K || {}, typeof b != "boolean" && (b = z instanceof e), this.objectMode = !!K.objectMode, b && (this.objectMode = this.objectMode || !!K.readableObjectMode), this.highWaterMark = h(this, K, "readableHighWaterMark", b), this.buffer = new f(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = K.emitClose !== !1, this.autoDestroy = !!K.autoDestroy, this.destroyed = !1, this.defaultEncoding = K.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, K.encoding && (x || (x = Hl().StringDecoder), this.decoder = new x(K.encoding), this.encoding = K.encoding);
  }
  function $(K) {
    if (e = e || Yl(), !(this instanceof $))
      return new $(K);
    var z = this instanceof e;
    this._readableState = new G(K, this, z), this.readable = !0, K && (typeof K.read == "function" && (this._read = K.read), typeof K.destroy == "function" && (this._destroy = K.destroy)), r.call(this);
  }
  Object.defineProperty($.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(z) {
      this._readableState && (this._readableState.destroyed = z);
    }
  }), $.prototype.destroy = c.destroy, $.prototype._undestroy = c.undestroy, $.prototype._destroy = function(K, z) {
    z(K);
  }, $.prototype.push = function(K, z) {
    var b = this._readableState, w;
    return b.objectMode ? w = !0 : typeof K == "string" && (z = z || b.defaultEncoding, z !== b.encoding && (K = n.from(K, z), z = ""), w = !0), V(this, K, z, !1, w);
  }, $.prototype.unshift = function(K) {
    return V(this, K, null, !0, !1);
  };
  function V(K, z, b, w, T) {
    u("readableAddChunk", z);
    var O = K._readableState;
    if (z === null)
      O.reading = !1, Y(K, O);
    else {
      var L;
      if (T || (L = W(O, z)), L)
        I(K, L);
      else if (O.objectMode || z && z.length > 0)
        if (typeof z != "string" && !O.objectMode && Object.getPrototypeOf(z) !== n.prototype && (z = s(z)), w)
          O.endEmitted ? I(K, new S()) : M(K, O, z, !0);
        else if (O.ended)
          I(K, new y());
        else {
          if (O.destroyed)
            return !1;
          O.reading = !1, O.decoder && !b ? (z = O.decoder.write(z), O.objectMode || z.length !== 0 ? M(K, O, z, !1) : fe(K, O)) : M(K, O, z, !1);
        }
      else
        w || (O.reading = !1, fe(K, O));
    }
    return !O.ended && (O.length < O.highWaterMark || O.length === 0);
  }
  function M(K, z, b, w) {
    z.flowing && z.length === 0 && !z.sync ? (z.awaitDrain = 0, K.emit("data", b)) : (z.length += z.objectMode ? 1 : b.length, w ? z.buffer.unshift(b) : z.buffer.push(b), z.needReadable && te(K)), fe(K, z);
  }
  function W(K, z) {
    var b;
    return !a(z) && typeof z != "string" && z !== void 0 && !K.objectMode && (b = new m("chunk", ["string", "Buffer", "Uint8Array"], z)), b;
  }
  $.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, $.prototype.setEncoding = function(K) {
    x || (x = Hl().StringDecoder);
    var z = new x(K);
    this._readableState.decoder = z, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var b = this._readableState.buffer.head, w = ""; b !== null; )
      w += z.write(b.data), b = b.next;
    return this._readableState.buffer.clear(), w !== "" && this._readableState.buffer.push(w), this._readableState.length = w.length, this;
  };
  var k = 1073741824;
  function U(K) {
    return K >= k ? K = k : (K--, K |= K >>> 1, K |= K >>> 2, K |= K >>> 4, K |= K >>> 8, K |= K >>> 16, K++), K;
  }
  function Z(K, z) {
    return K <= 0 || z.length === 0 && z.ended ? 0 : z.objectMode ? 1 : K !== K ? z.flowing && z.length ? z.buffer.head.data.length : z.length : (K > z.highWaterMark && (z.highWaterMark = U(K)), K <= z.length ? K : z.ended ? z.length : (z.needReadable = !0, 0));
  }
  $.prototype.read = function(K) {
    u("read", K), K = parseInt(K, 10);
    var z = this._readableState, b = K;
    if (K !== 0 && (z.emittedReadable = !1), K === 0 && z.needReadable && ((z.highWaterMark !== 0 ? z.length >= z.highWaterMark : z.length > 0) || z.ended))
      return u("read: emitReadable", z.length, z.ended), z.length === 0 && z.ended ? ge(this) : te(this), null;
    if (K = Z(K, z), K === 0 && z.ended)
      return z.length === 0 && ge(this), null;
    var w = z.needReadable;
    u("need readable", w), (z.length === 0 || z.length - K < z.highWaterMark) && (w = !0, u("length less than watermark", w)), z.ended || z.reading ? (w = !1, u("reading or ended", w)) : w && (u("do read"), z.reading = !0, z.sync = !0, z.length === 0 && (z.needReadable = !0), this._read(z.highWaterMark), z.sync = !1, z.reading || (K = Z(b, z)));
    var T;
    return K > 0 ? T = ee(K, z) : T = null, T === null ? (z.needReadable = z.length <= z.highWaterMark, K = 0) : (z.length -= K, z.awaitDrain = 0), z.length === 0 && (z.ended || (z.needReadable = !0), b !== K && z.ended && ge(this)), T !== null && this.emit("data", T), T;
  };
  function Y(K, z) {
    if (u("onEofChunk"), !z.ended) {
      if (z.decoder) {
        var b = z.decoder.end();
        b && b.length && (z.buffer.push(b), z.length += z.objectMode ? 1 : b.length);
      }
      z.ended = !0, z.sync ? te(K) : (z.needReadable = !1, z.emittedReadable || (z.emittedReadable = !0, se(K)));
    }
  }
  function te(K) {
    var z = K._readableState;
    u("emitReadable", z.needReadable, z.emittedReadable), z.needReadable = !1, z.emittedReadable || (u("emitReadable", z.flowing), z.emittedReadable = !0, $t.nextTick(se, K));
  }
  function se(K) {
    var z = K._readableState;
    u("emitReadable_", z.destroyed, z.length, z.ended), !z.destroyed && (z.length || z.ended) && (K.emit("readable"), z.emittedReadable = !1), z.needReadable = !z.flowing && !z.ended && z.length <= z.highWaterMark, le(K);
  }
  function fe(K, z) {
    z.readingMore || (z.readingMore = !0, $t.nextTick(he, K, z));
  }
  function he(K, z) {
    for (; !z.reading && !z.ended && (z.length < z.highWaterMark || z.flowing && z.length === 0); ) {
      var b = z.length;
      if (u("maybeReadMore read 0"), K.read(0), b === z.length)
        break;
    }
    z.readingMore = !1;
  }
  $.prototype._read = function(K) {
    I(this, new _("_read()"));
  }, $.prototype.pipe = function(K, z) {
    var b = this, w = this._readableState;
    switch (w.pipesCount) {
      case 0:
        w.pipes = K;
        break;
      case 1:
        w.pipes = [w.pipes, K];
        break;
      default:
        w.pipes.push(K);
        break;
    }
    w.pipesCount += 1, u("pipe count=%d opts=%j", w.pipesCount, z);
    var T = (!z || z.end !== !1) && K !== $t.stdout && K !== $t.stderr, O = T ? ne : Me;
    w.endEmitted ? $t.nextTick(O) : b.once("end", O), K.on("unpipe", L);
    function L(N, R) {
      u("onunpipe"), N === b && R && R.hasUnpiped === !1 && (R.hasUnpiped = !0, ye());
    }
    function ne() {
      u("onend"), K.end();
    }
    var ue = ae(b);
    K.on("drain", ue);
    var oe = !1;
    function ye() {
      u("cleanup"), K.removeListener("close", Ce), K.removeListener("finish", Ie), K.removeListener("drain", ue), K.removeListener("error", me), K.removeListener("unpipe", L), b.removeListener("end", ne), b.removeListener("end", Me), b.removeListener("data", B), oe = !0, w.awaitDrain && (!K._writableState || K._writableState.needDrain) && ue();
    }
    b.on("data", B);
    function B(N) {
      u("ondata");
      var R = K.write(N);
      u("dest.write", R), R === !1 && ((w.pipesCount === 1 && w.pipes === K || w.pipesCount > 1 && Oe(w.pipes, K) !== -1) && !oe && (u("false write response, pause", w.awaitDrain), w.awaitDrain++), b.pause());
    }
    function me(N) {
      u("onerror", N), Me(), K.removeListener("error", me), t(K, "error") === 0 && I(K, N);
    }
    J(K, "error", me);
    function Ce() {
      K.removeListener("finish", Ie), Me();
    }
    K.once("close", Ce);
    function Ie() {
      u("onfinish"), K.removeListener("close", Ce), Me();
    }
    K.once("finish", Ie);
    function Me() {
      u("unpipe"), b.unpipe(K);
    }
    return K.emit("pipe", b), w.flowing || (u("pipe resume"), b.resume()), K;
  };
  function ae(K) {
    return function() {
      var b = K._readableState;
      u("pipeOnDrain", b.awaitDrain), b.awaitDrain && b.awaitDrain--, b.awaitDrain === 0 && t(K, "data") && (b.flowing = !0, le(K));
    };
  }
  $.prototype.unpipe = function(K) {
    var z = this._readableState, b = {
      hasUnpiped: !1
    };
    if (z.pipesCount === 0)
      return this;
    if (z.pipesCount === 1)
      return K && K !== z.pipes ? this : (K || (K = z.pipes), z.pipes = null, z.pipesCount = 0, z.flowing = !1, K && K.emit("unpipe", this, b), this);
    if (!K) {
      var w = z.pipes, T = z.pipesCount;
      z.pipes = null, z.pipesCount = 0, z.flowing = !1;
      for (var O = 0; O < T; O++)
        w[O].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var L = Oe(z.pipes, K);
    return L === -1 ? this : (z.pipes.splice(L, 1), z.pipesCount -= 1, z.pipesCount === 1 && (z.pipes = z.pipes[0]), K.emit("unpipe", this, b), this);
  }, $.prototype.on = function(K, z) {
    var b = r.prototype.on.call(this, K, z), w = this._readableState;
    return K === "data" ? (w.readableListening = this.listenerCount("readable") > 0, w.flowing !== !1 && this.resume()) : K === "readable" && !w.endEmitted && !w.readableListening && (w.readableListening = w.needReadable = !0, w.flowing = !1, w.emittedReadable = !1, u("on readable", w.length, w.reading), w.length ? te(this) : w.reading || $t.nextTick(H, this)), b;
  }, $.prototype.addListener = $.prototype.on, $.prototype.removeListener = function(K, z) {
    var b = r.prototype.removeListener.call(this, K, z);
    return K === "readable" && $t.nextTick(be, this), b;
  }, $.prototype.removeAllListeners = function(K) {
    var z = r.prototype.removeAllListeners.apply(this, arguments);
    return (K === "readable" || K === void 0) && $t.nextTick(be, this), z;
  };
  function be(K) {
    var z = K._readableState;
    z.readableListening = K.listenerCount("readable") > 0, z.resumeScheduled && !z.paused ? z.flowing = !0 : K.listenerCount("data") > 0 && K.resume();
  }
  function H(K) {
    u("readable nexttick read 0"), K.read(0);
  }
  $.prototype.resume = function() {
    var K = this._readableState;
    return K.flowing || (u("resume"), K.flowing = !K.readableListening, pe(this, K)), K.paused = !1, this;
  };
  function pe(K, z) {
    z.resumeScheduled || (z.resumeScheduled = !0, $t.nextTick(ke, K, z));
  }
  function ke(K, z) {
    u("resume", z.reading), z.reading || K.read(0), z.resumeScheduled = !1, K.emit("resume"), le(K), z.flowing && !z.reading && K.read(0);
  }
  $.prototype.pause = function() {
    return u("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (u("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function le(K) {
    var z = K._readableState;
    for (u("flow", z.flowing); z.flowing && K.read() !== null; )
      ;
  }
  $.prototype.wrap = function(K) {
    var z = this, b = this._readableState, w = !1;
    K.on("end", function() {
      if (u("wrapped end"), b.decoder && !b.ended) {
        var L = b.decoder.end();
        L && L.length && z.push(L);
      }
      z.push(null);
    }), K.on("data", function(L) {
      if (u("wrapped data"), b.decoder && (L = b.decoder.write(L)), !(b.objectMode && L == null) && !(!b.objectMode && (!L || !L.length))) {
        var ne = z.push(L);
        ne || (w = !0, K.pause());
      }
    });
    for (var T in K)
      this[T] === void 0 && typeof K[T] == "function" && (this[T] = /* @__PURE__ */ function(ne) {
        return function() {
          return K[ne].apply(K, arguments);
        };
      }(T));
    for (var O = 0; O < j.length; O++)
      K.on(j[O], this.emit.bind(this, j[O]));
    return this._read = function(L) {
      u("wrapped _read", L), w && (w = !1, K.resume());
    }, this;
  }, typeof Symbol == "function" && ($.prototype[Symbol.asyncIterator] = function() {
    return E === void 0 && (E = sfe()), E(this);
  }), Object.defineProperty($.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty($.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty($.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(z) {
      this._readableState && (this._readableState.flowing = z);
    }
  }), $._fromList = ee, Object.defineProperty($.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function ee(K, z) {
    if (z.length === 0)
      return null;
    var b;
    return z.objectMode ? b = z.buffer.shift() : !K || K >= z.length ? (z.decoder ? b = z.buffer.join("") : z.buffer.length === 1 ? b = z.buffer.first() : b = z.buffer.concat(z.length), z.buffer.clear()) : b = z.buffer.consume(K, z.decoder), b;
  }
  function ge(K) {
    var z = K._readableState;
    u("endReadable", z.endEmitted), z.endEmitted || (z.ended = !0, $t.nextTick(Ae, z, K));
  }
  function Ae(K, z) {
    if (u("endReadableNT", K.endEmitted, K.length), !K.endEmitted && K.length === 0 && (K.endEmitted = !0, z.readable = !1, z.emit("end"), K.autoDestroy)) {
      var b = z._writableState;
      (!b || b.autoDestroy && b.finished) && z.destroy();
    }
  }
  typeof Symbol == "function" && ($.from = function(K, z) {
    return C === void 0 && (C = afe()), C($, K, z);
  });
  function Oe(K, z) {
    for (var b = 0, w = K.length; b < w; b++)
      if (K[b] === z)
        return b;
    return -1;
  }
  return u0;
}
var C8 = go, pg = Qa.codes, lfe = pg.ERR_METHOD_NOT_IMPLEMENTED, ufe = pg.ERR_MULTIPLE_CALLBACK, ffe = pg.ERR_TRANSFORM_ALREADY_TRANSFORMING, cfe = pg.ERR_TRANSFORM_WITH_LENGTH_0, gg = Yl();
xc(go, gg);
function dfe(e, t) {
  var r = this._transformState;
  r.transforming = !1;
  var n = r.writecb;
  if (n === null)
    return this.emit("error", new ufe());
  r.writechunk = null, r.writecb = null, t != null && this.push(t), n(e);
  var o = this._readableState;
  o.reading = !1, (o.needReadable || o.length < o.highWaterMark) && this._read(o.highWaterMark);
}
function go(e) {
  if (!(this instanceof go))
    return new go(e);
  gg.call(this, e), this._transformState = {
    afterTransform: dfe.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", hfe);
}
function hfe() {
  var e = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
    yI(e, t, r);
  }) : yI(this, null, null);
}
go.prototype.push = function(e, t) {
  return this._transformState.needTransform = !1, gg.prototype.push.call(this, e, t);
};
go.prototype._transform = function(e, t, r) {
  r(new lfe("_transform()"));
};
go.prototype._write = function(e, t, r) {
  var n = this._transformState;
  if (n.writecb = r, n.writechunk = e, n.writeencoding = t, !n.transforming) {
    var o = this._readableState;
    (n.needTransform || o.needReadable || o.length < o.highWaterMark) && this._read(o.highWaterMark);
  }
};
go.prototype._read = function(e) {
  var t = this._transformState;
  t.writechunk !== null && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
};
go.prototype._destroy = function(e, t) {
  gg.prototype._destroy.call(this, e, function(r) {
    t(r);
  });
};
function yI(e, t, r) {
  if (t)
    return e.emit("error", t);
  if (r != null && e.push(r), e._writableState.length)
    throw new cfe();
  if (e._transformState.transforming)
    throw new ffe();
  return e.push(null);
}
var pfe = qf, k8 = C8;
xc(qf, k8);
function qf(e) {
  if (!(this instanceof qf))
    return new qf(e);
  k8.call(this, e);
}
qf.prototype._transform = function(e, t, r) {
  r(null, e);
};
var f0;
function gfe(e) {
  var t = !1;
  return function() {
    t || (t = !0, e.apply(void 0, arguments));
  };
}
var I8 = Qa.codes, bfe = I8.ERR_MISSING_ARGS, yfe = I8.ERR_STREAM_DESTROYED;
function mI(e) {
  if (e)
    throw e;
}
function mfe(e) {
  return e.setHeader && typeof e.abort == "function";
}
function vfe(e, t, r, n) {
  n = gfe(n);
  var o = !1;
  e.on("close", function() {
    o = !0;
  }), f0 === void 0 && (f0 = Kx), f0(e, {
    readable: t,
    writable: r
  }, function(a) {
    if (a)
      return n(a);
    o = !0, n();
  });
  var s = !1;
  return function(a) {
    if (!o && !s) {
      if (s = !0, mfe(e))
        return e.abort();
      if (typeof e.destroy == "function")
        return e.destroy();
      n(a || new yfe("pipe"));
    }
  };
}
function vI(e) {
  e();
}
function wfe(e, t) {
  return e.pipe(t);
}
function _fe(e) {
  return !e.length || typeof e[e.length - 1] != "function" ? mI : e.pop();
}
function Sfe() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var n = _fe(t);
  if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
    throw new bfe("streams");
  var o, s = t.map(function(a, l) {
    var u = l < t.length - 1, f = l > 0;
    return vfe(a, u, f, function(c) {
      o || (o = c), c && s.forEach(vI), !u && (s.forEach(vI), n(o));
    });
  });
  return t.reduce(wfe);
}
var Efe = Sfe;
(function(e, t) {
  t = e.exports = $8(), t.Stream = t, t.Readable = t, t.Writable = A8(), t.Duplex = Yl(), t.Transform = C8, t.PassThrough = pfe, t.finished = Kx, t.pipeline = Efe;
})(NS, NS.exports);
var M8 = NS.exports;
const xfe = /* @__PURE__ */ $n(M8);
var N8 = { exports: {} };
const Rfe = Vx, Afe = /([\x00-\x20<>"{}|^`\\]|%(?![0-9A-F][0-9A-F]))/g, Tfe = (e, t) => {
  let r = t.codePointAt(0).toString(16) + "";
  return r.length > 4 ? "\\U" + r.padStart(8, "0") : "\\u" + r.padStart(4, "0");
}, $h = (e) => e.replace(Afe, Tfe), Yx = /^(?:[\u0000-@[-`{-\u00bf\u00d7\u00f7\u0300-\u306f\u037e\u2000-\u200b\u200e-\u206f\u2190-\u2bff\u2ff0-\u3000\ud800-\uf8ff\ufdd0-\ufddf\ufffe\uffff].+|(?:.+?[\u0000-,\/:-@[-^`{-\u00b6\u00b8-\u00bf\u00d7\u00f7\u037e\u2000-\u200b\u200e-\u203e\u2041-\u206f\u2190-\u2bff\u2ff0-\u3000\ud800-\uf8ff\ufdd0-\ufddf\ufffe\uffff].*)|.+\.)$/, L8 = /^(?:\\|[\u0000-\/;-@[-^`{-\u00bf\u00d7\u00f7\u0300-\u306f\u037e\u2000-\u200b\u200e-\u206f\u2190-\u2bff\u2ff0-\u3000\ud800-\uf8ff\ufdd0-\ufddf\ufffe\uffff].+|(?:.+?(?:\\|[\u0000-,\/;-@[-^`{-\u00b6\u00b8-\u00bf\u00d7\u00f7\u037e\u2000-\u200b\u200e-\u203e\u2041-\u206f\u2190-\u2bff\u2ff0-\u3000\ud800-\uf8ff\ufdd0-\ufddf\ufffe\uffff]).+)|(?:.+?(?:\\|[\u0000-,.\/;-@[-^`{-\u00b6\u00b8-\u00bf\u00d7\u00f7\u037e\u2000-\u200b\u200e-\u203e\u2041-\u206f\u2190-\u2bff\u2ff0-\u3000\ud800-\uf8ff\ufdd0-\ufddf\ufffe\uffff])))$/, $fe = /^([Tt](rue)?|TRUE)$/, Cfe = /^([Ff](alse)?|FALSE)$/, kfe = "xxxxxxxx_xxxx_4xxx_yxxx_xxxxxxxxxxxx", Ife = /[xy]/g, Qu = () => {
  let e = Date.now();
  return typeof performance < "u" && (e += performance.now()), kfe.replace(Ife, (t) => {
    let r = (e + Math.random() * 16) % 16 | 0;
    return e = Math.floor(e / 16), (t === "x" ? r : r & 3 | 8).toString(16);
  });
}, bg = Symbol("prefix-cache"), Mfe = /[$^*()+[\\{}|.?]/g, Nfe = "((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_:0-9]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&'()*+,;=/?#@%])(?:(?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}.:]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&'()*+,;=/?#@%])*(?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}:]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&'()*+,;=/?#@%]))?)$";
function wI(e, t = !1) {
  let r = [], n = {};
  for (let o in e) {
    let s = e[o];
    t && Yx.test(o) || (n[s] = o, r.push(s.replace(Mfe, "\\$&")));
  }
  return r.length ? (e[bg] = {
    _r_iris: new RegExp(`^(${r.join("|")})${Nfe}`, "u"),
    _h_inverse: n
  }, Object.freeze(e)) : e;
}
const O8 = (e, t) => {
  let r = t[bg];
  if (r) {
    let n = r._r_iris.exec(e);
    if (n)
      return r._h_inverse[n[1]] + ":" + n[2];
  } else {
    let n = "", o = "", s = -1;
    for (let a in t) {
      let l = t[a];
      if (e.indexOf(l) === 0 && l.length > s && !Yx.test(a)) {
        let u = e.slice(l.length);
        L8.test(u) || (o = u, n = a, s = l.length);
      }
    }
    if (s !== -1)
      return n + ":" + o;
  }
  return "<" + e + ">";
}, Rc = (e, t = {}) => {
  let r = t[bg];
  if (r) {
    let n = r._r_iris.exec(e);
    if (n)
      return r._h_inverse[n[1]] + ":" + n[2];
  } else {
    let n = "", o = -1;
    for (let s in t) {
      let a = t[s];
      e.startsWith(a) && a.length > o && (n = s, o = a.length);
    }
    if (o !== -1)
      return n + ":" + e.slice(o);
  }
  return ">" + e;
}, Lfe = /^([^:]*):(.*)$/;
function P8(e, t = {}, r = !1) {
  switch (e[0]) {
    case ">":
      return "<" + e.slice(1) + ">";
    case "_":
      return e.length <= 2 || e[2] === "#" ? new Wf()[r ? "verbose" : "terse"]() : e;
    case '"':
      return JSON.stringify(e.slice(1));
    case "@": {
      let n = e.indexOf('"');
      return JSON.stringify(e.slice(n + 1)) + e.slice(0, n);
    }
    case "^": {
      let n = e.indexOf('"');
      return JSON.stringify(e.slice(n + 1)) + "^^" + P8(e.slice(1, n), t, r);
    }
    case "*":
      return "";
    case "<":
    case "`":
      return Qe.c1(e).terse(t);
    default: {
      if (e === "a")
        return r ? "<http://www.w3.org/1999/02/22-rdf-syntax-ns#type>" : "a";
      let [, n, o] = Lfe.exec(e);
      return r || L8.test(o) || Yx.test(n) ? "<" + t[n] + o + ">" : e;
    }
  }
}
class Ss {
  valueOf() {
    return this.concise();
  }
  toString() {
    return this.concise();
  }
  equals(t) {
    return t ? this === t || t.termType === this.termType && t.value === this.value : !1;
  }
}
Object.assign(Ss.prototype, {
  isGraphyTerm: !0
});
class er extends Ss {
  constructor(t) {
    super(), this.value = t;
  }
  concise(t = {}) {
    return Rc(this.value, t);
  }
  terse(t = {}, r = !1) {
    return O8($h(this.value), t);
  }
  verbose() {
    return "<" + $h(this.value) + ">";
  }
  isolate() {
    return {
      termType: "NamedNode",
      value: this.value
    };
  }
}
Object.assign(er.prototype, {
  termType: "NamedNode",
  isNamedNode: !0
});
const PS = new er("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
PS.isRdfTypeAlias = !0;
const D8 = new er("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString"), Ofe = D8.isolate(), Pfe = new er("http://www.w3.org/1999/02/22-rdf-syntax-ns#first"), _I = new er("http://www.w3.org/1999/02/22-rdf-syntax-ns#rest"), Dfe = new er("http://www.w3.org/1999/02/22-rdf-syntax-ns#nil"), Ffe = new er("http://www.w3.org/2001/XMLSchema#date"), jfe = new er("http://www.w3.org/2001/XMLSchema#dateTime"), Qo = new er("http://www.w3.org/2001/XMLSchema#string");
class yg extends Ss {
  equals(t) {
    return t ? this === t || t.termType === "Literal" && t.value === this.value && this.datatype.equals(t.datatype) && t.language === this.language : !1;
  }
  verbose() {
    return JSON.stringify(this.value) + (this.language ? "@" + this.language : "^^" + this.datatype.verbose());
  }
  concise(t) {
    return this.language ? "@" + this.language + '"' + this.value : "^" + Rc(this.datatype.value, t) + '"' + this.value;
  }
  terse(t = {}) {
    let r = this.datatype.terse(t);
    return JSON.stringify(this.value) + (this.language ? "@" + this.language : "^^" + r);
  }
  isolate() {
    return {
      termType: "Literal",
      value: this.value,
      language: this.language,
      datatype: this.datatype.isolate()
    };
  }
}
Object.assign(yg.prototype, {
  datatype: Qo,
  language: "",
  termType: "Literal",
  isLiteral: !0,
  isSimple: !1
});
class Zu extends yg {
  constructor(t, r) {
    super(), this.value = t, this.language = (r[0] === "@" ? r.slice(1) : r).toLowerCase();
  }
  verbose() {
    return JSON.stringify(this.value) + "@" + this.language;
  }
  concise() {
    return "@" + this.language + '"' + this.value;
  }
  terse() {
    return JSON.stringify(this.value) + "@" + this.language;
  }
  isolate() {
    return {
      termType: "Literal",
      value: this.value,
      language: this.language,
      datatype: Ofe
    };
  }
}
Object.assign(Zu.prototype, {
  datatype: D8,
  isLanguaged: !0
});
class vu extends yg {
  verbose() {
    return JSON.stringify(this.value) + "^^" + this.datatype.verbose();
  }
  concise(t) {
    return "^" + Rc(this.datatype.value, t) + '"' + this.value;
  }
  terse(t = {}) {
    let r = this.datatype.terse(t);
    return JSON.stringify(this.value) + "^^" + r;
  }
  isolate() {
    return {
      termType: "Literal",
      value: this.value,
      language: this.language,
      datatype: this.datatype.isolate()
    };
  }
}
Object.assign(vu.prototype, {
  isDatatyped: !0
});
class gd extends vu {
  constructor(t, r) {
    super(), this.value = t, this.datatype = r;
  }
}
class F8 extends Ss {
  constructor(t) {
    super(), this.value = t;
  }
  get isSimple() {
    return !this.language && !this.datatype.equals(Qo);
  }
  get isLanguaged() {
    return !!this.language;
  }
  get isDatatyped() {
    return Qo.equals(this.datatype);
  }
  equals(t) {
    return t ? this === t || t.termType === "Literal" && t.value === this.value && this.datatype.equals(t.datatype) && t.language === this.language : !1;
  }
  verbose() {
    return JSON.stringify(this.value) + (this.language ? "@" + this.language : "^^" + this.datatype.verbose());
  }
  concise(t) {
    return this.language ? "@" + this.language + '"' + this.value : "^" + Rc(this.datatype.value, t) + '"' + this.value;
  }
  terse(t = {}) {
    let r = this.datatype.terse(t);
    return JSON.stringify(this.value) + (this.language ? "@" + this.language : "^^" + r);
  }
  isolate() {
    return {
      termType: "Literal",
      value: this.value,
      language: this.language,
      datatype: this.datatype.isolate()
    };
  }
}
Object.assign(F8.prototype, {
  datatype: Qo,
  language: "",
  termType: "Literal",
  isLiteral: !0
});
class Hs extends yg {
  constructor(t) {
    super(), this.value = t;
  }
  verbose() {
    return JSON.stringify(this.value);
  }
  concise() {
    return '"' + this.value;
  }
  terse() {
    return JSON.stringify(this.value);
  }
}
Object.assign(Hs.prototype, {
  isSimple: !0
});
const j8 = new er("http://www.w3.org/2001/XMLSchema#integer");
class ha extends vu {
  static from(t) {
    let r = new ha(+t);
    return r.value = t, r;
  }
  constructor(t) {
    super(), this.value = t + "", this.number = t;
  }
  concise(t = {}) {
    return "^" + j8.concise(t) + '"' + this.value;
  }
  terse() {
    return this.value.includes("e") ? `"${this.value}"^^<http://www.w3.org/2001/XMLSchema#integer>` : this.value;
  }
}
Object.assign(ha.prototype, {
  datatype: j8,
  isNumeric: !0,
  isInteger: !0
});
const Ac = new er("http://www.w3.org/2001/XMLSchema#double");
class Ei extends vu {
  static from(t) {
    let r = new Ei(+t);
    return r.value = t, r;
  }
  constructor(t) {
    super(), this.value = t + "", this.number = t;
  }
  concise(t = {}) {
    return "^" + Ac.concise(t) + '"' + this.value;
  }
  terse() {
    return this.number.toExponential();
  }
}
Object.assign(Ei.prototype, {
  datatype: Ac,
  isNumeric: !0,
  isDouble: !0
});
const B8 = new er("http://www.w3.org/2001/XMLSchema#decimal");
class pa extends vu {
  static from(t) {
    let r = new pa(+t);
    return r.value = t, r;
  }
  constructor(t) {
    super(), this.value = t + "", this.number = t;
  }
  concise(t = {}) {
    return "^" + B8.concise(t) + '"' + this.value;
  }
  terse() {
    return this.value.includes("e") ? `"${this.value}"^^<http://www.w3.org/2001/XMLSchema#decimal>` : this.value + (this.value.includes(".") ? "" : ".0");
  }
}
Object.assign(pa.prototype, {
  datatype: B8,
  isNumeric: !0,
  isDecimal: !0
});
const q8 = new er("http://www.w3.org/2001/XMLSchema#boolean");
class hi extends vu {
  static from(t) {
    let r = new hi(+t);
    return r.value = t, r;
  }
  constructor(t) {
    super(), this.value = t + "", this.boolean = t;
  }
  concise(t = {}) {
    return "^" + q8.concise(t) + '"' + this.value;
  }
  terse() {
    return this.value + "";
  }
}
Object.assign(hi.prototype, {
  datatype: q8,
  isBoolean: !0
});
class W8 extends Ei {
  constructor() {
    super(1 / 0), this.value = "INF";
  }
  terse(t) {
    return '"INF"^^' + Ac.terse(t);
  }
}
Object.assign(W8.prototype, {
  isInfinite: !0
});
class U8 extends Ei {
  constructor() {
    super(-1 / 0), this.value = "-INF";
  }
  terse(t) {
    return '"-INF"^^' + Ac.terse(t);
  }
}
Object.assign(U8.prototype, {
  isInfinite: !0
});
class H8 extends Ei {
  constructor() {
    super(NaN), this.value = "NaN";
  }
  terse(t) {
    return '"NaN"^^' + Ac.terse(t);
  }
}
Object.assign(H8.prototype, {
  isNaN: !0
});
function Js(e, t = !1) {
  this.value = e, this.isAnonymous = t;
}
Js.prototype = Object.assign(
  Object.create(Ss.prototype),
  {
    termType: "BlankNode",
    isBlankNode: !0,
    concise() {
      return "_:" + this.value;
    },
    terse() {
      return "_:" + this.value;
    },
    verbose() {
      return "_:" + this.value;
    },
    isolate() {
      return {
        termType: "BlankNode",
        value: this.value
      };
    }
  }
);
function Wf() {
}
Wf.prototype = Object.assign(
  Object.create(Js.prototype),
  {
    isAnonymous: !0,
    isEphemeral: !0,
    concise() {
      return "_:#" + this.value;
    },
    terse() {
      return "[]";
    },
    verbose() {
      return "_:" + this.value;
    },
    isolate() {
      return {
        termType: "BlankNode",
        value: this.value
      };
    },
    equals() {
      return !1;
    }
  }
);
Object.defineProperty(Wf.prototype, "value", {
  get() {
    return "_" + Qu();
  }
});
class z8 extends Ss {
  constructor(t) {
    super(), this.value = t;
  }
  concise() {
    return "?" + this.value;
  }
  terse() {
    throw new Error("Cannot call .terse() on 'Variable' term type");
  }
  verbose() {
    throw new Error("Cannot call .verbose() on 'Variable' term type");
  }
  isolate() {
    return {
      termType: "Variable",
      value: this.value
    };
  }
}
Object.assign(z8.prototype, {
  termType: "Variable",
  isVariable: !0
});
function Uf() {
}
Uf.prototype = Object.assign(
  Object.create(Ss.prototype),
  {
    value: "",
    termType: "DefaultGraph",
    isDefaultGraph: !0,
    concise() {
      return "*";
    },
    terse() {
      return "";
    },
    verbose() {
      return "";
    },
    isolate() {
      return {
        termType: "DefaultGraph",
        value: ""
      };
    }
  }
);
Object.assign(
  Object.create(Ss.prototype),
  {
    value: "",
    termType: "NoGraph",
    concise() {
      return "";
    },
    terse() {
      return "";
    },
    verbose() {
      return "";
    },
    isolate() {
      return {
        termType: "NoGraph",
        value: ""
      };
    }
  }
);
const Ch = new Uf();
function jn(e, t, r, n = Ch) {
  this.subject = e, this.predicate = t, this.object = r, this.graph = n;
}
Object.assign(jn.prototype, {
  isGraphyQuad: !0,
  equals(e) {
    return e ? this === e || this.object.equals(e.object) && this.subject.equals(e.subject) && this.predicate.equals(e.predicate) && this.graph.equals(e.graph) : !1;
  },
  valueOf() {
    return this.verbose();
  },
  concise(e = {}) {
    return [
      this.subject.concise(e),
      this.predicate.concise(e),
      this.object.concise(e),
      this.graph.concise(e)
    ];
  },
  terse(e) {
    let t = this.graph.isDefaultGraph;
    return (t ? "" : this.graph.terse(e) + " { ") + this.subject.terse(e) + " " + this.predicate.terse(e) + " " + this.object.terse(e) + " ." + (t ? "" : " }");
  },
  verbose() {
    return this.subject.verbose() + " " + this.predicate.verbose() + " " + this.object.verbose() + " " + (this.graph.isDefaultGraph ? "" : this.graph.verbose() + " ") + ".";
  },
  isolate() {
    return {
      subject: this.subject.isolate(),
      predicate: this.predicate.isolate(),
      object: this.object.isolate(),
      graph: this.graph.isolate()
    };
  }
});
let SI = {
  namedNode(e) {
    return new er(e);
  },
  blankNode(e, t) {
    return new Js(e, t);
  },
  literal(e) {
    return new F8(e);
  },
  defaultGraph() {
    return new Uf();
  },
  quad(e, t, r, n) {
    return new jn(e, t, r, n || Ch);
  },
  integer(e) {
    return ha.from(e);
  },
  double(e) {
    return Ei.from(e);
  },
  decimal(e) {
    return pa.from(e);
  },
  boolean(e) {
    return new hi(e);
  }
};
const Qe = N8.exports = {
  concise: Rc,
  adopt(e) {
    let t = Object.create(e), r = !1;
    if (typeof e.boolean != "function") {
      let n = e.namedNode("http://www.w3.org/2001/XMLSchema#boolean");
      t.boolean = (o) => e.literal(o + "", n), r = !0;
    }
    if (typeof e.double != "function") {
      let n = e.namedNode("http://www.w3.org/2001/XMLSchema#double");
      t.double = (o) => e.literal(o + "", n), r = !0;
    }
    if (typeof e.decimal != "function") {
      let n = e.namedNode("http://www.w3.org/2001/XMLSchema#decimal");
      t.decimal = (o) => e.literal(o + "", n), r = !0;
    }
    if (typeof e.integer != "function") {
      let n = e.namedNode("http://www.w3.org/2001/XMLSchema#integer");
      t.integer = (o) => e.literal(o + "", n), r = !0;
    }
    return typeof e.simpleLiteral != "function" && (t.simpleLiteral = (n) => e.literal(n), r = !0), typeof e.languagedLiteral != "function" && (t.languagedLiteral = (n, o) => e.literal(n, o), r = !0), typeof e.datatypedLiteral != "function" && (t.datatypedLiteral = (n, o) => e.literal(n, o), r = !0), r ? t : e;
  },
  raw: SI,
  unfiltered: {
    ...SI,
    literal(e, t) {
      return !t || Qo.equals(t) ? new Hs(e) : typeof t == "string" ? new Zu(e, t) : Qo.equals(t) ? new Hs(e) : new gd(e, t);
    },
    simpleLiteral(e) {
      return new Hs(e);
    },
    languagedLiteral(e, t) {
      return new Zu(e, t);
    },
    datatypedLiteral(e, t) {
      return Qo.equals(t) ? new Hs(e) : new gd(e, t);
    }
  },
  number(e) {
    return typeof e == "number" && (!Number.isFinite(e) || Number.isNaN(e)) ? Qe.double(e) : Number.isInteger(e) || typeof e == "bigint" ? Qe.integer(e) : Qe.decimal(e);
  },
  date(e) {
    return Qe.literal(e.toISOString().replace(/T.+$/, "Z"), Ffe);
  },
  dateTime(e) {
    return Qe.literal(e.toISOString(), jfe);
  },
  namedNode(e) {
    return new er(e);
  },
  ephemeral() {
    return new Wf();
  },
  // @deprecated
  anonymous() {
    return new Wf();
  },
  blankNode(e) {
    if (e) {
      if (typeof e == "string")
        return new Js(e);
    } else
      return new Js("_" + Qu(), !0);
    throw new TypeError(`factory.blankNode(label) expects 'label' parameter to be falsy or a string; instead found: ${e}`);
  },
  literal(e, t) {
    return !t || Qo.equals(t) ? new Hs(e) : typeof t == "string" ? new Zu(e, t) : new gd(e, t);
  },
  integer(e) {
    let t = typeof e;
    if (t === "number") {
      if (Number.isFinite(e)) {
        if (!Number.isInteger(e))
          throw new Error("Number is not an integer: " + e);
      } else
        throw Number.isNaN(e) ? new Error("XSD integer cannot encode NaN. Try using double") : new Error("XSD integer cannot encode +/-infinity. Try using double");
      return new ha(e);
    } else if (t === "string") {
      if (e === "")
        throw new Error("Refusing to serialize empty string as xsd:integer");
      let r = +e;
      if (Number.isNaN(r) || !Number.isInteger(r))
        throw new Error("Invalid integer string: " + e);
      return new ha(r);
    } else
      throw t === "undefined" ? new Error("Refusing to serialize undefined value as xsd:integer") : e === null ? new Error("Refusing to serialize null value as xsd:integer") : new Error("XSD integer expects a number type or integer string");
  },
  double(e) {
    let t = typeof e;
    if (t === "number")
      return Number.isFinite(e) ? new Ei(e) : Number.isNaN(e) ? new H8() : e > 0 ? new W8() : new U8();
    if (t === "string") {
      if (e === "")
        throw new Error("Refusing to serialize empty string as xsd:double");
      let r = +e;
      if (Number.isNaN(r))
        throw new Error("Invalid decimal string: " + e);
      return new Ei(r);
    } else
      throw t === "undefined" ? new Error("Refusing to serialize undefined value as xsd:double") : e === null ? new Error("Refusing to serialize null value as xsd:double") : new Error("XSD double expects a number type or double string");
  },
  decimal(e) {
    let t = typeof e;
    if (t === "number") {
      if (!Number.isFinite(e))
        throw Number.isNaN(e) ? new Error("XSD decimal cannot encode NaN. Try using double") : new Error("XSD decimal cannot encode +/-infinity. Try using double");
      return new pa(e);
    } else if (t === "string") {
      if (e === "")
        throw new Error("Refusing to serialize empty string as xsd:decimal");
      let r = +e;
      if (Number.isNaN(r))
        throw new Error("Invalid decimal string: " + e);
      return new pa(r);
    } else
      throw t === "undefined" ? new Error("Refusing to serialize undefined value as xsd:decimal") : e === null ? new Error("Refusing to serialize null value as xsd:decimal") : new Error("XSD decimal expects a number type or decimal string");
  },
  boolean(e) {
    let t = typeof e;
    if (t === "boolean")
      return new hi(e);
    if (t === "number") {
      if (e === 1)
        return new hi(!0);
      if (e === 0)
        return new hi(!1);
      throw new Error("Boolean value 'w_value' must be either a '1' or '0' if using numbers");
    } else if (t === "string") {
      if ($fe.test(e))
        return new hi(!0);
      if (Cfe.test(e))
        return new hi(!1);
      throw e === "" ? new Error("Refusing to serialize empty string as xsd:boolean") : new Error("Invalid boolean string: " + e);
    } else
      throw t === "undefined" ? new Error("Refusing to serialize undefined value as xsd:boolean") : e === null ? new Error("Refusing to serialize null value as xsd:boolean") : new Error("XSD boolean expects a boolean type or boolean string");
  },
  defaultGraph() {
    return new Uf();
  },
  variable(e) {
    return new z8(e);
  },
  // warn
  triple(e, t, r) {
    let n = new Error("It is strongly encouraged to use .quad() instead of .triple()");
    return console.warn(n.stack.replace(/^(\s*)Error:/, "$1Warning:")), new jn(e, t, r);
  },
  quad(e, t, r, n) {
    return new jn(e, t, r, n || Ch);
  },
  term(e, t) {
    return typeof e == "string" ? Qe.c1(e, t) : Qe.from.rdfjs_term(e);
  },
  /**
   * construct a term object from a concise term string
   * @param  {c1_string} sc1_term - a representation of the term object to create
   * @param  {Object} h_prefixes - mappings for prefixes
   * @return {Term} - an RDFJS-compatible term object
   */
  c1(e, t = {}) {
    switch (e[0]) {
      case "^": {
        let r = e.indexOf('"');
        if (r === -1)
          throw new Error(`Invalid concise-term string, no content literal delimiter found: '${e}'`);
        let n = e.slice(1, r);
        return Qe.literal(e.slice(r + 1), Qe.c1_node_explicit(n, t));
      }
      case "@": {
        let r = e.indexOf('"');
        if (r === -1)
          throw new Error(`Invalid concise-term string, no content literal delimiter found: '${e}'`);
        let n = e.slice(1, r);
        return Qe.literal(e.slice(r + 1), n);
      }
      case '"':
        return Qe.literal(e.slice(1));
      default:
        return Qe.c1_node(e, t);
    }
  },
  // construct a term object from a concise term string for nodes
  c1_node(e, t = {}) {
    if (e === "a")
      return PS;
    if (e === "*")
      return Qe.defaultGraph();
    if (e[0] === "_") {
      if (e[1] !== ":")
        throw new Error(`Invliad concise-term string, prefixes are not allowed to start with an underscore: '${e}'`);
      return e[2] === "#" || e.length === 2 ? Qe.ephemeral() : Qe.blankNode(e.slice(2));
    }
    return Qe.c1_node_explicit(e, t);
  },
  // construct a named node
  c1_named_node(e, t = {}) {
    return e === "a" ? PS : Qe.c1_node_explicit(e, t);
  },
  // construct a term object from a concise term string for nodes (no shortcuts)
  c1_node_explicit(e, t = {}) {
    switch (e[0]) {
      case ">":
        return Qe.namedNode(e.slice(1));
      case "<":
        throw new Error(`Whoops! It looks like this concise-term string starts with a '<' character. Remember to use '>' if you are trying to make an absolute IRI reference.
Invalid concise-term string '${e}'`);
      case "`":
        throw new Error(`The backtick character '\`' is reserved for concise-struct key directives and should not be used in the object position.
Invalid concise-term string '${e}'`);
      default:
        return this.c1_prefixed_node(e, t);
    }
  },
  // construct a term object from a concise term string for prefixed nodes
  c1_prefixed_node(e, t = {}) {
    let r = e.indexOf(":");
    if (r === -1)
      throw new Error(`A relative or prefixed node must include a ':' character. 
Invalid concise-term string for node: '${e}'`);
    let n = e.slice(0, r), o = e.slice(r + 1);
    if (n in t)
      return Qe.namedNode(t[n] + o);
    throw new Error(`Prefix not defined: '${n}'`);
  },
  c1_to_nt: P8,
  *quads(e, t = {}) {
    for (let r in e)
      yield* Qe.triples(e[r], t, r);
  },
  *triples(e, t = {}, r = "*") {
    let n = Qe.c1(r, t);
    for (let o in e) {
      let s = Qe.c1(o, t), a = e[o];
      yield* Qe.pairs(n, s, a, t);
    }
  },
  *pairs(e, t, r, n = {}) {
    for (let o in r) {
      let s = Qe.c1(o, n), a = r[o];
      yield* Qe.objects(e, t, s, a, n);
    }
  },
  *collection(e, t, r, n = {}) {
    yield* Qe.objects(e, t, Pfe, r[0], n);
    let o = r.slice(1);
    if (!o.length)
      yield new jn(t, _I, Dfe, e);
    else {
      let s = Qe.blankNode();
      yield new jn(t, _I, s, e), yield* Qe.collection(e, s, o, n);
    }
  },
  *objects(e, t, r, n, o, s = !1) {
    switch (typeof n) {
      case "string": {
        yield new jn(t, r, Qe.c1(n, o), e);
        break;
      }
      case "number": {
        yield new jn(t, r, Qe.number(n), e);
        break;
      }
      case "object": {
        if (Array.isArray(n))
          if (s) {
            let l = Qe.blankNode();
            yield new jn(t, r, l, e), yield* Qe.collection(e, l, n, o);
          } else
            for (let l of n)
              yield* Qe.objects(e, t, r, l, o, !0);
        else {
          let l = Qe.blankNode();
          yield new jn(t, r, l, e), yield* Qe.pairs(e, l, n, o);
        }
        break;
      }
      default:
        throw new Error(`invalid object type: ${typeof n}`);
    }
  },
  from: {
    term(e) {
      return e === null || e.isGraphyTerm ? e : Qe.from.rdfjs_term(e);
    },
    quad(e) {
      if (e === null || e.isGraphyQuad)
        return e;
      let t = Qe.from;
      return new jn(
        t.rdfjs_term(e.subject),
        t.rdfjs_term(e.predicate),
        t.rdfjs_term(e.object),
        e.graph ? t.rdfjs_term(e.graph) : Ch
      );
    },
    rdfjs_term(e) {
      switch (e.termType) {
        case "NamedNode":
          return new er(e.value);
        case "BlankNode":
          return new Js(e.value);
        case "Literal":
          return Qe.literal(e.value, e.language ? e.language : e.datatype ? new er(e.datatype.value) : null);
        case "DefaultGraph":
          return new Uf();
        default:
          throw new TypeError(`invalid termType: ${e.termType}`);
      }
    },
    sparql_result(e) {
      switch (e.type) {
        case "uri":
          return new er(e.value);
        case "literal":
        case "typed-literal":
          return "xml:lang" in e ? new Zu(e.value, e["xml:lang"]) : "datatype" in e && e.datatype !== "http://www.w3.org/2001/XMLSchema#string" ? new gd(e.value, new er(e.datatype)) : new Hs(e.value);
        case "bnode":
          return new Js(e.value);
        default:
          throw new Error(`unexpected SPARQL Result JSON Format Term type: ${e.type}`);
      }
    }
  },
  to: {
    boolean: (e) => hi.from(e),
    integer: (e) => ha.from(e),
    decimal: (e) => pa.from(e),
    double: (e) => Ei.from(e)
  },
  /**
   * @param  {Object} gc_comment -
   * @return {string} a `concise-term string` directive to be used as a key in `concise-term structs`
   * 	in order to write a comment to the document (only works with supporting serializers)
   */
  comment(e = {}) {
    return `\`[${Qu()}]${JSON.stringify({ ...e, type: "comment" })}`;
  },
  /**
   * @param  {integer} [line_count=1] - number of newlines to insert
   * @return {string} a `concise-term string` directive to be used as a key in `concise-term structs`
   * 	in order to write the given number of newlines to the document (only works with supporting serializers)
   */
  newlines() {
    return `\`[${Qu()}]{"type":"newlines"}`;
  },
  /**
   * @param {string} s_key - key that identifies which aspect to configure. e.g., 'lists'
   * @return {string} a `concise-term string` directive to be used as a key in `concise-term structs`
   * 	in order to write the given number of newlines to the document (only works with supporting serializers)
   */
  config(e) {
    if (typeof e != "string")
      throw new TypeError(`Expected 'key' argument to be a string, instead found ${typeof e}`);
    return `\`[${Qu()}]{"type":"config","value":${JSON.stringify(e)}}`;
  },
  /**
   * @param {AnyQuad} g_quad - quad to hash
   * @return {string} a sha256 hash of the quad
   */
  hash(e) {
    let t = Qe.from.quad(e), r = Rfe.createHash("sha256");
    return r.update(t.verbose()), r.digest("hex");
  },
  cache_prefixes: wI,
  cachePrefixes: wI,
  terse: O8,
  clean_iri: $h,
  cleanIri: $h,
  $_PREFIX_CACHE: bg
};
Object.assign(Qe, {
  c3: Qe.triples,
  c4: Qe.quads,
  fromTerm: Qe.from.term,
  fromQuad: Qe.from.quad
});
var Bfe = N8.exports;
const EI = /* @__PURE__ */ $n(Bfe);
class G8 {
  constructor(t) {
    this.term = t;
  }
  toTerm() {
    const t = `"""${this.term.value.replace(/"$/, '\\"')}"""`;
    return {
      terse: (r) => t + this.langOrDatatype(r),
      verbose: (r) => t + this.langOrDatatype(r)
    };
  }
  langOrDatatype(t) {
    if (this.term.language)
      return `@${this.term.language}`;
    if (this.term.datatype.equals(yf.string))
      return "";
    const r = uD(this.term.datatype.value, t);
    return r ? `^^${r}` : `^^<${this.term.datatype.value}>`;
  }
}
const V8 = /* @__PURE__ */ new Map([[G8, (e) => e.toTerm()]]);
function qfe(e) {
  return e.has(Bn.first) && e.has(Bn.rest);
}
class Wfe extends xfe.Transform {
  constructor({
    prefixes: t = {},
    strict: r = !1,
    preserveListNodeProperties: n = !1
  } = {}) {
    super({ objectMode: !0 }), this.prefixes = t, this.graphs = new Vu(), this.blankNodes = new Vu(), this.strict = r, this.preserveListNodeProperties = n;
  }
  _transform({ subject: t, predicate: r, object: n, graph: o }, s, a) {
    const l = this.getGraph(o), u = l.get(t) || { predicates: new Vu() }, f = u.predicates.get(r) || [];
    if (u.predicates.set(r, [...f, n]), n.termType === "BlankNode") {
      const c = this.blankNodes.get(n) || 0;
      this.blankNodes.set(n, c + 1);
    }
    l.set(t, u), a();
  }
  _flush() {
    const t = [...this.graphs].reduce((r, [n, o]) => {
      const s = this.toHashKey(n);
      let a = r[s] || {};
      return a = [...o].reduce(
        this.toConciseHash(n).bind(this),
        a
      ), {
        ...r,
        [s]: a
      };
    }, {});
    this.push({
      type: this.strict ? "c4r" : "c4",
      value: t
    }), this.push(null);
  }
  toConciseHash(t) {
    return (r, [n, { predicates: o }]) => {
      if (!this.strict && this.blankNodes.get(n) === 1)
        return r;
      const s = this.toHashKey(n);
      return {
        ...r,
        [s]: this.createPropertyMap(t, o)
      };
    };
  }
  createPropertyMap(t, r, n = 0) {
    const o = (s) => {
      if (!this.strict && this.blankNodes.get(s) === 1) {
        const a = this.graphs.get(t).get(s);
        if (a)
          return this.createPropertyMap(t, a.predicates, n + 1);
      }
      return this.toHashKey(s);
    };
    if (!this.strict && qfe(r) && !this.preserveListNodeProperties) {
      const [s] = r.get(Bn.first), [a] = r.get(Bn.rest);
      if (n === 0) {
        let u;
        if (a.equals(Bn.nil))
          u = this.toHashKey(Bn.nil);
        else {
          const f = o(a);
          u = Array.isArray(f) ? [...f] : [f];
        }
        return {
          [this.toHashKey(Bn.first)]: [o(s)],
          [this.toHashKey(Bn.rest)]: [u]
        };
      }
      if (a.equals(Bn.nil))
        return [o(s)];
      const l = o(a);
      return [o(s), ...l];
    }
    return [...r].reduce((s, [a, l]) => {
      const u = this.toHashKey(a), f = l.map(o.bind(this));
      return {
        ...s,
        [u]: f
      };
    }, {});
  }
  getGraph(t) {
    const r = this.graphs.get(t) || new Vu();
    return this.graphs.set(t, r), r;
  }
  literalHash(t) {
    if (t.datatype && !this.strict)
      switch (t.datatype.value) {
        case yf.integer.value: {
          const r = +t.value;
          if (Number.isInteger(r))
            return r;
          break;
        }
        case yf.decimal.value: {
          const r = +t.value;
          if (!Number.isNaN(r) && !Number.isInteger(r))
            return r;
          break;
        }
        case yf.boolean.value: {
          if (t.value === "true")
            return !0;
          if (t.value === "false")
            return !1;
          break;
        }
      }
    return t.value.includes(`
`) ? new G8(t) : EI.fromTerm(t).concise(this.prefixes);
  }
  toHashKey(t) {
    return t.termType === "Literal" ? this.literalHash(t) : t.equals(Bn.type) ? "a" : EI.fromTerm(t).concise(this.prefixes);
  }
}
async function Xx(e, t = {}) {
  const r = (await e).default;
  return class {
    constructor(n = {}) {
      this.defaults = n;
    }
    // eslint-disable-next-line class-methods-use-this
    import(n, { preserveListNodeProperties: o, ...s } = {}) {
      const a = {
        ...this.defaults.prefixes || {},
        ...s.prefixes || {}
      }, l = r({
        prefixes: a,
        coercions: t.coercions
      });
      return n.pipe(
        new Wfe({
          prefixes: a,
          strict: t.strict,
          preserveListNodeProperties: o
        })
      ).pipe(l), l;
    }
  };
}
const K8 = ei(
  () => Xx(import("./main-DoOuJ6ky.js").then((e) => e.m), { coercions: V8 })
), Ufe = ei(
  () => Xx(import("./main-BYp9DXeS.js").then((e) => e.m), { strict: !0 })
), Hfe = ei(
  () => Xx(import("./main-DEjxPe0c.js").then((e) => e.m), { strict: !0, coercions: V8 })
);
async function Y8(e) {
  const t = (await e).default;
  return class {
    // eslint-disable-next-line class-methods-use-this
    import(r, n) {
      return r.pipe(n ? t(n) : t());
    }
  };
}
const Jx = ei(
  () => Y8(import("./main-DVOEbC02.js").then((e) => e.m))
), X8 = ei(
  () => Y8(import("./main-CJ_e1MxV.js").then((e) => e.m))
), zfe = ei(async () => {
  const e = (await import("./index-CQnfTQ4g.js")).default;
  return class extends e {
    constructor({ prefixes: r = {}, ...n } = {}) {
      super({
        compact: !0,
        skipGraphProperty: !0,
        encoding: "string",
        ...n
      }), this.prefixes = r;
    }
    import(r, { prefixes: n = {} } = {}) {
      const o = { ...this.prefixes, ...n };
      return super.import(r, { context: o });
    }
  };
}), On = new hD({});
On.import(bn);
const ti = {
  jsonLd: "application/ld+json",
  ntriples: "application/n-triples",
  nquads: "application/n-quads",
  notation3: "text/n3",
  rdfXml: "application/rdf+xml",
  trig: "application/trig",
  turtle: "text/turtle"
};
On.serializers.set(ti.jsonLd, new zfe());
On.serializers.set(ti.notation3, new K8());
On.serializers.set(ti.turtle, new K8());
On.serializers.set(ti.trig, new Hfe());
On.serializers.set(ti.rdfXml, new Ufe());
On.parsers.set(ti.notation3, new Jx());
On.parsers.set(ti.turtle, new Jx());
On.parsers.set(ti.trig, new Jx());
On.parsers.set(ti.ntriples, new X8());
On.parsers.set(ti.nquads, new X8());
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Hd = window, Qx = Hd.ShadowRoot && (Hd.ShadyCSS === void 0 || Hd.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, Zx = Symbol(), xI = /* @__PURE__ */ new WeakMap();
let J8 = class {
  constructor(t, r, n) {
    if (this._$cssResult$ = !0, n !== Zx)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = r;
  }
  get styleSheet() {
    let t = this.o;
    const r = this.t;
    if (Qx && t === void 0) {
      const n = r !== void 0 && r.length === 1;
      n && (t = xI.get(r)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), n && xI.set(r, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const Gfe = (e) => new J8(typeof e == "string" ? e : e + "", void 0, Zx), Vfe = (e, ...t) => {
  const r = e.length === 1 ? e[0] : t.reduce((n, o, s) => n + ((a) => {
    if (a._$cssResult$ === !0)
      return a.cssText;
    if (typeof a == "number")
      return a;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + a + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(o) + e[s + 1], e[0]);
  return new J8(r, e, Zx);
}, Kfe = (e, t) => {
  Qx ? e.adoptedStyleSheets = t.map((r) => r instanceof CSSStyleSheet ? r : r.styleSheet) : t.forEach((r) => {
    const n = document.createElement("style"), o = Hd.litNonce;
    o !== void 0 && n.setAttribute("nonce", o), n.textContent = r.cssText, e.appendChild(n);
  });
}, RI = Qx ? (e) => e : (e) => e instanceof CSSStyleSheet ? ((t) => {
  let r = "";
  for (const n of t.cssRules)
    r += n.cssText;
  return Gfe(r);
})(e) : e;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var c0;
const kh = window, AI = kh.trustedTypes, Yfe = AI ? AI.emptyScript : "", TI = kh.reactiveElementPolyfillSupport, DS = { toAttribute(e, t) {
  switch (t) {
    case Boolean:
      e = e ? Yfe : null;
      break;
    case Object:
    case Array:
      e = e == null ? e : JSON.stringify(e);
  }
  return e;
}, fromAttribute(e, t) {
  let r = e;
  switch (t) {
    case Boolean:
      r = e !== null;
      break;
    case Number:
      r = e === null ? null : Number(e);
      break;
    case Object:
    case Array:
      try {
        r = JSON.parse(e);
      } catch {
        r = null;
      }
  }
  return r;
} }, Q8 = (e, t) => t !== e && (t == t || e == e), d0 = { attribute: !0, type: String, converter: DS, reflect: !1, hasChanged: Q8 }, FS = "finalized";
let wl = class extends HTMLElement {
  constructor() {
    super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this.u();
  }
  static addInitializer(t) {
    var r;
    this.finalize(), ((r = this.h) !== null && r !== void 0 ? r : this.h = []).push(t);
  }
  static get observedAttributes() {
    this.finalize();
    const t = [];
    return this.elementProperties.forEach((r, n) => {
      const o = this._$Ep(n, r);
      o !== void 0 && (this._$Ev.set(o, n), t.push(o));
    }), t;
  }
  static createProperty(t, r = d0) {
    if (r.state && (r.attribute = !1), this.finalize(), this.elementProperties.set(t, r), !r.noAccessor && !this.prototype.hasOwnProperty(t)) {
      const n = typeof t == "symbol" ? Symbol() : "__" + t, o = this.getPropertyDescriptor(t, n, r);
      o !== void 0 && Object.defineProperty(this.prototype, t, o);
    }
  }
  static getPropertyDescriptor(t, r, n) {
    return { get() {
      return this[r];
    }, set(o) {
      const s = this[t];
      this[r] = o, this.requestUpdate(t, s, n);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) || d0;
  }
  static finalize() {
    if (this.hasOwnProperty(FS))
      return !1;
    this[FS] = !0;
    const t = Object.getPrototypeOf(this);
    if (t.finalize(), t.h !== void 0 && (this.h = [...t.h]), this.elementProperties = new Map(t.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
      const r = this.properties, n = [...Object.getOwnPropertyNames(r), ...Object.getOwnPropertySymbols(r)];
      for (const o of n)
        this.createProperty(o, r[o]);
    }
    return this.elementStyles = this.finalizeStyles(this.styles), !0;
  }
  static finalizeStyles(t) {
    const r = [];
    if (Array.isArray(t)) {
      const n = new Set(t.flat(1 / 0).reverse());
      for (const o of n)
        r.unshift(RI(o));
    } else
      t !== void 0 && r.push(RI(t));
    return r;
  }
  static _$Ep(t, r) {
    const n = r.attribute;
    return n === !1 ? void 0 : typeof n == "string" ? n : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  u() {
    var t;
    this._$E_ = new Promise((r) => this.enableUpdating = r), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), (t = this.constructor.h) === null || t === void 0 || t.forEach((r) => r(this));
  }
  addController(t) {
    var r, n;
    ((r = this._$ES) !== null && r !== void 0 ? r : this._$ES = []).push(t), this.renderRoot !== void 0 && this.isConnected && ((n = t.hostConnected) === null || n === void 0 || n.call(t));
  }
  removeController(t) {
    var r;
    (r = this._$ES) === null || r === void 0 || r.splice(this._$ES.indexOf(t) >>> 0, 1);
  }
  _$Eg() {
    this.constructor.elementProperties.forEach((t, r) => {
      this.hasOwnProperty(r) && (this._$Ei.set(r, this[r]), delete this[r]);
    });
  }
  createRenderRoot() {
    var t;
    const r = (t = this.shadowRoot) !== null && t !== void 0 ? t : this.attachShadow(this.constructor.shadowRootOptions);
    return Kfe(r, this.constructor.elementStyles), r;
  }
  connectedCallback() {
    var t;
    this.renderRoot === void 0 && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$ES) === null || t === void 0 || t.forEach((r) => {
      var n;
      return (n = r.hostConnected) === null || n === void 0 ? void 0 : n.call(r);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$ES) === null || t === void 0 || t.forEach((r) => {
      var n;
      return (n = r.hostDisconnected) === null || n === void 0 ? void 0 : n.call(r);
    });
  }
  attributeChangedCallback(t, r, n) {
    this._$AK(t, n);
  }
  _$EO(t, r, n = d0) {
    var o;
    const s = this.constructor._$Ep(t, n);
    if (s !== void 0 && n.reflect === !0) {
      const a = (((o = n.converter) === null || o === void 0 ? void 0 : o.toAttribute) !== void 0 ? n.converter : DS).toAttribute(r, n.type);
      this._$El = t, a == null ? this.removeAttribute(s) : this.setAttribute(s, a), this._$El = null;
    }
  }
  _$AK(t, r) {
    var n;
    const o = this.constructor, s = o._$Ev.get(t);
    if (s !== void 0 && this._$El !== s) {
      const a = o.getPropertyOptions(s), l = typeof a.converter == "function" ? { fromAttribute: a.converter } : ((n = a.converter) === null || n === void 0 ? void 0 : n.fromAttribute) !== void 0 ? a.converter : DS;
      this._$El = s, this[s] = l.fromAttribute(r, a.type), this._$El = null;
    }
  }
  requestUpdate(t, r, n) {
    let o = !0;
    t !== void 0 && (((n = n || this.constructor.getPropertyOptions(t)).hasChanged || Q8)(this[t], r) ? (this._$AL.has(t) || this._$AL.set(t, r), n.reflect === !0 && this._$El !== t && (this._$EC === void 0 && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t, n))) : o = !1), !this.isUpdatePending && o && (this._$E_ = this._$Ej());
  }
  async _$Ej() {
    this.isUpdatePending = !0;
    try {
      await this._$E_;
    } catch (r) {
      Promise.reject(r);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t;
    if (!this.isUpdatePending)
      return;
    this.hasUpdated, this._$Ei && (this._$Ei.forEach((o, s) => this[s] = o), this._$Ei = void 0);
    let r = !1;
    const n = this._$AL;
    try {
      r = this.shouldUpdate(n), r ? (this.willUpdate(n), (t = this._$ES) === null || t === void 0 || t.forEach((o) => {
        var s;
        return (s = o.hostUpdate) === null || s === void 0 ? void 0 : s.call(o);
      }), this.update(n)) : this._$Ek();
    } catch (o) {
      throw r = !1, this._$Ek(), o;
    }
    r && this._$AE(n);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var r;
    (r = this._$ES) === null || r === void 0 || r.forEach((n) => {
      var o;
      return (o = n.hostUpdated) === null || o === void 0 ? void 0 : o.call(n);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$Ek() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$E_;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$EC !== void 0 && (this._$EC.forEach((r, n) => this._$EO(n, this[n], r)), this._$EC = void 0), this._$Ek();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
};
wl[FS] = !0, wl.elementProperties = /* @__PURE__ */ new Map(), wl.elementStyles = [], wl.shadowRootOptions = { mode: "open" }, TI == null || TI({ ReactiveElement: wl }), ((c0 = kh.reactiveElementVersions) !== null && c0 !== void 0 ? c0 : kh.reactiveElementVersions = []).push("1.6.2");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var h0;
const Ih = window, Xl = Ih.trustedTypes, $I = Xl ? Xl.createPolicy("lit-html", { createHTML: (e) => e }) : void 0, jS = "$lit$", Vo = `lit$${(Math.random() + "").slice(9)}$`, Z8 = "?" + Vo, Xfe = `<${Z8}>`, $a = document, Hf = () => $a.createComment(""), zf = (e) => e === null || typeof e != "object" && typeof e != "function", ej = Array.isArray, Jfe = (e) => ej(e) || typeof (e == null ? void 0 : e[Symbol.iterator]) == "function", p0 = `[ 	
\f\r]`, Ou = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, CI = /-->/g, kI = />/g, Ps = RegExp(`>|${p0}(?:([^\\s"'>=/]+)(${p0}*=${p0}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), II = /'/g, MI = /"/g, tj = /^(?:script|style|textarea|title)$/i, Qfe = (e) => (t, ...r) => ({ _$litType$: e, strings: t, values: r }), Zfe = Qfe(1), Jl = Symbol.for("lit-noChange"), sr = Symbol.for("lit-nothing"), NI = /* @__PURE__ */ new WeakMap(), Qs = $a.createTreeWalker($a, 129, null, !1), ece = (e, t) => {
  const r = e.length - 1, n = [];
  let o, s = t === 2 ? "<svg>" : "", a = Ou;
  for (let u = 0; u < r; u++) {
    const f = e[u];
    let c, d, h = -1, p = 0;
    for (; p < f.length && (a.lastIndex = p, d = a.exec(f), d !== null); )
      p = a.lastIndex, a === Ou ? d[1] === "!--" ? a = CI : d[1] !== void 0 ? a = kI : d[2] !== void 0 ? (tj.test(d[2]) && (o = RegExp("</" + d[2], "g")), a = Ps) : d[3] !== void 0 && (a = Ps) : a === Ps ? d[0] === ">" ? (a = o ?? Ou, h = -1) : d[1] === void 0 ? h = -2 : (h = a.lastIndex - d[2].length, c = d[1], a = d[3] === void 0 ? Ps : d[3] === '"' ? MI : II) : a === MI || a === II ? a = Ps : a === CI || a === kI ? a = Ou : (a = Ps, o = void 0);
    const m = a === Ps && e[u + 1].startsWith("/>") ? " " : "";
    s += a === Ou ? f + Xfe : h >= 0 ? (n.push(c), f.slice(0, h) + jS + f.slice(h) + Vo + m) : f + Vo + (h === -2 ? (n.push(void 0), u) : m);
  }
  const l = s + (e[r] || "<?>") + (t === 2 ? "</svg>" : "");
  if (!Array.isArray(e) || !e.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return [$I !== void 0 ? $I.createHTML(l) : l, n];
};
let BS = class rj {
  constructor({ strings: t, _$litType$: r }, n) {
    let o;
    this.parts = [];
    let s = 0, a = 0;
    const l = t.length - 1, u = this.parts, [f, c] = ece(t, r);
    if (this.el = rj.createElement(f, n), Qs.currentNode = this.el.content, r === 2) {
      const d = this.el.content, h = d.firstChild;
      h.remove(), d.append(...h.childNodes);
    }
    for (; (o = Qs.nextNode()) !== null && u.length < l; ) {
      if (o.nodeType === 1) {
        if (o.hasAttributes()) {
          const d = [];
          for (const h of o.getAttributeNames())
            if (h.endsWith(jS) || h.startsWith(Vo)) {
              const p = c[a++];
              if (d.push(h), p !== void 0) {
                const m = o.getAttribute(p.toLowerCase() + jS).split(Vo), y = /([.?@])?(.*)/.exec(p);
                u.push({ type: 1, index: s, name: y[2], strings: m, ctor: y[1] === "." ? rce : y[1] === "?" ? ice : y[1] === "@" ? oce : mg });
              } else
                u.push({ type: 6, index: s });
            }
          for (const h of d)
            o.removeAttribute(h);
        }
        if (tj.test(o.tagName)) {
          const d = o.textContent.split(Vo), h = d.length - 1;
          if (h > 0) {
            o.textContent = Xl ? Xl.emptyScript : "";
            for (let p = 0; p < h; p++)
              o.append(d[p], Hf()), Qs.nextNode(), u.push({ type: 2, index: ++s });
            o.append(d[h], Hf());
          }
        }
      } else if (o.nodeType === 8)
        if (o.data === Z8)
          u.push({ type: 2, index: s });
        else {
          let d = -1;
          for (; (d = o.data.indexOf(Vo, d + 1)) !== -1; )
            u.push({ type: 7, index: s }), d += Vo.length - 1;
        }
      s++;
    }
  }
  static createElement(t, r) {
    const n = $a.createElement("template");
    return n.innerHTML = t, n;
  }
};
function Ql(e, t, r = e, n) {
  var o, s, a, l;
  if (t === Jl)
    return t;
  let u = n !== void 0 ? (o = r._$Co) === null || o === void 0 ? void 0 : o[n] : r._$Cl;
  const f = zf(t) ? void 0 : t._$litDirective$;
  return (u == null ? void 0 : u.constructor) !== f && ((s = u == null ? void 0 : u._$AO) === null || s === void 0 || s.call(u, !1), f === void 0 ? u = void 0 : (u = new f(e), u._$AT(e, r, n)), n !== void 0 ? ((a = (l = r)._$Co) !== null && a !== void 0 ? a : l._$Co = [])[n] = u : r._$Cl = u), u !== void 0 && (t = Ql(e, u._$AS(e, t.values), u, n)), t;
}
let tce = class {
  constructor(t, r) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = r;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    var r;
    const { el: { content: n }, parts: o } = this._$AD, s = ((r = t == null ? void 0 : t.creationScope) !== null && r !== void 0 ? r : $a).importNode(n, !0);
    Qs.currentNode = s;
    let a = Qs.nextNode(), l = 0, u = 0, f = o[0];
    for (; f !== void 0; ) {
      if (l === f.index) {
        let c;
        f.type === 2 ? c = new eR(a, a.nextSibling, this, t) : f.type === 1 ? c = new f.ctor(a, f.name, f.strings, this, t) : f.type === 6 && (c = new sce(a, this, t)), this._$AV.push(c), f = o[++u];
      }
      l !== (f == null ? void 0 : f.index) && (a = Qs.nextNode(), l++);
    }
    return Qs.currentNode = $a, s;
  }
  v(t) {
    let r = 0;
    for (const n of this._$AV)
      n !== void 0 && (n.strings !== void 0 ? (n._$AI(t, n, r), r += n.strings.length - 2) : n._$AI(t[r])), r++;
  }
}, eR = class nj {
  constructor(t, r, n, o) {
    var s;
    this.type = 2, this._$AH = sr, this._$AN = void 0, this._$AA = t, this._$AB = r, this._$AM = n, this.options = o, this._$Cp = (s = o == null ? void 0 : o.isConnected) === null || s === void 0 || s;
  }
  get _$AU() {
    var t, r;
    return (r = (t = this._$AM) === null || t === void 0 ? void 0 : t._$AU) !== null && r !== void 0 ? r : this._$Cp;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const r = this._$AM;
    return r !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = r.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, r = this) {
    t = Ql(this, t, r), zf(t) ? t === sr || t == null || t === "" ? (this._$AH !== sr && this._$AR(), this._$AH = sr) : t !== this._$AH && t !== Jl && this._(t) : t._$litType$ !== void 0 ? this.g(t) : t.nodeType !== void 0 ? this.$(t) : Jfe(t) ? this.T(t) : this._(t);
  }
  k(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  $(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.k(t));
  }
  _(t) {
    this._$AH !== sr && zf(this._$AH) ? this._$AA.nextSibling.data = t : this.$($a.createTextNode(t)), this._$AH = t;
  }
  g(t) {
    var r;
    const { values: n, _$litType$: o } = t, s = typeof o == "number" ? this._$AC(t) : (o.el === void 0 && (o.el = BS.createElement(o.h, this.options)), o);
    if (((r = this._$AH) === null || r === void 0 ? void 0 : r._$AD) === s)
      this._$AH.v(n);
    else {
      const a = new tce(s, this), l = a.u(this.options);
      a.v(n), this.$(l), this._$AH = a;
    }
  }
  _$AC(t) {
    let r = NI.get(t.strings);
    return r === void 0 && NI.set(t.strings, r = new BS(t)), r;
  }
  T(t) {
    ej(this._$AH) || (this._$AH = [], this._$AR());
    const r = this._$AH;
    let n, o = 0;
    for (const s of t)
      o === r.length ? r.push(n = new nj(this.k(Hf()), this.k(Hf()), this, this.options)) : n = r[o], n._$AI(s), o++;
    o < r.length && (this._$AR(n && n._$AB.nextSibling, o), r.length = o);
  }
  _$AR(t = this._$AA.nextSibling, r) {
    var n;
    for ((n = this._$AP) === null || n === void 0 || n.call(this, !1, !0, r); t && t !== this._$AB; ) {
      const o = t.nextSibling;
      t.remove(), t = o;
    }
  }
  setConnected(t) {
    var r;
    this._$AM === void 0 && (this._$Cp = t, (r = this._$AP) === null || r === void 0 || r.call(this, t));
  }
};
class mg {
  constructor(t, r, n, o, s) {
    this.type = 1, this._$AH = sr, this._$AN = void 0, this.element = t, this.name = r, this._$AM = o, this.options = s, n.length > 2 || n[0] !== "" || n[1] !== "" ? (this._$AH = Array(n.length - 1).fill(new String()), this.strings = n) : this._$AH = sr;
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t, r = this, n, o) {
    const s = this.strings;
    let a = !1;
    if (s === void 0)
      t = Ql(this, t, r, 0), a = !zf(t) || t !== this._$AH && t !== Jl, a && (this._$AH = t);
    else {
      const l = t;
      let u, f;
      for (t = s[0], u = 0; u < s.length - 1; u++)
        f = Ql(this, l[n + u], r, u), f === Jl && (f = this._$AH[u]), a || (a = !zf(f) || f !== this._$AH[u]), f === sr ? t = sr : t !== sr && (t += (f ?? "") + s[u + 1]), this._$AH[u] = f;
    }
    a && !o && this.j(t);
  }
  j(t) {
    t === sr ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}
class rce extends mg {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === sr ? void 0 : t;
  }
}
const nce = Xl ? Xl.emptyScript : "";
let ice = class extends mg {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    t && t !== sr ? this.element.setAttribute(this.name, nce) : this.element.removeAttribute(this.name);
  }
}, oce = class extends mg {
  constructor(t, r, n, o, s) {
    super(t, r, n, o, s), this.type = 5;
  }
  _$AI(t, r = this) {
    var n;
    if ((t = (n = Ql(this, t, r, 0)) !== null && n !== void 0 ? n : sr) === Jl)
      return;
    const o = this._$AH, s = t === sr && o !== sr || t.capture !== o.capture || t.once !== o.once || t.passive !== o.passive, a = t !== sr && (o === sr || s);
    s && this.element.removeEventListener(this.name, this, o), a && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var r, n;
    typeof this._$AH == "function" ? this._$AH.call((n = (r = this.options) === null || r === void 0 ? void 0 : r.host) !== null && n !== void 0 ? n : this.element, t) : this._$AH.handleEvent(t);
  }
}, sce = class {
  constructor(t, r, n) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = r, this.options = n;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    Ql(this, t);
  }
};
const LI = Ih.litHtmlPolyfillSupport;
LI == null || LI(BS, eR), ((h0 = Ih.litHtmlVersions) !== null && h0 !== void 0 ? h0 : Ih.litHtmlVersions = []).push("2.7.4");
const ace = (e, t, r) => {
  var n, o;
  const s = (n = r == null ? void 0 : r.renderBefore) !== null && n !== void 0 ? n : t;
  let a = s._$litPart$;
  if (a === void 0) {
    const l = (o = r == null ? void 0 : r.renderBefore) !== null && o !== void 0 ? o : null;
    s._$litPart$ = a = new eR(t.insertBefore(Hf(), l), l, void 0, r ?? {});
  }
  return a._$AI(e), a;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var g0, b0;
let xf = class extends wl {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t, r;
    const n = super.createRenderRoot();
    return (t = (r = this.renderOptions).renderBefore) !== null && t !== void 0 || (r.renderBefore = n.firstChild), n;
  }
  update(t) {
    const r = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = ace(r, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) === null || t === void 0 || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) === null || t === void 0 || t.setConnected(!1);
  }
  render() {
    return Jl;
  }
};
xf.finalized = !0, xf._$litElement$ = !0, (g0 = globalThis.litElementHydrateSupport) === null || g0 === void 0 || g0.call(globalThis, { LitElement: xf });
const OI = globalThis.litElementPolyfillSupport;
OI == null || OI({ LitElement: xf });
((b0 = globalThis.litElementVersions) !== null && b0 !== void 0 ? b0 : globalThis.litElementVersions = []).push("3.3.2");
var Vr = navigator.userAgent, ij = navigator.platform, bo = /gecko\/\d/i.test(Vr), oj = /MSIE \d/.test(Vr), sj = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Vr), vg = /Edge\/(\d+)/.exec(Vr), ct = oj || sj || vg, kt = ct && (oj ? document.documentMode || 6 : +(vg || sj)[1]), Tr = !vg && /WebKit\//.test(Vr), lce = Tr && /Qt\/\d+\.\d+/.test(Vr), wg = !vg && /Chrome\//.test(Vr), Jn = /Opera\//.test(Vr), _g = /Apple Computer/.test(navigator.vendor), uce = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(Vr), fce = /PhantomJS/.test(Vr), Tc = _g && (/Mobile\/\w+/.test(Vr) || navigator.maxTouchPoints > 2), Sg = /Android/.test(Vr), Gf = Tc || Sg || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(Vr), Rn = Tc || /Mac/.test(ij), cce = /\bCrOS\b/.test(Vr), dce = /win/i.test(ij), ga = Jn && Vr.match(/Version\/(\d*\.\d*)/);
ga && (ga = Number(ga[1]));
ga && ga >= 15 && (Jn = !1, Tr = !0);
var PI = Rn && (lce || Jn && (ga == null || ga < 12.11)), tR = bo || ct && kt >= 9;
function Zl(e) {
  return new RegExp("(^|\\s)" + e + "(?:$|\\s)\\s*");
}
var Za = function(e, t) {
  let r = e.className, n = Zl(t).exec(r);
  if (n) {
    let o = r.slice(n.index + n[0].length);
    e.className = r.slice(0, n.index) + (o ? n[1] + o : "");
  }
};
function us(e) {
  for (let t = e.childNodes.length; t > 0; --t)
    e.removeChild(e.firstChild);
  return e;
}
function hn(e, t) {
  return us(e).appendChild(t);
}
function Ue(e, t, r, n) {
  let o = document.createElement(e);
  if (r && (o.className = r), n && (o.style.cssText = n), typeof t == "string")
    o.appendChild(document.createTextNode(t));
  else if (t)
    for (let s = 0; s < t.length; ++s)
      o.appendChild(t[s]);
  return o;
}
function Pl(e, t, r, n) {
  let o = Ue(e, t, r, n);
  return o.setAttribute("role", "presentation"), o;
}
var Ca;
document.createRange ? Ca = function(e, t, r, n) {
  let o = document.createRange();
  return o.setEnd(n || e, r), o.setStart(e, t), o;
} : Ca = function(e, t, r) {
  let n = document.body.createTextRange();
  try {
    n.moveToElementText(e.parentNode);
  } catch {
    return n;
  }
  return n.collapse(!0), n.moveEnd("character", r), n.moveStart("character", t), n;
};
function fs(e, t) {
  if (t.nodeType == 3 && (t = t.parentNode), e.contains)
    return e.contains(t);
  do
    if (t.nodeType == 11 && (t = t.host), t == e)
      return !0;
  while (t = t.parentNode);
}
function En() {
  let e;
  try {
    e = document.activeElement;
  } catch {
    e = document.body || null;
  }
  for (; e && e.shadowRoot && e.shadowRoot.activeElement; )
    e = e.shadowRoot.activeElement;
  return e;
}
function el(e, t) {
  let r = e.className;
  Zl(t).test(r) || (e.className += (r ? " " : "") + t);
}
function y0(e, t) {
  let r = e.split(" ");
  for (let n = 0; n < r.length; n++)
    r[n] && !Zl(r[n]).test(t) && (t += " " + r[n]);
  return t;
}
var Vf = function(e) {
  e.select();
};
Tc ? Vf = function(e) {
  e.selectionStart = 0, e.selectionEnd = e.value.length;
} : ct && (Vf = function(e) {
  try {
    e.select();
  } catch {
  }
});
function rR(e) {
  let t = Array.prototype.slice.call(arguments, 1);
  return function() {
    return e.apply(null, t);
  };
}
function ka(e, t, r) {
  t || (t = {});
  for (let n in e)
    e.hasOwnProperty(n) && (r !== !1 || !t.hasOwnProperty(n)) && (t[n] = e[n]);
  return t;
}
function _n(e, t, r, n, o) {
  t == null && (t = e.search(/[^\s\u00a0]/), t == -1 && (t = e.length));
  for (let s = n || 0, a = o || 0; ; ) {
    let l = e.indexOf("	", s);
    if (l < 0 || l >= t)
      return a + (t - s);
    a += l - s, a += r - a % r, s = l + 1;
  }
}
var eu = class {
  constructor() {
    this.id = null, this.f = null, this.time = 0, this.handler = rR(this.onTimeout, this);
  }
  onTimeout(e) {
    e.id = 0, e.time <= +/* @__PURE__ */ new Date() ? e.f() : setTimeout(e.handler, e.time - +/* @__PURE__ */ new Date());
  }
  set(e, t) {
    this.f = t;
    const r = +/* @__PURE__ */ new Date() + e;
    (!this.id || r < this.time) && (clearTimeout(this.id), this.id = setTimeout(this.handler, e), this.time = r);
  }
};
function mr(e, t) {
  for (let r = 0; r < e.length; ++r)
    if (e[r] == t)
      return r;
  return -1;
}
var aj = 50, Eg = { toString: function() {
  return "CodeMirror.Pass";
} }, Ii = { scroll: !1 }, m0 = { origin: "*mouse" }, Rf = { origin: "+move" };
function qS(e, t, r) {
  for (let n = 0, o = 0; ; ) {
    let s = e.indexOf("	", n);
    s == -1 && (s = e.length);
    let a = s - n;
    if (s == e.length || o + a >= t)
      return n + Math.min(a, t - o);
    if (o += s - n, o += r - o % r, n = s + 1, o >= t)
      return n;
  }
}
var bd = [""];
function nR(e) {
  for (; bd.length <= e; )
    bd.push(yt(bd) + " ");
  return bd[e];
}
function yt(e) {
  return e[e.length - 1];
}
function xg(e, t) {
  let r = [];
  for (let n = 0; n < e.length; n++)
    r[n] = t(e[n], n);
  return r;
}
function hce(e, t, r) {
  let n = 0, o = r(t);
  for (; n < e.length && r(e[n]) <= o; )
    n++;
  e.splice(n, 0, t);
}
function DI() {
}
function lj(e, t) {
  let r;
  return Object.create ? r = Object.create(e) : (DI.prototype = e, r = new DI()), t && ka(t, r), r;
}
var pce = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
function WS(e) {
  return /\w/.test(e) || e > "" && (e.toUpperCase() != e.toLowerCase() || pce.test(e));
}
function zd(e, t) {
  return t ? t.source.indexOf("\\w") > -1 && WS(e) ? !0 : t.test(e) : WS(e);
}
function FI(e) {
  for (let t in e)
    if (e.hasOwnProperty(t) && e[t])
      return !1;
  return !0;
}
var gce = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
function US(e) {
  return e.charCodeAt(0) >= 768 && gce.test(e);
}
function uj(e, t, r) {
  for (; (r < 0 ? t > 0 : t < e.length) && US(e.charAt(t)); )
    t += r;
  return t;
}
function Kf(e, t, r) {
  let n = t > r ? -1 : 1;
  for (; ; ) {
    if (t == r)
      return t;
    let o = (t + r) / 2, s = n < 0 ? Math.ceil(o) : Math.floor(o);
    if (s == t)
      return e(s) ? t : r;
    e(s) ? r = s : t = s + n;
  }
}
function bce(e, t, r, n) {
  if (!e)
    return n(t, r, "ltr", 0);
  let o = !1;
  for (let s = 0; s < e.length; ++s) {
    let a = e[s];
    (a.from < r && a.to > t || t == r && a.to == t) && (n(Math.max(a.from, t), Math.min(a.to, r), a.level == 1 ? "rtl" : "ltr", s), o = !0);
  }
  o || n(t, r, "ltr");
}
var ef = null;
function Yf(e, t, r) {
  let n;
  ef = null;
  for (let o = 0; o < e.length; ++o) {
    let s = e[o];
    if (s.from < t && s.to > t)
      return o;
    s.to == t && (s.from != s.to && r == "before" ? n = o : ef = o), s.from == t && (s.from != s.to && r != "before" ? n = o : ef = o);
  }
  return n ?? ef;
}
var yce = /* @__PURE__ */ function() {
  let e = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN", t = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
  function r(f) {
    return f <= 247 ? e.charAt(f) : 1424 <= f && f <= 1524 ? "R" : 1536 <= f && f <= 1785 ? t.charAt(f - 1536) : 1774 <= f && f <= 2220 ? "r" : 8192 <= f && f <= 8203 ? "w" : f == 8204 ? "b" : "L";
  }
  let n = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, o = /[stwN]/, s = /[LRr]/, a = /[Lb1n]/, l = /[1n]/;
  function u(f, c, d) {
    this.level = f, this.from = c, this.to = d;
  }
  return function(f, c) {
    let d = c == "ltr" ? "L" : "R";
    if (f.length == 0 || c == "ltr" && !n.test(f))
      return !1;
    let h = f.length, p = [];
    for (let _ = 0; _ < h; ++_)
      p.push(r(f.charCodeAt(_)));
    for (let _ = 0, S = d; _ < h; ++_) {
      let x = p[_];
      x == "m" ? p[_] = S : S = x;
    }
    for (let _ = 0, S = d; _ < h; ++_) {
      let x = p[_];
      x == "1" && S == "r" ? p[_] = "n" : s.test(x) && (S = x, x == "r" && (p[_] = "R"));
    }
    for (let _ = 1, S = p[0]; _ < h - 1; ++_) {
      let x = p[_];
      x == "+" && S == "1" && p[_ + 1] == "1" ? p[_] = "1" : x == "," && S == p[_ + 1] && (S == "1" || S == "n") && (p[_] = S), S = x;
    }
    for (let _ = 0; _ < h; ++_) {
      let S = p[_];
      if (S == ",")
        p[_] = "N";
      else if (S == "%") {
        let x;
        for (x = _ + 1; x < h && p[x] == "%"; ++x)
          ;
        let E = _ && p[_ - 1] == "!" || x < h && p[x] == "1" ? "1" : "N";
        for (let C = _; C < x; ++C)
          p[C] = E;
        _ = x - 1;
      }
    }
    for (let _ = 0, S = d; _ < h; ++_) {
      let x = p[_];
      S == "L" && x == "1" ? p[_] = "L" : s.test(x) && (S = x);
    }
    for (let _ = 0; _ < h; ++_)
      if (o.test(p[_])) {
        let S;
        for (S = _ + 1; S < h && o.test(p[S]); ++S)
          ;
        let x = (_ ? p[_ - 1] : d) == "L", E = (S < h ? p[S] : d) == "L", C = x == E ? x ? "L" : "R" : d;
        for (let I = _; I < S; ++I)
          p[I] = C;
        _ = S - 1;
      }
    let m = [], y;
    for (let _ = 0; _ < h; )
      if (a.test(p[_])) {
        let S = _;
        for (++_; _ < h && a.test(p[_]); ++_)
          ;
        m.push(new u(0, S, _));
      } else {
        let S = _, x = m.length, E = c == "rtl" ? 1 : 0;
        for (++_; _ < h && p[_] != "L"; ++_)
          ;
        for (let C = S; C < _; )
          if (l.test(p[C])) {
            S < C && (m.splice(x, 0, new u(1, S, C)), x += E);
            let I = C;
            for (++C; C < _ && l.test(p[C]); ++C)
              ;
            m.splice(x, 0, new u(2, I, C)), x += E, S = C;
          } else
            ++C;
        S < _ && m.splice(x, 0, new u(1, S, _));
      }
    return c == "ltr" && (m[0].level == 1 && (y = f.match(/^\s+/)) && (m[0].from = y[0].length, m.unshift(new u(0, 0, y[0].length))), yt(m).level == 1 && (y = f.match(/\s+$/)) && (yt(m).to -= y[0].length, m.push(new u(0, h - y[0].length, h)))), c == "rtl" ? m.reverse() : m;
  };
}();
function $o(e, t) {
  let r = e.order;
  return r == null && (r = e.order = yce(e.text, t)), r;
}
var fj = [], He = function(e, t, r) {
  if (e.addEventListener)
    e.addEventListener(t, r, !1);
  else if (e.attachEvent)
    e.attachEvent("on" + t, r);
  else {
    let n = e._handlers || (e._handlers = {});
    n[t] = (n[t] || fj).concat(r);
  }
};
function iR(e, t) {
  return e._handlers && e._handlers[t] || fj;
}
function cn(e, t, r) {
  if (e.removeEventListener)
    e.removeEventListener(t, r, !1);
  else if (e.detachEvent)
    e.detachEvent("on" + t, r);
  else {
    let n = e._handlers, o = n && n[t];
    if (o) {
      let s = mr(o, r);
      s > -1 && (n[t] = o.slice(0, s).concat(o.slice(s + 1)));
    }
  }
}
function Ht(e, t) {
  let r = iR(e, t);
  if (!r.length)
    return;
  let n = Array.prototype.slice.call(arguments, 2);
  for (let o = 0; o < r.length; ++o)
    r[o].apply(null, n);
}
function Qt(e, t, r) {
  return typeof t == "string" && (t = { type: t, preventDefault: function() {
    this.defaultPrevented = !0;
  } }), Ht(e, r || t.type, e, t), HS(t) || t.codemirrorIgnore;
}
function cj(e) {
  let t = e._handlers && e._handlers.cursorActivity;
  if (!t)
    return;
  let r = e.curOp.cursorActivityHandlers || (e.curOp.cursorActivityHandlers = []);
  for (let n = 0; n < t.length; ++n)
    mr(r, t[n]) == -1 && r.push(t[n]);
}
function An(e, t) {
  return iR(e, t).length > 0;
}
function wu(e) {
  e.prototype.on = function(t, r) {
    He(this, t, r);
  }, e.prototype.off = function(t, r) {
    cn(this, t, r);
  };
}
function Br(e) {
  e.preventDefault ? e.preventDefault() : e.returnValue = !1;
}
function dj(e) {
  e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0;
}
function HS(e) {
  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == !1;
}
function Xf(e) {
  Br(e), dj(e);
}
function oR(e) {
  return e.target || e.srcElement;
}
function hj(e) {
  let t = e.which;
  return t == null && (e.button & 1 ? t = 1 : e.button & 2 ? t = 3 : e.button & 4 && (t = 2)), Rn && e.ctrlKey && t == 1 && (t = 3), t;
}
var mce = function() {
  if (ct && kt < 9)
    return !1;
  let e = Ue("div");
  return "draggable" in e || "dragDrop" in e;
}(), v0;
function vce(e) {
  if (v0 == null) {
    let r = Ue("span", "");
    hn(e, Ue("span", [r, document.createTextNode("x")])), e.firstChild.offsetHeight != 0 && (v0 = r.offsetWidth <= 1 && r.offsetHeight > 2 && !(ct && kt < 8));
  }
  let t = v0 ? Ue("span", "") : Ue("span", "", null, "display: inline-block; width: 1px; margin-right: -1px");
  return t.setAttribute("cm-text", ""), t;
}
var w0;
function wce(e) {
  if (w0 != null)
    return w0;
  let t = hn(e, document.createTextNode("AA")), r = Ca(t, 0, 1).getBoundingClientRect(), n = Ca(t, 1, 2).getBoundingClientRect();
  return us(e), !r || r.left == r.right ? !1 : w0 = n.right - r.right < 3;
}
var sR = `

b`.split(/\n/).length != 3 ? (e) => {
  let t = 0, r = [], n = e.length;
  for (; t <= n; ) {
    let o = e.indexOf(`
`, t);
    o == -1 && (o = e.length);
    let s = e.slice(t, e.charAt(o - 1) == "\r" ? o - 1 : o), a = s.indexOf("\r");
    a != -1 ? (r.push(s.slice(0, a)), t += a + 1) : (r.push(s), t = o + 1);
  }
  return r;
} : (e) => e.split(/\r\n?|\n/), _ce = window.getSelection ? (e) => {
  try {
    return e.selectionStart != e.selectionEnd;
  } catch {
    return !1;
  }
} : (e) => {
  let t;
  try {
    t = e.ownerDocument.selection.createRange();
  } catch {
  }
  return !t || t.parentElement() != e ? !1 : t.compareEndPoints("StartToEnd", t) != 0;
}, Sce = (() => {
  let e = Ue("div");
  return "oncopy" in e ? !0 : (e.setAttribute("oncopy", "return;"), typeof e.oncopy == "function");
})(), _0 = null;
function Ece(e) {
  if (_0 != null)
    return _0;
  let t = hn(e, Ue("span", "x")), r = t.getBoundingClientRect(), n = Ca(t, 0, 1).getBoundingClientRect();
  return _0 = Math.abs(r.left - n.left) > 1;
}
var aR = {}, xl = {};
function xce(e, t) {
  arguments.length > 2 && (t.dependencies = Array.prototype.slice.call(arguments, 2)), aR[e] = t;
}
function Rce(e, t) {
  xl[e] = t;
}
function Mh(e) {
  if (typeof e == "string" && xl.hasOwnProperty(e))
    e = xl[e];
  else if (e && typeof e.name == "string" && xl.hasOwnProperty(e.name)) {
    let t = xl[e.name];
    typeof t == "string" && (t = { name: t }), e = lj(t, e), e.name = t.name;
  } else {
    if (typeof e == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(e))
      return Mh("application/xml");
    if (typeof e == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(e))
      return Mh("application/json");
  }
  return typeof e == "string" ? { name: e } : e || { name: "null" };
}
function lR(e, t) {
  t = Mh(t);
  let r = aR[t.name];
  if (!r)
    return lR(e, "text/plain");
  let n = r(e, t);
  if (Dl.hasOwnProperty(t.name)) {
    let o = Dl[t.name];
    for (let s in o)
      o.hasOwnProperty(s) && (n.hasOwnProperty(s) && (n["_" + s] = n[s]), n[s] = o[s]);
  }
  if (n.name = t.name, t.helperType && (n.helperType = t.helperType), t.modeProps)
    for (let o in t.modeProps)
      n[o] = t.modeProps[o];
  return n;
}
var Dl = {};
function Ace(e, t) {
  let r = Dl.hasOwnProperty(e) ? Dl[e] : Dl[e] = {};
  ka(t, r);
}
function ba(e, t) {
  if (t === !0)
    return t;
  if (e.copyState)
    return e.copyState(t);
  let r = {};
  for (let n in t) {
    let o = t[n];
    o instanceof Array && (o = o.concat([])), r[n] = o;
  }
  return r;
}
function uR(e, t) {
  let r;
  for (; e.innerMode && (r = e.innerMode(t), !(!r || r.mode == e)); )
    t = r.state, e = r.mode;
  return r || { mode: e, state: t };
}
function pj(e, t, r) {
  return e.startState ? e.startState(t, r) : !0;
}
var Tce = class {
  constructor(e, t, r) {
    this.pos = this.start = 0, this.string = e, this.tabSize = t || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0, this.lineOracle = r;
  }
  eol() {
    return this.pos >= this.string.length;
  }
  sol() {
    return this.pos == this.lineStart;
  }
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  eat(e) {
    let t = this.string.charAt(this.pos), r;
    if (typeof e == "string" ? r = t == e : r = t && (e.test ? e.test(t) : e(t)), r)
      return ++this.pos, t;
  }
  eatWhile(e) {
    let t = this.pos;
    for (; this.eat(e); )
      ;
    return this.pos > t;
  }
  eatSpace() {
    let e = this.pos;
    for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
      ++this.pos;
    return this.pos > e;
  }
  skipToEnd() {
    this.pos = this.string.length;
  }
  skipTo(e) {
    let t = this.string.indexOf(e, this.pos);
    if (t > -1)
      return this.pos = t, !0;
  }
  backUp(e) {
    this.pos -= e;
  }
  column() {
    return this.lastColumnPos < this.start && (this.lastColumnValue = _n(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? _n(this.string, this.lineStart, this.tabSize) : 0);
  }
  indentation() {
    return _n(this.string, null, this.tabSize) - (this.lineStart ? _n(this.string, this.lineStart, this.tabSize) : 0);
  }
  match(e, t, r) {
    if (typeof e == "string") {
      let n = (s) => r ? s.toLowerCase() : s, o = this.string.substr(this.pos, e.length);
      if (n(o) == n(e))
        return t !== !1 && (this.pos += e.length), !0;
    } else {
      let n = this.string.slice(this.pos).match(e);
      return n && n.index > 0 ? null : (n && t !== !1 && (this.pos += n[0].length), n);
    }
  }
  current() {
    return this.string.slice(this.start, this.pos);
  }
  hideFirstChars(e, t) {
    this.lineStart += e;
    try {
      return t();
    } finally {
      this.lineStart -= e;
    }
  }
  lookAhead(e) {
    let t = this.lineOracle;
    return t && t.lookAhead(e);
  }
  baseToken() {
    let e = this.lineOracle;
    return e && e.baseToken(this.pos);
  }
}, Rg = Tce;
function je(e, t) {
  if (t -= e.first, t < 0 || t >= e.size)
    throw new Error("There is no line " + (t + e.first) + " in the document.");
  let r = e;
  for (; !r.lines; )
    for (let n = 0; ; ++n) {
      let o = r.children[n], s = o.chunkSize();
      if (t < s) {
        r = o;
        break;
      }
      t -= s;
    }
  return r.lines[t];
}
function ya(e, t, r) {
  let n = [], o = t.line;
  return e.iter(t.line, r.line + 1, (s) => {
    let a = s.text;
    o == r.line && (a = a.slice(0, r.ch)), o == t.line && (a = a.slice(t.ch)), n.push(a), ++o;
  }), n;
}
function S0(e, t, r) {
  let n = [];
  return e.iter(t, r, (o) => {
    n.push(o.text);
  }), n;
}
function Mi(e, t) {
  let r = t - e.height;
  if (r)
    for (let n = e; n; n = n.parent)
      n.height += r;
}
function mt(e) {
  if (e.parent == null)
    return null;
  let t = e.parent, r = mr(t.lines, e);
  for (let n = t.parent; n; t = n, n = n.parent)
    for (let o = 0; n.children[o] != t; ++o)
      r += n.children[o].chunkSize();
  return r + t.first;
}
function Zs(e, t) {
  let r = e.first;
  e:
    do {
      for (let o = 0; o < e.children.length; ++o) {
        let s = e.children[o], a = s.height;
        if (t < a) {
          e = s;
          continue e;
        }
        t -= a, r += s.chunkSize();
      }
      return r;
    } while (!e.lines);
  let n = 0;
  for (; n < e.lines.length; ++n) {
    let o = e.lines[n], s = o.height;
    if (t < s)
      break;
    t -= s;
  }
  return r + n;
}
function Jf(e, t) {
  return t >= e.first && t < e.first + e.size;
}
function fR(e, t) {
  return String(e.lineNumberFormatter(t + e.firstLineNumber));
}
function Se(e, t, r = null) {
  if (!(this instanceof Se))
    return new Se(e, t, r);
  this.line = e, this.ch = t, this.sticky = r;
}
function Ye(e, t) {
  return e.line - t.line || e.ch - t.ch;
}
function zS(e, t) {
  return e.sticky == t.sticky && Ye(e, t) == 0;
}
function GS(e) {
  return Se(e.line, e.ch);
}
function Ag(e, t) {
  return Ye(e, t) < 0 ? t : e;
}
function Tg(e, t) {
  return Ye(e, t) < 0 ? e : t;
}
function gj(e, t) {
  return Math.max(e.first, Math.min(t, e.first + e.size - 1));
}
function Ke(e, t) {
  if (t.line < e.first)
    return Se(e.first, 0);
  let r = e.first + e.size - 1;
  return t.line > r ? Se(r, je(e, r).text.length) : $ce(t, je(e, t.line).text.length);
}
function $ce(e, t) {
  let r = e.ch;
  return r == null || r > t ? Se(e.line, t) : r < 0 ? Se(e.line, 0) : e;
}
function jI(e, t) {
  let r = [];
  for (let n = 0; n < t.length; n++)
    r[n] = Ke(e, t[n]);
  return r;
}
var Nh = class {
  constructor(e, t) {
    this.state = e, this.lookAhead = t;
  }
}, Af = class {
  constructor(e, t, r, n) {
    this.state = t, this.doc = e, this.line = r, this.maxLookAhead = n || 0, this.baseTokens = null, this.baseTokenPos = 1;
  }
  lookAhead(e) {
    let t = this.doc.getLine(this.line + e);
    return t != null && e > this.maxLookAhead && (this.maxLookAhead = e), t;
  }
  baseToken(e) {
    if (!this.baseTokens)
      return null;
    for (; this.baseTokens[this.baseTokenPos] <= e; )
      this.baseTokenPos += 2;
    let t = this.baseTokens[this.baseTokenPos + 1];
    return {
      type: t && t.replace(/( |^)overlay .*/, ""),
      size: this.baseTokens[this.baseTokenPos] - e
    };
  }
  nextLine() {
    this.line++, this.maxLookAhead > 0 && this.maxLookAhead--;
  }
  static fromSaved(e, t, r) {
    return t instanceof Nh ? new Af(e, ba(e.mode, t.state), r, t.lookAhead) : new Af(e, ba(e.mode, t), r);
  }
  save(e) {
    let t = e !== !1 ? ba(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new Nh(t, this.maxLookAhead) : t;
  }
};
function bj(e, t, r, n) {
  let o = [e.state.modeGen], s = {};
  UI(e, t.text, e.doc.mode, r, (l, u) => o.push(l, u), s, n);
  let a = r.state;
  for (let l = 0; l < e.state.overlays.length; ++l) {
    r.baseTokens = o;
    let u = e.state.overlays[l], f = 1, c = 0;
    r.state = !0, UI(e, t.text, u.mode, r, (d, h) => {
      let p = f;
      for (; c < d; ) {
        let m = o[f];
        m > d && o.splice(f, 1, d, o[f + 1], m), f += 2, c = Math.min(d, m);
      }
      if (h)
        if (u.opaque)
          o.splice(p, f - p, d, "overlay " + h), f = p + 2;
        else
          for (; p < f; p += 2) {
            let m = o[p + 1];
            o[p + 1] = (m ? m + " " : "") + "overlay " + h;
          }
    }, s), r.state = a, r.baseTokens = null, r.baseTokenPos = 1;
  }
  return { styles: o, classes: s.bgClass || s.textClass ? s : null };
}
function yj(e, t, r) {
  if (!t.styles || t.styles[0] != e.state.modeGen) {
    let n = $c(e, mt(t)), o = t.text.length > e.options.maxHighlightLength && ba(e.doc.mode, n.state), s = bj(e, t, n);
    o && (n.state = o), t.stateAfter = n.save(!o), t.styles = s.styles, s.classes ? t.styleClasses = s.classes : t.styleClasses && (t.styleClasses = null), r === e.doc.highlightFrontier && (e.doc.modeFrontier = Math.max(e.doc.modeFrontier, ++e.doc.highlightFrontier));
  }
  return t.styles;
}
function $c(e, t, r) {
  let n = e.doc, o = e.display;
  if (!n.mode.startState)
    return new Af(n, !0, t);
  let s = Cce(e, t, r), a = s > n.first && je(n, s - 1).stateAfter, l = a ? Af.fromSaved(n, a, s) : new Af(n, pj(n.mode), s);
  return n.iter(s, t, (u) => {
    cR(e, u.text, l);
    let f = l.line;
    u.stateAfter = f == t - 1 || f % 5 == 0 || f >= o.viewFrom && f < o.viewTo ? l.save() : null, l.nextLine();
  }), r && (n.modeFrontier = l.line), l;
}
function cR(e, t, r, n) {
  let o = e.doc.mode, s = new Rg(t, e.options.tabSize, r);
  for (s.start = s.pos = n || 0, t == "" && mj(o, r.state); !s.eol(); )
    dR(o, s, r.state), s.start = s.pos;
}
function mj(e, t) {
  if (e.blankLine)
    return e.blankLine(t);
  if (!e.innerMode)
    return;
  let r = uR(e, t);
  if (r.mode.blankLine)
    return r.mode.blankLine(r.state);
}
function dR(e, t, r, n) {
  for (let o = 0; o < 10; o++) {
    n && (n[0] = uR(e, r).mode);
    let s = e.token(t, r);
    if (t.pos > t.start)
      return s;
  }
  throw new Error("Mode " + e.name + " failed to advance stream.");
}
var BI = class {
  constructor(e, t, r) {
    this.start = e.start, this.end = e.pos, this.string = e.current(), this.type = t || null, this.state = r;
  }
};
function qI(e, t, r, n) {
  let o = e.doc, s = o.mode, a;
  t = Ke(o, t);
  let l = je(o, t.line), u = $c(e, t.line, r), f = new Rg(l.text, e.options.tabSize, u), c;
  for (n && (c = []); (n || f.pos < t.ch) && !f.eol(); )
    f.start = f.pos, a = dR(s, f, u.state), n && c.push(new BI(f, a, ba(o.mode, u.state)));
  return n ? c : new BI(f, a, u.state);
}
function WI(e, t) {
  if (e)
    for (; ; ) {
      let r = e.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!r)
        break;
      e = e.slice(0, r.index) + e.slice(r.index + r[0].length);
      let n = r[1] ? "bgClass" : "textClass";
      t[n] == null ? t[n] = r[2] : new RegExp("(?:^|\\s)" + r[2] + "(?:$|\\s)").test(t[n]) || (t[n] += " " + r[2]);
    }
  return e;
}
function UI(e, t, r, n, o, s, a) {
  let l = r.flattenSpans;
  l == null && (l = e.options.flattenSpans);
  let u = 0, f = null, c = new Rg(t, e.options.tabSize, n), d, h = e.options.addModeClass && [null];
  for (t == "" && WI(mj(r, n.state), s); !c.eol(); ) {
    if (c.pos > e.options.maxHighlightLength ? (l = !1, a && cR(e, t, n, c.pos), c.pos = t.length, d = null) : d = WI(dR(r, c, n.state, h), s), h) {
      let p = h[0].name;
      p && (d = "m-" + (d ? p + " " + d : p));
    }
    if (!l || f != d) {
      for (; u < c.start; )
        u = Math.min(c.start, u + 5e3), o(u, f);
      f = d;
    }
    c.start = c.pos;
  }
  for (; u < c.pos; ) {
    let p = Math.min(c.pos, u + 5e3);
    o(p, f), u = p;
  }
}
function Cce(e, t, r) {
  let n, o, s = e.doc, a = r ? -1 : t - (e.doc.mode.innerMode ? 1e3 : 100);
  for (let l = t; l > a; --l) {
    if (l <= s.first)
      return s.first;
    let u = je(s, l - 1), f = u.stateAfter;
    if (f && (!r || l + (f instanceof Nh ? f.lookAhead : 0) <= s.modeFrontier))
      return l;
    let c = _n(u.text, null, e.options.tabSize);
    (o == null || n > c) && (o = l - 1, n = c);
  }
  return o;
}
function kce(e, t) {
  if (e.modeFrontier = Math.min(e.modeFrontier, t), e.highlightFrontier < t - 10)
    return;
  let r = e.first;
  for (let n = t - 1; n > r; n--) {
    let o = je(e, n).stateAfter;
    if (o && (!(o instanceof Nh) || n + o.lookAhead < t)) {
      r = n + 1;
      break;
    }
  }
  e.highlightFrontier = Math.min(e.highlightFrontier, r);
}
var vj = !1, yo = !1;
function Ice() {
  vj = !0;
}
function Mce() {
  yo = !0;
}
function $g(e, t, r) {
  this.marker = e, this.from = t, this.to = r;
}
function Qf(e, t) {
  if (e)
    for (let r = 0; r < e.length; ++r) {
      let n = e[r];
      if (n.marker == t)
        return n;
    }
}
function Nce(e, t) {
  let r;
  for (let n = 0; n < e.length; ++n)
    e[n] != t && (r || (r = [])).push(e[n]);
  return r;
}
function Lce(e, t) {
  e.markedSpans = e.markedSpans ? e.markedSpans.concat([t]) : [t], t.marker.attachLine(e);
}
function Oce(e, t, r) {
  let n;
  if (e)
    for (let o = 0; o < e.length; ++o) {
      let s = e[o], a = s.marker;
      if (s.from == null || (a.inclusiveLeft ? s.from <= t : s.from < t) || s.from == t && a.type == "bookmark" && (!r || !s.marker.insertLeft)) {
        let u = s.to == null || (a.inclusiveRight ? s.to >= t : s.to > t);
        (n || (n = [])).push(new $g(a, s.from, u ? null : s.to));
      }
    }
  return n;
}
function Pce(e, t, r) {
  let n;
  if (e)
    for (let o = 0; o < e.length; ++o) {
      let s = e[o], a = s.marker;
      if (s.to == null || (a.inclusiveRight ? s.to >= t : s.to > t) || s.from == t && a.type == "bookmark" && (!r || s.marker.insertLeft)) {
        let u = s.from == null || (a.inclusiveLeft ? s.from <= t : s.from < t);
        (n || (n = [])).push(new $g(a, u ? null : s.from - t, s.to == null ? null : s.to - t));
      }
    }
  return n;
}
function VS(e, t) {
  if (t.full)
    return null;
  let r = Jf(e, t.from.line) && je(e, t.from.line).markedSpans, n = Jf(e, t.to.line) && je(e, t.to.line).markedSpans;
  if (!r && !n)
    return null;
  let o = t.from.ch, s = t.to.ch, a = Ye(t.from, t.to) == 0, l = Oce(r, o, a), u = Pce(n, s, a), f = t.text.length == 1, c = yt(t.text).length + (f ? o : 0);
  if (l)
    for (let h = 0; h < l.length; ++h) {
      let p = l[h];
      if (p.to == null) {
        let m = Qf(u, p.marker);
        m ? f && (p.to = m.to == null ? null : m.to + c) : p.to = o;
      }
    }
  if (u)
    for (let h = 0; h < u.length; ++h) {
      let p = u[h];
      p.to != null && (p.to += c), p.from == null ? Qf(l, p.marker) || (p.from = c, f && (l || (l = [])).push(p)) : (p.from += c, f && (l || (l = [])).push(p));
    }
  l && (l = HI(l)), u && u != l && (u = HI(u));
  let d = [l];
  if (!f) {
    let h = t.text.length - 2, p;
    if (h > 0 && l)
      for (let m = 0; m < l.length; ++m)
        l[m].to == null && (p || (p = [])).push(new $g(l[m].marker, null, null));
    for (let m = 0; m < h; ++m)
      d.push(p);
    d.push(u);
  }
  return d;
}
function HI(e) {
  for (let t = 0; t < e.length; ++t) {
    let r = e[t];
    r.from != null && r.from == r.to && r.marker.clearWhenEmpty !== !1 && e.splice(t--, 1);
  }
  return e.length ? e : null;
}
function Dce(e, t, r) {
  let n = null;
  if (e.iter(t.line, r.line + 1, (s) => {
    if (s.markedSpans)
      for (let a = 0; a < s.markedSpans.length; ++a) {
        let l = s.markedSpans[a].marker;
        l.readOnly && (!n || mr(n, l) == -1) && (n || (n = [])).push(l);
      }
  }), !n)
    return null;
  let o = [{ from: t, to: r }];
  for (let s = 0; s < n.length; ++s) {
    let a = n[s], l = a.find(0);
    for (let u = 0; u < o.length; ++u) {
      let f = o[u];
      if (Ye(f.to, l.from) < 0 || Ye(f.from, l.to) > 0)
        continue;
      let c = [u, 1], d = Ye(f.from, l.from), h = Ye(f.to, l.to);
      (d < 0 || !a.inclusiveLeft && !d) && c.push({ from: f.from, to: l.from }), (h > 0 || !a.inclusiveRight && !h) && c.push({ from: l.to, to: f.to }), o.splice.apply(o, c), u += c.length - 3;
    }
  }
  return o;
}
function wj(e) {
  let t = e.markedSpans;
  if (t) {
    for (let r = 0; r < t.length; ++r)
      t[r].marker.detachLine(e);
    e.markedSpans = null;
  }
}
function _j(e, t) {
  if (t) {
    for (let r = 0; r < t.length; ++r)
      t[r].marker.attachLine(e);
    e.markedSpans = t;
  }
}
function Lh(e) {
  return e.inclusiveLeft ? -1 : 0;
}
function Oh(e) {
  return e.inclusiveRight ? 1 : 0;
}
function hR(e, t) {
  let r = e.lines.length - t.lines.length;
  if (r != 0)
    return r;
  let n = e.find(), o = t.find(), s = Ye(n.from, o.from) || Lh(e) - Lh(t);
  if (s)
    return -s;
  let a = Ye(n.to, o.to) || Oh(e) - Oh(t);
  return a || t.id - e.id;
}
function Sj(e, t) {
  let r = yo && e.markedSpans, n;
  if (r)
    for (let o, s = 0; s < r.length; ++s)
      o = r[s], o.marker.collapsed && (t ? o.from : o.to) == null && (!n || hR(n, o.marker) < 0) && (n = o.marker);
  return n;
}
function Ej(e) {
  return Sj(e, !0);
}
function Cg(e) {
  return Sj(e, !1);
}
function Fce(e, t) {
  let r = yo && e.markedSpans, n;
  if (r)
    for (let o = 0; o < r.length; ++o) {
      let s = r[o];
      s.marker.collapsed && (s.from == null || s.from < t) && (s.to == null || s.to > t) && (!n || hR(n, s.marker) < 0) && (n = s.marker);
    }
  return n;
}
function zI(e, t, r, n, o) {
  let s = je(e, t), a = yo && s.markedSpans;
  if (a)
    for (let l = 0; l < a.length; ++l) {
      let u = a[l];
      if (!u.marker.collapsed)
        continue;
      let f = u.marker.find(0), c = Ye(f.from, r) || Lh(u.marker) - Lh(o), d = Ye(f.to, n) || Oh(u.marker) - Oh(o);
      if (!(c >= 0 && d <= 0 || c <= 0 && d >= 0) && (c <= 0 && (u.marker.inclusiveRight && o.inclusiveLeft ? Ye(f.to, r) >= 0 : Ye(f.to, r) > 0) || c >= 0 && (u.marker.inclusiveRight && o.inclusiveLeft ? Ye(f.from, n) <= 0 : Ye(f.from, n) < 0)))
        return !0;
    }
}
function Ni(e) {
  let t;
  for (; t = Ej(e); )
    e = t.find(-1, !0).line;
  return e;
}
function jce(e) {
  let t;
  for (; t = Cg(e); )
    e = t.find(1, !0).line;
  return e;
}
function Bce(e) {
  let t, r;
  for (; t = Cg(e); )
    e = t.find(1, !0).line, (r || (r = [])).push(e);
  return r;
}
function pR(e, t) {
  let r = je(e, t), n = Ni(r);
  return r == n ? t : mt(n);
}
function xj(e, t) {
  if (t > e.lastLine())
    return t;
  let r = je(e, t), n;
  if (!cs(e, r))
    return t;
  for (; n = Cg(r); )
    r = n.find(1, !0).line;
  return mt(r) + 1;
}
function cs(e, t) {
  let r = yo && t.markedSpans;
  if (r) {
    for (let n, o = 0; o < r.length; ++o)
      if (n = r[o], !!n.marker.collapsed) {
        if (n.from == null)
          return !0;
        if (!n.marker.widgetNode && n.from == 0 && n.marker.inclusiveLeft && KS(e, t, n))
          return !0;
      }
  }
}
function KS(e, t, r) {
  if (r.to == null) {
    let n = r.marker.find(1, !0);
    return KS(e, n.line, Qf(n.line.markedSpans, r.marker));
  }
  if (r.marker.inclusiveRight && r.to == t.text.length)
    return !0;
  for (let n, o = 0; o < t.markedSpans.length; ++o)
    if (n = t.markedSpans[o], n.marker.collapsed && !n.marker.widgetNode && n.from == r.to && (n.to == null || n.to != r.from) && (n.marker.inclusiveLeft || r.marker.inclusiveRight) && KS(e, t, n))
      return !0;
}
function mo(e) {
  e = Ni(e);
  let t = 0, r = e.parent;
  for (let n = 0; n < r.lines.length; ++n) {
    let o = r.lines[n];
    if (o == e)
      break;
    t += o.height;
  }
  for (let n = r.parent; n; r = n, n = r.parent)
    for (let o = 0; o < n.children.length; ++o) {
      let s = n.children[o];
      if (s == r)
        break;
      t += s.height;
    }
  return t;
}
function Ph(e) {
  if (e.height == 0)
    return 0;
  let t = e.text.length, r, n = e;
  for (; r = Ej(n); ) {
    let o = r.find(0, !0);
    n = o.from.line, t += o.from.ch - o.to.ch;
  }
  for (n = e; r = Cg(n); ) {
    let o = r.find(0, !0);
    t -= n.text.length - o.from.ch, n = o.to.line, t += n.text.length - o.to.ch;
  }
  return t;
}
function gR(e) {
  let t = e.display, r = e.doc;
  t.maxLine = je(r, r.first), t.maxLineLength = Ph(t.maxLine), t.maxLineChanged = !0, r.iter((n) => {
    let o = Ph(n);
    o > t.maxLineLength && (t.maxLineLength = o, t.maxLine = n);
  });
}
var Zf = class {
  constructor(e, t, r) {
    this.text = e, _j(this, t), this.height = r ? r(this) : 1;
  }
  lineNo() {
    return mt(this);
  }
};
wu(Zf);
function qce(e, t, r, n) {
  e.text = t, e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null), e.order != null && (e.order = null), wj(e), _j(e, r);
  let o = n ? n(e) : 1;
  o != e.height && Mi(e, o);
}
function Wce(e) {
  e.parent = null, wj(e);
}
var Uce = {}, Hce = {};
function GI(e, t) {
  if (!e || /^\s*$/.test(e))
    return null;
  let r = t.addModeClass ? Hce : Uce;
  return r[e] || (r[e] = e.replace(/\S+/g, "cm-$&"));
}
function Rj(e, t) {
  let r = Pl("span", null, null, Tr ? "padding-right: .1px" : null), n = {
    pre: Pl("pre", [r], "CodeMirror-line"),
    content: r,
    col: 0,
    pos: 0,
    cm: e,
    trailingSpace: !1,
    splitSpaces: e.getOption("lineWrapping")
  };
  t.measure = {};
  for (let o = 0; o <= (t.rest ? t.rest.length : 0); o++) {
    let s = o ? t.rest[o - 1] : t.line, a;
    n.pos = 0, n.addToken = Gce, wce(e.display.measure) && (a = $o(s, e.doc.direction)) && (n.addToken = Kce(n.addToken, a)), n.map = [];
    let l = t != e.display.externalMeasured && mt(s);
    Yce(s, n, yj(e, s, l)), s.styleClasses && (s.styleClasses.bgClass && (n.bgClass = y0(s.styleClasses.bgClass, n.bgClass || "")), s.styleClasses.textClass && (n.textClass = y0(s.styleClasses.textClass, n.textClass || ""))), n.map.length == 0 && n.map.push(0, 0, n.content.appendChild(vce(e.display.measure))), o == 0 ? (t.measure.map = n.map, t.measure.cache = {}) : ((t.measure.maps || (t.measure.maps = [])).push(n.map), (t.measure.caches || (t.measure.caches = [])).push({}));
  }
  if (Tr) {
    let o = n.content.lastChild;
    (/\bcm-tab\b/.test(o.className) || o.querySelector && o.querySelector(".cm-tab")) && (n.content.className = "cm-tab-wrap-hack");
  }
  return Ht(e, "renderLine", e, t.line, n.pre), n.pre.className && (n.textClass = y0(n.pre.className, n.textClass || "")), n;
}
function zce(e) {
  let t = Ue("span", "", "cm-invalidchar");
  return t.title = "\\u" + e.charCodeAt(0).toString(16), t.setAttribute("aria-label", t.title), t;
}
function Gce(e, t, r, n, o, s, a) {
  if (!t)
    return;
  let l = e.splitSpaces ? Vce(t, e.trailingSpace) : t, u = e.cm.state.specialChars, f = !1, c;
  if (!u.test(t))
    e.col += t.length, c = document.createTextNode(l), e.map.push(e.pos, e.pos + t.length, c), ct && kt < 9 && (f = !0), e.pos += t.length;
  else {
    c = document.createDocumentFragment();
    let d = 0;
    for (; ; ) {
      u.lastIndex = d;
      let h = u.exec(t), p = h ? h.index - d : t.length - d;
      if (p) {
        let y = document.createTextNode(l.slice(d, d + p));
        ct && kt < 9 ? c.appendChild(Ue("span", [y])) : c.appendChild(y), e.map.push(e.pos, e.pos + p, y), e.col += p, e.pos += p;
      }
      if (!h)
        break;
      d += p + 1;
      let m;
      if (h[0] == "	") {
        let y = e.cm.options.tabSize, _ = y - e.col % y;
        m = c.appendChild(Ue("span", nR(_), "cm-tab")), m.setAttribute("role", "presentation"), m.setAttribute("cm-text", "	"), e.col += _;
      } else
        h[0] == "\r" || h[0] == `
` ? (m = c.appendChild(Ue("span", h[0] == "\r" ? "" : "", "cm-invalidchar")), m.setAttribute("cm-text", h[0]), e.col += 1) : (m = e.cm.options.specialCharPlaceholder(h[0]), m.setAttribute("cm-text", h[0]), ct && kt < 9 ? c.appendChild(Ue("span", [m])) : c.appendChild(m), e.col += 1);
      e.map.push(e.pos, e.pos + 1, m), e.pos++;
    }
  }
  if (e.trailingSpace = l.charCodeAt(t.length - 1) == 32, r || n || o || f || s || a) {
    let d = r || "";
    n && (d += n), o && (d += o);
    let h = Ue("span", [c], d, s);
    if (a)
      for (let p in a)
        a.hasOwnProperty(p) && p != "style" && p != "class" && h.setAttribute(p, a[p]);
    return e.content.appendChild(h);
  }
  e.content.appendChild(c);
}
function Vce(e, t) {
  if (e.length > 1 && !/  /.test(e))
    return e;
  let r = t, n = "";
  for (let o = 0; o < e.length; o++) {
    let s = e.charAt(o);
    s == " " && r && (o == e.length - 1 || e.charCodeAt(o + 1) == 32) && (s = ""), n += s, r = s == " ";
  }
  return n;
}
function Kce(e, t) {
  return (r, n, o, s, a, l, u) => {
    o = o ? o + " cm-force-border" : "cm-force-border";
    let f = r.pos, c = f + n.length;
    for (; ; ) {
      let d;
      for (let h = 0; h < t.length && (d = t[h], !(d.to > f && d.from <= f)); h++)
        ;
      if (d.to >= c)
        return e(r, n, o, s, a, l, u);
      e(r, n.slice(0, d.to - f), o, s, null, l, u), s = null, n = n.slice(d.to - f), f = d.to;
    }
  };
}
function VI(e, t, r, n) {
  let o = !n && r.widgetNode;
  o && e.map.push(e.pos, e.pos + t, o), !n && e.cm.display.input.needsContentAttribute && (o || (o = e.content.appendChild(document.createElement("span"))), o.setAttribute("cm-marker", r.id)), o && (e.cm.display.input.setUneditable(o), e.content.appendChild(o)), e.pos += t, e.trailingSpace = !1;
}
function Yce(e, t, r) {
  let n = e.markedSpans, o = e.text, s = 0;
  if (!n) {
    for (let x = 1; x < r.length; x += 2)
      t.addToken(t, o.slice(s, s = r[x]), GI(r[x + 1], t.cm.options));
    return;
  }
  let a = o.length, l = 0, u = 1, f = "", c, d, h = 0, p, m, y, _, S;
  for (; ; ) {
    if (h == l) {
      p = m = y = d = "", S = null, _ = null, h = 1 / 0;
      let E = [], C;
      for (let I = 0; I < n.length; ++I) {
        let j = n[I], J = j.marker;
        if (J.type == "bookmark" && j.from == l && J.widgetNode)
          E.push(J);
        else if (j.from <= l && (j.to == null || j.to > l || J.collapsed && j.to == l && j.from == l)) {
          if (j.to != null && j.to != l && h > j.to && (h = j.to, m = ""), J.className && (p += " " + J.className), J.css && (d = (d ? d + ";" : "") + J.css), J.startStyle && j.from == l && (y += " " + J.startStyle), J.endStyle && j.to == h && (C || (C = [])).push(J.endStyle, j.to), J.title && ((S || (S = {})).title = J.title), J.attributes)
            for (let G in J.attributes)
              (S || (S = {}))[G] = J.attributes[G];
          J.collapsed && (!_ || hR(_.marker, J) < 0) && (_ = j);
        } else
          j.from > l && h > j.from && (h = j.from);
      }
      if (C)
        for (let I = 0; I < C.length; I += 2)
          C[I + 1] == h && (m += " " + C[I]);
      if (!_ || _.from == l)
        for (let I = 0; I < E.length; ++I)
          VI(t, 0, E[I]);
      if (_ && (_.from || 0) == l) {
        if (VI(t, (_.to == null ? a + 1 : _.to) - l, _.marker, _.from == null), _.to == null)
          return;
        _.to == l && (_ = !1);
      }
    }
    if (l >= a)
      break;
    let x = Math.min(a, h);
    for (; ; ) {
      if (f) {
        let E = l + f.length;
        if (!_) {
          let C = E > x ? f.slice(0, x - l) : f;
          t.addToken(t, C, c ? c + p : p, y, l + C.length == h ? m : "", d, S);
        }
        if (E >= x) {
          f = f.slice(x - l), l = x;
          break;
        }
        l = E, y = "";
      }
      f = o.slice(s, s = r[u++]), c = GI(r[u++], t.cm.options);
    }
  }
}
function Aj(e, t, r) {
  this.line = t, this.rest = Bce(t), this.size = this.rest ? mt(yt(this.rest)) - r + 1 : 1, this.node = this.text = null, this.hidden = cs(e, t);
}
function Gd(e, t, r) {
  let n = [], o;
  for (let s = t; s < r; s = o) {
    let a = new Aj(e.doc, je(e.doc, s), s);
    o = s + a.size, n.push(a);
  }
  return n;
}
var Fl = null;
function Xce(e) {
  Fl ? Fl.ops.push(e) : e.ownsGroup = Fl = {
    ops: [e],
    delayedCallbacks: []
  };
}
function Jce(e) {
  let t = e.delayedCallbacks, r = 0;
  do {
    for (; r < t.length; r++)
      t[r].call(null);
    for (let n = 0; n < e.ops.length; n++) {
      let o = e.ops[n];
      if (o.cursorActivityHandlers)
        for (; o.cursorActivityCalled < o.cursorActivityHandlers.length; )
          o.cursorActivityHandlers[o.cursorActivityCalled++].call(null, o.cm);
    }
  } while (r < t.length);
}
function Qce(e, t) {
  let r = e.ownsGroup;
  if (r)
    try {
      Jce(r);
    } finally {
      Fl = null, t(r);
    }
}
var Tf = null;
function ir(e, t) {
  let r = iR(e, t);
  if (!r.length)
    return;
  let n = Array.prototype.slice.call(arguments, 2), o;
  Fl ? o = Fl.delayedCallbacks : Tf ? o = Tf : (o = Tf = [], setTimeout(Zce, 0));
  for (let s = 0; s < r.length; ++s)
    o.push(() => r[s].apply(null, n));
}
function Zce() {
  let e = Tf;
  Tf = null;
  for (let t = 0; t < e.length; ++t)
    e[t]();
}
function Tj(e, t, r, n) {
  for (let o = 0; o < t.changes.length; o++) {
    let s = t.changes[o];
    s == "text" ? tde(e, t) : s == "gutter" ? Cj(e, t, r, n) : s == "class" ? bR(e, t) : s == "widget" && rde(e, t, n);
  }
  t.changes = null;
}
function ec(e) {
  return e.node == e.text && (e.node = Ue("div", null, null, "position: relative"), e.text.parentNode && e.text.parentNode.replaceChild(e.node, e.text), e.node.appendChild(e.text), ct && kt < 8 && (e.node.style.zIndex = 2)), e.node;
}
function ede(e, t) {
  let r = t.bgClass ? t.bgClass + " " + (t.line.bgClass || "") : t.line.bgClass;
  if (r && (r += " CodeMirror-linebackground"), t.background)
    r ? t.background.className = r : (t.background.parentNode.removeChild(t.background), t.background = null);
  else if (r) {
    let n = ec(t);
    t.background = n.insertBefore(Ue("div", null, r), n.firstChild), e.display.input.setUneditable(t.background);
  }
}
function $j(e, t) {
  let r = e.display.externalMeasured;
  return r && r.line == t.line ? (e.display.externalMeasured = null, t.measure = r.measure, r.built) : Rj(e, t);
}
function tde(e, t) {
  let r = t.text.className, n = $j(e, t);
  t.text == t.node && (t.node = n.pre), t.text.parentNode.replaceChild(n.pre, t.text), t.text = n.pre, n.bgClass != t.bgClass || n.textClass != t.textClass ? (t.bgClass = n.bgClass, t.textClass = n.textClass, bR(e, t)) : r && (t.text.className = r);
}
function bR(e, t) {
  ede(e, t), t.line.wrapClass ? ec(t).className = t.line.wrapClass : t.node != t.text && (t.node.className = "");
  let r = t.textClass ? t.textClass + " " + (t.line.textClass || "") : t.line.textClass;
  t.text.className = r || "";
}
function Cj(e, t, r, n) {
  if (t.gutter && (t.node.removeChild(t.gutter), t.gutter = null), t.gutterBackground && (t.node.removeChild(t.gutterBackground), t.gutterBackground = null), t.line.gutterClass) {
    let s = ec(t);
    t.gutterBackground = Ue("div", null, "CodeMirror-gutter-background " + t.line.gutterClass, `left: ${e.options.fixedGutter ? n.fixedPos : -n.gutterTotalWidth}px; width: ${n.gutterTotalWidth}px`), e.display.input.setUneditable(t.gutterBackground), s.insertBefore(t.gutterBackground, t.text);
  }
  let o = t.line.gutterMarkers;
  if (e.options.lineNumbers || o) {
    let s = ec(t), a = t.gutter = Ue("div", null, "CodeMirror-gutter-wrapper", `left: ${e.options.fixedGutter ? n.fixedPos : -n.gutterTotalWidth}px`);
    if (a.setAttribute("aria-hidden", "true"), e.display.input.setUneditable(a), s.insertBefore(a, t.text), t.line.gutterClass && (a.className += " " + t.line.gutterClass), e.options.lineNumbers && (!o || !o["CodeMirror-linenumbers"]) && (t.lineNumber = a.appendChild(Ue("div", fR(e.options, r), "CodeMirror-linenumber CodeMirror-gutter-elt", `left: ${n.gutterLeft["CodeMirror-linenumbers"]}px; width: ${e.display.lineNumInnerWidth}px`))), o)
      for (let l = 0; l < e.display.gutterSpecs.length; ++l) {
        let u = e.display.gutterSpecs[l].className, f = o.hasOwnProperty(u) && o[u];
        f && a.appendChild(Ue("div", [f], "CodeMirror-gutter-elt", `left: ${n.gutterLeft[u]}px; width: ${n.gutterWidth[u]}px`));
      }
  }
}
function rde(e, t, r) {
  t.alignable && (t.alignable = null);
  let n = Zl("CodeMirror-linewidget");
  for (let o = t.node.firstChild, s; o; o = s)
    s = o.nextSibling, n.test(o.className) && t.node.removeChild(o);
  kj(e, t, r);
}
function nde(e, t, r, n) {
  let o = $j(e, t);
  return t.text = t.node = o.pre, o.bgClass && (t.bgClass = o.bgClass), o.textClass && (t.textClass = o.textClass), bR(e, t), Cj(e, t, r, n), kj(e, t, n), t.node;
}
function kj(e, t, r) {
  if (KI(e, t.line, t, r, !0), t.rest)
    for (let n = 0; n < t.rest.length; n++)
      KI(e, t.rest[n], t, r, !1);
}
function KI(e, t, r, n, o) {
  if (!t.widgets)
    return;
  let s = ec(r);
  for (let a = 0, l = t.widgets; a < l.length; ++a) {
    let u = l[a], f = Ue("div", [u.node], "CodeMirror-linewidget" + (u.className ? " " + u.className : ""));
    u.handleMouseEvents || f.setAttribute("cm-ignore-events", "true"), ide(u, f, r, n), e.display.input.setUneditable(f), o && u.above ? s.insertBefore(f, r.gutter || r.text) : s.appendChild(f), ir(u, "redraw");
  }
}
function ide(e, t, r, n) {
  if (e.noHScroll) {
    (r.alignable || (r.alignable = [])).push(t);
    let o = n.wrapperWidth;
    t.style.left = n.fixedPos + "px", e.coverGutter || (o -= n.gutterTotalWidth, t.style.paddingLeft = n.gutterTotalWidth + "px"), t.style.width = o + "px";
  }
  e.coverGutter && (t.style.zIndex = 5, t.style.position = "relative", e.noHScroll || (t.style.marginLeft = -n.gutterTotalWidth + "px"));
}
function tc(e) {
  if (e.height != null)
    return e.height;
  let t = e.doc.cm;
  if (!t)
    return 0;
  if (!fs(document.body, e.node)) {
    let r = "position: relative;";
    e.coverGutter && (r += "margin-left: -" + t.display.gutters.offsetWidth + "px;"), e.noHScroll && (r += "width: " + t.display.wrapper.clientWidth + "px;"), hn(t.display.measure, Ue("div", [e.node], null, r));
  }
  return e.height = e.node.parentNode.offsetHeight;
}
function vo(e, t) {
  for (let r = oR(t); r != e.wrapper; r = r.parentNode)
    if (!r || r.nodeType == 1 && r.getAttribute("cm-ignore-events") == "true" || r.parentNode == e.sizer && r != e.mover)
      return !0;
}
function kg(e) {
  return e.lineSpace.offsetTop;
}
function yR(e) {
  return e.mover.offsetHeight - e.lineSpace.offsetHeight;
}
function Ij(e) {
  if (e.cachedPaddingH)
    return e.cachedPaddingH;
  let t = hn(e.measure, Ue("pre", "x", "CodeMirror-line-like")), r = window.getComputedStyle ? window.getComputedStyle(t) : t.currentStyle, n = { left: parseInt(r.paddingLeft), right: parseInt(r.paddingRight) };
  return !isNaN(n.left) && !isNaN(n.right) && (e.cachedPaddingH = n), n;
}
function Li(e) {
  return aj - e.display.nativeBarWidth;
}
function tl(e) {
  return e.display.scroller.clientWidth - Li(e) - e.display.barWidth;
}
function mR(e) {
  return e.display.scroller.clientHeight - Li(e) - e.display.barHeight;
}
function ode(e, t, r) {
  let n = e.options.lineWrapping, o = n && tl(e);
  if (!t.measure.heights || n && t.measure.width != o) {
    let s = t.measure.heights = [];
    if (n) {
      t.measure.width = o;
      let a = t.text.firstChild.getClientRects();
      for (let l = 0; l < a.length - 1; l++) {
        let u = a[l], f = a[l + 1];
        Math.abs(u.bottom - f.bottom) > 2 && s.push((u.bottom + f.top) / 2 - r.top);
      }
    }
    s.push(r.bottom - r.top);
  }
}
function Mj(e, t, r) {
  if (e.line == t)
    return { map: e.measure.map, cache: e.measure.cache };
  for (let n = 0; n < e.rest.length; n++)
    if (e.rest[n] == t)
      return { map: e.measure.maps[n], cache: e.measure.caches[n] };
  for (let n = 0; n < e.rest.length; n++)
    if (mt(e.rest[n]) > r)
      return { map: e.measure.maps[n], cache: e.measure.caches[n], before: !0 };
}
function sde(e, t) {
  t = Ni(t);
  let r = mt(t), n = e.display.externalMeasured = new Aj(e.doc, t, r);
  n.lineN = r;
  let o = n.built = Rj(e, n);
  return n.text = o.pre, hn(e.display.lineMeasure, o.pre), n;
}
function Nj(e, t, r, n) {
  return Oi(e, _u(e, t), r, n);
}
function vR(e, t) {
  if (t >= e.display.viewFrom && t < e.display.viewTo)
    return e.display.view[Ma(e, t)];
  let r = e.display.externalMeasured;
  if (r && t >= r.lineN && t < r.lineN + r.size)
    return r;
}
function _u(e, t) {
  let r = mt(t), n = vR(e, r);
  n && !n.text ? n = null : n && n.changes && (Tj(e, n, r, SR(e)), e.curOp.forceUpdate = !0), n || (n = sde(e, t));
  let o = Mj(n, t, r);
  return {
    line: t,
    view: n,
    rect: null,
    map: o.map,
    cache: o.cache,
    before: o.before,
    hasHeights: !1
  };
}
function Oi(e, t, r, n, o) {
  t.before && (r = -1);
  let s = r + (n || ""), a;
  return t.cache.hasOwnProperty(s) ? a = t.cache[s] : (t.rect || (t.rect = t.view.text.getBoundingClientRect()), t.hasHeights || (ode(e, t.view, t.rect), t.hasHeights = !0), a = lde(e, t, r, n), a.bogus || (t.cache[s] = a)), {
    left: a.left,
    right: a.right,
    top: o ? a.rtop : a.top,
    bottom: o ? a.rbottom : a.bottom
  };
}
var Lj = { left: 0, right: 0, top: 0, bottom: 0 };
function Oj(e, t, r) {
  let n, o, s, a, l, u;
  for (let f = 0; f < e.length; f += 3)
    if (l = e[f], u = e[f + 1], t < l ? (o = 0, s = 1, a = "left") : t < u ? (o = t - l, s = o + 1) : (f == e.length - 3 || t == u && e[f + 3] > t) && (s = u - l, o = s - 1, t >= u && (a = "right")), o != null) {
      if (n = e[f + 2], l == u && r == (n.insertLeft ? "left" : "right") && (a = r), r == "left" && o == 0)
        for (; f && e[f - 2] == e[f - 3] && e[f - 1].insertLeft; )
          n = e[(f -= 3) + 2], a = "left";
      if (r == "right" && o == u - l)
        for (; f < e.length - 3 && e[f + 3] == e[f + 4] && !e[f + 5].insertLeft; )
          n = e[(f += 3) + 2], a = "right";
      break;
    }
  return { node: n, start: o, end: s, collapse: a, coverStart: l, coverEnd: u };
}
function ade(e, t) {
  let r = Lj;
  if (t == "left")
    for (let n = 0; n < e.length && (r = e[n]).left == r.right; n++)
      ;
  else
    for (let n = e.length - 1; n >= 0 && (r = e[n]).left == r.right; n--)
      ;
  return r;
}
function lde(e, t, r, n) {
  let o = Oj(t.map, r, n), s = o.node, a = o.start, l = o.end, u = o.collapse, f;
  if (s.nodeType == 3) {
    for (let x = 0; x < 4; x++) {
      for (; a && US(t.line.text.charAt(o.coverStart + a)); )
        --a;
      for (; o.coverStart + l < o.coverEnd && US(t.line.text.charAt(o.coverStart + l)); )
        ++l;
      if (ct && kt < 9 && a == 0 && l == o.coverEnd - o.coverStart ? f = s.parentNode.getBoundingClientRect() : f = ade(Ca(s, a, l).getClientRects(), n), f.left || f.right || a == 0)
        break;
      l = a, a = a - 1, u = "right";
    }
    ct && kt < 11 && (f = ude(e.display.measure, f));
  } else {
    a > 0 && (u = n = "right");
    let x;
    e.options.lineWrapping && (x = s.getClientRects()).length > 1 ? f = x[n == "right" ? x.length - 1 : 0] : f = s.getBoundingClientRect();
  }
  if (ct && kt < 9 && !a && (!f || !f.left && !f.right)) {
    let x = s.parentNode.getClientRects()[0];
    x ? f = { left: x.left, right: x.left + Su(e.display), top: x.top, bottom: x.bottom } : f = Lj;
  }
  let c = f.top - t.rect.top, d = f.bottom - t.rect.top, h = (c + d) / 2, p = t.view.measure.heights, m = 0;
  for (; m < p.length - 1 && !(h < p[m]); m++)
    ;
  let y = m ? p[m - 1] : 0, _ = p[m], S = {
    left: (u == "right" ? f.right : f.left) - t.rect.left,
    right: (u == "left" ? f.left : f.right) - t.rect.left,
    top: y,
    bottom: _
  };
  return !f.left && !f.right && (S.bogus = !0), e.options.singleCursorHeightPerLine || (S.rtop = c, S.rbottom = d), S;
}
function ude(e, t) {
  if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !Ece(e))
    return t;
  let r = screen.logicalXDPI / screen.deviceXDPI, n = screen.logicalYDPI / screen.deviceYDPI;
  return {
    left: t.left * r,
    right: t.right * r,
    top: t.top * n,
    bottom: t.bottom * n
  };
}
function Pj(e) {
  if (e.measure && (e.measure.cache = {}, e.measure.heights = null, e.rest))
    for (let t = 0; t < e.rest.length; t++)
      e.measure.caches[t] = {};
}
function Dj(e) {
  e.display.externalMeasure = null, us(e.display.lineMeasure);
  for (let t = 0; t < e.display.view.length; t++)
    Pj(e.display.view[t]);
}
function rc(e) {
  Dj(e), e.display.cachedCharWidth = e.display.cachedTextHeight = e.display.cachedPaddingH = null, e.options.lineWrapping || (e.display.maxLineChanged = !0), e.display.lineNumChars = null;
}
function Fj() {
  return wg && Sg ? -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) : window.pageXOffset || (document.documentElement || document.body).scrollLeft;
}
function jj() {
  return wg && Sg ? -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) : window.pageYOffset || (document.documentElement || document.body).scrollTop;
}
function wR(e) {
  let t = 0;
  if (e.widgets)
    for (let r = 0; r < e.widgets.length; ++r)
      e.widgets[r].above && (t += tc(e.widgets[r]));
  return t;
}
function Ig(e, t, r, n, o) {
  if (!o) {
    let a = wR(t);
    r.top += a, r.bottom += a;
  }
  if (n == "line")
    return r;
  n || (n = "local");
  let s = mo(t);
  if (n == "local" ? s += kg(e.display) : s -= e.display.viewOffset, n == "page" || n == "window") {
    let a = e.display.lineSpace.getBoundingClientRect();
    s += a.top + (n == "window" ? 0 : jj());
    let l = a.left + (n == "window" ? 0 : Fj());
    r.left += l, r.right += l;
  }
  return r.top += s, r.bottom += s, r;
}
function YI(e, t, r) {
  if (r == "div")
    return t;
  let n = t.left, o = t.top;
  if (r == "page")
    n -= Fj(), o -= jj();
  else if (r == "local" || !r) {
    let a = e.display.sizer.getBoundingClientRect();
    n += a.left, o += a.top;
  }
  let s = e.display.lineSpace.getBoundingClientRect();
  return { left: n - s.left, top: o - s.top };
}
function YS(e, t, r, n, o) {
  return n || (n = je(e.doc, t.line)), Ig(e, n, Nj(e, n, t.ch, o), r);
}
function Gn(e, t, r, n, o, s) {
  n = n || je(e.doc, t.line), o || (o = _u(e, n));
  function a(m, y) {
    let _ = Oi(e, o, m, y ? "right" : "left", s);
    return y ? _.left = _.right : _.right = _.left, Ig(e, n, _, r);
  }
  let l = $o(n, e.doc.direction), u = t.ch, f = t.sticky;
  if (u >= n.text.length ? (u = n.text.length, f = "before") : u <= 0 && (u = 0, f = "after"), !l)
    return a(f == "before" ? u - 1 : u, f == "before");
  function c(m, y, _) {
    let S = l[y], x = S.level == 1;
    return a(_ ? m - 1 : m, x != _);
  }
  let d = Yf(l, u, f), h = ef, p = c(u, d, f == "before");
  return h != null && (p.other = c(u, h, f != "before")), p;
}
function XI(e, t) {
  let r = 0;
  t = Ke(e.doc, t), e.options.lineWrapping || (r = Su(e.display) * t.ch);
  let n = je(e.doc, t.line), o = mo(n) + kg(e.display);
  return { left: r, right: r, top: o, bottom: o + n.height };
}
function XS(e, t, r, n, o) {
  let s = Se(e, t, r);
  return s.xRel = o, n && (s.outside = n), s;
}
function _R(e, t, r) {
  let n = e.doc;
  if (r += e.display.viewOffset, r < 0)
    return XS(n.first, 0, null, -1, -1);
  let o = Zs(n, r), s = n.first + n.size - 1;
  if (o > s)
    return XS(n.first + n.size - 1, je(n, s).text.length, null, 1, 1);
  t < 0 && (t = 0);
  let a = je(n, o);
  for (; ; ) {
    let l = fde(e, a, o, t, r), u = Fce(a, l.ch + (l.xRel > 0 || l.outside > 0 ? 1 : 0));
    if (!u)
      return l;
    let f = u.find(1);
    if (f.line == o)
      return f;
    a = je(n, o = f.line);
  }
}
function Bj(e, t, r, n) {
  n -= wR(t);
  let o = t.text.length, s = Kf((a) => Oi(e, r, a - 1).bottom <= n, o, 0);
  return o = Kf((a) => Oi(e, r, a).top > n, s, o), { begin: s, end: o };
}
function qj(e, t, r, n) {
  r || (r = _u(e, t));
  let o = Ig(e, t, Oi(e, r, n), "line").top;
  return Bj(e, t, r, o);
}
function JS(e, t, r, n) {
  return e.bottom <= r ? !1 : e.top > r ? !0 : (n ? e.left : e.right) > t;
}
function fde(e, t, r, n, o) {
  o -= mo(t);
  let s = _u(e, t), a = wR(t), l = 0, u = t.text.length, f = !0, c = $o(t, e.doc.direction);
  if (c) {
    let S = (e.options.lineWrapping ? dde : cde)(e, t, r, s, c, n, o);
    f = S.level != 1, l = f ? S.from : S.to - 1, u = f ? S.to : S.from - 1;
  }
  let d = null, h = null, p = Kf((S) => {
    let x = Oi(e, s, S);
    return x.top += a, x.bottom += a, JS(x, n, o, !1) ? (x.top <= o && x.left <= n && (d = S, h = x), !0) : !1;
  }, l, u), m, y, _ = !1;
  if (h) {
    let S = n - h.left < h.right - n, x = S == f;
    p = d + (x ? 0 : 1), y = x ? "after" : "before", m = S ? h.left : h.right;
  } else {
    !f && (p == u || p == l) && p++, y = p == 0 ? "after" : p == t.text.length ? "before" : Oi(e, s, p - (f ? 1 : 0)).bottom + a <= o == f ? "after" : "before";
    let S = Gn(e, Se(r, p, y), "line", t, s);
    m = S.left, _ = o < S.top ? -1 : o >= S.bottom ? 1 : 0;
  }
  return p = uj(t.text, p, 1), XS(r, p, y, _, n - m);
}
function cde(e, t, r, n, o, s, a) {
  let l = Kf((f) => {
    let c = o[f], d = c.level != 1;
    return JS(Gn(e, Se(r, d ? c.to : c.from, d ? "before" : "after"), "line", t, n), s, a, !0);
  }, 0, o.length - 1), u = o[l];
  if (l > 0) {
    let f = u.level != 1, c = Gn(e, Se(r, f ? u.from : u.to, f ? "after" : "before"), "line", t, n);
    JS(c, s, a, !0) && c.top > a && (u = o[l - 1]);
  }
  return u;
}
function dde(e, t, r, n, o, s, a) {
  let { begin: l, end: u } = Bj(e, t, n, a);
  /\s/.test(t.text.charAt(u - 1)) && u--;
  let f = null, c = null;
  for (let d = 0; d < o.length; d++) {
    let h = o[d];
    if (h.from >= u || h.to <= l)
      continue;
    let p = h.level != 1, m = Oi(e, n, p ? Math.min(u, h.to) - 1 : Math.max(l, h.from)).right, y = m < s ? s - m + 1e9 : m - s;
    (!f || c > y) && (f = h, c = y);
  }
  return f || (f = o[o.length - 1]), f.from < l && (f = { from: l, to: f.to, level: f.level }), f.to > u && (f = { from: f.from, to: u, level: f.level }), f;
}
var Ds;
function tu(e) {
  if (e.cachedTextHeight != null)
    return e.cachedTextHeight;
  if (Ds == null) {
    Ds = Ue("pre", null, "CodeMirror-line-like");
    for (let r = 0; r < 49; ++r)
      Ds.appendChild(document.createTextNode("x")), Ds.appendChild(Ue("br"));
    Ds.appendChild(document.createTextNode("x"));
  }
  hn(e.measure, Ds);
  let t = Ds.offsetHeight / 50;
  return t > 3 && (e.cachedTextHeight = t), us(e.measure), t || 1;
}
function Su(e) {
  if (e.cachedCharWidth != null)
    return e.cachedCharWidth;
  let t = Ue("span", "xxxxxxxxxx"), r = Ue("pre", [t], "CodeMirror-line-like");
  hn(e.measure, r);
  let n = t.getBoundingClientRect(), o = (n.right - n.left) / 10;
  return o > 2 && (e.cachedCharWidth = o), o || 10;
}
function SR(e) {
  let t = e.display, r = {}, n = {}, o = t.gutters.clientLeft;
  for (let s = t.gutters.firstChild, a = 0; s; s = s.nextSibling, ++a) {
    let l = e.display.gutterSpecs[a].className;
    r[l] = s.offsetLeft + s.clientLeft + o, n[l] = s.clientWidth;
  }
  return {
    fixedPos: ER(t),
    gutterTotalWidth: t.gutters.offsetWidth,
    gutterLeft: r,
    gutterWidth: n,
    wrapperWidth: t.wrapper.clientWidth
  };
}
function ER(e) {
  return e.scroller.getBoundingClientRect().left - e.sizer.getBoundingClientRect().left;
}
function Wj(e) {
  let t = tu(e.display), r = e.options.lineWrapping, n = r && Math.max(5, e.display.scroller.clientWidth / Su(e.display) - 3);
  return (o) => {
    if (cs(e.doc, o))
      return 0;
    let s = 0;
    if (o.widgets)
      for (let a = 0; a < o.widgets.length; a++)
        o.widgets[a].height && (s += o.widgets[a].height);
    return r ? s + (Math.ceil(o.text.length / n) || 1) * t : s + t;
  };
}
function xR(e) {
  let t = e.doc, r = Wj(e);
  t.iter((n) => {
    let o = r(n);
    o != n.height && Mi(n, o);
  });
}
function Ia(e, t, r, n) {
  let o = e.display;
  if (!r && oR(t).getAttribute("cm-not-content") == "true")
    return null;
  let s, a, l = o.lineSpace.getBoundingClientRect();
  try {
    s = t.clientX - l.left, a = t.clientY - l.top;
  } catch {
    return null;
  }
  let u = _R(e, s, a), f;
  if (n && u.xRel > 0 && (f = je(e.doc, u.line).text).length == u.ch) {
    let c = _n(f, f.length, e.options.tabSize) - f.length;
    u = Se(u.line, Math.max(0, Math.round((s - Ij(e.display).left) / Su(e.display)) - c));
  }
  return u;
}
function Ma(e, t) {
  if (t >= e.display.viewTo || (t -= e.display.viewFrom, t < 0))
    return null;
  let r = e.display.view;
  for (let n = 0; n < r.length; n++)
    if (t -= r[n].size, t < 0)
      return n;
}
function qr(e, t, r, n) {
  t == null && (t = e.doc.first), r == null && (r = e.doc.first + e.doc.size), n || (n = 0);
  let o = e.display;
  if (n && r < o.viewTo && (o.updateLineNumbers == null || o.updateLineNumbers > t) && (o.updateLineNumbers = t), e.curOp.viewChanged = !0, t >= o.viewTo)
    yo && pR(e.doc, t) < o.viewTo && Wo(e);
  else if (r <= o.viewFrom)
    yo && xj(e.doc, r + n) > o.viewFrom ? Wo(e) : (o.viewFrom += n, o.viewTo += n);
  else if (t <= o.viewFrom && r >= o.viewTo)
    Wo(e);
  else if (t <= o.viewFrom) {
    let a = yd(e, r, r + n, 1);
    a ? (o.view = o.view.slice(a.index), o.viewFrom = a.lineN, o.viewTo += n) : Wo(e);
  } else if (r >= o.viewTo) {
    let a = yd(e, t, t, -1);
    a ? (o.view = o.view.slice(0, a.index), o.viewTo = a.lineN) : Wo(e);
  } else {
    let a = yd(e, t, t, -1), l = yd(e, r, r + n, 1);
    a && l ? (o.view = o.view.slice(0, a.index).concat(Gd(e, a.lineN, l.lineN)).concat(o.view.slice(l.index)), o.viewTo += n) : Wo(e);
  }
  let s = o.externalMeasured;
  s && (r < s.lineN ? s.lineN += n : t < s.lineN + s.size && (o.externalMeasured = null));
}
function Es(e, t, r) {
  e.curOp.viewChanged = !0;
  let n = e.display, o = e.display.externalMeasured;
  if (o && t >= o.lineN && t < o.lineN + o.size && (n.externalMeasured = null), t < n.viewFrom || t >= n.viewTo)
    return;
  let s = n.view[Ma(e, t)];
  if (s.node == null)
    return;
  let a = s.changes || (s.changes = []);
  mr(a, r) == -1 && a.push(r);
}
function Wo(e) {
  e.display.viewFrom = e.display.viewTo = e.doc.first, e.display.view = [], e.display.viewOffset = 0;
}
function yd(e, t, r, n) {
  let o = Ma(e, t), s, a = e.display.view;
  if (!yo || r == e.doc.first + e.doc.size)
    return { index: o, lineN: r };
  let l = e.display.viewFrom;
  for (let u = 0; u < o; u++)
    l += a[u].size;
  if (l != t) {
    if (n > 0) {
      if (o == a.length - 1)
        return null;
      s = l + a[o].size - t, o++;
    } else
      s = l - t;
    t += s, r += s;
  }
  for (; pR(e.doc, r) != r; ) {
    if (o == (n < 0 ? 0 : a.length - 1))
      return null;
    r += n * a[o - (n < 0 ? 1 : 0)].size, o += n;
  }
  return { index: o, lineN: r };
}
function hde(e, t, r) {
  let n = e.display;
  n.view.length == 0 || t >= n.viewTo || r <= n.viewFrom ? (n.view = Gd(e, t, r), n.viewFrom = t) : (n.viewFrom > t ? n.view = Gd(e, t, n.viewFrom).concat(n.view) : n.viewFrom < t && (n.view = n.view.slice(Ma(e, t))), n.viewFrom = t, n.viewTo < r ? n.view = n.view.concat(Gd(e, n.viewTo, r)) : n.viewTo > r && (n.view = n.view.slice(0, Ma(e, r)))), n.viewTo = r;
}
function JI(e) {
  let t = e.display.view, r = 0;
  for (let n = 0; n < t.length; n++) {
    let o = t[n];
    !o.hidden && (!o.node || o.changes) && ++r;
  }
  return r;
}
function $f(e) {
  e.display.input.showSelection(e.display.input.prepareSelection());
}
function Uj(e, t = !0) {
  let r = e.doc, n = {}, o = n.cursors = document.createDocumentFragment(), s = n.selection = document.createDocumentFragment();
  for (let a = 0; a < r.sel.ranges.length; a++) {
    if (!t && a == r.sel.primIndex)
      continue;
    let l = r.sel.ranges[a];
    if (l.from().line >= e.display.viewTo || l.to().line < e.display.viewFrom)
      continue;
    let u = l.empty();
    (u || e.options.showCursorWhenSelecting) && Hj(e, l.head, o), u || pde(e, l, s);
  }
  return n;
}
function Hj(e, t, r) {
  let n = Gn(e, t, "div", null, null, !e.options.singleCursorHeightPerLine), o = r.appendChild(Ue("div", "", "CodeMirror-cursor"));
  if (o.style.left = n.left + "px", o.style.top = n.top + "px", o.style.height = Math.max(0, n.bottom - n.top) * e.options.cursorHeight + "px", n.other) {
    let s = r.appendChild(Ue("div", "", "CodeMirror-cursor CodeMirror-secondarycursor"));
    s.style.display = "", s.style.left = n.other.left + "px", s.style.top = n.other.top + "px", s.style.height = (n.other.bottom - n.other.top) * 0.85 + "px";
  }
}
function md(e, t) {
  return e.top - t.top || e.left - t.left;
}
function pde(e, t, r) {
  let n = e.display, o = e.doc, s = document.createDocumentFragment(), a = Ij(e.display), l = a.left, u = Math.max(n.sizerWidth, tl(e) - n.sizer.offsetLeft) - a.right, f = o.direction == "ltr";
  function c(m, y, _, S) {
    y < 0 && (y = 0), y = Math.round(y), S = Math.round(S), s.appendChild(Ue("div", null, "CodeMirror-selected", `position: absolute; left: ${m}px;
                             top: ${y}px; width: ${_ ?? u - m}px;
                             height: ${S - y}px`));
  }
  function d(m, y, _) {
    let S = je(o, m), x = S.text.length, E, C;
    function I(G, $) {
      return YS(e, Se(m, G), "div", S, $);
    }
    function j(G, $, V) {
      let M = qj(e, S, null, G), W = $ == "ltr" == (V == "after") ? "left" : "right", k = V == "after" ? M.begin : M.end - (/\s/.test(S.text.charAt(M.end - 1)) ? 2 : 1);
      return I(k, W)[W];
    }
    let J = $o(S, o.direction);
    return bce(J, y || 0, _ ?? x, (G, $, V, M) => {
      let W = V == "ltr", k = I(G, W ? "left" : "right"), U = I($ - 1, W ? "right" : "left"), Z = y == null && G == 0, Y = _ == null && $ == x, te = M == 0, se = !J || M == J.length - 1;
      if (U.top - k.top <= 3) {
        let fe = (f ? Z : Y) && te, he = (f ? Y : Z) && se, ae = fe ? l : (W ? k : U).left, be = he ? u : (W ? U : k).right;
        c(ae, k.top, be - ae, k.bottom);
      } else {
        let fe, he, ae, be;
        W ? (fe = f && Z && te ? l : k.left, he = f ? u : j(G, V, "before"), ae = f ? l : j($, V, "after"), be = f && Y && se ? u : U.right) : (fe = f ? j(G, V, "before") : l, he = !f && Z && te ? u : k.right, ae = !f && Y && se ? l : U.left, be = f ? j($, V, "after") : u), c(fe, k.top, he - fe, k.bottom), k.bottom < U.top && c(l, k.bottom, null, U.top), c(ae, U.top, be - ae, U.bottom);
      }
      (!E || md(k, E) < 0) && (E = k), md(U, E) < 0 && (E = U), (!C || md(k, C) < 0) && (C = k), md(U, C) < 0 && (C = U);
    }), { start: E, end: C };
  }
  let h = t.from(), p = t.to();
  if (h.line == p.line)
    d(h.line, h.ch, p.ch);
  else {
    let m = je(o, h.line), y = je(o, p.line), _ = Ni(m) == Ni(y), S = d(h.line, h.ch, _ ? m.text.length + 1 : null).end, x = d(p.line, _ ? 0 : null, p.ch).start;
    _ && (S.top < x.top - 2 ? (c(S.right, S.top, null, S.bottom), c(l, x.top, x.left, x.bottom)) : c(S.right, S.top, x.left - S.right, S.bottom)), S.bottom < x.top && c(l, S.bottom, null, x.top);
  }
  r.appendChild(s);
}
function RR(e) {
  if (!e.state.focused)
    return;
  let t = e.display;
  clearInterval(t.blinker);
  let r = !0;
  t.cursorDiv.style.visibility = "", e.options.cursorBlinkRate > 0 ? t.blinker = setInterval(() => {
    e.hasFocus() || Eu(e), t.cursorDiv.style.visibility = (r = !r) ? "" : "hidden";
  }, e.options.cursorBlinkRate) : e.options.cursorBlinkRate < 0 && (t.cursorDiv.style.visibility = "hidden");
}
function zj(e) {
  e.hasFocus() || (e.display.input.focus(), e.state.focused || TR(e));
}
function AR(e) {
  e.state.delayingBlurEvent = !0, setTimeout(() => {
    e.state.delayingBlurEvent && (e.state.delayingBlurEvent = !1, e.state.focused && Eu(e));
  }, 100);
}
function TR(e, t) {
  e.state.delayingBlurEvent && !e.state.draggingText && (e.state.delayingBlurEvent = !1), e.options.readOnly != "nocursor" && (e.state.focused || (Ht(e, "focus", e, t), e.state.focused = !0, el(e.display.wrapper, "CodeMirror-focused"), !e.curOp && e.display.selForContextMenu != e.doc.sel && (e.display.input.reset(), Tr && setTimeout(() => e.display.input.reset(!0), 20)), e.display.input.receivedFocus()), RR(e));
}
function Eu(e, t) {
  e.state.delayingBlurEvent || (e.state.focused && (Ht(e, "blur", e, t), e.state.focused = !1, Za(e.display.wrapper, "CodeMirror-focused")), clearInterval(e.display.blinker), setTimeout(() => {
    e.state.focused || (e.display.shift = !1);
  }, 150));
}
function Mg(e) {
  let t = e.display, r = t.lineDiv.offsetTop;
  for (let n = 0; n < t.view.length; n++) {
    let o = t.view[n], s = e.options.lineWrapping, a, l = 0;
    if (o.hidden)
      continue;
    if (ct && kt < 8) {
      let f = o.node.offsetTop + o.node.offsetHeight;
      a = f - r, r = f;
    } else {
      let f = o.node.getBoundingClientRect();
      a = f.bottom - f.top, !s && o.text.firstChild && (l = o.text.firstChild.getBoundingClientRect().right - f.left - 1);
    }
    let u = o.line.height - a;
    if ((u > 5e-3 || u < -5e-3) && (Mi(o.line, a), QI(o.line), o.rest))
      for (let f = 0; f < o.rest.length; f++)
        QI(o.rest[f]);
    if (l > e.display.sizerWidth) {
      let f = Math.ceil(l / Su(e.display));
      f > e.display.maxLineLength && (e.display.maxLineLength = f, e.display.maxLine = o.line, e.display.maxLineChanged = !0);
    }
  }
}
function QI(e) {
  if (e.widgets)
    for (let t = 0; t < e.widgets.length; ++t) {
      let r = e.widgets[t], n = r.node.parentNode;
      n && (r.height = n.offsetHeight);
    }
}
function Dh(e, t, r) {
  let n = r && r.top != null ? Math.max(0, r.top) : e.scroller.scrollTop;
  n = Math.floor(n - kg(e));
  let o = r && r.bottom != null ? r.bottom : n + e.wrapper.clientHeight, s = Zs(t, n), a = Zs(t, o);
  if (r && r.ensure) {
    let l = r.ensure.from.line, u = r.ensure.to.line;
    l < s ? (s = l, a = Zs(t, mo(je(t, l)) + e.wrapper.clientHeight)) : Math.min(u, t.lastLine()) >= a && (s = Zs(t, mo(je(t, u)) - e.wrapper.clientHeight), a = u);
  }
  return { from: s, to: Math.max(a, s + 1) };
}
function gde(e, t) {
  if (Qt(e, "scrollCursorIntoView"))
    return;
  let r = e.display, n = r.sizer.getBoundingClientRect(), o = null;
  if (t.top + n.top < 0 ? o = !0 : t.bottom + n.top > (window.innerHeight || document.documentElement.clientHeight) && (o = !1), o != null && !fce) {
    let s = Ue("div", "", null, `position: absolute;
                         top: ${t.top - r.viewOffset - kg(e.display)}px;
                         height: ${t.bottom - t.top + Li(e) + r.barHeight}px;
                         left: ${t.left}px; width: ${Math.max(2, t.right - t.left)}px;`);
    e.display.lineSpace.appendChild(s), s.scrollIntoView(o), e.display.lineSpace.removeChild(s);
  }
}
function bde(e, t, r, n) {
  n == null && (n = 0);
  let o;
  !e.options.lineWrapping && t == r && (t = t.ch ? Se(t.line, t.sticky == "before" ? t.ch - 1 : t.ch, "after") : t, r = t.sticky == "before" ? Se(t.line, t.ch + 1, "before") : t);
  for (let s = 0; s < 5; s++) {
    let a = !1, l = Gn(e, t), u = !r || r == t ? l : Gn(e, r);
    o = {
      left: Math.min(l.left, u.left),
      top: Math.min(l.top, u.top) - n,
      right: Math.max(l.left, u.left),
      bottom: Math.max(l.bottom, u.bottom) + n
    };
    let f = $R(e, o), c = e.doc.scrollTop, d = e.doc.scrollLeft;
    if (f.scrollTop != null && (Cc(e, f.scrollTop), Math.abs(e.doc.scrollTop - c) > 1 && (a = !0)), f.scrollLeft != null && (rl(e, f.scrollLeft), Math.abs(e.doc.scrollLeft - d) > 1 && (a = !0)), !a)
      break;
  }
  return o;
}
function yde(e, t) {
  let r = $R(e, t);
  r.scrollTop != null && Cc(e, r.scrollTop), r.scrollLeft != null && rl(e, r.scrollLeft);
}
function $R(e, t) {
  let r = e.display, n = tu(e.display);
  t.top < 0 && (t.top = 0);
  let o = e.curOp && e.curOp.scrollTop != null ? e.curOp.scrollTop : r.scroller.scrollTop, s = mR(e), a = {};
  t.bottom - t.top > s && (t.bottom = t.top + s);
  let l = e.doc.height + yR(r), u = t.top < n, f = t.bottom > l - n;
  if (t.top < o)
    a.scrollTop = u ? 0 : t.top;
  else if (t.bottom > o + s) {
    let m = Math.min(t.top, (f ? l : t.bottom) - s);
    m != o && (a.scrollTop = m);
  }
  let c = e.options.fixedGutter ? 0 : r.gutters.offsetWidth, d = e.curOp && e.curOp.scrollLeft != null ? e.curOp.scrollLeft : r.scroller.scrollLeft - c, h = tl(e) - r.gutters.offsetWidth, p = t.right - t.left > h;
  return p && (t.right = t.left + h), t.left < 10 ? a.scrollLeft = 0 : t.left < d ? a.scrollLeft = Math.max(0, t.left + c - (p ? 0 : 10)) : t.right > h + d - 3 && (a.scrollLeft = t.right + (p ? 0 : 10) - h), a;
}
function CR(e, t) {
  t != null && (Ng(e), e.curOp.scrollTop = (e.curOp.scrollTop == null ? e.doc.scrollTop : e.curOp.scrollTop) + t);
}
function xu(e) {
  Ng(e);
  let t = e.getCursor();
  e.curOp.scrollToPos = { from: t, to: t, margin: e.options.cursorScrollMargin };
}
function Cf(e, t, r) {
  (t != null || r != null) && Ng(e), t != null && (e.curOp.scrollLeft = t), r != null && (e.curOp.scrollTop = r);
}
function mde(e, t) {
  Ng(e), e.curOp.scrollToPos = t;
}
function Ng(e) {
  let t = e.curOp.scrollToPos;
  if (t) {
    e.curOp.scrollToPos = null;
    let r = XI(e, t.from), n = XI(e, t.to);
    Gj(e, r, n, t.margin);
  }
}
function Gj(e, t, r, n) {
  let o = $R(e, {
    left: Math.min(t.left, r.left),
    top: Math.min(t.top, r.top) - n,
    right: Math.max(t.right, r.right),
    bottom: Math.max(t.bottom, r.bottom) + n
  });
  Cf(e, o.scrollLeft, o.scrollTop);
}
function Cc(e, t) {
  Math.abs(e.doc.scrollTop - t) < 2 || (bo || QS(e, { top: t }), Vj(e, t, !0), bo && QS(e), kc(e, 100));
}
function Vj(e, t, r) {
  t = Math.max(0, Math.min(e.display.scroller.scrollHeight - e.display.scroller.clientHeight, t)), !(e.display.scroller.scrollTop == t && !r) && (e.doc.scrollTop = t, e.display.scrollbars.setScrollTop(t), e.display.scroller.scrollTop != t && (e.display.scroller.scrollTop = t));
}
function rl(e, t, r, n) {
  t = Math.max(0, Math.min(t, e.display.scroller.scrollWidth - e.display.scroller.clientWidth)), !((r ? t == e.doc.scrollLeft : Math.abs(e.doc.scrollLeft - t) < 2) && !n) && (e.doc.scrollLeft = t, Qj(e), e.display.scroller.scrollLeft != t && (e.display.scroller.scrollLeft = t), e.display.scrollbars.setScrollLeft(t));
}
function nc(e) {
  let t = e.display, r = t.gutters.offsetWidth, n = Math.round(e.doc.height + yR(e.display));
  return {
    clientHeight: t.scroller.clientHeight,
    viewHeight: t.wrapper.clientHeight,
    scrollWidth: t.scroller.scrollWidth,
    clientWidth: t.scroller.clientWidth,
    viewWidth: t.wrapper.clientWidth,
    barLeft: e.options.fixedGutter ? r : 0,
    docHeight: n,
    scrollHeight: n + Li(e) + t.barHeight,
    nativeBarWidth: t.nativeBarWidth,
    gutterWidth: r
  };
}
var vde = class {
  constructor(e, t, r) {
    this.cm = r;
    let n = this.vert = Ue("div", [Ue("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar"), o = this.horiz = Ue("div", [Ue("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    n.tabIndex = o.tabIndex = -1, e(n), e(o), He(n, "scroll", () => {
      n.clientHeight && t(n.scrollTop, "vertical");
    }), He(o, "scroll", () => {
      o.clientWidth && t(o.scrollLeft, "horizontal");
    }), this.checkedZeroWidth = !1, ct && kt < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px");
  }
  update(e) {
    let t = e.scrollWidth > e.clientWidth + 1, r = e.scrollHeight > e.clientHeight + 1, n = e.nativeBarWidth;
    if (r) {
      this.vert.style.display = "block", this.vert.style.bottom = t ? n + "px" : "0";
      let o = e.viewHeight - (t ? n : 0);
      this.vert.firstChild.style.height = Math.max(0, e.scrollHeight - e.clientHeight + o) + "px";
    } else
      this.vert.style.display = "", this.vert.firstChild.style.height = "0";
    if (t) {
      this.horiz.style.display = "block", this.horiz.style.right = r ? n + "px" : "0", this.horiz.style.left = e.barLeft + "px";
      let o = e.viewWidth - e.barLeft - (r ? n : 0);
      this.horiz.firstChild.style.width = Math.max(0, e.scrollWidth - e.clientWidth + o) + "px";
    } else
      this.horiz.style.display = "", this.horiz.firstChild.style.width = "0";
    return !this.checkedZeroWidth && e.clientHeight > 0 && (n == 0 && this.zeroWidthHack(), this.checkedZeroWidth = !0), { right: r ? n : 0, bottom: t ? n : 0 };
  }
  setScrollLeft(e) {
    this.horiz.scrollLeft != e && (this.horiz.scrollLeft = e), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
  }
  setScrollTop(e) {
    this.vert.scrollTop != e && (this.vert.scrollTop = e), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
  }
  zeroWidthHack() {
    let e = Rn && !uce ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = e, this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none", this.disableHoriz = new eu(), this.disableVert = new eu();
  }
  enableZeroWidthBar(e, t, r) {
    e.style.pointerEvents = "auto";
    function n() {
      let o = e.getBoundingClientRect();
      (r == "vert" ? document.elementFromPoint(o.right - 1, (o.top + o.bottom) / 2) : document.elementFromPoint((o.right + o.left) / 2, o.bottom - 1)) != e ? e.style.pointerEvents = "none" : t.set(1e3, n);
    }
    t.set(1e3, n);
  }
  clear() {
    let e = this.horiz.parentNode;
    e.removeChild(this.horiz), e.removeChild(this.vert);
  }
}, wde = class {
  update() {
    return { bottom: 0, right: 0 };
  }
  setScrollLeft() {
  }
  setScrollTop() {
  }
  clear() {
  }
};
function ru(e, t) {
  t || (t = nc(e));
  let r = e.display.barWidth, n = e.display.barHeight;
  ZI(e, t);
  for (let o = 0; o < 4 && r != e.display.barWidth || n != e.display.barHeight; o++)
    r != e.display.barWidth && e.options.lineWrapping && Mg(e), ZI(e, nc(e)), r = e.display.barWidth, n = e.display.barHeight;
}
function ZI(e, t) {
  let r = e.display, n = r.scrollbars.update(t);
  r.sizer.style.paddingRight = (r.barWidth = n.right) + "px", r.sizer.style.paddingBottom = (r.barHeight = n.bottom) + "px", r.heightForcer.style.borderBottom = n.bottom + "px solid transparent", n.right && n.bottom ? (r.scrollbarFiller.style.display = "block", r.scrollbarFiller.style.height = n.bottom + "px", r.scrollbarFiller.style.width = n.right + "px") : r.scrollbarFiller.style.display = "", n.bottom && e.options.coverGutterNextToScrollbar && e.options.fixedGutter ? (r.gutterFiller.style.display = "block", r.gutterFiller.style.height = n.bottom + "px", r.gutterFiller.style.width = t.gutterWidth + "px") : r.gutterFiller.style.display = "";
}
var Kj = { native: vde, null: wde };
function Yj(e) {
  e.display.scrollbars && (e.display.scrollbars.clear(), e.display.scrollbars.addClass && Za(e.display.wrapper, e.display.scrollbars.addClass)), e.display.scrollbars = new Kj[e.options.scrollbarStyle]((t) => {
    e.display.wrapper.insertBefore(t, e.display.scrollbarFiller), He(t, "mousedown", () => {
      e.state.focused && setTimeout(() => e.display.input.focus(), 0);
    }), t.setAttribute("cm-not-content", "true");
  }, (t, r) => {
    r == "horizontal" ? rl(e, t) : Cc(e, t);
  }, e), e.display.scrollbars.addClass && el(e.display.wrapper, e.display.scrollbars.addClass);
}
var _de = 0;
function nl(e) {
  e.curOp = {
    cm: e,
    viewChanged: !1,
    startHeight: e.doc.height,
    forceUpdate: !1,
    updateInput: 0,
    typing: !1,
    changeObjs: null,
    cursorActivityHandlers: null,
    cursorActivityCalled: 0,
    selectionChanged: !1,
    updateMaxLine: !1,
    scrollLeft: null,
    scrollTop: null,
    scrollToPos: null,
    focus: !1,
    id: ++_de
  }, Xce(e.curOp);
}
function il(e) {
  let t = e.curOp;
  t && Qce(t, (r) => {
    for (let n = 0; n < r.ops.length; n++)
      r.ops[n].cm.curOp = null;
    Sde(r);
  });
}
function Sde(e) {
  let t = e.ops;
  for (let r = 0; r < t.length; r++)
    Ede(t[r]);
  for (let r = 0; r < t.length; r++)
    xde(t[r]);
  for (let r = 0; r < t.length; r++)
    Rde(t[r]);
  for (let r = 0; r < t.length; r++)
    Ade(t[r]);
  for (let r = 0; r < t.length; r++)
    Tde(t[r]);
}
function Ede(e) {
  let t = e.cm, r = t.display;
  Cde(t), e.updateMaxLine && gR(t), e.mustUpdate = e.viewChanged || e.forceUpdate || e.scrollTop != null || e.scrollToPos && (e.scrollToPos.from.line < r.viewFrom || e.scrollToPos.to.line >= r.viewTo) || r.maxLineChanged && t.options.lineWrapping, e.update = e.mustUpdate && new Xj(t, e.mustUpdate && { top: e.scrollTop, ensure: e.scrollToPos }, e.forceUpdate);
}
function xde(e) {
  e.updatedDisplay = e.mustUpdate && kR(e.cm, e.update);
}
function Rde(e) {
  let t = e.cm, r = t.display;
  e.updatedDisplay && Mg(t), e.barMeasure = nc(t), r.maxLineChanged && !t.options.lineWrapping && (e.adjustWidthTo = Nj(t, r.maxLine, r.maxLine.text.length).left + 3, t.display.sizerWidth = e.adjustWidthTo, e.barMeasure.scrollWidth = Math.max(r.scroller.clientWidth, r.sizer.offsetLeft + e.adjustWidthTo + Li(t) + t.display.barWidth), e.maxScrollLeft = Math.max(0, r.sizer.offsetLeft + e.adjustWidthTo - tl(t))), (e.updatedDisplay || e.selectionChanged) && (e.preparedSelection = r.input.prepareSelection());
}
function Ade(e) {
  let t = e.cm;
  e.adjustWidthTo != null && (t.display.sizer.style.minWidth = e.adjustWidthTo + "px", e.maxScrollLeft < t.doc.scrollLeft && rl(t, Math.min(t.display.scroller.scrollLeft, e.maxScrollLeft), !0), t.display.maxLineChanged = !1);
  let r = e.focus && e.focus == En();
  e.preparedSelection && t.display.input.showSelection(e.preparedSelection, r), (e.updatedDisplay || e.startHeight != t.doc.height) && ru(t, e.barMeasure), e.updatedDisplay && MR(t, e.barMeasure), e.selectionChanged && RR(t), t.state.focused && e.updateInput && t.display.input.reset(e.typing), r && zj(e.cm);
}
function Tde(e) {
  let t = e.cm, r = t.display, n = t.doc;
  if (e.updatedDisplay && Jj(t, e.update), r.wheelStartX != null && (e.scrollTop != null || e.scrollLeft != null || e.scrollToPos) && (r.wheelStartX = r.wheelStartY = null), e.scrollTop != null && Vj(t, e.scrollTop, e.forceScroll), e.scrollLeft != null && rl(t, e.scrollLeft, !0, !0), e.scrollToPos) {
    let a = bde(t, Ke(n, e.scrollToPos.from), Ke(n, e.scrollToPos.to), e.scrollToPos.margin);
    gde(t, a);
  }
  let o = e.maybeHiddenMarkers, s = e.maybeUnhiddenMarkers;
  if (o)
    for (let a = 0; a < o.length; ++a)
      o[a].lines.length || Ht(o[a], "hide");
  if (s)
    for (let a = 0; a < s.length; ++a)
      s[a].lines.length && Ht(s[a], "unhide");
  r.wrapper.offsetHeight && (n.scrollTop = t.display.scroller.scrollTop), e.changeObjs && Ht(t, "changes", t, e.changeObjs), e.update && e.update.finish();
}
function en(e, t) {
  if (e.curOp)
    return t();
  nl(e);
  try {
    return t();
  } finally {
    il(e);
  }
}
function tr(e, t) {
  return function() {
    if (e.curOp)
      return t.apply(e, arguments);
    nl(e);
    try {
      return t.apply(e, arguments);
    } finally {
      il(e);
    }
  };
}
function Rr(e) {
  return function() {
    if (this.curOp)
      return e.apply(this, arguments);
    nl(this);
    try {
      return e.apply(this, arguments);
    } finally {
      il(this);
    }
  };
}
function Jt(e) {
  return function() {
    let t = this.cm;
    if (!t || t.curOp)
      return e.apply(this, arguments);
    nl(t);
    try {
      return e.apply(this, arguments);
    } finally {
      il(t);
    }
  };
}
function kc(e, t) {
  e.doc.highlightFrontier < e.display.viewTo && e.state.highlight.set(t, rR($de, e));
}
function $de(e) {
  let t = e.doc;
  if (t.highlightFrontier >= e.display.viewTo)
    return;
  let r = +/* @__PURE__ */ new Date() + e.options.workTime, n = $c(e, t.highlightFrontier), o = [];
  t.iter(n.line, Math.min(t.first + t.size, e.display.viewTo + 500), (s) => {
    if (n.line >= e.display.viewFrom) {
      let a = s.styles, l = s.text.length > e.options.maxHighlightLength ? ba(t.mode, n.state) : null, u = bj(e, s, n, !0);
      l && (n.state = l), s.styles = u.styles;
      let f = s.styleClasses, c = u.classes;
      c ? s.styleClasses = c : f && (s.styleClasses = null);
      let d = !a || a.length != s.styles.length || f != c && (!f || !c || f.bgClass != c.bgClass || f.textClass != c.textClass);
      for (let h = 0; !d && h < a.length; ++h)
        d = a[h] != s.styles[h];
      d && o.push(n.line), s.stateAfter = n.save(), n.nextLine();
    } else
      s.text.length <= e.options.maxHighlightLength && cR(e, s.text, n), s.stateAfter = n.line % 5 == 0 ? n.save() : null, n.nextLine();
    if (+/* @__PURE__ */ new Date() > r)
      return kc(e, e.options.workDelay), !0;
  }), t.highlightFrontier = n.line, t.modeFrontier = Math.max(t.modeFrontier, n.line), o.length && en(e, () => {
    for (let s = 0; s < o.length; s++)
      Es(e, o[s], "text");
  });
}
var Xj = class {
  constructor(e, t, r) {
    let n = e.display;
    this.viewport = t, this.visible = Dh(n, e.doc, t), this.editorIsHidden = !n.wrapper.offsetWidth, this.wrapperHeight = n.wrapper.clientHeight, this.wrapperWidth = n.wrapper.clientWidth, this.oldDisplayWidth = tl(e), this.force = r, this.dims = SR(e), this.events = [];
  }
  signal(e, t) {
    An(e, t) && this.events.push(arguments);
  }
  finish() {
    for (let e = 0; e < this.events.length; e++)
      Ht.apply(null, this.events[e]);
  }
};
function Cde(e) {
  let t = e.display;
  !t.scrollbarsClipped && t.scroller.offsetWidth && (t.nativeBarWidth = t.scroller.offsetWidth - t.scroller.clientWidth, t.heightForcer.style.height = Li(e) + "px", t.sizer.style.marginBottom = -t.nativeBarWidth + "px", t.sizer.style.borderRightWidth = Li(e) + "px", t.scrollbarsClipped = !0);
}
function kde(e) {
  if (e.hasFocus())
    return null;
  let t = En();
  if (!t || !fs(e.display.lineDiv, t))
    return null;
  let r = { activeElt: t };
  if (window.getSelection) {
    let n = window.getSelection();
    n.anchorNode && n.extend && fs(e.display.lineDiv, n.anchorNode) && (r.anchorNode = n.anchorNode, r.anchorOffset = n.anchorOffset, r.focusNode = n.focusNode, r.focusOffset = n.focusOffset);
  }
  return r;
}
function Ide(e) {
  if (!(!e || !e.activeElt || e.activeElt == En()) && (e.activeElt.focus(), !/^(INPUT|TEXTAREA)$/.test(e.activeElt.nodeName) && e.anchorNode && fs(document.body, e.anchorNode) && fs(document.body, e.focusNode))) {
    let t = window.getSelection(), r = document.createRange();
    r.setEnd(e.anchorNode, e.anchorOffset), r.collapse(!1), t.removeAllRanges(), t.addRange(r), t.extend(e.focusNode, e.focusOffset);
  }
}
function kR(e, t) {
  let r = e.display, n = e.doc;
  if (t.editorIsHidden)
    return Wo(e), !1;
  if (!t.force && t.visible.from >= r.viewFrom && t.visible.to <= r.viewTo && (r.updateLineNumbers == null || r.updateLineNumbers >= r.viewTo) && r.renderedView == r.view && JI(e) == 0)
    return !1;
  Zj(e) && (Wo(e), t.dims = SR(e));
  let o = n.first + n.size, s = Math.max(t.visible.from - e.options.viewportMargin, n.first), a = Math.min(o, t.visible.to + e.options.viewportMargin);
  r.viewFrom < s && s - r.viewFrom < 20 && (s = Math.max(n.first, r.viewFrom)), r.viewTo > a && r.viewTo - a < 20 && (a = Math.min(o, r.viewTo)), yo && (s = pR(e.doc, s), a = xj(e.doc, a));
  let l = s != r.viewFrom || a != r.viewTo || r.lastWrapHeight != t.wrapperHeight || r.lastWrapWidth != t.wrapperWidth;
  hde(e, s, a), r.viewOffset = mo(je(e.doc, r.viewFrom)), e.display.mover.style.top = r.viewOffset + "px";
  let u = JI(e);
  if (!l && u == 0 && !t.force && r.renderedView == r.view && (r.updateLineNumbers == null || r.updateLineNumbers >= r.viewTo))
    return !1;
  let f = kde(e);
  return u > 4 && (r.lineDiv.style.display = "none"), Mde(e, r.updateLineNumbers, t.dims), u > 4 && (r.lineDiv.style.display = ""), r.renderedView = r.view, Ide(f), us(r.cursorDiv), us(r.selectionDiv), r.gutters.style.height = r.sizer.style.minHeight = 0, l && (r.lastWrapHeight = t.wrapperHeight, r.lastWrapWidth = t.wrapperWidth, kc(e, 400)), r.updateLineNumbers = null, !0;
}
function Jj(e, t) {
  let r = t.viewport;
  for (let n = !0; ; n = !1) {
    if (!n || !e.options.lineWrapping || t.oldDisplayWidth == tl(e)) {
      if (r && r.top != null && (r = { top: Math.min(e.doc.height + yR(e.display) - mR(e), r.top) }), t.visible = Dh(e.display, e.doc, r), t.visible.from >= e.display.viewFrom && t.visible.to <= e.display.viewTo)
        break;
    } else
      n && (t.visible = Dh(e.display, e.doc, r));
    if (!kR(e, t))
      break;
    Mg(e);
    let o = nc(e);
    $f(e), ru(e, o), MR(e, o), t.force = !1;
  }
  t.signal(e, "update", e), (e.display.viewFrom != e.display.reportedViewFrom || e.display.viewTo != e.display.reportedViewTo) && (t.signal(e, "viewportChange", e, e.display.viewFrom, e.display.viewTo), e.display.reportedViewFrom = e.display.viewFrom, e.display.reportedViewTo = e.display.viewTo);
}
function QS(e, t) {
  let r = new Xj(e, t);
  if (kR(e, r)) {
    Mg(e), Jj(e, r);
    let n = nc(e);
    $f(e), ru(e, n), MR(e, n), r.finish();
  }
}
function Mde(e, t, r) {
  let n = e.display, o = e.options.lineNumbers, s = n.lineDiv, a = s.firstChild;
  function l(c) {
    let d = c.nextSibling;
    return Tr && Rn && e.display.currentWheelTarget == c ? c.style.display = "none" : c.parentNode.removeChild(c), d;
  }
  let u = n.view, f = n.viewFrom;
  for (let c = 0; c < u.length; c++) {
    let d = u[c];
    if (!d.hidden)
      if (!d.node || d.node.parentNode != s) {
        let h = nde(e, d, f, r);
        s.insertBefore(h, a);
      } else {
        for (; a != d.node; )
          a = l(a);
        let h = o && t != null && t <= f && d.lineNumber;
        d.changes && (mr(d.changes, "gutter") > -1 && (h = !1), Tj(e, d, f, r)), h && (us(d.lineNumber), d.lineNumber.appendChild(document.createTextNode(fR(e.options, f)))), a = d.node.nextSibling;
      }
    f += d.size;
  }
  for (; a; )
    a = l(a);
}
function IR(e) {
  let t = e.gutters.offsetWidth;
  e.sizer.style.marginLeft = t + "px", ir(e, "gutterChanged", e);
}
function MR(e, t) {
  e.display.sizer.style.minHeight = t.docHeight + "px", e.display.heightForcer.style.top = t.docHeight + "px", e.display.gutters.style.height = t.docHeight + e.display.barHeight + Li(e) + "px";
}
function Qj(e) {
  let t = e.display, r = t.view;
  if (!t.alignWidgets && (!t.gutters.firstChild || !e.options.fixedGutter))
    return;
  let n = ER(t) - t.scroller.scrollLeft + e.doc.scrollLeft, o = t.gutters.offsetWidth, s = n + "px";
  for (let a = 0; a < r.length; a++)
    if (!r[a].hidden) {
      e.options.fixedGutter && (r[a].gutter && (r[a].gutter.style.left = s), r[a].gutterBackground && (r[a].gutterBackground.style.left = s));
      let l = r[a].alignable;
      if (l)
        for (let u = 0; u < l.length; u++)
          l[u].style.left = s;
    }
  e.options.fixedGutter && (t.gutters.style.left = n + o + "px");
}
function Zj(e) {
  if (!e.options.lineNumbers)
    return !1;
  let t = e.doc, r = fR(e.options, t.first + t.size - 1), n = e.display;
  if (r.length != n.lineNumChars) {
    let o = n.measure.appendChild(Ue("div", [Ue("div", r)], "CodeMirror-linenumber CodeMirror-gutter-elt")), s = o.firstChild.offsetWidth, a = o.offsetWidth - s;
    return n.lineGutter.style.width = "", n.lineNumInnerWidth = Math.max(s, n.lineGutter.offsetWidth - a) + 1, n.lineNumWidth = n.lineNumInnerWidth + a, n.lineNumChars = n.lineNumInnerWidth ? r.length : -1, n.lineGutter.style.width = n.lineNumWidth + "px", IR(e.display), !0;
  }
  return !1;
}
function ZS(e, t) {
  let r = [], n = !1;
  for (let o = 0; o < e.length; o++) {
    let s = e[o], a = null;
    if (typeof s != "string" && (a = s.style, s = s.className), s == "CodeMirror-linenumbers")
      if (t)
        n = !0;
      else
        continue;
    r.push({ className: s, style: a });
  }
  return t && !n && r.push({ className: "CodeMirror-linenumbers", style: null }), r;
}
function eB(e) {
  let t = e.gutters, r = e.gutterSpecs;
  us(t), e.lineGutter = null;
  for (let n = 0; n < r.length; ++n) {
    let { className: o, style: s } = r[n], a = t.appendChild(Ue("div", null, "CodeMirror-gutter " + o));
    s && (a.style.cssText = s), o == "CodeMirror-linenumbers" && (e.lineGutter = a, a.style.width = (e.lineNumWidth || 1) + "px");
  }
  t.style.display = r.length ? "" : "none", IR(e);
}
function Pu(e) {
  eB(e.display), qr(e), Qj(e);
}
function Nde(e, t, r, n) {
  let o = this;
  this.input = r, o.scrollbarFiller = Ue("div", null, "CodeMirror-scrollbar-filler"), o.scrollbarFiller.setAttribute("cm-not-content", "true"), o.gutterFiller = Ue("div", null, "CodeMirror-gutter-filler"), o.gutterFiller.setAttribute("cm-not-content", "true"), o.lineDiv = Pl("div", null, "CodeMirror-code"), o.selectionDiv = Ue("div", null, null, "position: relative; z-index: 1"), o.cursorDiv = Ue("div", null, "CodeMirror-cursors"), o.measure = Ue("div", null, "CodeMirror-measure"), o.lineMeasure = Ue("div", null, "CodeMirror-measure"), o.lineSpace = Pl("div", [o.measure, o.lineMeasure, o.selectionDiv, o.cursorDiv, o.lineDiv], null, "position: relative; outline: none");
  let s = Pl("div", [o.lineSpace], "CodeMirror-lines");
  o.mover = Ue("div", [s], null, "position: relative"), o.sizer = Ue("div", [o.mover], "CodeMirror-sizer"), o.sizerWidth = null, o.heightForcer = Ue("div", null, null, "position: absolute; height: " + aj + "px; width: 1px;"), o.gutters = Ue("div", null, "CodeMirror-gutters"), o.lineGutter = null, o.scroller = Ue("div", [o.sizer, o.heightForcer, o.gutters], "CodeMirror-scroll"), o.scroller.setAttribute("tabIndex", "-1"), o.wrapper = Ue("div", [o.scrollbarFiller, o.gutterFiller, o.scroller], "CodeMirror"), ct && kt < 8 && (o.gutters.style.zIndex = -1, o.scroller.style.paddingRight = 0), !Tr && !(bo && Gf) && (o.scroller.draggable = !0), e && (e.appendChild ? e.appendChild(o.wrapper) : e(o.wrapper)), o.viewFrom = o.viewTo = t.first, o.reportedViewFrom = o.reportedViewTo = t.first, o.view = [], o.renderedView = null, o.externalMeasured = null, o.viewOffset = 0, o.lastWrapHeight = o.lastWrapWidth = 0, o.updateLineNumbers = null, o.nativeBarWidth = o.barHeight = o.barWidth = 0, o.scrollbarsClipped = !1, o.lineNumWidth = o.lineNumInnerWidth = o.lineNumChars = null, o.alignWidgets = !1, o.cachedCharWidth = o.cachedTextHeight = o.cachedPaddingH = null, o.maxLine = null, o.maxLineLength = 0, o.maxLineChanged = !1, o.wheelDX = o.wheelDY = o.wheelStartX = o.wheelStartY = null, o.shift = !1, o.selForContextMenu = null, o.activeTouch = null, o.gutterSpecs = ZS(n.gutters, n.lineNumbers), eB(o), r.init(o);
}
var vd = 0, un = null;
ct ? un = -0.53 : bo ? un = 15 : wg ? un = -0.7 : _g && (un = -1 / 3);
function tB(e) {
  let t = e.wheelDeltaX, r = e.wheelDeltaY;
  return t == null && e.detail && e.axis == e.HORIZONTAL_AXIS && (t = e.detail), r == null && e.detail && e.axis == e.VERTICAL_AXIS ? r = e.detail : r == null && (r = e.wheelDelta), { x: t, y: r };
}
function Lde(e) {
  let t = tB(e);
  return t.x *= un, t.y *= un, t;
}
function e2(e, t) {
  let r = tB(t), n = r.x, o = r.y, s = e.display, a = s.scroller, l = a.scrollWidth > a.clientWidth, u = a.scrollHeight > a.clientHeight;
  if (n && l || o && u) {
    if (o && Rn && Tr) {
      e:
        for (let f = t.target, c = s.view; f != a; f = f.parentNode)
          for (let d = 0; d < c.length; d++)
            if (c[d].node == f) {
              e.display.currentWheelTarget = f;
              break e;
            }
    }
    if (n && !bo && !Jn && un != null) {
      o && u && Cc(e, Math.max(0, a.scrollTop + o * un)), rl(e, Math.max(0, a.scrollLeft + n * un)), (!o || o && u) && Br(t), s.wheelStartX = null;
      return;
    }
    if (o && un != null) {
      let f = o * un, c = e.doc.scrollTop, d = c + s.wrapper.clientHeight;
      f < 0 ? c = Math.max(0, c + f - 50) : d = Math.min(e.doc.height, d + f + 50), QS(e, { top: c, bottom: d });
    }
    vd < 20 && (s.wheelStartX == null ? (s.wheelStartX = a.scrollLeft, s.wheelStartY = a.scrollTop, s.wheelDX = n, s.wheelDY = o, setTimeout(() => {
      if (s.wheelStartX == null)
        return;
      let f = a.scrollLeft - s.wheelStartX, c = a.scrollTop - s.wheelStartY, d = c && s.wheelDY && c / s.wheelDY || f && s.wheelDX && f / s.wheelDX;
      s.wheelStartX = s.wheelStartY = null, d && (un = (un * vd + d) / (vd + 1), ++vd);
    }, 200)) : (s.wheelDX += n, s.wheelDY += o));
  }
}
var xs = class {
  constructor(t, r) {
    this.ranges = t, this.primIndex = r;
  }
  primary() {
    return this.ranges[this.primIndex];
  }
  equals(t) {
    if (t == this)
      return !0;
    if (t.primIndex != this.primIndex || t.ranges.length != this.ranges.length)
      return !1;
    for (let r = 0; r < this.ranges.length; r++) {
      let n = this.ranges[r], o = t.ranges[r];
      if (!zS(n.anchor, o.anchor) || !zS(n.head, o.head))
        return !1;
    }
    return !0;
  }
  deepCopy() {
    let t = [];
    for (let r = 0; r < this.ranges.length; r++)
      t[r] = new wt(GS(this.ranges[r].anchor), GS(this.ranges[r].head));
    return new xs(t, this.primIndex);
  }
  somethingSelected() {
    for (let t = 0; t < this.ranges.length; t++)
      if (!this.ranges[t].empty())
        return !0;
    return !1;
  }
  contains(t, r) {
    r || (r = t);
    for (let n = 0; n < this.ranges.length; n++) {
      let o = this.ranges[n];
      if (Ye(r, o.from()) >= 0 && Ye(t, o.to()) <= 0)
        return n;
    }
    return -1;
  }
}, wt = class {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  from() {
    return Tg(this.anchor, this.head);
  }
  to() {
    return Ag(this.anchor, this.head);
  }
  empty() {
    return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
  }
};
function Vn(e, t, r) {
  let n = e && e.options.selectionsMayTouch, o = t[r];
  t.sort((s, a) => Ye(s.from(), a.from())), r = mr(t, o);
  for (let s = 1; s < t.length; s++) {
    let a = t[s], l = t[s - 1], u = Ye(l.to(), a.from());
    if (n && !a.empty() ? u > 0 : u >= 0) {
      let f = Tg(l.from(), a.from()), c = Ag(l.to(), a.to()), d = l.empty() ? a.from() == a.head : l.from() == l.head;
      s <= r && --r, t.splice(--s, 2, new wt(d ? c : f, d ? f : c));
    }
  }
  return new xs(t, r);
}
function ds(e, t) {
  return new xs([new wt(e, t || e)], 0);
}
function hs(e) {
  return e.text ? Se(e.from.line + e.text.length - 1, yt(e.text).length + (e.text.length == 1 ? e.from.ch : 0)) : e.to;
}
function t2(e, t) {
  if (Ye(e, t.from) < 0)
    return e;
  if (Ye(e, t.to) <= 0)
    return hs(t);
  let r = e.line + t.text.length - (t.to.line - t.from.line) - 1, n = e.ch;
  return e.line == t.to.line && (n += hs(t).ch - t.to.ch), Se(r, n);
}
function NR(e, t) {
  let r = [];
  for (let n = 0; n < e.sel.ranges.length; n++) {
    let o = e.sel.ranges[n];
    r.push(new wt(t2(o.anchor, t), t2(o.head, t)));
  }
  return Vn(e.cm, r, e.sel.primIndex);
}
function r2(e, t, r) {
  return e.line == t.line ? Se(r.line, e.ch - t.ch + r.ch) : Se(r.line + (e.line - t.line), e.ch);
}
function Ode(e, t, r) {
  let n = [], o = Se(e.first, 0), s = o;
  for (let a = 0; a < t.length; a++) {
    let l = t[a], u = r2(l.from, o, s), f = r2(hs(l), o, s);
    if (o = l.to, s = f, r == "around") {
      let c = e.sel.ranges[a], d = Ye(c.head, c.anchor) < 0;
      n[a] = new wt(d ? f : u, d ? u : f);
    } else
      n[a] = new wt(u, u);
  }
  return new xs(n, e.sel.primIndex);
}
function eE(e) {
  e.doc.mode = lR(e.options, e.doc.modeOption), tf(e);
}
function tf(e) {
  e.doc.iter((t) => {
    t.stateAfter && (t.stateAfter = null), t.styles && (t.styles = null);
  }), e.doc.modeFrontier = e.doc.highlightFrontier = e.doc.first, kc(e, 100), e.state.modeGen++, e.curOp && qr(e);
}
function rB(e, t) {
  return t.from.ch == 0 && t.to.ch == 0 && yt(t.text) == "" && (!e.cm || e.cm.options.wholeLineUpdateBefore);
}
function LR(e, t, r, n) {
  function o(y) {
    return r ? r[y] : null;
  }
  function s(y, _, S) {
    qce(y, _, S, n), ir(y, "change", y, t);
  }
  function a(y, _) {
    let S = [];
    for (let x = y; x < _; ++x)
      S.push(new Zf(f[x], o(x), n));
    return S;
  }
  let l = t.from, u = t.to, f = t.text, c = je(e, l.line), d = je(e, u.line), h = yt(f), p = o(f.length - 1), m = u.line - l.line;
  if (t.full)
    e.insert(0, a(0, f.length)), e.remove(f.length, e.size - f.length);
  else if (rB(e, t)) {
    let y = a(0, f.length - 1);
    s(d, d.text, p), m && e.remove(l.line, m), y.length && e.insert(l.line, y);
  } else if (c == d)
    if (f.length == 1)
      s(c, c.text.slice(0, l.ch) + h + c.text.slice(u.ch), p);
    else {
      let y = a(1, f.length - 1);
      y.push(new Zf(h + c.text.slice(u.ch), p, n)), s(c, c.text.slice(0, l.ch) + f[0], o(0)), e.insert(l.line + 1, y);
    }
  else if (f.length == 1)
    s(c, c.text.slice(0, l.ch) + f[0] + d.text.slice(u.ch), o(0)), e.remove(l.line + 1, m);
  else {
    s(c, c.text.slice(0, l.ch) + f[0], o(0)), s(d, h + d.text.slice(u.ch), p);
    let y = a(1, f.length - 1);
    m > 1 && e.remove(l.line + 1, m - 1), e.insert(l.line + 1, y);
  }
  ir(e, "change", e, t);
}
function ts(e, t, r) {
  function n(o, s, a) {
    if (o.linked)
      for (let l = 0; l < o.linked.length; ++l) {
        let u = o.linked[l];
        if (u.doc == s)
          continue;
        let f = a && u.sharedHist;
        r && !f || (t(u.doc, f), n(u.doc, o, f));
      }
  }
  n(e, null, !0);
}
function nB(e, t) {
  if (t.cm)
    throw new Error("This document is already in use.");
  e.doc = t, t.cm = e, xR(e), eE(e), iB(e), e.options.lineWrapping || gR(e), e.options.mode = t.modeOption, qr(e);
}
function iB(e) {
  (e.doc.direction == "rtl" ? el : Za)(e.display.lineDiv, "CodeMirror-rtl");
}
function Pde(e) {
  en(e, () => {
    iB(e), qr(e);
  });
}
function Vd(e) {
  this.done = [], this.undone = [], this.undoDepth = e ? e.undoDepth : 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = e ? e.maxGeneration : 1;
}
function tE(e, t) {
  let r = { from: GS(t.from), to: hs(t), text: ya(e, t.from, t.to) };
  return n2(e, r, t.from.line, t.to.line + 1), ts(e, (n) => n2(n, r, t.from.line, t.to.line + 1), !0), r;
}
function oB(e) {
  for (; e.length && yt(e).ranges; )
    e.pop();
}
function Dde(e, t) {
  if (t)
    return oB(e.done), yt(e.done);
  if (e.done.length && !yt(e.done).ranges)
    return yt(e.done);
  if (e.done.length > 1 && !e.done[e.done.length - 2].ranges)
    return e.done.pop(), yt(e.done);
}
function sB(e, t, r, n) {
  let o = e.history;
  o.undone.length = 0;
  let s = +/* @__PURE__ */ new Date(), a, l;
  if ((o.lastOp == n || o.lastOrigin == t.origin && t.origin && (t.origin.charAt(0) == "+" && o.lastModTime > s - (e.cm ? e.cm.options.historyEventDelay : 500) || t.origin.charAt(0) == "*")) && (a = Dde(o, o.lastOp == n)))
    l = yt(a.changes), Ye(t.from, t.to) == 0 && Ye(t.from, l.to) == 0 ? l.to = hs(t) : a.changes.push(tE(e, t));
  else {
    let u = yt(o.done);
    for ((!u || !u.ranges) && Fh(e.sel, o.done), a = {
      changes: [tE(e, t)],
      generation: o.generation
    }, o.done.push(a); o.done.length > o.undoDepth; )
      o.done.shift(), o.done[0].ranges || o.done.shift();
  }
  o.done.push(r), o.generation = ++o.maxGeneration, o.lastModTime = o.lastSelTime = s, o.lastOp = o.lastSelOp = n, o.lastOrigin = o.lastSelOrigin = t.origin, l || Ht(e, "historyAdded");
}
function Fde(e, t, r, n) {
  let o = t.charAt(0);
  return o == "*" || o == "+" && r.ranges.length == n.ranges.length && r.somethingSelected() == n.somethingSelected() && /* @__PURE__ */ new Date() - e.history.lastSelTime <= (e.cm ? e.cm.options.historyEventDelay : 500);
}
function jde(e, t, r, n) {
  let o = e.history, s = n && n.origin;
  r == o.lastSelOp || s && o.lastSelOrigin == s && (o.lastModTime == o.lastSelTime && o.lastOrigin == s || Fde(e, s, yt(o.done), t)) ? o.done[o.done.length - 1] = t : Fh(t, o.done), o.lastSelTime = +/* @__PURE__ */ new Date(), o.lastSelOrigin = s, o.lastSelOp = r, n && n.clearRedo !== !1 && oB(o.undone);
}
function Fh(e, t) {
  let r = yt(t);
  r && r.ranges && r.equals(e) || t.push(e);
}
function n2(e, t, r, n) {
  let o = t["spans_" + e.id], s = 0;
  e.iter(Math.max(e.first, r), Math.min(e.first + e.size, n), (a) => {
    a.markedSpans && ((o || (o = t["spans_" + e.id] = {}))[s] = a.markedSpans), ++s;
  });
}
function Bde(e) {
  if (!e)
    return null;
  let t;
  for (let r = 0; r < e.length; ++r)
    e[r].marker.explicitlyCleared ? t || (t = e.slice(0, r)) : t && t.push(e[r]);
  return t ? t.length ? t : null : e;
}
function qde(e, t) {
  let r = t["spans_" + e.id];
  if (!r)
    return null;
  let n = [];
  for (let o = 0; o < t.text.length; ++o)
    n.push(Bde(r[o]));
  return n;
}
function i2(e, t) {
  let r = qde(e, t), n = VS(e, t);
  if (!r)
    return n;
  if (!n)
    return r;
  for (let o = 0; o < r.length; ++o) {
    let s = r[o], a = n[o];
    if (s && a)
      e:
        for (let l = 0; l < a.length; ++l) {
          let u = a[l];
          for (let f = 0; f < s.length; ++f)
            if (s[f].marker == u.marker)
              continue e;
          s.push(u);
        }
    else
      a && (r[o] = a);
  }
  return r;
}
function cl(e, t, r) {
  let n = [];
  for (let s = 0; s < e.length; ++s) {
    let a = e[s];
    if (a.ranges) {
      n.push(r ? xs.prototype.deepCopy.call(a) : a);
      continue;
    }
    let l = a.changes, u = [];
    n.push({ changes: u });
    for (let f = 0; f < l.length; ++f) {
      let c = l[f], d;
      if (u.push({ from: c.from, to: c.to, text: c.text }), t)
        for (var o in c)
          (d = o.match(/^spans_(\d+)$/)) && mr(t, Number(d[1])) > -1 && (yt(u)[o] = c[o], delete c[o]);
    }
  }
  return n;
}
function OR(e, t, r, n) {
  if (n) {
    let o = e.anchor;
    if (r) {
      let s = Ye(t, o) < 0;
      s != Ye(r, o) < 0 ? (o = t, t = r) : s != Ye(t, r) < 0 && (t = r);
    }
    return new wt(o, t);
  } else
    return new wt(r || t, t);
}
function Lg(e, t, r, n, o) {
  o == null && (o = e.cm && (e.cm.display.shift || e.extend)), hr(e, new xs([OR(e.sel.primary(), t, r, o)], 0), n);
}
function o2(e, t, r) {
  let n = [], o = e.cm && (e.cm.display.shift || e.extend);
  for (let a = 0; a < e.sel.ranges.length; a++)
    n[a] = OR(e.sel.ranges[a], t[a], null, o);
  let s = Vn(e.cm, n, e.sel.primIndex);
  hr(e, s, r);
}
function PR(e, t, r, n) {
  let o = e.sel.ranges.slice(0);
  o[t] = r, hr(e, Vn(e.cm, o, e.sel.primIndex), n);
}
function s2(e, t, r, n) {
  hr(e, ds(t, r), n);
}
function Wde(e, t, r) {
  let n = {
    ranges: t.ranges,
    update: function(o) {
      this.ranges = [];
      for (let s = 0; s < o.length; s++)
        this.ranges[s] = new wt(Ke(e, o[s].anchor), Ke(e, o[s].head));
    },
    origin: r && r.origin
  };
  return Ht(e, "beforeSelectionChange", e, n), e.cm && Ht(e.cm, "beforeSelectionChange", e.cm, n), n.ranges != t.ranges ? Vn(e.cm, n.ranges, n.ranges.length - 1) : t;
}
function aB(e, t, r) {
  let n = e.history.done, o = yt(n);
  o && o.ranges ? (n[n.length - 1] = t, Og(e, t, r)) : hr(e, t, r);
}
function hr(e, t, r) {
  Og(e, t, r), jde(e, e.sel, e.cm ? e.cm.curOp.id : NaN, r);
}
function Og(e, t, r) {
  (An(e, "beforeSelectionChange") || e.cm && An(e.cm, "beforeSelectionChange")) && (t = Wde(e, t, r));
  let n = r && r.bias || (Ye(t.primary().head, e.sel.primary().head) < 0 ? -1 : 1);
  lB(e, fB(e, t, n, !0)), !(r && r.scroll === !1) && e.cm && e.cm.getOption("readOnly") != "nocursor" && xu(e.cm);
}
function lB(e, t) {
  t.equals(e.sel) || (e.sel = t, e.cm && (e.cm.curOp.updateInput = 1, e.cm.curOp.selectionChanged = !0, cj(e.cm)), ir(e, "cursorActivity", e));
}
function uB(e) {
  lB(e, fB(e, e.sel, null, !1));
}
function fB(e, t, r, n) {
  let o;
  for (let s = 0; s < t.ranges.length; s++) {
    let a = t.ranges[s], l = t.ranges.length == e.sel.ranges.length && e.sel.ranges[s], u = jh(e, a.anchor, l && l.anchor, r, n), f = jh(e, a.head, l && l.head, r, n);
    (o || u != a.anchor || f != a.head) && (o || (o = t.ranges.slice(0, s)), o[s] = new wt(u, f));
  }
  return o ? Vn(e.cm, o, t.primIndex) : t;
}
function Rl(e, t, r, n, o) {
  let s = je(e, t.line);
  if (s.markedSpans)
    for (let a = 0; a < s.markedSpans.length; ++a) {
      let l = s.markedSpans[a], u = l.marker, f = "selectLeft" in u ? !u.selectLeft : u.inclusiveLeft, c = "selectRight" in u ? !u.selectRight : u.inclusiveRight;
      if ((l.from == null || (f ? l.from <= t.ch : l.from < t.ch)) && (l.to == null || (c ? l.to >= t.ch : l.to > t.ch))) {
        if (o && (Ht(u, "beforeCursorEnter"), u.explicitlyCleared))
          if (s.markedSpans) {
            --a;
            continue;
          } else
            break;
        if (!u.atomic)
          continue;
        if (r) {
          let h = u.find(n < 0 ? 1 : -1), p;
          if ((n < 0 ? c : f) && (h = a2(e, h, -n, h && h.line == t.line ? s : null)), h && h.line == t.line && (p = Ye(h, r)) && (n < 0 ? p < 0 : p > 0))
            return Rl(e, h, t, n, o);
        }
        let d = u.find(n < 0 ? -1 : 1);
        return (n < 0 ? f : c) && (d = a2(e, d, n, d.line == t.line ? s : null)), d ? Rl(e, d, t, n, o) : null;
      }
    }
  return t;
}
function jh(e, t, r, n, o) {
  let s = n || 1, a = Rl(e, t, r, s, o) || !o && Rl(e, t, r, s, !0) || Rl(e, t, r, -s, o) || !o && Rl(e, t, r, -s, !0);
  return a || (e.cantEdit = !0, Se(e.first, 0));
}
function a2(e, t, r, n) {
  return r < 0 && t.ch == 0 ? t.line > e.first ? Ke(e, Se(t.line - 1)) : null : r > 0 && t.ch == (n || je(e, t.line)).text.length ? t.line < e.first + e.size - 1 ? Se(t.line + 1, 0) : null : new Se(t.line, t.ch + r);
}
function cB(e) {
  e.setSelection(Se(e.firstLine(), 0), Se(e.lastLine()), Ii);
}
function dB(e, t, r) {
  let n = {
    canceled: !1,
    from: t.from,
    to: t.to,
    text: t.text,
    origin: t.origin,
    cancel: () => n.canceled = !0
  };
  return r && (n.update = (o, s, a, l) => {
    o && (n.from = Ke(e, o)), s && (n.to = Ke(e, s)), a && (n.text = a), l !== void 0 && (n.origin = l);
  }), Ht(e, "beforeChange", e, n), e.cm && Ht(e.cm, "beforeChange", e.cm, n), n.canceled ? (e.cm && (e.cm.curOp.updateInput = 2), null) : { from: n.from, to: n.to, text: n.text, origin: n.origin };
}
function nu(e, t, r) {
  if (e.cm) {
    if (!e.cm.curOp)
      return tr(e.cm, nu)(e, t, r);
    if (e.cm.state.suppressEdits)
      return;
  }
  if ((An(e, "beforeChange") || e.cm && An(e.cm, "beforeChange")) && (t = dB(e, t, !0), !t))
    return;
  let n = vj && !r && Dce(e, t.from, t.to);
  if (n)
    for (let o = n.length - 1; o >= 0; --o)
      l2(e, { from: n[o].from, to: n[o].to, text: o ? [""] : t.text, origin: t.origin });
  else
    l2(e, t);
}
function l2(e, t) {
  if (t.text.length == 1 && t.text[0] == "" && Ye(t.from, t.to) == 0)
    return;
  let r = NR(e, t);
  sB(e, t, r, e.cm ? e.cm.curOp.id : NaN), ic(e, t, r, VS(e, t));
  let n = [];
  ts(e, (o, s) => {
    !s && mr(n, o.history) == -1 && (hB(o.history, t), n.push(o.history)), ic(o, t, null, VS(o, t));
  });
}
function wd(e, t, r) {
  let n = e.cm && e.cm.state.suppressEdits;
  if (n && !r)
    return;
  let o = e.history, s, a = e.sel, l = t == "undo" ? o.done : o.undone, u = t == "undo" ? o.undone : o.done, f = 0;
  for (; f < l.length && (s = l[f], !(r ? s.ranges && !s.equals(e.sel) : !s.ranges)); f++)
    ;
  if (f == l.length)
    return;
  for (o.lastOrigin = o.lastSelOrigin = null; ; )
    if (s = l.pop(), s.ranges) {
      if (Fh(s, u), r && !s.equals(e.sel)) {
        hr(e, s, { clearRedo: !1 });
        return;
      }
      a = s;
    } else if (n) {
      l.push(s);
      return;
    } else
      break;
  let c = [];
  Fh(a, u), u.push({ changes: c, generation: o.generation }), o.generation = s.generation || ++o.maxGeneration;
  let d = An(e, "beforeChange") || e.cm && An(e.cm, "beforeChange");
  for (let h = s.changes.length - 1; h >= 0; --h) {
    let p = s.changes[h];
    if (p.origin = t, d && !dB(e, p, !1)) {
      l.length = 0;
      return;
    }
    c.push(tE(e, p));
    let m = h ? NR(e, p) : yt(l);
    ic(e, p, m, i2(e, p)), !h && e.cm && e.cm.scrollIntoView({ from: p.from, to: hs(p) });
    let y = [];
    ts(e, (_, S) => {
      !S && mr(y, _.history) == -1 && (hB(_.history, p), y.push(_.history)), ic(_, p, null, i2(_, p));
    });
  }
}
function u2(e, t) {
  if (t != 0 && (e.first += t, e.sel = new xs(xg(e.sel.ranges, (r) => new wt(Se(r.anchor.line + t, r.anchor.ch), Se(r.head.line + t, r.head.ch))), e.sel.primIndex), e.cm)) {
    qr(e.cm, e.first, e.first - t, t);
    for (let r = e.cm.display, n = r.viewFrom; n < r.viewTo; n++)
      Es(e.cm, n, "gutter");
  }
}
function ic(e, t, r, n) {
  if (e.cm && !e.cm.curOp)
    return tr(e.cm, ic)(e, t, r, n);
  if (t.to.line < e.first) {
    u2(e, t.text.length - 1 - (t.to.line - t.from.line));
    return;
  }
  if (t.from.line > e.lastLine())
    return;
  if (t.from.line < e.first) {
    let s = t.text.length - 1 - (e.first - t.from.line);
    u2(e, s), t = {
      from: Se(e.first, 0),
      to: Se(t.to.line + s, t.to.ch),
      text: [yt(t.text)],
      origin: t.origin
    };
  }
  let o = e.lastLine();
  t.to.line > o && (t = {
    from: t.from,
    to: Se(o, je(e, o).text.length),
    text: [t.text[0]],
    origin: t.origin
  }), t.removed = ya(e, t.from, t.to), r || (r = NR(e, t)), e.cm ? Ude(e.cm, t, n) : LR(e, t, n), Og(e, r, Ii), e.cantEdit && jh(e, Se(e.firstLine(), 0)) && (e.cantEdit = !1);
}
function Ude(e, t, r) {
  let n = e.doc, o = e.display, s = t.from, a = t.to, l = !1, u = s.line;
  e.options.lineWrapping || (u = mt(Ni(je(n, s.line))), n.iter(u, a.line + 1, (h) => {
    if (h == o.maxLine)
      return l = !0, !0;
  })), n.sel.contains(t.from, t.to) > -1 && cj(e), LR(n, t, r, Wj(e)), e.options.lineWrapping || (n.iter(u, s.line + t.text.length, (h) => {
    let p = Ph(h);
    p > o.maxLineLength && (o.maxLine = h, o.maxLineLength = p, o.maxLineChanged = !0, l = !1);
  }), l && (e.curOp.updateMaxLine = !0)), kce(n, s.line), kc(e, 400);
  let f = t.text.length - (a.line - s.line) - 1;
  t.full ? qr(e) : s.line == a.line && t.text.length == 1 && !rB(e.doc, t) ? Es(e, s.line, "text") : qr(e, s.line, a.line + 1, f);
  let c = An(e, "changes"), d = An(e, "change");
  if (d || c) {
    let h = {
      from: s,
      to: a,
      text: t.text,
      removed: t.removed,
      origin: t.origin
    };
    d && ir(e, "change", e, h), c && (e.curOp.changeObjs || (e.curOp.changeObjs = [])).push(h);
  }
  e.display.selForContextMenu = null;
}
function Ru(e, t, r, n, o) {
  n || (n = r), Ye(n, r) < 0 && ([r, n] = [n, r]), typeof t == "string" && (t = e.splitLines(t)), nu(e, { from: r, to: n, text: t, origin: o });
}
function f2(e, t, r, n) {
  r < e.line ? e.line += n : t < e.line && (e.line = t, e.ch = 0);
}
function c2(e, t, r, n) {
  for (let o = 0; o < e.length; ++o) {
    let s = e[o], a = !0;
    if (s.ranges) {
      s.copied || (s = e[o] = s.deepCopy(), s.copied = !0);
      for (let l = 0; l < s.ranges.length; l++)
        f2(s.ranges[l].anchor, t, r, n), f2(s.ranges[l].head, t, r, n);
      continue;
    }
    for (let l = 0; l < s.changes.length; ++l) {
      let u = s.changes[l];
      if (r < u.from.line)
        u.from = Se(u.from.line + n, u.from.ch), u.to = Se(u.to.line + n, u.to.ch);
      else if (t <= u.to.line) {
        a = !1;
        break;
      }
    }
    a || (e.splice(0, o + 1), o = 0);
  }
}
function hB(e, t) {
  let r = t.from.line, n = t.to.line, o = t.text.length - (n - r) - 1;
  c2(e.done, r, n, o), c2(e.undone, r, n, o);
}
function rf(e, t, r, n) {
  let o = t, s = t;
  return typeof t == "number" ? s = je(e, gj(e, t)) : o = mt(t), o == null ? null : (n(s, o) && e.cm && Es(e.cm, o, r), s);
}
function kf(e) {
  this.lines = e, this.parent = null;
  let t = 0;
  for (let r = 0; r < e.length; ++r)
    e[r].parent = this, t += e[r].height;
  this.height = t;
}
kf.prototype = {
  chunkSize() {
    return this.lines.length;
  },
  removeInner(e, t) {
    for (let r = e, n = e + t; r < n; ++r) {
      let o = this.lines[r];
      this.height -= o.height, Wce(o), ir(o, "delete");
    }
    this.lines.splice(e, t);
  },
  collapse(e) {
    e.push.apply(e, this.lines);
  },
  insertInner(e, t, r) {
    this.height += r, this.lines = this.lines.slice(0, e).concat(t).concat(this.lines.slice(e));
    for (let n = 0; n < t.length; ++n)
      t[n].parent = this;
  },
  iterN(e, t, r) {
    for (let n = e + t; e < n; ++e)
      if (r(this.lines[e]))
        return !0;
  }
};
function If(e) {
  this.children = e;
  let t = 0, r = 0;
  for (let n = 0; n < e.length; ++n) {
    let o = e[n];
    t += o.chunkSize(), r += o.height, o.parent = this;
  }
  this.size = t, this.height = r, this.parent = null;
}
If.prototype = {
  chunkSize() {
    return this.size;
  },
  removeInner(e, t) {
    this.size -= t;
    for (let r = 0; r < this.children.length; ++r) {
      let n = this.children[r], o = n.chunkSize();
      if (e < o) {
        let s = Math.min(t, o - e), a = n.height;
        if (n.removeInner(e, s), this.height -= a - n.height, o == s && (this.children.splice(r--, 1), n.parent = null), (t -= s) == 0)
          break;
        e = 0;
      } else
        e -= o;
    }
    if (this.size - t < 25 && (this.children.length > 1 || !(this.children[0] instanceof kf))) {
      let r = [];
      this.collapse(r), this.children = [new kf(r)], this.children[0].parent = this;
    }
  },
  collapse(e) {
    for (let t = 0; t < this.children.length; ++t)
      this.children[t].collapse(e);
  },
  insertInner(e, t, r) {
    this.size += t.length, this.height += r;
    for (let n = 0; n < this.children.length; ++n) {
      let o = this.children[n], s = o.chunkSize();
      if (e <= s) {
        if (o.insertInner(e, t, r), o.lines && o.lines.length > 50) {
          let a = o.lines.length % 25 + 25;
          for (let l = a; l < o.lines.length; ) {
            let u = new kf(o.lines.slice(l, l += 25));
            o.height -= u.height, this.children.splice(++n, 0, u), u.parent = this;
          }
          o.lines = o.lines.slice(0, a), this.maybeSpill();
        }
        break;
      }
      e -= s;
    }
  },
  maybeSpill() {
    if (this.children.length <= 10)
      return;
    let e = this;
    do {
      let t = e.children.splice(e.children.length - 5, 5), r = new If(t);
      if (e.parent) {
        e.size -= r.size, e.height -= r.height;
        let n = mr(e.parent.children, e);
        e.parent.children.splice(n + 1, 0, r);
      } else {
        let n = new If(e.children);
        n.parent = e, e.children = [n, r], e = n;
      }
      r.parent = e.parent;
    } while (e.children.length > 10);
    e.parent.maybeSpill();
  },
  iterN(e, t, r) {
    for (let n = 0; n < this.children.length; ++n) {
      let o = this.children[n], s = o.chunkSize();
      if (e < s) {
        let a = Math.min(t, s - e);
        if (o.iterN(e, a, r))
          return !0;
        if ((t -= a) == 0)
          break;
        e = 0;
      } else
        e -= s;
    }
  }
};
var DR = class {
  constructor(e, t, r) {
    if (r)
      for (let n in r)
        r.hasOwnProperty(n) && (this[n] = r[n]);
    this.doc = e, this.node = t;
  }
  clear() {
    let e = this.doc.cm, t = this.line.widgets, r = this.line, n = mt(r);
    if (n == null || !t)
      return;
    for (let s = 0; s < t.length; ++s)
      t[s] == this && t.splice(s--, 1);
    t.length || (r.widgets = null);
    let o = tc(this);
    Mi(r, Math.max(0, r.height - o)), e && (en(e, () => {
      d2(e, r, -o), Es(e, n, "widget");
    }), ir(e, "lineWidgetCleared", e, this, n));
  }
  changed() {
    let e = this.height, t = this.doc.cm, r = this.line;
    this.height = null;
    let n = tc(this) - e;
    n && (cs(this.doc, r) || Mi(r, r.height + n), t && en(t, () => {
      t.curOp.forceUpdate = !0, d2(t, r, n), ir(t, "lineWidgetChanged", t, this, mt(r));
    }));
  }
};
wu(DR);
function d2(e, t, r) {
  mo(t) < (e.curOp && e.curOp.scrollTop || e.doc.scrollTop) && CR(e, r);
}
function Hde(e, t, r, n) {
  let o = new DR(e, r, n), s = e.cm;
  return s && o.noHScroll && (s.display.alignWidgets = !0), rf(e, t, "widget", (a) => {
    let l = a.widgets || (a.widgets = []);
    if (o.insertAt == null ? l.push(o) : l.splice(Math.min(l.length, Math.max(0, o.insertAt)), 0, o), o.line = a, s && !cs(e, a)) {
      let u = mo(a) < e.scrollTop;
      Mi(a, a.height + tc(o)), u && CR(s, o.height), s.curOp.forceUpdate = !0;
    }
    return !0;
  }), s && ir(s, "lineWidgetAdded", s, o, typeof t == "number" ? t : mt(t)), o;
}
var pB = 0, FR = class {
  constructor(e, t) {
    this.lines = [], this.type = t, this.doc = e, this.id = ++pB;
  }
  clear() {
    if (this.explicitlyCleared)
      return;
    let e = this.doc.cm, t = e && !e.curOp;
    if (t && nl(e), An(this, "clear")) {
      let o = this.find();
      o && ir(this, "clear", o.from, o.to);
    }
    let r = null, n = null;
    for (let o = 0; o < this.lines.length; ++o) {
      let s = this.lines[o], a = Qf(s.markedSpans, this);
      e && !this.collapsed ? Es(e, mt(s), "text") : e && (a.to != null && (n = mt(s)), a.from != null && (r = mt(s))), s.markedSpans = Nce(s.markedSpans, a), a.from == null && this.collapsed && !cs(this.doc, s) && e && Mi(s, tu(e.display));
    }
    if (e && this.collapsed && !e.options.lineWrapping)
      for (let o = 0; o < this.lines.length; ++o) {
        let s = Ni(this.lines[o]), a = Ph(s);
        a > e.display.maxLineLength && (e.display.maxLine = s, e.display.maxLineLength = a, e.display.maxLineChanged = !0);
      }
    r != null && e && this.collapsed && qr(e, r, n + 1), this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, e && uB(e.doc)), e && ir(e, "markerCleared", e, this, r, n), t && il(e), this.parent && this.parent.clear();
  }
  find(e, t) {
    e == null && this.type == "bookmark" && (e = 1);
    let r, n;
    for (let o = 0; o < this.lines.length; ++o) {
      let s = this.lines[o], a = Qf(s.markedSpans, this);
      if (a.from != null && (r = Se(t ? s : mt(s), a.from), e == -1))
        return r;
      if (a.to != null && (n = Se(t ? s : mt(s), a.to), e == 1))
        return n;
    }
    return r && { from: r, to: n };
  }
  changed() {
    let e = this.find(-1, !0), t = this, r = this.doc.cm;
    !e || !r || en(r, () => {
      let n = e.line, o = mt(e.line), s = vR(r, o);
      if (s && (Pj(s), r.curOp.selectionChanged = r.curOp.forceUpdate = !0), r.curOp.updateMaxLine = !0, !cs(t.doc, n) && t.height != null) {
        let a = t.height;
        t.height = null;
        let l = tc(t) - a;
        l && Mi(n, n.height + l);
      }
      ir(r, "markerChanged", r, this);
    });
  }
  attachLine(e) {
    if (!this.lines.length && this.doc.cm) {
      let t = this.doc.cm.curOp;
      (!t.maybeHiddenMarkers || mr(t.maybeHiddenMarkers, this) == -1) && (t.maybeUnhiddenMarkers || (t.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(e);
  }
  detachLine(e) {
    if (this.lines.splice(mr(this.lines, e), 1), !this.lines.length && this.doc.cm) {
      let t = this.doc.cm.curOp;
      (t.maybeHiddenMarkers || (t.maybeHiddenMarkers = [])).push(this);
    }
  }
};
wu(FR);
function iu(e, t, r, n, o) {
  if (n && n.shared)
    return zde(e, t, r, n, o);
  if (e.cm && !e.cm.curOp)
    return tr(e.cm, iu)(e, t, r, n, o);
  let s = new FR(e, o), a = Ye(t, r);
  if (n && ka(n, s, !1), a > 0 || a == 0 && s.clearWhenEmpty !== !1)
    return s;
  if (s.replacedWith && (s.collapsed = !0, s.widgetNode = Pl("span", [s.replacedWith], "CodeMirror-widget"), n.handleMouseEvents || s.widgetNode.setAttribute("cm-ignore-events", "true"), n.insertLeft && (s.widgetNode.insertLeft = !0)), s.collapsed) {
    if (zI(e, t.line, t, r, s) || t.line != r.line && zI(e, r.line, t, r, s))
      throw new Error("Inserting collapsed marker partially overlapping an existing one");
    Mce();
  }
  s.addToHistory && sB(e, { from: t, to: r, origin: "markText" }, e.sel, NaN);
  let l = t.line, u = e.cm, f;
  if (e.iter(l, r.line + 1, (c) => {
    u && s.collapsed && !u.options.lineWrapping && Ni(c) == u.display.maxLine && (f = !0), s.collapsed && l != t.line && Mi(c, 0), Lce(c, new $g(s, l == t.line ? t.ch : null, l == r.line ? r.ch : null)), ++l;
  }), s.collapsed && e.iter(t.line, r.line + 1, (c) => {
    cs(e, c) && Mi(c, 0);
  }), s.clearOnEnter && He(s, "beforeCursorEnter", () => s.clear()), s.readOnly && (Ice(), (e.history.done.length || e.history.undone.length) && e.clearHistory()), s.collapsed && (s.id = ++pB, s.atomic = !0), u) {
    if (f && (u.curOp.updateMaxLine = !0), s.collapsed)
      qr(u, t.line, r.line + 1);
    else if (s.className || s.startStyle || s.endStyle || s.css || s.attributes || s.title)
      for (let c = t.line; c <= r.line; c++)
        Es(u, c, "text");
    s.atomic && uB(u.doc), ir(u, "markerAdded", u, s);
  }
  return s;
}
var jR = class {
  constructor(e, t) {
    this.markers = e, this.primary = t;
    for (let r = 0; r < e.length; ++r)
      e[r].parent = this;
  }
  clear() {
    if (!this.explicitlyCleared) {
      this.explicitlyCleared = !0;
      for (let e = 0; e < this.markers.length; ++e)
        this.markers[e].clear();
      ir(this, "clear");
    }
  }
  find(e, t) {
    return this.primary.find(e, t);
  }
};
wu(jR);
function zde(e, t, r, n, o) {
  n = ka(n), n.shared = !1;
  let s = [iu(e, t, r, n, o)], a = s[0], l = n.widgetNode;
  return ts(e, (u) => {
    l && (n.widgetNode = l.cloneNode(!0)), s.push(iu(u, Ke(u, t), Ke(u, r), n, o));
    for (let f = 0; f < u.linked.length; ++f)
      if (u.linked[f].isParent)
        return;
    a = yt(s);
  }), new jR(s, a);
}
function h2(e) {
  return e.findMarks(Se(e.first, 0), e.clipPos(Se(e.lastLine())), (t) => t.parent);
}
function Gde(e, t) {
  for (let r = 0; r < t.length; r++) {
    let n = t[r], o = n.find(), s = e.clipPos(o.from), a = e.clipPos(o.to);
    if (Ye(s, a)) {
      let l = iu(e, s, a, n.primary, n.primary.type);
      n.markers.push(l), l.parent = n;
    }
  }
}
function Vde(e) {
  for (let t = 0; t < e.length; t++) {
    let r = e[t], n = [r.primary.doc];
    ts(r.primary.doc, (o) => n.push(o));
    for (let o = 0; o < r.markers.length; o++) {
      let s = r.markers[o];
      mr(n, s.doc) == -1 && (s.parent = null, r.markers.splice(o--, 1));
    }
  }
}
var Kde = 0, Qi = function(e, t, r, n, o) {
  if (!(this instanceof Qi))
    return new Qi(e, t, r, n, o);
  r == null && (r = 0), If.call(this, [new kf([new Zf("", null)])]), this.first = r, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, this.cleanGeneration = 1, this.modeFrontier = this.highlightFrontier = r;
  let s = Se(r, 0);
  this.sel = ds(s), this.history = new Vd(null), this.id = ++Kde, this.modeOption = t, this.lineSep = n, this.direction = o == "rtl" ? "rtl" : "ltr", this.extend = !1, typeof e == "string" && (e = this.splitLines(e)), LR(this, { from: s, to: s, text: e }), hr(this, ds(s), Ii);
};
Qi.prototype = lj(If.prototype, {
  constructor: Qi,
  iter: function(e, t, r) {
    r ? this.iterN(e - this.first, t - e, r) : this.iterN(this.first, this.first + this.size, e);
  },
  insert: function(e, t) {
    let r = 0;
    for (let n = 0; n < t.length; ++n)
      r += t[n].height;
    this.insertInner(e - this.first, t, r);
  },
  remove: function(e, t) {
    this.removeInner(e - this.first, t);
  },
  getValue: function(e) {
    let t = S0(this, this.first, this.first + this.size);
    return e === !1 ? t : t.join(e || this.lineSeparator());
  },
  setValue: Jt(function(e) {
    let t = Se(this.first, 0), r = this.first + this.size - 1;
    nu(this, {
      from: t,
      to: Se(r, je(this, r).text.length),
      text: this.splitLines(e),
      origin: "setValue",
      full: !0
    }, !0), this.cm && Cf(this.cm, 0, 0), hr(this, ds(t), Ii);
  }),
  replaceRange: function(e, t, r, n) {
    t = Ke(this, t), r = r ? Ke(this, r) : t, Ru(this, e, t, r, n);
  },
  getRange: function(e, t, r) {
    let n = ya(this, Ke(this, e), Ke(this, t));
    return r === !1 ? n : n.join(r || this.lineSeparator());
  },
  getLine: function(e) {
    let t = this.getLineHandle(e);
    return t && t.text;
  },
  getLineHandle: function(e) {
    if (Jf(this, e))
      return je(this, e);
  },
  getLineNumber: function(e) {
    return mt(e);
  },
  getLineHandleVisualStart: function(e) {
    return typeof e == "number" && (e = je(this, e)), Ni(e);
  },
  lineCount: function() {
    return this.size;
  },
  firstLine: function() {
    return this.first;
  },
  lastLine: function() {
    return this.first + this.size - 1;
  },
  clipPos: function(e) {
    return Ke(this, e);
  },
  getCursor: function(e) {
    let t = this.sel.primary(), r;
    return e == null || e == "head" ? r = t.head : e == "anchor" ? r = t.anchor : e == "end" || e == "to" || e === !1 ? r = t.to() : r = t.from(), r;
  },
  listSelections: function() {
    return this.sel.ranges;
  },
  somethingSelected: function() {
    return this.sel.somethingSelected();
  },
  setCursor: Jt(function(e, t, r) {
    s2(this, Ke(this, typeof e == "number" ? Se(e, t || 0) : e), null, r);
  }),
  setSelection: Jt(function(e, t, r) {
    s2(this, Ke(this, e), Ke(this, t || e), r);
  }),
  extendSelection: Jt(function(e, t, r) {
    Lg(this, Ke(this, e), t && Ke(this, t), r);
  }),
  extendSelections: Jt(function(e, t) {
    o2(this, jI(this, e), t);
  }),
  extendSelectionsBy: Jt(function(e, t) {
    let r = xg(this.sel.ranges, e);
    o2(this, jI(this, r), t);
  }),
  setSelections: Jt(function(e, t, r) {
    if (!e.length)
      return;
    let n = [];
    for (let o = 0; o < e.length; o++)
      n[o] = new wt(Ke(this, e[o].anchor), Ke(this, e[o].head || e[o].anchor));
    t == null && (t = Math.min(e.length - 1, this.sel.primIndex)), hr(this, Vn(this.cm, n, t), r);
  }),
  addSelection: Jt(function(e, t, r) {
    let n = this.sel.ranges.slice(0);
    n.push(new wt(Ke(this, e), Ke(this, t || e))), hr(this, Vn(this.cm, n, n.length - 1), r);
  }),
  getSelection: function(e) {
    let t = this.sel.ranges, r;
    for (let n = 0; n < t.length; n++) {
      let o = ya(this, t[n].from(), t[n].to());
      r = r ? r.concat(o) : o;
    }
    return e === !1 ? r : r.join(e || this.lineSeparator());
  },
  getSelections: function(e) {
    let t = [], r = this.sel.ranges;
    for (let n = 0; n < r.length; n++) {
      let o = ya(this, r[n].from(), r[n].to());
      e !== !1 && (o = o.join(e || this.lineSeparator())), t[n] = o;
    }
    return t;
  },
  replaceSelection: function(e, t, r) {
    let n = [];
    for (let o = 0; o < this.sel.ranges.length; o++)
      n[o] = e;
    this.replaceSelections(n, t, r || "+input");
  },
  replaceSelections: Jt(function(e, t, r) {
    let n = [], o = this.sel;
    for (let a = 0; a < o.ranges.length; a++) {
      let l = o.ranges[a];
      n[a] = { from: l.from(), to: l.to(), text: this.splitLines(e[a]), origin: r };
    }
    let s = t && t != "end" && Ode(this, n, t);
    for (let a = n.length - 1; a >= 0; a--)
      nu(this, n[a]);
    s ? aB(this, s) : this.cm && xu(this.cm);
  }),
  undo: Jt(function() {
    wd(this, "undo");
  }),
  redo: Jt(function() {
    wd(this, "redo");
  }),
  undoSelection: Jt(function() {
    wd(this, "undo", !0);
  }),
  redoSelection: Jt(function() {
    wd(this, "redo", !0);
  }),
  setExtending: function(e) {
    this.extend = e;
  },
  getExtending: function() {
    return this.extend;
  },
  historySize: function() {
    let e = this.history, t = 0, r = 0;
    for (let n = 0; n < e.done.length; n++)
      e.done[n].ranges || ++t;
    for (let n = 0; n < e.undone.length; n++)
      e.undone[n].ranges || ++r;
    return { undo: t, redo: r };
  },
  clearHistory: function() {
    this.history = new Vd(this.history), ts(this, (e) => e.history = this.history, !0);
  },
  markClean: function() {
    this.cleanGeneration = this.changeGeneration(!0);
  },
  changeGeneration: function(e) {
    return e && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation;
  },
  isClean: function(e) {
    return this.history.generation == (e || this.cleanGeneration);
  },
  getHistory: function() {
    return {
      done: cl(this.history.done),
      undone: cl(this.history.undone)
    };
  },
  setHistory: function(e) {
    let t = this.history = new Vd(this.history);
    t.done = cl(e.done.slice(0), null, !0), t.undone = cl(e.undone.slice(0), null, !0);
  },
  setGutterMarker: Jt(function(e, t, r) {
    return rf(this, e, "gutter", (n) => {
      let o = n.gutterMarkers || (n.gutterMarkers = {});
      return o[t] = r, !r && FI(o) && (n.gutterMarkers = null), !0;
    });
  }),
  clearGutter: Jt(function(e) {
    this.iter((t) => {
      t.gutterMarkers && t.gutterMarkers[e] && rf(this, t, "gutter", () => (t.gutterMarkers[e] = null, FI(t.gutterMarkers) && (t.gutterMarkers = null), !0));
    });
  }),
  lineInfo: function(e) {
    let t;
    if (typeof e == "number") {
      if (!Jf(this, e) || (t = e, e = je(this, e), !e))
        return null;
    } else if (t = mt(e), t == null)
      return null;
    return {
      line: t,
      handle: e,
      text: e.text,
      gutterMarkers: e.gutterMarkers,
      textClass: e.textClass,
      bgClass: e.bgClass,
      wrapClass: e.wrapClass,
      widgets: e.widgets
    };
  },
  addLineClass: Jt(function(e, t, r) {
    return rf(this, e, t == "gutter" ? "gutter" : "class", (n) => {
      let o = t == "text" ? "textClass" : t == "background" ? "bgClass" : t == "gutter" ? "gutterClass" : "wrapClass";
      if (!n[o])
        n[o] = r;
      else {
        if (Zl(r).test(n[o]))
          return !1;
        n[o] += " " + r;
      }
      return !0;
    });
  }),
  removeLineClass: Jt(function(e, t, r) {
    return rf(this, e, t == "gutter" ? "gutter" : "class", (n) => {
      let o = t == "text" ? "textClass" : t == "background" ? "bgClass" : t == "gutter" ? "gutterClass" : "wrapClass", s = n[o];
      if (s)
        if (r == null)
          n[o] = null;
        else {
          let a = s.match(Zl(r));
          if (!a)
            return !1;
          let l = a.index + a[0].length;
          n[o] = s.slice(0, a.index) + (!a.index || l == s.length ? "" : " ") + s.slice(l) || null;
        }
      else
        return !1;
      return !0;
    });
  }),
  addLineWidget: Jt(function(e, t, r) {
    return Hde(this, e, t, r);
  }),
  removeLineWidget: function(e) {
    e.clear();
  },
  markText: function(e, t, r) {
    return iu(this, Ke(this, e), Ke(this, t), r, r && r.type || "range");
  },
  setBookmark: function(e, t) {
    let r = {
      replacedWith: t && (t.nodeType == null ? t.widget : t),
      insertLeft: t && t.insertLeft,
      clearWhenEmpty: !1,
      shared: t && t.shared,
      handleMouseEvents: t && t.handleMouseEvents
    };
    return e = Ke(this, e), iu(this, e, e, r, "bookmark");
  },
  findMarksAt: function(e) {
    e = Ke(this, e);
    let t = [], r = je(this, e.line).markedSpans;
    if (r)
      for (let n = 0; n < r.length; ++n) {
        let o = r[n];
        (o.from == null || o.from <= e.ch) && (o.to == null || o.to >= e.ch) && t.push(o.marker.parent || o.marker);
      }
    return t;
  },
  findMarks: function(e, t, r) {
    e = Ke(this, e), t = Ke(this, t);
    let n = [], o = e.line;
    return this.iter(e.line, t.line + 1, (s) => {
      let a = s.markedSpans;
      if (a)
        for (let l = 0; l < a.length; l++) {
          let u = a[l];
          !(u.to != null && o == e.line && e.ch >= u.to || u.from == null && o != e.line || u.from != null && o == t.line && u.from >= t.ch) && (!r || r(u.marker)) && n.push(u.marker.parent || u.marker);
        }
      ++o;
    }), n;
  },
  getAllMarks: function() {
    let e = [];
    return this.iter((t) => {
      let r = t.markedSpans;
      if (r)
        for (let n = 0; n < r.length; ++n)
          r[n].from != null && e.push(r[n].marker);
    }), e;
  },
  posFromIndex: function(e) {
    let t, r = this.first, n = this.lineSeparator().length;
    return this.iter((o) => {
      let s = o.text.length + n;
      if (s > e)
        return t = e, !0;
      e -= s, ++r;
    }), Ke(this, Se(r, t));
  },
  indexFromPos: function(e) {
    e = Ke(this, e);
    let t = e.ch;
    if (e.line < this.first || e.ch < 0)
      return 0;
    let r = this.lineSeparator().length;
    return this.iter(this.first, e.line, (n) => {
      t += n.text.length + r;
    }), t;
  },
  copy: function(e) {
    let t = new Qi(S0(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
    return t.scrollTop = this.scrollTop, t.scrollLeft = this.scrollLeft, t.sel = this.sel, t.extend = !1, e && (t.history.undoDepth = this.history.undoDepth, t.setHistory(this.getHistory())), t;
  },
  linkedDoc: function(e) {
    e || (e = {});
    let t = this.first, r = this.first + this.size;
    e.from != null && e.from > t && (t = e.from), e.to != null && e.to < r && (r = e.to);
    let n = new Qi(S0(this, t, r), e.mode || this.modeOption, t, this.lineSep, this.direction);
    return e.sharedHist && (n.history = this.history), (this.linked || (this.linked = [])).push({ doc: n, sharedHist: e.sharedHist }), n.linked = [{ doc: this, isParent: !0, sharedHist: e.sharedHist }], Gde(n, h2(this)), n;
  },
  unlinkDoc: function(e) {
    if (e instanceof _he && (e = e.doc), this.linked) {
      for (let t = 0; t < this.linked.length; ++t)
        if (this.linked[t].doc == e) {
          this.linked.splice(t, 1), e.unlinkDoc(this), Vde(h2(this));
          break;
        }
    }
    if (e.history == this.history) {
      let t = [e.id];
      ts(e, (r) => t.push(r.id), !0), e.history = new Vd(null), e.history.done = cl(this.history.done, t), e.history.undone = cl(this.history.undone, t);
    }
  },
  iterLinkedDocs: function(e) {
    ts(this, e);
  },
  getMode: function() {
    return this.mode;
  },
  getEditor: function() {
    return this.cm;
  },
  splitLines: function(e) {
    return this.lineSep ? e.split(this.lineSep) : sR(e);
  },
  lineSeparator: function() {
    return this.lineSep || `
`;
  },
  setDirection: Jt(function(e) {
    e != "rtl" && (e = "ltr"), e != this.direction && (this.direction = e, this.iter((t) => t.order = null), this.cm && Pde(this.cm));
  })
});
Qi.prototype.eachLine = Qi.prototype.iter;
var ma = Qi, gB = 0;
function Yde(e) {
  let t = this;
  if (bB(t), Qt(t, e) || vo(t.display, e))
    return;
  Br(e), ct && (gB = +/* @__PURE__ */ new Date());
  let r = Ia(t, e, !0), n = e.dataTransfer.files;
  if (!(!r || t.isReadOnly()))
    if (n && n.length && window.FileReader && window.File) {
      let o = n.length, s = Array(o), a = 0;
      const l = () => {
        ++a == o && tr(t, () => {
          r = Ke(t.doc, r);
          let f = {
            from: r,
            to: r,
            text: t.doc.splitLines(s.filter((c) => c != null).join(t.doc.lineSeparator())),
            origin: "paste"
          };
          nu(t.doc, f), aB(t.doc, ds(Ke(t.doc, r), Ke(t.doc, hs(f))));
        })();
      }, u = (f, c) => {
        if (t.options.allowDropFileTypes && mr(t.options.allowDropFileTypes, f.type) == -1) {
          l();
          return;
        }
        let d = new FileReader();
        d.onerror = () => l(), d.onload = () => {
          let h = d.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(h)) {
            l();
            return;
          }
          s[c] = h, l();
        }, d.readAsText(f);
      };
      for (let f = 0; f < n.length; f++)
        u(n[f], f);
    } else {
      if (t.state.draggingText && t.doc.sel.contains(r) > -1) {
        t.state.draggingText(e), setTimeout(() => t.display.input.focus(), 20);
        return;
      }
      try {
        let o = e.dataTransfer.getData("Text");
        if (o) {
          let s;
          if (t.state.draggingText && !t.state.draggingText.copy && (s = t.listSelections()), Og(t.doc, ds(r, r)), s)
            for (let a = 0; a < s.length; ++a)
              Ru(t.doc, "", s[a].anchor, s[a].head, "drag");
          t.replaceSelection(o, "around", "paste"), t.display.input.focus();
        }
      } catch {
      }
    }
}
function Xde(e, t) {
  if (ct && (!e.state.draggingText || +/* @__PURE__ */ new Date() - gB < 100)) {
    Xf(t);
    return;
  }
  if (!(Qt(e, t) || vo(e.display, t)) && (t.dataTransfer.setData("Text", e.getSelection()), t.dataTransfer.effectAllowed = "copyMove", t.dataTransfer.setDragImage && !_g)) {
    let r = Ue("img", null, null, "position: fixed; left: 0; top: 0;");
    r.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", Jn && (r.width = r.height = 1, e.display.wrapper.appendChild(r), r._top = r.offsetTop), t.dataTransfer.setDragImage(r, 0, 0), Jn && r.parentNode.removeChild(r);
  }
}
function Jde(e, t) {
  let r = Ia(e, t);
  if (!r)
    return;
  let n = document.createDocumentFragment();
  Hj(e, r, n), e.display.dragCursor || (e.display.dragCursor = Ue("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), e.display.lineSpace.insertBefore(e.display.dragCursor, e.display.cursorDiv)), hn(e.display.dragCursor, n);
}
function bB(e) {
  e.display.dragCursor && (e.display.lineSpace.removeChild(e.display.dragCursor), e.display.dragCursor = null);
}
function p2(e) {
  if (!document.getElementsByClassName)
    return;
  let t = document.getElementsByClassName("CodeMirror"), r = [];
  for (let n = 0; n < t.length; n++) {
    let o = t[n].CodeMirror;
    o && r.push(o);
  }
  r.length && r[0].operation(() => {
    for (let n = 0; n < r.length; n++)
      e(r[n]);
  });
}
var g2 = !1;
function Qde() {
  g2 || (Zde(), g2 = !0);
}
function Zde() {
  let e;
  He(window, "resize", () => {
    e == null && (e = setTimeout(() => {
      e = null, p2(ehe);
    }, 100));
  }), He(window, "blur", () => p2(Eu));
}
function ehe(e) {
  let t = e.display;
  t.cachedCharWidth = t.cachedTextHeight = t.cachedPaddingH = null, t.scrollbarsClipped = !1, e.setSize();
}
var ps = {
  3: "Pause",
  8: "Backspace",
  9: "Tab",
  13: "Enter",
  16: "Shift",
  17: "Ctrl",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Esc",
  32: "Space",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "Left",
  38: "Up",
  39: "Right",
  40: "Down",
  44: "PrintScrn",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Mod",
  92: "Mod",
  93: "Mod",
  106: "*",
  107: "=",
  109: "-",
  110: ".",
  111: "/",
  145: "ScrollLock",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  224: "Mod",
  63232: "Up",
  63233: "Down",
  63234: "Left",
  63235: "Right",
  63272: "Delete",
  63273: "Home",
  63275: "End",
  63276: "PageUp",
  63277: "PageDown",
  63302: "Insert"
};
for (let e = 0; e < 10; e++)
  ps[e + 48] = ps[e + 96] = String(e);
for (let e = 65; e <= 90; e++)
  ps[e] = String.fromCharCode(e);
for (let e = 1; e <= 12; e++)
  ps[e + 111] = ps[e + 63235] = "F" + e;
var no = {};
no.basic = {
  Left: "goCharLeft",
  Right: "goCharRight",
  Up: "goLineUp",
  Down: "goLineDown",
  End: "goLineEnd",
  Home: "goLineStartSmart",
  PageUp: "goPageUp",
  PageDown: "goPageDown",
  Delete: "delCharAfter",
  Backspace: "delCharBefore",
  "Shift-Backspace": "delCharBefore",
  Tab: "defaultTab",
  "Shift-Tab": "indentAuto",
  Enter: "newlineAndIndent",
  Insert: "toggleOverwrite",
  Esc: "singleSelection"
};
no.pcDefault = {
  "Ctrl-A": "selectAll",
  "Ctrl-D": "deleteLine",
  "Ctrl-Z": "undo",
  "Shift-Ctrl-Z": "redo",
  "Ctrl-Y": "redo",
  "Ctrl-Home": "goDocStart",
  "Ctrl-End": "goDocEnd",
  "Ctrl-Up": "goLineUp",
  "Ctrl-Down": "goLineDown",
  "Ctrl-Left": "goGroupLeft",
  "Ctrl-Right": "goGroupRight",
  "Alt-Left": "goLineStart",
  "Alt-Right": "goLineEnd",
  "Ctrl-Backspace": "delGroupBefore",
  "Ctrl-Delete": "delGroupAfter",
  "Ctrl-S": "save",
  "Ctrl-F": "find",
  "Ctrl-G": "findNext",
  "Shift-Ctrl-G": "findPrev",
  "Shift-Ctrl-F": "replace",
  "Shift-Ctrl-R": "replaceAll",
  "Ctrl-[": "indentLess",
  "Ctrl-]": "indentMore",
  "Ctrl-U": "undoSelection",
  "Shift-Ctrl-U": "redoSelection",
  "Alt-U": "redoSelection",
  fallthrough: "basic"
};
no.emacsy = {
  "Ctrl-F": "goCharRight",
  "Ctrl-B": "goCharLeft",
  "Ctrl-P": "goLineUp",
  "Ctrl-N": "goLineDown",
  "Ctrl-A": "goLineStart",
  "Ctrl-E": "goLineEnd",
  "Ctrl-V": "goPageDown",
  "Shift-Ctrl-V": "goPageUp",
  "Ctrl-D": "delCharAfter",
  "Ctrl-H": "delCharBefore",
  "Alt-Backspace": "delWordBefore",
  "Ctrl-K": "killLine",
  "Ctrl-T": "transposeChars",
  "Ctrl-O": "openLine"
};
no.macDefault = {
  "Cmd-A": "selectAll",
  "Cmd-D": "deleteLine",
  "Cmd-Z": "undo",
  "Shift-Cmd-Z": "redo",
  "Cmd-Y": "redo",
  "Cmd-Home": "goDocStart",
  "Cmd-Up": "goDocStart",
  "Cmd-End": "goDocEnd",
  "Cmd-Down": "goDocEnd",
  "Alt-Left": "goGroupLeft",
  "Alt-Right": "goGroupRight",
  "Cmd-Left": "goLineLeft",
  "Cmd-Right": "goLineRight",
  "Alt-Backspace": "delGroupBefore",
  "Ctrl-Alt-Backspace": "delGroupAfter",
  "Alt-Delete": "delGroupAfter",
  "Cmd-S": "save",
  "Cmd-F": "find",
  "Cmd-G": "findNext",
  "Shift-Cmd-G": "findPrev",
  "Cmd-Alt-F": "replace",
  "Shift-Cmd-Alt-F": "replaceAll",
  "Cmd-[": "indentLess",
  "Cmd-]": "indentMore",
  "Cmd-Backspace": "delWrappedLineLeft",
  "Cmd-Delete": "delWrappedLineRight",
  "Cmd-U": "undoSelection",
  "Shift-Cmd-U": "redoSelection",
  "Ctrl-Up": "goDocStart",
  "Ctrl-Down": "goDocEnd",
  fallthrough: ["basic", "emacsy"]
};
no.default = Rn ? no.macDefault : no.pcDefault;
function the(e) {
  let t = e.split(/-(?!$)/);
  e = t[t.length - 1];
  let r, n, o, s;
  for (let a = 0; a < t.length - 1; a++) {
    let l = t[a];
    if (/^(cmd|meta|m)$/i.test(l))
      s = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      n = !0;
    else if (/^s(hift)?$/i.test(l))
      o = !0;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return r && (e = "Alt-" + e), n && (e = "Ctrl-" + e), s && (e = "Cmd-" + e), o && (e = "Shift-" + e), e;
}
function rhe(e) {
  let t = {};
  for (let r in e)
    if (e.hasOwnProperty(r)) {
      let n = e[r];
      if (/^(name|fallthrough|(de|at)tach)$/.test(r))
        continue;
      if (n == "...") {
        delete e[r];
        continue;
      }
      let o = xg(r.split(" "), the);
      for (let s = 0; s < o.length; s++) {
        let a, l;
        s == o.length - 1 ? (l = o.join(" "), a = n) : (l = o.slice(0, s + 1).join(" "), a = "...");
        let u = t[l];
        if (!u)
          t[l] = a;
        else if (u != a)
          throw new Error("Inconsistent bindings for " + l);
      }
      delete e[r];
    }
  for (let r in t)
    e[r] = t[r];
  return e;
}
function jl(e, t, r, n) {
  t = Bh(t);
  let o = t.call ? t.call(e, n) : t[e];
  if (o === !1)
    return "nothing";
  if (o === "...")
    return "multi";
  if (o != null && r(o))
    return "handled";
  if (t.fallthrough) {
    if (Object.prototype.toString.call(t.fallthrough) != "[object Array]")
      return jl(e, t.fallthrough, r, n);
    for (let s = 0; s < t.fallthrough.length; s++) {
      let a = jl(e, t.fallthrough[s], r, n);
      if (a)
        return a;
    }
  }
}
function yB(e) {
  let t = typeof e == "string" ? e : ps[e.keyCode];
  return t == "Ctrl" || t == "Alt" || t == "Shift" || t == "Mod";
}
function mB(e, t, r) {
  let n = e;
  return t.altKey && n != "Alt" && (e = "Alt-" + e), (PI ? t.metaKey : t.ctrlKey) && n != "Ctrl" && (e = "Ctrl-" + e), (PI ? t.ctrlKey : t.metaKey) && n != "Mod" && (e = "Cmd-" + e), !r && t.shiftKey && n != "Shift" && (e = "Shift-" + e), e;
}
function vB(e, t) {
  if (Jn && e.keyCode == 34 && e.char)
    return !1;
  let r = ps[e.keyCode];
  return r == null || e.altGraphKey ? !1 : (e.keyCode == 3 && e.code && (r = e.code), mB(r, e, t));
}
function Bh(e) {
  return typeof e == "string" ? no[e] : e;
}
function _l(e, t) {
  let r = e.doc.sel.ranges, n = [];
  for (let o = 0; o < r.length; o++) {
    let s = t(r[o]);
    for (; n.length && Ye(s.from, yt(n).to) <= 0; ) {
      let a = n.pop();
      if (Ye(a.from, s.from) < 0) {
        s.from = a.from;
        break;
      }
    }
    n.push(s);
  }
  en(e, () => {
    for (let o = n.length - 1; o >= 0; o--)
      Ru(e.doc, "", n[o].from, n[o].to, "+delete");
    xu(e);
  });
}
function BR(e, t, r) {
  let n = uj(e.text, t + r, r);
  return n < 0 || n > e.text.length ? null : n;
}
function rE(e, t, r) {
  let n = BR(e, t.ch, r);
  return n == null ? null : new Se(t.line, n, r < 0 ? "after" : "before");
}
function qR(e, t, r, n, o) {
  if (e) {
    t.doc.direction == "rtl" && (o = -o);
    let s = $o(r, t.doc.direction);
    if (s) {
      let a = o < 0 ? yt(s) : s[0], u = o < 0 == (a.level == 1) ? "after" : "before", f;
      if (a.level > 0 || t.doc.direction == "rtl") {
        let c = _u(t, r);
        f = o < 0 ? r.text.length - 1 : 0;
        let d = Oi(t, c, f).top;
        f = Kf((h) => Oi(t, c, h).top == d, o < 0 == (a.level == 1) ? a.from : a.to - 1, f), u == "before" && (f = BR(r, f, 1));
      } else
        f = o < 0 ? a.to : a.from;
      return new Se(n, f, u);
    }
  }
  return new Se(n, o < 0 ? r.text.length : 0, o < 0 ? "before" : "after");
}
function nhe(e, t, r, n) {
  let o = $o(t, e.doc.direction);
  if (!o)
    return rE(t, r, n);
  r.ch >= t.text.length ? (r.ch = t.text.length, r.sticky = "before") : r.ch <= 0 && (r.ch = 0, r.sticky = "after");
  let s = Yf(o, r.ch, r.sticky), a = o[s];
  if (e.doc.direction == "ltr" && a.level % 2 == 0 && (n > 0 ? a.to > r.ch : a.from < r.ch))
    return rE(t, r, n);
  let l = (m, y) => BR(t, m instanceof Se ? m.ch : m, y), u, f = (m) => e.options.lineWrapping ? (u = u || _u(e, t), qj(e, t, u, m)) : { begin: 0, end: t.text.length }, c = f(r.sticky == "before" ? l(r, -1) : r.ch);
  if (e.doc.direction == "rtl" || a.level == 1) {
    let m = a.level == 1 == n < 0, y = l(r, m ? 1 : -1);
    if (y != null && (m ? y <= a.to && y <= c.end : y >= a.from && y >= c.begin)) {
      let _ = m ? "before" : "after";
      return new Se(r.line, y, _);
    }
  }
  let d = (m, y, _) => {
    let S = (x, E) => E ? new Se(r.line, l(x, 1), "before") : new Se(r.line, x, "after");
    for (; m >= 0 && m < o.length; m += y) {
      let x = o[m], E = y > 0 == (x.level != 1), C = E ? _.begin : l(_.end, -1);
      if (x.from <= C && C < x.to || (C = E ? x.from : l(x.to, -1), _.begin <= C && C < _.end))
        return S(C, E);
    }
  }, h = d(s + n, n, c);
  if (h)
    return h;
  let p = n > 0 ? c.end : l(c.begin, -1);
  return p != null && !(n > 0 && p == t.text.length) && (h = d(n > 0 ? 0 : o.length - 1, n, f(p)), h) ? h : null;
}
var oc = {
  selectAll: cB,
  singleSelection: (e) => e.setSelection(e.getCursor("anchor"), e.getCursor("head"), Ii),
  killLine: (e) => _l(e, (t) => {
    if (t.empty()) {
      let r = je(e.doc, t.head.line).text.length;
      return t.head.ch == r && t.head.line < e.lastLine() ? { from: t.head, to: Se(t.head.line + 1, 0) } : { from: t.head, to: Se(t.head.line, r) };
    } else
      return { from: t.from(), to: t.to() };
  }),
  deleteLine: (e) => _l(e, (t) => ({
    from: Se(t.from().line, 0),
    to: Ke(e.doc, Se(t.to().line + 1, 0))
  })),
  delLineLeft: (e) => _l(e, (t) => ({
    from: Se(t.from().line, 0),
    to: t.from()
  })),
  delWrappedLineLeft: (e) => _l(e, (t) => {
    let r = e.charCoords(t.head, "div").top + 5;
    return { from: e.coordsChar({ left: 0, top: r }, "div"), to: t.from() };
  }),
  delWrappedLineRight: (e) => _l(e, (t) => {
    let r = e.charCoords(t.head, "div").top + 5, n = e.coordsChar({ left: e.display.lineDiv.offsetWidth + 100, top: r }, "div");
    return { from: t.from(), to: n };
  }),
  undo: (e) => e.undo(),
  redo: (e) => e.redo(),
  undoSelection: (e) => e.undoSelection(),
  redoSelection: (e) => e.redoSelection(),
  goDocStart: (e) => e.extendSelection(Se(e.firstLine(), 0)),
  goDocEnd: (e) => e.extendSelection(Se(e.lastLine())),
  goLineStart: (e) => e.extendSelectionsBy((t) => wB(e, t.head.line), { origin: "+move", bias: 1 }),
  goLineStartSmart: (e) => e.extendSelectionsBy((t) => b2(e, t.head), { origin: "+move", bias: 1 }),
  goLineEnd: (e) => e.extendSelectionsBy((t) => ihe(e, t.head.line), { origin: "+move", bias: -1 }),
  goLineRight: (e) => e.extendSelectionsBy((t) => {
    let r = e.cursorCoords(t.head, "div").top + 5;
    return e.coordsChar({ left: e.display.lineDiv.offsetWidth + 100, top: r }, "div");
  }, Rf),
  goLineLeft: (e) => e.extendSelectionsBy((t) => {
    let r = e.cursorCoords(t.head, "div").top + 5;
    return e.coordsChar({ left: 0, top: r }, "div");
  }, Rf),
  goLineLeftSmart: (e) => e.extendSelectionsBy((t) => {
    let r = e.cursorCoords(t.head, "div").top + 5, n = e.coordsChar({ left: 0, top: r }, "div");
    return n.ch < e.getLine(n.line).search(/\S/) ? b2(e, t.head) : n;
  }, Rf),
  goLineUp: (e) => e.moveV(-1, "line"),
  goLineDown: (e) => e.moveV(1, "line"),
  goPageUp: (e) => e.moveV(-1, "page"),
  goPageDown: (e) => e.moveV(1, "page"),
  goCharLeft: (e) => e.moveH(-1, "char"),
  goCharRight: (e) => e.moveH(1, "char"),
  goColumnLeft: (e) => e.moveH(-1, "column"),
  goColumnRight: (e) => e.moveH(1, "column"),
  goWordLeft: (e) => e.moveH(-1, "word"),
  goGroupRight: (e) => e.moveH(1, "group"),
  goGroupLeft: (e) => e.moveH(-1, "group"),
  goWordRight: (e) => e.moveH(1, "word"),
  delCharBefore: (e) => e.deleteH(-1, "codepoint"),
  delCharAfter: (e) => e.deleteH(1, "char"),
  delWordBefore: (e) => e.deleteH(-1, "word"),
  delWordAfter: (e) => e.deleteH(1, "word"),
  delGroupBefore: (e) => e.deleteH(-1, "group"),
  delGroupAfter: (e) => e.deleteH(1, "group"),
  indentAuto: (e) => e.indentSelection("smart"),
  indentMore: (e) => e.indentSelection("add"),
  indentLess: (e) => e.indentSelection("subtract"),
  insertTab: (e) => e.replaceSelection("	"),
  insertSoftTab: (e) => {
    let t = [], r = e.listSelections(), n = e.options.tabSize;
    for (let o = 0; o < r.length; o++) {
      let s = r[o].from(), a = _n(e.getLine(s.line), s.ch, n);
      t.push(nR(n - a % n));
    }
    e.replaceSelections(t);
  },
  defaultTab: (e) => {
    e.somethingSelected() ? e.indentSelection("add") : e.execCommand("insertTab");
  },
  transposeChars: (e) => en(e, () => {
    let t = e.listSelections(), r = [];
    for (let n = 0; n < t.length; n++) {
      if (!t[n].empty())
        continue;
      let o = t[n].head, s = je(e.doc, o.line).text;
      if (s) {
        if (o.ch == s.length && (o = new Se(o.line, o.ch - 1)), o.ch > 0)
          o = new Se(o.line, o.ch + 1), e.replaceRange(s.charAt(o.ch - 1) + s.charAt(o.ch - 2), Se(o.line, o.ch - 2), o, "+transpose");
        else if (o.line > e.doc.first) {
          let a = je(e.doc, o.line - 1).text;
          a && (o = new Se(o.line, 1), e.replaceRange(s.charAt(0) + e.doc.lineSeparator() + a.charAt(a.length - 1), Se(o.line - 1, a.length - 1), o, "+transpose"));
        }
      }
      r.push(new wt(o, o));
    }
    e.setSelections(r);
  }),
  newlineAndIndent: (e) => en(e, () => {
    let t = e.listSelections();
    for (let r = t.length - 1; r >= 0; r--)
      e.replaceRange(e.doc.lineSeparator(), t[r].anchor, t[r].head, "+input");
    t = e.listSelections();
    for (let r = 0; r < t.length; r++)
      e.indentLine(t[r].from().line, null, !0);
    xu(e);
  }),
  openLine: (e) => e.replaceSelection(`
`, "start"),
  toggleOverwrite: (e) => e.toggleOverwrite()
};
function wB(e, t) {
  let r = je(e.doc, t), n = Ni(r);
  return n != r && (t = mt(n)), qR(!0, e, n, t, 1);
}
function ihe(e, t) {
  let r = je(e.doc, t), n = jce(r);
  return n != r && (t = mt(n)), qR(!0, e, r, t, -1);
}
function b2(e, t) {
  let r = wB(e, t.line), n = je(e.doc, r.line), o = $o(n, e.doc.direction);
  if (!o || o[0].level == 0) {
    let s = Math.max(r.ch, n.text.search(/\S/)), a = t.line == r.line && t.ch <= s && t.ch;
    return Se(r.line, a ? 0 : s, r.sticky);
  }
  return r;
}
function Kd(e, t, r) {
  if (typeof t == "string" && (t = oc[t], !t))
    return !1;
  e.display.input.ensurePolled();
  let n = e.display.shift, o = !1;
  try {
    e.isReadOnly() && (e.state.suppressEdits = !0), r && (e.display.shift = !1), o = t(e) != Eg;
  } finally {
    e.display.shift = n, e.state.suppressEdits = !1;
  }
  return o;
}
function ohe(e, t, r) {
  for (let n = 0; n < e.state.keyMaps.length; n++) {
    let o = jl(t, e.state.keyMaps[n], r, e);
    if (o)
      return o;
  }
  return e.options.extraKeys && jl(t, e.options.extraKeys, r, e) || jl(t, e.options.keyMap, r, e);
}
var she = new eu();
function Mf(e, t, r, n) {
  let o = e.state.keySeq;
  if (o) {
    if (yB(t))
      return "handled";
    if (/\'$/.test(t) ? e.state.keySeq = null : she.set(50, () => {
      e.state.keySeq == o && (e.state.keySeq = null, e.display.input.reset());
    }), y2(e, o + " " + t, r, n))
      return !0;
  }
  return y2(e, t, r, n);
}
function y2(e, t, r, n) {
  let o = ohe(e, t, n);
  return o == "multi" && (e.state.keySeq = t), o == "handled" && ir(e, "keyHandled", e, t, r), (o == "handled" || o == "multi") && (Br(r), RR(e)), !!o;
}
function _B(e, t) {
  let r = vB(t, !0);
  return r ? t.shiftKey && !e.state.keySeq ? Mf(e, "Shift-" + r, t, (n) => Kd(e, n, !0)) || Mf(e, r, t, (n) => {
    if (typeof n == "string" ? /^go[A-Z]/.test(n) : n.motion)
      return Kd(e, n);
  }) : Mf(e, r, t, (n) => Kd(e, n)) : !1;
}
function ahe(e, t, r) {
  return Mf(e, "'" + r + "'", t, (n) => Kd(e, n, !0));
}
var nE = null;
function SB(e) {
  let t = this;
  if (e.target && e.target != t.display.input.getField() || (t.curOp.focus = En(), Qt(t, e)))
    return;
  ct && kt < 11 && e.keyCode == 27 && (e.returnValue = !1);
  let r = e.keyCode;
  t.display.shift = r == 16 || e.shiftKey;
  let n = _B(t, e);
  Jn && (nE = n ? r : null, !n && r == 88 && !Sce && (Rn ? e.metaKey : e.ctrlKey) && t.replaceSelection("", null, "cut")), bo && !Rn && !n && r == 46 && e.shiftKey && !e.ctrlKey && document.execCommand && document.execCommand("cut"), r == 18 && !/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className) && lhe(t);
}
function lhe(e) {
  let t = e.display.lineDiv;
  el(t, "CodeMirror-crosshair");
  function r(n) {
    (n.keyCode == 18 || !n.altKey) && (Za(t, "CodeMirror-crosshair"), cn(document, "keyup", r), cn(document, "mouseover", r));
  }
  He(document, "keyup", r), He(document, "mouseover", r);
}
function EB(e) {
  e.keyCode == 16 && (this.doc.sel.shift = !1), Qt(this, e);
}
function xB(e) {
  let t = this;
  if (e.target && e.target != t.display.input.getField() || vo(t.display, e) || Qt(t, e) || e.ctrlKey && !e.altKey || Rn && e.metaKey)
    return;
  let r = e.keyCode, n = e.charCode;
  if (Jn && r == nE) {
    nE = null, Br(e);
    return;
  }
  if (Jn && (!e.which || e.which < 10) && _B(t, e))
    return;
  let o = String.fromCharCode(n ?? r);
  o != "\b" && (ahe(t, e, o) || t.display.input.onKeyPress(e));
}
var uhe = 400, m2 = class {
  constructor(e, t, r) {
    this.time = e, this.pos = t, this.button = r;
  }
  compare(e, t, r) {
    return this.time + uhe > e && Ye(t, this.pos) == 0 && r == this.button;
  }
}, Du, Fu;
function fhe(e, t) {
  let r = +/* @__PURE__ */ new Date();
  return Fu && Fu.compare(r, e, t) ? (Du = Fu = null, "triple") : Du && Du.compare(r, e, t) ? (Fu = new m2(r, e, t), Du = null, "double") : (Du = new m2(r, e, t), Fu = null, "single");
}
function RB(e) {
  let t = this, r = t.display;
  if (Qt(t, e) || r.activeTouch && r.input.supportsTouch())
    return;
  if (r.input.ensurePolled(), r.shift = e.shiftKey, vo(r, e)) {
    Tr || (r.scroller.draggable = !1, setTimeout(() => r.scroller.draggable = !0, 100));
    return;
  }
  if (iE(t, e))
    return;
  let n = Ia(t, e), o = hj(e), s = n ? fhe(n, o) : "single";
  window.focus(), o == 1 && t.state.selectingText && t.state.selectingText(e), !(n && che(t, o, n, s, e)) && (o == 1 ? n ? hhe(t, n, s, e) : oR(e) == r.scroller && Br(e) : o == 2 ? (n && Lg(t.doc, n), setTimeout(() => r.input.focus(), 20)) : o == 3 && (tR ? t.display.input.onContextMenu(e) : AR(t)));
}
function che(e, t, r, n, o) {
  let s = "Click";
  return n == "double" ? s = "Double" + s : n == "triple" && (s = "Triple" + s), s = (t == 1 ? "Left" : t == 2 ? "Middle" : "Right") + s, Mf(e, mB(s, o), o, (a) => {
    if (typeof a == "string" && (a = oc[a]), !a)
      return !1;
    let l = !1;
    try {
      e.isReadOnly() && (e.state.suppressEdits = !0), l = a(e, r) != Eg;
    } finally {
      e.state.suppressEdits = !1;
    }
    return l;
  });
}
function dhe(e, t, r) {
  let n = e.getOption("configureMouse"), o = n ? n(e, t, r) : {};
  if (o.unit == null) {
    let s = cce ? r.shiftKey && r.metaKey : r.altKey;
    o.unit = s ? "rectangle" : t == "single" ? "char" : t == "double" ? "word" : "line";
  }
  return (o.extend == null || e.doc.extend) && (o.extend = e.doc.extend || r.shiftKey), o.addNew == null && (o.addNew = Rn ? r.metaKey : r.ctrlKey), o.moveOnDrag == null && (o.moveOnDrag = !(Rn ? r.altKey : r.ctrlKey)), o;
}
function hhe(e, t, r, n) {
  ct ? setTimeout(rR(zj, e), 0) : e.curOp.focus = En();
  let o = dhe(e, r, n), s = e.doc.sel, a;
  e.options.dragDrop && mce && !e.isReadOnly() && r == "single" && (a = s.contains(t)) > -1 && (Ye((a = s.ranges[a]).from(), t) < 0 || t.xRel > 0) && (Ye(a.to(), t) > 0 || t.xRel < 0) ? phe(e, n, t, o) : ghe(e, n, t, o);
}
function phe(e, t, r, n) {
  let o = e.display, s = !1, a = tr(e, (f) => {
    Tr && (o.scroller.draggable = !1), e.state.draggingText = !1, e.state.delayingBlurEvent && (e.hasFocus() ? e.state.delayingBlurEvent = !1 : AR(e)), cn(o.wrapper.ownerDocument, "mouseup", a), cn(o.wrapper.ownerDocument, "mousemove", l), cn(o.scroller, "dragstart", u), cn(o.scroller, "drop", a), s || (Br(f), n.addNew || Lg(e.doc, r, null, null, n.extend), Tr && !_g || ct && kt == 9 ? setTimeout(() => {
      o.wrapper.ownerDocument.body.focus({ preventScroll: !0 }), o.input.focus();
    }, 20) : o.input.focus());
  }), l = function(f) {
    s = s || Math.abs(t.clientX - f.clientX) + Math.abs(t.clientY - f.clientY) >= 10;
  }, u = () => s = !0;
  Tr && (o.scroller.draggable = !0), e.state.draggingText = a, a.copy = !n.moveOnDrag, He(o.wrapper.ownerDocument, "mouseup", a), He(o.wrapper.ownerDocument, "mousemove", l), He(o.scroller, "dragstart", u), He(o.scroller, "drop", a), e.state.delayingBlurEvent = !0, setTimeout(() => o.input.focus(), 20), o.scroller.dragDrop && o.scroller.dragDrop();
}
function v2(e, t, r) {
  if (r == "char")
    return new wt(t, t);
  if (r == "word")
    return e.findWordAt(t);
  if (r == "line")
    return new wt(Se(t.line, 0), Ke(e.doc, Se(t.line + 1, 0)));
  let n = r(e, t);
  return new wt(n.from, n.to);
}
function ghe(e, t, r, n) {
  ct && AR(e);
  let o = e.display, s = e.doc;
  Br(t);
  let a, l, u = s.sel, f = u.ranges;
  if (n.addNew && !n.extend ? (l = s.sel.contains(r), l > -1 ? a = f[l] : a = new wt(r, r)) : (a = s.sel.primary(), l = s.sel.primIndex), n.unit == "rectangle")
    n.addNew || (a = new wt(r, r)), r = Ia(e, t, !0, !0), l = -1;
  else {
    let x = v2(e, r, n.unit);
    n.extend ? a = OR(a, x.anchor, x.head, n.extend) : a = x;
  }
  n.addNew ? l == -1 ? (l = f.length, hr(s, Vn(e, f.concat([a]), l), { scroll: !1, origin: "*mouse" })) : f.length > 1 && f[l].empty() && n.unit == "char" && !n.extend ? (hr(s, Vn(e, f.slice(0, l).concat(f.slice(l + 1)), 0), { scroll: !1, origin: "*mouse" }), u = s.sel) : PR(s, l, a, m0) : (l = 0, hr(s, new xs([a], 0), m0), u = s.sel);
  let c = r;
  function d(x) {
    if (Ye(c, x) != 0)
      if (c = x, n.unit == "rectangle") {
        let E = [], C = e.options.tabSize, I = _n(je(s, r.line).text, r.ch, C), j = _n(je(s, x.line).text, x.ch, C), J = Math.min(I, j), G = Math.max(I, j);
        for (let $ = Math.min(r.line, x.line), V = Math.min(e.lastLine(), Math.max(r.line, x.line)); $ <= V; $++) {
          let M = je(s, $).text, W = qS(M, J, C);
          J == G ? E.push(new wt(Se($, W), Se($, W))) : M.length > W && E.push(new wt(Se($, W), Se($, qS(M, G, C))));
        }
        E.length || E.push(new wt(r, r)), hr(s, Vn(e, u.ranges.slice(0, l).concat(E), l), { origin: "*mouse", scroll: !1 }), e.scrollIntoView(x);
      } else {
        let E = a, C = v2(e, x, n.unit), I = E.anchor, j;
        Ye(C.anchor, I) > 0 ? (j = C.head, I = Tg(E.from(), C.anchor)) : (j = C.anchor, I = Ag(E.to(), C.head));
        let J = u.ranges.slice(0);
        J[l] = bhe(e, new wt(Ke(s, I), j)), hr(s, Vn(e, J, l), m0);
      }
  }
  let h = o.wrapper.getBoundingClientRect(), p = 0;
  function m(x) {
    let E = ++p, C = Ia(e, x, !0, n.unit == "rectangle");
    if (C)
      if (Ye(C, c) != 0) {
        e.curOp.focus = En(), d(C);
        let I = Dh(o, s);
        (C.line >= I.to || C.line < I.from) && setTimeout(tr(e, () => {
          p == E && m(x);
        }), 150);
      } else {
        let I = x.clientY < h.top ? -20 : x.clientY > h.bottom ? 20 : 0;
        I && setTimeout(tr(e, () => {
          p == E && (o.scroller.scrollTop += I, m(x));
        }), 50);
      }
  }
  function y(x) {
    e.state.selectingText = !1, p = 1 / 0, x && (Br(x), o.input.focus()), cn(o.wrapper.ownerDocument, "mousemove", _), cn(o.wrapper.ownerDocument, "mouseup", S), s.history.lastSelOrigin = null;
  }
  let _ = tr(e, (x) => {
    x.buttons === 0 || !hj(x) ? y(x) : m(x);
  }), S = tr(e, y);
  e.state.selectingText = S, He(o.wrapper.ownerDocument, "mousemove", _), He(o.wrapper.ownerDocument, "mouseup", S);
}
function bhe(e, t) {
  let { anchor: r, head: n } = t, o = je(e.doc, r.line);
  if (Ye(r, n) == 0 && r.sticky == n.sticky)
    return t;
  let s = $o(o);
  if (!s)
    return t;
  let a = Yf(s, r.ch, r.sticky), l = s[a];
  if (l.from != r.ch && l.to != r.ch)
    return t;
  let u = a + (l.from == r.ch == (l.level != 1) ? 0 : 1);
  if (u == 0 || u == s.length)
    return t;
  let f;
  if (n.line != r.line)
    f = (n.line - r.line) * (e.doc.direction == "ltr" ? 1 : -1) > 0;
  else {
    let m = Yf(s, n.ch, n.sticky), y = m - a || (n.ch - r.ch) * (l.level == 1 ? -1 : 1);
    m == u - 1 || m == u ? f = y < 0 : f = y > 0;
  }
  let c = s[u + (f ? -1 : 0)], d = f == (c.level == 1), h = d ? c.from : c.to, p = d ? "after" : "before";
  return r.ch == h && r.sticky == p ? t : new wt(new Se(r.line, h, p), n);
}
function AB(e, t, r, n) {
  let o, s;
  if (t.touches)
    o = t.touches[0].clientX, s = t.touches[0].clientY;
  else
    try {
      o = t.clientX, s = t.clientY;
    } catch {
      return !1;
    }
  if (o >= Math.floor(e.display.gutters.getBoundingClientRect().right))
    return !1;
  n && Br(t);
  let a = e.display, l = a.lineDiv.getBoundingClientRect();
  if (s > l.bottom || !An(e, r))
    return HS(t);
  s -= l.top - a.viewOffset;
  for (let u = 0; u < e.display.gutterSpecs.length; ++u) {
    let f = a.gutters.childNodes[u];
    if (f && f.getBoundingClientRect().right >= o) {
      let c = Zs(e.doc, s), d = e.display.gutterSpecs[u];
      return Ht(e, r, e, c, d.className, t), HS(t);
    }
  }
}
function iE(e, t) {
  return AB(e, t, "gutterClick", !0);
}
function w2(e, t) {
  vo(e.display, t) || yhe(e, t) || Qt(e, t, "contextmenu") || tR || e.display.input.onContextMenu(t);
}
function yhe(e, t) {
  return An(e, "gutterContextMenu") ? AB(e, t, "gutterContextMenu", !1) : !1;
}
function TB(e) {
  e.display.wrapper.className = e.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + e.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), rc(e);
}
var Al = { toString: function() {
  return "CodeMirror.Init";
} }, $B = {}, Yd = {};
function mhe(e) {
  let t = e.optionHandlers;
  function r(n, o, s, a) {
    e.defaults[n] = o, s && (t[n] = a ? (l, u, f) => {
      f != Al && s(l, u, f);
    } : s);
  }
  e.defineOption = r, e.Init = Al, r("value", "", (n, o) => n.setValue(o), !0), r("mode", null, (n, o) => {
    n.doc.modeOption = o, eE(n);
  }, !0), r("indentUnit", 2, eE, !0), r("indentWithTabs", !1), r("smartIndent", !0), r("tabSize", 4, (n) => {
    tf(n), rc(n), qr(n);
  }, !0), r("lineSeparator", null, (n, o) => {
    if (n.doc.lineSep = o, !o)
      return;
    let s = [], a = n.doc.first;
    n.doc.iter((l) => {
      for (let u = 0; ; ) {
        let f = l.text.indexOf(o, u);
        if (f == -1)
          break;
        u = f + o.length, s.push(Se(a, f));
      }
      a++;
    });
    for (let l = s.length - 1; l >= 0; l--)
      Ru(n.doc, o, s[l], Se(s[l].line, s[l].ch + o.length));
  }), r("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, (n, o, s) => {
    n.state.specialChars = new RegExp(o.source + (o.test("	") ? "" : "|	"), "g"), s != Al && n.refresh();
  }), r("specialCharPlaceholder", zce, (n) => n.refresh(), !0), r("electricChars", !0), r("inputStyle", Gf ? "contenteditable" : "textarea", () => {
    throw new Error("inputStyle can not (yet) be changed in a running editor");
  }, !0), r("spellcheck", !1, (n, o) => n.getInputField().spellcheck = o, !0), r("autocorrect", !1, (n, o) => n.getInputField().autocorrect = o, !0), r("autocapitalize", !1, (n, o) => n.getInputField().autocapitalize = o, !0), r("rtlMoveVisually", !dce), r("wholeLineUpdateBefore", !0), r("theme", "default", (n) => {
    TB(n), Pu(n);
  }, !0), r("keyMap", "default", (n, o, s) => {
    let a = Bh(o), l = s != Al && Bh(s);
    l && l.detach && l.detach(n, a), a.attach && a.attach(n, l || null);
  }), r("extraKeys", null), r("configureMouse", null), r("lineWrapping", !1, whe, !0), r("gutters", [], (n, o) => {
    n.display.gutterSpecs = ZS(o, n.options.lineNumbers), Pu(n);
  }, !0), r("fixedGutter", !0, (n, o) => {
    n.display.gutters.style.left = o ? ER(n.display) + "px" : "0", n.refresh();
  }, !0), r("coverGutterNextToScrollbar", !1, (n) => ru(n), !0), r("scrollbarStyle", "native", (n) => {
    Yj(n), ru(n), n.display.scrollbars.setScrollTop(n.doc.scrollTop), n.display.scrollbars.setScrollLeft(n.doc.scrollLeft);
  }, !0), r("lineNumbers", !1, (n, o) => {
    n.display.gutterSpecs = ZS(n.options.gutters, o), Pu(n);
  }, !0), r("firstLineNumber", 1, Pu, !0), r("lineNumberFormatter", (n) => n, Pu, !0), r("showCursorWhenSelecting", !1, $f, !0), r("resetSelectionOnContextMenu", !0), r("lineWiseCopyCut", !0), r("pasteLinesPerSelection", !0), r("selectionsMayTouch", !1), r("readOnly", !1, (n, o) => {
    o == "nocursor" && (Eu(n), n.display.input.blur()), n.display.input.readOnlyChanged(o);
  }), r("screenReaderLabel", null, (n, o) => {
    o = o === "" ? null : o, n.display.input.screenReaderLabelChanged(o);
  }), r("disableInput", !1, (n, o) => {
    o || n.display.input.reset();
  }, !0), r("dragDrop", !0, vhe), r("allowDropFileTypes", null), r("cursorBlinkRate", 530), r("cursorScrollMargin", 0), r("cursorHeight", 1, $f, !0), r("singleCursorHeightPerLine", !0, $f, !0), r("workTime", 100), r("workDelay", 100), r("flattenSpans", !0, tf, !0), r("addModeClass", !1, tf, !0), r("pollInterval", 100), r("undoDepth", 200, (n, o) => n.doc.history.undoDepth = o), r("historyEventDelay", 1250), r("viewportMargin", 10, (n) => n.refresh(), !0), r("maxHighlightLength", 1e4, tf, !0), r("moveInputWithCursor", !0, (n, o) => {
    o || n.display.input.resetPosition();
  }), r("tabindex", null, (n, o) => n.display.input.getField().tabIndex = o || ""), r("autofocus", null), r("direction", "ltr", (n, o) => n.doc.setDirection(o), !0), r("phrases", null);
}
function vhe(e, t, r) {
  let n = r && r != Al;
  if (!t != !n) {
    let o = e.display.dragFunctions, s = t ? He : cn;
    s(e.display.scroller, "dragstart", o.start), s(e.display.scroller, "dragenter", o.enter), s(e.display.scroller, "dragover", o.over), s(e.display.scroller, "dragleave", o.leave), s(e.display.scroller, "drop", o.drop);
  }
}
function whe(e) {
  e.options.lineWrapping ? (el(e.display.wrapper, "CodeMirror-wrap"), e.display.sizer.style.minWidth = "", e.display.sizerWidth = null) : (Za(e.display.wrapper, "CodeMirror-wrap"), gR(e)), xR(e), qr(e), rc(e), setTimeout(() => ru(e), 100);
}
function Mt(e, t) {
  if (!(this instanceof Mt))
    return new Mt(e, t);
  this.options = t = t ? ka(t) : {}, ka($B, t, !1);
  let r = t.value;
  typeof r == "string" ? r = new ma(r, t.mode, null, t.lineSeparator, t.direction) : t.mode && (r.modeOption = t.mode), this.doc = r;
  let n = new Mt.inputStyles[t.inputStyle](this), o = this.display = new Nde(e, r, n, t);
  o.wrapper.CodeMirror = this, TB(this), t.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), Yj(this), this.state = {
    keyMaps: [],
    overlays: [],
    modeGen: 0,
    overwrite: !1,
    delayingBlurEvent: !1,
    focused: !1,
    suppressEdits: !1,
    pasteIncoming: -1,
    cutIncoming: -1,
    selectingText: !1,
    draggingText: !1,
    highlight: new eu(),
    keySeq: null,
    specialChars: null
  }, t.autofocus && !Gf && o.input.focus(), ct && kt < 11 && setTimeout(() => this.display.input.reset(!0), 20), She(this), Qde(), nl(this), this.curOp.forceUpdate = !0, nB(this, r), t.autofocus && !Gf || this.hasFocus() ? setTimeout(() => {
    this.hasFocus() && !this.state.focused && TR(this);
  }, 20) : Eu(this);
  for (let s in Yd)
    Yd.hasOwnProperty(s) && Yd[s](this, t[s], Al);
  Zj(this), t.finishInit && t.finishInit(this);
  for (let s = 0; s < oE.length; ++s)
    oE[s](this);
  il(this), Tr && t.lineWrapping && getComputedStyle(o.lineDiv).textRendering == "optimizelegibility" && (o.lineDiv.style.textRendering = "auto");
}
Mt.defaults = $B;
Mt.optionHandlers = Yd;
var _he = Mt;
function She(e) {
  let t = e.display;
  He(t.scroller, "mousedown", tr(e, RB)), ct && kt < 11 ? He(t.scroller, "dblclick", tr(e, (u) => {
    if (Qt(e, u))
      return;
    let f = Ia(e, u);
    if (!f || iE(e, u) || vo(e.display, u))
      return;
    Br(u);
    let c = e.findWordAt(f);
    Lg(e.doc, c.anchor, c.head);
  })) : He(t.scroller, "dblclick", (u) => Qt(e, u) || Br(u)), He(t.scroller, "contextmenu", (u) => w2(e, u)), He(t.input.getField(), "contextmenu", (u) => {
    t.scroller.contains(u.target) || w2(e, u);
  });
  let r, n = { end: 0 };
  function o() {
    t.activeTouch && (r = setTimeout(() => t.activeTouch = null, 1e3), n = t.activeTouch, n.end = +/* @__PURE__ */ new Date());
  }
  function s(u) {
    if (u.touches.length != 1)
      return !1;
    let f = u.touches[0];
    return f.radiusX <= 1 && f.radiusY <= 1;
  }
  function a(u, f) {
    if (f.left == null)
      return !0;
    let c = f.left - u.left, d = f.top - u.top;
    return c * c + d * d > 20 * 20;
  }
  He(t.scroller, "touchstart", (u) => {
    if (!Qt(e, u) && !s(u) && !iE(e, u)) {
      t.input.ensurePolled(), clearTimeout(r);
      let f = +/* @__PURE__ */ new Date();
      t.activeTouch = {
        start: f,
        moved: !1,
        prev: f - n.end <= 300 ? n : null
      }, u.touches.length == 1 && (t.activeTouch.left = u.touches[0].pageX, t.activeTouch.top = u.touches[0].pageY);
    }
  }), He(t.scroller, "touchmove", () => {
    t.activeTouch && (t.activeTouch.moved = !0);
  }), He(t.scroller, "touchend", (u) => {
    let f = t.activeTouch;
    if (f && !vo(t, u) && f.left != null && !f.moved && /* @__PURE__ */ new Date() - f.start < 300) {
      let c = e.coordsChar(t.activeTouch, "page"), d;
      !f.prev || a(f, f.prev) ? d = new wt(c, c) : !f.prev.prev || a(f, f.prev.prev) ? d = e.findWordAt(c) : d = new wt(Se(c.line, 0), Ke(e.doc, Se(c.line + 1, 0))), e.setSelection(d.anchor, d.head), e.focus(), Br(u);
    }
    o();
  }), He(t.scroller, "touchcancel", o), He(t.scroller, "scroll", () => {
    t.scroller.clientHeight && (Cc(e, t.scroller.scrollTop), rl(e, t.scroller.scrollLeft, !0), Ht(e, "scroll", e));
  }), He(t.scroller, "mousewheel", (u) => e2(e, u)), He(t.scroller, "DOMMouseScroll", (u) => e2(e, u)), He(t.wrapper, "scroll", () => t.wrapper.scrollTop = t.wrapper.scrollLeft = 0), t.dragFunctions = {
    enter: (u) => {
      Qt(e, u) || Xf(u);
    },
    over: (u) => {
      Qt(e, u) || (Jde(e, u), Xf(u));
    },
    start: (u) => Xde(e, u),
    drop: tr(e, Yde),
    leave: (u) => {
      Qt(e, u) || bB(e);
    }
  };
  let l = t.input.getField();
  He(l, "keyup", (u) => EB.call(e, u)), He(l, "keydown", tr(e, SB)), He(l, "keypress", tr(e, xB)), He(l, "focus", (u) => TR(e, u)), He(l, "blur", (u) => Eu(e, u));
}
var oE = [];
Mt.defineInitHook = (e) => oE.push(e);
function Nf(e, t, r, n) {
  let o = e.doc, s;
  r == null && (r = "add"), r == "smart" && (o.mode.indent ? s = $c(e, t).state : r = "prev");
  let a = e.options.tabSize, l = je(o, t), u = _n(l.text, null, a);
  l.stateAfter && (l.stateAfter = null);
  let f = l.text.match(/^\s*/)[0], c;
  if (!n && !/\S/.test(l.text))
    c = 0, r = "not";
  else if (r == "smart" && (c = o.mode.indent(s, l.text.slice(f.length), l.text), c == Eg || c > 150)) {
    if (!n)
      return;
    r = "prev";
  }
  r == "prev" ? t > o.first ? c = _n(je(o, t - 1).text, null, a) : c = 0 : r == "add" ? c = u + e.options.indentUnit : r == "subtract" ? c = u - e.options.indentUnit : typeof r == "number" && (c = u + r), c = Math.max(0, c);
  let d = "", h = 0;
  if (e.options.indentWithTabs)
    for (let p = Math.floor(c / a); p; --p)
      h += a, d += "	";
  if (h < c && (d += nR(c - h)), d != f)
    return Ru(o, d, Se(t, 0), Se(t, f.length), "+input"), l.stateAfter = null, !0;
  for (let p = 0; p < o.sel.ranges.length; p++) {
    let m = o.sel.ranges[p];
    if (m.head.line == t && m.head.ch < f.length) {
      let y = Se(t, f.length);
      PR(o, p, new wt(y, y));
      break;
    }
  }
}
var qn = null;
function qh(e) {
  qn = e;
}
function WR(e, t, r, n, o) {
  let s = e.doc;
  e.display.shift = !1, n || (n = s.sel);
  let a = +/* @__PURE__ */ new Date() - 200, l = o == "paste" || e.state.pasteIncoming > a, u = sR(t), f = null;
  if (l && n.ranges.length > 1)
    if (qn && qn.text.join(`
`) == t) {
      if (n.ranges.length % qn.text.length == 0) {
        f = [];
        for (let d = 0; d < qn.text.length; d++)
          f.push(s.splitLines(qn.text[d]));
      }
    } else
      u.length == n.ranges.length && e.options.pasteLinesPerSelection && (f = xg(u, (d) => [d]));
  let c = e.curOp.updateInput;
  for (let d = n.ranges.length - 1; d >= 0; d--) {
    let h = n.ranges[d], p = h.from(), m = h.to();
    h.empty() && (r && r > 0 ? p = Se(p.line, p.ch - r) : e.state.overwrite && !l ? m = Se(m.line, Math.min(je(s, m.line).text.length, m.ch + yt(u).length)) : l && qn && qn.lineWise && qn.text.join(`
`) == u.join(`
`) && (p = m = Se(p.line, 0)));
    let y = {
      from: p,
      to: m,
      text: f ? f[d % f.length] : u,
      origin: o || (l ? "paste" : e.state.cutIncoming > a ? "cut" : "+input")
    };
    nu(e.doc, y), ir(e, "inputRead", e, y);
  }
  t && !l && kB(e, t), xu(e), e.curOp.updateInput < 2 && (e.curOp.updateInput = c), e.curOp.typing = !0, e.state.pasteIncoming = e.state.cutIncoming = -1;
}
function CB(e, t) {
  let r = e.clipboardData && e.clipboardData.getData("Text");
  if (r)
    return e.preventDefault(), !t.isReadOnly() && !t.options.disableInput && en(t, () => WR(t, r, 0, null, "paste")), !0;
}
function kB(e, t) {
  if (!e.options.electricChars || !e.options.smartIndent)
    return;
  let r = e.doc.sel;
  for (let n = r.ranges.length - 1; n >= 0; n--) {
    let o = r.ranges[n];
    if (o.head.ch > 100 || n && r.ranges[n - 1].head.line == o.head.line)
      continue;
    let s = e.getModeAt(o.head), a = !1;
    if (s.electricChars) {
      for (let l = 0; l < s.electricChars.length; l++)
        if (t.indexOf(s.electricChars.charAt(l)) > -1) {
          a = Nf(e, o.head.line, "smart");
          break;
        }
    } else
      s.electricInput && s.electricInput.test(je(e.doc, o.head.line).text.slice(0, o.head.ch)) && (a = Nf(e, o.head.line, "smart"));
    a && ir(e, "electricInput", e, o.head.line);
  }
}
function IB(e) {
  let t = [], r = [];
  for (let n = 0; n < e.doc.sel.ranges.length; n++) {
    let o = e.doc.sel.ranges[n].head.line, s = { anchor: Se(o, 0), head: Se(o + 1, 0) };
    r.push(s), t.push(e.getRange(s.anchor, s.head));
  }
  return { text: t, ranges: r };
}
function MB(e, t, r, n) {
  e.setAttribute("autocorrect", r ? "" : "off"), e.setAttribute("autocapitalize", n ? "" : "off"), e.setAttribute("spellcheck", !!t);
}
function NB() {
  let e = Ue("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"), t = Ue("div", [e], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
  return Tr ? e.style.width = "1000px" : e.setAttribute("wrap", "off"), Tc && (e.style.border = "1px solid black"), MB(e), t;
}
function Ehe(e) {
  let t = e.optionHandlers, r = e.helpers = {};
  e.prototype = {
    constructor: e,
    focus: function() {
      window.focus(), this.display.input.focus();
    },
    setOption: function(n, o) {
      let s = this.options, a = s[n];
      s[n] == o && n != "mode" || (s[n] = o, t.hasOwnProperty(n) && tr(this, t[n])(this, o, a), Ht(this, "optionChange", this, n));
    },
    getOption: function(n) {
      return this.options[n];
    },
    getDoc: function() {
      return this.doc;
    },
    addKeyMap: function(n, o) {
      this.state.keyMaps[o ? "push" : "unshift"](Bh(n));
    },
    removeKeyMap: function(n) {
      let o = this.state.keyMaps;
      for (let s = 0; s < o.length; ++s)
        if (o[s] == n || o[s].name == n)
          return o.splice(s, 1), !0;
    },
    addOverlay: Rr(function(n, o) {
      let s = n.token ? n : e.getMode(this.options, n);
      if (s.startState)
        throw new Error("Overlays may not be stateful.");
      hce(this.state.overlays, {
        mode: s,
        modeSpec: n,
        opaque: o && o.opaque,
        priority: o && o.priority || 0
      }, (a) => a.priority), this.state.modeGen++, qr(this);
    }),
    removeOverlay: Rr(function(n) {
      let o = this.state.overlays;
      for (let s = 0; s < o.length; ++s) {
        let a = o[s].modeSpec;
        if (a == n || typeof n == "string" && a.name == n) {
          o.splice(s, 1), this.state.modeGen++, qr(this);
          return;
        }
      }
    }),
    indentLine: Rr(function(n, o, s) {
      typeof o != "string" && typeof o != "number" && (o == null ? o = this.options.smartIndent ? "smart" : "prev" : o = o ? "add" : "subtract"), Jf(this.doc, n) && Nf(this, n, o, s);
    }),
    indentSelection: Rr(function(n) {
      let o = this.doc.sel.ranges, s = -1;
      for (let a = 0; a < o.length; a++) {
        let l = o[a];
        if (l.empty())
          l.head.line > s && (Nf(this, l.head.line, n, !0), s = l.head.line, a == this.doc.sel.primIndex && xu(this));
        else {
          let u = l.from(), f = l.to(), c = Math.max(s, u.line);
          s = Math.min(this.lastLine(), f.line - (f.ch ? 0 : 1)) + 1;
          for (let h = c; h < s; ++h)
            Nf(this, h, n);
          let d = this.doc.sel.ranges;
          u.ch == 0 && o.length == d.length && d[a].from().ch > 0 && PR(this.doc, a, new wt(u, d[a].to()), Ii);
        }
      }
    }),
    getTokenAt: function(n, o) {
      return qI(this, n, o);
    },
    getLineTokens: function(n, o) {
      return qI(this, Se(n), o, !0);
    },
    getTokenTypeAt: function(n) {
      n = Ke(this.doc, n);
      let o = yj(this, je(this.doc, n.line)), s = 0, a = (o.length - 1) / 2, l = n.ch, u;
      if (l == 0)
        u = o[2];
      else
        for (; ; ) {
          let c = s + a >> 1;
          if ((c ? o[c * 2 - 1] : 0) >= l)
            a = c;
          else if (o[c * 2 + 1] < l)
            s = c + 1;
          else {
            u = o[c * 2 + 2];
            break;
          }
        }
      let f = u ? u.indexOf("overlay ") : -1;
      return f < 0 ? u : f == 0 ? null : u.slice(0, f - 1);
    },
    getModeAt: function(n) {
      let o = this.doc.mode;
      return o.innerMode ? e.innerMode(o, this.getTokenAt(n).state).mode : o;
    },
    getHelper: function(n, o) {
      return this.getHelpers(n, o)[0];
    },
    getHelpers: function(n, o) {
      let s = [];
      if (!r.hasOwnProperty(o))
        return s;
      let a = r[o], l = this.getModeAt(n);
      if (typeof l[o] == "string")
        a[l[o]] && s.push(a[l[o]]);
      else if (l[o])
        for (let u = 0; u < l[o].length; u++) {
          let f = a[l[o][u]];
          f && s.push(f);
        }
      else
        l.helperType && a[l.helperType] ? s.push(a[l.helperType]) : a[l.name] && s.push(a[l.name]);
      for (let u = 0; u < a._global.length; u++) {
        let f = a._global[u];
        f.pred(l, this) && mr(s, f.val) == -1 && s.push(f.val);
      }
      return s;
    },
    getStateAfter: function(n, o) {
      let s = this.doc;
      return n = gj(s, n ?? s.first + s.size - 1), $c(this, n + 1, o).state;
    },
    cursorCoords: function(n, o) {
      let s, a = this.doc.sel.primary();
      return n == null ? s = a.head : typeof n == "object" ? s = Ke(this.doc, n) : s = n ? a.from() : a.to(), Gn(this, s, o || "page");
    },
    charCoords: function(n, o) {
      return YS(this, Ke(this.doc, n), o || "page");
    },
    coordsChar: function(n, o) {
      return n = YI(this, n, o || "page"), _R(this, n.left, n.top);
    },
    lineAtHeight: function(n, o) {
      return n = YI(this, { top: n, left: 0 }, o || "page").top, Zs(this.doc, n + this.display.viewOffset);
    },
    heightAtLine: function(n, o, s) {
      let a = !1, l;
      if (typeof n == "number") {
        let u = this.doc.first + this.doc.size - 1;
        n < this.doc.first ? n = this.doc.first : n > u && (n = u, a = !0), l = je(this.doc, n);
      } else
        l = n;
      return Ig(this, l, { top: 0, left: 0 }, o || "page", s || a).top + (a ? this.doc.height - mo(l) : 0);
    },
    defaultTextHeight: function() {
      return tu(this.display);
    },
    defaultCharWidth: function() {
      return Su(this.display);
    },
    getViewport: function() {
      return { from: this.display.viewFrom, to: this.display.viewTo };
    },
    addWidget: function(n, o, s, a, l) {
      let u = this.display;
      n = Gn(this, Ke(this.doc, n));
      let f = n.bottom, c = n.left;
      if (o.style.position = "absolute", o.setAttribute("cm-ignore-events", "true"), this.display.input.setUneditable(o), u.sizer.appendChild(o), a == "over")
        f = n.top;
      else if (a == "above" || a == "near") {
        let d = Math.max(u.wrapper.clientHeight, this.doc.height), h = Math.max(u.sizer.clientWidth, u.lineSpace.clientWidth);
        (a == "above" || n.bottom + o.offsetHeight > d) && n.top > o.offsetHeight ? f = n.top - o.offsetHeight : n.bottom + o.offsetHeight <= d && (f = n.bottom), c + o.offsetWidth > h && (c = h - o.offsetWidth);
      }
      o.style.top = f + "px", o.style.left = o.style.right = "", l == "right" ? (c = u.sizer.clientWidth - o.offsetWidth, o.style.right = "0px") : (l == "left" ? c = 0 : l == "middle" && (c = (u.sizer.clientWidth - o.offsetWidth) / 2), o.style.left = c + "px"), s && yde(this, { left: c, top: f, right: c + o.offsetWidth, bottom: f + o.offsetHeight });
    },
    triggerOnKeyDown: Rr(SB),
    triggerOnKeyPress: Rr(xB),
    triggerOnKeyUp: EB,
    triggerOnMouseDown: Rr(RB),
    execCommand: function(n) {
      if (oc.hasOwnProperty(n))
        return oc[n].call(null, this);
    },
    triggerElectric: Rr(function(n) {
      kB(this, n);
    }),
    findPosH: function(n, o, s, a) {
      let l = 1;
      o < 0 && (l = -1, o = -o);
      let u = Ke(this.doc, n);
      for (let f = 0; f < o && (u = E0(this.doc, u, l, s, a), !u.hitSide); ++f)
        ;
      return u;
    },
    moveH: Rr(function(n, o) {
      this.extendSelectionsBy((s) => this.display.shift || this.doc.extend || s.empty() ? E0(this.doc, s.head, n, o, this.options.rtlMoveVisually) : n < 0 ? s.from() : s.to(), Rf);
    }),
    deleteH: Rr(function(n, o) {
      let s = this.doc.sel, a = this.doc;
      s.somethingSelected() ? a.replaceSelection("", null, "+delete") : _l(this, (l) => {
        let u = E0(a, l.head, n, o, !1);
        return n < 0 ? { from: u, to: l.head } : { from: l.head, to: u };
      });
    }),
    findPosV: function(n, o, s, a) {
      let l = 1, u = a;
      o < 0 && (l = -1, o = -o);
      let f = Ke(this.doc, n);
      for (let c = 0; c < o; ++c) {
        let d = Gn(this, f, "div");
        if (u == null ? u = d.left : d.left = u, f = _2(this, d, l, s), f.hitSide)
          break;
      }
      return f;
    },
    moveV: Rr(function(n, o) {
      let s = this.doc, a = [], l = !this.display.shift && !s.extend && s.sel.somethingSelected();
      if (s.extendSelectionsBy((u) => {
        if (l)
          return n < 0 ? u.from() : u.to();
        let f = Gn(this, u.head, "div");
        u.goalColumn != null && (f.left = u.goalColumn), a.push(f.left);
        let c = _2(this, f, n, o);
        return o == "page" && u == s.sel.primary() && CR(this, YS(this, c, "div").top - f.top), c;
      }, Rf), a.length)
        for (let u = 0; u < s.sel.ranges.length; u++)
          s.sel.ranges[u].goalColumn = a[u];
    }),
    findWordAt: function(n) {
      let o = this.doc, s = je(o, n.line).text, a = n.ch, l = n.ch;
      if (s) {
        let u = this.getHelper(n, "wordChars");
        (n.sticky == "before" || l == s.length) && a ? --a : ++l;
        let f = s.charAt(a), c = zd(f, u) ? (d) => zd(d, u) : /\s/.test(f) ? (d) => /\s/.test(d) : (d) => !/\s/.test(d) && !zd(d);
        for (; a > 0 && c(s.charAt(a - 1)); )
          --a;
        for (; l < s.length && c(s.charAt(l)); )
          ++l;
      }
      return new wt(Se(n.line, a), Se(n.line, l));
    },
    toggleOverwrite: function(n) {
      n != null && n == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? el(this.display.cursorDiv, "CodeMirror-overwrite") : Za(this.display.cursorDiv, "CodeMirror-overwrite"), Ht(this, "overwriteToggle", this, this.state.overwrite));
    },
    hasFocus: function() {
      return this.display.input.getField() == En();
    },
    isReadOnly: function() {
      return !!(this.options.readOnly || this.doc.cantEdit);
    },
    scrollTo: Rr(function(n, o) {
      Cf(this, n, o);
    }),
    getScrollInfo: function() {
      let n = this.display.scroller;
      return {
        left: n.scrollLeft,
        top: n.scrollTop,
        height: n.scrollHeight - Li(this) - this.display.barHeight,
        width: n.scrollWidth - Li(this) - this.display.barWidth,
        clientHeight: mR(this),
        clientWidth: tl(this)
      };
    },
    scrollIntoView: Rr(function(n, o) {
      n == null ? (n = { from: this.doc.sel.primary().head, to: null }, o == null && (o = this.options.cursorScrollMargin)) : typeof n == "number" ? n = { from: Se(n, 0), to: null } : n.from == null && (n = { from: n, to: null }), n.to || (n.to = n.from), n.margin = o || 0, n.from.line != null ? mde(this, n) : Gj(this, n.from, n.to, n.margin);
    }),
    setSize: Rr(function(n, o) {
      let s = (l) => typeof l == "number" || /^\d+$/.test(String(l)) ? l + "px" : l;
      n != null && (this.display.wrapper.style.width = s(n)), o != null && (this.display.wrapper.style.height = s(o)), this.options.lineWrapping && Dj(this);
      let a = this.display.viewFrom;
      this.doc.iter(a, this.display.viewTo, (l) => {
        if (l.widgets) {
          for (let u = 0; u < l.widgets.length; u++)
            if (l.widgets[u].noHScroll) {
              Es(this, a, "widget");
              break;
            }
        }
        ++a;
      }), this.curOp.forceUpdate = !0, Ht(this, "refresh", this);
    }),
    operation: function(n) {
      return en(this, n);
    },
    startOperation: function() {
      return nl(this);
    },
    endOperation: function() {
      return il(this);
    },
    refresh: Rr(function() {
      let n = this.display.cachedTextHeight;
      qr(this), this.curOp.forceUpdate = !0, rc(this), Cf(this, this.doc.scrollLeft, this.doc.scrollTop), IR(this.display), (n == null || Math.abs(n - tu(this.display)) > 0.5 || this.options.lineWrapping) && xR(this), Ht(this, "refresh", this);
    }),
    swapDoc: Rr(function(n) {
      let o = this.doc;
      return o.cm = null, this.state.selectingText && this.state.selectingText(), nB(this, n), rc(this), this.display.input.reset(), Cf(this, n.scrollLeft, n.scrollTop), this.curOp.forceScroll = !0, ir(this, "swapDoc", this, o), o;
    }),
    phrase: function(n) {
      let o = this.options.phrases;
      return o && Object.prototype.hasOwnProperty.call(o, n) ? o[n] : n;
    },
    getInputField: function() {
      return this.display.input.getField();
    },
    getWrapperElement: function() {
      return this.display.wrapper;
    },
    getScrollerElement: function() {
      return this.display.scroller;
    },
    getGutterElement: function() {
      return this.display.gutters;
    }
  }, wu(e), e.registerHelper = function(n, o, s) {
    r.hasOwnProperty(n) || (r[n] = e[n] = { _global: [] }), r[n][o] = s;
  }, e.registerGlobalHelper = function(n, o, s, a) {
    e.registerHelper(n, o, a), r[n]._global.push({ pred: s, val: a });
  };
}
function E0(e, t, r, n, o) {
  let s = t, a = r, l = je(e, t.line), u = o && e.direction == "rtl" ? -r : r;
  function f() {
    let h = t.line + u;
    return h < e.first || h >= e.first + e.size ? !1 : (t = new Se(h, t.ch, t.sticky), l = je(e, h));
  }
  function c(h) {
    let p;
    if (n == "codepoint") {
      let m = l.text.charCodeAt(t.ch + (r > 0 ? 0 : -1));
      if (isNaN(m))
        p = null;
      else {
        let y = r > 0 ? m >= 55296 && m < 56320 : m >= 56320 && m < 57343;
        p = new Se(t.line, Math.max(0, Math.min(l.text.length, t.ch + r * (y ? 2 : 1))), -r);
      }
    } else
      o ? p = nhe(e.cm, l, t, r) : p = rE(l, t, r);
    if (p == null)
      if (!h && f())
        t = qR(o, e.cm, l, t.line, u);
      else
        return !1;
    else
      t = p;
    return !0;
  }
  if (n == "char" || n == "codepoint")
    c();
  else if (n == "column")
    c(!0);
  else if (n == "word" || n == "group") {
    let h = null, p = n == "group", m = e.cm && e.cm.getHelper(t, "wordChars");
    for (let y = !0; !(r < 0 && !c(!y)); y = !1) {
      let _ = l.text.charAt(t.ch) || `
`, S = zd(_, m) ? "w" : p && _ == `
` ? "n" : !p || /\s/.test(_) ? null : "p";
      if (p && !y && !S && (S = "s"), h && h != S) {
        r < 0 && (r = 1, c(), t.sticky = "after");
        break;
      }
      if (S && (h = S), r > 0 && !c(!y))
        break;
    }
  }
  let d = jh(e, t, s, a, !0);
  return zS(s, d) && (d.hitSide = !0), d;
}
function _2(e, t, r, n) {
  let o = e.doc, s = t.left, a;
  if (n == "page") {
    let u = Math.min(e.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight), f = Math.max(u - 0.5 * tu(e.display), 3);
    a = (r > 0 ? t.bottom : t.top) + r * f;
  } else
    n == "line" && (a = r > 0 ? t.bottom + 3 : t.top - 3);
  let l;
  for (; l = _R(e, s, a), !!l.outside; ) {
    if (r < 0 ? a <= 0 : a >= o.height) {
      l.hitSide = !0;
      break;
    }
    a += r * 5;
  }
  return l;
}
var LB = class {
  constructor(e) {
    this.cm = e, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, this.polling = new eu(), this.composing = null, this.gracePeriod = !1, this.readDOMTimeout = null;
  }
  init(e) {
    let t = this, r = t.cm, n = t.div = e.lineDiv;
    n.contentEditable = !0, MB(n, r.options.spellcheck, r.options.autocorrect, r.options.autocapitalize);
    function o(a) {
      for (let l = a.target; l; l = l.parentNode) {
        if (l == n)
          return !0;
        if (/\bCodeMirror-(?:line)?widget\b/.test(l.className))
          break;
      }
      return !1;
    }
    He(n, "paste", (a) => {
      !o(a) || Qt(r, a) || CB(a, r) || kt <= 11 && setTimeout(tr(r, () => this.updateFromDOM()), 20);
    }), He(n, "compositionstart", (a) => {
      this.composing = { data: a.data, done: !1 };
    }), He(n, "compositionupdate", (a) => {
      this.composing || (this.composing = { data: a.data, done: !1 });
    }), He(n, "compositionend", (a) => {
      this.composing && (a.data != this.composing.data && this.readFromDOMSoon(), this.composing.done = !0);
    }), He(n, "touchstart", () => t.forceCompositionEnd()), He(n, "input", () => {
      this.composing || this.readFromDOMSoon();
    });
    function s(a) {
      if (!o(a) || Qt(r, a))
        return;
      if (r.somethingSelected())
        qh({ lineWise: !1, text: r.getSelections() }), a.type == "cut" && r.replaceSelection("", null, "cut");
      else if (r.options.lineWiseCopyCut) {
        let c = IB(r);
        qh({ lineWise: !0, text: c.text }), a.type == "cut" && r.operation(() => {
          r.setSelections(c.ranges, 0, Ii), r.replaceSelection("", null, "cut");
        });
      } else
        return;
      if (a.clipboardData) {
        a.clipboardData.clearData();
        let c = qn.text.join(`
`);
        if (a.clipboardData.setData("Text", c), a.clipboardData.getData("Text") == c) {
          a.preventDefault();
          return;
        }
      }
      let l = NB(), u = l.firstChild;
      r.display.lineSpace.insertBefore(l, r.display.lineSpace.firstChild), u.value = qn.text.join(`
`);
      let f = En();
      Vf(u), setTimeout(() => {
        r.display.lineSpace.removeChild(l), f.focus(), f == n && t.showPrimarySelection();
      }, 50);
    }
    He(n, "copy", s), He(n, "cut", s);
  }
  screenReaderLabelChanged(e) {
    e ? this.div.setAttribute("aria-label", e) : this.div.removeAttribute("aria-label");
  }
  prepareSelection() {
    let e = Uj(this.cm, !1);
    return e.focus = En() == this.div, e;
  }
  showSelection(e, t) {
    !e || !this.cm.display.view.length || ((e.focus || t) && this.showPrimarySelection(), this.showMultipleSelections(e));
  }
  getSelection() {
    return this.cm.display.wrapper.ownerDocument.getSelection();
  }
  showPrimarySelection() {
    let e = this.getSelection(), t = this.cm, r = t.doc.sel.primary(), n = r.from(), o = r.to();
    if (t.display.viewTo == t.display.viewFrom || n.line >= t.display.viewTo || o.line < t.display.viewFrom) {
      e.removeAllRanges();
      return;
    }
    let s = _d(t, e.anchorNode, e.anchorOffset), a = _d(t, e.focusNode, e.focusOffset);
    if (s && !s.bad && a && !a.bad && Ye(Tg(s, a), n) == 0 && Ye(Ag(s, a), o) == 0)
      return;
    let l = t.display.view, u = n.line >= t.display.viewFrom && S2(t, n) || { node: l[0].measure.map[2], offset: 0 }, f = o.line < t.display.viewTo && S2(t, o);
    if (!f) {
      let h = l[l.length - 1].measure, p = h.maps ? h.maps[h.maps.length - 1] : h.map;
      f = { node: p[p.length - 1], offset: p[p.length - 2] - p[p.length - 3] };
    }
    if (!u || !f) {
      e.removeAllRanges();
      return;
    }
    let c = e.rangeCount && e.getRangeAt(0), d;
    try {
      d = Ca(u.node, u.offset, f.offset, f.node);
    } catch {
    }
    d && (!bo && t.state.focused ? (e.collapse(u.node, u.offset), d.collapsed || (e.removeAllRanges(), e.addRange(d))) : (e.removeAllRanges(), e.addRange(d)), c && e.anchorNode == null ? e.addRange(c) : bo && this.startGracePeriod()), this.rememberSelection();
  }
  startGracePeriod() {
    clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(() => {
      this.gracePeriod = !1, this.selectionChanged() && this.cm.operation(() => this.cm.curOp.selectionChanged = !0);
    }, 20);
  }
  showMultipleSelections(e) {
    hn(this.cm.display.cursorDiv, e.cursors), hn(this.cm.display.selectionDiv, e.selection);
  }
  rememberSelection() {
    let e = this.getSelection();
    this.lastAnchorNode = e.anchorNode, this.lastAnchorOffset = e.anchorOffset, this.lastFocusNode = e.focusNode, this.lastFocusOffset = e.focusOffset;
  }
  selectionInEditor() {
    let e = this.getSelection();
    if (!e.rangeCount)
      return !1;
    let t = e.getRangeAt(0).commonAncestorContainer;
    return fs(this.div, t);
  }
  focus() {
    this.cm.options.readOnly != "nocursor" && ((!this.selectionInEditor() || En() != this.div) && this.showSelection(this.prepareSelection(), !0), this.div.focus());
  }
  blur() {
    this.div.blur();
  }
  getField() {
    return this.div;
  }
  supportsTouch() {
    return !0;
  }
  receivedFocus() {
    let e = this;
    this.selectionInEditor() ? this.pollSelection() : en(this.cm, () => e.cm.curOp.selectionChanged = !0);
    function t() {
      e.cm.state.focused && (e.pollSelection(), e.polling.set(e.cm.options.pollInterval, t));
    }
    this.polling.set(this.cm.options.pollInterval, t);
  }
  selectionChanged() {
    let e = this.getSelection();
    return e.anchorNode != this.lastAnchorNode || e.anchorOffset != this.lastAnchorOffset || e.focusNode != this.lastFocusNode || e.focusOffset != this.lastFocusOffset;
  }
  pollSelection() {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged())
      return;
    let e = this.getSelection(), t = this.cm;
    if (Sg && wg && this.cm.display.gutterSpecs.length && Rhe(e.anchorNode)) {
      this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs }), this.blur(), this.focus();
      return;
    }
    if (this.composing)
      return;
    this.rememberSelection();
    let r = _d(t, e.anchorNode, e.anchorOffset), n = _d(t, e.focusNode, e.focusOffset);
    r && n && en(t, () => {
      hr(t.doc, ds(r, n), Ii), (r.bad || n.bad) && (t.curOp.selectionChanged = !0);
    });
  }
  pollContent() {
    this.readDOMTimeout != null && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null);
    let e = this.cm, t = e.display, r = e.doc.sel.primary(), n = r.from(), o = r.to();
    if (n.ch == 0 && n.line > e.firstLine() && (n = Se(n.line - 1, je(e.doc, n.line - 1).length)), o.ch == je(e.doc, o.line).text.length && o.line < e.lastLine() && (o = Se(o.line + 1, 0)), n.line < t.viewFrom || o.line > t.viewTo - 1)
      return !1;
    let s, a, l;
    n.line == t.viewFrom || (s = Ma(e, n.line)) == 0 ? (a = mt(t.view[0].line), l = t.view[0].node) : (a = mt(t.view[s].line), l = t.view[s - 1].node.nextSibling);
    let u = Ma(e, o.line), f, c;
    if (u == t.view.length - 1 ? (f = t.viewTo - 1, c = t.lineDiv.lastChild) : (f = mt(t.view[u + 1].line) - 1, c = t.view[u + 1].node.previousSibling), !l)
      return !1;
    let d = e.doc.splitLines(Ahe(e, l, c, a, f)), h = ya(e.doc, Se(a, 0), Se(f, je(e.doc, f).text.length));
    for (; d.length > 1 && h.length > 1; )
      if (yt(d) == yt(h))
        d.pop(), h.pop(), f--;
      else if (d[0] == h[0])
        d.shift(), h.shift(), a++;
      else
        break;
    let p = 0, m = 0, y = d[0], _ = h[0], S = Math.min(y.length, _.length);
    for (; p < S && y.charCodeAt(p) == _.charCodeAt(p); )
      ++p;
    let x = yt(d), E = yt(h), C = Math.min(x.length - (d.length == 1 ? p : 0), E.length - (h.length == 1 ? p : 0));
    for (; m < C && x.charCodeAt(x.length - m - 1) == E.charCodeAt(E.length - m - 1); )
      ++m;
    if (d.length == 1 && h.length == 1 && a == n.line)
      for (; p && p > n.ch && x.charCodeAt(x.length - m - 1) == E.charCodeAt(E.length - m - 1); )
        p--, m++;
    d[d.length - 1] = x.slice(0, x.length - m).replace(/^\u200b+/, ""), d[0] = d[0].slice(p).replace(/\u200b+$/, "");
    let I = Se(a, p), j = Se(f, h.length ? yt(h).length - m : 0);
    if (d.length > 1 || d[0] || Ye(I, j))
      return Ru(e.doc, d, I, j, "+input"), !0;
  }
  ensurePolled() {
    this.forceCompositionEnd();
  }
  reset() {
    this.forceCompositionEnd();
  }
  forceCompositionEnd() {
    this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), this.div.blur(), this.div.focus());
  }
  readFromDOMSoon() {
    this.readDOMTimeout == null && (this.readDOMTimeout = setTimeout(() => {
      if (this.readDOMTimeout = null, this.composing)
        if (this.composing.done)
          this.composing = null;
        else
          return;
      this.updateFromDOM();
    }, 80));
  }
  updateFromDOM() {
    (this.cm.isReadOnly() || !this.pollContent()) && en(this.cm, () => qr(this.cm));
  }
  setUneditable(e) {
    e.contentEditable = "false";
  }
  onKeyPress(e) {
    e.charCode == 0 || this.composing || (e.preventDefault(), this.cm.isReadOnly() || tr(this.cm, WR)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0));
  }
  readOnlyChanged(e) {
    this.div.contentEditable = String(e != "nocursor");
  }
  onContextMenu() {
  }
  resetPosition() {
  }
}, xhe = LB;
LB.prototype.needsContentAttribute = !0;
function S2(e, t) {
  let r = vR(e, t.line);
  if (!r || r.hidden)
    return null;
  let n = je(e.doc, t.line), o = Mj(r, n, t.line), s = $o(n, e.doc.direction), a = "left";
  s && (a = Yf(s, t.ch) % 2 ? "right" : "left");
  let l = Oj(o.map, t.ch, a);
  return l.offset = l.collapse == "right" ? l.end : l.start, l;
}
function Rhe(e) {
  for (let t = e; t; t = t.parentNode)
    if (/CodeMirror-gutter-wrapper/.test(t.className))
      return !0;
  return !1;
}
function Sl(e, t) {
  return t && (e.bad = !0), e;
}
function Ahe(e, t, r, n, o) {
  let s = "", a = !1, l = e.doc.lineSeparator(), u = !1;
  function f(p) {
    return (m) => m.id == p;
  }
  function c() {
    a && (s += l, u && (s += l), a = u = !1);
  }
  function d(p) {
    p && (c(), s += p);
  }
  function h(p) {
    if (p.nodeType == 1) {
      let m = p.getAttribute("cm-text");
      if (m) {
        d(m);
        return;
      }
      let y = p.getAttribute("cm-marker"), _;
      if (y) {
        let x = e.findMarks(Se(n, 0), Se(o + 1, 0), f(+y));
        x.length && (_ = x[0].find(0)) && d(ya(e.doc, _.from, _.to).join(l));
        return;
      }
      if (p.getAttribute("contenteditable") == "false")
        return;
      let S = /^(pre|div|p|li|table|br)$/i.test(p.nodeName);
      if (!/^br$/i.test(p.nodeName) && p.textContent.length == 0)
        return;
      S && c();
      for (let x = 0; x < p.childNodes.length; x++)
        h(p.childNodes[x]);
      /^(pre|p)$/i.test(p.nodeName) && (u = !0), S && (a = !0);
    } else
      p.nodeType == 3 && d(p.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
  }
  for (; h(t), t != r; )
    t = t.nextSibling, u = !1;
  return s;
}
function _d(e, t, r) {
  let n;
  if (t == e.display.lineDiv) {
    if (n = e.display.lineDiv.childNodes[r], !n)
      return Sl(e.clipPos(Se(e.display.viewTo - 1)), !0);
    t = null, r = 0;
  } else
    for (n = t; ; n = n.parentNode) {
      if (!n || n == e.display.lineDiv)
        return null;
      if (n.parentNode && n.parentNode == e.display.lineDiv)
        break;
    }
  for (let o = 0; o < e.display.view.length; o++) {
    let s = e.display.view[o];
    if (s.node == n)
      return The(s, t, r);
  }
}
function The(e, t, r) {
  let n = e.text.firstChild, o = !1;
  if (!t || !fs(n, t))
    return Sl(Se(mt(e.line), 0), !0);
  if (t == n && (o = !0, t = n.childNodes[r], r = 0, !t)) {
    let d = e.rest ? yt(e.rest) : e.line;
    return Sl(Se(mt(d), d.text.length), o);
  }
  let s = t.nodeType == 3 ? t : null, a = t;
  for (!s && t.childNodes.length == 1 && t.firstChild.nodeType == 3 && (s = t.firstChild, r && (r = s.nodeValue.length)); a.parentNode != n; )
    a = a.parentNode;
  let l = e.measure, u = l.maps;
  function f(d, h, p) {
    for (let m = -1; m < (u ? u.length : 0); m++) {
      let y = m < 0 ? l.map : u[m];
      for (let _ = 0; _ < y.length; _ += 3) {
        let S = y[_ + 2];
        if (S == d || S == h) {
          let x = mt(m < 0 ? e.line : e.rest[m]), E = y[_] + p;
          return (p < 0 || S != d) && (E = y[_ + (p ? 1 : 0)]), Se(x, E);
        }
      }
    }
  }
  let c = f(s, a, r);
  if (c)
    return Sl(c, o);
  for (let d = a.nextSibling, h = s ? s.nodeValue.length - r : 0; d; d = d.nextSibling) {
    if (c = f(d, d.firstChild, 0), c)
      return Sl(Se(c.line, c.ch - h), o);
    h += d.textContent.length;
  }
  for (let d = a.previousSibling, h = r; d; d = d.previousSibling) {
    if (c = f(d, d.firstChild, -1), c)
      return Sl(Se(c.line, c.ch + h), o);
    h += d.textContent.length;
  }
}
var OB = class {
  constructor(e) {
    this.cm = e, this.prevInput = "", this.pollingFast = !1, this.polling = new eu(), this.hasSelection = !1, this.composing = null;
  }
  init(e) {
    let t = this, r = this.cm;
    this.createField(e);
    const n = this.textarea;
    e.wrapper.insertBefore(this.wrapper, e.wrapper.firstChild), Tc && (n.style.width = "0px"), He(n, "input", () => {
      ct && kt >= 9 && this.hasSelection && (this.hasSelection = null), t.poll();
    }), He(n, "paste", (s) => {
      Qt(r, s) || CB(s, r) || (r.state.pasteIncoming = +/* @__PURE__ */ new Date(), t.fastPoll());
    });
    function o(s) {
      if (!Qt(r, s)) {
        if (r.somethingSelected())
          qh({ lineWise: !1, text: r.getSelections() });
        else if (r.options.lineWiseCopyCut) {
          let a = IB(r);
          qh({ lineWise: !0, text: a.text }), s.type == "cut" ? r.setSelections(a.ranges, null, Ii) : (t.prevInput = "", n.value = a.text.join(`
`), Vf(n));
        } else
          return;
        s.type == "cut" && (r.state.cutIncoming = +/* @__PURE__ */ new Date());
      }
    }
    He(n, "cut", o), He(n, "copy", o), He(e.scroller, "paste", (s) => {
      if (vo(e, s) || Qt(r, s))
        return;
      if (!n.dispatchEvent) {
        r.state.pasteIncoming = +/* @__PURE__ */ new Date(), t.focus();
        return;
      }
      const a = new Event("paste");
      a.clipboardData = s.clipboardData, n.dispatchEvent(a);
    }), He(e.lineSpace, "selectstart", (s) => {
      vo(e, s) || Br(s);
    }), He(n, "compositionstart", () => {
      let s = r.getCursor("from");
      t.composing && t.composing.range.clear(), t.composing = {
        start: s,
        range: r.markText(s, r.getCursor("to"), { className: "CodeMirror-composing" })
      };
    }), He(n, "compositionend", () => {
      t.composing && (t.poll(), t.composing.range.clear(), t.composing = null);
    });
  }
  createField(e) {
    this.wrapper = NB(), this.textarea = this.wrapper.firstChild;
  }
  screenReaderLabelChanged(e) {
    e ? this.textarea.setAttribute("aria-label", e) : this.textarea.removeAttribute("aria-label");
  }
  prepareSelection() {
    let e = this.cm, t = e.display, r = e.doc, n = Uj(e);
    if (e.options.moveInputWithCursor) {
      let o = Gn(e, r.sel.primary().head, "div"), s = t.wrapper.getBoundingClientRect(), a = t.lineDiv.getBoundingClientRect();
      n.teTop = Math.max(0, Math.min(t.wrapper.clientHeight - 10, o.top + a.top - s.top)), n.teLeft = Math.max(0, Math.min(t.wrapper.clientWidth - 10, o.left + a.left - s.left));
    }
    return n;
  }
  showSelection(e) {
    let t = this.cm, r = t.display;
    hn(r.cursorDiv, e.cursors), hn(r.selectionDiv, e.selection), e.teTop != null && (this.wrapper.style.top = e.teTop + "px", this.wrapper.style.left = e.teLeft + "px");
  }
  reset(e) {
    if (this.contextMenuPending || this.composing)
      return;
    let t = this.cm;
    if (t.somethingSelected()) {
      this.prevInput = "";
      let r = t.getSelection();
      this.textarea.value = r, t.state.focused && Vf(this.textarea), ct && kt >= 9 && (this.hasSelection = r);
    } else
      e || (this.prevInput = this.textarea.value = "", ct && kt >= 9 && (this.hasSelection = null));
  }
  getField() {
    return this.textarea;
  }
  supportsTouch() {
    return !1;
  }
  focus() {
    if (this.cm.options.readOnly != "nocursor" && (!Gf || En() != this.textarea))
      try {
        this.textarea.focus();
      } catch {
      }
  }
  blur() {
    this.textarea.blur();
  }
  resetPosition() {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  }
  receivedFocus() {
    this.slowPoll();
  }
  slowPoll() {
    this.pollingFast || this.polling.set(this.cm.options.pollInterval, () => {
      this.poll(), this.cm.state.focused && this.slowPoll();
    });
  }
  fastPoll() {
    let e = !1, t = this;
    t.pollingFast = !0;
    function r() {
      !t.poll() && !e ? (e = !0, t.polling.set(60, r)) : (t.pollingFast = !1, t.slowPoll());
    }
    t.polling.set(20, r);
  }
  poll() {
    let e = this.cm, t = this.textarea, r = this.prevInput;
    if (this.contextMenuPending || !e.state.focused || _ce(t) && !r && !this.composing || e.isReadOnly() || e.options.disableInput || e.state.keySeq)
      return !1;
    let n = t.value;
    if (n == r && !e.somethingSelected())
      return !1;
    if (ct && kt >= 9 && this.hasSelection === n || Rn && /[\uf700-\uf7ff]/.test(n))
      return e.display.input.reset(), !1;
    if (e.doc.sel == e.display.selForContextMenu) {
      let a = n.charCodeAt(0);
      if (a == 8203 && !r && (r = ""), a == 8666)
        return this.reset(), this.cm.execCommand("undo");
    }
    let o = 0, s = Math.min(r.length, n.length);
    for (; o < s && r.charCodeAt(o) == n.charCodeAt(o); )
      ++o;
    return en(e, () => {
      WR(e, n.slice(o), r.length - o, null, this.composing ? "*compose" : null), n.length > 1e3 || n.indexOf(`
`) > -1 ? t.value = this.prevInput = "" : this.prevInput = n, this.composing && (this.composing.range.clear(), this.composing.range = e.markText(this.composing.start, e.getCursor("to"), { className: "CodeMirror-composing" }));
    }), !0;
  }
  ensurePolled() {
    this.pollingFast && this.poll() && (this.pollingFast = !1);
  }
  onKeyPress() {
    ct && kt >= 9 && (this.hasSelection = null), this.fastPoll();
  }
  onContextMenu(e) {
    let t = this, r = t.cm, n = r.display, o = t.textarea;
    t.contextMenuPending && t.contextMenuPending();
    let s = Ia(r, e), a = n.scroller.scrollTop;
    if (!s || Jn)
      return;
    r.options.resetSelectionOnContextMenu && r.doc.sel.contains(s) == -1 && tr(r, hr)(r.doc, ds(s), Ii);
    let u = o.style.cssText, f = t.wrapper.style.cssText, c = t.wrapper.offsetParent.getBoundingClientRect();
    t.wrapper.style.cssText = "position: static", o.style.cssText = `position: absolute; width: 30px; height: 30px;
      top: ${e.clientY - c.top - 5}px; left: ${e.clientX - c.left - 5}px;
      z-index: 1000; background: ${ct ? "rgba(255, 255, 255, .05)" : "transparent"};
      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);`;
    let d;
    Tr && (d = window.scrollY), n.input.focus(), Tr && window.scrollTo(null, d), n.input.reset(), r.somethingSelected() || (o.value = t.prevInput = " "), t.contextMenuPending = p, n.selForContextMenu = r.doc.sel, clearTimeout(n.detectingSelectAll);
    function h() {
      if (o.selectionStart != null) {
        let m = r.somethingSelected(), y = "" + (m ? o.value : "");
        o.value = "", o.value = y, t.prevInput = m ? "" : "", o.selectionStart = 1, o.selectionEnd = y.length, n.selForContextMenu = r.doc.sel;
      }
    }
    function p() {
      if (t.contextMenuPending == p && (t.contextMenuPending = !1, t.wrapper.style.cssText = f, o.style.cssText = u, ct && kt < 9 && n.scrollbars.setScrollTop(n.scroller.scrollTop = a), o.selectionStart != null)) {
        (!ct || ct && kt < 9) && h();
        let m = 0, y = () => {
          n.selForContextMenu == r.doc.sel && o.selectionStart == 0 && o.selectionEnd > 0 && t.prevInput == "" ? tr(r, cB)(r) : m++ < 10 ? n.detectingSelectAll = setTimeout(y, 500) : (n.selForContextMenu = null, n.input.reset());
        };
        n.detectingSelectAll = setTimeout(y, 200);
      }
    }
    if (ct && kt >= 9 && h(), tR) {
      Xf(e);
      let m = () => {
        cn(window, "mouseup", m), setTimeout(p, 20);
      };
      He(window, "mouseup", m);
    } else
      setTimeout(p, 50);
  }
  readOnlyChanged(e) {
    e || this.reset(), this.textarea.disabled = e == "nocursor", this.textarea.readOnly = !!e;
  }
  setUneditable() {
  }
}, $he = OB;
OB.prototype.needsContentAttribute = !1;
function Che(e, t) {
  if (t = t ? ka(t) : {}, t.value = e.value, !t.tabindex && e.tabIndex && (t.tabindex = e.tabIndex), !t.placeholder && e.placeholder && (t.placeholder = e.placeholder), t.autofocus == null) {
    let s = En();
    t.autofocus = s == e || e.getAttribute("autofocus") != null && s == document.body;
  }
  function r() {
    e.value = o.getValue();
  }
  let n;
  if (e.form && (He(e.form, "submit", r), !t.leaveSubmitMethodAlone)) {
    let s = e.form;
    n = s.submit;
    try {
      let a = s.submit = () => {
        r(), s.submit = n, s.submit(), s.submit = a;
      };
    } catch {
    }
  }
  t.finishInit = (s) => {
    s.save = r, s.getTextArea = () => e, s.toTextArea = () => {
      s.toTextArea = isNaN, r(), e.parentNode.removeChild(s.getWrapperElement()), e.style.display = "", e.form && (cn(e.form, "submit", r), !t.leaveSubmitMethodAlone && typeof e.form.submit == "function" && (e.form.submit = n));
    };
  }, e.style.display = "none";
  let o = Mt((s) => e.parentNode.insertBefore(s, e.nextSibling), t);
  return o;
}
function khe(e) {
  e.off = cn, e.on = He, e.wheelEventPixels = Lde, e.Doc = ma, e.splitLines = sR, e.countColumn = _n, e.findColumn = qS, e.isWordChar = WS, e.Pass = Eg, e.signal = Ht, e.Line = Zf, e.changeEnd = hs, e.scrollbarModel = Kj, e.Pos = Se, e.cmpPos = Ye, e.modes = aR, e.mimeModes = xl, e.resolveMode = Mh, e.getMode = lR, e.modeExtensions = Dl, e.extendMode = Ace, e.copyState = ba, e.startState = pj, e.innerMode = uR, e.commands = oc, e.keyMap = no, e.keyName = vB, e.isModifierKey = yB, e.lookupKey = jl, e.normalizeKeyMap = rhe, e.StringStream = Rg, e.SharedTextMarker = jR, e.TextMarker = FR, e.LineWidget = DR, e.e_preventDefault = Br, e.e_stopPropagation = dj, e.e_stop = Xf, e.addClass = el, e.contains = fs, e.rmClass = Za, e.keyNames = ps;
}
mhe(Mt);
Ehe(Mt);
var Ihe = "iter insert remove copy getEditor constructor".split(" ");
for (let e in ma.prototype)
  ma.prototype.hasOwnProperty(e) && mr(Ihe, e) < 0 && (Mt.prototype[e] = /* @__PURE__ */ function(t) {
    return function() {
      return t.apply(this.doc, arguments);
    };
  }(ma.prototype[e]));
wu(ma);
Mt.inputStyles = { textarea: $he, contenteditable: xhe };
Mt.defineMode = function(e) {
  !Mt.defaults.mode && e != "null" && (Mt.defaults.mode = e), xce.apply(this, arguments);
};
Mt.defineMIME = Rce;
Mt.defineMode("null", () => ({ token: (e) => e.skipToEnd() }));
Mt.defineMIME("text/plain", "null");
Mt.defineExtension = (e, t) => {
  Mt.prototype[e] = t;
};
Mt.defineDocExtension = (e, t) => {
  ma.prototype[e] = t;
};
Mt.fromTextArea = Che;
khe(Mt);
Mt.version = "5.61.0";
var Xd = Mt;
document.body.insertAdjacentHTML("beforeend", `
<style>
/* BASICS */

.CodeMirror {
  /* Set height, width, borders, and global font properties here */
  font-family: monospace;
  height: auto;
  color: black;
  direction: ltr;
}

/* PADDING */

.CodeMirror-lines {
  padding: 4px 0; /* Vertical padding around content */
}
.CodeMirror pre.CodeMirror-line,
.CodeMirror pre.CodeMirror-line-like {
  padding: 0 4px; /* Horizontal padding of content */
}

.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
  background-color: white; /* The little square between H and V scrollbars */
}

/* GUTTER */

.CodeMirror-gutters {
  border-right: 1px solid #ddd;
  background-color: #f7f7f7;
  white-space: nowrap;
}
.CodeMirror-linenumbers {}
.CodeMirror-linenumber {
  padding: 0 3px 0 5px;
  min-width: 20px;
  text-align: right;
  color: #999;
  white-space: nowrap;
}

.CodeMirror-guttermarker { color: black; }
.CodeMirror-guttermarker-subtle { color: #999; }

/* CURSOR */

.CodeMirror-cursor {
  border-left: 1px solid black;
  border-right: none;
  width: 0;
}
/* Shown when moving in bi-directional text */
.CodeMirror div.CodeMirror-secondarycursor {
  border-left: 1px solid silver;
}
.cm-fat-cursor .CodeMirror-cursor {
  width: auto;
  border: 0 !important;
  background: #7e7;
}
.cm-fat-cursor div.CodeMirror-cursors {
  z-index: 1;
}
.cm-fat-cursor-mark {
  background-color: rgba(20, 255, 20, 0.5);
  -webkit-animation: blink 1.06s steps(1) infinite;
  -moz-animation: blink 1.06s steps(1) infinite;
  animation: blink 1.06s steps(1) infinite;
}
.cm-animate-fat-cursor {
  width: auto;
  border: 0;
  -webkit-animation: blink 1.06s steps(1) infinite;
  -moz-animation: blink 1.06s steps(1) infinite;
  animation: blink 1.06s steps(1) infinite;
  background-color: #7e7;
}
@-moz-keyframes blink {
  0% {}
  50% { background-color: transparent; }
  100% {}
}
@-webkit-keyframes blink {
  0% {}
  50% { background-color: transparent; }
  100% {}
}
@keyframes blink {
  0% {}
  50% { background-color: transparent; }
  100% {}
}

/* Can style cursor different in overwrite (non-insert) mode */
.CodeMirror-overwrite .CodeMirror-cursor {}

.cm-tab { display: inline-block; text-decoration: inherit; }

.CodeMirror-rulers {
  position: absolute;
  left: 0; right: 0; top: -50px; bottom: 0;
  overflow: hidden;
}
.CodeMirror-ruler {
  border-left: 1px solid #ccc;
  top: 0; bottom: 0;
  position: absolute;
}

/* DEFAULT THEME */

.cm-s-default .cm-header {color: blue;}
.cm-s-default .cm-quote {color: #090;}
.cm-negative {color: #d44;}
.cm-positive {color: #292;}
.cm-header, .cm-strong {font-weight: bold;}
.cm-em {font-style: italic;}
.cm-link {text-decoration: underline;}
.cm-strikethrough {text-decoration: line-through;}

.cm-s-default .cm-keyword {color: #708;}
.cm-s-default .cm-atom {color: #219;}
.cm-s-default .cm-number {color: #164;}
.cm-s-default .cm-def {color: #00f;}
.cm-s-default .cm-variable,
.cm-s-default .cm-punctuation,
.cm-s-default .cm-property,
.cm-s-default .cm-operator {}
.cm-s-default .cm-variable-2 {color: #05a;}
.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}
.cm-s-default .cm-comment {color: #a50;}
.cm-s-default .cm-string {color: #a11;}
.cm-s-default .cm-string-2 {color: #f50;}
.cm-s-default .cm-meta {color: #555;}
.cm-s-default .cm-qualifier {color: #555;}
.cm-s-default .cm-builtin {color: #30a;}
.cm-s-default .cm-bracket {color: #997;}
.cm-s-default .cm-tag {color: #170;}
.cm-s-default .cm-attribute {color: #00c;}
.cm-s-default .cm-hr {color: #999;}
.cm-s-default .cm-link {color: #00c;}

.cm-s-default .cm-error {color: #f00;}
.cm-invalidchar {color: #f00;}

.CodeMirror-composing { border-bottom: 2px solid; }

/* Default styles for common addons */

div.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}
div.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}
.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }
.CodeMirror-activeline-background {background: #e8f2ff;}

/* STOP */

/* The rest of this file contains styles related to the mechanics of
    the editor. You probably shouldn't touch them. */

.CodeMirror {
  position: relative;
  overflow: hidden;
  background: white;
}

.CodeMirror-scroll {
  overflow: scroll !important; /* Things will break if this is overridden */
  /* 50px is the magic margin used to hide the element's real scrollbars */
  /* See overflow: hidden in .CodeMirror */
  margin-bottom: -50px; margin-right: -50px;
  padding-bottom: 50px;
  height: 100%;
  outline: none; /* Prevent dragging from highlighting the element */
  position: relative;
}
.CodeMirror-sizer {
  position: relative;
  border-right: 50px solid transparent;
}

/* The fake, visible scrollbars. Used to force redraw during scrolling
    before actual scrolling happens, thus preventing shaking and
    flickering artifacts. */
.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
  position: absolute;
  z-index: 6;
  display: none;
}
.CodeMirror-vscrollbar {
  right: 0; top: 0;
  overflow-x: hidden;
  overflow-y: scroll;
}
.CodeMirror-hscrollbar {
  bottom: 0; left: 0;
  overflow-y: hidden;
  overflow-x: scroll;
}
.CodeMirror-scrollbar-filler {
  right: 0; bottom: 0;
}
.CodeMirror-gutter-filler {
  left: 0; bottom: 0;
}

.CodeMirror-gutters {
  position: absolute; left: 0; top: 0;
  min-height: 100%;
  z-index: 3;
}
.CodeMirror-gutter {
  white-space: normal;
  height: 100%;
  display: inline-block;
  vertical-align: top;
  margin-bottom: -50px;
}
.CodeMirror-gutter-wrapper {
  position: absolute;
  z-index: 4;
  background: none !important;
  border: none !important;
}
.CodeMirror-gutter-background {
  position: absolute;
  top: 0; bottom: 0;
  z-index: 4;
}
.CodeMirror-gutter-elt {
  position: absolute;
  cursor: default;
  z-index: 4;
}
.CodeMirror-gutter-wrapper ::selection { background-color: transparent }
.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }

.CodeMirror-lines {
  cursor: text;
  min-height: 1px; /* prevents collapsing before first draw */
}
.CodeMirror pre.CodeMirror-line,
.CodeMirror pre.CodeMirror-line-like {
  /* Reset some styles that the rest of the page might have set */
  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;
  border-width: 0;
  background: transparent;
  font-family: inherit;
  font-size: inherit;
  margin: 0;
  white-space: pre;
  word-wrap: normal;
  line-height: inherit;
  color: inherit;
  z-index: 2;
  position: relative;
  overflow: visible;
  -webkit-tap-highlight-color: transparent;
  -webkit-font-variant-ligatures: contextual;
  font-variant-ligatures: contextual;
}
.CodeMirror-wrap pre.CodeMirror-line,
.CodeMirror-wrap pre.CodeMirror-line-like {
  word-wrap: break-word;
  white-space: pre-wrap;
  word-break: normal;
}

.CodeMirror-linebackground {
  position: absolute;
  left: 0; right: 0; top: 0; bottom: 0;
  z-index: 0;
}

.CodeMirror-linewidget {
  position: relative;
  z-index: 2;
  padding: 0.1px; /* Force widget margins to stay inside of the container */
}

.CodeMirror-widget {}

.CodeMirror-rtl pre { direction: rtl; }

.CodeMirror-code {
  outline: none;
}

/* Force content-box sizing for the elements where we expect it */
.CodeMirror-scroll,
.CodeMirror-sizer,
.CodeMirror-gutter,
.CodeMirror-gutters,
.CodeMirror-linenumber {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
}

.CodeMirror-measure {
  position: absolute;
  width: 100%;
  height: 0;
  overflow: hidden;
  visibility: hidden;
}

.CodeMirror-cursor {
  position: absolute;
  pointer-events: none;
}
.CodeMirror-measure pre { position: static; }

div.CodeMirror-cursors {
  visibility: hidden;
  position: relative;
  z-index: 3;
}
div.CodeMirror-dragcursors {
  visibility: visible;
}

.CodeMirror-focused div.CodeMirror-cursors {
  visibility: visible;
}

.CodeMirror-selected { background: #d9d9d9; }
.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }
.CodeMirror-crosshair { cursor: crosshair; }
.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }
.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }

.cm-searching {
  background-color: #ffa;
  background-color: rgba(255, 255, 0, .4);
}

/* Used to force a border model for a node */
.cm-force-border { padding-right: .1px; }

@media print {
  /* Hide the cursor when printing */
  .CodeMirror div.CodeMirror-cursors {
    visibility: hidden;
  }
}

/* See issue #2901 */
.cm-tab-wrap-hack:after { content: ''; }

/* Help users use markselection to safely style text background */
span.CodeMirror-selectedtext { background: none; }
</style>
`);
self.CodeMirror = Xd;
var sE = class extends HTMLElement {
  static get observedAttributes() {
    return ["src", "readonly", "mode", "theme"];
  }
  attributeChangedCallback(e, t, r) {
    this.__initialized && t !== r && (e === "readonly" ? this[e] = r !== null : this[e] = r);
  }
  get readonly() {
    return this.editor.getOption("readOnly");
  }
  set readonly(e) {
    this.editor.setOption("readOnly", e);
  }
  get mode() {
    return this.editor.getOption("mode");
  }
  set mode(e) {
    this.editor.setOption("mode", e);
  }
  get theme() {
    return this.editor.getOption("theme");
  }
  set theme(e) {
    this.editor.setOption("theme", e);
  }
  get src() {
    return this.getAttribute("src");
  }
  set src(e) {
    this.setAttribute("src", e), this.setSrc();
  }
  get value() {
    return this.editor.getValue();
  }
  set value(e) {
    this.setValue(e);
  }
  constructor() {
    super(), this.__initialized = !1, this.__element = null, this.editor = null;
  }
  async connectedCallback() {
    const e = document.createElement("template");
    e.innerHTML = sE.template(), this.appendChild(e.content.cloneNode(!0)), this.style.display = "block", this.__element = this.querySelector("textarea");
    const t = this.hasAttribute("mode") ? this.getAttribute("mode") : "null", r = this.hasAttribute("theme") ? this.getAttribute("theme") : "default";
    let n = this.getAttribute("readonly");
    n === "" ? n = !0 : n !== "nocursor" && (n = !1);
    let o = "";
    const s = this.querySelector("script");
    s && s.getAttribute("type") === "wc-content" && (o = sE.dedentText(s.innerHTML), o = o.replace(/&lt;(\/?script)(.*?)&gt;/g, "<$1$2>"));
    let a = Xd.defaults.viewportMargin;
    if (this.hasAttribute("viewport-margin")) {
      const l = this.getAttribute("viewport-margin").toLowerCase();
      a = l === "infinity" ? 1 / 0 : parseInt(l);
    }
    this.editor = Xd.fromTextArea(this.__element, {
      lineNumbers: !0,
      readOnly: n,
      mode: t,
      theme: r,
      viewportMargin: a
    }), this.hasAttribute("src") ? this.setSrc(this.getAttribute("src")) : (await new Promise((l) => setTimeout(l, 50)), this.value = o), this.__initialized = !0;
  }
  disconnectedCallback() {
    this.editor && this.editor.toTextArea(), this.editor = null, this.__initialized = !1;
  }
  async setSrc() {
    const e = this.getAttribute("src"), t = await this.fetchSrc(e);
    this.value = t;
  }
  async setValue(e) {
    this.editor.swapDoc(Xd.Doc(e, this.getAttribute("mode"))), this.editor.refresh();
  }
  async fetchSrc(e) {
    return (await fetch(e)).text();
  }
  static template() {
    return `
      <textarea style="display:inherit; width:inherit; height:inherit;"></textarea>
    `;
  }
  static dedentText(e) {
    const t = e.split(`
`);
    t[0] === "" && t.splice(0, 1);
    const r = t[0];
    let n = 0;
    const s = r[0] === "	" ? "	" : " ";
    for (; r[n] === s; )
      n += 1;
    const a = [];
    for (const l of t) {
      let u = l;
      for (let f = 0; f < n && u[0] === s; f++)
        u = u.substring(1);
      a.push(u);
    }
    return a[a.length - 1] === "" && a.splice(a.length - 1, 1), a.join(`
`);
  }
};
customElements.define("wc-codemirror", sE);
function E2(e, t, r, n) {
  var o, s = !1, a = 0;
  function l() {
    o && clearTimeout(o);
  }
  function u() {
    l(), s = !0;
  }
  typeof t != "boolean" && (n = r, r = t, t = void 0);
  function f() {
    for (var c = arguments.length, d = new Array(c), h = 0; h < c; h++)
      d[h] = arguments[h];
    var p = this, m = Date.now() - a;
    if (s)
      return;
    function y() {
      a = Date.now(), r.apply(p, d);
    }
    function _() {
      o = void 0;
    }
    n && !o && y(), l(), n === void 0 && m > e ? y() : t !== !0 && (o = setTimeout(n ? _ : y, n === void 0 ? e - m : e));
  }
  return f.cancel = u, f;
}
function Mhe(e, t, r) {
  return r === void 0 ? E2(e, t, !1) : E2(e, r, t !== !1);
}
const Lo = Symbol("Initial value"), x0 = Symbol("Editor dirty"), zi = Symbol("ParseHandler");
function Nhe(e) {
  let n = 0;
  return new Promise((o, s) => {
    const a = setInterval(() => {
      e() && (clearInterval(a), o()), n += 1, n === 100 && (clearInterval(a), s(new Error("Value did not become truthy in time")));
    }, 10);
  });
}
class Lhe extends xf {
  static get styles() {
    return Vfe`
      :host {
        display: block;
        text-align: left;
      }

      [part='error'] {
        text-decoration: underline;
        text-decoration-color: red;
        text-decoration-style: wavy;
      }

      wc-codemirror,
      #wrapper {
        width: 100%;
        height: 100%;
      }

      :host(:not([ready])) #wrapper {
        display: none;
      }
    `;
  }
  static get properties() {
    return {
      value: { type: String, noAccessor: !0 },
      readonly: { type: Boolean, reflect: !0 },
      prefixes: { type: String, attribute: "prefixes" },
      isParsing: { type: Boolean, attribute: "is-parsing", reflect: !0 },
      autoParse: { type: Boolean, attribute: "auto-parse" },
      parseDelay: { type: Number },
      customPrefixes: { type: Object }
    };
  }
  constructor() {
    super(), this.parseDelay = 250, this[Lo] = "", this.customPrefixes = {}, this.__style = document.createElement("link"), this.__style.rel = "stylesheet", this.__style.href = "https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.61.1/codemirror.min.css";
  }
  connectedCallback() {
    const t = new Promise((r) => {
      this.__style.onload = r;
    });
    super.connectedCallback(), this.ready = Promise.resolve().then(async () => {
      await t, await this.requestUpdate(), await Nhe(
        () => this.codeMirror && this.codeMirror.editor && this.codeMirror.__initialized
      ), await this._initializeCodeMirror(), [...this.renderRoot.querySelectorAll("[class^=CodeMirror]")].forEach(
        (r) => {
          r.classList.forEach((n) => {
            n.match(/^CodeMirror/) && r.setAttribute("part", n);
          });
        }
      ), this.setAttribute("ready", ""), this.codeMirror.editor.refresh(), this[Lo] && this.codeMirror.editor.setValue(this[Lo]);
    });
  }
  get _prefixes() {
    return async () => {
      const t = await Promise.resolve().then(() => TE);
      return (this.prefixes || "").split(",").map((n) => n.trim()).reduce((n, o) => o in t ? { ...n, [o]: t[o]().value } : n, {});
    };
  }
  /**
   * The underlying `<wc-codemirror>` element
   */
  get codeMirror() {
    return this.renderRoot.querySelector("wc-codemirror");
  }
  /**
   * Gets the text contents of the underlying editor
   * @returns {string}
   */
  get value() {
    return this.hasAttribute("ready") ? this.codeMirror.editor.getValue() : this[Lo] || "";
  }
  set value(t) {
    typeof t == "string" && (this.hasAttribute("ready") ? this.value !== t && (this.codeMirror.editor.setValue(t), this[zi]()) : this[Lo] = t);
  }
  async firstUpdated(t) {
    super.firstUpdated(t), this[Lo] && (await this.ready, this.codeMirror.editor.setValue(this[Lo]), this[zi](), this[Lo] = void 0);
  }
  updated(t) {
    super.updated(t), (t.has("autoParse") || t.has("parseDelay")) && this.__setParseHandler();
  }
  render() {
    return Zfe`${this.__style}
      <div id="wrapper">
        <wc-codemirror mode="${this.format}" ?readonly="${this.readonly}">
        </wc-codemirror>
      </div>`;
  }
  async parse() {
    if (!this.isParsing) {
      this.__errorMarker && this.__errorMarker.clear(), this.isParsing = !0;
      try {
        await this._parse();
      } catch (t) {
        typeof this._errorLine == "function" && await this.__highlightError(this._errorLine(t)), this.dispatchEvent(
          new CustomEvent("parsing-failed", {
            detail: { error: t }
          })
        );
      } finally {
        this.isParsing = !1;
      }
    }
  }
  async _initializeCodeMirror() {
    this.codeMirror.editor.setSize("100%", "100%"), this.__setParseHandler(), this.codeMirror.editor.on("change", () => {
      this[x0] = !0;
    });
  }
  __setParseHandler() {
    this.codeMirror.editor && (this[zi] && (this.codeMirror.editor.off("blur", this[zi]), this.codeMirror.editor.off("change", this[zi])), this.autoParse ? (this[zi] = Mhe(
      this.parseDelay,
      this.__beginParse.bind(this)
    ), this.codeMirror.editor.on("change", this[zi])) : (this[zi] = this.__beginParse.bind(this), this.codeMirror.editor.on("blur", this[zi])));
  }
  async __beginParse() {
    this[x0] && await this.parse(), this[x0] = !1;
  }
  async __highlightError(t) {
    if (!this.ready)
      return;
    let r = { line: 0, ch: 0 }, n = { line: 0, ch: Number.MAX_SAFE_INTEGER };
    t && t.from && (r = t.from, this.codeMirror.editor.scrollIntoView(r)), t && t.to && (n = t.to);
    const o = t ? t.message : "";
    await this.ready, this.__errorMarker = this.codeMirror.editor.getDoc().markText(r, n, {
      attributes: { part: "error", title: o }
    });
  }
  async _combinePrefixes() {
    return Object.entries(this.customPrefixes).reduce((t, [r, n]) => !n || !r || typeof n != "string" || typeof r != "string" ? t : {
      ...t,
      [r]: n
    }, await this._prefixes());
  }
}
window.CodeMirror.defineMode("javascript", function(e, t) {
  var r = e.indentUnit, n = t.statementIndent, o = t.jsonld, s = t.json || o, a = t.typescript, l = t.wordCharacters || /[\w$\xa1-\uffff]/, u = function() {
    function P(Or) {
      return { type: Or, style: "keyword" };
    }
    var Q = P("keyword a"), ve = P("keyword b"), Re = P("keyword c"), Je = P("keyword d"), ht = P("operator"), Tt = { type: "atom", style: "atom" };
    return {
      if: P("if"),
      while: Q,
      with: Q,
      else: ve,
      do: ve,
      try: ve,
      finally: ve,
      return: Je,
      break: Je,
      continue: Je,
      new: P("new"),
      delete: Re,
      void: Re,
      throw: Re,
      debugger: P("debugger"),
      var: P("var"),
      const: P("var"),
      let: P("var"),
      function: P("function"),
      catch: P("catch"),
      for: P("for"),
      switch: P("switch"),
      case: P("case"),
      default: P("default"),
      in: ht,
      typeof: ht,
      instanceof: ht,
      true: Tt,
      false: Tt,
      null: Tt,
      undefined: Tt,
      NaN: Tt,
      Infinity: Tt,
      this: P("this"),
      class: P("class"),
      super: P("atom"),
      yield: Re,
      export: P("export"),
      import: P("import"),
      extends: Re,
      await: Re
    };
  }(), f = /[+\-*&%=<>!?|~^@]/, c = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
  function d(P) {
    for (var Q = !1, ve, Re = !1; (ve = P.next()) != null; ) {
      if (!Q) {
        if (ve == "/" && !Re)
          return;
        ve == "[" ? Re = !0 : Re && ve == "]" && (Re = !1);
      }
      Q = !Q && ve == "\\";
    }
  }
  var h, p;
  function m(P, Q, ve) {
    return h = P, p = ve, Q;
  }
  function y(P, Q) {
    var ve = P.next();
    if (ve == '"' || ve == "'")
      return Q.tokenize = _(ve), Q.tokenize(P, Q);
    if (ve == "." && P.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/))
      return m("number", "number");
    if (ve == "." && P.match(".."))
      return m("spread", "meta");
    if (/[\[\]{}\(\),;\:\.]/.test(ve))
      return m(ve);
    if (ve == "=" && P.eat(">"))
      return m("=>", "operator");
    if (ve == "0" && P.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/))
      return m("number", "number");
    if (/\d/.test(ve))
      return P.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/), m("number", "number");
    if (ve == "/")
      return P.eat("*") ? (Q.tokenize = S, S(P, Q)) : P.eat("/") ? (P.skipToEnd(), m("comment", "comment")) : $A(P, Q, 1) ? (d(P), P.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/), m("regexp", "string-2")) : (P.eat("="), m("operator", "operator", P.current()));
    if (ve == "`")
      return Q.tokenize = x, x(P, Q);
    if (ve == "#")
      return P.skipToEnd(), m("error", "error");
    if (ve == "<" && P.match("!--") || ve == "-" && P.match("->"))
      return P.skipToEnd(), m("comment", "comment");
    if (f.test(ve))
      return (ve != ">" || !Q.lexical || Q.lexical.type != ">") && (P.eat("=") ? (ve == "!" || ve == "=") && P.eat("=") : /[<>*+\-]/.test(ve) && (P.eat(ve), ve == ">" && P.eat(ve))), m("operator", "operator", P.current());
    if (l.test(ve)) {
      P.eatWhile(l);
      var Re = P.current();
      if (Q.lastType != ".") {
        if (u.propertyIsEnumerable(Re)) {
          var Je = u[Re];
          return m(Je.type, Je.style, Re);
        }
        if (Re == "async" && P.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, !1))
          return m("async", "keyword", Re);
      }
      return m("variable", "variable", Re);
    }
  }
  function _(P) {
    return function(Q, ve) {
      var Re = !1, Je;
      if (o && Q.peek() == "@" && Q.match(c))
        return ve.tokenize = y, m("jsonld-keyword", "meta");
      for (; (Je = Q.next()) != null && !(Je == P && !Re); )
        Re = !Re && Je == "\\";
      return Re || (ve.tokenize = y), m("string", "string");
    };
  }
  function S(P, Q) {
    for (var ve = !1, Re; Re = P.next(); ) {
      if (Re == "/" && ve) {
        Q.tokenize = y;
        break;
      }
      ve = Re == "*";
    }
    return m("comment", "comment");
  }
  function x(P, Q) {
    for (var ve = !1, Re; (Re = P.next()) != null; ) {
      if (!ve && (Re == "`" || Re == "$" && P.eat("{"))) {
        Q.tokenize = y;
        break;
      }
      ve = !ve && Re == "\\";
    }
    return m("quasi", "string-2", P.current());
  }
  var E = "([{}])";
  function C(P, Q) {
    Q.fatArrowAt && (Q.fatArrowAt = null);
    var ve = P.string.indexOf("=>", P.start);
    if (!(ve < 0)) {
      if (a) {
        var Re = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(
          P.string.slice(P.start, ve)
        );
        Re && (ve = Re.index);
      }
      for (var Je = 0, ht = !1, Tt = ve - 1; Tt >= 0; --Tt) {
        var Or = P.string.charAt(Tt), ai = E.indexOf(Or);
        if (ai >= 0 && ai < 3) {
          if (!Je) {
            ++Tt;
            break;
          }
          if (--Je == 0) {
            Or == "(" && (ht = !0);
            break;
          }
        } else if (ai >= 3 && ai < 6)
          ++Je;
        else if (l.test(Or))
          ht = !0;
        else if (/["'\/`]/.test(Or))
          for (; ; --Tt) {
            if (Tt == 0)
              return;
            var dW = P.string.charAt(Tt - 1);
            if (dW == Or && P.string.charAt(Tt - 2) != "\\") {
              Tt--;
              break;
            }
          }
        else if (ht && !Je) {
          ++Tt;
          break;
        }
      }
      ht && !Je && (Q.fatArrowAt = Tt);
    }
  }
  var I = {
    atom: !0,
    number: !0,
    variable: !0,
    string: !0,
    regexp: !0,
    this: !0,
    "jsonld-keyword": !0
  };
  function j(P, Q, ve, Re, Je, ht) {
    this.indented = P, this.column = Q, this.type = ve, this.prev = Je, this.info = ht, Re != null && (this.align = Re);
  }
  function J(P, Q) {
    for (var ve = P.localVars; ve; ve = ve.next)
      if (ve.name == Q)
        return !0;
    for (var Re = P.context; Re; Re = Re.prev)
      for (var ve = Re.vars; ve; ve = ve.next)
        if (ve.name == Q)
          return !0;
  }
  function G(P, Q, ve, Re, Je) {
    var ht = P.cc;
    for ($.state = P, $.stream = Je, $.marked = null, $.cc = ht, $.style = Q, P.lexical.hasOwnProperty("align") || (P.lexical.align = !0); ; ) {
      var Tt = ht.length ? ht.pop() : s ? ee : ke;
      if (Tt(ve, Re)) {
        for (; ht.length && ht[ht.length - 1].lex; )
          ht.pop()();
        return $.marked ? $.marked : ve == "variable" && J(P, Re) ? "variable-2" : Q;
      }
    }
  }
  var $ = { state: null, column: null, marked: null, cc: null };
  function V() {
    for (var P = arguments.length - 1; P >= 0; P--)
      $.cc.push(arguments[P]);
  }
  function M() {
    return V.apply(null, arguments), !0;
  }
  function W(P, Q) {
    for (var ve = Q; ve; ve = ve.next)
      if (ve.name == P)
        return !0;
    return !1;
  }
  function k(P) {
    var Q = $.state;
    if ($.marked = "def", Q.context) {
      if (Q.lexical.info == "var" && Q.context && Q.context.block) {
        var ve = U(P, Q.context);
        if (ve != null) {
          Q.context = ve;
          return;
        }
      } else if (!W(P, Q.localVars)) {
        Q.localVars = new te(P, Q.localVars);
        return;
      }
    }
    t.globalVars && !W(P, Q.globalVars) && (Q.globalVars = new te(P, Q.globalVars));
  }
  function U(P, Q) {
    if (Q)
      if (Q.block) {
        var ve = U(P, Q.prev);
        return ve ? ve == Q.prev ? Q : new Y(ve, Q.vars, !0) : null;
      } else
        return W(P, Q.vars) ? Q : new Y(Q.prev, new te(P, Q.vars), !1);
    else
      return null;
  }
  function Z(P) {
    return P == "public" || P == "private" || P == "protected" || P == "abstract" || P == "readonly";
  }
  function Y(P, Q, ve) {
    this.prev = P, this.vars = Q, this.block = ve;
  }
  function te(P, Q) {
    this.name = P, this.next = Q;
  }
  var se = new te("this", new te("arguments", null));
  function fe() {
    $.state.context = new Y($.state.context, $.state.localVars, !1), $.state.localVars = se;
  }
  function he() {
    $.state.context = new Y($.state.context, $.state.localVars, !0), $.state.localVars = null;
  }
  function ae() {
    $.state.localVars = $.state.context.vars, $.state.context = $.state.context.prev;
  }
  ae.lex = !0;
  function be(P, Q) {
    var ve = function() {
      var Re = $.state, Je = Re.indented;
      if (Re.lexical.type == "stat")
        Je = Re.lexical.indented;
      else
        for (var ht = Re.lexical; ht && ht.type == ")" && ht.align; ht = ht.prev)
          Je = ht.indented;
      Re.lexical = new j(
        Je,
        $.stream.column(),
        P,
        null,
        Re.lexical,
        Q
      );
    };
    return ve.lex = !0, ve;
  }
  function H() {
    var P = $.state;
    P.lexical.prev && (P.lexical.type == ")" && (P.indented = P.lexical.indented), P.lexical = P.lexical.prev);
  }
  H.lex = !0;
  function pe(P) {
    function Q(ve) {
      return ve == P ? M() : P == ";" || ve == "}" || ve == ")" || ve == "]" ? V() : M(Q);
    }
    return Q;
  }
  function ke(P, Q) {
    return P == "var" ? M(be("vardef", Q), Lr, pe(";"), H) : P == "keyword a" ? M(be("form"), Ae, ke, H) : P == "keyword b" ? M(be("form"), ke, H) : P == "keyword d" ? $.stream.match(/^\s*$/, !1) ? M() : M(be("stat"), K, pe(";"), H) : P == "debugger" ? M(pe(";")) : P == "{" ? M(be("}"), he, R, H, ae) : P == ";" ? M() : P == "if" ? ($.state.lexical.info == "else" && $.state.cc[$.state.cc.length - 1] == H && $.state.cc.pop()(), M(be("form"), Ae, ke, H, g)) : P == "function" ? M(X) : P == "for" ? M(be("form"), v, ke, H) : P == "class" || a && Q == "interface" ? ($.marked = "keyword", M(
      be("form", P == "class" ? P : Q),
      Kr,
      H
    )) : P == "variable" ? a && Q == "declare" ? ($.marked = "keyword", M(ke)) : a && (Q == "module" || Q == "enum" || Q == "type") && $.stream.match(/^\s*\w/, !1) ? ($.marked = "keyword", Q == "enum" ? M(TA) : Q == "type" ? M(We, pe("operator"), de, pe(";")) : M(
      be("form"),
      At,
      pe("{"),
      be("}"),
      R,
      H,
      H
    )) : a && Q == "namespace" ? ($.marked = "keyword", M(be("form"), ee, ke, H)) : a && Q == "abstract" ? ($.marked = "keyword", M(ke)) : M(be("stat"), ye) : P == "switch" ? M(
      be("form"),
      Ae,
      pe("{"),
      be("}", "switch"),
      he,
      R,
      H,
      H,
      ae
    ) : P == "case" ? M(ee, pe(":")) : P == "default" ? M(pe(":")) : P == "catch" ? M(
      be("form"),
      fe,
      le,
      ke,
      H,
      ae
    ) : P == "export" ? M(be("stat"), cr, H) : P == "import" ? M(be("stat"), dr, H) : P == "async" ? M(ke) : Q == "@" ? M(ee, ke) : V(be("stat"), ee, pe(";"), H);
  }
  function le(P) {
    if (P == "(")
      return M(Xt, pe(")"));
  }
  function ee(P, Q) {
    return Oe(P, Q, !1);
  }
  function ge(P, Q) {
    return Oe(P, Q, !0);
  }
  function Ae(P) {
    return P != "(" ? V() : M(be(")"), ee, pe(")"), H);
  }
  function Oe(P, Q, ve) {
    if ($.state.fatArrowAt == $.stream.start) {
      var Re = ve ? L : O;
      if (P == "(")
        return M(
          fe,
          be(")"),
          Me(Xt, ")"),
          H,
          pe("=>"),
          Re,
          ae
        );
      if (P == "variable")
        return V(fe, At, pe("=>"), Re, ae);
    }
    var Je = ve ? b : z;
    return I.hasOwnProperty(P) ? M(Je) : P == "function" ? M(X, Je) : P == "class" || a && Q == "interface" ? ($.marked = "keyword", M(be("form"), dt, H)) : P == "keyword c" || P == "async" ? M(ve ? ge : ee) : P == "(" ? M(be(")"), K, pe(")"), H, Je) : P == "operator" || P == "spread" ? M(ve ? ge : ee) : P == "[" ? M(be("]"), uW, H, Je) : P == "{" ? N(me, "}", null, Je) : P == "quasi" ? V(w, Je) : P == "new" ? M(ne(ve)) : P == "import" ? M(ee) : M();
  }
  function K(P) {
    return P.match(/[;\}\)\],]/) ? V() : V(ee);
  }
  function z(P, Q) {
    return P == "," ? M(ee) : b(P, Q, !1);
  }
  function b(P, Q, ve) {
    var Re = ve == !1 ? z : b, Je = ve == !1 ? ee : ge;
    if (P == "=>")
      return M(
        fe,
        ve ? L : O,
        ae
      );
    if (P == "operator")
      return /\+\+|--/.test(Q) || a && Q == "!" ? M(Re) : a && Q == "<" && $.stream.match(/^([^>]|<.*?>)*>\s*\(/, !1) ? M(be(">"), Me(de, ">"), H, Re) : Q == "?" ? M(ee, pe(":"), Je) : M(Je);
    if (P == "quasi")
      return V(w, Re);
    if (P != ";") {
      if (P == "(")
        return N(ge, ")", "call", Re);
      if (P == ".")
        return M(B, Re);
      if (P == "[")
        return M(be("]"), K, pe("]"), H, Re);
      if (a && Q == "as")
        return $.marked = "keyword", M(de, Re);
      if (P == "regexp")
        return $.state.lastType = $.marked = "operator", $.stream.backUp($.stream.pos - $.stream.start - 1), M(Je);
    }
  }
  function w(P, Q) {
    return P != "quasi" ? V() : Q.slice(Q.length - 2) != "${" ? M(w) : M(ee, T);
  }
  function T(P) {
    if (P == "}")
      return $.marked = "string-2", $.state.tokenize = x, M(w);
  }
  function O(P) {
    return C($.stream, $.state), V(P == "{" ? ke : ee);
  }
  function L(P) {
    return C($.stream, $.state), V(P == "{" ? ke : ge);
  }
  function ne(P) {
    return function(Q) {
      return Q == "." ? M(P ? oe : ue) : Q == "variable" && a ? M(
        Ze,
        P ? b : z
      ) : V(P ? ge : ee);
    };
  }
  function ue(P, Q) {
    if (Q == "target")
      return $.marked = "keyword", M(z);
  }
  function oe(P, Q) {
    if (Q == "target")
      return $.marked = "keyword", M(b);
  }
  function ye(P) {
    return P == ":" ? M(H, ke) : V(z, pe(";"), H);
  }
  function B(P) {
    if (P == "variable")
      return $.marked = "property", M();
  }
  function me(P, Q) {
    if (P == "async")
      return $.marked = "property", M(me);
    if (P == "variable" || $.style == "keyword") {
      if ($.marked = "property", Q == "get" || Q == "set")
        return M(Ce);
      var ve;
      return a && $.state.fatArrowAt == $.stream.start && (ve = $.stream.match(/^\s*:\s*/, !1)) && ($.state.fatArrowAt = $.stream.pos + ve[0].length), M(Ie);
    } else {
      if (P == "number" || P == "string")
        return $.marked = o ? "property" : $.style + " property", M(Ie);
      if (P == "jsonld-keyword")
        return M(Ie);
      if (a && Z(Q))
        return $.marked = "keyword", M(me);
      if (P == "[")
        return M(ee, A, pe("]"), Ie);
      if (P == "spread")
        return M(ge, Ie);
      if (Q == "*")
        return $.marked = "keyword", M(me);
      if (P == ":")
        return V(Ie);
    }
  }
  function Ce(P) {
    return P != "variable" ? V(Ie) : ($.marked = "property", M(X));
  }
  function Ie(P) {
    if (P == ":")
      return M(ge);
    if (P == "(")
      return V(X);
  }
  function Me(P, Q, ve) {
    function Re(Je, ht) {
      if (ve ? ve.indexOf(Je) > -1 : Je == ",") {
        var Tt = $.state.lexical;
        return Tt.info == "call" && (Tt.pos = (Tt.pos || 0) + 1), M(function(Or, ai) {
          return Or == Q || ai == Q ? V() : V(P);
        }, Re);
      }
      return Je == Q || ht == Q ? M() : ve && ve.indexOf(";") > -1 ? V(P) : M(pe(Q));
    }
    return function(Je, ht) {
      return Je == Q || ht == Q ? M() : V(P, Re);
    };
  }
  function N(P, Q, ve) {
    for (var Re = 3; Re < arguments.length; Re++)
      $.cc.push(arguments[Re]);
    return M(be(Q, ve), Me(P, Q), H);
  }
  function R(P) {
    return P == "}" ? M() : V(ke, R);
  }
  function A(P, Q) {
    if (a) {
      if (P == ":")
        return M(de);
      if (Q == "?")
        return M(A);
    }
  }
  function q(P, Q) {
    if (a && (P == ":" || Q == "in"))
      return M(de);
  }
  function re(P) {
    if (a && P == ":")
      return $.stream.match(/^\s*\w+\s+is\b/, !1) ? M(ee, ce, de) : M(de);
  }
  function ce(P, Q) {
    if (Q == "is")
      return $.marked = "keyword", M();
  }
  function de(P, Q) {
    if (Q == "keyof" || Q == "typeof" || Q == "infer")
      return $.marked = "keyword", M(Q == "typeof" ? ge : de);
    if (P == "variable" || Q == "void")
      return $.marked = "type", M(Ve);
    if (Q == "|" || Q == "&")
      return M(de);
    if (P == "string" || P == "number" || P == "atom")
      return M(Ve);
    if (P == "[")
      return M(
        be("]"),
        Me(de, "]", ","),
        H,
        Ve
      );
    if (P == "{")
      return M(
        be("}"),
        Me(it, "}", ",;"),
        H,
        Ve
      );
    if (P == "(")
      return M(Me(ze, ")"), De, Ve);
    if (P == "<")
      return M(Me(de, ">"), de);
  }
  function De(P) {
    if (P == "=>")
      return M(de);
  }
  function it(P, Q) {
    if (P == "variable" || $.style == "keyword")
      return $.marked = "property", M(it);
    if (Q == "?" || P == "number" || P == "string")
      return M(it);
    if (P == ":")
      return M(de);
    if (P == "[")
      return M(pe("variable"), q, pe("]"), it);
    if (P == "(")
      return V(Le, it);
  }
  function ze(P, Q) {
    return P == "variable" && $.stream.match(/^\s*[?:]/, !1) || Q == "?" ? M(ze) : P == ":" ? M(de) : P == "spread" ? M(ze) : V(de);
  }
  function Ve(P, Q) {
    if (Q == "<")
      return M(be(">"), Me(de, ">"), H, Ve);
    if (Q == "|" || P == "." || Q == "&")
      return M(de);
    if (P == "[")
      return M(de, pe("]"), Ve);
    if (Q == "extends" || Q == "implements")
      return $.marked = "keyword", M(de);
    if (Q == "?")
      return M(de, pe(":"), de);
  }
  function Ze(P, Q) {
    if (Q == "<")
      return M(be(">"), Me(de, ">"), H, Ve);
  }
  function Er() {
    return V(de, Wi);
  }
  function Wi(P, Q) {
    if (Q == "=")
      return M(de);
  }
  function Lr(P, Q) {
    return Q == "enum" ? ($.marked = "keyword", M(TA)) : V(At, A, Nt, ln);
  }
  function At(P, Q) {
    if (a && Z(Q))
      return $.marked = "keyword", M(At);
    if (P == "variable")
      return k(Q), M();
    if (P == "spread")
      return M(At);
    if (P == "[")
      return N(Ui, "]");
    if (P == "{")
      return N(si, "}");
  }
  function si(P, Q) {
    return P == "variable" && !$.stream.match(/^\s*:/, !1) ? (k(Q), M(Nt)) : (P == "variable" && ($.marked = "property"), P == "spread" ? M(At) : P == "}" ? V() : P == "[" ? M(ee, pe("]"), pe(":"), si) : M(pe(":"), At, Nt));
  }
  function Ui() {
    return V(At, Nt);
  }
  function Nt(P, Q) {
    if (Q == "=")
      return M(ge);
  }
  function ln(P) {
    if (P == ",")
      return M(Lr);
  }
  function g(P, Q) {
    if (P == "keyword b" && Q == "else")
      return M(be("form", "else"), ke, H);
  }
  function v(P, Q) {
    if (Q == "await")
      return M(v);
    if (P == "(")
      return M(be(")"), F, H);
  }
  function F(P) {
    return P == "var" ? M(Lr, D) : P == "variable" ? M(D) : V(D);
  }
  function D(P, Q) {
    return P == ")" ? M() : P == ";" ? M(D) : Q == "in" || Q == "of" ? ($.marked = "keyword", M(ee, D)) : V(ee, D);
  }
  function X(P, Q) {
    if (Q == "*")
      return $.marked = "keyword", M(X);
    if (P == "variable")
      return k(Q), M(X);
    if (P == "(")
      return M(
        fe,
        be(")"),
        Me(Xt, ")"),
        H,
        re,
        ke,
        ae
      );
    if (a && Q == "<")
      return M(be(">"), Me(Er, ">"), H, X);
  }
  function Le(P, Q) {
    if (Q == "*")
      return $.marked = "keyword", M(Le);
    if (P == "variable")
      return k(Q), M(Le);
    if (P == "(")
      return M(
        fe,
        be(")"),
        Me(Xt, ")"),
        H,
        re,
        ae
      );
    if (a && Q == "<")
      return M(be(">"), Me(Er, ">"), H, Le);
  }
  function We(P, Q) {
    if (P == "keyword" || P == "variable")
      return $.marked = "type", M(We);
    if (Q == "<")
      return M(be(">"), Me(Er, ">"), H);
  }
  function Xt(P, Q) {
    return Q == "@" && M(ee, Xt), P == "spread" ? M(Xt) : a && Z(Q) ? ($.marked = "keyword", M(Xt)) : a && P == "this" ? M(A, Nt) : V(At, A, Nt);
  }
  function dt(P, Q) {
    return P == "variable" ? Kr(P, Q) : yn(P, Q);
  }
  function Kr(P, Q) {
    if (P == "variable")
      return k(Q), M(yn);
  }
  function yn(P, Q) {
    if (Q == "<")
      return M(
        be(">"),
        Me(Er, ">"),
        H,
        yn
      );
    if (Q == "extends" || Q == "implements" || a && P == ",")
      return Q == "implements" && ($.marked = "keyword"), M(a ? de : ee, yn);
    if (P == "{")
      return M(be("}"), Wt, H);
  }
  function Wt(P, Q) {
    if (P == "async" || P == "variable" && (Q == "static" || Q == "get" || Q == "set" || a && Z(Q)) && $.stream.match(/^\s+[\w$\xa1-\uffff]/, !1))
      return $.marked = "keyword", M(Wt);
    if (P == "variable" || $.style == "keyword")
      return $.marked = "property", M(a ? xr : X, Wt);
    if (P == "number" || P == "string")
      return M(a ? xr : X, Wt);
    if (P == "[")
      return M(
        ee,
        A,
        pe("]"),
        a ? xr : X,
        Wt
      );
    if (Q == "*")
      return $.marked = "keyword", M(Wt);
    if (a && P == "(")
      return V(Le, Wt);
    if (P == ";" || P == ",")
      return M(Wt);
    if (P == "}")
      return M();
    if (Q == "@")
      return M(ee, Wt);
  }
  function xr(P, Q) {
    if (Q == "?")
      return M(xr);
    if (P == ":")
      return M(de, Nt);
    if (Q == "=")
      return M(ge);
    var ve = $.state.lexical.prev, Re = ve && ve.info == "interface";
    return V(Re ? Le : X);
  }
  function cr(P, Q) {
    return Q == "*" ? ($.marked = "keyword", M(db, pe(";"))) : Q == "default" ? ($.marked = "keyword", M(ee, pe(";"))) : P == "{" ? M(Me(or, "}"), db, pe(";")) : V(ke);
  }
  function or(P, Q) {
    if (Q == "as")
      return $.marked = "keyword", M(pe("variable"));
    if (P == "variable")
      return V(ge, or);
  }
  function dr(P) {
    return P == "string" ? M() : P == "(" ? V(ee) : V(St, ft, db);
  }
  function St(P, Q) {
    return P == "{" ? N(St, "}") : (P == "variable" && k(Q), Q == "*" && ($.marked = "keyword"), M(rt));
  }
  function ft(P) {
    if (P == ",")
      return M(St, ft);
  }
  function rt(P, Q) {
    if (Q == "as")
      return $.marked = "keyword", M(St);
  }
  function db(P, Q) {
    if (Q == "from")
      return $.marked = "keyword", M(ee);
  }
  function uW(P) {
    return P == "]" ? M() : V(Me(ge, "]"));
  }
  function TA() {
    return V(
      be("form"),
      At,
      pe("{"),
      be("}"),
      Me(fW, "}"),
      H,
      H
    );
  }
  function fW() {
    return V(At, Nt);
  }
  function cW(P, Q) {
    return P.lastType == "operator" || P.lastType == "," || f.test(Q.charAt(0)) || /[,.]/.test(Q.charAt(0));
  }
  function $A(P, Q, ve) {
    return Q.tokenize == y && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(
      Q.lastType
    ) || Q.lastType == "quasi" && /\{\s*$/.test(P.string.slice(0, P.pos - (ve || 0)));
  }
  return {
    startState: function(P) {
      var Q = {
        tokenize: y,
        lastType: "sof",
        cc: [],
        lexical: new j(
          (P || 0) - r,
          0,
          "block",
          !1
        ),
        localVars: t.localVars,
        context: t.localVars && new Y(null, null, !1),
        indented: P || 0
      };
      return t.globalVars && typeof t.globalVars == "object" && (Q.globalVars = t.globalVars), Q;
    },
    token: function(P, Q) {
      if (P.sol() && (Q.lexical.hasOwnProperty("align") || (Q.lexical.align = !1), Q.indented = P.indentation(), C(P, Q)), Q.tokenize != S && P.eatSpace())
        return null;
      var ve = Q.tokenize(P, Q);
      return h == "comment" ? ve : (Q.lastType = h == "operator" && (p == "++" || p == "--") ? "incdec" : h, G(Q, ve, h, p, P));
    },
    indent: function(P, Q) {
      if (P.tokenize == S)
        return CodeMirror.Pass;
      if (P.tokenize != y)
        return 0;
      var ve = Q && Q.charAt(0), Re = P.lexical, Je;
      if (!/^\s*else\b/.test(Q))
        for (var ht = P.cc.length - 1; ht >= 0; --ht) {
          var Tt = P.cc[ht];
          if (Tt == H)
            Re = Re.prev;
          else if (Tt != g)
            break;
        }
      for (; (Re.type == "stat" || Re.type == "form") && (ve == "}" || (Je = P.cc[P.cc.length - 1]) && (Je == z || Je == b) && !/^[,\.=+\-*:?[\(]/.test(Q)); )
        Re = Re.prev;
      n && Re.type == ")" && Re.prev.type == "stat" && (Re = Re.prev);
      var Or = Re.type, ai = ve == Or;
      return Or == "vardef" ? Re.indented + (P.lastType == "operator" || P.lastType == "," ? Re.info.length + 1 : 0) : Or == "form" && ve == "{" ? Re.indented : Or == "form" ? Re.indented + r : Or == "stat" ? Re.indented + (cW(P, Q) ? n || r : 0) : Re.info == "switch" && !ai && t.doubleIndentSwitch != !1 ? Re.indented + (/^(?:case|default)\b/.test(Q) ? r : 2 * r) : Re.align ? Re.column + (ai ? 0 : 1) : Re.indented + (ai ? 0 : r);
    },
    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
    blockCommentStart: s ? null : "/*",
    blockCommentEnd: s ? null : "*/",
    blockCommentContinue: s ? null : " * ",
    lineComment: s ? null : "//",
    fold: "brace",
    closeBrackets: "()[]{}''\"\"``",
    helperType: s ? "json" : "javascript",
    jsonldMode: o,
    jsonMode: s,
    expressionAllowed: $A,
    skipExpression: function(P) {
      var Q = P.cc[P.cc.length - 1];
      (Q == ee || Q == ge) && P.cc.pop();
    }
  };
});
CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);
CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/x-javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", { name: "javascript", json: !0 });
CodeMirror.defineMIME("application/x-json", { name: "javascript", json: !0 });
CodeMirror.defineMIME("application/ld+json", {
  name: "javascript",
  jsonld: !0
});
CodeMirror.defineMIME("text/typescript", {
  name: "javascript",
  typescript: !0
});
CodeMirror.defineMIME("application/typescript", {
  name: "javascript",
  typescript: !0
});
window.CodeMirror.defineMode("turtle", function(e) {
  var t = e.indentUnit, r;
  function n(c) {
    return new RegExp("^(?:" + c.join("|") + ")$", "i");
  }
  n([]);
  var o = n(["@prefix", "@base", "a"]), s = /[*+\-<>=&|]/;
  function a(c, d) {
    var h = c.next();
    if (r = null, h == "<" && !c.match(/^[\s\u00a0=]/, !1))
      return c.match(/^[^\s\u00a0>]*>?/), "atom";
    if (h == '"' || h == "'")
      return d.tokenize = l(h), d.tokenize(c, d);
    if (/[{}\(\),\.;\[\]]/.test(h))
      return r = h, null;
    if (h == "#")
      return c.skipToEnd(), "comment";
    if (s.test(h))
      return c.eatWhile(s), null;
    if (h == ":")
      return "operator";
    if (c.eatWhile(/[_\w\d]/), c.peek() == ":")
      return "variable-3";
    var p = c.current();
    return o.test(p) ? "meta" : h >= "A" && h <= "Z" ? "comment" : "keyword";
    var p = c.current();
  }
  function l(c) {
    return function(d, h) {
      for (var p = !1, m; (m = d.next()) != null; ) {
        if (m == c && !p) {
          h.tokenize = a;
          break;
        }
        p = !p && m == "\\";
      }
      return "string";
    };
  }
  function u(c, d, h) {
    c.context = {
      prev: c.context,
      indent: c.indent,
      col: h,
      type: d
    };
  }
  function f(c) {
    c.indent = c.context.indent, c.context = c.context.prev;
  }
  return {
    startState: function() {
      return { tokenize: a, context: null, indent: 0, col: 0 };
    },
    token: function(c, d) {
      if (c.sol() && (d.context && d.context.align == null && (d.context.align = !1), d.indent = c.indentation()), c.eatSpace())
        return null;
      var h = d.tokenize(c, d);
      if (h != "comment" && d.context && d.context.align == null && d.context.type != "pattern" && (d.context.align = !0), r == "(")
        u(d, ")", c.column());
      else if (r == "[")
        u(d, "]", c.column());
      else if (r == "{")
        u(d, "}", c.column());
      else if (/[\]\}\)]/.test(r)) {
        for (; d.context && d.context.type == "pattern"; )
          f(d);
        d.context && r == d.context.type && f(d);
      } else
        r == "." && d.context && d.context.type == "pattern" ? f(d) : /atom|string|variable/.test(h) && d.context && (/[\}\]]/.test(d.context.type) ? u(d, "pattern", c.column()) : d.context.type == "pattern" && !d.context.align && (d.context.align = !0, d.context.col = c.column()));
      return h;
    },
    indent: function(c, d) {
      var h = d && d.charAt(0), p = c.context;
      if (/[\]\}]/.test(h))
        for (; p && p.type == "pattern"; )
          p = p.prev;
      var m = p && h == p.type;
      return p ? p.type == "pattern" ? p.col : p.align ? p.col + (m ? 0 : 1) : p.indent + (m ? 0 : t) : 0;
    },
    lineComment: "#"
  };
});
CodeMirror.defineMIME("text/turtle", "turtle");
CodeMirror.defineMIME("text/n3", "turtle");
CodeMirror.defineMIME("application/trig", "turtle");
window.CodeMirror.defineMode("ntriples", function() {
  var e = {
    PRE_SUBJECT: 0,
    WRITING_SUB_URI: 1,
    WRITING_BNODE_URI: 2,
    PRE_PRED: 3,
    WRITING_PRED_URI: 4,
    PRE_OBJ: 5,
    WRITING_OBJ_URI: 6,
    WRITING_OBJ_BNODE: 7,
    WRITING_OBJ_LITERAL: 8,
    WRITING_LIT_LANG: 9,
    WRITING_LIT_TYPE: 10,
    POST_OBJ: 11,
    ERROR: 12
  };
  function t(r, n) {
    var o = r.location, s;
    o == e.PRE_SUBJECT && n == "<" ? s = e.WRITING_SUB_URI : o == e.PRE_SUBJECT && n == "_" ? s = e.WRITING_BNODE_URI : o == e.PRE_PRED && n == "<" ? s = e.WRITING_PRED_URI : o == e.PRE_OBJ && n == "<" ? s = e.WRITING_OBJ_URI : o == e.PRE_OBJ && n == "_" ? s = e.WRITING_OBJ_BNODE : o == e.PRE_OBJ && n == '"' ? s = e.WRITING_OBJ_LITERAL : o == e.WRITING_SUB_URI && n == ">" || o == e.WRITING_BNODE_URI && n == " " ? s = e.PRE_PRED : o == e.WRITING_PRED_URI && n == ">" ? s = e.PRE_OBJ : o == e.WRITING_OBJ_URI && n == ">" || o == e.WRITING_OBJ_BNODE && n == " " || o == e.WRITING_OBJ_LITERAL && n == '"' || o == e.WRITING_LIT_LANG && n == " " || o == e.WRITING_LIT_TYPE && n == ">" ? s = e.POST_OBJ : o == e.WRITING_OBJ_LITERAL && n == "@" ? s = e.WRITING_LIT_LANG : o == e.WRITING_OBJ_LITERAL && n == "^" ? s = e.WRITING_LIT_TYPE : n == " " && (o == e.PRE_SUBJECT || o == e.PRE_PRED || o == e.PRE_OBJ || o == e.POST_OBJ) ? s = o : o == e.POST_OBJ && n == "." ? s = e.PRE_SUBJECT : s = e.ERROR, r.location = s;
  }
  return {
    startState: function() {
      return {
        location: e.PRE_SUBJECT,
        uris: [],
        anchors: [],
        bnodes: [],
        langs: [],
        types: []
      };
    },
    token: function(r, n) {
      var o = r.next();
      if (o == "<") {
        t(n, o);
        var s = "";
        return r.eatWhile(function(c) {
          return c != "#" && c != ">" ? (s += c, !0) : !1;
        }), n.uris.push(s), r.match("#", !1) || (r.next(), t(n, ">")), "variable";
      }
      if (o == "#") {
        var a = "";
        return r.eatWhile(function(c) {
          return c != ">" && c != " " ? (a += c, !0) : !1;
        }), n.anchors.push(a), "variable-2";
      }
      if (o == ">")
        return t(n, ">"), "variable";
      if (o == "_") {
        t(n, o);
        var l = "";
        return r.eatWhile(function(c) {
          return c != " " ? (l += c, !0) : !1;
        }), n.bnodes.push(l), r.next(), t(n, " "), "builtin";
      }
      if (o == '"')
        return t(n, o), r.eatWhile(function(c) {
          return c != '"';
        }), r.next(), r.peek() != "@" && r.peek() != "^" && t(n, '"'), "string";
      if (o == "@") {
        t(n, "@");
        var u = "";
        return r.eatWhile(function(c) {
          return c != " " ? (u += c, !0) : !1;
        }), n.langs.push(u), r.next(), t(n, " "), "string-2";
      }
      if (o == "^") {
        r.next(), t(n, "^");
        var f = "";
        return r.eatWhile(function(c) {
          return c != ">" ? (f += c, !0) : !1;
        }), n.types.push(f), r.next(), t(n, ">"), "variable";
      }
      o == " " && t(n, o), o == "." && t(n, o);
    }
  };
});
CodeMirror.defineMIME("application/n-triples", "ntriples");
CodeMirror.defineMIME("application/n-quads", "ntriples");
CodeMirror.defineMIME("text/n-triples", "ntriples");
var Ohe = {
  autoSelfClosers: {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    command: !0,
    embed: !0,
    frame: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
    menuitem: !0
  },
  implicitlyClosed: {
    dd: !0,
    li: !0,
    optgroup: !0,
    option: !0,
    p: !0,
    rp: !0,
    rt: !0,
    tbody: !0,
    td: !0,
    tfoot: !0,
    th: !0,
    tr: !0
  },
  contextGrabbers: {
    dd: { dd: !0, dt: !0 },
    dt: { dd: !0, dt: !0 },
    li: { li: !0 },
    option: { option: !0, optgroup: !0 },
    optgroup: { optgroup: !0 },
    p: {
      address: !0,
      article: !0,
      aside: !0,
      blockquote: !0,
      dir: !0,
      div: !0,
      dl: !0,
      fieldset: !0,
      footer: !0,
      form: !0,
      h1: !0,
      h2: !0,
      h3: !0,
      h4: !0,
      h5: !0,
      h6: !0,
      header: !0,
      hgroup: !0,
      hr: !0,
      menu: !0,
      nav: !0,
      ol: !0,
      p: !0,
      pre: !0,
      section: !0,
      table: !0,
      ul: !0
    },
    rp: { rp: !0, rt: !0 },
    rt: { rp: !0, rt: !0 },
    tbody: { tbody: !0, tfoot: !0 },
    td: { td: !0, th: !0 },
    tfoot: { tbody: !0 },
    th: { td: !0, th: !0 },
    thead: { tbody: !0, tfoot: !0 },
    tr: { tr: !0 }
  },
  doNotIndent: { pre: !0 },
  allowUnquoted: !0,
  allowMissing: !0,
  caseFold: !0
}, Phe = {
  autoSelfClosers: {},
  implicitlyClosed: {},
  contextGrabbers: {},
  doNotIndent: {},
  allowUnquoted: !1,
  allowMissing: !1,
  allowMissingTagName: !1,
  caseFold: !1
};
window.CodeMirror.defineMode("xml", function(e, t) {
  var r = e.indentUnit, n = {}, o = t.htmlMode ? Ohe : Phe;
  for (var s in o)
    n[s] = o[s];
  for (var s in t)
    n[s] = t[s];
  var a, l;
  function u($, V) {
    function M(U) {
      return V.tokenize = U, U($, V);
    }
    var W = $.next();
    if (W == "<")
      return $.eat("!") ? $.eat("[") ? $.match("CDATA[") ? M(d("atom", "]]>")) : null : $.match("--") ? M(d("comment", "-->")) : $.match("DOCTYPE", !0, !0) ? ($.eatWhile(/[\w\._\-]/), M(h(1))) : null : $.eat("?") ? ($.eatWhile(/[\w\._\-]/), V.tokenize = d("meta", "?>"), "meta") : (a = $.eat("/") ? "closeTag" : "openTag", V.tokenize = f, "tag bracket");
    if (W == "&") {
      var k;
      return $.eat("#") ? $.eat("x") ? k = $.eatWhile(/[a-fA-F\d]/) && $.eat(";") : k = $.eatWhile(/[\d]/) && $.eat(";") : k = $.eatWhile(/[\w\.\-:]/) && $.eat(";"), k ? "atom" : "error";
    } else
      return $.eatWhile(/[^&<]/), null;
  }
  u.isInText = !0;
  function f($, V) {
    var M = $.next();
    if (M == ">" || M == "/" && $.eat(">"))
      return V.tokenize = u, a = M == ">" ? "endTag" : "selfcloseTag", "tag bracket";
    if (M == "=")
      return a = "equals", null;
    if (M == "<") {
      V.tokenize = u, V.state = _, V.tagName = V.tagStart = null;
      var W = V.tokenize($, V);
      return W ? W + " tag error" : "tag error";
    } else
      return /[\'\"]/.test(M) ? (V.tokenize = c(M), V.stringStartCol = $.column(), V.tokenize($, V)) : ($.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/), "word");
  }
  function c($) {
    var V = function(M, W) {
      for (; !M.eol(); )
        if (M.next() == $) {
          W.tokenize = f;
          break;
        }
      return "string";
    };
    return V.isInAttribute = !0, V;
  }
  function d($, V) {
    return function(M, W) {
      for (; !M.eol(); ) {
        if (M.match(V)) {
          W.tokenize = u;
          break;
        }
        M.next();
      }
      return $;
    };
  }
  function h($) {
    return function(V, M) {
      for (var W; (W = V.next()) != null; ) {
        if (W == "<")
          return M.tokenize = h($ + 1), M.tokenize(V, M);
        if (W == ">")
          if ($ == 1) {
            M.tokenize = u;
            break;
          } else
            return M.tokenize = h($ - 1), M.tokenize(V, M);
      }
      return "meta";
    };
  }
  function p($, V, M) {
    this.prev = $.context, this.tagName = V, this.indent = $.indented, this.startOfLine = M, (n.doNotIndent.hasOwnProperty(V) || $.context && $.context.noIndent) && (this.noIndent = !0);
  }
  function m($) {
    $.context && ($.context = $.context.prev);
  }
  function y($, V) {
    for (var M; ; ) {
      if (!$.context || (M = $.context.tagName, !n.contextGrabbers.hasOwnProperty(M) || !n.contextGrabbers[M].hasOwnProperty(V)))
        return;
      m($);
    }
  }
  function _($, V, M) {
    return $ == "openTag" ? (M.tagStart = V.column(), S) : $ == "closeTag" ? x : _;
  }
  function S($, V, M) {
    return $ == "word" ? (M.tagName = V.current(), l = "tag", I) : n.allowMissingTagName && $ == "endTag" ? (l = "tag bracket", I($, V, M)) : (l = "error", S);
  }
  function x($, V, M) {
    if ($ == "word") {
      var W = V.current();
      return M.context && M.context.tagName != W && n.implicitlyClosed.hasOwnProperty(M.context.tagName) && m(M), M.context && M.context.tagName == W || n.matchClosing === !1 ? (l = "tag", E) : (l = "tag error", C);
    } else
      return n.allowMissingTagName && $ == "endTag" ? (l = "tag bracket", E($, V, M)) : (l = "error", C);
  }
  function E($, V, M) {
    return $ != "endTag" ? (l = "error", E) : (m(M), _);
  }
  function C($, V, M) {
    return l = "error", E($, V, M);
  }
  function I($, V, M) {
    if ($ == "word")
      return l = "attribute", j;
    if ($ == "endTag" || $ == "selfcloseTag") {
      var W = M.tagName, k = M.tagStart;
      return M.tagName = M.tagStart = null, $ == "selfcloseTag" || n.autoSelfClosers.hasOwnProperty(W) ? y(M, W) : (y(M, W), M.context = new p(M, W, k == M.indented)), _;
    }
    return l = "error", I;
  }
  function j($, V, M) {
    return $ == "equals" ? J : (n.allowMissing || (l = "error"), I($, V, M));
  }
  function J($, V, M) {
    return $ == "string" ? G : $ == "word" && n.allowUnquoted ? (l = "string", I) : (l = "error", I($, V, M));
  }
  function G($, V, M) {
    return $ == "string" ? G : I($, V, M);
  }
  return {
    startState: function($) {
      var V = {
        tokenize: u,
        state: _,
        indented: $ || 0,
        tagName: null,
        tagStart: null,
        context: null
      };
      return $ != null && (V.baseIndent = $), V;
    },
    token: function($, V) {
      if (!V.tagName && $.sol() && (V.indented = $.indentation()), $.eatSpace())
        return null;
      a = null;
      var M = V.tokenize($, V);
      return (M || a) && M != "comment" && (l = null, V.state = V.state(a || M, $, V), l && (M = l == "error" ? M + " error" : l)), M;
    },
    indent: function($, V, M) {
      var W = $.context;
      if ($.tokenize.isInAttribute)
        return $.tagStart == $.indented ? $.stringStartCol + 1 : $.indented + r;
      if (W && W.noIndent)
        return CodeMirror.Pass;
      if ($.tokenize != f && $.tokenize != u)
        return M ? M.match(/^(\s*)/)[0].length : 0;
      if ($.tagName)
        return n.multilineTagIndentPastTag !== !1 ? $.tagStart + $.tagName.length + 2 : $.tagStart + r * (n.multilineTagIndentFactor || 1);
      if (n.alignCDATA && /<!\[CDATA\[/.test(V))
        return 0;
      var k = V && /^<(\/)?([\w_:\.-]*)/.exec(V);
      if (k && k[1])
        for (; W; )
          if (W.tagName == k[2]) {
            W = W.prev;
            break;
          } else if (n.implicitlyClosed.hasOwnProperty(W.tagName))
            W = W.prev;
          else
            break;
      else if (k)
        for (; W; ) {
          var U = n.contextGrabbers[W.tagName];
          if (U && U.hasOwnProperty(k[2]))
            W = W.prev;
          else
            break;
        }
      for (; W && W.prev && !W.startOfLine; )
        W = W.prev;
      return W ? W.indent + r : $.baseIndent || 0;
    },
    electricInput: /<\/[\s\w:]+>$/,
    blockCommentStart: "<!--",
    blockCommentEnd: "-->",
    configuration: n.htmlMode ? "html" : "xml",
    helperType: n.htmlMode ? "html" : "xml",
    skipAttribute: function($) {
      $.state == J && ($.state = I);
    },
    xmlCurrentTag: function($) {
      return $.tagName ? { name: $.tagName, close: $.type == "closeTag" } : null;
    },
    xmlCurrentContext: function($) {
      for (var V = [], M = $.context; M; M = M.prev)
        M.tagName && V.push(M.tagName);
      return V.reverse();
    }
  };
});
CodeMirror.defineMIME("text/xml", "xml");
CodeMirror.defineMIME("application/xml", "xml");
CodeMirror.mimeModes.hasOwnProperty("text/html") || CodeMirror.defineMIME("text/html", { name: "xml", htmlMode: !0 });
const Sd = Symbol("parsed quads");
class Dhe extends Lhe {
  static get properties() {
    return {
      format: { type: String, reflect: !0 },
      quads: { type: Array },
      noReserialize: { type: Boolean, attribute: "no-reserialize" }
    };
  }
  constructor() {
    super(), this.isParsing = !1, this.noReserialize = !1;
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.ready = null;
  }
  /**
   * Gets or set RDF/JS quads. Setting will parse them using the chosen `format` and set to the text editor
   *
   * @returns {Quad[]}
   */
  get quads() {
    return this[Sd];
  }
  set quads(t) {
    if (typeof t > "u" || t === null)
      return;
    const r = this[Sd];
    this[Sd] = t, this.requestUpdate("quads", r);
  }
  async updated(t) {
    super.updated(t);
    let r = !1, n = !1;
    const o = this.quads && this.quads.length > 0;
    t.has("format") && (r = o && !this.noReserialize, n = !r), t.has("quads") && (r = !0), (t.has("prefixes") || t.has("customPrefixes")) && (r = o), n ? this.parse() : r && this.__serialize();
  }
  async _parse() {
    const { toStream: t } = await import("./stream-Cbm-YXkP.js"), r = t(this.value), n = [], o = {}, s = this.$rdf.formats.parsers.import(
      this.format,
      r
    );
    if (!s) {
      this.dispatchEvent(
        new CustomEvent("parsing-failed", {
          detail: {
            notFound: !0
          }
        })
      );
      return;
    }
    s.on("prefix", (a, l) => {
      o[a] = l;
    });
    for await (const a of s)
      n.push(a);
    this[Sd] = n, this.dispatchEvent(
      new CustomEvent("quads-changed", {
        detail: {
          value: n
        }
      })
    ), this.__notifyParsedPrefixes(o);
  }
  async __serialize() {
    if (!this.format)
      return;
    await this.ready;
    const { Readable: t } = await import("./stream-Cbm-YXkP.js"), r = [...this.quads || []], n = new t({
      objectMode: !0,
      read() {
        if (r.length === 0) {
          this.push(null);
          return;
        }
        this.push(r.shift());
      }
    }), o = this.$rdf.formats.serializers.import(
      this.format,
      n,
      {
        prefixes: await this._combinePrefixes()
      }
    );
    if (!o) {
      this.value = `No serializer found for media type ${this.format}`;
      return;
    }
    let s = "";
    for await (const a of o)
      s += a;
    this.format === ti.jsonLd && (s = JSON.stringify(JSON.parse(s), null, 2)), this.value = s, this.dispatchEvent(
      new CustomEvent("serialized", {
        detail: {
          value: s
        }
      })
    );
  }
  // eslint-disable-next-line class-methods-use-this
  _errorLine(t) {
    const r = { message: t.message };
    return t.context && t.context.line && (r.from = { line: t.context.line - 1, ch: 0 }, r.to = {
      line: t.context.line - 1,
      ch: Number.MAX_SAFE_INTEGER
    }), r;
  }
  __notifyParsedPrefixes(t) {
    const r = {}, n = { ...t };
    for (const [o, s] of Object.entries(t))
      o in TE && (r[o] = s, delete n[o]);
    this.dispatchEvent(
      new CustomEvent("prefixes-parsed", {
        detail: {
          prefixes: {
            ...r,
            ...n
          }
        }
      })
    );
  }
}
const PB = new mp([pD, lu]);
PB.formats.import(On);
window.customElements.define(
  "rdf-editor",
  class extends vse(Dhe, PB) {
  }
);
function $r(e, t, ...r) {
  if (e in t) {
    let o = t[e];
    return typeof o == "function" ? o(...r) : o;
  }
  let n = new Error(`Tried to handle "${e}" but there is no handler defined. Only defined handlers are: ${Object.keys(t).map((o) => `"${o}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(n, $r), n;
}
var Na = ((e) => (e[e.None = 0] = "None", e[e.RenderStrategy = 1] = "RenderStrategy", e[e.Static = 2] = "Static", e))(Na || {}), Fhe = ((e) => (e[e.Unmount = 0] = "Unmount", e[e.Hidden = 1] = "Hidden", e))(Fhe || {});
function fr({ visible: e = !0, features: t = 0, ourProps: r, theirProps: n, ...o }) {
  var s;
  let a = FB(n, r), l = Object.assign(o, { props: a });
  if (e || t & 2 && a.static)
    return R0(l);
  if (t & 1) {
    let u = (s = a.unmount) == null || s ? 0 : 1;
    return $r(u, { 0() {
      return null;
    }, 1() {
      return R0({ ...o, props: { ...a, hidden: !0, style: { display: "none" } } });
    } });
  }
  return R0(l);
}
function R0({ props: e, attrs: t, slots: r, slot: n, name: o }) {
  var s, a;
  let { as: l, ...u } = Pg(e, ["unmount", "static"]), f = (s = r.default) == null ? void 0 : s.call(r, n), c = {};
  if (n) {
    let d = !1, h = [];
    for (let [p, m] of Object.entries(n))
      typeof m == "boolean" && (d = !0), m === !0 && h.push(p);
    d && (c["data-headlessui-state"] = h.join(" "));
  }
  if (l === "template") {
    if (f = DB(f ?? []), Object.keys(u).length > 0 || Object.keys(t).length > 0) {
      let [d, ...h] = f ?? [];
      if (!jhe(d) || h.length > 0)
        throw new Error(['Passing props on "template"!', "", `The current component <${o} /> is rendering a "template".`, "However we need to passthrough the following props:", Object.keys(u).concat(Object.keys(t)).map((y) => y.trim()).filter((y, _, S) => S.indexOf(y) === _).sort((y, _) => y.localeCompare(_)).map((y) => `  - ${y}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map((y) => `  - ${y}`).join(`
`)].join(`
`));
      let p = FB((a = d.props) != null ? a : {}, u), m = Xn(d, p);
      for (let y in p)
        y.startsWith("on") && (m.props || (m.props = {}), m.props[y] = p[y]);
      return m;
    }
    return Array.isArray(f) && f.length === 1 ? f[0] : f;
  }
  return Ut(l, Object.assign({}, u, c), { default: () => f });
}
function DB(e) {
  return e.flatMap((t) => t.type === lt ? DB(t.children) : [t]);
}
function FB(...e) {
  if (e.length === 0)
    return {};
  if (e.length === 1)
    return e[0];
  let t = {}, r = {};
  for (let n of e)
    for (let o in n)
      o.startsWith("on") && typeof n[o] == "function" ? (r[o] != null || (r[o] = []), r[o].push(n[o])) : t[o] = n[o];
  if (t.disabled || t["aria-disabled"])
    return Object.assign(t, Object.fromEntries(Object.keys(r).map((n) => [n, void 0])));
  for (let n in r)
    Object.assign(t, { [n](o, ...s) {
      let a = r[n];
      for (let l of a) {
        if (o instanceof Event && o.defaultPrevented)
          return;
        l(o, ...s);
      }
    } });
  return t;
}
function UR(e) {
  let t = Object.assign({}, e);
  for (let r in t)
    t[r] === void 0 && delete t[r];
  return t;
}
function Pg(e, t = []) {
  let r = Object.assign({}, e);
  for (let n of t)
    n in r && delete r[n];
  return r;
}
function jhe(e) {
  return e == null ? !1 : typeof e.type == "string" || typeof e.type == "object" || typeof e.type == "function";
}
let Bhe = 0;
function qhe() {
  return ++Bhe;
}
function ri() {
  return qhe();
}
var tt = ((e) => (e.Space = " ", e.Enter = "Enter", e.Escape = "Escape", e.Backspace = "Backspace", e.Delete = "Delete", e.ArrowLeft = "ArrowLeft", e.ArrowUp = "ArrowUp", e.ArrowRight = "ArrowRight", e.ArrowDown = "ArrowDown", e.Home = "Home", e.End = "End", e.PageUp = "PageUp", e.PageDown = "PageDown", e.Tab = "Tab", e))(tt || {});
function Whe(e) {
  throw new Error("Unexpected object: " + e);
}
var Ct = ((e) => (e[e.First = 0] = "First", e[e.Previous = 1] = "Previous", e[e.Next = 2] = "Next", e[e.Last = 3] = "Last", e[e.Specific = 4] = "Specific", e[e.Nothing = 5] = "Nothing", e))(Ct || {});
function jB(e, t) {
  let r = t.resolveItems();
  if (r.length <= 0)
    return null;
  let n = t.resolveActiveIndex(), o = n ?? -1, s = (() => {
    switch (e.focus) {
      case 0:
        return r.findIndex((a) => !t.resolveDisabled(a));
      case 1: {
        let a = r.slice().reverse().findIndex((l, u, f) => o !== -1 && f.length - u - 1 >= o ? !1 : !t.resolveDisabled(l));
        return a === -1 ? a : r.length - 1 - a;
      }
      case 2:
        return r.findIndex((a, l) => l <= o ? !1 : !t.resolveDisabled(a));
      case 3: {
        let a = r.slice().reverse().findIndex((l) => !t.resolveDisabled(l));
        return a === -1 ? a : r.length - 1 - a;
      }
      case 4:
        return r.findIndex((a) => t.resolveId(a) === e.id);
      case 5:
        return null;
      default:
        Whe(e);
    }
  })();
  return s === -1 ? n : s;
}
function Be(e) {
  var t;
  return e == null || e.value == null ? null : (t = e.value.$el) != null ? t : e.value;
}
let BB = Symbol("Context");
var dn = ((e) => (e[e.Open = 1] = "Open", e[e.Closed = 2] = "Closed", e[e.Closing = 4] = "Closing", e[e.Opening = 8] = "Opening", e))(dn || {});
function HR() {
  return yr(BB, null);
}
function qB(e) {
  Tn(BB, e);
}
function x2(e, t) {
  if (e)
    return e;
  let r = t ?? "button";
  if (typeof r == "string" && r.toLowerCase() === "button")
    return "button";
}
function zR(e, t) {
  let r = $e(x2(e.value.type, e.value.as));
  return Dt(() => {
    r.value = x2(e.value.type, e.value.as);
  }), Qn(() => {
    var n;
    r.value || Be(t) && Be(t) instanceof HTMLButtonElement && !((n = Be(t)) != null && n.hasAttribute("type")) && (r.value = "button");
  }), r;
}
var Uhe = Object.defineProperty, Hhe = (e, t, r) => t in e ? Uhe(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, R2 = (e, t, r) => (Hhe(e, typeof t != "symbol" ? t + "" : t, r), r);
let zhe = class {
  constructor() {
    R2(this, "current", this.detect()), R2(this, "currentId", 0);
  }
  set(t) {
    this.current !== t && (this.currentId = 0, this.current = t);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
}, Dg = new zhe();
function Yn(e) {
  if (Dg.isServer)
    return null;
  if (e instanceof Node)
    return e.ownerDocument;
  if (e != null && e.hasOwnProperty("value")) {
    let t = Be(e);
    if (t)
      return t.ownerDocument;
  }
  return document;
}
function WB({ container: e, accept: t, walk: r, enabled: n }) {
  Qn(() => {
    let o = e.value;
    if (!o || n !== void 0 && !n.value)
      return;
    let s = Yn(e);
    if (!s)
      return;
    let a = Object.assign((u) => t(u), { acceptNode: t }), l = s.createTreeWalker(o, NodeFilter.SHOW_ELEMENT, a, !1);
    for (; l.nextNode(); )
      r(l.currentNode);
  });
}
let aE = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e) => `${e}:not([tabindex='-1'])`).join(",");
var Qr = ((e) => (e[e.First = 1] = "First", e[e.Previous = 2] = "Previous", e[e.Next = 4] = "Next", e[e.Last = 8] = "Last", e[e.WrapAround = 16] = "WrapAround", e[e.NoScroll = 32] = "NoScroll", e))(Qr || {}), Wh = ((e) => (e[e.Error = 0] = "Error", e[e.Overflow = 1] = "Overflow", e[e.Success = 2] = "Success", e[e.Underflow = 3] = "Underflow", e))(Wh || {}), Ghe = ((e) => (e[e.Previous = -1] = "Previous", e[e.Next = 1] = "Next", e))(Ghe || {});
function UB(e = document.body) {
  return e == null ? [] : Array.from(e.querySelectorAll(aE)).sort((t, r) => Math.sign((t.tabIndex || Number.MAX_SAFE_INTEGER) - (r.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var Fg = ((e) => (e[e.Strict = 0] = "Strict", e[e.Loose = 1] = "Loose", e))(Fg || {});
function jg(e, t = 0) {
  var r;
  return e === ((r = Yn(e)) == null ? void 0 : r.body) ? !1 : $r(t, { 0() {
    return e.matches(aE);
  }, 1() {
    let n = e;
    for (; n !== null; ) {
      if (n.matches(aE))
        return !0;
      n = n.parentElement;
    }
    return !1;
  } });
}
function HB(e) {
  let t = Yn(e);
  gr(() => {
    t && !jg(t.activeElement, 0) && rs(e);
  });
}
var Vhe = ((e) => (e[e.Keyboard = 0] = "Keyboard", e[e.Mouse = 1] = "Mouse", e))(Vhe || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (e) => {
  e.metaKey || e.altKey || e.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (e) => {
  e.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function rs(e) {
  e == null || e.focus({ preventScroll: !0 });
}
let Khe = ["textarea", "input"].join(",");
function Yhe(e) {
  var t, r;
  return (r = (t = e == null ? void 0 : e.matches) == null ? void 0 : t.call(e, Khe)) != null ? r : !1;
}
function Bg(e, t = (r) => r) {
  return e.slice().sort((r, n) => {
    let o = t(r), s = t(n);
    if (o === null || s === null)
      return 0;
    let a = o.compareDocumentPosition(s);
    return a & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : a & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function Xhe(e, t) {
  return va(UB(), t, { relativeTo: e });
}
function va(e, t, { sorted: r = !0, relativeTo: n = null, skipElements: o = [] } = {}) {
  var s;
  let a = (s = Array.isArray(e) ? e.length > 0 ? e[0].ownerDocument : document : e == null ? void 0 : e.ownerDocument) != null ? s : document, l = Array.isArray(e) ? r ? Bg(e) : e : UB(e);
  o.length > 0 && l.length > 1 && (l = l.filter((m) => !o.includes(m))), n = n ?? a.activeElement;
  let u = (() => {
    if (t & 5)
      return 1;
    if (t & 10)
      return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), f = (() => {
    if (t & 1)
      return 0;
    if (t & 2)
      return Math.max(0, l.indexOf(n)) - 1;
    if (t & 4)
      return Math.max(0, l.indexOf(n)) + 1;
    if (t & 8)
      return l.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), c = t & 32 ? { preventScroll: !0 } : {}, d = 0, h = l.length, p;
  do {
    if (d >= h || d + h <= 0)
      return 0;
    let m = f + d;
    if (t & 16)
      m = (m + h) % h;
    else {
      if (m < 0)
        return 3;
      if (m >= h)
        return 1;
    }
    p = l[m], p == null || p.focus(c), d += u;
  } while (p !== a.activeElement);
  return t & 6 && Yhe(p) && p.select(), 2;
}
function A2(e, t, r) {
  Dg.isServer || Qn((n) => {
    document.addEventListener(e, t, r), n(() => document.removeEventListener(e, t, r));
  });
}
function zB(e, t, r) {
  Dg.isServer || Qn((n) => {
    window.addEventListener(e, t, r), n(() => window.removeEventListener(e, t, r));
  });
}
function GR(e, t, r = Ne(() => !0)) {
  function n(s, a) {
    if (!r.value || s.defaultPrevented)
      return;
    let l = a(s);
    if (l === null || !l.getRootNode().contains(l))
      return;
    let u = function f(c) {
      return typeof c == "function" ? f(c()) : Array.isArray(c) || c instanceof Set ? c : [c];
    }(e);
    for (let f of u) {
      if (f === null)
        continue;
      let c = f instanceof HTMLElement ? f : Be(f);
      if (c != null && c.contains(l) || s.composed && s.composedPath().includes(c))
        return;
    }
    return !jg(l, Fg.Loose) && l.tabIndex !== -1 && s.preventDefault(), t(s, l);
  }
  let o = $e(null);
  A2("mousedown", (s) => {
    var a, l;
    r.value && (o.value = ((l = (a = s.composedPath) == null ? void 0 : a.call(s)) == null ? void 0 : l[0]) || s.target);
  }, !0), A2("click", (s) => {
    o.value && (n(s, () => o.value), o.value = null);
  }, !0), zB("blur", (s) => n(s, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
var La = ((e) => (e[e.None = 1] = "None", e[e.Focusable = 2] = "Focusable", e[e.Hidden = 4] = "Hidden", e))(La || {});
let ou = nt({ name: "Hidden", props: { as: { type: [Object, String], default: "div" }, features: { type: Number, default: 1 } }, setup(e, { slots: t, attrs: r }) {
  return () => {
    let { features: n, ...o } = e, s = { "aria-hidden": (n & 2) === 2 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(n & 4) === 4 && (n & 2) !== 2 && { display: "none" } } };
    return fr({ ourProps: s, theirProps: o, slot: {}, attrs: r, slots: t, name: "Hidden" });
  };
} });
function VR(e = {}, t = null, r = []) {
  for (let [n, o] of Object.entries(e))
    VB(r, GB(t, n), o);
  return r;
}
function GB(e, t) {
  return e ? e + "[" + t + "]" : t;
}
function VB(e, t, r) {
  if (Array.isArray(r))
    for (let [n, o] of r.entries())
      VB(e, GB(t, n.toString()), o);
  else
    r instanceof Date ? e.push([t, r.toISOString()]) : typeof r == "boolean" ? e.push([t, r ? "1" : "0"]) : typeof r == "string" ? e.push([t, r]) : typeof r == "number" ? e.push([t, `${r}`]) : r == null ? e.push([t, ""]) : VR(r, t, e);
}
function KB(e) {
  var t;
  let r = (t = e == null ? void 0 : e.form) != null ? t : e.closest("form");
  if (r) {
    for (let n of r.elements)
      if (n.tagName === "INPUT" && n.type === "submit" || n.tagName === "BUTTON" && n.type === "submit" || n.nodeName === "INPUT" && n.type === "image") {
        n.click();
        return;
      }
  }
}
function KR(e, t, r) {
  let n = $e(r == null ? void 0 : r.value), o = Ne(() => e.value !== void 0);
  return [Ne(() => o.value ? e.value : n.value), function(s) {
    return o.value || (n.value = s), t == null ? void 0 : t(s);
  }];
}
function T2(e) {
  return [e.screenX, e.screenY];
}
function YB() {
  let e = $e([-1, -1]);
  return { wasMoved(t) {
    let r = T2(t);
    return e.value[0] === r[0] && e.value[1] === r[1] ? !1 : (e.value = r, !0);
  }, update(t) {
    e.value = T2(t);
  } };
}
function Jhe() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function XB() {
  let e = [], t = { addEventListener(r, n, o, s) {
    return r.addEventListener(n, o, s), t.add(() => r.removeEventListener(n, o, s));
  }, requestAnimationFrame(...r) {
    let n = requestAnimationFrame(...r);
    t.add(() => cancelAnimationFrame(n));
  }, nextFrame(...r) {
    t.requestAnimationFrame(() => {
      t.requestAnimationFrame(...r);
    });
  }, setTimeout(...r) {
    let n = setTimeout(...r);
    t.add(() => clearTimeout(n));
  }, style(r, n, o) {
    let s = r.style.getPropertyValue(n);
    return Object.assign(r.style, { [n]: o }), this.add(() => {
      Object.assign(r.style, { [n]: s });
    });
  }, group(r) {
    let n = XB();
    return r(n), this.add(() => n.dispose());
  }, add(r) {
    return e.push(r), () => {
      let n = e.indexOf(r);
      if (n >= 0)
        for (let o of e.splice(n, 1))
          o();
    };
  }, dispose() {
    for (let r of e.splice(0))
      r();
  } };
  return t;
}
var nf = ((e) => (e[e.Forwards = 0] = "Forwards", e[e.Backwards = 1] = "Backwards", e))(nf || {});
function Qhe() {
  let e = $e(0);
  return zB("keydown", (t) => {
    t.key === "Tab" && (e.value = t.shiftKey ? 1 : 0);
  }), e;
}
function JB(e, t, r, n) {
  Dg.isServer || Qn((o) => {
    e = e ?? window, e.addEventListener(t, r, n), o(() => e.removeEventListener(t, r, n));
  });
}
function QB(e) {
  typeof queueMicrotask == "function" ? queueMicrotask(e) : Promise.resolve().then(e).catch((t) => setTimeout(() => {
    throw t;
  }));
}
function Zhe(e) {
  function t() {
    document.readyState !== "loading" && (e(), document.removeEventListener("DOMContentLoaded", t));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", t), t());
}
function ZB(e) {
  if (!e)
    return /* @__PURE__ */ new Set();
  if (typeof e == "function")
    return new Set(e());
  let t = /* @__PURE__ */ new Set();
  for (let r of e.value) {
    let n = Be(r);
    n instanceof HTMLElement && t.add(n);
  }
  return t;
}
var eq = ((e) => (e[e.None = 1] = "None", e[e.InitialFocus = 2] = "InitialFocus", e[e.TabLock = 4] = "TabLock", e[e.FocusLock = 8] = "FocusLock", e[e.RestoreFocus = 16] = "RestoreFocus", e[e.All = 30] = "All", e))(eq || {});
let ju = Object.assign(nt({ name: "FocusTrap", props: { as: { type: [Object, String], default: "div" }, initialFocus: { type: Object, default: null }, features: { type: Number, default: 30 }, containers: { type: [Object, Function], default: $e(/* @__PURE__ */ new Set()) } }, inheritAttrs: !1, setup(e, { attrs: t, slots: r, expose: n }) {
  let o = $e(null);
  n({ el: o, $el: o });
  let s = Ne(() => Yn(o)), a = $e(!1);
  Dt(() => a.value = !0), xn(() => a.value = !1), tpe({ ownerDocument: s }, Ne(() => a.value && !!(e.features & 16)));
  let l = rpe({ ownerDocument: s, container: o, initialFocus: Ne(() => e.initialFocus) }, Ne(() => a.value && !!(e.features & 2)));
  npe({ ownerDocument: s, container: o, containers: e.containers, previousActiveElement: l }, Ne(() => a.value && !!(e.features & 8)));
  let u = Qhe();
  function f(p) {
    let m = Be(o);
    m && ((y) => y())(() => {
      $r(u.value, { [nf.Forwards]: () => {
        va(m, Qr.First, { skipElements: [p.relatedTarget] });
      }, [nf.Backwards]: () => {
        va(m, Qr.Last, { skipElements: [p.relatedTarget] });
      } });
    });
  }
  let c = $e(!1);
  function d(p) {
    p.key === "Tab" && (c.value = !0, requestAnimationFrame(() => {
      c.value = !1;
    }));
  }
  function h(p) {
    if (!a.value)
      return;
    let m = ZB(e.containers);
    Be(o) instanceof HTMLElement && m.add(Be(o));
    let y = p.relatedTarget;
    y instanceof HTMLElement && y.dataset.headlessuiFocusGuard !== "true" && (tq(m, y) || (c.value ? va(Be(o), $r(u.value, { [nf.Forwards]: () => Qr.Next, [nf.Backwards]: () => Qr.Previous }) | Qr.WrapAround, { relativeTo: p.target }) : p.target instanceof HTMLElement && rs(p.target)));
  }
  return () => {
    let p = {}, m = { ref: o, onKeydown: d, onFocusout: h }, { features: y, initialFocus: _, containers: S, ...x } = e;
    return Ut(lt, [!!(y & 4) && Ut(ou, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: f, features: La.Focusable }), fr({ ourProps: m, theirProps: { ...t, ...x }, slot: p, attrs: t, slots: r, name: "FocusTrap" }), !!(y & 4) && Ut(ou, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: f, features: La.Focusable })]);
  };
} }), { features: eq }), Ks = [];
Zhe(() => {
  function e(t) {
    t.target instanceof HTMLElement && t.target !== document.body && Ks[0] !== t.target && (Ks.unshift(t.target), Ks = Ks.filter((r) => r != null && r.isConnected), Ks.splice(10));
  }
  window.addEventListener("click", e, { capture: !0 }), window.addEventListener("mousedown", e, { capture: !0 }), window.addEventListener("focus", e, { capture: !0 }), document.body.addEventListener("click", e, { capture: !0 }), document.body.addEventListener("mousedown", e, { capture: !0 }), document.body.addEventListener("focus", e, { capture: !0 });
});
function epe(e) {
  let t = $e(Ks.slice());
  return br([e], ([r], [n]) => {
    n === !0 && r === !1 ? QB(() => {
      t.value.splice(0);
    }) : n === !1 && r === !0 && (t.value = Ks.slice());
  }, { flush: "post" }), () => {
    var r;
    return (r = t.value.find((n) => n != null && n.isConnected)) != null ? r : null;
  };
}
function tpe({ ownerDocument: e }, t) {
  let r = epe(t);
  Dt(() => {
    Qn(() => {
      var n, o;
      t.value || ((n = e.value) == null ? void 0 : n.activeElement) === ((o = e.value) == null ? void 0 : o.body) && rs(r());
    }, { flush: "post" });
  }), xn(() => {
    t.value && rs(r());
  });
}
function rpe({ ownerDocument: e, container: t, initialFocus: r }, n) {
  let o = $e(null), s = $e(!1);
  return Dt(() => s.value = !0), xn(() => s.value = !1), Dt(() => {
    br([t, r, n], (a, l) => {
      if (a.every((f, c) => (l == null ? void 0 : l[c]) === f) || !n.value)
        return;
      let u = Be(t);
      u && QB(() => {
        var f, c;
        if (!s.value)
          return;
        let d = Be(r), h = (f = e.value) == null ? void 0 : f.activeElement;
        if (d) {
          if (d === h) {
            o.value = h;
            return;
          }
        } else if (u.contains(h)) {
          o.value = h;
          return;
        }
        d ? rs(d) : va(u, Qr.First | Qr.NoScroll) === Wh.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), o.value = (c = e.value) == null ? void 0 : c.activeElement;
      });
    }, { immediate: !0, flush: "post" });
  }), o;
}
function npe({ ownerDocument: e, container: t, containers: r, previousActiveElement: n }, o) {
  var s;
  JB((s = e.value) == null ? void 0 : s.defaultView, "focus", (a) => {
    if (!o.value)
      return;
    let l = ZB(r);
    Be(t) instanceof HTMLElement && l.add(Be(t));
    let u = n.value;
    if (!u)
      return;
    let f = a.target;
    f && f instanceof HTMLElement ? tq(l, f) ? (n.value = f, rs(f)) : (a.preventDefault(), a.stopPropagation(), rs(u)) : rs(n.value);
  }, !0);
}
function tq(e, t) {
  for (let r of e)
    if (r.contains(t))
      return !0;
  return !1;
}
let A0 = /* @__PURE__ */ new Map(), Bu = /* @__PURE__ */ new Map();
function $2(e, t = $e(!0)) {
  Qn((r) => {
    var n;
    if (!t.value)
      return;
    let o = Be(e);
    if (!o)
      return;
    r(function() {
      var a;
      if (!o)
        return;
      let l = (a = Bu.get(o)) != null ? a : 1;
      if (l === 1 ? Bu.delete(o) : Bu.set(o, l - 1), l !== 1)
        return;
      let u = A0.get(o);
      u && (u["aria-hidden"] === null ? o.removeAttribute("aria-hidden") : o.setAttribute("aria-hidden", u["aria-hidden"]), o.inert = u.inert, A0.delete(o));
    });
    let s = (n = Bu.get(o)) != null ? n : 0;
    Bu.set(o, s + 1), s === 0 && (A0.set(o, { "aria-hidden": o.getAttribute("aria-hidden"), inert: o.inert }), o.setAttribute("aria-hidden", "true"), o.inert = !0);
  });
}
let rq = Symbol("ForcePortalRootContext");
function ipe() {
  return yr(rq, !1);
}
let C2 = nt({ name: "ForcePortalRoot", props: { as: { type: [Object, String], default: "template" }, force: { type: Boolean, default: !1 } }, setup(e, { slots: t, attrs: r }) {
  return Tn(rq, e.force), () => {
    let { force: n, ...o } = e;
    return fr({ theirProps: o, ourProps: {}, slot: {}, slots: t, attrs: r, name: "ForcePortalRoot" });
  };
} });
function ope(e) {
  let t = Yn(e);
  if (!t) {
    if (e === null)
      return null;
    throw new Error(`[Headless UI]: Cannot find ownerDocument for contextElement: ${e}`);
  }
  let r = t.getElementById("headlessui-portal-root");
  if (r)
    return r;
  let n = t.createElement("div");
  return n.setAttribute("id", "headlessui-portal-root"), t.body.appendChild(n);
}
let spe = nt({ name: "Portal", props: { as: { type: [Object, String], default: "div" } }, setup(e, { slots: t, attrs: r }) {
  let n = $e(null), o = Ne(() => Yn(n)), s = ipe(), a = yr(nq, null), l = $e(s === !0 || a == null ? ope(n.value) : a.resolveTarget());
  Qn(() => {
    s || a != null && (l.value = a.resolveTarget());
  });
  let u = yr(lE, null);
  return Dt(() => {
    let f = Be(n);
    f && u && xn(u.register(f));
  }), xn(() => {
    var f, c;
    let d = (f = o.value) == null ? void 0 : f.getElementById("headlessui-portal-root");
    d && l.value === d && l.value.children.length <= 0 && ((c = l.value.parentElement) == null || c.removeChild(l.value));
  }), () => {
    if (l.value === null)
      return null;
    let f = { ref: n, "data-headlessui-portal": "" };
    return Ut(DU, { to: l.value }, fr({ ourProps: f, theirProps: e, slot: {}, attrs: r, slots: t, name: "Portal" }));
  };
} }), lE = Symbol("PortalParentContext");
function ape() {
  let e = yr(lE, null), t = $e([]);
  function r(s) {
    return t.value.push(s), e && e.register(s), () => n(s);
  }
  function n(s) {
    let a = t.value.indexOf(s);
    a !== -1 && t.value.splice(a, 1), e && e.unregister(s);
  }
  let o = { register: r, unregister: n, portals: t };
  return [t, nt({ name: "PortalWrapper", setup(s, { slots: a }) {
    return Tn(lE, o), () => {
      var l;
      return (l = a.default) == null ? void 0 : l.call(a);
    };
  } })];
}
let nq = Symbol("PortalGroupContext"), lpe = nt({ name: "PortalGroup", props: { as: { type: [Object, String], default: "template" }, target: { type: Object, default: null } }, setup(e, { attrs: t, slots: r }) {
  let n = ap({ resolveTarget() {
    return e.target;
  } });
  return Tn(nq, n), () => {
    let { target: o, ...s } = e;
    return fr({ theirProps: s, ourProps: {}, slot: {}, attrs: t, slots: r, name: "PortalGroup" });
  };
} }), iq = Symbol("StackContext");
var uE = ((e) => (e[e.Add = 0] = "Add", e[e.Remove = 1] = "Remove", e))(uE || {});
function upe() {
  return yr(iq, () => {
  });
}
function fpe({ type: e, enabled: t, element: r, onUpdate: n }) {
  let o = upe();
  function s(...a) {
    n == null || n(...a), o(...a);
  }
  Dt(() => {
    br(t, (a, l) => {
      a ? s(0, e, r) : l === !0 && s(1, e, r);
    }, { immediate: !0, flush: "sync" });
  }), xn(() => {
    t.value && s(1, e, r);
  }), Tn(iq, s);
}
let cpe = Symbol("DescriptionContext");
function YR({ slot: e = $e({}), name: t = "Description", props: r = {} } = {}) {
  let n = $e([]);
  function o(s) {
    return n.value.push(s), () => {
      let a = n.value.indexOf(s);
      a !== -1 && n.value.splice(a, 1);
    };
  }
  return Tn(cpe, { register: o, slot: e, name: t, props: r }), Ne(() => n.value.length > 0 ? n.value.join(" ") : void 0);
}
function dpe(e) {
  let t = u4(e.getSnapshot());
  return xn(e.subscribe(() => {
    t.value = e.getSnapshot();
  })), t;
}
function hpe(e, t) {
  let r = e(), n = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return r;
  }, subscribe(o) {
    return n.add(o), () => n.delete(o);
  }, dispatch(o, ...s) {
    let a = t[o].call(r, ...s);
    a && (r = a, n.forEach((l) => l()));
  } };
}
function ppe() {
  let e;
  return { before({ doc: t }) {
    var r;
    let n = t.documentElement;
    e = ((r = t.defaultView) != null ? r : window).innerWidth - n.clientWidth;
  }, after({ doc: t, d: r }) {
    let n = t.documentElement, o = n.clientWidth - n.offsetWidth, s = e - o;
    r.style(n, "paddingRight", `${s}px`);
  } };
}
function gpe() {
  if (!Jhe())
    return {};
  let e;
  return { before() {
    e = window.pageYOffset;
  }, after({ doc: t, d: r, meta: n }) {
    function o(a) {
      return n.containers.flatMap((l) => l()).some((l) => l.contains(a));
    }
    r.style(t.body, "marginTop", `-${e}px`), window.scrollTo(0, 0);
    let s = null;
    r.addEventListener(t, "click", (a) => {
      if (a.target instanceof HTMLElement)
        try {
          let l = a.target.closest("a");
          if (!l)
            return;
          let { hash: u } = new URL(l.href), f = t.querySelector(u);
          f && !o(f) && (s = f);
        } catch {
        }
    }, !0), r.addEventListener(t, "touchmove", (a) => {
      a.target instanceof HTMLElement && !o(a.target) && a.preventDefault();
    }, { passive: !1 }), r.add(() => {
      window.scrollTo(0, window.pageYOffset + e), s && s.isConnected && (s.scrollIntoView({ block: "nearest" }), s = null);
    });
  } };
}
function bpe() {
  return { before({ doc: e, d: t }) {
    t.style(e.documentElement, "overflow", "hidden");
  } };
}
function ype(e) {
  let t = {};
  for (let r of e)
    Object.assign(t, r(t));
  return t;
}
let ea = hpe(() => /* @__PURE__ */ new Map(), { PUSH(e, t) {
  var r;
  let n = (r = this.get(e)) != null ? r : { doc: e, count: 0, d: XB(), meta: /* @__PURE__ */ new Set() };
  return n.count++, n.meta.add(t), this.set(e, n), this;
}, POP(e, t) {
  let r = this.get(e);
  return r && (r.count--, r.meta.delete(t)), this;
}, SCROLL_PREVENT({ doc: e, d: t, meta: r }) {
  let n = { doc: e, d: t, meta: ype(r) }, o = [gpe(), ppe(), bpe()];
  o.forEach(({ before: s }) => s == null ? void 0 : s(n)), o.forEach(({ after: s }) => s == null ? void 0 : s(n));
}, SCROLL_ALLOW({ d: e }) {
  e.dispose();
}, TEARDOWN({ doc: e }) {
  this.delete(e);
} });
ea.subscribe(() => {
  let e = ea.getSnapshot(), t = /* @__PURE__ */ new Map();
  for (let [r] of e)
    t.set(r, r.documentElement.style.overflow);
  for (let r of e.values()) {
    let n = t.get(r.doc) === "hidden", o = r.count !== 0;
    (o && !n || !o && n) && ea.dispatch(r.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", r), r.count === 0 && ea.dispatch("TEARDOWN", r);
  }
});
function mpe(e, t, r) {
  let n = dpe(ea), o = Ne(() => {
    let s = e.value ? n.value.get(e.value) : void 0;
    return s ? s.count > 0 : !1;
  });
  return br([e, t], ([s, a], [l], u) => {
    if (!s || !a)
      return;
    ea.dispatch("PUSH", s, r);
    let f = !1;
    u(() => {
      f || (ea.dispatch("POP", l ?? s, r), f = !0);
    });
  }, { immediate: !0 }), o;
}
function vpe({ defaultContainers: e = [], portals: t } = {}) {
  let r = $e(null), n = Yn(r);
  function o() {
    var s;
    let a = [];
    for (let l of e)
      l !== null && (l instanceof HTMLElement ? a.push(l) : "value" in l && l.value instanceof HTMLElement && a.push(l.value));
    if (t != null && t.value)
      for (let l of t.value)
        a.push(l);
    for (let l of (s = n == null ? void 0 : n.querySelectorAll("html > *, body > *")) != null ? s : [])
      l !== document.body && l !== document.head && l instanceof HTMLElement && l.id !== "headlessui-portal-root" && (l.contains(Be(r)) || a.some((u) => l.contains(u)) || a.push(l));
    return a;
  }
  return { resolveContainers: o, contains(s) {
    return o().some((a) => a.contains(s));
  }, mainTreeNodeRef: r, MainTreeNode() {
    return Ut(ou, { features: La.Hidden, ref: r });
  } };
}
var wpe = ((e) => (e[e.Open = 0] = "Open", e[e.Closed = 1] = "Closed", e))(wpe || {});
let fE = Symbol("DialogContext");
function oq(e) {
  let t = yr(fE, null);
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, oq), r;
  }
  return t;
}
let Ed = "DC8F892D-2EBD-447C-A4C8-A03058436FF4", _pe = nt({ name: "Dialog", inheritAttrs: !1, props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, open: { type: [Boolean, String], default: Ed }, initialFocus: { type: Object, default: null }, id: { type: String, default: () => `headlessui-dialog-${ri()}` } }, emits: { close: (e) => !0 }, setup(e, { emit: t, attrs: r, slots: n, expose: o }) {
  var s;
  let a = $e(!1);
  Dt(() => {
    a.value = !0;
  });
  let l = $e(0), u = HR(), f = Ne(() => e.open === Ed && u !== null ? (u.value & dn.Open) === dn.Open : e.open), c = $e(null), d = Ne(() => Yn(c));
  if (o({ el: c, $el: c }), !(e.open !== Ed || u !== null))
    throw new Error("You forgot to provide an `open` prop to the `Dialog`.");
  if (typeof f.value != "boolean")
    throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${f.value === Ed ? void 0 : e.open}`);
  let h = Ne(() => a.value && f.value ? 0 : 1), p = Ne(() => h.value === 0), m = Ne(() => l.value > 1), y = yr(fE, null) !== null, [_, S] = ape(), { resolveContainers: x, mainTreeNodeRef: E, MainTreeNode: C } = vpe({ portals: _, defaultContainers: [Ne(() => {
    var te;
    return (te = k.panelRef.value) != null ? te : c.value;
  })] }), I = Ne(() => m.value ? "parent" : "leaf"), j = Ne(() => u !== null ? (u.value & dn.Closing) === dn.Closing : !1), J = Ne(() => y || j.value ? !1 : p.value), G = Ne(() => {
    var te, se, fe;
    return (fe = Array.from((se = (te = d.value) == null ? void 0 : te.querySelectorAll("body > *")) != null ? se : []).find((he) => he.id === "headlessui-portal-root" ? !1 : he.contains(Be(E)) && he instanceof HTMLElement)) != null ? fe : null;
  });
  $2(G, J);
  let $ = Ne(() => m.value ? !0 : p.value), V = Ne(() => {
    var te, se, fe;
    return (fe = Array.from((se = (te = d.value) == null ? void 0 : te.querySelectorAll("[data-headlessui-portal]")) != null ? se : []).find((he) => he.contains(Be(E)) && he instanceof HTMLElement)) != null ? fe : null;
  });
  $2(V, $), fpe({ type: "Dialog", enabled: Ne(() => h.value === 0), element: c, onUpdate: (te, se) => {
    if (se === "Dialog")
      return $r(te, { [uE.Add]: () => l.value += 1, [uE.Remove]: () => l.value -= 1 });
  } });
  let M = YR({ name: "DialogDescription", slot: Ne(() => ({ open: f.value })) }), W = $e(null), k = { titleId: W, panelRef: $e(null), dialogState: h, setTitleId(te) {
    W.value !== te && (W.value = te);
  }, close() {
    t("close", !1);
  } };
  Tn(fE, k);
  let U = Ne(() => !(!p.value || m.value));
  GR(x, (te, se) => {
    k.close(), gr(() => se == null ? void 0 : se.focus());
  }, U);
  let Z = Ne(() => !(m.value || h.value !== 0));
  JB((s = d.value) == null ? void 0 : s.defaultView, "keydown", (te) => {
    Z.value && (te.defaultPrevented || te.key === tt.Escape && (te.preventDefault(), te.stopPropagation(), k.close()));
  });
  let Y = Ne(() => !(j.value || h.value !== 0 || y));
  return mpe(d, Y, (te) => {
    var se;
    return { containers: [...(se = te.containers) != null ? se : [], x] };
  }), Qn((te) => {
    if (h.value !== 0)
      return;
    let se = Be(c);
    if (!se)
      return;
    let fe = new ResizeObserver((he) => {
      for (let ae of he) {
        let be = ae.target.getBoundingClientRect();
        be.x === 0 && be.y === 0 && be.width === 0 && be.height === 0 && k.close();
      }
    });
    fe.observe(se), te(() => fe.disconnect());
  }), () => {
    let { id: te, open: se, initialFocus: fe, ...he } = e, ae = { ...r, ref: c, id: te, role: "dialog", "aria-modal": h.value === 0 ? !0 : void 0, "aria-labelledby": W.value, "aria-describedby": M.value }, be = { open: h.value === 0 };
    return Ut(C2, { force: !0 }, () => [Ut(spe, () => Ut(lpe, { target: c.value }, () => Ut(C2, { force: !1 }, () => Ut(ju, { initialFocus: fe, containers: x, features: p.value ? $r(I.value, { parent: ju.features.RestoreFocus, leaf: ju.features.All & ~ju.features.FocusLock }) : ju.features.None }, () => Ut(S, {}, () => fr({ ourProps: ae, theirProps: { ...he, ...r }, slot: be, attrs: r, slots: n, visible: h.value === 0, features: Na.RenderStrategy | Na.Static, name: "Dialog" })))))), Ut(C)]);
  };
} }), Spe = nt({ name: "DialogOverlay", props: { as: { type: [Object, String], default: "div" }, id: { type: String, default: () => `headlessui-dialog-overlay-${ri()}` } }, setup(e, { attrs: t, slots: r }) {
  let n = oq("DialogOverlay");
  function o(s) {
    s.target === s.currentTarget && (s.preventDefault(), s.stopPropagation(), n.close());
  }
  return () => {
    let { id: s, ...a } = e;
    return fr({ ourProps: { id: s, "aria-hidden": !0, onClick: o }, theirProps: a, slot: { open: n.dialogState.value === 0 }, attrs: t, slots: r, name: "DialogOverlay" });
  };
} }), k2 = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function I2(e) {
  var t, r;
  let n = (t = e.innerText) != null ? t : "", o = e.cloneNode(!0);
  if (!(o instanceof HTMLElement))
    return n;
  let s = !1;
  for (let l of o.querySelectorAll('[hidden],[aria-hidden],[role="img"]'))
    l.remove(), s = !0;
  let a = s ? (r = o.innerText) != null ? r : "" : n;
  return k2.test(a) && (a = a.replace(k2, "")), a;
}
function Epe(e) {
  let t = e.getAttribute("aria-label");
  if (typeof t == "string")
    return t.trim();
  let r = e.getAttribute("aria-labelledby");
  if (r) {
    let n = r.split(" ").map((o) => {
      let s = document.getElementById(o);
      if (s) {
        let a = s.getAttribute("aria-label");
        return typeof a == "string" ? a.trim() : I2(s).trim();
      }
      return null;
    }).filter(Boolean);
    if (n.length > 0)
      return n.join(", ");
  }
  return I2(e).trim();
}
function sq(e) {
  let t = $e(""), r = $e("");
  return () => {
    let n = Be(e);
    if (!n)
      return "";
    let o = n.innerText;
    if (t.value === o)
      return r.value;
    let s = Epe(n).trim().toLowerCase();
    return t.value = o, r.value = s, s;
  };
}
function xpe(e, t) {
  return e === t;
}
var Rpe = ((e) => (e[e.Open = 0] = "Open", e[e.Closed = 1] = "Closed", e))(Rpe || {}), Ape = ((e) => (e[e.Single = 0] = "Single", e[e.Multi = 1] = "Multi", e))(Ape || {}), Tpe = ((e) => (e[e.Pointer = 0] = "Pointer", e[e.Other = 1] = "Other", e))(Tpe || {});
function $pe(e) {
  requestAnimationFrame(() => requestAnimationFrame(e));
}
let aq = Symbol("ListboxContext");
function qg(e) {
  let t = yr(aq, null);
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <Listbox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, qg), r;
  }
  return t;
}
let Cpe = nt({ name: "Listbox", emits: { "update:modelValue": (e) => !0 }, props: { as: { type: [Object, String], default: "template" }, disabled: { type: [Boolean], default: !1 }, by: { type: [String, Function], default: () => xpe }, horizontal: { type: [Boolean], default: !1 }, modelValue: { type: [Object, String, Number, Boolean], default: void 0 }, defaultValue: { type: [Object, String, Number, Boolean], default: void 0 }, form: { type: String, optional: !0 }, name: { type: String, optional: !0 }, multiple: { type: [Boolean], default: !1 } }, inheritAttrs: !1, setup(e, { slots: t, attrs: r, emit: n }) {
  let o = $e(1), s = $e(null), a = $e(null), l = $e(null), u = $e([]), f = $e(""), c = $e(null), d = $e(1);
  function h(x = (E) => E) {
    let E = c.value !== null ? u.value[c.value] : null, C = Bg(x(u.value.slice()), (j) => Be(j.dataRef.domRef)), I = E ? C.indexOf(E) : null;
    return I === -1 && (I = null), { options: C, activeOptionIndex: I };
  }
  let p = Ne(() => e.multiple ? 1 : 0), [m, y] = KR(Ne(() => e.modelValue === void 0 ? $r(p.value, { 1: [], 0: void 0 }) : e.modelValue), (x) => n("update:modelValue", x), Ne(() => e.defaultValue)), _ = { listboxState: o, value: m, mode: p, compare(x, E) {
    if (typeof e.by == "string") {
      let C = e.by;
      return (x == null ? void 0 : x[C]) === (E == null ? void 0 : E[C]);
    }
    return e.by(x, E);
  }, orientation: Ne(() => e.horizontal ? "horizontal" : "vertical"), labelRef: s, buttonRef: a, optionsRef: l, disabled: Ne(() => e.disabled), options: u, searchQuery: f, activeOptionIndex: c, activationTrigger: d, closeListbox() {
    e.disabled || o.value !== 1 && (o.value = 1, c.value = null);
  }, openListbox() {
    e.disabled || o.value !== 0 && (o.value = 0);
  }, goToOption(x, E, C) {
    if (e.disabled || o.value === 1)
      return;
    let I = h(), j = jB(x === Ct.Specific ? { focus: Ct.Specific, id: E } : { focus: x }, { resolveItems: () => I.options, resolveActiveIndex: () => I.activeOptionIndex, resolveId: (J) => J.id, resolveDisabled: (J) => J.dataRef.disabled });
    f.value = "", c.value = j, d.value = C ?? 1, u.value = I.options;
  }, search(x) {
    if (e.disabled || o.value === 1)
      return;
    let E = f.value !== "" ? 0 : 1;
    f.value += x.toLowerCase();
    let C = (c.value !== null ? u.value.slice(c.value + E).concat(u.value.slice(0, c.value + E)) : u.value).find((j) => j.dataRef.textValue.startsWith(f.value) && !j.dataRef.disabled), I = C ? u.value.indexOf(C) : -1;
    I === -1 || I === c.value || (c.value = I, d.value = 1);
  }, clearSearch() {
    e.disabled || o.value !== 1 && f.value !== "" && (f.value = "");
  }, registerOption(x, E) {
    let C = h((I) => [...I, { id: x, dataRef: E }]);
    u.value = C.options, c.value = C.activeOptionIndex;
  }, unregisterOption(x) {
    let E = h((C) => {
      let I = C.findIndex((j) => j.id === x);
      return I !== -1 && C.splice(I, 1), C;
    });
    u.value = E.options, c.value = E.activeOptionIndex, d.value = 1;
  }, select(x) {
    e.disabled || y($r(p.value, { 0: () => x, 1: () => {
      let E = Fe(_.value.value).slice(), C = Fe(x), I = E.findIndex((j) => _.compare(C, Fe(j)));
      return I === -1 ? E.push(C) : E.splice(I, 1), E;
    } }));
  } };
  GR([a, l], (x, E) => {
    var C;
    _.closeListbox(), jg(E, Fg.Loose) || (x.preventDefault(), (C = Be(a)) == null || C.focus());
  }, Ne(() => o.value === 0)), Tn(aq, _), qB(Ne(() => $r(o.value, { 0: dn.Open, 1: dn.Closed })));
  let S = Ne(() => {
    var x;
    return (x = Be(a)) == null ? void 0 : x.closest("form");
  });
  return Dt(() => {
    br([S], () => {
      if (!S.value || e.defaultValue === void 0)
        return;
      function x() {
        _.select(e.defaultValue);
      }
      return S.value.addEventListener("reset", x), () => {
        var E;
        (E = S.value) == null || E.removeEventListener("reset", x);
      };
    }, { immediate: !0 });
  }), () => {
    let { name: x, modelValue: E, disabled: C, form: I, ...j } = e, J = { open: o.value === 0, disabled: C, value: m.value };
    return Ut(lt, [...x != null && m.value != null ? VR({ [x]: m.value }).map(([G, $]) => Ut(ou, UR({ features: La.Hidden, key: G, as: "input", type: "hidden", hidden: !0, readOnly: !0, form: I, name: G, value: $ }))) : [], fr({ ourProps: {}, theirProps: { ...r, ...Pg(j, ["defaultValue", "onUpdate:modelValue", "horizontal", "multiple", "by"]) }, slot: J, slots: t, attrs: r, name: "Listbox" })]);
  };
} }), kpe = nt({ name: "ListboxButton", props: { as: { type: [Object, String], default: "button" }, id: { type: String, default: () => `headlessui-listbox-button-${ri()}` } }, setup(e, { attrs: t, slots: r, expose: n }) {
  let o = qg("ListboxButton");
  n({ el: o.buttonRef, $el: o.buttonRef });
  function s(f) {
    switch (f.key) {
      case tt.Space:
      case tt.Enter:
      case tt.ArrowDown:
        f.preventDefault(), o.openListbox(), gr(() => {
          var c;
          (c = Be(o.optionsRef)) == null || c.focus({ preventScroll: !0 }), o.value.value || o.goToOption(Ct.First);
        });
        break;
      case tt.ArrowUp:
        f.preventDefault(), o.openListbox(), gr(() => {
          var c;
          (c = Be(o.optionsRef)) == null || c.focus({ preventScroll: !0 }), o.value.value || o.goToOption(Ct.Last);
        });
        break;
    }
  }
  function a(f) {
    switch (f.key) {
      case tt.Space:
        f.preventDefault();
        break;
    }
  }
  function l(f) {
    o.disabled.value || (o.listboxState.value === 0 ? (o.closeListbox(), gr(() => {
      var c;
      return (c = Be(o.buttonRef)) == null ? void 0 : c.focus({ preventScroll: !0 });
    })) : (f.preventDefault(), o.openListbox(), $pe(() => {
      var c;
      return (c = Be(o.optionsRef)) == null ? void 0 : c.focus({ preventScroll: !0 });
    })));
  }
  let u = zR(Ne(() => ({ as: e.as, type: t.type })), o.buttonRef);
  return () => {
    var f, c;
    let d = { open: o.listboxState.value === 0, disabled: o.disabled.value, value: o.value.value }, { id: h, ...p } = e, m = { ref: o.buttonRef, id: h, type: u.value, "aria-haspopup": "listbox", "aria-controls": (f = Be(o.optionsRef)) == null ? void 0 : f.id, "aria-expanded": o.disabled.value ? void 0 : o.listboxState.value === 0, "aria-labelledby": o.labelRef.value ? [(c = Be(o.labelRef)) == null ? void 0 : c.id, h].join(" ") : void 0, disabled: o.disabled.value === !0 ? !0 : void 0, onKeydown: s, onKeyup: a, onClick: l };
    return fr({ ourProps: m, theirProps: p, slot: d, attrs: t, slots: r, name: "ListboxButton" });
  };
} }), Ipe = nt({ name: "ListboxOptions", props: { as: { type: [Object, String], default: "ul" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, id: { type: String, default: () => `headlessui-listbox-options-${ri()}` } }, setup(e, { attrs: t, slots: r, expose: n }) {
  let o = qg("ListboxOptions"), s = $e(null);
  n({ el: o.optionsRef, $el: o.optionsRef });
  function a(f) {
    switch (s.value && clearTimeout(s.value), f.key) {
      case tt.Space:
        if (o.searchQuery.value !== "")
          return f.preventDefault(), f.stopPropagation(), o.search(f.key);
      case tt.Enter:
        if (f.preventDefault(), f.stopPropagation(), o.activeOptionIndex.value !== null) {
          let c = o.options.value[o.activeOptionIndex.value];
          o.select(c.dataRef.value);
        }
        o.mode.value === 0 && (o.closeListbox(), gr(() => {
          var c;
          return (c = Be(o.buttonRef)) == null ? void 0 : c.focus({ preventScroll: !0 });
        }));
        break;
      case $r(o.orientation.value, { vertical: tt.ArrowDown, horizontal: tt.ArrowRight }):
        return f.preventDefault(), f.stopPropagation(), o.goToOption(Ct.Next);
      case $r(o.orientation.value, { vertical: tt.ArrowUp, horizontal: tt.ArrowLeft }):
        return f.preventDefault(), f.stopPropagation(), o.goToOption(Ct.Previous);
      case tt.Home:
      case tt.PageUp:
        return f.preventDefault(), f.stopPropagation(), o.goToOption(Ct.First);
      case tt.End:
      case tt.PageDown:
        return f.preventDefault(), f.stopPropagation(), o.goToOption(Ct.Last);
      case tt.Escape:
        f.preventDefault(), f.stopPropagation(), o.closeListbox(), gr(() => {
          var c;
          return (c = Be(o.buttonRef)) == null ? void 0 : c.focus({ preventScroll: !0 });
        });
        break;
      case tt.Tab:
        f.preventDefault(), f.stopPropagation();
        break;
      default:
        f.key.length === 1 && (o.search(f.key), s.value = setTimeout(() => o.clearSearch(), 350));
        break;
    }
  }
  let l = HR(), u = Ne(() => l !== null ? (l.value & dn.Open) === dn.Open : o.listboxState.value === 0);
  return () => {
    var f, c, d, h;
    let p = { open: o.listboxState.value === 0 }, { id: m, ...y } = e, _ = { "aria-activedescendant": o.activeOptionIndex.value === null || (f = o.options.value[o.activeOptionIndex.value]) == null ? void 0 : f.id, "aria-multiselectable": o.mode.value === 1 ? !0 : void 0, "aria-labelledby": (h = (c = Be(o.labelRef)) == null ? void 0 : c.id) != null ? h : (d = Be(o.buttonRef)) == null ? void 0 : d.id, "aria-orientation": o.orientation.value, id: m, onKeydown: a, role: "listbox", tabIndex: 0, ref: o.optionsRef };
    return fr({ ourProps: _, theirProps: y, slot: p, attrs: t, slots: r, features: Na.RenderStrategy | Na.Static, visible: u.value, name: "ListboxOptions" });
  };
} }), Mpe = nt({ name: "ListboxOption", props: { as: { type: [Object, String], default: "li" }, value: { type: [Object, String, Number, Boolean] }, disabled: { type: Boolean, default: !1 }, id: { type: String, default: () => `headlessui-listbox.option-${ri()}` } }, setup(e, { slots: t, attrs: r, expose: n }) {
  let o = qg("ListboxOption"), s = $e(null);
  n({ el: s, $el: s });
  let a = Ne(() => o.activeOptionIndex.value !== null ? o.options.value[o.activeOptionIndex.value].id === e.id : !1), l = Ne(() => $r(o.mode.value, { 0: () => o.compare(Fe(o.value.value), Fe(e.value)), 1: () => Fe(o.value.value).some((S) => o.compare(Fe(S), Fe(e.value))) })), u = Ne(() => $r(o.mode.value, { 1: () => {
    var S;
    let x = Fe(o.value.value);
    return ((S = o.options.value.find((E) => x.some((C) => o.compare(Fe(C), Fe(E.dataRef.value))))) == null ? void 0 : S.id) === e.id;
  }, 0: () => l.value })), f = sq(s), c = Ne(() => ({ disabled: e.disabled, value: e.value, get textValue() {
    return f();
  }, domRef: s }));
  Dt(() => o.registerOption(e.id, c)), xn(() => o.unregisterOption(e.id)), Dt(() => {
    br([o.listboxState, l], () => {
      o.listboxState.value === 0 && l.value && $r(o.mode.value, { 1: () => {
        u.value && o.goToOption(Ct.Specific, e.id);
      }, 0: () => {
        o.goToOption(Ct.Specific, e.id);
      } });
    }, { immediate: !0 });
  }), Qn(() => {
    o.listboxState.value === 0 && a.value && o.activationTrigger.value !== 0 && gr(() => {
      var S, x;
      return (x = (S = Be(s)) == null ? void 0 : S.scrollIntoView) == null ? void 0 : x.call(S, { block: "nearest" });
    });
  });
  function d(S) {
    if (e.disabled)
      return S.preventDefault();
    o.select(e.value), o.mode.value === 0 && (o.closeListbox(), gr(() => {
      var x;
      return (x = Be(o.buttonRef)) == null ? void 0 : x.focus({ preventScroll: !0 });
    }));
  }
  function h() {
    if (e.disabled)
      return o.goToOption(Ct.Nothing);
    o.goToOption(Ct.Specific, e.id);
  }
  let p = YB();
  function m(S) {
    p.update(S);
  }
  function y(S) {
    p.wasMoved(S) && (e.disabled || a.value || o.goToOption(Ct.Specific, e.id, 0));
  }
  function _(S) {
    p.wasMoved(S) && (e.disabled || a.value && o.goToOption(Ct.Nothing));
  }
  return () => {
    let { disabled: S } = e, x = { active: a.value, selected: l.value, disabled: S }, { id: E, value: C, disabled: I, ...j } = e, J = { id: E, ref: s, role: "option", tabIndex: S === !0 ? void 0 : -1, "aria-disabled": S === !0 ? !0 : void 0, "aria-selected": l.value, disabled: void 0, onClick: d, onFocus: h, onPointerenter: m, onMouseenter: m, onPointermove: y, onMousemove: y, onPointerleave: _, onMouseleave: _ };
    return fr({ ourProps: J, theirProps: j, slot: x, attrs: r, slots: t, name: "ListboxOption" });
  };
} });
var Npe = ((e) => (e[e.Open = 0] = "Open", e[e.Closed = 1] = "Closed", e))(Npe || {}), Lpe = ((e) => (e[e.Pointer = 0] = "Pointer", e[e.Other = 1] = "Other", e))(Lpe || {});
function Ope(e) {
  requestAnimationFrame(() => requestAnimationFrame(e));
}
let lq = Symbol("MenuContext");
function Wg(e) {
  let t = yr(lq, null);
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, Wg), r;
  }
  return t;
}
let Ppe = nt({ name: "Menu", props: { as: { type: [Object, String], default: "template" } }, setup(e, { slots: t, attrs: r }) {
  let n = $e(1), o = $e(null), s = $e(null), a = $e([]), l = $e(""), u = $e(null), f = $e(1);
  function c(h = (p) => p) {
    let p = u.value !== null ? a.value[u.value] : null, m = Bg(h(a.value.slice()), (_) => Be(_.dataRef.domRef)), y = p ? m.indexOf(p) : null;
    return y === -1 && (y = null), { items: m, activeItemIndex: y };
  }
  let d = { menuState: n, buttonRef: o, itemsRef: s, items: a, searchQuery: l, activeItemIndex: u, activationTrigger: f, closeMenu: () => {
    n.value = 1, u.value = null;
  }, openMenu: () => n.value = 0, goToItem(h, p, m) {
    let y = c(), _ = jB(h === Ct.Specific ? { focus: Ct.Specific, id: p } : { focus: h }, { resolveItems: () => y.items, resolveActiveIndex: () => y.activeItemIndex, resolveId: (S) => S.id, resolveDisabled: (S) => S.dataRef.disabled });
    l.value = "", u.value = _, f.value = m ?? 1, a.value = y.items;
  }, search(h) {
    let p = l.value !== "" ? 0 : 1;
    l.value += h.toLowerCase();
    let m = (u.value !== null ? a.value.slice(u.value + p).concat(a.value.slice(0, u.value + p)) : a.value).find((_) => _.dataRef.textValue.startsWith(l.value) && !_.dataRef.disabled), y = m ? a.value.indexOf(m) : -1;
    y === -1 || y === u.value || (u.value = y, f.value = 1);
  }, clearSearch() {
    l.value = "";
  }, registerItem(h, p) {
    let m = c((y) => [...y, { id: h, dataRef: p }]);
    a.value = m.items, u.value = m.activeItemIndex, f.value = 1;
  }, unregisterItem(h) {
    let p = c((m) => {
      let y = m.findIndex((_) => _.id === h);
      return y !== -1 && m.splice(y, 1), m;
    });
    a.value = p.items, u.value = p.activeItemIndex, f.value = 1;
  } };
  return GR([o, s], (h, p) => {
    var m;
    d.closeMenu(), jg(p, Fg.Loose) || (h.preventDefault(), (m = Be(o)) == null || m.focus());
  }, Ne(() => n.value === 0)), Tn(lq, d), qB(Ne(() => $r(n.value, { 0: dn.Open, 1: dn.Closed }))), () => {
    let h = { open: n.value === 0, close: d.closeMenu };
    return fr({ ourProps: {}, theirProps: e, slot: h, slots: t, attrs: r, name: "Menu" });
  };
} }), Dpe = nt({ name: "MenuButton", props: { disabled: { type: Boolean, default: !1 }, as: { type: [Object, String], default: "button" }, id: { type: String, default: () => `headlessui-menu-button-${ri()}` } }, setup(e, { attrs: t, slots: r, expose: n }) {
  let o = Wg("MenuButton");
  n({ el: o.buttonRef, $el: o.buttonRef });
  function s(f) {
    switch (f.key) {
      case tt.Space:
      case tt.Enter:
      case tt.ArrowDown:
        f.preventDefault(), f.stopPropagation(), o.openMenu(), gr(() => {
          var c;
          (c = Be(o.itemsRef)) == null || c.focus({ preventScroll: !0 }), o.goToItem(Ct.First);
        });
        break;
      case tt.ArrowUp:
        f.preventDefault(), f.stopPropagation(), o.openMenu(), gr(() => {
          var c;
          (c = Be(o.itemsRef)) == null || c.focus({ preventScroll: !0 }), o.goToItem(Ct.Last);
        });
        break;
    }
  }
  function a(f) {
    switch (f.key) {
      case tt.Space:
        f.preventDefault();
        break;
    }
  }
  function l(f) {
    e.disabled || (o.menuState.value === 0 ? (o.closeMenu(), gr(() => {
      var c;
      return (c = Be(o.buttonRef)) == null ? void 0 : c.focus({ preventScroll: !0 });
    })) : (f.preventDefault(), o.openMenu(), Ope(() => {
      var c;
      return (c = Be(o.itemsRef)) == null ? void 0 : c.focus({ preventScroll: !0 });
    })));
  }
  let u = zR(Ne(() => ({ as: e.as, type: t.type })), o.buttonRef);
  return () => {
    var f;
    let c = { open: o.menuState.value === 0 }, { id: d, ...h } = e, p = { ref: o.buttonRef, id: d, type: u.value, "aria-haspopup": "menu", "aria-controls": (f = Be(o.itemsRef)) == null ? void 0 : f.id, "aria-expanded": e.disabled ? void 0 : o.menuState.value === 0, onKeydown: s, onKeyup: a, onClick: l };
    return fr({ ourProps: p, theirProps: h, slot: c, attrs: t, slots: r, name: "MenuButton" });
  };
} }), Fpe = nt({ name: "MenuItems", props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, id: { type: String, default: () => `headlessui-menu-items-${ri()}` } }, setup(e, { attrs: t, slots: r, expose: n }) {
  let o = Wg("MenuItems"), s = $e(null);
  n({ el: o.itemsRef, $el: o.itemsRef }), WB({ container: Ne(() => Be(o.itemsRef)), enabled: Ne(() => o.menuState.value === 0), accept(c) {
    return c.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : c.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(c) {
    c.setAttribute("role", "none");
  } });
  function a(c) {
    var d;
    switch (s.value && clearTimeout(s.value), c.key) {
      case tt.Space:
        if (o.searchQuery.value !== "")
          return c.preventDefault(), c.stopPropagation(), o.search(c.key);
      case tt.Enter:
        if (c.preventDefault(), c.stopPropagation(), o.activeItemIndex.value !== null) {
          let h = o.items.value[o.activeItemIndex.value];
          (d = Be(h.dataRef.domRef)) == null || d.click();
        }
        o.closeMenu(), HB(Be(o.buttonRef));
        break;
      case tt.ArrowDown:
        return c.preventDefault(), c.stopPropagation(), o.goToItem(Ct.Next);
      case tt.ArrowUp:
        return c.preventDefault(), c.stopPropagation(), o.goToItem(Ct.Previous);
      case tt.Home:
      case tt.PageUp:
        return c.preventDefault(), c.stopPropagation(), o.goToItem(Ct.First);
      case tt.End:
      case tt.PageDown:
        return c.preventDefault(), c.stopPropagation(), o.goToItem(Ct.Last);
      case tt.Escape:
        c.preventDefault(), c.stopPropagation(), o.closeMenu(), gr(() => {
          var h;
          return (h = Be(o.buttonRef)) == null ? void 0 : h.focus({ preventScroll: !0 });
        });
        break;
      case tt.Tab:
        c.preventDefault(), c.stopPropagation(), o.closeMenu(), gr(() => Xhe(Be(o.buttonRef), c.shiftKey ? Qr.Previous : Qr.Next));
        break;
      default:
        c.key.length === 1 && (o.search(c.key), s.value = setTimeout(() => o.clearSearch(), 350));
        break;
    }
  }
  function l(c) {
    switch (c.key) {
      case tt.Space:
        c.preventDefault();
        break;
    }
  }
  let u = HR(), f = Ne(() => u !== null ? (u.value & dn.Open) === dn.Open : o.menuState.value === 0);
  return () => {
    var c, d;
    let h = { open: o.menuState.value === 0 }, { id: p, ...m } = e, y = { "aria-activedescendant": o.activeItemIndex.value === null || (c = o.items.value[o.activeItemIndex.value]) == null ? void 0 : c.id, "aria-labelledby": (d = Be(o.buttonRef)) == null ? void 0 : d.id, id: p, onKeydown: a, onKeyup: l, role: "menu", tabIndex: 0, ref: o.itemsRef };
    return fr({ ourProps: y, theirProps: m, slot: h, attrs: t, slots: r, features: Na.RenderStrategy | Na.Static, visible: f.value, name: "MenuItems" });
  };
} }), M2 = nt({ name: "MenuItem", inheritAttrs: !1, props: { as: { type: [Object, String], default: "template" }, disabled: { type: Boolean, default: !1 }, id: { type: String, default: () => `headlessui-menu-item-${ri()}` } }, setup(e, { slots: t, attrs: r, expose: n }) {
  let o = Wg("MenuItem"), s = $e(null);
  n({ el: s, $el: s });
  let a = Ne(() => o.activeItemIndex.value !== null ? o.items.value[o.activeItemIndex.value].id === e.id : !1), l = sq(s), u = Ne(() => ({ disabled: e.disabled, get textValue() {
    return l();
  }, domRef: s }));
  Dt(() => o.registerItem(e.id, u)), xn(() => o.unregisterItem(e.id)), Qn(() => {
    o.menuState.value === 0 && a.value && o.activationTrigger.value !== 0 && gr(() => {
      var y, _;
      return (_ = (y = Be(s)) == null ? void 0 : y.scrollIntoView) == null ? void 0 : _.call(y, { block: "nearest" });
    });
  });
  function f(y) {
    if (e.disabled)
      return y.preventDefault();
    o.closeMenu(), HB(Be(o.buttonRef));
  }
  function c() {
    if (e.disabled)
      return o.goToItem(Ct.Nothing);
    o.goToItem(Ct.Specific, e.id);
  }
  let d = YB();
  function h(y) {
    d.update(y);
  }
  function p(y) {
    d.wasMoved(y) && (e.disabled || a.value || o.goToItem(Ct.Specific, e.id, 0));
  }
  function m(y) {
    d.wasMoved(y) && (e.disabled || a.value && o.goToItem(Ct.Nothing));
  }
  return () => {
    let { disabled: y } = e, _ = { active: a.value, disabled: y, close: o.closeMenu }, { id: S, ...x } = e;
    return fr({ ourProps: { id: S, ref: s, role: "menuitem", tabIndex: y === !0 ? void 0 : -1, "aria-disabled": y === !0 ? !0 : void 0, disabled: void 0, onClick: f, onFocus: c, onPointerenter: h, onMouseenter: h, onPointermove: p, onMousemove: p, onPointerleave: m, onMouseleave: m }, theirProps: { ...r, ...x }, slot: _, attrs: r, slots: t, name: "MenuItem" });
  };
} }), jpe = Symbol("LabelContext");
function uq({ slot: e = {}, name: t = "Label", props: r = {} } = {}) {
  let n = $e([]);
  function o(s) {
    return n.value.push(s), () => {
      let a = n.value.indexOf(s);
      a !== -1 && n.value.splice(a, 1);
    };
  }
  return Tn(jpe, { register: o, slot: e, name: t, props: r }), Ne(() => n.value.length > 0 ? n.value.join(" ") : void 0);
}
function Bpe(e, t) {
  return e === t;
}
let fq = Symbol("RadioGroupContext");
function cq(e) {
  let t = yr(fq, null);
  if (t === null) {
    let r = new Error(`<${e} /> is missing a parent <RadioGroup /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, cq), r;
  }
  return t;
}
let qpe = nt({ name: "RadioGroup", emits: { "update:modelValue": (e) => !0 }, props: { as: { type: [Object, String], default: "div" }, disabled: { type: [Boolean], default: !1 }, by: { type: [String, Function], default: () => Bpe }, modelValue: { type: [Object, String, Number, Boolean], default: void 0 }, defaultValue: { type: [Object, String, Number, Boolean], default: void 0 }, form: { type: String, optional: !0 }, name: { type: String, optional: !0 }, id: { type: String, default: () => `headlessui-radiogroup-${ri()}` } }, inheritAttrs: !1, setup(e, { emit: t, attrs: r, slots: n, expose: o }) {
  let s = $e(null), a = $e([]), l = uq({ name: "RadioGroupLabel" }), u = YR({ name: "RadioGroupDescription" });
  o({ el: s, $el: s });
  let [f, c] = KR(Ne(() => e.modelValue), (m) => t("update:modelValue", m), Ne(() => e.defaultValue)), d = { options: a, value: f, disabled: Ne(() => e.disabled), firstOption: Ne(() => a.value.find((m) => !m.propsRef.disabled)), containsCheckedOption: Ne(() => a.value.some((m) => d.compare(Fe(m.propsRef.value), Fe(e.modelValue)))), compare(m, y) {
    if (typeof e.by == "string") {
      let _ = e.by;
      return (m == null ? void 0 : m[_]) === (y == null ? void 0 : y[_]);
    }
    return e.by(m, y);
  }, change(m) {
    var y;
    if (e.disabled || d.compare(Fe(f.value), Fe(m)))
      return !1;
    let _ = (y = a.value.find((S) => d.compare(Fe(S.propsRef.value), Fe(m)))) == null ? void 0 : y.propsRef;
    return _ != null && _.disabled ? !1 : (c(m), !0);
  }, registerOption(m) {
    a.value.push(m), a.value = Bg(a.value, (y) => y.element);
  }, unregisterOption(m) {
    let y = a.value.findIndex((_) => _.id === m);
    y !== -1 && a.value.splice(y, 1);
  } };
  Tn(fq, d), WB({ container: Ne(() => Be(s)), accept(m) {
    return m.getAttribute("role") === "radio" ? NodeFilter.FILTER_REJECT : m.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(m) {
    m.setAttribute("role", "none");
  } });
  function h(m) {
    if (!s.value || !s.value.contains(m.target))
      return;
    let y = a.value.filter((_) => _.propsRef.disabled === !1).map((_) => _.element);
    switch (m.key) {
      case tt.Enter:
        KB(m.currentTarget);
        break;
      case tt.ArrowLeft:
      case tt.ArrowUp:
        if (m.preventDefault(), m.stopPropagation(), va(y, Qr.Previous | Qr.WrapAround) === Wh.Success) {
          let _ = a.value.find((S) => {
            var x;
            return S.element === ((x = Yn(s)) == null ? void 0 : x.activeElement);
          });
          _ && d.change(_.propsRef.value);
        }
        break;
      case tt.ArrowRight:
      case tt.ArrowDown:
        if (m.preventDefault(), m.stopPropagation(), va(y, Qr.Next | Qr.WrapAround) === Wh.Success) {
          let _ = a.value.find((S) => {
            var x;
            return S.element === ((x = Yn(S.element)) == null ? void 0 : x.activeElement);
          });
          _ && d.change(_.propsRef.value);
        }
        break;
      case tt.Space:
        {
          m.preventDefault(), m.stopPropagation();
          let _ = a.value.find((S) => {
            var x;
            return S.element === ((x = Yn(S.element)) == null ? void 0 : x.activeElement);
          });
          _ && d.change(_.propsRef.value);
        }
        break;
    }
  }
  let p = Ne(() => {
    var m;
    return (m = Be(s)) == null ? void 0 : m.closest("form");
  });
  return Dt(() => {
    br([p], () => {
      if (!p.value || e.defaultValue === void 0)
        return;
      function m() {
        d.change(e.defaultValue);
      }
      return p.value.addEventListener("reset", m), () => {
        var y;
        (y = p.value) == null || y.removeEventListener("reset", m);
      };
    }, { immediate: !0 });
  }), () => {
    let { disabled: m, name: y, id: _, form: S, ...x } = e, E = { ref: s, id: _, role: "radiogroup", "aria-labelledby": l.value, "aria-describedby": u.value, onKeydown: h };
    return Ut(lt, [...y != null && f.value != null ? VR({ [y]: f.value }).map(([C, I]) => Ut(ou, UR({ features: La.Hidden, key: C, as: "input", type: "hidden", hidden: !0, readOnly: !0, form: S, name: C, value: I }))) : [], fr({ ourProps: E, theirProps: { ...r, ...Pg(x, ["modelValue", "defaultValue", "by"]) }, slot: {}, attrs: r, slots: n, name: "RadioGroup" })]);
  };
} });
var Wpe = ((e) => (e[e.Empty = 1] = "Empty", e[e.Active = 2] = "Active", e))(Wpe || {});
let Upe = nt({ name: "RadioGroupOption", props: { as: { type: [Object, String], default: "div" }, value: { type: [Object, String, Number, Boolean] }, disabled: { type: Boolean, default: !1 }, id: { type: String, default: () => `headlessui-radiogroup-option-${ri()}` } }, setup(e, { attrs: t, slots: r, expose: n }) {
  let o = cq("RadioGroupOption"), s = uq({ name: "RadioGroupLabel" }), a = YR({ name: "RadioGroupDescription" }), l = $e(null), u = Ne(() => ({ value: e.value, disabled: e.disabled })), f = $e(1);
  n({ el: l, $el: l });
  let c = Ne(() => Be(l));
  Dt(() => o.registerOption({ id: e.id, element: c, propsRef: u })), xn(() => o.unregisterOption(e.id));
  let d = Ne(() => {
    var x;
    return ((x = o.firstOption.value) == null ? void 0 : x.id) === e.id;
  }), h = Ne(() => o.disabled.value || e.disabled), p = Ne(() => o.compare(Fe(o.value.value), Fe(e.value))), m = Ne(() => h.value ? -1 : p.value || !o.containsCheckedOption.value && d.value ? 0 : -1);
  function y() {
    var x;
    o.change(e.value) && (f.value |= 2, (x = Be(l)) == null || x.focus());
  }
  function _() {
    f.value |= 2;
  }
  function S() {
    f.value &= -3;
  }
  return () => {
    let { id: x, value: E, disabled: C, ...I } = e, j = { checked: p.value, disabled: h.value, active: !!(f.value & 2) }, J = { id: x, ref: l, role: "radio", "aria-checked": p.value ? "true" : "false", "aria-labelledby": s.value, "aria-describedby": a.value, "aria-disabled": h.value ? !0 : void 0, tabIndex: m.value, onClick: h.value ? void 0 : y, onFocus: h.value ? void 0 : _, onBlur: h.value ? void 0 : S };
    return fr({ ourProps: J, theirProps: I, slot: j, attrs: t, slots: r, name: "RadioGroupOption" });
  };
} }), Hpe = Symbol("GroupContext"), zpe = nt({ name: "Switch", emits: { "update:modelValue": (e) => !0 }, props: { as: { type: [Object, String], default: "button" }, modelValue: { type: Boolean, default: void 0 }, defaultChecked: { type: Boolean, optional: !0 }, form: { type: String, optional: !0 }, name: { type: String, optional: !0 }, value: { type: String, optional: !0 }, id: { type: String, default: () => `headlessui-switch-${ri()}` } }, inheritAttrs: !1, setup(e, { emit: t, attrs: r, slots: n, expose: o }) {
  let s = yr(Hpe, null), [a, l] = KR(Ne(() => e.modelValue), (_) => t("update:modelValue", _), Ne(() => e.defaultChecked));
  function u() {
    l(!a.value);
  }
  let f = $e(null), c = s === null ? f : s.switchRef, d = zR(Ne(() => ({ as: e.as, type: r.type })), c);
  o({ el: c, $el: c });
  function h(_) {
    _.preventDefault(), u();
  }
  function p(_) {
    _.key === tt.Space ? (_.preventDefault(), u()) : _.key === tt.Enter && KB(_.currentTarget);
  }
  function m(_) {
    _.preventDefault();
  }
  let y = Ne(() => {
    var _, S;
    return (S = (_ = Be(c)) == null ? void 0 : _.closest) == null ? void 0 : S.call(_, "form");
  });
  return Dt(() => {
    br([y], () => {
      if (!y.value || e.defaultChecked === void 0)
        return;
      function _() {
        l(e.defaultChecked);
      }
      return y.value.addEventListener("reset", _), () => {
        var S;
        (S = y.value) == null || S.removeEventListener("reset", _);
      };
    }, { immediate: !0 });
  }), () => {
    let { id: _, name: S, value: x, form: E, ...C } = e, I = { checked: a.value }, j = { id: _, ref: c, role: "switch", type: d.value, tabIndex: 0, "aria-checked": a.value, "aria-labelledby": s == null ? void 0 : s.labelledby.value, "aria-describedby": s == null ? void 0 : s.describedby.value, onClick: h, onKeyup: p, onKeypress: m };
    return Ut(lt, [S != null && a.value != null ? Ut(ou, UR({ features: La.Hidden, as: "input", type: "checkbox", hidden: !0, readOnly: !0, checked: a.value, form: E, name: S, value: x })) : null, fr({ ourProps: j, theirProps: { ...r, ...Pg(C, ["modelValue", "defaultChecked"]) }, slot: I, attrs: r, slots: n, name: "Switch" })]);
  };
} });
const Gpe = { class: "flex items-center justify-center min-h-screen" }, Vpe = { class: "modal-card" }, Kpe = {
  name: "SpexDialog"
}, dq = /* @__PURE__ */ nt({
  ...Kpe,
  props: {
    open: { type: Boolean }
  },
  emits: ["close"],
  setup(e, { emit: t }) {
    return (r, n) => (we(), Et(Pe(_pe), {
      open: r.open,
      onClose: n[0] || (n[0] = (o) => r.$emit("close")),
      class: "fixed inset-0 z-10 overflow-y-auto"
    }, {
      default: Ge(() => [
        ie("div", Gpe, [
          Ee(Pe(Spe), { class: "fixed inset-0 bg-black opacity-50" }),
          ie("div", Vpe, [
            io(r.$slots, "default")
          ])
        ])
      ]),
      _: 3
    }, 8, ["open"]));
  }
}), Ype = { class: "group inline-block relative" }, Xpe = {
  key: 0,
  class: "invisible group-hover:visible absolute z-10 bottom-full left-1/2 -translate-x-1/2 -translate-y-1 delay-300"
}, Jpe = { class: "bg-gray-800 text-white font-normal text-sm rounded py-1 px-3 whitespace-nowrap" }, Qpe = /* @__PURE__ */ ie("svg", {
  class: "absolute h-3 w-full left-0 top-full fill-current text-gray-800",
  viewBox: "0 0 255 255"
}, [
  /* @__PURE__ */ ie("polygon", { points: "0,0 127.5,127.5 255,0" })
], -1), Zpe = {
  name: "SpexTooltip"
}, Wr = /* @__PURE__ */ nt({
  ...Zpe,
  props: {
    label: {},
    position: {}
  },
  setup(e) {
    return (t, r) => (we(), Te("div", Ype, [
      t.label ? (we(), Te("div", Xpe, [
        ie("div", Jpe, [
          tn(pt(t.label) + " ", 1),
          Qpe
        ])
      ])) : gt("", !0),
      ie("div", null, [
        io(t.$slots, "default")
      ])
    ]));
  }
}), hq = (e) => (D4("data-v-a0722119"), e = e(), F4(), e), ege = { class: "modal-card-head py-4" }, tge = /* @__PURE__ */ hq(() => /* @__PURE__ */ ie("h3", { style: { color: "grey" } }, "Generated SHACL shapes", -1)), rge = { class: "ml-auto" }, nge = { class: "modal-card-body overflow-y-hidden flex flex-col pb-0" }, ige = { class: "flex justify-between" }, oge = { class: "flex items-center gap-2" }, sge = /* @__PURE__ */ hq(() => /* @__PURE__ */ ie("span", null, "Copy", -1)), age = {
  name: "ModalShacl"
}, lge = /* @__PURE__ */ nt({
  ...age,
  props: {
    datamodel: {},
    loadShacl: {}
  },
  emits: ["close", "open-load-shacl"],
  setup(e, { emit: t }) {
    const r = e, n = co.getInstance(), o = Ne(() => n.prefixes.reduce((p, { prefix: m, namespace: y }) => ({ ...p, [m]: y }), {})), s = Ne(() => [...n.dataModelToSHACL(r.datamodel).dataset]), a = $e(null), l = $e(null), u = $e([
      { label: "JSON-LD", value: "application/ld+json" },
      { label: "Turtle", value: "text/turtle" },
      { label: "N-Triples", value: "application/n-triples" }
    ]), f = $e("application/ld+json"), c = $e(["sh", "schema"].join(","));
    async function d() {
      const p = l.value.codeMirror.value;
      await navigator.clipboard.writeText(p), a.value = "Copied ", setTimeout(() => {
        a.value = null;
      }, 3e3);
    }
    function h() {
      t("open-load-shacl"), t("close");
    }
    return (p, m) => {
      const y = x1("rdf-editor");
      return we(), Et(dq, {
        onClose: m[2] || (m[2] = (_) => p.$emit("close"))
      }, {
        default: Ge(() => [
          ie("div", ege, [
            tge,
            ie("div", rge, [
              Ee(Wr, {
                label: "Load SHACL shapes",
                position: "bottom",
                class: "mr-4"
              }, {
                default: Ge(() => [
                  ie("button", {
                    class: "button",
                    onClick: h
                  }, [
                    Ee(Pe(qH), { class: "icon" })
                  ])
                ]),
                _: 1
              }),
              Ee(Wr, {
                label: "Close",
                position: "bottom"
              }, {
                default: Ge(() => [
                  ie("button", {
                    class: "button is-light",
                    onClick: m[0] || (m[0] = (_) => p.$emit("close"))
                  }, [
                    Ee(Pe(as), { class: "icon" })
                  ])
                ]),
                _: 1
              })
            ])
          ]),
          ie("div", nge, [
            ie("div", ige, [
              Ee(Pe(qpe), {
                modelValue: f.value,
                "onUpdate:modelValue": m[1] || (m[1] = (_) => f.value = _),
                class: "field has-addons"
              }, {
                default: Ge(() => [
                  (we(!0), Te(lt, null, pr(u.value, (_) => (we(), Et(Pe(Upe), {
                    key: _.value,
                    value: _.value,
                    class: "control"
                  }, {
                    default: Ge(({ checked: S }) => [
                      ie("span", {
                        class: lr(["button", S ? "is-primary" : ""])
                      }, pt(_.label), 3)
                    ]),
                    _: 2
                  }, 1032, ["value"]))), 128))
                ]),
                _: 1
              }, 8, ["modelValue"]),
              ie("div", oge, [
                Fr(ie("span", { class: "text-green-500" }, pt(a.value), 513), [
                  [Ea, a.value]
                ]),
                ie("button", {
                  class: "button",
                  onClick: d
                }, [
                  Ee(Pe(aD), { class: "icon" }),
                  sge
                ])
              ])
            ]),
            Ee(y, {
              format: f.value,
              ".quads": s.value,
              ".prefixes": c.value,
              ".customPrefixes": o.value,
              ref_key: "snippet",
              ref: l,
              class: "overflow-y-auto"
            }, null, 8, ["format", ".quads", ".prefixes", ".customPrefixes"])
          ])
        ]),
        _: 1
      });
    };
  }
}), ni = (e, t) => {
  const r = e.__vccOpts || e;
  for (const [n, o] of t)
    r[n] = o;
  return r;
}, uge = /* @__PURE__ */ ni(lge, [["__scopeId", "data-v-a0722119"]]), fge = {
  name: "ModalShaclLoad",
  props: ["load", "endpoint"],
  emits: ["close"],
  components: { SpexDialog: dq, XMarkIcon: as },
  data() {
    return {
      data: "",
      error: null
    };
  },
  methods: {
    async onSubmit() {
      if (this.data)
        try {
          const e = Vt.formast.parsers.import("text/turtle", M8.Readable.from(this.data)), t = await Vt.dataset().import(e), r = Vt.clownface({ dataset: t, term: Jo.DefaultShapes }).in(Un.type).in(Jo.shape);
          if (!r.term)
            throw new Error("No node with spex:shape pointing to a spex:DefaultShapes found");
          const n = this.endpoint.dataModelFromSHACL(r);
          this.load(n), this.$emit("close");
        } catch (e) {
          this.error = e.toString();
        }
    }
  }
}, cge = { class: "modal-card-head py-4" }, dge = /* @__PURE__ */ ie("h3", { style: { color: "grey" } }, "Load SHACL shapes", -1), hge = { class: "ml-auto" }, pge = { class: "modal-card-body" }, gge = { class: "field" }, bge = {
  key: 0,
  class: "help is-danger"
}, yge = /* @__PURE__ */ ie("p", {
  class: "help",
  style: { color: "grey" }
}, [
  /* @__PURE__ */ tn(" Paste your SHACL shapes in "),
  /* @__PURE__ */ ie("strong", null, "Turtle"),
  /* @__PURE__ */ tn(" format in the field above. ")
], -1), mge = /* @__PURE__ */ ie("div", { class: "field" }, [
  /* @__PURE__ */ ie("button", {
    class: "button is-primary",
    type: "submit"
  }, "Load")
], -1);
function vge(e, t, r, n, o, s) {
  const a = x1("XMarkIcon"), l = x1("SpexDialog");
  return we(), Et(l, {
    onClose: t[3] || (t[3] = (u) => e.$emit("close"))
  }, {
    default: Ge(() => [
      ie("div", cge, [
        dge,
        ie("div", hge, [
          ie("button", {
            class: "button is-light",
            title: "Close",
            onClick: t[0] || (t[0] = (u) => e.$emit("close"))
          }, [
            Ee(a, { class: "icon" })
          ])
        ])
      ]),
      ie("div", pge, [
        ie("form", {
          onSubmit: t[2] || (t[2] = kH((...u) => s.onSubmit && s.onSubmit(...u), ["prevent"]))
        }, [
          ie("div", gge, [
            Fr(ie("textarea", {
              type: "textarea",
              class: lr(["textarea", { "is-danger": o.error }]),
              "onUpdate:modelValue": t[1] || (t[1] = (u) => o.data = u)
            }, null, 2), [
              [zo, o.data]
            ]),
            o.error ? (we(), Te("p", bge, pt(o.error), 1)) : gt("", !0),
            yge
          ]),
          mge
        ], 32)
      ])
    ]),
    _: 1
  });
}
const wge = /* @__PURE__ */ ni(fge, [["render", vge]]), _ge = { class: "flex justify-center flex-row gap-1" }, Sge = { class: "relative z-50 text-right flex justify-center flex-row" }, Ege = { class: "flex h-full justify-center" }, xge = { class: "px-1 py-1" }, Rge = {
  name: "ShapeComponentActions"
}, Age = /* @__PURE__ */ nt({
  ...Rge,
  props: {
    table: {}
  },
  emits: ["hide", "explore", "export"],
  setup(e, { emit: t }) {
    const r = $e(null);
    function n(o) {
      t("export", o), r.value = "", setTimeout(() => {
        r.value = null;
      }, 1500);
    }
    return (o, s) => (we(), Te("div", _ge, [
      ie("div", null, [
        ie("div", Sge, [
          Ee(Pe(Ppe), {
            as: "div",
            class: "relative inline-block"
          }, {
            default: Ge(() => [
              ie("div", Ege, [
                Ee(Pe(Dpe), {
                  style: { "font-size": "0.75rem", height: "2.5em", width: "2.5em", "border-radius": "2px", "padding-top": "1px" },
                  class: "inline-flex w-full justify-center rounded-md bg-black bg-opacity-20 text-sm font-medium text-white hover:bg-opacity-30 focus:outline-none focus-visible:ring-2 focus-visible:ring-white focus-visible:ring-opacity-75"
                }, {
                  default: Ge(() => [
                    Ee(Pe(VH), {
                      class: "h-7 w-7 --color-primary-300 hover:text-orange",
                      "aria-hidden": "true"
                    })
                  ]),
                  _: 1
                })
              ]),
              Ee(yp, {
                "enter-active-class": "transition duration-100 ease-out",
                "enter-from-class": "transform scale-95 opacity-0",
                "enter-to-class": "transform scale-100 opacity-100",
                "leave-active-class": "transition duration-75 ease-in",
                "leave-from-class": "transform scale-100 opacity-100",
                "leave-to-class": "transform scale-95 opacity-0"
              }, {
                default: Ge(() => [
                  Ee(Pe(Fpe), { class: "absolute right-0 mt-2 w-56 origin-top-right divide-y divide-gray-100 rounded-md bg-white shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none" }, {
                    default: Ge(() => [
                      ie("div", xge, [
                        Ee(Pe(M2), null, {
                          default: Ge(({ active: a }) => [
                            ie("button", {
                              class: lr([
                                a ? "bg-orange-400 text-white" : "text-gray-900",
                                "group flex w-full items-center rounded-md px-2 py-2 text-sm"
                              ]),
                              onClick: s[0] || (s[0] = (l) => n(o.table))
                            }, [
                              Ee(Pe(aD), {
                                class: "mr-2 h-5 w-5 icon",
                                "aria-hidden": "true"
                              }),
                              tn(" Copy NodeShape ")
                            ], 2)
                          ]),
                          _: 1
                        }),
                        Ee(Pe(M2), null, {
                          default: Ge(({ active: a }) => [
                            ie("button", {
                              class: lr([
                                a ? "bg-orange-400 text-white" : "text-gray-900",
                                "group flex w-full items-center rounded-md px-2 py-2 text-sm"
                              ]),
                              onClick: s[1] || (s[1] = (l) => o.$emit("explore", o.table))
                            }, [
                              Ee(Pe(JH), {
                                class: "mr-2 h-5 w-5 icon",
                                "aria-hidden": "true"
                              }),
                              tn(" Explore Data ")
                            ], 2)
                          ]),
                          _: 1
                        })
                      ])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ])
      ]),
      Ee(Wr, { label: "Hide" }, {
        default: Ge(() => [
          ie("button", {
            class: "button is-light is-small",
            onClick: s[2] || (s[2] = (a) => o.$emit("hide", o.table))
          }, [
            Ee(Pe(lD), { class: "icon" })
          ])
        ]),
        _: 1
      })
    ]));
  }
}), Tge = { class: "font-bold" }, $ge = { class: "w-full" }, Cge = ["data-id", "onMouseenter", "onMouseleave"], kge = { class: "text-inherit dark:border-gray-500 px-3 py-2" }, Ige = { class: "text-inherit dark:border-gray-500 px-3 py-2" }, Mge = {
  name: "ShapeComponent"
}, Nge = /* @__PURE__ */ nt({
  ...Mge,
  props: {
    table: {},
    activeLinks: {}
  },
  emits: ["hide", "explore", "export", "hover-title", "unhover-title", "hover-property", "unhover-property"],
  setup(e, { emit: t }) {
    const r = e;
    function n(a) {
      a.stopPropagation();
    }
    const o = Ne(() => r.activeLinks.some((a) => a.target === r.table.id));
    function s(a) {
      return r.activeLinks.some((l) => l.source === r.table.id && l.sourceProperty === a.id);
    }
    return (a, l) => (we(), Te("div", {
      class: lr(["border dark:border-gray-500 rounded-lg shadow-md bg-white dark:bg-gray-800 opacity-90 text-sm", { active: o.value }])
    }, [
      ie("header", {
        class: "bg-gray-100 dark:bg-gray-900 flex items-center gap-4 justify-between px-3 py-2 rounded-lg",
        onMouseenter: l[3] || (l[3] = (u) => a.$emit("hover-title", a.table)),
        onMouseleave: l[4] || (l[4] = (u) => a.$emit("unhover-title", a.table))
      }, [
        Ee(Wr, {
          label: a.table.id
        }, {
          default: Ge(() => [
            ie("h3", Tge, pt(a.table.name), 1)
          ]),
          _: 1
        }, 8, ["label"]),
        Ee(Age, {
          table: a.table,
          onExport: l[0] || (l[0] = (u) => a.$emit("export", a.table)),
          onHide: l[1] || (l[1] = (u) => a.$emit("hide", a.table)),
          onExplore: l[2] || (l[2] = (u) => a.$emit("explore", a.table))
        }, null, 8, ["table"])
      ], 32),
      ie("table", $ge, [
        (we(!0), Te(lt, null, pr(a.table.properties, (u, f) => (we(), Te("tr", {
          class: lr(["border-b last:border-b-0 hover:bg-orange-400 hover:bg-opacity-20 text-gray-800 dark:text-gray-50", { active: s(u) }]),
          key: f,
          "data-id": u.id,
          onMouseenter: (c) => a.$emit("hover-property", a.table, u),
          onMouseleave: (c) => a.$emit("unhover-property", a.table, u)
        }, [
          ie("th", kge, [
            Ee(Wr, {
              label: u.id
            }, {
              default: Ge(() => [
                ie("span", { onMousedown: n }, pt(u.name), 33)
              ]),
              _: 2
            }, 1032, ["label"])
          ]),
          ie("td", Ige, [
            (we(!0), Te(lt, null, pr(u.values, (c) => (we(), Te("div", {
              key: c.id
            }, [
              io(a.$slots, "property-value", { value: c }, () => [
                Ee(Wr, {
                  label: c.id
                }, {
                  default: Ge(() => [
                    ie("span", { onMousedown: n }, pt(c.name), 33)
                  ]),
                  _: 2
                }, 1032, ["label"])
              ])
            ]))), 128))
          ])
        ], 42, Cge))), 128))
      ])
    ], 2));
  }
});
var Lge = { value: () => {
} };
function Ic() {
  for (var e = 0, t = arguments.length, r = {}, n; e < t; ++e) {
    if (!(n = arguments[e] + "") || n in r || /[\s.]/.test(n))
      throw new Error("illegal type: " + n);
    r[n] = [];
  }
  return new Jd(r);
}
function Jd(e) {
  this._ = e;
}
function Oge(e, t) {
  return e.trim().split(/^|\s+/).map(function(r) {
    var n = "", o = r.indexOf(".");
    if (o >= 0 && (n = r.slice(o + 1), r = r.slice(0, o)), r && !t.hasOwnProperty(r))
      throw new Error("unknown type: " + r);
    return { type: r, name: n };
  });
}
Jd.prototype = Ic.prototype = {
  constructor: Jd,
  on: function(e, t) {
    var r = this._, n = Oge(e + "", r), o, s = -1, a = n.length;
    if (arguments.length < 2) {
      for (; ++s < a; )
        if ((o = (e = n[s]).type) && (o = Pge(r[o], e.name)))
          return o;
      return;
    }
    if (t != null && typeof t != "function")
      throw new Error("invalid callback: " + t);
    for (; ++s < a; )
      if (o = (e = n[s]).type)
        r[o] = N2(r[o], e.name, t);
      else if (t == null)
        for (o in r)
          r[o] = N2(r[o], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var r in t)
      e[r] = t[r].slice();
    return new Jd(e);
  },
  call: function(e, t) {
    if ((o = arguments.length - 2) > 0)
      for (var r = new Array(o), n = 0, o, s; n < o; ++n)
        r[n] = arguments[n + 2];
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (s = this._[e], n = 0, o = s.length; n < o; ++n)
      s[n].value.apply(t, r);
  },
  apply: function(e, t, r) {
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (var n = this._[e], o = 0, s = n.length; o < s; ++o)
      n[o].value.apply(t, r);
  }
};
function Pge(e, t) {
  for (var r = 0, n = e.length, o; r < n; ++r)
    if ((o = e[r]).name === t)
      return o.value;
}
function N2(e, t, r) {
  for (var n = 0, o = e.length; n < o; ++n)
    if (e[n].name === t) {
      e[n] = Lge, e = e.slice(0, n).concat(e.slice(n + 1));
      break;
    }
  return r != null && e.push({ name: t, value: r }), e;
}
var cE = "http://www.w3.org/1999/xhtml";
const L2 = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: cE,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Ug(e) {
  var t = e += "", r = t.indexOf(":");
  return r >= 0 && (t = e.slice(0, r)) !== "xmlns" && (e = e.slice(r + 1)), L2.hasOwnProperty(t) ? { space: L2[t], local: e } : e;
}
function Dge(e) {
  return function() {
    var t = this.ownerDocument, r = this.namespaceURI;
    return r === cE && t.documentElement.namespaceURI === cE ? t.createElement(e) : t.createElementNS(r, e);
  };
}
function Fge(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function pq(e) {
  var t = Ug(e);
  return (t.local ? Fge : Dge)(t);
}
function jge() {
}
function XR(e) {
  return e == null ? jge : function() {
    return this.querySelector(e);
  };
}
function Bge(e) {
  typeof e != "function" && (e = XR(e));
  for (var t = this._groups, r = t.length, n = new Array(r), o = 0; o < r; ++o)
    for (var s = t[o], a = s.length, l = n[o] = new Array(a), u, f, c = 0; c < a; ++c)
      (u = s[c]) && (f = e.call(u, u.__data__, c, s)) && ("__data__" in u && (f.__data__ = u.__data__), l[c] = f);
  return new pn(n, this._parents);
}
function qge(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function Wge() {
  return [];
}
function gq(e) {
  return e == null ? Wge : function() {
    return this.querySelectorAll(e);
  };
}
function Uge(e) {
  return function() {
    return qge(e.apply(this, arguments));
  };
}
function Hge(e) {
  typeof e == "function" ? e = Uge(e) : e = gq(e);
  for (var t = this._groups, r = t.length, n = [], o = [], s = 0; s < r; ++s)
    for (var a = t[s], l = a.length, u, f = 0; f < l; ++f)
      (u = a[f]) && (n.push(e.call(u, u.__data__, f, a)), o.push(u));
  return new pn(n, o);
}
function bq(e) {
  return function() {
    return this.matches(e);
  };
}
function yq(e) {
  return function(t) {
    return t.matches(e);
  };
}
var zge = Array.prototype.find;
function Gge(e) {
  return function() {
    return zge.call(this.children, e);
  };
}
function Vge() {
  return this.firstElementChild;
}
function Kge(e) {
  return this.select(e == null ? Vge : Gge(typeof e == "function" ? e : yq(e)));
}
var Yge = Array.prototype.filter;
function Xge() {
  return Array.from(this.children);
}
function Jge(e) {
  return function() {
    return Yge.call(this.children, e);
  };
}
function Qge(e) {
  return this.selectAll(e == null ? Xge : Jge(typeof e == "function" ? e : yq(e)));
}
function Zge(e) {
  typeof e != "function" && (e = bq(e));
  for (var t = this._groups, r = t.length, n = new Array(r), o = 0; o < r; ++o)
    for (var s = t[o], a = s.length, l = n[o] = [], u, f = 0; f < a; ++f)
      (u = s[f]) && e.call(u, u.__data__, f, s) && l.push(u);
  return new pn(n, this._parents);
}
function mq(e) {
  return new Array(e.length);
}
function ebe() {
  return new pn(this._enter || this._groups.map(mq), this._parents);
}
function Uh(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
Uh.prototype = {
  constructor: Uh,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function tbe(e) {
  return function() {
    return e;
  };
}
function rbe(e, t, r, n, o, s) {
  for (var a = 0, l, u = t.length, f = s.length; a < f; ++a)
    (l = t[a]) ? (l.__data__ = s[a], n[a] = l) : r[a] = new Uh(e, s[a]);
  for (; a < u; ++a)
    (l = t[a]) && (o[a] = l);
}
function nbe(e, t, r, n, o, s, a) {
  var l, u, f = /* @__PURE__ */ new Map(), c = t.length, d = s.length, h = new Array(c), p;
  for (l = 0; l < c; ++l)
    (u = t[l]) && (h[l] = p = a.call(u, u.__data__, l, t) + "", f.has(p) ? o[l] = u : f.set(p, u));
  for (l = 0; l < d; ++l)
    p = a.call(e, s[l], l, s) + "", (u = f.get(p)) ? (n[l] = u, u.__data__ = s[l], f.delete(p)) : r[l] = new Uh(e, s[l]);
  for (l = 0; l < c; ++l)
    (u = t[l]) && f.get(h[l]) === u && (o[l] = u);
}
function ibe(e) {
  return e.__data__;
}
function obe(e, t) {
  if (!arguments.length)
    return Array.from(this, ibe);
  var r = t ? nbe : rbe, n = this._parents, o = this._groups;
  typeof e != "function" && (e = tbe(e));
  for (var s = o.length, a = new Array(s), l = new Array(s), u = new Array(s), f = 0; f < s; ++f) {
    var c = n[f], d = o[f], h = d.length, p = sbe(e.call(c, c && c.__data__, f, n)), m = p.length, y = l[f] = new Array(m), _ = a[f] = new Array(m), S = u[f] = new Array(h);
    r(c, d, y, _, S, p, t);
    for (var x = 0, E = 0, C, I; x < m; ++x)
      if (C = y[x]) {
        for (x >= E && (E = x + 1); !(I = _[E]) && ++E < m; )
          ;
        C._next = I || null;
      }
  }
  return a = new pn(a, n), a._enter = l, a._exit = u, a;
}
function sbe(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function abe() {
  return new pn(this._exit || this._groups.map(mq), this._parents);
}
function lbe(e, t, r) {
  var n = this.enter(), o = this, s = this.exit();
  return typeof e == "function" ? (n = e(n), n && (n = n.selection())) : n = n.append(e + ""), t != null && (o = t(o), o && (o = o.selection())), r == null ? s.remove() : r(s), n && o ? n.merge(o).order() : o;
}
function ube(e) {
  for (var t = e.selection ? e.selection() : e, r = this._groups, n = t._groups, o = r.length, s = n.length, a = Math.min(o, s), l = new Array(o), u = 0; u < a; ++u)
    for (var f = r[u], c = n[u], d = f.length, h = l[u] = new Array(d), p, m = 0; m < d; ++m)
      (p = f[m] || c[m]) && (h[m] = p);
  for (; u < o; ++u)
    l[u] = r[u];
  return new pn(l, this._parents);
}
function fbe() {
  for (var e = this._groups, t = -1, r = e.length; ++t < r; )
    for (var n = e[t], o = n.length - 1, s = n[o], a; --o >= 0; )
      (a = n[o]) && (s && a.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(a, s), s = a);
  return this;
}
function cbe(e) {
  e || (e = dbe);
  function t(d, h) {
    return d && h ? e(d.__data__, h.__data__) : !d - !h;
  }
  for (var r = this._groups, n = r.length, o = new Array(n), s = 0; s < n; ++s) {
    for (var a = r[s], l = a.length, u = o[s] = new Array(l), f, c = 0; c < l; ++c)
      (f = a[c]) && (u[c] = f);
    u.sort(t);
  }
  return new pn(o, this._parents).order();
}
function dbe(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function hbe() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function pbe() {
  return Array.from(this);
}
function gbe() {
  for (var e = this._groups, t = 0, r = e.length; t < r; ++t)
    for (var n = e[t], o = 0, s = n.length; o < s; ++o) {
      var a = n[o];
      if (a)
        return a;
    }
  return null;
}
function bbe() {
  let e = 0;
  for (const t of this)
    ++e;
  return e;
}
function ybe() {
  return !this.node();
}
function mbe(e) {
  for (var t = this._groups, r = 0, n = t.length; r < n; ++r)
    for (var o = t[r], s = 0, a = o.length, l; s < a; ++s)
      (l = o[s]) && e.call(l, l.__data__, s, o);
  return this;
}
function vbe(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function wbe(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function _be(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function Sbe(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function Ebe(e, t) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.removeAttribute(e) : this.setAttribute(e, r);
  };
}
function xbe(e, t) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, r);
  };
}
function Rbe(e, t) {
  var r = Ug(e);
  if (arguments.length < 2) {
    var n = this.node();
    return r.local ? n.getAttributeNS(r.space, r.local) : n.getAttribute(r);
  }
  return this.each((t == null ? r.local ? wbe : vbe : typeof t == "function" ? r.local ? xbe : Ebe : r.local ? Sbe : _be)(r, t));
}
function vq(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function Abe(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function Tbe(e, t, r) {
  return function() {
    this.style.setProperty(e, t, r);
  };
}
function $be(e, t, r) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.style.removeProperty(e) : this.style.setProperty(e, n, r);
  };
}
function Cbe(e, t, r) {
  return arguments.length > 1 ? this.each((t == null ? Abe : typeof t == "function" ? $be : Tbe)(e, t, r ?? "")) : su(this.node(), e);
}
function su(e, t) {
  return e.style.getPropertyValue(t) || vq(e).getComputedStyle(e, null).getPropertyValue(t);
}
function kbe(e) {
  return function() {
    delete this[e];
  };
}
function Ibe(e, t) {
  return function() {
    this[e] = t;
  };
}
function Mbe(e, t) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? delete this[e] : this[e] = r;
  };
}
function Nbe(e, t) {
  return arguments.length > 1 ? this.each((t == null ? kbe : typeof t == "function" ? Mbe : Ibe)(e, t)) : this.node()[e];
}
function wq(e) {
  return e.trim().split(/^|\s+/);
}
function JR(e) {
  return e.classList || new _q(e);
}
function _q(e) {
  this._node = e, this._names = wq(e.getAttribute("class") || "");
}
_q.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function Sq(e, t) {
  for (var r = JR(e), n = -1, o = t.length; ++n < o; )
    r.add(t[n]);
}
function Eq(e, t) {
  for (var r = JR(e), n = -1, o = t.length; ++n < o; )
    r.remove(t[n]);
}
function Lbe(e) {
  return function() {
    Sq(this, e);
  };
}
function Obe(e) {
  return function() {
    Eq(this, e);
  };
}
function Pbe(e, t) {
  return function() {
    (t.apply(this, arguments) ? Sq : Eq)(this, e);
  };
}
function Dbe(e, t) {
  var r = wq(e + "");
  if (arguments.length < 2) {
    for (var n = JR(this.node()), o = -1, s = r.length; ++o < s; )
      if (!n.contains(r[o]))
        return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? Pbe : t ? Lbe : Obe)(r, t));
}
function Fbe() {
  this.textContent = "";
}
function jbe(e) {
  return function() {
    this.textContent = e;
  };
}
function Bbe(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function qbe(e) {
  return arguments.length ? this.each(e == null ? Fbe : (typeof e == "function" ? Bbe : jbe)(e)) : this.node().textContent;
}
function Wbe() {
  this.innerHTML = "";
}
function Ube(e) {
  return function() {
    this.innerHTML = e;
  };
}
function Hbe(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function zbe(e) {
  return arguments.length ? this.each(e == null ? Wbe : (typeof e == "function" ? Hbe : Ube)(e)) : this.node().innerHTML;
}
function Gbe() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function Vbe() {
  return this.each(Gbe);
}
function Kbe() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function Ybe() {
  return this.each(Kbe);
}
function Xbe(e) {
  var t = typeof e == "function" ? e : pq(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function Jbe() {
  return null;
}
function Qbe(e, t) {
  var r = typeof e == "function" ? e : pq(e), n = t == null ? Jbe : typeof t == "function" ? t : XR(t);
  return this.select(function() {
    return this.insertBefore(r.apply(this, arguments), n.apply(this, arguments) || null);
  });
}
function Zbe() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function eye() {
  return this.each(Zbe);
}
function tye() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function rye() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function nye(e) {
  return this.select(e ? rye : tye);
}
function iye(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function oye(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function sye(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var r = "", n = t.indexOf(".");
    return n >= 0 && (r = t.slice(n + 1), t = t.slice(0, n)), { type: t, name: r };
  });
}
function aye(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var r = 0, n = -1, o = t.length, s; r < o; ++r)
        s = t[r], (!e.type || s.type === e.type) && s.name === e.name ? this.removeEventListener(s.type, s.listener, s.options) : t[++n] = s;
      ++n ? t.length = n : delete this.__on;
    }
  };
}
function lye(e, t, r) {
  return function() {
    var n = this.__on, o, s = oye(t);
    if (n) {
      for (var a = 0, l = n.length; a < l; ++a)
        if ((o = n[a]).type === e.type && o.name === e.name) {
          this.removeEventListener(o.type, o.listener, o.options), this.addEventListener(o.type, o.listener = s, o.options = r), o.value = t;
          return;
        }
    }
    this.addEventListener(e.type, s, r), o = { type: e.type, name: e.name, value: t, listener: s, options: r }, n ? n.push(o) : this.__on = [o];
  };
}
function uye(e, t, r) {
  var n = sye(e + ""), o, s = n.length, a;
  if (arguments.length < 2) {
    var l = this.node().__on;
    if (l) {
      for (var u = 0, f = l.length, c; u < f; ++u)
        for (o = 0, c = l[u]; o < s; ++o)
          if ((a = n[o]).type === c.type && a.name === c.name)
            return c.value;
    }
    return;
  }
  for (l = t ? lye : aye, o = 0; o < s; ++o)
    this.each(l(n[o], t, r));
  return this;
}
function xq(e, t, r) {
  var n = vq(e), o = n.CustomEvent;
  typeof o == "function" ? o = new o(t, r) : (o = n.document.createEvent("Event"), r ? (o.initEvent(t, r.bubbles, r.cancelable), o.detail = r.detail) : o.initEvent(t, !1, !1)), e.dispatchEvent(o);
}
function fye(e, t) {
  return function() {
    return xq(this, e, t);
  };
}
function cye(e, t) {
  return function() {
    return xq(this, e, t.apply(this, arguments));
  };
}
function dye(e, t) {
  return this.each((typeof t == "function" ? cye : fye)(e, t));
}
function* hye() {
  for (var e = this._groups, t = 0, r = e.length; t < r; ++t)
    for (var n = e[t], o = 0, s = n.length, a; o < s; ++o)
      (a = n[o]) && (yield a);
}
var Rq = [null];
function pn(e, t) {
  this._groups = e, this._parents = t;
}
function Mc() {
  return new pn([[document.documentElement]], Rq);
}
function pye() {
  return this;
}
pn.prototype = Mc.prototype = {
  constructor: pn,
  select: Bge,
  selectAll: Hge,
  selectChild: Kge,
  selectChildren: Qge,
  filter: Zge,
  data: obe,
  enter: ebe,
  exit: abe,
  join: lbe,
  merge: ube,
  selection: pye,
  order: fbe,
  sort: cbe,
  call: hbe,
  nodes: pbe,
  node: gbe,
  size: bbe,
  empty: ybe,
  each: mbe,
  attr: Rbe,
  style: Cbe,
  property: Nbe,
  classed: Dbe,
  text: qbe,
  html: zbe,
  raise: Vbe,
  lower: Ybe,
  append: Xbe,
  insert: Qbe,
  remove: eye,
  clone: nye,
  datum: iye,
  on: uye,
  dispatch: dye,
  [Symbol.iterator]: hye
};
function wn(e) {
  return typeof e == "string" ? new pn([[document.querySelector(e)]], [document.documentElement]) : new pn([[e]], Rq);
}
function gye(e) {
  let t;
  for (; t = e.sourceEvent; )
    e = t;
  return e;
}
function Xi(e, t) {
  if (e = gye(e), t === void 0 && (t = e.currentTarget), t) {
    var r = t.ownerSVGElement || t;
    if (r.createSVGPoint) {
      var n = r.createSVGPoint();
      return n.x = e.clientX, n.y = e.clientY, n = n.matrixTransform(t.getScreenCTM().inverse()), [n.x, n.y];
    }
    if (t.getBoundingClientRect) {
      var o = t.getBoundingClientRect();
      return [e.clientX - o.left - t.clientLeft, e.clientY - o.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
const bye = { passive: !1 }, sc = { capture: !0, passive: !1 };
function T0(e) {
  e.stopImmediatePropagation();
}
function Bl(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function Aq(e) {
  var t = e.document.documentElement, r = wn(e).on("dragstart.drag", Bl, sc);
  "onselectstart" in t ? r.on("selectstart.drag", Bl, sc) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function Tq(e, t) {
  var r = e.document.documentElement, n = wn(e).on("dragstart.drag", null);
  t && (n.on("click.drag", Bl, sc), setTimeout(function() {
    n.on("click.drag", null);
  }, 0)), "onselectstart" in r ? n.on("selectstart.drag", null) : (r.style.MozUserSelect = r.__noselect, delete r.__noselect);
}
const xd = (e) => () => e;
function dE(e, {
  sourceEvent: t,
  subject: r,
  target: n,
  identifier: o,
  active: s,
  x: a,
  y: l,
  dx: u,
  dy: f,
  dispatch: c
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    subject: { value: r, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    identifier: { value: o, enumerable: !0, configurable: !0 },
    active: { value: s, enumerable: !0, configurable: !0 },
    x: { value: a, enumerable: !0, configurable: !0 },
    y: { value: l, enumerable: !0, configurable: !0 },
    dx: { value: u, enumerable: !0, configurable: !0 },
    dy: { value: f, enumerable: !0, configurable: !0 },
    _: { value: c }
  });
}
dE.prototype.on = function() {
  var e = this._.on.apply(this._, arguments);
  return e === this._ ? this : e;
};
function yye(e) {
  return !e.ctrlKey && !e.button;
}
function mye() {
  return this.parentNode;
}
function vye(e, t) {
  return t ?? { x: e.x, y: e.y };
}
function wye() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function _ye() {
  var e = yye, t = mye, r = vye, n = wye, o = {}, s = Ic("start", "drag", "end"), a = 0, l, u, f, c, d = 0;
  function h(C) {
    C.on("mousedown.drag", p).filter(n).on("touchstart.drag", _).on("touchmove.drag", S, bye).on("touchend.drag touchcancel.drag", x).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function p(C, I) {
    if (!(c || !e.call(this, C, I))) {
      var j = E(this, t.call(this, C, I), C, I, "mouse");
      j && (wn(C.view).on("mousemove.drag", m, sc).on("mouseup.drag", y, sc), Aq(C.view), T0(C), f = !1, l = C.clientX, u = C.clientY, j("start", C));
    }
  }
  function m(C) {
    if (Bl(C), !f) {
      var I = C.clientX - l, j = C.clientY - u;
      f = I * I + j * j > d;
    }
    o.mouse("drag", C);
  }
  function y(C) {
    wn(C.view).on("mousemove.drag mouseup.drag", null), Tq(C.view, f), Bl(C), o.mouse("end", C);
  }
  function _(C, I) {
    if (e.call(this, C, I)) {
      var j = C.changedTouches, J = t.call(this, C, I), G = j.length, $, V;
      for ($ = 0; $ < G; ++$)
        (V = E(this, J, C, I, j[$].identifier, j[$])) && (T0(C), V("start", C, j[$]));
    }
  }
  function S(C) {
    var I = C.changedTouches, j = I.length, J, G;
    for (J = 0; J < j; ++J)
      (G = o[I[J].identifier]) && (Bl(C), G("drag", C, I[J]));
  }
  function x(C) {
    var I = C.changedTouches, j = I.length, J, G;
    for (c && clearTimeout(c), c = setTimeout(function() {
      c = null;
    }, 500), J = 0; J < j; ++J)
      (G = o[I[J].identifier]) && (T0(C), G("end", C, I[J]));
  }
  function E(C, I, j, J, G, $) {
    var V = s.copy(), M = Xi($ || j, I), W, k, U;
    if ((U = r.call(C, new dE("beforestart", {
      sourceEvent: j,
      target: h,
      identifier: G,
      active: a,
      x: M[0],
      y: M[1],
      dx: 0,
      dy: 0,
      dispatch: V
    }), J)) != null)
      return W = U.x - M[0] || 0, k = U.y - M[1] || 0, function Z(Y, te, se) {
        var fe = M, he;
        switch (Y) {
          case "start":
            o[G] = Z, he = a++;
            break;
          case "end":
            delete o[G], --a;
          case "drag":
            M = Xi(se || te, I), he = a;
            break;
        }
        V.call(
          Y,
          C,
          new dE(Y, {
            sourceEvent: te,
            subject: U,
            target: h,
            identifier: G,
            active: he,
            x: M[0] + W,
            y: M[1] + k,
            dx: M[0] - fe[0],
            dy: M[1] - fe[1],
            dispatch: V
          }),
          J
        );
      };
  }
  return h.filter = function(C) {
    return arguments.length ? (e = typeof C == "function" ? C : xd(!!C), h) : e;
  }, h.container = function(C) {
    return arguments.length ? (t = typeof C == "function" ? C : xd(C), h) : t;
  }, h.subject = function(C) {
    return arguments.length ? (r = typeof C == "function" ? C : xd(C), h) : r;
  }, h.touchable = function(C) {
    return arguments.length ? (n = typeof C == "function" ? C : xd(!!C), h) : n;
  }, h.on = function() {
    var C = s.on.apply(s, arguments);
    return C === s ? h : C;
  }, h.clickDistance = function(C) {
    return arguments.length ? (d = (C = +C) * C, h) : Math.sqrt(d);
  }, h;
}
function QR(e, t, r) {
  e.prototype = t.prototype = r, r.constructor = e;
}
function $q(e, t) {
  var r = Object.create(e.prototype);
  for (var n in t)
    r[n] = t[n];
  return r;
}
function Nc() {
}
var ac = 0.7, Hh = 1 / ac, ql = "\\s*([+-]?\\d+)\\s*", lc = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", xi = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Sye = /^#([0-9a-f]{3,8})$/, Eye = new RegExp(`^rgb\\(${ql},${ql},${ql}\\)$`), xye = new RegExp(`^rgb\\(${xi},${xi},${xi}\\)$`), Rye = new RegExp(`^rgba\\(${ql},${ql},${ql},${lc}\\)$`), Aye = new RegExp(`^rgba\\(${xi},${xi},${xi},${lc}\\)$`), Tye = new RegExp(`^hsl\\(${lc},${xi},${xi}\\)$`), $ye = new RegExp(`^hsla\\(${lc},${xi},${xi},${lc}\\)$`), O2 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
QR(Nc, uc, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: P2,
  // Deprecated! Use color.formatHex.
  formatHex: P2,
  formatHex8: Cye,
  formatHsl: kye,
  formatRgb: D2,
  toString: D2
});
function P2() {
  return this.rgb().formatHex();
}
function Cye() {
  return this.rgb().formatHex8();
}
function kye() {
  return Cq(this).formatHsl();
}
function D2() {
  return this.rgb().formatRgb();
}
function uc(e) {
  var t, r;
  return e = (e + "").trim().toLowerCase(), (t = Sye.exec(e)) ? (r = t[1].length, t = parseInt(t[1], 16), r === 6 ? F2(t) : r === 3 ? new Zr(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : r === 8 ? Rd(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : r === 4 ? Rd(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = Eye.exec(e)) ? new Zr(t[1], t[2], t[3], 1) : (t = xye.exec(e)) ? new Zr(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = Rye.exec(e)) ? Rd(t[1], t[2], t[3], t[4]) : (t = Aye.exec(e)) ? Rd(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = Tye.exec(e)) ? q2(t[1], t[2] / 100, t[3] / 100, 1) : (t = $ye.exec(e)) ? q2(t[1], t[2] / 100, t[3] / 100, t[4]) : O2.hasOwnProperty(e) ? F2(O2[e]) : e === "transparent" ? new Zr(NaN, NaN, NaN, 0) : null;
}
function F2(e) {
  return new Zr(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function Rd(e, t, r, n) {
  return n <= 0 && (e = t = r = NaN), new Zr(e, t, r, n);
}
function Iye(e) {
  return e instanceof Nc || (e = uc(e)), e ? (e = e.rgb(), new Zr(e.r, e.g, e.b, e.opacity)) : new Zr();
}
function hE(e, t, r, n) {
  return arguments.length === 1 ? Iye(e) : new Zr(e, t, r, n ?? 1);
}
function Zr(e, t, r, n) {
  this.r = +e, this.g = +t, this.b = +r, this.opacity = +n;
}
QR(Zr, hE, $q(Nc, {
  brighter(e) {
    return e = e == null ? Hh : Math.pow(Hh, e), new Zr(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? ac : Math.pow(ac, e), new Zr(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Zr(wa(this.r), wa(this.g), wa(this.b), zh(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: j2,
  // Deprecated! Use color.formatHex.
  formatHex: j2,
  formatHex8: Mye,
  formatRgb: B2,
  toString: B2
}));
function j2() {
  return `#${ta(this.r)}${ta(this.g)}${ta(this.b)}`;
}
function Mye() {
  return `#${ta(this.r)}${ta(this.g)}${ta(this.b)}${ta((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function B2() {
  const e = zh(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${wa(this.r)}, ${wa(this.g)}, ${wa(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function zh(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function wa(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function ta(e) {
  return e = wa(e), (e < 16 ? "0" : "") + e.toString(16);
}
function q2(e, t, r, n) {
  return n <= 0 ? e = t = r = NaN : r <= 0 || r >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Hn(e, t, r, n);
}
function Cq(e) {
  if (e instanceof Hn)
    return new Hn(e.h, e.s, e.l, e.opacity);
  if (e instanceof Nc || (e = uc(e)), !e)
    return new Hn();
  if (e instanceof Hn)
    return e;
  e = e.rgb();
  var t = e.r / 255, r = e.g / 255, n = e.b / 255, o = Math.min(t, r, n), s = Math.max(t, r, n), a = NaN, l = s - o, u = (s + o) / 2;
  return l ? (t === s ? a = (r - n) / l + (r < n) * 6 : r === s ? a = (n - t) / l + 2 : a = (t - r) / l + 4, l /= u < 0.5 ? s + o : 2 - s - o, a *= 60) : l = u > 0 && u < 1 ? 0 : a, new Hn(a, l, u, e.opacity);
}
function Nye(e, t, r, n) {
  return arguments.length === 1 ? Cq(e) : new Hn(e, t, r, n ?? 1);
}
function Hn(e, t, r, n) {
  this.h = +e, this.s = +t, this.l = +r, this.opacity = +n;
}
QR(Hn, Nye, $q(Nc, {
  brighter(e) {
    return e = e == null ? Hh : Math.pow(Hh, e), new Hn(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? ac : Math.pow(ac, e), new Hn(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, r = this.l, n = r + (r < 0.5 ? r : 1 - r) * t, o = 2 * r - n;
    return new Zr(
      $0(e >= 240 ? e - 240 : e + 120, o, n),
      $0(e, o, n),
      $0(e < 120 ? e + 240 : e - 120, o, n),
      this.opacity
    );
  },
  clamp() {
    return new Hn(W2(this.h), Ad(this.s), Ad(this.l), zh(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = zh(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${W2(this.h)}, ${Ad(this.s) * 100}%, ${Ad(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function W2(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function Ad(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function $0(e, t, r) {
  return (e < 60 ? t + (r - t) * e / 60 : e < 180 ? r : e < 240 ? t + (r - t) * (240 - e) / 60 : t) * 255;
}
const kq = (e) => () => e;
function Lye(e, t) {
  return function(r) {
    return e + r * t;
  };
}
function Oye(e, t, r) {
  return e = Math.pow(e, r), t = Math.pow(t, r) - e, r = 1 / r, function(n) {
    return Math.pow(e + n * t, r);
  };
}
function Pye(e) {
  return (e = +e) == 1 ? Iq : function(t, r) {
    return r - t ? Oye(t, r, e) : kq(isNaN(t) ? r : t);
  };
}
function Iq(e, t) {
  var r = t - e;
  return r ? Lye(e, r) : kq(isNaN(e) ? t : e);
}
const U2 = function e(t) {
  var r = Pye(t);
  function n(o, s) {
    var a = r((o = hE(o)).r, (s = hE(s)).r), l = r(o.g, s.g), u = r(o.b, s.b), f = Iq(o.opacity, s.opacity);
    return function(c) {
      return o.r = a(c), o.g = l(c), o.b = u(c), o.opacity = f(c), o + "";
    };
  }
  return n.gamma = e, n;
}(1);
function Uo(e, t) {
  return e = +e, t = +t, function(r) {
    return e * (1 - r) + t * r;
  };
}
var pE = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, C0 = new RegExp(pE.source, "g");
function Dye(e) {
  return function() {
    return e;
  };
}
function Fye(e) {
  return function(t) {
    return e(t) + "";
  };
}
function jye(e, t) {
  var r = pE.lastIndex = C0.lastIndex = 0, n, o, s, a = -1, l = [], u = [];
  for (e = e + "", t = t + ""; (n = pE.exec(e)) && (o = C0.exec(t)); )
    (s = o.index) > r && (s = t.slice(r, s), l[a] ? l[a] += s : l[++a] = s), (n = n[0]) === (o = o[0]) ? l[a] ? l[a] += o : l[++a] = o : (l[++a] = null, u.push({ i: a, x: Uo(n, o) })), r = C0.lastIndex;
  return r < t.length && (s = t.slice(r), l[a] ? l[a] += s : l[++a] = s), l.length < 2 ? u[0] ? Fye(u[0].x) : Dye(t) : (t = u.length, function(f) {
    for (var c = 0, d; c < t; ++c)
      l[(d = u[c]).i] = d.x(f);
    return l.join("");
  });
}
var H2 = 180 / Math.PI, gE = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function Mq(e, t, r, n, o, s) {
  var a, l, u;
  return (a = Math.sqrt(e * e + t * t)) && (e /= a, t /= a), (u = e * r + t * n) && (r -= e * u, n -= t * u), (l = Math.sqrt(r * r + n * n)) && (r /= l, n /= l, u /= l), e * n < t * r && (e = -e, t = -t, u = -u, a = -a), {
    translateX: o,
    translateY: s,
    rotate: Math.atan2(t, e) * H2,
    skewX: Math.atan(u) * H2,
    scaleX: a,
    scaleY: l
  };
}
var Td;
function Bye(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? gE : Mq(t.a, t.b, t.c, t.d, t.e, t.f);
}
function qye(e) {
  return e == null || (Td || (Td = document.createElementNS("http://www.w3.org/2000/svg", "g")), Td.setAttribute("transform", e), !(e = Td.transform.baseVal.consolidate())) ? gE : (e = e.matrix, Mq(e.a, e.b, e.c, e.d, e.e, e.f));
}
function Nq(e, t, r, n) {
  function o(f) {
    return f.length ? f.pop() + " " : "";
  }
  function s(f, c, d, h, p, m) {
    if (f !== d || c !== h) {
      var y = p.push("translate(", null, t, null, r);
      m.push({ i: y - 4, x: Uo(f, d) }, { i: y - 2, x: Uo(c, h) });
    } else
      (d || h) && p.push("translate(" + d + t + h + r);
  }
  function a(f, c, d, h) {
    f !== c ? (f - c > 180 ? c += 360 : c - f > 180 && (f += 360), h.push({ i: d.push(o(d) + "rotate(", null, n) - 2, x: Uo(f, c) })) : c && d.push(o(d) + "rotate(" + c + n);
  }
  function l(f, c, d, h) {
    f !== c ? h.push({ i: d.push(o(d) + "skewX(", null, n) - 2, x: Uo(f, c) }) : c && d.push(o(d) + "skewX(" + c + n);
  }
  function u(f, c, d, h, p, m) {
    if (f !== d || c !== h) {
      var y = p.push(o(p) + "scale(", null, ",", null, ")");
      m.push({ i: y - 4, x: Uo(f, d) }, { i: y - 2, x: Uo(c, h) });
    } else
      (d !== 1 || h !== 1) && p.push(o(p) + "scale(" + d + "," + h + ")");
  }
  return function(f, c) {
    var d = [], h = [];
    return f = e(f), c = e(c), s(f.translateX, f.translateY, c.translateX, c.translateY, d, h), a(f.rotate, c.rotate, d, h), l(f.skewX, c.skewX, d, h), u(f.scaleX, f.scaleY, c.scaleX, c.scaleY, d, h), f = c = null, function(p) {
      for (var m = -1, y = h.length, _; ++m < y; )
        d[(_ = h[m]).i] = _.x(p);
      return d.join("");
    };
  };
}
var Wye = Nq(Bye, "px, ", "px)", "deg)"), Uye = Nq(qye, ", ", ")", ")"), Hye = 1e-12;
function z2(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function zye(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function Gye(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const Vye = function e(t, r, n) {
  function o(s, a) {
    var l = s[0], u = s[1], f = s[2], c = a[0], d = a[1], h = a[2], p = c - l, m = d - u, y = p * p + m * m, _, S;
    if (y < Hye)
      S = Math.log(h / f) / t, _ = function(J) {
        return [
          l + J * p,
          u + J * m,
          f * Math.exp(t * J * S)
        ];
      };
    else {
      var x = Math.sqrt(y), E = (h * h - f * f + n * y) / (2 * f * r * x), C = (h * h - f * f - n * y) / (2 * h * r * x), I = Math.log(Math.sqrt(E * E + 1) - E), j = Math.log(Math.sqrt(C * C + 1) - C);
      S = (j - I) / t, _ = function(J) {
        var G = J * S, $ = z2(I), V = f / (r * x) * ($ * Gye(t * G + I) - zye(I));
        return [
          l + V * p,
          u + V * m,
          f * $ / z2(t * G + I)
        ];
      };
    }
    return _.duration = S * 1e3 * t / Math.SQRT2, _;
  }
  return o.rho = function(s) {
    var a = Math.max(1e-3, +s), l = a * a, u = l * l;
    return e(a, l, u);
  }, o;
}(Math.SQRT2, 2, 4);
var au = 0, of = 0, qu = 0, Lq = 1e3, Gh, sf, Vh = 0, Oa = 0, Hg = 0, fc = typeof performance == "object" && performance.now ? performance : Date, Oq = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function ZR() {
  return Oa || (Oq(Kye), Oa = fc.now() + Hg);
}
function Kye() {
  Oa = 0;
}
function Kh() {
  this._call = this._time = this._next = null;
}
Kh.prototype = eA.prototype = {
  constructor: Kh,
  restart: function(e, t, r) {
    if (typeof e != "function")
      throw new TypeError("callback is not a function");
    r = (r == null ? ZR() : +r) + (t == null ? 0 : +t), !this._next && sf !== this && (sf ? sf._next = this : Gh = this, sf = this), this._call = e, this._time = r, bE();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, bE());
  }
};
function eA(e, t, r) {
  var n = new Kh();
  return n.restart(e, t, r), n;
}
function Yye() {
  ZR(), ++au;
  for (var e = Gh, t; e; )
    (t = Oa - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --au;
}
function G2() {
  Oa = (Vh = fc.now()) + Hg, au = of = 0;
  try {
    Yye();
  } finally {
    au = 0, Jye(), Oa = 0;
  }
}
function Xye() {
  var e = fc.now(), t = e - Vh;
  t > Lq && (Hg -= t, Vh = e);
}
function Jye() {
  for (var e, t = Gh, r, n = 1 / 0; t; )
    t._call ? (n > t._time && (n = t._time), e = t, t = t._next) : (r = t._next, t._next = null, t = e ? e._next = r : Gh = r);
  sf = e, bE(n);
}
function bE(e) {
  if (!au) {
    of && (of = clearTimeout(of));
    var t = e - Oa;
    t > 24 ? (e < 1 / 0 && (of = setTimeout(G2, e - fc.now() - Hg)), qu && (qu = clearInterval(qu))) : (qu || (Vh = fc.now(), qu = setInterval(Xye, Lq)), au = 1, Oq(G2));
  }
}
function V2(e, t, r) {
  var n = new Kh();
  return t = t == null ? 0 : +t, n.restart((o) => {
    n.stop(), e(o + t);
  }, t, r), n;
}
var Qye = Ic("start", "end", "cancel", "interrupt"), Zye = [], Pq = 0, K2 = 1, yE = 2, Qd = 3, Y2 = 4, mE = 5, Zd = 6;
function zg(e, t, r, n, o, s) {
  var a = e.__transition;
  if (!a)
    e.__transition = {};
  else if (r in a)
    return;
  e0e(e, r, {
    name: t,
    index: n,
    // For context during callback.
    group: o,
    // For context during callback.
    on: Qye,
    tween: Zye,
    time: s.time,
    delay: s.delay,
    duration: s.duration,
    ease: s.ease,
    timer: null,
    state: Pq
  });
}
function tA(e, t) {
  var r = ii(e, t);
  if (r.state > Pq)
    throw new Error("too late; already scheduled");
  return r;
}
function qi(e, t) {
  var r = ii(e, t);
  if (r.state > Qd)
    throw new Error("too late; already running");
  return r;
}
function ii(e, t) {
  var r = e.__transition;
  if (!r || !(r = r[t]))
    throw new Error("transition not found");
  return r;
}
function e0e(e, t, r) {
  var n = e.__transition, o;
  n[t] = r, r.timer = eA(s, 0, r.time);
  function s(f) {
    r.state = K2, r.timer.restart(a, r.delay, r.time), r.delay <= f && a(f - r.delay);
  }
  function a(f) {
    var c, d, h, p;
    if (r.state !== K2)
      return u();
    for (c in n)
      if (p = n[c], p.name === r.name) {
        if (p.state === Qd)
          return V2(a);
        p.state === Y2 ? (p.state = Zd, p.timer.stop(), p.on.call("interrupt", e, e.__data__, p.index, p.group), delete n[c]) : +c < t && (p.state = Zd, p.timer.stop(), p.on.call("cancel", e, e.__data__, p.index, p.group), delete n[c]);
      }
    if (V2(function() {
      r.state === Qd && (r.state = Y2, r.timer.restart(l, r.delay, r.time), l(f));
    }), r.state = yE, r.on.call("start", e, e.__data__, r.index, r.group), r.state === yE) {
      for (r.state = Qd, o = new Array(h = r.tween.length), c = 0, d = -1; c < h; ++c)
        (p = r.tween[c].value.call(e, e.__data__, r.index, r.group)) && (o[++d] = p);
      o.length = d + 1;
    }
  }
  function l(f) {
    for (var c = f < r.duration ? r.ease.call(null, f / r.duration) : (r.timer.restart(u), r.state = mE, 1), d = -1, h = o.length; ++d < h; )
      o[d].call(e, c);
    r.state === mE && (r.on.call("end", e, e.__data__, r.index, r.group), u());
  }
  function u() {
    r.state = Zd, r.timer.stop(), delete n[t];
    for (var f in n)
      return;
    delete e.__transition;
  }
}
function eh(e, t) {
  var r = e.__transition, n, o, s = !0, a;
  if (r) {
    t = t == null ? null : t + "";
    for (a in r) {
      if ((n = r[a]).name !== t) {
        s = !1;
        continue;
      }
      o = n.state > yE && n.state < mE, n.state = Zd, n.timer.stop(), n.on.call(o ? "interrupt" : "cancel", e, e.__data__, n.index, n.group), delete r[a];
    }
    s && delete e.__transition;
  }
}
function t0e(e) {
  return this.each(function() {
    eh(this, e);
  });
}
function r0e(e, t) {
  var r, n;
  return function() {
    var o = qi(this, e), s = o.tween;
    if (s !== r) {
      n = r = s;
      for (var a = 0, l = n.length; a < l; ++a)
        if (n[a].name === t) {
          n = n.slice(), n.splice(a, 1);
          break;
        }
    }
    o.tween = n;
  };
}
function n0e(e, t, r) {
  var n, o;
  if (typeof r != "function")
    throw new Error();
  return function() {
    var s = qi(this, e), a = s.tween;
    if (a !== n) {
      o = (n = a).slice();
      for (var l = { name: t, value: r }, u = 0, f = o.length; u < f; ++u)
        if (o[u].name === t) {
          o[u] = l;
          break;
        }
      u === f && o.push(l);
    }
    s.tween = o;
  };
}
function i0e(e, t) {
  var r = this._id;
  if (e += "", arguments.length < 2) {
    for (var n = ii(this.node(), r).tween, o = 0, s = n.length, a; o < s; ++o)
      if ((a = n[o]).name === e)
        return a.value;
    return null;
  }
  return this.each((t == null ? r0e : n0e)(r, e, t));
}
function rA(e, t, r) {
  var n = e._id;
  return e.each(function() {
    var o = qi(this, n);
    (o.value || (o.value = {}))[t] = r.apply(this, arguments);
  }), function(o) {
    return ii(o, n).value[t];
  };
}
function Dq(e, t) {
  var r;
  return (typeof t == "number" ? Uo : t instanceof uc ? U2 : (r = uc(t)) ? (t = r, U2) : jye)(e, t);
}
function o0e(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function s0e(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function a0e(e, t, r) {
  var n, o = r + "", s;
  return function() {
    var a = this.getAttribute(e);
    return a === o ? null : a === n ? s : s = t(n = a, r);
  };
}
function l0e(e, t, r) {
  var n, o = r + "", s;
  return function() {
    var a = this.getAttributeNS(e.space, e.local);
    return a === o ? null : a === n ? s : s = t(n = a, r);
  };
}
function u0e(e, t, r) {
  var n, o, s;
  return function() {
    var a, l = r(this), u;
    return l == null ? void this.removeAttribute(e) : (a = this.getAttribute(e), u = l + "", a === u ? null : a === n && u === o ? s : (o = u, s = t(n = a, l)));
  };
}
function f0e(e, t, r) {
  var n, o, s;
  return function() {
    var a, l = r(this), u;
    return l == null ? void this.removeAttributeNS(e.space, e.local) : (a = this.getAttributeNS(e.space, e.local), u = l + "", a === u ? null : a === n && u === o ? s : (o = u, s = t(n = a, l)));
  };
}
function c0e(e, t) {
  var r = Ug(e), n = r === "transform" ? Uye : Dq;
  return this.attrTween(e, typeof t == "function" ? (r.local ? f0e : u0e)(r, n, rA(this, "attr." + e, t)) : t == null ? (r.local ? s0e : o0e)(r) : (r.local ? l0e : a0e)(r, n, t));
}
function d0e(e, t) {
  return function(r) {
    this.setAttribute(e, t.call(this, r));
  };
}
function h0e(e, t) {
  return function(r) {
    this.setAttributeNS(e.space, e.local, t.call(this, r));
  };
}
function p0e(e, t) {
  var r, n;
  function o() {
    var s = t.apply(this, arguments);
    return s !== n && (r = (n = s) && h0e(e, s)), r;
  }
  return o._value = t, o;
}
function g0e(e, t) {
  var r, n;
  function o() {
    var s = t.apply(this, arguments);
    return s !== n && (r = (n = s) && d0e(e, s)), r;
  }
  return o._value = t, o;
}
function b0e(e, t) {
  var r = "attr." + e;
  if (arguments.length < 2)
    return (r = this.tween(r)) && r._value;
  if (t == null)
    return this.tween(r, null);
  if (typeof t != "function")
    throw new Error();
  var n = Ug(e);
  return this.tween(r, (n.local ? p0e : g0e)(n, t));
}
function y0e(e, t) {
  return function() {
    tA(this, e).delay = +t.apply(this, arguments);
  };
}
function m0e(e, t) {
  return t = +t, function() {
    tA(this, e).delay = t;
  };
}
function v0e(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? y0e : m0e)(t, e)) : ii(this.node(), t).delay;
}
function w0e(e, t) {
  return function() {
    qi(this, e).duration = +t.apply(this, arguments);
  };
}
function _0e(e, t) {
  return t = +t, function() {
    qi(this, e).duration = t;
  };
}
function S0e(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? w0e : _0e)(t, e)) : ii(this.node(), t).duration;
}
function E0e(e, t) {
  if (typeof t != "function")
    throw new Error();
  return function() {
    qi(this, e).ease = t;
  };
}
function x0e(e) {
  var t = this._id;
  return arguments.length ? this.each(E0e(t, e)) : ii(this.node(), t).ease;
}
function R0e(e, t) {
  return function() {
    var r = t.apply(this, arguments);
    if (typeof r != "function")
      throw new Error();
    qi(this, e).ease = r;
  };
}
function A0e(e) {
  if (typeof e != "function")
    throw new Error();
  return this.each(R0e(this._id, e));
}
function T0e(e) {
  typeof e != "function" && (e = bq(e));
  for (var t = this._groups, r = t.length, n = new Array(r), o = 0; o < r; ++o)
    for (var s = t[o], a = s.length, l = n[o] = [], u, f = 0; f < a; ++f)
      (u = s[f]) && e.call(u, u.__data__, f, s) && l.push(u);
  return new wo(n, this._parents, this._name, this._id);
}
function $0e(e) {
  if (e._id !== this._id)
    throw new Error();
  for (var t = this._groups, r = e._groups, n = t.length, o = r.length, s = Math.min(n, o), a = new Array(n), l = 0; l < s; ++l)
    for (var u = t[l], f = r[l], c = u.length, d = a[l] = new Array(c), h, p = 0; p < c; ++p)
      (h = u[p] || f[p]) && (d[p] = h);
  for (; l < n; ++l)
    a[l] = t[l];
  return new wo(a, this._parents, this._name, this._id);
}
function C0e(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var r = t.indexOf(".");
    return r >= 0 && (t = t.slice(0, r)), !t || t === "start";
  });
}
function k0e(e, t, r) {
  var n, o, s = C0e(t) ? tA : qi;
  return function() {
    var a = s(this, e), l = a.on;
    l !== n && (o = (n = l).copy()).on(t, r), a.on = o;
  };
}
function I0e(e, t) {
  var r = this._id;
  return arguments.length < 2 ? ii(this.node(), r).on.on(e) : this.each(k0e(r, e, t));
}
function M0e(e) {
  return function() {
    var t = this.parentNode;
    for (var r in this.__transition)
      if (+r !== e)
        return;
    t && t.removeChild(this);
  };
}
function N0e() {
  return this.on("end.remove", M0e(this._id));
}
function L0e(e) {
  var t = this._name, r = this._id;
  typeof e != "function" && (e = XR(e));
  for (var n = this._groups, o = n.length, s = new Array(o), a = 0; a < o; ++a)
    for (var l = n[a], u = l.length, f = s[a] = new Array(u), c, d, h = 0; h < u; ++h)
      (c = l[h]) && (d = e.call(c, c.__data__, h, l)) && ("__data__" in c && (d.__data__ = c.__data__), f[h] = d, zg(f[h], t, r, h, f, ii(c, r)));
  return new wo(s, this._parents, t, r);
}
function O0e(e) {
  var t = this._name, r = this._id;
  typeof e != "function" && (e = gq(e));
  for (var n = this._groups, o = n.length, s = [], a = [], l = 0; l < o; ++l)
    for (var u = n[l], f = u.length, c, d = 0; d < f; ++d)
      if (c = u[d]) {
        for (var h = e.call(c, c.__data__, d, u), p, m = ii(c, r), y = 0, _ = h.length; y < _; ++y)
          (p = h[y]) && zg(p, t, r, y, h, m);
        s.push(h), a.push(c);
      }
  return new wo(s, a, t, r);
}
var P0e = Mc.prototype.constructor;
function D0e() {
  return new P0e(this._groups, this._parents);
}
function F0e(e, t) {
  var r, n, o;
  return function() {
    var s = su(this, e), a = (this.style.removeProperty(e), su(this, e));
    return s === a ? null : s === r && a === n ? o : o = t(r = s, n = a);
  };
}
function Fq(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function j0e(e, t, r) {
  var n, o = r + "", s;
  return function() {
    var a = su(this, e);
    return a === o ? null : a === n ? s : s = t(n = a, r);
  };
}
function B0e(e, t, r) {
  var n, o, s;
  return function() {
    var a = su(this, e), l = r(this), u = l + "";
    return l == null && (u = l = (this.style.removeProperty(e), su(this, e))), a === u ? null : a === n && u === o ? s : (o = u, s = t(n = a, l));
  };
}
function q0e(e, t) {
  var r, n, o, s = "style." + t, a = "end." + s, l;
  return function() {
    var u = qi(this, e), f = u.on, c = u.value[s] == null ? l || (l = Fq(t)) : void 0;
    (f !== r || o !== c) && (n = (r = f).copy()).on(a, o = c), u.on = n;
  };
}
function W0e(e, t, r) {
  var n = (e += "") == "transform" ? Wye : Dq;
  return t == null ? this.styleTween(e, F0e(e, n)).on("end.style." + e, Fq(e)) : typeof t == "function" ? this.styleTween(e, B0e(e, n, rA(this, "style." + e, t))).each(q0e(this._id, e)) : this.styleTween(e, j0e(e, n, t), r).on("end.style." + e, null);
}
function U0e(e, t, r) {
  return function(n) {
    this.style.setProperty(e, t.call(this, n), r);
  };
}
function H0e(e, t, r) {
  var n, o;
  function s() {
    var a = t.apply(this, arguments);
    return a !== o && (n = (o = a) && U0e(e, a, r)), n;
  }
  return s._value = t, s;
}
function z0e(e, t, r) {
  var n = "style." + (e += "");
  if (arguments.length < 2)
    return (n = this.tween(n)) && n._value;
  if (t == null)
    return this.tween(n, null);
  if (typeof t != "function")
    throw new Error();
  return this.tween(n, H0e(e, t, r ?? ""));
}
function G0e(e) {
  return function() {
    this.textContent = e;
  };
}
function V0e(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function K0e(e) {
  return this.tween("text", typeof e == "function" ? V0e(rA(this, "text", e)) : G0e(e == null ? "" : e + ""));
}
function Y0e(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function X0e(e) {
  var t, r;
  function n() {
    var o = e.apply(this, arguments);
    return o !== r && (t = (r = o) && Y0e(o)), t;
  }
  return n._value = e, n;
}
function J0e(e) {
  var t = "text";
  if (arguments.length < 1)
    return (t = this.tween(t)) && t._value;
  if (e == null)
    return this.tween(t, null);
  if (typeof e != "function")
    throw new Error();
  return this.tween(t, X0e(e));
}
function Q0e() {
  for (var e = this._name, t = this._id, r = jq(), n = this._groups, o = n.length, s = 0; s < o; ++s)
    for (var a = n[s], l = a.length, u, f = 0; f < l; ++f)
      if (u = a[f]) {
        var c = ii(u, t);
        zg(u, e, r, f, a, {
          time: c.time + c.delay + c.duration,
          delay: 0,
          duration: c.duration,
          ease: c.ease
        });
      }
  return new wo(n, this._parents, e, r);
}
function Z0e() {
  var e, t, r = this, n = r._id, o = r.size();
  return new Promise(function(s, a) {
    var l = { value: a }, u = { value: function() {
      --o === 0 && s();
    } };
    r.each(function() {
      var f = qi(this, n), c = f.on;
      c !== e && (t = (e = c).copy(), t._.cancel.push(l), t._.interrupt.push(l), t._.end.push(u)), f.on = t;
    }), o === 0 && s();
  });
}
var eme = 0;
function wo(e, t, r, n) {
  this._groups = e, this._parents = t, this._name = r, this._id = n;
}
function jq() {
  return ++eme;
}
var Gi = Mc.prototype;
wo.prototype = {
  constructor: wo,
  select: L0e,
  selectAll: O0e,
  selectChild: Gi.selectChild,
  selectChildren: Gi.selectChildren,
  filter: T0e,
  merge: $0e,
  selection: D0e,
  transition: Q0e,
  call: Gi.call,
  nodes: Gi.nodes,
  node: Gi.node,
  size: Gi.size,
  empty: Gi.empty,
  each: Gi.each,
  on: I0e,
  attr: c0e,
  attrTween: b0e,
  style: W0e,
  styleTween: z0e,
  text: K0e,
  textTween: J0e,
  remove: N0e,
  tween: i0e,
  delay: v0e,
  duration: S0e,
  ease: x0e,
  easeVarying: A0e,
  end: Z0e,
  [Symbol.iterator]: Gi[Symbol.iterator]
};
function tme(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var rme = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: tme
};
function nme(e, t) {
  for (var r; !(r = e.__transition) || !(r = r[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return r;
}
function ime(e) {
  var t, r;
  e instanceof wo ? (t = e._id, e = e._name) : (t = jq(), (r = rme).time = ZR(), e = e == null ? null : e + "");
  for (var n = this._groups, o = n.length, s = 0; s < o; ++s)
    for (var a = n[s], l = a.length, u, f = 0; f < l; ++f)
      (u = a[f]) && zg(u, e, t, f, a, r || nme(u, t));
  return new wo(n, this._parents, e, t);
}
Mc.prototype.interrupt = t0e;
Mc.prototype.transition = ime;
const vE = Math.PI, wE = 2 * vE, zs = 1e-6, ome = wE - zs;
function Bq(e) {
  this._ += e[0];
  for (let t = 1, r = e.length; t < r; ++t)
    this._ += arguments[t] + e[t];
}
function sme(e) {
  let t = Math.floor(e);
  if (!(t >= 0))
    throw new Error(`invalid digits: ${e}`);
  if (t > 15)
    return Bq;
  const r = 10 ** t;
  return function(n) {
    this._ += n[0];
    for (let o = 1, s = n.length; o < s; ++o)
      this._ += Math.round(arguments[o] * r) / r + n[o];
  };
}
class ame {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? Bq : sme(t);
  }
  moveTo(t, r) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +r}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, r) {
    this._append`L${this._x1 = +t},${this._y1 = +r}`;
  }
  quadraticCurveTo(t, r, n, o) {
    this._append`Q${+t},${+r},${this._x1 = +n},${this._y1 = +o}`;
  }
  bezierCurveTo(t, r, n, o, s, a) {
    this._append`C${+t},${+r},${+n},${+o},${this._x1 = +s},${this._y1 = +a}`;
  }
  arcTo(t, r, n, o, s) {
    if (t = +t, r = +r, n = +n, o = +o, s = +s, s < 0)
      throw new Error(`negative radius: ${s}`);
    let a = this._x1, l = this._y1, u = n - t, f = o - r, c = a - t, d = l - r, h = c * c + d * d;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = r}`;
    else if (h > zs)
      if (!(Math.abs(d * u - f * c) > zs) || !s)
        this._append`L${this._x1 = t},${this._y1 = r}`;
      else {
        let p = n - a, m = o - l, y = u * u + f * f, _ = p * p + m * m, S = Math.sqrt(y), x = Math.sqrt(h), E = s * Math.tan((vE - Math.acos((y + h - _) / (2 * S * x))) / 2), C = E / x, I = E / S;
        Math.abs(C - 1) > zs && this._append`L${t + C * c},${r + C * d}`, this._append`A${s},${s},0,0,${+(d * p > c * m)},${this._x1 = t + I * u},${this._y1 = r + I * f}`;
      }
  }
  arc(t, r, n, o, s, a) {
    if (t = +t, r = +r, n = +n, a = !!a, n < 0)
      throw new Error(`negative radius: ${n}`);
    let l = n * Math.cos(o), u = n * Math.sin(o), f = t + l, c = r + u, d = 1 ^ a, h = a ? o - s : s - o;
    this._x1 === null ? this._append`M${f},${c}` : (Math.abs(this._x1 - f) > zs || Math.abs(this._y1 - c) > zs) && this._append`L${f},${c}`, n && (h < 0 && (h = h % wE + wE), h > ome ? this._append`A${n},${n},0,1,${d},${t - l},${r - u}A${n},${n},0,1,${d},${this._x1 = f},${this._y1 = c}` : h > zs && this._append`A${n},${n},0,${+(h >= vE)},${d},${this._x1 = t + n * Math.cos(s)},${this._y1 = r + n * Math.sin(s)}`);
  }
  rect(t, r, n, o) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +r}h${n = +n}v${+o}h${-n}Z`;
  }
  toString() {
    return this._;
  }
}
function Kn(e) {
  return function() {
    return e;
  };
}
function X2(e) {
  return (e() - 0.5) * 1e-6;
}
function lme(e) {
  return e.index;
}
function J2(e, t) {
  var r = e.get(t);
  if (!r)
    throw new Error("node not found: " + t);
  return r;
}
function ume(e) {
  var t = lme, r = d, n, o = Kn(30), s, a, l, u, f, c = 1;
  e == null && (e = []);
  function d(_) {
    return 1 / Math.min(l[_.source.index], l[_.target.index]);
  }
  function h(_) {
    for (var S = 0, x = e.length; S < c; ++S)
      for (var E = 0, C, I, j, J, G, $, V; E < x; ++E)
        C = e[E], I = C.source, j = C.target, J = j.x + j.vx - I.x - I.vx || X2(f), G = j.y + j.vy - I.y - I.vy || X2(f), $ = Math.sqrt(J * J + G * G), $ = ($ - s[E]) / $ * _ * n[E], J *= $, G *= $, j.vx -= J * (V = u[E]), j.vy -= G * V, I.vx += J * (V = 1 - V), I.vy += G * V;
  }
  function p() {
    if (a) {
      var _, S = a.length, x = e.length, E = new Map(a.map((I, j) => [t(I, j, a), I])), C;
      for (_ = 0, l = new Array(S); _ < x; ++_)
        C = e[_], C.index = _, typeof C.source != "object" && (C.source = J2(E, C.source)), typeof C.target != "object" && (C.target = J2(E, C.target)), l[C.source.index] = (l[C.source.index] || 0) + 1, l[C.target.index] = (l[C.target.index] || 0) + 1;
      for (_ = 0, u = new Array(x); _ < x; ++_)
        C = e[_], u[_] = l[C.source.index] / (l[C.source.index] + l[C.target.index]);
      n = new Array(x), m(), s = new Array(x), y();
    }
  }
  function m() {
    if (a)
      for (var _ = 0, S = e.length; _ < S; ++_)
        n[_] = +r(e[_], _, e);
  }
  function y() {
    if (a)
      for (var _ = 0, S = e.length; _ < S; ++_)
        s[_] = +o(e[_], _, e);
  }
  return h.initialize = function(_, S) {
    a = _, f = S, p();
  }, h.links = function(_) {
    return arguments.length ? (e = _, p(), h) : e;
  }, h.id = function(_) {
    return arguments.length ? (t = _, h) : t;
  }, h.iterations = function(_) {
    return arguments.length ? (c = +_, h) : c;
  }, h.strength = function(_) {
    return arguments.length ? (r = typeof _ == "function" ? _ : Kn(+_), m(), h) : r;
  }, h.distance = function(_) {
    return arguments.length ? (o = typeof _ == "function" ? _ : Kn(+_), y(), h) : o;
  }, h;
}
const fme = 1664525, cme = 1013904223, Q2 = 4294967296;
function dme() {
  let e = 1;
  return () => (e = (fme * e + cme) % Q2) / Q2;
}
var hme = 10, pme = Math.PI * (3 - Math.sqrt(5));
function gme(e) {
  var t, r = 1, n = 1e-3, o = 1 - Math.pow(n, 1 / 300), s = 0, a = 0.6, l = /* @__PURE__ */ new Map(), u = eA(d), f = Ic("tick", "end"), c = dme();
  e == null && (e = []);
  function d() {
    h(), f.call("tick", t), r < n && (u.stop(), f.call("end", t));
  }
  function h(y) {
    var _, S = e.length, x;
    y === void 0 && (y = 1);
    for (var E = 0; E < y; ++E)
      for (r += (s - r) * o, l.forEach(function(C) {
        C(r);
      }), _ = 0; _ < S; ++_)
        x = e[_], x.fx == null ? x.x += x.vx *= a : (x.x = x.fx, x.vx = 0), x.fy == null ? x.y += x.vy *= a : (x.y = x.fy, x.vy = 0);
    return t;
  }
  function p() {
    for (var y = 0, _ = e.length, S; y < _; ++y) {
      if (S = e[y], S.index = y, S.fx != null && (S.x = S.fx), S.fy != null && (S.y = S.fy), isNaN(S.x) || isNaN(S.y)) {
        var x = hme * Math.sqrt(0.5 + y), E = y * pme;
        S.x = x * Math.cos(E), S.y = x * Math.sin(E);
      }
      (isNaN(S.vx) || isNaN(S.vy)) && (S.vx = S.vy = 0);
    }
  }
  function m(y) {
    return y.initialize && y.initialize(e, c), y;
  }
  return p(), t = {
    tick: h,
    restart: function() {
      return u.restart(d), t;
    },
    stop: function() {
      return u.stop(), t;
    },
    nodes: function(y) {
      return arguments.length ? (e = y, p(), l.forEach(m), t) : e;
    },
    alpha: function(y) {
      return arguments.length ? (r = +y, t) : r;
    },
    alphaMin: function(y) {
      return arguments.length ? (n = +y, t) : n;
    },
    alphaDecay: function(y) {
      return arguments.length ? (o = +y, t) : +o;
    },
    alphaTarget: function(y) {
      return arguments.length ? (s = +y, t) : s;
    },
    velocityDecay: function(y) {
      return arguments.length ? (a = 1 - y, t) : 1 - a;
    },
    randomSource: function(y) {
      return arguments.length ? (c = y, l.forEach(m), t) : c;
    },
    force: function(y, _) {
      return arguments.length > 1 ? (_ == null ? l.delete(y) : l.set(y, m(_)), t) : l.get(y);
    },
    find: function(y, _, S) {
      var x = 0, E = e.length, C, I, j, J, G;
      for (S == null ? S = 1 / 0 : S *= S, x = 0; x < E; ++x)
        J = e[x], C = y - J.x, I = _ - J.y, j = C * C + I * I, j < S && (G = J, S = j);
      return G;
    },
    on: function(y, _) {
      return arguments.length > 1 ? (f.on(y, _), t) : f.on(y);
    }
  };
}
function bme(e) {
  var t = Kn(0.1), r, n, o;
  typeof e != "function" && (e = Kn(e == null ? 0 : +e));
  function s(l) {
    for (var u = 0, f = r.length, c; u < f; ++u)
      c = r[u], c.vx += (o[u] - c.x) * n[u] * l;
  }
  function a() {
    if (r) {
      var l, u = r.length;
      for (n = new Array(u), o = new Array(u), l = 0; l < u; ++l)
        n[l] = isNaN(o[l] = +e(r[l], l, r)) ? 0 : +t(r[l], l, r);
    }
  }
  return s.initialize = function(l) {
    r = l, a();
  }, s.strength = function(l) {
    return arguments.length ? (t = typeof l == "function" ? l : Kn(+l), a(), s) : t;
  }, s.x = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : Kn(+l), a(), s) : e;
  }, s;
}
function yme(e) {
  var t = Kn(0.1), r, n, o;
  typeof e != "function" && (e = Kn(e == null ? 0 : +e));
  function s(l) {
    for (var u = 0, f = r.length, c; u < f; ++u)
      c = r[u], c.vy += (o[u] - c.y) * n[u] * l;
  }
  function a() {
    if (r) {
      var l, u = r.length;
      for (n = new Array(u), o = new Array(u), l = 0; l < u; ++l)
        n[l] = isNaN(o[l] = +e(r[l], l, r)) ? 0 : +t(r[l], l, r);
    }
  }
  return s.initialize = function(l) {
    r = l, a();
  }, s.strength = function(l) {
    return arguments.length ? (t = typeof l == "function" ? l : Kn(+l), a(), s) : t;
  }, s.y = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : Kn(+l), a(), s) : e;
  }, s;
}
function Z2(e) {
  return function() {
    return e;
  };
}
function mme(e) {
  let t = 3;
  return e.digits = function(r) {
    if (!arguments.length)
      return t;
    if (r == null)
      t = null;
    else {
      const n = Math.floor(r);
      if (!(n >= 0))
        throw new RangeError(`invalid digits: ${r}`);
      t = n;
    }
    return e;
  }, () => new ame(t);
}
var vme = Array.prototype.slice;
function wme(e) {
  return e[0];
}
function _me(e) {
  return e[1];
}
class Sme {
  constructor(t, r) {
    this._context = t, this._x = r;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(t, r) {
    switch (t = +t, r = +r, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(t, r) : this._context.moveTo(t, r);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, r, t, r) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + r) / 2, t, this._y0, t, r);
        break;
      }
    }
    this._x0 = t, this._y0 = r;
  }
}
function Eme(e) {
  return new Sme(e, !0);
}
function xme(e) {
  return e.source;
}
function Rme(e) {
  return e.target;
}
function Ame(e) {
  let t = xme, r = Rme, n = wme, o = _me, s = null, a = null, l = mme(u);
  function u() {
    let f;
    const c = vme.call(arguments), d = t.apply(this, c), h = r.apply(this, c);
    if (s == null && (a = e(f = l())), a.lineStart(), c[0] = d, a.point(+n.apply(this, c), +o.apply(this, c)), c[0] = h, a.point(+n.apply(this, c), +o.apply(this, c)), a.lineEnd(), f)
      return a = null, f + "" || null;
  }
  return u.source = function(f) {
    return arguments.length ? (t = f, u) : t;
  }, u.target = function(f) {
    return arguments.length ? (r = f, u) : r;
  }, u.x = function(f) {
    return arguments.length ? (n = typeof f == "function" ? f : Z2(+f), u) : n;
  }, u.y = function(f) {
    return arguments.length ? (o = typeof f == "function" ? f : Z2(+f), u) : o;
  }, u.context = function(f) {
    return arguments.length ? (f == null ? s = a = null : a = e(s = f), u) : s;
  }, u;
}
function Tme() {
  return Ame(Eme);
}
const $d = (e) => () => e;
function $me(e, {
  sourceEvent: t,
  target: r,
  transform: n,
  dispatch: o
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: r, enumerable: !0, configurable: !0 },
    transform: { value: n, enumerable: !0, configurable: !0 },
    _: { value: o }
  });
}
function Zi(e, t, r) {
  this.k = e, this.x = t, this.y = r;
}
Zi.prototype = {
  constructor: Zi,
  scale: function(e) {
    return e === 1 ? this : new Zi(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new Zi(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var Gg = new Zi(1, 0, 0);
nA.prototype = Zi.prototype;
function nA(e) {
  for (; !e.__zoom; )
    if (!(e = e.parentNode))
      return Gg;
  return e.__zoom;
}
function k0(e) {
  e.stopImmediatePropagation();
}
function Wu(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function Cme(e) {
  return (!e.ctrlKey || e.type === "wheel") && !e.button;
}
function kme() {
  var e = this;
  return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
}
function eM() {
  return this.__zoom || Gg;
}
function Ime(e) {
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
}
function Mme() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Nme(e, t, r) {
  var n = e.invertX(t[0][0]) - r[0][0], o = e.invertX(t[1][0]) - r[1][0], s = e.invertY(t[0][1]) - r[0][1], a = e.invertY(t[1][1]) - r[1][1];
  return e.translate(
    o > n ? (n + o) / 2 : Math.min(0, n) || Math.max(0, o),
    a > s ? (s + a) / 2 : Math.min(0, s) || Math.max(0, a)
  );
}
function Lme() {
  var e = Cme, t = kme, r = Nme, n = Ime, o = Mme, s = [0, 1 / 0], a = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], l = 250, u = Vye, f = Ic("start", "zoom", "end"), c, d, h, p = 500, m = 150, y = 0, _ = 10;
  function S(U) {
    U.property("__zoom", eM).on("wheel.zoom", G, { passive: !1 }).on("mousedown.zoom", $).on("dblclick.zoom", V).filter(o).on("touchstart.zoom", M).on("touchmove.zoom", W).on("touchend.zoom touchcancel.zoom", k).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  S.transform = function(U, Z, Y, te) {
    var se = U.selection ? U.selection() : U;
    se.property("__zoom", eM), U !== se ? I(U, Z, Y, te) : se.interrupt().each(function() {
      j(this, arguments).event(te).start().zoom(null, typeof Z == "function" ? Z.apply(this, arguments) : Z).end();
    });
  }, S.scaleBy = function(U, Z, Y, te) {
    S.scaleTo(U, function() {
      var se = this.__zoom.k, fe = typeof Z == "function" ? Z.apply(this, arguments) : Z;
      return se * fe;
    }, Y, te);
  }, S.scaleTo = function(U, Z, Y, te) {
    S.transform(U, function() {
      var se = t.apply(this, arguments), fe = this.__zoom, he = Y == null ? C(se) : typeof Y == "function" ? Y.apply(this, arguments) : Y, ae = fe.invert(he), be = typeof Z == "function" ? Z.apply(this, arguments) : Z;
      return r(E(x(fe, be), he, ae), se, a);
    }, Y, te);
  }, S.translateBy = function(U, Z, Y, te) {
    S.transform(U, function() {
      return r(this.__zoom.translate(
        typeof Z == "function" ? Z.apply(this, arguments) : Z,
        typeof Y == "function" ? Y.apply(this, arguments) : Y
      ), t.apply(this, arguments), a);
    }, null, te);
  }, S.translateTo = function(U, Z, Y, te, se) {
    S.transform(U, function() {
      var fe = t.apply(this, arguments), he = this.__zoom, ae = te == null ? C(fe) : typeof te == "function" ? te.apply(this, arguments) : te;
      return r(Gg.translate(ae[0], ae[1]).scale(he.k).translate(
        typeof Z == "function" ? -Z.apply(this, arguments) : -Z,
        typeof Y == "function" ? -Y.apply(this, arguments) : -Y
      ), fe, a);
    }, te, se);
  };
  function x(U, Z) {
    return Z = Math.max(s[0], Math.min(s[1], Z)), Z === U.k ? U : new Zi(Z, U.x, U.y);
  }
  function E(U, Z, Y) {
    var te = Z[0] - Y[0] * U.k, se = Z[1] - Y[1] * U.k;
    return te === U.x && se === U.y ? U : new Zi(U.k, te, se);
  }
  function C(U) {
    return [(+U[0][0] + +U[1][0]) / 2, (+U[0][1] + +U[1][1]) / 2];
  }
  function I(U, Z, Y, te) {
    U.on("start.zoom", function() {
      j(this, arguments).event(te).start();
    }).on("interrupt.zoom end.zoom", function() {
      j(this, arguments).event(te).end();
    }).tween("zoom", function() {
      var se = this, fe = arguments, he = j(se, fe).event(te), ae = t.apply(se, fe), be = Y == null ? C(ae) : typeof Y == "function" ? Y.apply(se, fe) : Y, H = Math.max(ae[1][0] - ae[0][0], ae[1][1] - ae[0][1]), pe = se.__zoom, ke = typeof Z == "function" ? Z.apply(se, fe) : Z, le = u(pe.invert(be).concat(H / pe.k), ke.invert(be).concat(H / ke.k));
      return function(ee) {
        if (ee === 1)
          ee = ke;
        else {
          var ge = le(ee), Ae = H / ge[2];
          ee = new Zi(Ae, be[0] - ge[0] * Ae, be[1] - ge[1] * Ae);
        }
        he.zoom(null, ee);
      };
    });
  }
  function j(U, Z, Y) {
    return !Y && U.__zooming || new J(U, Z);
  }
  function J(U, Z) {
    this.that = U, this.args = Z, this.active = 0, this.sourceEvent = null, this.extent = t.apply(U, Z), this.taps = 0;
  }
  J.prototype = {
    event: function(U) {
      return U && (this.sourceEvent = U), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(U, Z) {
      return this.mouse && U !== "mouse" && (this.mouse[1] = Z.invert(this.mouse[0])), this.touch0 && U !== "touch" && (this.touch0[1] = Z.invert(this.touch0[0])), this.touch1 && U !== "touch" && (this.touch1[1] = Z.invert(this.touch1[0])), this.that.__zoom = Z, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(U) {
      var Z = wn(this.that).datum();
      f.call(
        U,
        this.that,
        new $me(U, {
          sourceEvent: this.sourceEvent,
          target: S,
          type: U,
          transform: this.that.__zoom,
          dispatch: f
        }),
        Z
      );
    }
  };
  function G(U, ...Z) {
    if (!e.apply(this, arguments))
      return;
    var Y = j(this, Z).event(U), te = this.__zoom, se = Math.max(s[0], Math.min(s[1], te.k * Math.pow(2, n.apply(this, arguments)))), fe = Xi(U);
    if (Y.wheel)
      (Y.mouse[0][0] !== fe[0] || Y.mouse[0][1] !== fe[1]) && (Y.mouse[1] = te.invert(Y.mouse[0] = fe)), clearTimeout(Y.wheel);
    else {
      if (te.k === se)
        return;
      Y.mouse = [fe, te.invert(fe)], eh(this), Y.start();
    }
    Wu(U), Y.wheel = setTimeout(he, m), Y.zoom("mouse", r(E(x(te, se), Y.mouse[0], Y.mouse[1]), Y.extent, a));
    function he() {
      Y.wheel = null, Y.end();
    }
  }
  function $(U, ...Z) {
    if (h || !e.apply(this, arguments))
      return;
    var Y = U.currentTarget, te = j(this, Z, !0).event(U), se = wn(U.view).on("mousemove.zoom", be, !0).on("mouseup.zoom", H, !0), fe = Xi(U, Y), he = U.clientX, ae = U.clientY;
    Aq(U.view), k0(U), te.mouse = [fe, this.__zoom.invert(fe)], eh(this), te.start();
    function be(pe) {
      if (Wu(pe), !te.moved) {
        var ke = pe.clientX - he, le = pe.clientY - ae;
        te.moved = ke * ke + le * le > y;
      }
      te.event(pe).zoom("mouse", r(E(te.that.__zoom, te.mouse[0] = Xi(pe, Y), te.mouse[1]), te.extent, a));
    }
    function H(pe) {
      se.on("mousemove.zoom mouseup.zoom", null), Tq(pe.view, te.moved), Wu(pe), te.event(pe).end();
    }
  }
  function V(U, ...Z) {
    if (e.apply(this, arguments)) {
      var Y = this.__zoom, te = Xi(U.changedTouches ? U.changedTouches[0] : U, this), se = Y.invert(te), fe = Y.k * (U.shiftKey ? 0.5 : 2), he = r(E(x(Y, fe), te, se), t.apply(this, Z), a);
      Wu(U), l > 0 ? wn(this).transition().duration(l).call(I, he, te, U) : wn(this).call(S.transform, he, te, U);
    }
  }
  function M(U, ...Z) {
    if (e.apply(this, arguments)) {
      var Y = U.touches, te = Y.length, se = j(this, Z, U.changedTouches.length === te).event(U), fe, he, ae, be;
      for (k0(U), he = 0; he < te; ++he)
        ae = Y[he], be = Xi(ae, this), be = [be, this.__zoom.invert(be), ae.identifier], se.touch0 ? !se.touch1 && se.touch0[2] !== be[2] && (se.touch1 = be, se.taps = 0) : (se.touch0 = be, fe = !0, se.taps = 1 + !!c);
      c && (c = clearTimeout(c)), fe && (se.taps < 2 && (d = be[0], c = setTimeout(function() {
        c = null;
      }, p)), eh(this), se.start());
    }
  }
  function W(U, ...Z) {
    if (this.__zooming) {
      var Y = j(this, Z).event(U), te = U.changedTouches, se = te.length, fe, he, ae, be;
      for (Wu(U), fe = 0; fe < se; ++fe)
        he = te[fe], ae = Xi(he, this), Y.touch0 && Y.touch0[2] === he.identifier ? Y.touch0[0] = ae : Y.touch1 && Y.touch1[2] === he.identifier && (Y.touch1[0] = ae);
      if (he = Y.that.__zoom, Y.touch1) {
        var H = Y.touch0[0], pe = Y.touch0[1], ke = Y.touch1[0], le = Y.touch1[1], ee = (ee = ke[0] - H[0]) * ee + (ee = ke[1] - H[1]) * ee, ge = (ge = le[0] - pe[0]) * ge + (ge = le[1] - pe[1]) * ge;
        he = x(he, Math.sqrt(ee / ge)), ae = [(H[0] + ke[0]) / 2, (H[1] + ke[1]) / 2], be = [(pe[0] + le[0]) / 2, (pe[1] + le[1]) / 2];
      } else if (Y.touch0)
        ae = Y.touch0[0], be = Y.touch0[1];
      else
        return;
      Y.zoom("touch", r(E(he, ae, be), Y.extent, a));
    }
  }
  function k(U, ...Z) {
    if (this.__zooming) {
      var Y = j(this, Z).event(U), te = U.changedTouches, se = te.length, fe, he;
      for (k0(U), h && clearTimeout(h), h = setTimeout(function() {
        h = null;
      }, p), fe = 0; fe < se; ++fe)
        he = te[fe], Y.touch0 && Y.touch0[2] === he.identifier ? delete Y.touch0 : Y.touch1 && Y.touch1[2] === he.identifier && delete Y.touch1;
      if (Y.touch1 && !Y.touch0 && (Y.touch0 = Y.touch1, delete Y.touch1), Y.touch0)
        Y.touch0[1] = this.__zoom.invert(Y.touch0[0]);
      else if (Y.end(), Y.taps === 2 && (he = Xi(he, this), Math.hypot(d[0] - he[0], d[1] - he[1]) < _)) {
        var ae = wn(this).on("dblclick.zoom");
        ae && ae.apply(this, arguments);
      }
    }
  }
  return S.wheelDelta = function(U) {
    return arguments.length ? (n = typeof U == "function" ? U : $d(+U), S) : n;
  }, S.filter = function(U) {
    return arguments.length ? (e = typeof U == "function" ? U : $d(!!U), S) : e;
  }, S.touchable = function(U) {
    return arguments.length ? (o = typeof U == "function" ? U : $d(!!U), S) : o;
  }, S.extent = function(U) {
    return arguments.length ? (t = typeof U == "function" ? U : $d([[+U[0][0], +U[0][1]], [+U[1][0], +U[1][1]]]), S) : t;
  }, S.scaleExtent = function(U) {
    return arguments.length ? (s[0] = +U[0], s[1] = +U[1], S) : [s[0], s[1]];
  }, S.translateExtent = function(U) {
    return arguments.length ? (a[0][0] = +U[0][0], a[1][0] = +U[1][0], a[0][1] = +U[0][1], a[1][1] = +U[1][1], S) : [[a[0][0], a[0][1]], [a[1][0], a[1][1]]];
  }, S.constrain = function(U) {
    return arguments.length ? (r = U, S) : r;
  }, S.duration = function(U) {
    return arguments.length ? (l = +U, S) : l;
  }, S.interpolate = function(U) {
    return arguments.length ? (u = U, S) : u;
  }, S.on = function() {
    var U = f.on.apply(f, arguments);
    return U === f ? S : U;
  }, S.clickDistance = function(U) {
    return arguments.length ? (y = (U = +U) * U, S) : Math.sqrt(y);
  }, S.tapDistance = function(U) {
    return arguments.length ? (_ = +U, S) : _;
  }, S;
}
function iA(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var I0, tM;
function Ome() {
  if (tM)
    return I0;
  tM = 1;
  function e() {
    this.__data__ = [], this.size = 0;
  }
  return I0 = e, I0;
}
var M0, rM;
function Au() {
  if (rM)
    return M0;
  rM = 1;
  function e(t, r) {
    return t === r || t !== t && r !== r;
  }
  return M0 = e, M0;
}
var N0, nM;
function Vg() {
  if (nM)
    return N0;
  nM = 1;
  var e = Au();
  function t(r, n) {
    for (var o = r.length; o--; )
      if (e(r[o][0], n))
        return o;
    return -1;
  }
  return N0 = t, N0;
}
var L0, iM;
function Pme() {
  if (iM)
    return L0;
  iM = 1;
  var e = Vg(), t = Array.prototype, r = t.splice;
  function n(o) {
    var s = this.__data__, a = e(s, o);
    if (a < 0)
      return !1;
    var l = s.length - 1;
    return a == l ? s.pop() : r.call(s, a, 1), --this.size, !0;
  }
  return L0 = n, L0;
}
var O0, oM;
function Dme() {
  if (oM)
    return O0;
  oM = 1;
  var e = Vg();
  function t(r) {
    var n = this.__data__, o = e(n, r);
    return o < 0 ? void 0 : n[o][1];
  }
  return O0 = t, O0;
}
var P0, sM;
function Fme() {
  if (sM)
    return P0;
  sM = 1;
  var e = Vg();
  function t(r) {
    return e(this.__data__, r) > -1;
  }
  return P0 = t, P0;
}
var D0, aM;
function jme() {
  if (aM)
    return D0;
  aM = 1;
  var e = Vg();
  function t(r, n) {
    var o = this.__data__, s = e(o, r);
    return s < 0 ? (++this.size, o.push([r, n])) : o[s][1] = n, this;
  }
  return D0 = t, D0;
}
var F0, lM;
function Kg() {
  if (lM)
    return F0;
  lM = 1;
  var e = Ome(), t = Pme(), r = Dme(), n = Fme(), o = jme();
  function s(a) {
    var l = -1, u = a == null ? 0 : a.length;
    for (this.clear(); ++l < u; ) {
      var f = a[l];
      this.set(f[0], f[1]);
    }
  }
  return s.prototype.clear = e, s.prototype.delete = t, s.prototype.get = r, s.prototype.has = n, s.prototype.set = o, F0 = s, F0;
}
var j0, uM;
function Bme() {
  if (uM)
    return j0;
  uM = 1;
  var e = Kg();
  function t() {
    this.__data__ = new e(), this.size = 0;
  }
  return j0 = t, j0;
}
var B0, fM;
function qme() {
  if (fM)
    return B0;
  fM = 1;
  function e(t) {
    var r = this.__data__, n = r.delete(t);
    return this.size = r.size, n;
  }
  return B0 = e, B0;
}
var q0, cM;
function Wme() {
  if (cM)
    return q0;
  cM = 1;
  function e(t) {
    return this.__data__.get(t);
  }
  return q0 = e, q0;
}
var W0, dM;
function Ume() {
  if (dM)
    return W0;
  dM = 1;
  function e(t) {
    return this.__data__.has(t);
  }
  return W0 = e, W0;
}
var U0, hM;
function Lc() {
  if (hM)
    return U0;
  hM = 1;
  var e = Ka(), t = Mn(), r = "[object AsyncFunction]", n = "[object Function]", o = "[object GeneratorFunction]", s = "[object Proxy]";
  function a(l) {
    if (!t(l))
      return !1;
    var u = e(l);
    return u == n || u == o || u == r || u == s;
  }
  return U0 = a, U0;
}
var H0, pM;
function Hme() {
  if (pM)
    return H0;
  pM = 1;
  var e = Zn(), t = e["__core-js_shared__"];
  return H0 = t, H0;
}
var z0, gM;
function zme() {
  if (gM)
    return z0;
  gM = 1;
  var e = Hme(), t = function() {
    var n = /[^.]+$/.exec(e && e.keys && e.keys.IE_PROTO || "");
    return n ? "Symbol(src)_1." + n : "";
  }();
  function r(n) {
    return !!t && t in n;
  }
  return z0 = r, z0;
}
var G0, bM;
function qq() {
  if (bM)
    return G0;
  bM = 1;
  var e = Function.prototype, t = e.toString;
  function r(n) {
    if (n != null) {
      try {
        return t.call(n);
      } catch {
      }
      try {
        return n + "";
      } catch {
      }
    }
    return "";
  }
  return G0 = r, G0;
}
var V0, yM;
function Gme() {
  if (yM)
    return V0;
  yM = 1;
  var e = Lc(), t = zme(), r = Mn(), n = qq(), o = /[\\^$.*+?()[\]{}|]/g, s = /^\[object .+?Constructor\]$/, a = Function.prototype, l = Object.prototype, u = a.toString, f = l.hasOwnProperty, c = RegExp(
    "^" + u.call(f).replace(o, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function d(h) {
    if (!r(h) || t(h))
      return !1;
    var p = e(h) ? c : s;
    return p.test(n(h));
  }
  return V0 = d, V0;
}
var K0, mM;
function Vme() {
  if (mM)
    return K0;
  mM = 1;
  function e(t, r) {
    return t == null ? void 0 : t[r];
  }
  return K0 = e, K0;
}
var Y0, vM;
function ol() {
  if (vM)
    return Y0;
  vM = 1;
  var e = Gme(), t = Vme();
  function r(n, o) {
    var s = t(n, o);
    return e(s) ? s : void 0;
  }
  return Y0 = r, Y0;
}
var X0, wM;
function oA() {
  if (wM)
    return X0;
  wM = 1;
  var e = ol(), t = Zn(), r = e(t, "Map");
  return X0 = r, X0;
}
var J0, _M;
function Yg() {
  if (_M)
    return J0;
  _M = 1;
  var e = ol(), t = e(Object, "create");
  return J0 = t, J0;
}
var Q0, SM;
function Kme() {
  if (SM)
    return Q0;
  SM = 1;
  var e = Yg();
  function t() {
    this.__data__ = e ? e(null) : {}, this.size = 0;
  }
  return Q0 = t, Q0;
}
var Z0, EM;
function Yme() {
  if (EM)
    return Z0;
  EM = 1;
  function e(t) {
    var r = this.has(t) && delete this.__data__[t];
    return this.size -= r ? 1 : 0, r;
  }
  return Z0 = e, Z0;
}
var em, xM;
function Xme() {
  if (xM)
    return em;
  xM = 1;
  var e = Yg(), t = "__lodash_hash_undefined__", r = Object.prototype, n = r.hasOwnProperty;
  function o(s) {
    var a = this.__data__;
    if (e) {
      var l = a[s];
      return l === t ? void 0 : l;
    }
    return n.call(a, s) ? a[s] : void 0;
  }
  return em = o, em;
}
var tm, RM;
function Jme() {
  if (RM)
    return tm;
  RM = 1;
  var e = Yg(), t = Object.prototype, r = t.hasOwnProperty;
  function n(o) {
    var s = this.__data__;
    return e ? s[o] !== void 0 : r.call(s, o);
  }
  return tm = n, tm;
}
var rm, AM;
function Qme() {
  if (AM)
    return rm;
  AM = 1;
  var e = Yg(), t = "__lodash_hash_undefined__";
  function r(n, o) {
    var s = this.__data__;
    return this.size += this.has(n) ? 0 : 1, s[n] = e && o === void 0 ? t : o, this;
  }
  return rm = r, rm;
}
var nm, TM;
function Zme() {
  if (TM)
    return nm;
  TM = 1;
  var e = Kme(), t = Yme(), r = Xme(), n = Jme(), o = Qme();
  function s(a) {
    var l = -1, u = a == null ? 0 : a.length;
    for (this.clear(); ++l < u; ) {
      var f = a[l];
      this.set(f[0], f[1]);
    }
  }
  return s.prototype.clear = e, s.prototype.delete = t, s.prototype.get = r, s.prototype.has = n, s.prototype.set = o, nm = s, nm;
}
var im, $M;
function eve() {
  if ($M)
    return im;
  $M = 1;
  var e = Zme(), t = Kg(), r = oA();
  function n() {
    this.size = 0, this.__data__ = {
      hash: new e(),
      map: new (r || t)(),
      string: new e()
    };
  }
  return im = n, im;
}
var om, CM;
function tve() {
  if (CM)
    return om;
  CM = 1;
  function e(t) {
    var r = typeof t;
    return r == "string" || r == "number" || r == "symbol" || r == "boolean" ? t !== "__proto__" : t === null;
  }
  return om = e, om;
}
var sm, kM;
function Xg() {
  if (kM)
    return sm;
  kM = 1;
  var e = tve();
  function t(r, n) {
    var o = r.__data__;
    return e(n) ? o[typeof n == "string" ? "string" : "hash"] : o.map;
  }
  return sm = t, sm;
}
var am, IM;
function rve() {
  if (IM)
    return am;
  IM = 1;
  var e = Xg();
  function t(r) {
    var n = e(this, r).delete(r);
    return this.size -= n ? 1 : 0, n;
  }
  return am = t, am;
}
var lm, MM;
function nve() {
  if (MM)
    return lm;
  MM = 1;
  var e = Xg();
  function t(r) {
    return e(this, r).get(r);
  }
  return lm = t, lm;
}
var um, NM;
function ive() {
  if (NM)
    return um;
  NM = 1;
  var e = Xg();
  function t(r) {
    return e(this, r).has(r);
  }
  return um = t, um;
}
var fm, LM;
function ove() {
  if (LM)
    return fm;
  LM = 1;
  var e = Xg();
  function t(r, n) {
    var o = e(this, r), s = o.size;
    return o.set(r, n), this.size += o.size == s ? 0 : 1, this;
  }
  return fm = t, fm;
}
var cm, OM;
function sA() {
  if (OM)
    return cm;
  OM = 1;
  var e = eve(), t = rve(), r = nve(), n = ive(), o = ove();
  function s(a) {
    var l = -1, u = a == null ? 0 : a.length;
    for (this.clear(); ++l < u; ) {
      var f = a[l];
      this.set(f[0], f[1]);
    }
  }
  return s.prototype.clear = e, s.prototype.delete = t, s.prototype.get = r, s.prototype.has = n, s.prototype.set = o, cm = s, cm;
}
var dm, PM;
function sve() {
  if (PM)
    return dm;
  PM = 1;
  var e = Kg(), t = oA(), r = sA(), n = 200;
  function o(s, a) {
    var l = this.__data__;
    if (l instanceof e) {
      var u = l.__data__;
      if (!t || u.length < n - 1)
        return u.push([s, a]), this.size = ++l.size, this;
      l = this.__data__ = new r(u);
    }
    return l.set(s, a), this.size = l.size, this;
  }
  return dm = o, dm;
}
var hm, DM;
function Jg() {
  if (DM)
    return hm;
  DM = 1;
  var e = Kg(), t = Bme(), r = qme(), n = Wme(), o = Ume(), s = sve();
  function a(l) {
    var u = this.__data__ = new e(l);
    this.size = u.size;
  }
  return a.prototype.clear = t, a.prototype.delete = r, a.prototype.get = n, a.prototype.has = o, a.prototype.set = s, hm = a, hm;
}
var pm, FM;
function aA() {
  if (FM)
    return pm;
  FM = 1;
  function e(t, r) {
    for (var n = -1, o = t == null ? 0 : t.length; ++n < o && r(t[n], n, t) !== !1; )
      ;
    return t;
  }
  return pm = e, pm;
}
var gm, jM;
function Wq() {
  if (jM)
    return gm;
  jM = 1;
  var e = ol(), t = function() {
    try {
      var r = e(Object, "defineProperty");
      return r({}, "", {}), r;
    } catch {
    }
  }();
  return gm = t, gm;
}
var bm, BM;
function Qg() {
  if (BM)
    return bm;
  BM = 1;
  var e = Wq();
  function t(r, n, o) {
    n == "__proto__" && e ? e(r, n, {
      configurable: !0,
      enumerable: !0,
      value: o,
      writable: !0
    }) : r[n] = o;
  }
  return bm = t, bm;
}
var ym, qM;
function Zg() {
  if (qM)
    return ym;
  qM = 1;
  var e = Qg(), t = Au(), r = Object.prototype, n = r.hasOwnProperty;
  function o(s, a, l) {
    var u = s[a];
    (!(n.call(s, a) && t(u, l)) || l === void 0 && !(a in s)) && e(s, a, l);
  }
  return ym = o, ym;
}
var mm, WM;
function Oc() {
  if (WM)
    return mm;
  WM = 1;
  var e = Zg(), t = Qg();
  function r(n, o, s, a) {
    var l = !s;
    s || (s = {});
    for (var u = -1, f = o.length; ++u < f; ) {
      var c = o[u], d = a ? a(s[c], n[c], c, s, n) : void 0;
      d === void 0 && (d = n[c]), l ? t(s, c, d) : e(s, c, d);
    }
    return s;
  }
  return mm = r, mm;
}
var vm, UM;
function ave() {
  if (UM)
    return vm;
  UM = 1;
  function e(t, r) {
    for (var n = -1, o = Array(t); ++n < t; )
      o[n] = r(n);
    return o;
  }
  return vm = e, vm;
}
var wm, HM;
function lve() {
  if (HM)
    return wm;
  HM = 1;
  var e = Ka(), t = ji(), r = "[object Arguments]";
  function n(o) {
    return t(o) && e(o) == r;
  }
  return wm = n, wm;
}
var _m, zM;
function Pc() {
  if (zM)
    return _m;
  zM = 1;
  var e = lve(), t = ji(), r = Object.prototype, n = r.hasOwnProperty, o = r.propertyIsEnumerable, s = e(/* @__PURE__ */ function() {
    return arguments;
  }()) ? e : function(a) {
    return t(a) && n.call(a, "callee") && !o.call(a, "callee");
  };
  return _m = s, _m;
}
var Sm, GM;
function Yt() {
  if (GM)
    return Sm;
  GM = 1;
  var e = Array.isArray;
  return Sm = e, Sm;
}
var af = { exports: {} }, Em, VM;
function uve() {
  if (VM)
    return Em;
  VM = 1;
  function e() {
    return !1;
  }
  return Em = e, Em;
}
af.exports;
var KM;
function Tu() {
  return KM || (KM = 1, function(e, t) {
    var r = Zn(), n = uve(), o = t && !t.nodeType && t, s = o && !0 && e && !e.nodeType && e, a = s && s.exports === o, l = a ? r.Buffer : void 0, u = l ? l.isBuffer : void 0, f = u || n;
    e.exports = f;
  }(af, af.exports)), af.exports;
}
var xm, YM;
function eb() {
  if (YM)
    return xm;
  YM = 1;
  var e = 9007199254740991, t = /^(?:0|[1-9]\d*)$/;
  function r(n, o) {
    var s = typeof n;
    return o = o ?? e, !!o && (s == "number" || s != "symbol" && t.test(n)) && n > -1 && n % 1 == 0 && n < o;
  }
  return xm = r, xm;
}
var Rm, XM;
function lA() {
  if (XM)
    return Rm;
  XM = 1;
  var e = 9007199254740991;
  function t(r) {
    return typeof r == "number" && r > -1 && r % 1 == 0 && r <= e;
  }
  return Rm = t, Rm;
}
var Am, JM;
function fve() {
  if (JM)
    return Am;
  JM = 1;
  var e = Ka(), t = lA(), r = ji(), n = "[object Arguments]", o = "[object Array]", s = "[object Boolean]", a = "[object Date]", l = "[object Error]", u = "[object Function]", f = "[object Map]", c = "[object Number]", d = "[object Object]", h = "[object RegExp]", p = "[object Set]", m = "[object String]", y = "[object WeakMap]", _ = "[object ArrayBuffer]", S = "[object DataView]", x = "[object Float32Array]", E = "[object Float64Array]", C = "[object Int8Array]", I = "[object Int16Array]", j = "[object Int32Array]", J = "[object Uint8Array]", G = "[object Uint8ClampedArray]", $ = "[object Uint16Array]", V = "[object Uint32Array]", M = {};
  M[x] = M[E] = M[C] = M[I] = M[j] = M[J] = M[G] = M[$] = M[V] = !0, M[n] = M[o] = M[_] = M[s] = M[S] = M[a] = M[l] = M[u] = M[f] = M[c] = M[d] = M[h] = M[p] = M[m] = M[y] = !1;
  function W(k) {
    return r(k) && t(k.length) && !!M[e(k)];
  }
  return Am = W, Am;
}
var Tm, QM;
function tb() {
  if (QM)
    return Tm;
  QM = 1;
  function e(t) {
    return function(r) {
      return t(r);
    };
  }
  return Tm = e, Tm;
}
var lf = { exports: {} };
lf.exports;
var ZM;
function uA() {
  return ZM || (ZM = 1, function(e, t) {
    var r = A7(), n = t && !t.nodeType && t, o = n && !0 && e && !e.nodeType && e, s = o && o.exports === n, a = s && r.process, l = function() {
      try {
        var u = o && o.require && o.require("util").types;
        return u || a && a.binding && a.binding("util");
      } catch {
      }
    }();
    e.exports = l;
  }(lf, lf.exports)), lf.exports;
}
var $m, eN;
function Dc() {
  if (eN)
    return $m;
  eN = 1;
  var e = fve(), t = tb(), r = uA(), n = r && r.isTypedArray, o = n ? t(n) : e;
  return $m = o, $m;
}
var Cm, tN;
function Uq() {
  if (tN)
    return Cm;
  tN = 1;
  var e = ave(), t = Pc(), r = Yt(), n = Tu(), o = eb(), s = Dc(), a = Object.prototype, l = a.hasOwnProperty;
  function u(f, c) {
    var d = r(f), h = !d && t(f), p = !d && !h && n(f), m = !d && !h && !p && s(f), y = d || h || p || m, _ = y ? e(f.length, String) : [], S = _.length;
    for (var x in f)
      (c || l.call(f, x)) && !(y && // Safari 9 has enumerable `arguments.length` in strict mode.
      (x == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      p && (x == "offset" || x == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      m && (x == "buffer" || x == "byteLength" || x == "byteOffset") || // Skip index properties.
      o(x, S))) && _.push(x);
    return _;
  }
  return Cm = u, Cm;
}
var km, rN;
function rb() {
  if (rN)
    return km;
  rN = 1;
  var e = Object.prototype;
  function t(r) {
    var n = r && r.constructor, o = typeof n == "function" && n.prototype || e;
    return r === o;
  }
  return km = t, km;
}
var Im, nN;
function Hq() {
  if (nN)
    return Im;
  nN = 1;
  function e(t, r) {
    return function(n) {
      return t(r(n));
    };
  }
  return Im = e, Im;
}
var Mm, iN;
function cve() {
  if (iN)
    return Mm;
  iN = 1;
  var e = Hq(), t = e(Object.keys, Object);
  return Mm = t, Mm;
}
var Nm, oN;
function fA() {
  if (oN)
    return Nm;
  oN = 1;
  var e = rb(), t = cve(), r = Object.prototype, n = r.hasOwnProperty;
  function o(s) {
    if (!e(s))
      return t(s);
    var a = [];
    for (var l in Object(s))
      n.call(s, l) && l != "constructor" && a.push(l);
    return a;
  }
  return Nm = o, Nm;
}
var Lm, sN;
function Co() {
  if (sN)
    return Lm;
  sN = 1;
  var e = Lc(), t = lA();
  function r(n) {
    return n != null && t(n.length) && !e(n);
  }
  return Lm = r, Lm;
}
var Om, aN;
function Rs() {
  if (aN)
    return Om;
  aN = 1;
  var e = Uq(), t = fA(), r = Co();
  function n(o) {
    return r(o) ? e(o) : t(o);
  }
  return Om = n, Om;
}
var Pm, lN;
function dve() {
  if (lN)
    return Pm;
  lN = 1;
  var e = Oc(), t = Rs();
  function r(n, o) {
    return n && e(o, t(o), n);
  }
  return Pm = r, Pm;
}
var Dm, uN;
function hve() {
  if (uN)
    return Dm;
  uN = 1;
  function e(t) {
    var r = [];
    if (t != null)
      for (var n in Object(t))
        r.push(n);
    return r;
  }
  return Dm = e, Dm;
}
var Fm, fN;
function pve() {
  if (fN)
    return Fm;
  fN = 1;
  var e = Mn(), t = rb(), r = hve(), n = Object.prototype, o = n.hasOwnProperty;
  function s(a) {
    if (!e(a))
      return r(a);
    var l = t(a), u = [];
    for (var f in a)
      f == "constructor" && (l || !o.call(a, f)) || u.push(f);
    return u;
  }
  return Fm = s, Fm;
}
var jm, cN;
function sl() {
  if (cN)
    return jm;
  cN = 1;
  var e = Uq(), t = pve(), r = Co();
  function n(o) {
    return r(o) ? e(o, !0) : t(o);
  }
  return jm = n, jm;
}
var Bm, dN;
function gve() {
  if (dN)
    return Bm;
  dN = 1;
  var e = Oc(), t = sl();
  function r(n, o) {
    return n && e(o, t(o), n);
  }
  return Bm = r, Bm;
}
var uf = { exports: {} };
uf.exports;
var hN;
function zq() {
  return hN || (hN = 1, function(e, t) {
    var r = Zn(), n = t && !t.nodeType && t, o = n && !0 && e && !e.nodeType && e, s = o && o.exports === n, a = s ? r.Buffer : void 0, l = a ? a.allocUnsafe : void 0;
    function u(f, c) {
      if (c)
        return f.slice();
      var d = f.length, h = l ? l(d) : new f.constructor(d);
      return f.copy(h), h;
    }
    e.exports = u;
  }(uf, uf.exports)), uf.exports;
}
var qm, pN;
function Gq() {
  if (pN)
    return qm;
  pN = 1;
  function e(t, r) {
    var n = -1, o = t.length;
    for (r || (r = Array(o)); ++n < o; )
      r[n] = t[n];
    return r;
  }
  return qm = e, qm;
}
var Wm, gN;
function Vq() {
  if (gN)
    return Wm;
  gN = 1;
  function e(t, r) {
    for (var n = -1, o = t == null ? 0 : t.length, s = 0, a = []; ++n < o; ) {
      var l = t[n];
      r(l, n, t) && (a[s++] = l);
    }
    return a;
  }
  return Wm = e, Wm;
}
var Um, bN;
function Kq() {
  if (bN)
    return Um;
  bN = 1;
  function e() {
    return [];
  }
  return Um = e, Um;
}
var Hm, yN;
function cA() {
  if (yN)
    return Hm;
  yN = 1;
  var e = Vq(), t = Kq(), r = Object.prototype, n = r.propertyIsEnumerable, o = Object.getOwnPropertySymbols, s = o ? function(a) {
    return a == null ? [] : (a = Object(a), e(o(a), function(l) {
      return n.call(a, l);
    }));
  } : t;
  return Hm = s, Hm;
}
var zm, mN;
function bve() {
  if (mN)
    return zm;
  mN = 1;
  var e = Oc(), t = cA();
  function r(n, o) {
    return e(n, t(n), o);
  }
  return zm = r, zm;
}
var Gm, vN;
function dA() {
  if (vN)
    return Gm;
  vN = 1;
  function e(t, r) {
    for (var n = -1, o = r.length, s = t.length; ++n < o; )
      t[s + n] = r[n];
    return t;
  }
  return Gm = e, Gm;
}
var Vm, wN;
function nb() {
  if (wN)
    return Vm;
  wN = 1;
  var e = Hq(), t = e(Object.getPrototypeOf, Object);
  return Vm = t, Vm;
}
var Km, _N;
function Yq() {
  if (_N)
    return Km;
  _N = 1;
  var e = dA(), t = nb(), r = cA(), n = Kq(), o = Object.getOwnPropertySymbols, s = o ? function(a) {
    for (var l = []; a; )
      e(l, r(a)), a = t(a);
    return l;
  } : n;
  return Km = s, Km;
}
var Ym, SN;
function yve() {
  if (SN)
    return Ym;
  SN = 1;
  var e = Oc(), t = Yq();
  function r(n, o) {
    return e(n, t(n), o);
  }
  return Ym = r, Ym;
}
var Xm, EN;
function Xq() {
  if (EN)
    return Xm;
  EN = 1;
  var e = dA(), t = Yt();
  function r(n, o, s) {
    var a = o(n);
    return t(n) ? a : e(a, s(n));
  }
  return Xm = r, Xm;
}
var Jm, xN;
function Jq() {
  if (xN)
    return Jm;
  xN = 1;
  var e = Xq(), t = cA(), r = Rs();
  function n(o) {
    return e(o, r, t);
  }
  return Jm = n, Jm;
}
var Qm, RN;
function mve() {
  if (RN)
    return Qm;
  RN = 1;
  var e = Xq(), t = Yq(), r = sl();
  function n(o) {
    return e(o, r, t);
  }
  return Qm = n, Qm;
}
var Zm, AN;
function vve() {
  if (AN)
    return Zm;
  AN = 1;
  var e = ol(), t = Zn(), r = e(t, "DataView");
  return Zm = r, Zm;
}
var ev, TN;
function wve() {
  if (TN)
    return ev;
  TN = 1;
  var e = ol(), t = Zn(), r = e(t, "Promise");
  return ev = r, ev;
}
var tv, $N;
function Qq() {
  if ($N)
    return tv;
  $N = 1;
  var e = ol(), t = Zn(), r = e(t, "Set");
  return tv = r, tv;
}
var rv, CN;
function _ve() {
  if (CN)
    return rv;
  CN = 1;
  var e = ol(), t = Zn(), r = e(t, "WeakMap");
  return rv = r, rv;
}
var nv, kN;
function $u() {
  if (kN)
    return nv;
  kN = 1;
  var e = vve(), t = oA(), r = wve(), n = Qq(), o = _ve(), s = Ka(), a = qq(), l = "[object Map]", u = "[object Object]", f = "[object Promise]", c = "[object Set]", d = "[object WeakMap]", h = "[object DataView]", p = a(e), m = a(t), y = a(r), _ = a(n), S = a(o), x = s;
  return (e && x(new e(new ArrayBuffer(1))) != h || t && x(new t()) != l || r && x(r.resolve()) != f || n && x(new n()) != c || o && x(new o()) != d) && (x = function(E) {
    var C = s(E), I = C == u ? E.constructor : void 0, j = I ? a(I) : "";
    if (j)
      switch (j) {
        case p:
          return h;
        case m:
          return l;
        case y:
          return f;
        case _:
          return c;
        case S:
          return d;
      }
    return C;
  }), nv = x, nv;
}
var iv, IN;
function Sve() {
  if (IN)
    return iv;
  IN = 1;
  var e = Object.prototype, t = e.hasOwnProperty;
  function r(n) {
    var o = n.length, s = new n.constructor(o);
    return o && typeof n[0] == "string" && t.call(n, "index") && (s.index = n.index, s.input = n.input), s;
  }
  return iv = r, iv;
}
var ov, MN;
function Zq() {
  if (MN)
    return ov;
  MN = 1;
  var e = Zn(), t = e.Uint8Array;
  return ov = t, ov;
}
var sv, NN;
function hA() {
  if (NN)
    return sv;
  NN = 1;
  var e = Zq();
  function t(r) {
    var n = new r.constructor(r.byteLength);
    return new e(n).set(new e(r)), n;
  }
  return sv = t, sv;
}
var av, LN;
function Eve() {
  if (LN)
    return av;
  LN = 1;
  var e = hA();
  function t(r, n) {
    var o = n ? e(r.buffer) : r.buffer;
    return new r.constructor(o, r.byteOffset, r.byteLength);
  }
  return av = t, av;
}
var lv, ON;
function xve() {
  if (ON)
    return lv;
  ON = 1;
  var e = /\w*$/;
  function t(r) {
    var n = new r.constructor(r.source, e.exec(r));
    return n.lastIndex = r.lastIndex, n;
  }
  return lv = t, lv;
}
var uv, PN;
function Rve() {
  if (PN)
    return uv;
  PN = 1;
  var e = gu(), t = e ? e.prototype : void 0, r = t ? t.valueOf : void 0;
  function n(o) {
    return r ? Object(r.call(o)) : {};
  }
  return uv = n, uv;
}
var fv, DN;
function e6() {
  if (DN)
    return fv;
  DN = 1;
  var e = hA();
  function t(r, n) {
    var o = n ? e(r.buffer) : r.buffer;
    return new r.constructor(o, r.byteOffset, r.length);
  }
  return fv = t, fv;
}
var cv, FN;
function Ave() {
  if (FN)
    return cv;
  FN = 1;
  var e = hA(), t = Eve(), r = xve(), n = Rve(), o = e6(), s = "[object Boolean]", a = "[object Date]", l = "[object Map]", u = "[object Number]", f = "[object RegExp]", c = "[object Set]", d = "[object String]", h = "[object Symbol]", p = "[object ArrayBuffer]", m = "[object DataView]", y = "[object Float32Array]", _ = "[object Float64Array]", S = "[object Int8Array]", x = "[object Int16Array]", E = "[object Int32Array]", C = "[object Uint8Array]", I = "[object Uint8ClampedArray]", j = "[object Uint16Array]", J = "[object Uint32Array]";
  function G($, V, M) {
    var W = $.constructor;
    switch (V) {
      case p:
        return e($);
      case s:
      case a:
        return new W(+$);
      case m:
        return t($, M);
      case y:
      case _:
      case S:
      case x:
      case E:
      case C:
      case I:
      case j:
      case J:
        return o($, M);
      case l:
        return new W();
      case u:
      case d:
        return new W($);
      case f:
        return r($);
      case c:
        return new W();
      case h:
        return n($);
    }
  }
  return cv = G, cv;
}
var dv, jN;
function t6() {
  if (jN)
    return dv;
  jN = 1;
  var e = Mn(), t = Object.create, r = /* @__PURE__ */ function() {
    function n() {
    }
    return function(o) {
      if (!e(o))
        return {};
      if (t)
        return t(o);
      n.prototype = o;
      var s = new n();
      return n.prototype = void 0, s;
    };
  }();
  return dv = r, dv;
}
var hv, BN;
function r6() {
  if (BN)
    return hv;
  BN = 1;
  var e = t6(), t = nb(), r = rb();
  function n(o) {
    return typeof o.constructor == "function" && !r(o) ? e(t(o)) : {};
  }
  return hv = n, hv;
}
var pv, qN;
function Tve() {
  if (qN)
    return pv;
  qN = 1;
  var e = $u(), t = ji(), r = "[object Map]";
  function n(o) {
    return t(o) && e(o) == r;
  }
  return pv = n, pv;
}
var gv, WN;
function $ve() {
  if (WN)
    return gv;
  WN = 1;
  var e = Tve(), t = tb(), r = uA(), n = r && r.isMap, o = n ? t(n) : e;
  return gv = o, gv;
}
var bv, UN;
function Cve() {
  if (UN)
    return bv;
  UN = 1;
  var e = $u(), t = ji(), r = "[object Set]";
  function n(o) {
    return t(o) && e(o) == r;
  }
  return bv = n, bv;
}
var yv, HN;
function kve() {
  if (HN)
    return yv;
  HN = 1;
  var e = Cve(), t = tb(), r = uA(), n = r && r.isSet, o = n ? t(n) : e;
  return yv = o, yv;
}
var mv, zN;
function n6() {
  if (zN)
    return mv;
  zN = 1;
  var e = Jg(), t = aA(), r = Zg(), n = dve(), o = gve(), s = zq(), a = Gq(), l = bve(), u = yve(), f = Jq(), c = mve(), d = $u(), h = Sve(), p = Ave(), m = r6(), y = Yt(), _ = Tu(), S = $ve(), x = Mn(), E = kve(), C = Rs(), I = sl(), j = 1, J = 2, G = 4, $ = "[object Arguments]", V = "[object Array]", M = "[object Boolean]", W = "[object Date]", k = "[object Error]", U = "[object Function]", Z = "[object GeneratorFunction]", Y = "[object Map]", te = "[object Number]", se = "[object Object]", fe = "[object RegExp]", he = "[object Set]", ae = "[object String]", be = "[object Symbol]", H = "[object WeakMap]", pe = "[object ArrayBuffer]", ke = "[object DataView]", le = "[object Float32Array]", ee = "[object Float64Array]", ge = "[object Int8Array]", Ae = "[object Int16Array]", Oe = "[object Int32Array]", K = "[object Uint8Array]", z = "[object Uint8ClampedArray]", b = "[object Uint16Array]", w = "[object Uint32Array]", T = {};
  T[$] = T[V] = T[pe] = T[ke] = T[M] = T[W] = T[le] = T[ee] = T[ge] = T[Ae] = T[Oe] = T[Y] = T[te] = T[se] = T[fe] = T[he] = T[ae] = T[be] = T[K] = T[z] = T[b] = T[w] = !0, T[k] = T[U] = T[H] = !1;
  function O(L, ne, ue, oe, ye, B) {
    var me, Ce = ne & j, Ie = ne & J, Me = ne & G;
    if (ue && (me = ye ? ue(L, oe, ye, B) : ue(L)), me !== void 0)
      return me;
    if (!x(L))
      return L;
    var N = y(L);
    if (N) {
      if (me = h(L), !Ce)
        return a(L, me);
    } else {
      var R = d(L), A = R == U || R == Z;
      if (_(L))
        return s(L, Ce);
      if (R == se || R == $ || A && !ye) {
        if (me = Ie || A ? {} : m(L), !Ce)
          return Ie ? u(L, o(me, L)) : l(L, n(me, L));
      } else {
        if (!T[R])
          return ye ? L : {};
        me = p(L, R, Ce);
      }
    }
    B || (B = new e());
    var q = B.get(L);
    if (q)
      return q;
    B.set(L, me), E(L) ? L.forEach(function(de) {
      me.add(O(de, ne, ue, de, L, B));
    }) : S(L) && L.forEach(function(de, De) {
      me.set(De, O(de, ne, ue, De, L, B));
    });
    var re = Me ? Ie ? c : f : Ie ? I : C, ce = N ? void 0 : re(L);
    return t(ce || L, function(de, De) {
      ce && (De = de, de = L[De]), r(me, De, O(de, ne, ue, De, L, B));
    }), me;
  }
  return mv = O, mv;
}
var vv, GN;
function Ive() {
  if (GN)
    return vv;
  GN = 1;
  var e = n6(), t = 4;
  function r(n) {
    return e(n, t);
  }
  return vv = r, vv;
}
var wv, VN;
function pA() {
  if (VN)
    return wv;
  VN = 1;
  function e(t) {
    return function() {
      return t;
    };
  }
  return wv = e, wv;
}
var _v, KN;
function Mve() {
  if (KN)
    return _v;
  KN = 1;
  function e(t) {
    return function(r, n, o) {
      for (var s = -1, a = Object(r), l = o(r), u = l.length; u--; ) {
        var f = l[t ? u : ++s];
        if (n(a[f], f, a) === !1)
          break;
      }
      return r;
    };
  }
  return _v = e, _v;
}
var Sv, YN;
function gA() {
  if (YN)
    return Sv;
  YN = 1;
  var e = Mve(), t = e();
  return Sv = t, Sv;
}
var Ev, XN;
function bA() {
  if (XN)
    return Ev;
  XN = 1;
  var e = gA(), t = Rs();
  function r(n, o) {
    return n && e(n, o, t);
  }
  return Ev = r, Ev;
}
var xv, JN;
function Nve() {
  if (JN)
    return xv;
  JN = 1;
  var e = Co();
  function t(r, n) {
    return function(o, s) {
      if (o == null)
        return o;
      if (!e(o))
        return r(o, s);
      for (var a = o.length, l = n ? a : -1, u = Object(o); (n ? l-- : ++l < a) && s(u[l], l, u) !== !1; )
        ;
      return o;
    };
  }
  return xv = t, xv;
}
var Rv, QN;
function ib() {
  if (QN)
    return Rv;
  QN = 1;
  var e = bA(), t = Nve(), r = t(e);
  return Rv = r, Rv;
}
var Av, ZN;
function al() {
  if (ZN)
    return Av;
  ZN = 1;
  function e(t) {
    return t;
  }
  return Av = e, Av;
}
var Tv, eL;
function i6() {
  if (eL)
    return Tv;
  eL = 1;
  var e = al();
  function t(r) {
    return typeof r == "function" ? r : e;
  }
  return Tv = t, Tv;
}
var $v, tL;
function o6() {
  if (tL)
    return $v;
  tL = 1;
  var e = aA(), t = ib(), r = i6(), n = Yt();
  function o(s, a) {
    var l = n(s) ? e : t;
    return l(s, r(a));
  }
  return $v = o, $v;
}
var Cv, rL;
function s6() {
  return rL || (rL = 1, Cv = o6()), Cv;
}
var kv, nL;
function Lve() {
  if (nL)
    return kv;
  nL = 1;
  var e = ib();
  function t(r, n) {
    var o = [];
    return e(r, function(s, a, l) {
      n(s, a, l) && o.push(s);
    }), o;
  }
  return kv = t, kv;
}
var Iv, iL;
function Ove() {
  if (iL)
    return Iv;
  iL = 1;
  var e = "__lodash_hash_undefined__";
  function t(r) {
    return this.__data__.set(r, e), this;
  }
  return Iv = t, Iv;
}
var Mv, oL;
function Pve() {
  if (oL)
    return Mv;
  oL = 1;
  function e(t) {
    return this.__data__.has(t);
  }
  return Mv = e, Mv;
}
var Nv, sL;
function a6() {
  if (sL)
    return Nv;
  sL = 1;
  var e = sA(), t = Ove(), r = Pve();
  function n(o) {
    var s = -1, a = o == null ? 0 : o.length;
    for (this.__data__ = new e(); ++s < a; )
      this.add(o[s]);
  }
  return n.prototype.add = n.prototype.push = t, n.prototype.has = r, Nv = n, Nv;
}
var Lv, aL;
function Dve() {
  if (aL)
    return Lv;
  aL = 1;
  function e(t, r) {
    for (var n = -1, o = t == null ? 0 : t.length; ++n < o; )
      if (r(t[n], n, t))
        return !0;
    return !1;
  }
  return Lv = e, Lv;
}
var Ov, lL;
function l6() {
  if (lL)
    return Ov;
  lL = 1;
  function e(t, r) {
    return t.has(r);
  }
  return Ov = e, Ov;
}
var Pv, uL;
function u6() {
  if (uL)
    return Pv;
  uL = 1;
  var e = a6(), t = Dve(), r = l6(), n = 1, o = 2;
  function s(a, l, u, f, c, d) {
    var h = u & n, p = a.length, m = l.length;
    if (p != m && !(h && m > p))
      return !1;
    var y = d.get(a), _ = d.get(l);
    if (y && _)
      return y == l && _ == a;
    var S = -1, x = !0, E = u & o ? new e() : void 0;
    for (d.set(a, l), d.set(l, a); ++S < p; ) {
      var C = a[S], I = l[S];
      if (f)
        var j = h ? f(I, C, S, l, a, d) : f(C, I, S, a, l, d);
      if (j !== void 0) {
        if (j)
          continue;
        x = !1;
        break;
      }
      if (E) {
        if (!t(l, function(J, G) {
          if (!r(E, G) && (C === J || c(C, J, u, f, d)))
            return E.push(G);
        })) {
          x = !1;
          break;
        }
      } else if (!(C === I || c(C, I, u, f, d))) {
        x = !1;
        break;
      }
    }
    return d.delete(a), d.delete(l), x;
  }
  return Pv = s, Pv;
}
var Dv, fL;
function Fve() {
  if (fL)
    return Dv;
  fL = 1;
  function e(t) {
    var r = -1, n = Array(t.size);
    return t.forEach(function(o, s) {
      n[++r] = [s, o];
    }), n;
  }
  return Dv = e, Dv;
}
var Fv, cL;
function yA() {
  if (cL)
    return Fv;
  cL = 1;
  function e(t) {
    var r = -1, n = Array(t.size);
    return t.forEach(function(o) {
      n[++r] = o;
    }), n;
  }
  return Fv = e, Fv;
}
var jv, dL;
function jve() {
  if (dL)
    return jv;
  dL = 1;
  var e = gu(), t = Zq(), r = Au(), n = u6(), o = Fve(), s = yA(), a = 1, l = 2, u = "[object Boolean]", f = "[object Date]", c = "[object Error]", d = "[object Map]", h = "[object Number]", p = "[object RegExp]", m = "[object Set]", y = "[object String]", _ = "[object Symbol]", S = "[object ArrayBuffer]", x = "[object DataView]", E = e ? e.prototype : void 0, C = E ? E.valueOf : void 0;
  function I(j, J, G, $, V, M, W) {
    switch (G) {
      case x:
        if (j.byteLength != J.byteLength || j.byteOffset != J.byteOffset)
          return !1;
        j = j.buffer, J = J.buffer;
      case S:
        return !(j.byteLength != J.byteLength || !M(new t(j), new t(J)));
      case u:
      case f:
      case h:
        return r(+j, +J);
      case c:
        return j.name == J.name && j.message == J.message;
      case p:
      case y:
        return j == J + "";
      case d:
        var k = o;
      case m:
        var U = $ & a;
        if (k || (k = s), j.size != J.size && !U)
          return !1;
        var Z = W.get(j);
        if (Z)
          return Z == J;
        $ |= l, W.set(j, J);
        var Y = n(k(j), k(J), $, V, M, W);
        return W.delete(j), Y;
      case _:
        if (C)
          return C.call(j) == C.call(J);
    }
    return !1;
  }
  return jv = I, jv;
}
var Bv, hL;
function Bve() {
  if (hL)
    return Bv;
  hL = 1;
  var e = Jq(), t = 1, r = Object.prototype, n = r.hasOwnProperty;
  function o(s, a, l, u, f, c) {
    var d = l & t, h = e(s), p = h.length, m = e(a), y = m.length;
    if (p != y && !d)
      return !1;
    for (var _ = p; _--; ) {
      var S = h[_];
      if (!(d ? S in a : n.call(a, S)))
        return !1;
    }
    var x = c.get(s), E = c.get(a);
    if (x && E)
      return x == a && E == s;
    var C = !0;
    c.set(s, a), c.set(a, s);
    for (var I = d; ++_ < p; ) {
      S = h[_];
      var j = s[S], J = a[S];
      if (u)
        var G = d ? u(J, j, S, a, s, c) : u(j, J, S, s, a, c);
      if (!(G === void 0 ? j === J || f(j, J, l, u, c) : G)) {
        C = !1;
        break;
      }
      I || (I = S == "constructor");
    }
    if (C && !I) {
      var $ = s.constructor, V = a.constructor;
      $ != V && "constructor" in s && "constructor" in a && !(typeof $ == "function" && $ instanceof $ && typeof V == "function" && V instanceof V) && (C = !1);
    }
    return c.delete(s), c.delete(a), C;
  }
  return Bv = o, Bv;
}
var qv, pL;
function qve() {
  if (pL)
    return qv;
  pL = 1;
  var e = Jg(), t = u6(), r = jve(), n = Bve(), o = $u(), s = Yt(), a = Tu(), l = Dc(), u = 1, f = "[object Arguments]", c = "[object Array]", d = "[object Object]", h = Object.prototype, p = h.hasOwnProperty;
  function m(y, _, S, x, E, C) {
    var I = s(y), j = s(_), J = I ? c : o(y), G = j ? c : o(_);
    J = J == f ? d : J, G = G == f ? d : G;
    var $ = J == d, V = G == d, M = J == G;
    if (M && a(y)) {
      if (!a(_))
        return !1;
      I = !0, $ = !1;
    }
    if (M && !$)
      return C || (C = new e()), I || l(y) ? t(y, _, S, x, E, C) : r(y, _, J, S, x, E, C);
    if (!(S & u)) {
      var W = $ && p.call(y, "__wrapped__"), k = V && p.call(_, "__wrapped__");
      if (W || k) {
        var U = W ? y.value() : y, Z = k ? _.value() : _;
        return C || (C = new e()), E(U, Z, S, x, C);
      }
    }
    return M ? (C || (C = new e()), n(y, _, S, x, E, C)) : !1;
  }
  return qv = m, qv;
}
var Wv, gL;
function f6() {
  if (gL)
    return Wv;
  gL = 1;
  var e = qve(), t = ji();
  function r(n, o, s, a, l) {
    return n === o ? !0 : n == null || o == null || !t(n) && !t(o) ? n !== n && o !== o : e(n, o, s, a, r, l);
  }
  return Wv = r, Wv;
}
var Uv, bL;
function Wve() {
  if (bL)
    return Uv;
  bL = 1;
  var e = Jg(), t = f6(), r = 1, n = 2;
  function o(s, a, l, u) {
    var f = l.length, c = f, d = !u;
    if (s == null)
      return !c;
    for (s = Object(s); f--; ) {
      var h = l[f];
      if (d && h[2] ? h[1] !== s[h[0]] : !(h[0] in s))
        return !1;
    }
    for (; ++f < c; ) {
      h = l[f];
      var p = h[0], m = s[p], y = h[1];
      if (d && h[2]) {
        if (m === void 0 && !(p in s))
          return !1;
      } else {
        var _ = new e();
        if (u)
          var S = u(m, y, p, s, a, _);
        if (!(S === void 0 ? t(y, m, r | n, u, _) : S))
          return !1;
      }
    }
    return !0;
  }
  return Uv = o, Uv;
}
var Hv, yL;
function c6() {
  if (yL)
    return Hv;
  yL = 1;
  var e = Mn();
  function t(r) {
    return r === r && !e(r);
  }
  return Hv = t, Hv;
}
var zv, mL;
function Uve() {
  if (mL)
    return zv;
  mL = 1;
  var e = c6(), t = Rs();
  function r(n) {
    for (var o = t(n), s = o.length; s--; ) {
      var a = o[s], l = n[a];
      o[s] = [a, l, e(l)];
    }
    return o;
  }
  return zv = r, zv;
}
var Gv, vL;
function d6() {
  if (vL)
    return Gv;
  vL = 1;
  function e(t, r) {
    return function(n) {
      return n == null ? !1 : n[t] === r && (r !== void 0 || t in Object(n));
    };
  }
  return Gv = e, Gv;
}
var Vv, wL;
function Hve() {
  if (wL)
    return Vv;
  wL = 1;
  var e = Wve(), t = Uve(), r = d6();
  function n(o) {
    var s = t(o);
    return s.length == 1 && s[0][2] ? r(s[0][0], s[0][1]) : function(a) {
      return a === o || e(a, o, s);
    };
  }
  return Vv = n, Vv;
}
var Kv, _L;
function mA() {
  if (_L)
    return Kv;
  _L = 1;
  var e = Yt(), t = bu(), r = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, n = /^\w*$/;
  function o(s, a) {
    if (e(s))
      return !1;
    var l = typeof s;
    return l == "number" || l == "symbol" || l == "boolean" || s == null || t(s) ? !0 : n.test(s) || !r.test(s) || a != null && s in Object(a);
  }
  return Kv = o, Kv;
}
var Yv, SL;
function zve() {
  if (SL)
    return Yv;
  SL = 1;
  var e = sA(), t = "Expected a function";
  function r(n, o) {
    if (typeof n != "function" || o != null && typeof o != "function")
      throw new TypeError(t);
    var s = function() {
      var a = arguments, l = o ? o.apply(this, a) : a[0], u = s.cache;
      if (u.has(l))
        return u.get(l);
      var f = n.apply(this, a);
      return s.cache = u.set(l, f) || u, f;
    };
    return s.cache = new (r.Cache || e)(), s;
  }
  return r.Cache = e, Yv = r, Yv;
}
var Xv, EL;
function Gve() {
  if (EL)
    return Xv;
  EL = 1;
  var e = zve(), t = 500;
  function r(n) {
    var o = e(n, function(a) {
      return s.size === t && s.clear(), a;
    }), s = o.cache;
    return o;
  }
  return Xv = r, Xv;
}
var Jv, xL;
function Vve() {
  if (xL)
    return Jv;
  xL = 1;
  var e = Gve(), t = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, r = /\\(\\)?/g, n = e(function(o) {
    var s = [];
    return o.charCodeAt(0) === 46 && s.push(""), o.replace(t, function(a, l, u, f) {
      s.push(u ? f.replace(r, "$1") : l || a);
    }), s;
  });
  return Jv = n, Jv;
}
var Qv, RL;
function ob() {
  if (RL)
    return Qv;
  RL = 1;
  function e(t, r) {
    for (var n = -1, o = t == null ? 0 : t.length, s = Array(o); ++n < o; )
      s[n] = r(t[n], n, t);
    return s;
  }
  return Qv = e, Qv;
}
var Zv, AL;
function Kve() {
  if (AL)
    return Zv;
  AL = 1;
  var e = gu(), t = ob(), r = Yt(), n = bu(), o = 1 / 0, s = e ? e.prototype : void 0, a = s ? s.toString : void 0;
  function l(u) {
    if (typeof u == "string")
      return u;
    if (r(u))
      return t(u, l) + "";
    if (n(u))
      return a ? a.call(u) : "";
    var f = u + "";
    return f == "0" && 1 / u == -o ? "-0" : f;
  }
  return Zv = l, Zv;
}
var ew, TL;
function h6() {
  if (TL)
    return ew;
  TL = 1;
  var e = Kve();
  function t(r) {
    return r == null ? "" : e(r);
  }
  return ew = t, ew;
}
var tw, $L;
function sb() {
  if ($L)
    return tw;
  $L = 1;
  var e = Yt(), t = mA(), r = Vve(), n = h6();
  function o(s, a) {
    return e(s) ? s : t(s, a) ? [s] : r(n(s));
  }
  return tw = o, tw;
}
var rw, CL;
function Fc() {
  if (CL)
    return rw;
  CL = 1;
  var e = bu(), t = 1 / 0;
  function r(n) {
    if (typeof n == "string" || e(n))
      return n;
    var o = n + "";
    return o == "0" && 1 / n == -t ? "-0" : o;
  }
  return rw = r, rw;
}
var nw, kL;
function ab() {
  if (kL)
    return nw;
  kL = 1;
  var e = sb(), t = Fc();
  function r(n, o) {
    o = e(o, n);
    for (var s = 0, a = o.length; n != null && s < a; )
      n = n[t(o[s++])];
    return s && s == a ? n : void 0;
  }
  return nw = r, nw;
}
var iw, IL;
function Yve() {
  if (IL)
    return iw;
  IL = 1;
  var e = ab();
  function t(r, n, o) {
    var s = r == null ? void 0 : e(r, n);
    return s === void 0 ? o : s;
  }
  return iw = t, iw;
}
var ow, ML;
function Xve() {
  if (ML)
    return ow;
  ML = 1;
  function e(t, r) {
    return t != null && r in Object(t);
  }
  return ow = e, ow;
}
var sw, NL;
function p6() {
  if (NL)
    return sw;
  NL = 1;
  var e = sb(), t = Pc(), r = Yt(), n = eb(), o = lA(), s = Fc();
  function a(l, u, f) {
    u = e(u, l);
    for (var c = -1, d = u.length, h = !1; ++c < d; ) {
      var p = s(u[c]);
      if (!(h = l != null && f(l, p)))
        break;
      l = l[p];
    }
    return h || ++c != d ? h : (d = l == null ? 0 : l.length, !!d && o(d) && n(p, d) && (r(l) || t(l)));
  }
  return sw = a, sw;
}
var aw, LL;
function g6() {
  if (LL)
    return aw;
  LL = 1;
  var e = Xve(), t = p6();
  function r(n, o) {
    return n != null && t(n, o, e);
  }
  return aw = r, aw;
}
var lw, OL;
function Jve() {
  if (OL)
    return lw;
  OL = 1;
  var e = f6(), t = Yve(), r = g6(), n = mA(), o = c6(), s = d6(), a = Fc(), l = 1, u = 2;
  function f(c, d) {
    return n(c) && o(d) ? s(a(c), d) : function(h) {
      var p = t(h, c);
      return p === void 0 && p === d ? r(h, c) : e(d, p, l | u);
    };
  }
  return lw = f, lw;
}
var uw, PL;
function b6() {
  if (PL)
    return uw;
  PL = 1;
  function e(t) {
    return function(r) {
      return r == null ? void 0 : r[t];
    };
  }
  return uw = e, uw;
}
var fw, DL;
function Qve() {
  if (DL)
    return fw;
  DL = 1;
  var e = ab();
  function t(r) {
    return function(n) {
      return e(n, r);
    };
  }
  return fw = t, fw;
}
var cw, FL;
function Zve() {
  if (FL)
    return cw;
  FL = 1;
  var e = b6(), t = Qve(), r = mA(), n = Fc();
  function o(s) {
    return r(s) ? e(n(s)) : t(s);
  }
  return cw = o, cw;
}
var dw, jL;
function ko() {
  if (jL)
    return dw;
  jL = 1;
  var e = Hve(), t = Jve(), r = al(), n = Yt(), o = Zve();
  function s(a) {
    return typeof a == "function" ? a : a == null ? r : typeof a == "object" ? n(a) ? t(a[0], a[1]) : e(a) : o(a);
  }
  return dw = s, dw;
}
var hw, BL;
function y6() {
  if (BL)
    return hw;
  BL = 1;
  var e = Vq(), t = Lve(), r = ko(), n = Yt();
  function o(s, a) {
    var l = n(s) ? e : t;
    return l(s, r(a, 3));
  }
  return hw = o, hw;
}
var pw, qL;
function ewe() {
  if (qL)
    return pw;
  qL = 1;
  var e = Object.prototype, t = e.hasOwnProperty;
  function r(n, o) {
    return n != null && t.call(n, o);
  }
  return pw = r, pw;
}
var gw, WL;
function m6() {
  if (WL)
    return gw;
  WL = 1;
  var e = ewe(), t = p6();
  function r(n, o) {
    return n != null && t(n, o, e);
  }
  return gw = r, gw;
}
var bw, UL;
function twe() {
  if (UL)
    return bw;
  UL = 1;
  var e = fA(), t = $u(), r = Pc(), n = Yt(), o = Co(), s = Tu(), a = rb(), l = Dc(), u = "[object Map]", f = "[object Set]", c = Object.prototype, d = c.hasOwnProperty;
  function h(p) {
    if (p == null)
      return !0;
    if (o(p) && (n(p) || typeof p == "string" || typeof p.splice == "function" || s(p) || l(p) || r(p)))
      return !p.length;
    var m = t(p);
    if (m == u || m == f)
      return !p.size;
    if (a(p))
      return !e(p).length;
    for (var y in p)
      if (d.call(p, y))
        return !1;
    return !0;
  }
  return bw = h, bw;
}
var yw, HL;
function v6() {
  if (HL)
    return yw;
  HL = 1;
  function e(t) {
    return t === void 0;
  }
  return yw = e, yw;
}
var mw, zL;
function w6() {
  if (zL)
    return mw;
  zL = 1;
  var e = ib(), t = Co();
  function r(n, o) {
    var s = -1, a = t(n) ? Array(n.length) : [];
    return e(n, function(l, u, f) {
      a[++s] = o(l, u, f);
    }), a;
  }
  return mw = r, mw;
}
var vw, GL;
function _6() {
  if (GL)
    return vw;
  GL = 1;
  var e = ob(), t = ko(), r = w6(), n = Yt();
  function o(s, a) {
    var l = n(s) ? e : r;
    return l(s, t(a, 3));
  }
  return vw = o, vw;
}
var ww, VL;
function rwe() {
  if (VL)
    return ww;
  VL = 1;
  function e(t, r, n, o) {
    var s = -1, a = t == null ? 0 : t.length;
    for (o && a && (n = t[++s]); ++s < a; )
      n = r(n, t[s], s, t);
    return n;
  }
  return ww = e, ww;
}
var _w, KL;
function nwe() {
  if (KL)
    return _w;
  KL = 1;
  function e(t, r, n, o, s) {
    return s(t, function(a, l, u) {
      n = o ? (o = !1, a) : r(n, a, l, u);
    }), n;
  }
  return _w = e, _w;
}
var Sw, YL;
function S6() {
  if (YL)
    return Sw;
  YL = 1;
  var e = rwe(), t = ib(), r = ko(), n = nwe(), o = Yt();
  function s(a, l, u) {
    var f = o(a) ? e : n, c = arguments.length < 3;
    return f(a, r(l, 4), u, c, t);
  }
  return Sw = s, Sw;
}
var Ew, XL;
function iwe() {
  if (XL)
    return Ew;
  XL = 1;
  var e = Ka(), t = Yt(), r = ji(), n = "[object String]";
  function o(s) {
    return typeof s == "string" || !t(s) && r(s) && e(s) == n;
  }
  return Ew = o, Ew;
}
var xw, JL;
function owe() {
  if (JL)
    return xw;
  JL = 1;
  var e = b6(), t = e("length");
  return xw = t, xw;
}
var Rw, QL;
function swe() {
  if (QL)
    return Rw;
  QL = 1;
  var e = "\\ud800-\\udfff", t = "\\u0300-\\u036f", r = "\\ufe20-\\ufe2f", n = "\\u20d0-\\u20ff", o = t + r + n, s = "\\ufe0e\\ufe0f", a = "\\u200d", l = RegExp("[" + a + e + o + s + "]");
  function u(f) {
    return l.test(f);
  }
  return Rw = u, Rw;
}
var Aw, ZL;
function awe() {
  if (ZL)
    return Aw;
  ZL = 1;
  var e = "\\ud800-\\udfff", t = "\\u0300-\\u036f", r = "\\ufe20-\\ufe2f", n = "\\u20d0-\\u20ff", o = t + r + n, s = "\\ufe0e\\ufe0f", a = "[" + e + "]", l = "[" + o + "]", u = "\\ud83c[\\udffb-\\udfff]", f = "(?:" + l + "|" + u + ")", c = "[^" + e + "]", d = "(?:\\ud83c[\\udde6-\\uddff]){2}", h = "[\\ud800-\\udbff][\\udc00-\\udfff]", p = "\\u200d", m = f + "?", y = "[" + s + "]?", _ = "(?:" + p + "(?:" + [c, d, h].join("|") + ")" + y + m + ")*", S = y + m + _, x = "(?:" + [c + l + "?", l, d, h, a].join("|") + ")", E = RegExp(u + "(?=" + u + ")|" + x + S, "g");
  function C(I) {
    for (var j = E.lastIndex = 0; E.test(I); )
      ++j;
    return j;
  }
  return Aw = C, Aw;
}
var Tw, eO;
function lwe() {
  if (eO)
    return Tw;
  eO = 1;
  var e = owe(), t = swe(), r = awe();
  function n(o) {
    return t(o) ? r(o) : e(o);
  }
  return Tw = n, Tw;
}
var $w, tO;
function uwe() {
  if (tO)
    return $w;
  tO = 1;
  var e = fA(), t = $u(), r = Co(), n = iwe(), o = lwe(), s = "[object Map]", a = "[object Set]";
  function l(u) {
    if (u == null)
      return 0;
    if (r(u))
      return n(u) ? o(u) : u.length;
    var f = t(u);
    return f == s || f == a ? u.size : e(u).length;
  }
  return $w = l, $w;
}
var Cw, rO;
function fwe() {
  if (rO)
    return Cw;
  rO = 1;
  var e = aA(), t = t6(), r = bA(), n = ko(), o = nb(), s = Yt(), a = Tu(), l = Lc(), u = Mn(), f = Dc();
  function c(d, h, p) {
    var m = s(d), y = m || a(d) || f(d);
    if (h = n(h, 4), p == null) {
      var _ = d && d.constructor;
      y ? p = m ? new _() : [] : u(d) ? p = l(_) ? t(o(d)) : {} : p = {};
    }
    return (y ? e : r)(d, function(S, x, E) {
      return h(p, S, x, E);
    }), p;
  }
  return Cw = c, Cw;
}
var kw, nO;
function cwe() {
  if (nO)
    return kw;
  nO = 1;
  var e = gu(), t = Pc(), r = Yt(), n = e ? e.isConcatSpreadable : void 0;
  function o(s) {
    return r(s) || t(s) || !!(n && s && s[n]);
  }
  return kw = o, kw;
}
var Iw, iO;
function vA() {
  if (iO)
    return Iw;
  iO = 1;
  var e = dA(), t = cwe();
  function r(n, o, s, a, l) {
    var u = -1, f = n.length;
    for (s || (s = t), l || (l = []); ++u < f; ) {
      var c = n[u];
      o > 0 && s(c) ? o > 1 ? r(c, o - 1, s, a, l) : e(l, c) : a || (l[l.length] = c);
    }
    return l;
  }
  return Iw = r, Iw;
}
var Mw, oO;
function dwe() {
  if (oO)
    return Mw;
  oO = 1;
  function e(t, r, n) {
    switch (n.length) {
      case 0:
        return t.call(r);
      case 1:
        return t.call(r, n[0]);
      case 2:
        return t.call(r, n[0], n[1]);
      case 3:
        return t.call(r, n[0], n[1], n[2]);
    }
    return t.apply(r, n);
  }
  return Mw = e, Mw;
}
var Nw, sO;
function E6() {
  if (sO)
    return Nw;
  sO = 1;
  var e = dwe(), t = Math.max;
  function r(n, o, s) {
    return o = t(o === void 0 ? n.length - 1 : o, 0), function() {
      for (var a = arguments, l = -1, u = t(a.length - o, 0), f = Array(u); ++l < u; )
        f[l] = a[o + l];
      l = -1;
      for (var c = Array(o + 1); ++l < o; )
        c[l] = a[l];
      return c[o] = s(f), e(n, this, c);
    };
  }
  return Nw = r, Nw;
}
var Lw, aO;
function hwe() {
  if (aO)
    return Lw;
  aO = 1;
  var e = pA(), t = Wq(), r = al(), n = t ? function(o, s) {
    return t(o, "toString", {
      configurable: !0,
      enumerable: !1,
      value: e(s),
      writable: !0
    });
  } : r;
  return Lw = n, Lw;
}
var Ow, lO;
function pwe() {
  if (lO)
    return Ow;
  lO = 1;
  var e = 800, t = 16, r = Date.now;
  function n(o) {
    var s = 0, a = 0;
    return function() {
      var l = r(), u = t - (l - a);
      if (a = l, u > 0) {
        if (++s >= e)
          return arguments[0];
      } else
        s = 0;
      return o.apply(void 0, arguments);
    };
  }
  return Ow = n, Ow;
}
var Pw, uO;
function x6() {
  if (uO)
    return Pw;
  uO = 1;
  var e = hwe(), t = pwe(), r = t(e);
  return Pw = r, Pw;
}
var Dw, fO;
function lb() {
  if (fO)
    return Dw;
  fO = 1;
  var e = al(), t = E6(), r = x6();
  function n(o, s) {
    return r(t(o, s, e), o + "");
  }
  return Dw = n, Dw;
}
var Fw, cO;
function R6() {
  if (cO)
    return Fw;
  cO = 1;
  function e(t, r, n, o) {
    for (var s = t.length, a = n + (o ? 1 : -1); o ? a-- : ++a < s; )
      if (r(t[a], a, t))
        return a;
    return -1;
  }
  return Fw = e, Fw;
}
var jw, dO;
function gwe() {
  if (dO)
    return jw;
  dO = 1;
  function e(t) {
    return t !== t;
  }
  return jw = e, jw;
}
var Bw, hO;
function bwe() {
  if (hO)
    return Bw;
  hO = 1;
  function e(t, r, n) {
    for (var o = n - 1, s = t.length; ++o < s; )
      if (t[o] === r)
        return o;
    return -1;
  }
  return Bw = e, Bw;
}
var qw, pO;
function ywe() {
  if (pO)
    return qw;
  pO = 1;
  var e = R6(), t = gwe(), r = bwe();
  function n(o, s, a) {
    return s === s ? r(o, s, a) : e(o, t, a);
  }
  return qw = n, qw;
}
var Ww, gO;
function mwe() {
  if (gO)
    return Ww;
  gO = 1;
  var e = ywe();
  function t(r, n) {
    var o = r == null ? 0 : r.length;
    return !!o && e(r, n, 0) > -1;
  }
  return Ww = t, Ww;
}
var Uw, bO;
function vwe() {
  if (bO)
    return Uw;
  bO = 1;
  function e(t, r, n) {
    for (var o = -1, s = t == null ? 0 : t.length; ++o < s; )
      if (n(r, t[o]))
        return !0;
    return !1;
  }
  return Uw = e, Uw;
}
var Hw, yO;
function wwe() {
  if (yO)
    return Hw;
  yO = 1;
  function e() {
  }
  return Hw = e, Hw;
}
var zw, mO;
function _we() {
  if (mO)
    return zw;
  mO = 1;
  var e = Qq(), t = wwe(), r = yA(), n = 1 / 0, o = e && 1 / r(new e([, -0]))[1] == n ? function(s) {
    return new e(s);
  } : t;
  return zw = o, zw;
}
var Gw, vO;
function Swe() {
  if (vO)
    return Gw;
  vO = 1;
  var e = a6(), t = mwe(), r = vwe(), n = l6(), o = _we(), s = yA(), a = 200;
  function l(u, f, c) {
    var d = -1, h = t, p = u.length, m = !0, y = [], _ = y;
    if (c)
      m = !1, h = r;
    else if (p >= a) {
      var S = f ? null : o(u);
      if (S)
        return s(S);
      m = !1, h = n, _ = new e();
    } else
      _ = f ? [] : y;
    e:
      for (; ++d < p; ) {
        var x = u[d], E = f ? f(x) : x;
        if (x = c || x !== 0 ? x : 0, m && E === E) {
          for (var C = _.length; C--; )
            if (_[C] === E)
              continue e;
          f && _.push(E), y.push(x);
        } else
          h(_, E, c) || (_ !== y && _.push(E), y.push(x));
      }
    return y;
  }
  return Gw = l, Gw;
}
var Vw, wO;
function A6() {
  if (wO)
    return Vw;
  wO = 1;
  var e = Co(), t = ji();
  function r(n) {
    return t(n) && e(n);
  }
  return Vw = r, Vw;
}
var Kw, _O;
function Ewe() {
  if (_O)
    return Kw;
  _O = 1;
  var e = vA(), t = lb(), r = Swe(), n = A6(), o = t(function(s) {
    return r(e(s, 1, n, !0));
  });
  return Kw = o, Kw;
}
var Yw, SO;
function xwe() {
  if (SO)
    return Yw;
  SO = 1;
  var e = ob();
  function t(r, n) {
    return e(n, function(o) {
      return r[o];
    });
  }
  return Yw = t, Yw;
}
var Xw, EO;
function T6() {
  if (EO)
    return Xw;
  EO = 1;
  var e = xwe(), t = Rs();
  function r(n) {
    return n == null ? [] : e(n, t(n));
  }
  return Xw = r, Xw;
}
var Jw, xO;
function Pn() {
  if (xO)
    return Jw;
  xO = 1;
  var e;
  if (typeof iA == "function")
    try {
      e = {
        clone: Ive(),
        constant: pA(),
        each: s6(),
        filter: y6(),
        has: m6(),
        isArray: Yt(),
        isEmpty: twe(),
        isFunction: Lc(),
        isUndefined: v6(),
        keys: Rs(),
        map: _6(),
        reduce: S6(),
        size: uwe(),
        transform: fwe(),
        union: Ewe(),
        values: T6()
      };
    } catch {
    }
  return e || (e = window._), Jw = e, Jw;
}
var Qw, RO;
function wA() {
  if (RO)
    return Qw;
  RO = 1;
  var e = Pn();
  Qw = o;
  var t = "\0", r = "\0", n = "";
  function o(c) {
    this._isDirected = e.has(c, "directed") ? c.directed : !0, this._isMultigraph = e.has(c, "multigraph") ? c.multigraph : !1, this._isCompound = e.has(c, "compound") ? c.compound : !1, this._label = void 0, this._defaultNodeLabelFn = e.constant(void 0), this._defaultEdgeLabelFn = e.constant(void 0), this._nodes = {}, this._isCompound && (this._parent = {}, this._children = {}, this._children[r] = {}), this._in = {}, this._preds = {}, this._out = {}, this._sucs = {}, this._edgeObjs = {}, this._edgeLabels = {};
  }
  o.prototype._nodeCount = 0, o.prototype._edgeCount = 0, o.prototype.isDirected = function() {
    return this._isDirected;
  }, o.prototype.isMultigraph = function() {
    return this._isMultigraph;
  }, o.prototype.isCompound = function() {
    return this._isCompound;
  }, o.prototype.setGraph = function(c) {
    return this._label = c, this;
  }, o.prototype.graph = function() {
    return this._label;
  }, o.prototype.setDefaultNodeLabel = function(c) {
    return e.isFunction(c) || (c = e.constant(c)), this._defaultNodeLabelFn = c, this;
  }, o.prototype.nodeCount = function() {
    return this._nodeCount;
  }, o.prototype.nodes = function() {
    return e.keys(this._nodes);
  }, o.prototype.sources = function() {
    var c = this;
    return e.filter(this.nodes(), function(d) {
      return e.isEmpty(c._in[d]);
    });
  }, o.prototype.sinks = function() {
    var c = this;
    return e.filter(this.nodes(), function(d) {
      return e.isEmpty(c._out[d]);
    });
  }, o.prototype.setNodes = function(c, d) {
    var h = arguments, p = this;
    return e.each(c, function(m) {
      h.length > 1 ? p.setNode(m, d) : p.setNode(m);
    }), this;
  }, o.prototype.setNode = function(c, d) {
    return e.has(this._nodes, c) ? (arguments.length > 1 && (this._nodes[c] = d), this) : (this._nodes[c] = arguments.length > 1 ? d : this._defaultNodeLabelFn(c), this._isCompound && (this._parent[c] = r, this._children[c] = {}, this._children[r][c] = !0), this._in[c] = {}, this._preds[c] = {}, this._out[c] = {}, this._sucs[c] = {}, ++this._nodeCount, this);
  }, o.prototype.node = function(c) {
    return this._nodes[c];
  }, o.prototype.hasNode = function(c) {
    return e.has(this._nodes, c);
  }, o.prototype.removeNode = function(c) {
    var d = this;
    if (e.has(this._nodes, c)) {
      var h = function(p) {
        d.removeEdge(d._edgeObjs[p]);
      };
      delete this._nodes[c], this._isCompound && (this._removeFromParentsChildList(c), delete this._parent[c], e.each(this.children(c), function(p) {
        d.setParent(p);
      }), delete this._children[c]), e.each(e.keys(this._in[c]), h), delete this._in[c], delete this._preds[c], e.each(e.keys(this._out[c]), h), delete this._out[c], delete this._sucs[c], --this._nodeCount;
    }
    return this;
  }, o.prototype.setParent = function(c, d) {
    if (!this._isCompound)
      throw new Error("Cannot set parent in a non-compound graph");
    if (e.isUndefined(d))
      d = r;
    else {
      d += "";
      for (var h = d; !e.isUndefined(h); h = this.parent(h))
        if (h === c)
          throw new Error("Setting " + d + " as parent of " + c + " would create a cycle");
      this.setNode(d);
    }
    return this.setNode(c), this._removeFromParentsChildList(c), this._parent[c] = d, this._children[d][c] = !0, this;
  }, o.prototype._removeFromParentsChildList = function(c) {
    delete this._children[this._parent[c]][c];
  }, o.prototype.parent = function(c) {
    if (this._isCompound) {
      var d = this._parent[c];
      if (d !== r)
        return d;
    }
  }, o.prototype.children = function(c) {
    if (e.isUndefined(c) && (c = r), this._isCompound) {
      var d = this._children[c];
      if (d)
        return e.keys(d);
    } else {
      if (c === r)
        return this.nodes();
      if (this.hasNode(c))
        return [];
    }
  }, o.prototype.predecessors = function(c) {
    var d = this._preds[c];
    if (d)
      return e.keys(d);
  }, o.prototype.successors = function(c) {
    var d = this._sucs[c];
    if (d)
      return e.keys(d);
  }, o.prototype.neighbors = function(c) {
    var d = this.predecessors(c);
    if (d)
      return e.union(d, this.successors(c));
  }, o.prototype.isLeaf = function(c) {
    var d;
    return this.isDirected() ? d = this.successors(c) : d = this.neighbors(c), d.length === 0;
  }, o.prototype.filterNodes = function(c) {
    var d = new this.constructor({
      directed: this._isDirected,
      multigraph: this._isMultigraph,
      compound: this._isCompound
    });
    d.setGraph(this.graph());
    var h = this;
    e.each(this._nodes, function(y, _) {
      c(_) && d.setNode(_, y);
    }), e.each(this._edgeObjs, function(y) {
      d.hasNode(y.v) && d.hasNode(y.w) && d.setEdge(y, h.edge(y));
    });
    var p = {};
    function m(y) {
      var _ = h.parent(y);
      return _ === void 0 || d.hasNode(_) ? (p[y] = _, _) : _ in p ? p[_] : m(_);
    }
    return this._isCompound && e.each(d.nodes(), function(y) {
      d.setParent(y, m(y));
    }), d;
  }, o.prototype.setDefaultEdgeLabel = function(c) {
    return e.isFunction(c) || (c = e.constant(c)), this._defaultEdgeLabelFn = c, this;
  }, o.prototype.edgeCount = function() {
    return this._edgeCount;
  }, o.prototype.edges = function() {
    return e.values(this._edgeObjs);
  }, o.prototype.setPath = function(c, d) {
    var h = this, p = arguments;
    return e.reduce(c, function(m, y) {
      return p.length > 1 ? h.setEdge(m, y, d) : h.setEdge(m, y), y;
    }), this;
  }, o.prototype.setEdge = function() {
    var c, d, h, p, m = !1, y = arguments[0];
    typeof y == "object" && y !== null && "v" in y ? (c = y.v, d = y.w, h = y.name, arguments.length === 2 && (p = arguments[1], m = !0)) : (c = y, d = arguments[1], h = arguments[3], arguments.length > 2 && (p = arguments[2], m = !0)), c = "" + c, d = "" + d, e.isUndefined(h) || (h = "" + h);
    var _ = l(this._isDirected, c, d, h);
    if (e.has(this._edgeLabels, _))
      return m && (this._edgeLabels[_] = p), this;
    if (!e.isUndefined(h) && !this._isMultigraph)
      throw new Error("Cannot set a named edge when isMultigraph = false");
    this.setNode(c), this.setNode(d), this._edgeLabels[_] = m ? p : this._defaultEdgeLabelFn(c, d, h);
    var S = u(this._isDirected, c, d, h);
    return c = S.v, d = S.w, Object.freeze(S), this._edgeObjs[_] = S, s(this._preds[d], c), s(this._sucs[c], d), this._in[d][_] = S, this._out[c][_] = S, this._edgeCount++, this;
  }, o.prototype.edge = function(c, d, h) {
    var p = arguments.length === 1 ? f(this._isDirected, arguments[0]) : l(this._isDirected, c, d, h);
    return this._edgeLabels[p];
  }, o.prototype.hasEdge = function(c, d, h) {
    var p = arguments.length === 1 ? f(this._isDirected, arguments[0]) : l(this._isDirected, c, d, h);
    return e.has(this._edgeLabels, p);
  }, o.prototype.removeEdge = function(c, d, h) {
    var p = arguments.length === 1 ? f(this._isDirected, arguments[0]) : l(this._isDirected, c, d, h), m = this._edgeObjs[p];
    return m && (c = m.v, d = m.w, delete this._edgeLabels[p], delete this._edgeObjs[p], a(this._preds[d], c), a(this._sucs[c], d), delete this._in[d][p], delete this._out[c][p], this._edgeCount--), this;
  }, o.prototype.inEdges = function(c, d) {
    var h = this._in[c];
    if (h) {
      var p = e.values(h);
      return d ? e.filter(p, function(m) {
        return m.v === d;
      }) : p;
    }
  }, o.prototype.outEdges = function(c, d) {
    var h = this._out[c];
    if (h) {
      var p = e.values(h);
      return d ? e.filter(p, function(m) {
        return m.w === d;
      }) : p;
    }
  }, o.prototype.nodeEdges = function(c, d) {
    var h = this.inEdges(c, d);
    if (h)
      return h.concat(this.outEdges(c, d));
  };
  function s(c, d) {
    c[d] ? c[d]++ : c[d] = 1;
  }
  function a(c, d) {
    --c[d] || delete c[d];
  }
  function l(c, d, h, p) {
    var m = "" + d, y = "" + h;
    if (!c && m > y) {
      var _ = m;
      m = y, y = _;
    }
    return m + n + y + n + (e.isUndefined(p) ? t : p);
  }
  function u(c, d, h, p) {
    var m = "" + d, y = "" + h;
    if (!c && m > y) {
      var _ = m;
      m = y, y = _;
    }
    var S = { v: m, w: y };
    return p && (S.name = p), S;
  }
  function f(c, d) {
    return l(c, d.v, d.w, d.name);
  }
  return Qw;
}
var Zw, AO;
function Rwe() {
  return AO || (AO = 1, Zw = "2.1.8"), Zw;
}
var e_, TO;
function Awe() {
  return TO || (TO = 1, e_ = {
    Graph: wA(),
    version: Rwe()
  }), e_;
}
var t_, $O;
function Twe() {
  if ($O)
    return t_;
  $O = 1;
  var e = Pn(), t = wA();
  t_ = {
    write: r,
    read: s
  };
  function r(a) {
    var l = {
      options: {
        directed: a.isDirected(),
        multigraph: a.isMultigraph(),
        compound: a.isCompound()
      },
      nodes: n(a),
      edges: o(a)
    };
    return e.isUndefined(a.graph()) || (l.value = e.clone(a.graph())), l;
  }
  function n(a) {
    return e.map(a.nodes(), function(l) {
      var u = a.node(l), f = a.parent(l), c = { v: l };
      return e.isUndefined(u) || (c.value = u), e.isUndefined(f) || (c.parent = f), c;
    });
  }
  function o(a) {
    return e.map(a.edges(), function(l) {
      var u = a.edge(l), f = { v: l.v, w: l.w };
      return e.isUndefined(l.name) || (f.name = l.name), e.isUndefined(u) || (f.value = u), f;
    });
  }
  function s(a) {
    var l = new t(a.options).setGraph(a.value);
    return e.each(a.nodes, function(u) {
      l.setNode(u.v, u.value), u.parent && l.setParent(u.v, u.parent);
    }), e.each(a.edges, function(u) {
      l.setEdge({ v: u.v, w: u.w, name: u.name }, u.value);
    }), l;
  }
  return t_;
}
var r_, CO;
function $we() {
  if (CO)
    return r_;
  CO = 1;
  var e = Pn();
  r_ = t;
  function t(r) {
    var n = {}, o = [], s;
    function a(l) {
      e.has(n, l) || (n[l] = !0, s.push(l), e.each(r.successors(l), a), e.each(r.predecessors(l), a));
    }
    return e.each(r.nodes(), function(l) {
      s = [], a(l), s.length && o.push(s);
    }), o;
  }
  return r_;
}
var n_, kO;
function $6() {
  if (kO)
    return n_;
  kO = 1;
  var e = Pn();
  n_ = t;
  function t() {
    this._arr = [], this._keyIndices = {};
  }
  return t.prototype.size = function() {
    return this._arr.length;
  }, t.prototype.keys = function() {
    return this._arr.map(function(r) {
      return r.key;
    });
  }, t.prototype.has = function(r) {
    return e.has(this._keyIndices, r);
  }, t.prototype.priority = function(r) {
    var n = this._keyIndices[r];
    if (n !== void 0)
      return this._arr[n].priority;
  }, t.prototype.min = function() {
    if (this.size() === 0)
      throw new Error("Queue underflow");
    return this._arr[0].key;
  }, t.prototype.add = function(r, n) {
    var o = this._keyIndices;
    if (r = String(r), !e.has(o, r)) {
      var s = this._arr, a = s.length;
      return o[r] = a, s.push({ key: r, priority: n }), this._decrease(a), !0;
    }
    return !1;
  }, t.prototype.removeMin = function() {
    this._swap(0, this._arr.length - 1);
    var r = this._arr.pop();
    return delete this._keyIndices[r.key], this._heapify(0), r.key;
  }, t.prototype.decrease = function(r, n) {
    var o = this._keyIndices[r];
    if (n > this._arr[o].priority)
      throw new Error("New priority is greater than current priority. Key: " + r + " Old: " + this._arr[o].priority + " New: " + n);
    this._arr[o].priority = n, this._decrease(o);
  }, t.prototype._heapify = function(r) {
    var n = this._arr, o = 2 * r, s = o + 1, a = r;
    o < n.length && (a = n[o].priority < n[a].priority ? o : a, s < n.length && (a = n[s].priority < n[a].priority ? s : a), a !== r && (this._swap(r, a), this._heapify(a)));
  }, t.prototype._decrease = function(r) {
    for (var n = this._arr, o = n[r].priority, s; r !== 0 && (s = r >> 1, !(n[s].priority < o)); )
      this._swap(r, s), r = s;
  }, t.prototype._swap = function(r, n) {
    var o = this._arr, s = this._keyIndices, a = o[r], l = o[n];
    o[r] = l, o[n] = a, s[l.key] = r, s[a.key] = n;
  }, n_;
}
var i_, IO;
function C6() {
  if (IO)
    return i_;
  IO = 1;
  var e = Pn(), t = $6();
  i_ = n;
  var r = e.constant(1);
  function n(s, a, l, u) {
    return o(
      s,
      String(a),
      l || r,
      u || function(f) {
        return s.outEdges(f);
      }
    );
  }
  function o(s, a, l, u) {
    var f = {}, c = new t(), d, h, p = function(m) {
      var y = m.v !== d ? m.v : m.w, _ = f[y], S = l(m), x = h.distance + S;
      if (S < 0)
        throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + m + " Weight: " + S);
      x < _.distance && (_.distance = x, _.predecessor = d, c.decrease(y, x));
    };
    for (s.nodes().forEach(function(m) {
      var y = m === a ? 0 : Number.POSITIVE_INFINITY;
      f[m] = { distance: y }, c.add(m, y);
    }); c.size() > 0 && (d = c.removeMin(), h = f[d], h.distance !== Number.POSITIVE_INFINITY); )
      u(d).forEach(p);
    return f;
  }
  return i_;
}
var o_, MO;
function Cwe() {
  if (MO)
    return o_;
  MO = 1;
  var e = C6(), t = Pn();
  o_ = r;
  function r(n, o, s) {
    return t.transform(n.nodes(), function(a, l) {
      a[l] = e(n, l, o, s);
    }, {});
  }
  return o_;
}
var s_, NO;
function k6() {
  if (NO)
    return s_;
  NO = 1;
  var e = Pn();
  s_ = t;
  function t(r) {
    var n = 0, o = [], s = {}, a = [];
    function l(u) {
      var f = s[u] = {
        onStack: !0,
        lowlink: n,
        index: n++
      };
      if (o.push(u), r.successors(u).forEach(function(h) {
        e.has(s, h) ? s[h].onStack && (f.lowlink = Math.min(f.lowlink, s[h].index)) : (l(h), f.lowlink = Math.min(f.lowlink, s[h].lowlink));
      }), f.lowlink === f.index) {
        var c = [], d;
        do
          d = o.pop(), s[d].onStack = !1, c.push(d);
        while (u !== d);
        a.push(c);
      }
    }
    return r.nodes().forEach(function(u) {
      e.has(s, u) || l(u);
    }), a;
  }
  return s_;
}
var a_, LO;
function kwe() {
  if (LO)
    return a_;
  LO = 1;
  var e = Pn(), t = k6();
  a_ = r;
  function r(n) {
    return e.filter(t(n), function(o) {
      return o.length > 1 || o.length === 1 && n.hasEdge(o[0], o[0]);
    });
  }
  return a_;
}
var l_, OO;
function Iwe() {
  if (OO)
    return l_;
  OO = 1;
  var e = Pn();
  l_ = r;
  var t = e.constant(1);
  function r(o, s, a) {
    return n(
      o,
      s || t,
      a || function(l) {
        return o.outEdges(l);
      }
    );
  }
  function n(o, s, a) {
    var l = {}, u = o.nodes();
    return u.forEach(function(f) {
      l[f] = {}, l[f][f] = { distance: 0 }, u.forEach(function(c) {
        f !== c && (l[f][c] = { distance: Number.POSITIVE_INFINITY });
      }), a(f).forEach(function(c) {
        var d = c.v === f ? c.w : c.v, h = s(c);
        l[f][d] = { distance: h, predecessor: f };
      });
    }), u.forEach(function(f) {
      var c = l[f];
      u.forEach(function(d) {
        var h = l[d];
        u.forEach(function(p) {
          var m = h[f], y = c[p], _ = h[p], S = m.distance + y.distance;
          S < _.distance && (_.distance = S, _.predecessor = y.predecessor);
        });
      });
    }), l;
  }
  return l_;
}
var u_, PO;
function I6() {
  if (PO)
    return u_;
  PO = 1;
  var e = Pn();
  u_ = t, t.CycleException = r;
  function t(n) {
    var o = {}, s = {}, a = [];
    function l(u) {
      if (e.has(s, u))
        throw new r();
      e.has(o, u) || (s[u] = !0, o[u] = !0, e.each(n.predecessors(u), l), delete s[u], a.push(u));
    }
    if (e.each(n.sinks(), l), e.size(o) !== n.nodeCount())
      throw new r();
    return a;
  }
  function r() {
  }
  return r.prototype = new Error(), u_;
}
var f_, DO;
function Mwe() {
  if (DO)
    return f_;
  DO = 1;
  var e = I6();
  f_ = t;
  function t(r) {
    try {
      e(r);
    } catch (n) {
      if (n instanceof e.CycleException)
        return !1;
      throw n;
    }
    return !0;
  }
  return f_;
}
var c_, FO;
function M6() {
  if (FO)
    return c_;
  FO = 1;
  var e = Pn();
  c_ = t;
  function t(n, o, s) {
    e.isArray(o) || (o = [o]);
    var a = (n.isDirected() ? n.successors : n.neighbors).bind(n), l = [], u = {};
    return e.each(o, function(f) {
      if (!n.hasNode(f))
        throw new Error("Graph does not have node: " + f);
      r(n, f, s === "post", u, a, l);
    }), l;
  }
  function r(n, o, s, a, l, u) {
    e.has(a, o) || (a[o] = !0, s || u.push(o), e.each(l(o), function(f) {
      r(n, f, s, a, l, u);
    }), s && u.push(o));
  }
  return c_;
}
var d_, jO;
function Nwe() {
  if (jO)
    return d_;
  jO = 1;
  var e = M6();
  d_ = t;
  function t(r, n) {
    return e(r, n, "post");
  }
  return d_;
}
var h_, BO;
function Lwe() {
  if (BO)
    return h_;
  BO = 1;
  var e = M6();
  h_ = t;
  function t(r, n) {
    return e(r, n, "pre");
  }
  return h_;
}
var p_, qO;
function Owe() {
  if (qO)
    return p_;
  qO = 1;
  var e = Pn(), t = wA(), r = $6();
  p_ = n;
  function n(o, s) {
    var a = new t(), l = {}, u = new r(), f;
    function c(h) {
      var p = h.v === f ? h.w : h.v, m = u.priority(p);
      if (m !== void 0) {
        var y = s(h);
        y < m && (l[p] = f, u.decrease(p, y));
      }
    }
    if (o.nodeCount() === 0)
      return a;
    e.each(o.nodes(), function(h) {
      u.add(h, Number.POSITIVE_INFINITY), a.setNode(h);
    }), u.decrease(o.nodes()[0], 0);
    for (var d = !1; u.size() > 0; ) {
      if (f = u.removeMin(), e.has(l, f))
        a.setEdge(f, l[f]);
      else {
        if (d)
          throw new Error("Input graph is not connected: " + o);
        d = !0;
      }
      o.nodeEdges(f).forEach(c);
    }
    return a;
  }
  return p_;
}
var g_, WO;
function Pwe() {
  return WO || (WO = 1, g_ = {
    components: $we(),
    dijkstra: C6(),
    dijkstraAll: Cwe(),
    findCycles: kwe(),
    floydWarshall: Iwe(),
    isAcyclic: Mwe(),
    postorder: Nwe(),
    preorder: Lwe(),
    prim: Owe(),
    tarjan: k6(),
    topsort: I6()
  }), g_;
}
var b_, UO;
function Dwe() {
  if (UO)
    return b_;
  UO = 1;
  var e = Awe();
  return b_ = {
    Graph: e.Graph,
    json: Twe(),
    alg: Pwe(),
    version: e.version
  }, b_;
}
var Yh;
if (typeof iA == "function")
  try {
    Yh = Dwe();
  } catch {
  }
Yh || (Yh = window.graphlib);
var oi = Yh, y_, HO;
function Fwe() {
  if (HO)
    return y_;
  HO = 1;
  var e = n6(), t = 1, r = 4;
  function n(o) {
    return e(o, t | r);
  }
  return y_ = n, y_;
}
var m_, zO;
function ub() {
  if (zO)
    return m_;
  zO = 1;
  var e = Au(), t = Co(), r = eb(), n = Mn();
  function o(s, a, l) {
    if (!n(l))
      return !1;
    var u = typeof a;
    return (u == "number" ? t(l) && r(a, l.length) : u == "string" && a in l) ? e(l[a], s) : !1;
  }
  return m_ = o, m_;
}
var v_, GO;
function jwe() {
  if (GO)
    return v_;
  GO = 1;
  var e = lb(), t = Au(), r = ub(), n = sl(), o = Object.prototype, s = o.hasOwnProperty, a = e(function(l, u) {
    l = Object(l);
    var f = -1, c = u.length, d = c > 2 ? u[2] : void 0;
    for (d && r(u[0], u[1], d) && (c = 1); ++f < c; )
      for (var h = u[f], p = n(h), m = -1, y = p.length; ++m < y; ) {
        var _ = p[m], S = l[_];
        (S === void 0 || t(S, o[_]) && !s.call(l, _)) && (l[_] = h[_]);
      }
    return l;
  });
  return v_ = a, v_;
}
var w_, VO;
function Bwe() {
  if (VO)
    return w_;
  VO = 1;
  var e = ko(), t = Co(), r = Rs();
  function n(o) {
    return function(s, a, l) {
      var u = Object(s);
      if (!t(s)) {
        var f = e(a, 3);
        s = r(s), a = function(d) {
          return f(u[d], d, u);
        };
      }
      var c = o(s, a, l);
      return c > -1 ? u[f ? s[c] : c] : void 0;
    };
  }
  return w_ = n, w_;
}
var __, KO;
function qwe() {
  if (KO)
    return __;
  KO = 1;
  var e = R6(), t = ko(), r = $7, n = Math.max;
  function o(s, a, l) {
    var u = s == null ? 0 : s.length;
    if (!u)
      return -1;
    var f = l == null ? 0 : r(l);
    return f < 0 && (f = n(u + f, 0)), e(s, t(a, 3), f);
  }
  return __ = o, __;
}
var S_, YO;
function Wwe() {
  if (YO)
    return S_;
  YO = 1;
  var e = Bwe(), t = qwe(), r = e(t);
  return S_ = r, S_;
}
var E_, XO;
function N6() {
  if (XO)
    return E_;
  XO = 1;
  var e = vA();
  function t(r) {
    var n = r == null ? 0 : r.length;
    return n ? e(r, 1) : [];
  }
  return E_ = t, E_;
}
var x_, JO;
function Uwe() {
  if (JO)
    return x_;
  JO = 1;
  var e = gA(), t = i6(), r = sl();
  function n(o, s) {
    return o == null ? o : e(o, t(s), r);
  }
  return x_ = n, x_;
}
var R_, QO;
function Hwe() {
  if (QO)
    return R_;
  QO = 1;
  function e(t) {
    var r = t == null ? 0 : t.length;
    return r ? t[r - 1] : void 0;
  }
  return R_ = e, R_;
}
var A_, ZO;
function zwe() {
  if (ZO)
    return A_;
  ZO = 1;
  var e = Qg(), t = bA(), r = ko();
  function n(o, s) {
    var a = {};
    return s = r(s, 3), t(o, function(l, u, f) {
      e(a, u, s(l, u, f));
    }), a;
  }
  return A_ = n, A_;
}
var T_, eP;
function _A() {
  if (eP)
    return T_;
  eP = 1;
  var e = bu();
  function t(r, n, o) {
    for (var s = -1, a = r.length; ++s < a; ) {
      var l = r[s], u = n(l);
      if (u != null && (f === void 0 ? u === u && !e(u) : o(u, f)))
        var f = u, c = l;
    }
    return c;
  }
  return T_ = t, T_;
}
var $_, tP;
function Gwe() {
  if (tP)
    return $_;
  tP = 1;
  function e(t, r) {
    return t > r;
  }
  return $_ = e, $_;
}
var C_, rP;
function Vwe() {
  if (rP)
    return C_;
  rP = 1;
  var e = _A(), t = Gwe(), r = al();
  function n(o) {
    return o && o.length ? e(o, r, t) : void 0;
  }
  return C_ = n, C_;
}
var k_, nP;
function L6() {
  if (nP)
    return k_;
  nP = 1;
  var e = Qg(), t = Au();
  function r(n, o, s) {
    (s !== void 0 && !t(n[o], s) || s === void 0 && !(o in n)) && e(n, o, s);
  }
  return k_ = r, k_;
}
var I_, iP;
function Kwe() {
  if (iP)
    return I_;
  iP = 1;
  var e = Ka(), t = nb(), r = ji(), n = "[object Object]", o = Function.prototype, s = Object.prototype, a = o.toString, l = s.hasOwnProperty, u = a.call(Object);
  function f(c) {
    if (!r(c) || e(c) != n)
      return !1;
    var d = t(c);
    if (d === null)
      return !0;
    var h = l.call(d, "constructor") && d.constructor;
    return typeof h == "function" && h instanceof h && a.call(h) == u;
  }
  return I_ = f, I_;
}
var M_, oP;
function O6() {
  if (oP)
    return M_;
  oP = 1;
  function e(t, r) {
    if (!(r === "constructor" && typeof t[r] == "function") && r != "__proto__")
      return t[r];
  }
  return M_ = e, M_;
}
var N_, sP;
function Ywe() {
  if (sP)
    return N_;
  sP = 1;
  var e = Oc(), t = sl();
  function r(n) {
    return e(n, t(n));
  }
  return N_ = r, N_;
}
var L_, aP;
function Xwe() {
  if (aP)
    return L_;
  aP = 1;
  var e = L6(), t = zq(), r = e6(), n = Gq(), o = r6(), s = Pc(), a = Yt(), l = A6(), u = Tu(), f = Lc(), c = Mn(), d = Kwe(), h = Dc(), p = O6(), m = Ywe();
  function y(_, S, x, E, C, I, j) {
    var J = p(_, x), G = p(S, x), $ = j.get(G);
    if ($) {
      e(_, x, $);
      return;
    }
    var V = I ? I(J, G, x + "", _, S, j) : void 0, M = V === void 0;
    if (M) {
      var W = a(G), k = !W && u(G), U = !W && !k && h(G);
      V = G, W || k || U ? a(J) ? V = J : l(J) ? V = n(J) : k ? (M = !1, V = t(G, !0)) : U ? (M = !1, V = r(G, !0)) : V = [] : d(G) || s(G) ? (V = J, s(J) ? V = m(J) : (!c(J) || f(J)) && (V = o(G))) : M = !1;
    }
    M && (j.set(G, V), C(V, G, E, I, j), j.delete(G)), e(_, x, V);
  }
  return L_ = y, L_;
}
var O_, lP;
function Jwe() {
  if (lP)
    return O_;
  lP = 1;
  var e = Jg(), t = L6(), r = gA(), n = Xwe(), o = Mn(), s = sl(), a = O6();
  function l(u, f, c, d, h) {
    u !== f && r(f, function(p, m) {
      if (h || (h = new e()), o(p))
        n(u, f, m, c, l, d, h);
      else {
        var y = d ? d(a(u, m), p, m + "", u, f, h) : void 0;
        y === void 0 && (y = p), t(u, m, y);
      }
    }, s);
  }
  return O_ = l, O_;
}
var P_, uP;
function Qwe() {
  if (uP)
    return P_;
  uP = 1;
  var e = lb(), t = ub();
  function r(n) {
    return e(function(o, s) {
      var a = -1, l = s.length, u = l > 1 ? s[l - 1] : void 0, f = l > 2 ? s[2] : void 0;
      for (u = n.length > 3 && typeof u == "function" ? (l--, u) : void 0, f && t(s[0], s[1], f) && (u = l < 3 ? void 0 : u, l = 1), o = Object(o); ++a < l; ) {
        var c = s[a];
        c && n(o, c, a, u);
      }
      return o;
    });
  }
  return P_ = r, P_;
}
var D_, fP;
function Zwe() {
  if (fP)
    return D_;
  fP = 1;
  var e = Jwe(), t = Qwe(), r = t(function(n, o, s) {
    e(n, o, s);
  });
  return D_ = r, D_;
}
var F_, cP;
function P6() {
  if (cP)
    return F_;
  cP = 1;
  function e(t, r) {
    return t < r;
  }
  return F_ = e, F_;
}
var j_, dP;
function e_e() {
  if (dP)
    return j_;
  dP = 1;
  var e = _A(), t = P6(), r = al();
  function n(o) {
    return o && o.length ? e(o, r, t) : void 0;
  }
  return j_ = n, j_;
}
var B_, hP;
function t_e() {
  if (hP)
    return B_;
  hP = 1;
  var e = _A(), t = ko(), r = P6();
  function n(o, s) {
    return o && o.length ? e(o, t(s, 2), r) : void 0;
  }
  return B_ = n, B_;
}
var q_, pP;
function r_e() {
  if (pP)
    return q_;
  pP = 1;
  var e = Zn(), t = function() {
    return e.Date.now();
  };
  return q_ = t, q_;
}
var W_, gP;
function n_e() {
  if (gP)
    return W_;
  gP = 1;
  var e = Zg(), t = sb(), r = eb(), n = Mn(), o = Fc();
  function s(a, l, u, f) {
    if (!n(a))
      return a;
    l = t(l, a);
    for (var c = -1, d = l.length, h = d - 1, p = a; p != null && ++c < d; ) {
      var m = o(l[c]), y = u;
      if (m === "__proto__" || m === "constructor" || m === "prototype")
        return a;
      if (c != h) {
        var _ = p[m];
        y = f ? f(_, m, p) : void 0, y === void 0 && (y = n(_) ? _ : r(l[c + 1]) ? [] : {});
      }
      e(p, m, y), p = p[m];
    }
    return a;
  }
  return W_ = s, W_;
}
var U_, bP;
function i_e() {
  if (bP)
    return U_;
  bP = 1;
  var e = ab(), t = n_e(), r = sb();
  function n(o, s, a) {
    for (var l = -1, u = s.length, f = {}; ++l < u; ) {
      var c = s[l], d = e(o, c);
      a(d, c) && t(f, r(c, o), d);
    }
    return f;
  }
  return U_ = n, U_;
}
var H_, yP;
function o_e() {
  if (yP)
    return H_;
  yP = 1;
  var e = i_e(), t = g6();
  function r(n, o) {
    return e(n, o, function(s, a) {
      return t(n, a);
    });
  }
  return H_ = r, H_;
}
var z_, mP;
function s_e() {
  if (mP)
    return z_;
  mP = 1;
  var e = N6(), t = E6(), r = x6();
  function n(o) {
    return r(t(o, void 0, e), o + "");
  }
  return z_ = n, z_;
}
var G_, vP;
function a_e() {
  if (vP)
    return G_;
  vP = 1;
  var e = o_e(), t = s_e(), r = t(function(n, o) {
    return n == null ? {} : e(n, o);
  });
  return G_ = r, G_;
}
var V_, wP;
function l_e() {
  if (wP)
    return V_;
  wP = 1;
  var e = Math.ceil, t = Math.max;
  function r(n, o, s, a) {
    for (var l = -1, u = t(e((o - n) / (s || 1)), 0), f = Array(u); u--; )
      f[a ? u : ++l] = n, n += s;
    return f;
  }
  return V_ = r, V_;
}
var K_, _P;
function u_e() {
  if (_P)
    return K_;
  _P = 1;
  var e = l_e(), t = ub(), r = T7;
  function n(o) {
    return function(s, a, l) {
      return l && typeof l != "number" && t(s, a, l) && (a = l = void 0), s = r(s), a === void 0 ? (a = s, s = 0) : a = r(a), l = l === void 0 ? s < a ? 1 : -1 : r(l), e(s, a, l, o);
    };
  }
  return K_ = n, K_;
}
var Y_, SP;
function f_e() {
  if (SP)
    return Y_;
  SP = 1;
  var e = u_e(), t = e();
  return Y_ = t, Y_;
}
var X_, EP;
function c_e() {
  if (EP)
    return X_;
  EP = 1;
  function e(t, r) {
    var n = t.length;
    for (t.sort(r); n--; )
      t[n] = t[n].value;
    return t;
  }
  return X_ = e, X_;
}
var J_, xP;
function d_e() {
  if (xP)
    return J_;
  xP = 1;
  var e = bu();
  function t(r, n) {
    if (r !== n) {
      var o = r !== void 0, s = r === null, a = r === r, l = e(r), u = n !== void 0, f = n === null, c = n === n, d = e(n);
      if (!f && !d && !l && r > n || l && u && c && !f && !d || s && u && c || !o && c || !a)
        return 1;
      if (!s && !l && !d && r < n || d && o && a && !s && !l || f && o && a || !u && a || !c)
        return -1;
    }
    return 0;
  }
  return J_ = t, J_;
}
var Q_, RP;
function h_e() {
  if (RP)
    return Q_;
  RP = 1;
  var e = d_e();
  function t(r, n, o) {
    for (var s = -1, a = r.criteria, l = n.criteria, u = a.length, f = o.length; ++s < u; ) {
      var c = e(a[s], l[s]);
      if (c) {
        if (s >= f)
          return c;
        var d = o[s];
        return c * (d == "desc" ? -1 : 1);
      }
    }
    return r.index - n.index;
  }
  return Q_ = t, Q_;
}
var Z_, AP;
function p_e() {
  if (AP)
    return Z_;
  AP = 1;
  var e = ob(), t = ab(), r = ko(), n = w6(), o = c_e(), s = tb(), a = h_e(), l = al(), u = Yt();
  function f(c, d, h) {
    d.length ? d = e(d, function(y) {
      return u(y) ? function(_) {
        return t(_, y.length === 1 ? y[0] : y);
      } : y;
    }) : d = [l];
    var p = -1;
    d = e(d, s(r));
    var m = n(c, function(y, _, S) {
      var x = e(d, function(E) {
        return E(y);
      });
      return { criteria: x, index: ++p, value: y };
    });
    return o(m, function(y, _) {
      return a(y, _, h);
    });
  }
  return Z_ = f, Z_;
}
var e1, TP;
function g_e() {
  if (TP)
    return e1;
  TP = 1;
  var e = vA(), t = p_e(), r = lb(), n = ub(), o = r(function(s, a) {
    if (s == null)
      return [];
    var l = a.length;
    return l > 1 && n(s, a[0], a[1]) ? a = [] : l > 2 && n(a[0], a[1], a[2]) && (a = [a[0]]), t(s, e(a, 1), []);
  });
  return e1 = o, e1;
}
var t1, $P;
function b_e() {
  if ($P)
    return t1;
  $P = 1;
  var e = h6(), t = 0;
  function r(n) {
    var o = ++t;
    return e(n) + o;
  }
  return t1 = r, t1;
}
var r1, CP;
function y_e() {
  if (CP)
    return r1;
  CP = 1;
  function e(t, r, n) {
    for (var o = -1, s = t.length, a = r.length, l = {}; ++o < s; ) {
      var u = o < a ? r[o] : void 0;
      n(l, t[o], u);
    }
    return l;
  }
  return r1 = e, r1;
}
var n1, kP;
function m_e() {
  if (kP)
    return n1;
  kP = 1;
  var e = Zg(), t = y_e();
  function r(n, o) {
    return t(n || [], o || [], e);
  }
  return n1 = r, n1;
}
var Xh;
if (typeof iA == "function")
  try {
    Xh = {
      cloneDeep: Fwe(),
      constant: pA(),
      defaults: jwe(),
      each: s6(),
      filter: y6(),
      find: Wwe(),
      flatten: N6(),
      forEach: o6(),
      forIn: Uwe(),
      has: m6(),
      isUndefined: v6(),
      last: Hwe(),
      map: _6(),
      mapValues: zwe(),
      max: Vwe(),
      merge: Zwe(),
      min: e_e(),
      minBy: t_e(),
      now: r_e(),
      pick: a_e(),
      range: f_e(),
      reduce: S6(),
      sortBy: g_e(),
      uniqueId: b_e(),
      values: T6(),
      zipObject: m_e()
    };
  } catch {
  }
Xh || (Xh = window._);
var Ot = Xh, v_e = fb;
function fb() {
  var e = {};
  e._next = e._prev = e, this._sentinel = e;
}
fb.prototype.dequeue = function() {
  var e = this._sentinel, t = e._prev;
  if (t !== e)
    return D6(t), t;
};
fb.prototype.enqueue = function(e) {
  var t = this._sentinel;
  e._prev && e._next && D6(e), e._next = t._next, t._next._prev = e, t._next = e, e._prev = t;
};
fb.prototype.toString = function() {
  for (var e = [], t = this._sentinel, r = t._prev; r !== t; )
    e.push(JSON.stringify(r, w_e)), r = r._prev;
  return "[" + e.join(", ") + "]";
};
function D6(e) {
  e._prev._next = e._next, e._next._prev = e._prev, delete e._next, delete e._prev;
}
function w_e(e, t) {
  if (e !== "_next" && e !== "_prev")
    return t;
}
var eo = Ot, __e = oi.Graph, S_e = v_e, E_e = R_e, x_e = eo.constant(1);
function R_e(e, t) {
  if (e.nodeCount() <= 1)
    return [];
  var r = T_e(e, t || x_e), n = A_e(r.graph, r.buckets, r.zeroIdx);
  return eo.flatten(eo.map(n, function(o) {
    return e.outEdges(o.v, o.w);
  }), !0);
}
function A_e(e, t, r) {
  for (var n = [], o = t[t.length - 1], s = t[0], a; e.nodeCount(); ) {
    for (; a = s.dequeue(); )
      i1(e, t, r, a);
    for (; a = o.dequeue(); )
      i1(e, t, r, a);
    if (e.nodeCount()) {
      for (var l = t.length - 2; l > 0; --l)
        if (a = t[l].dequeue(), a) {
          n = n.concat(i1(e, t, r, a, !0));
          break;
        }
    }
  }
  return n;
}
function i1(e, t, r, n, o) {
  var s = o ? [] : void 0;
  return eo.forEach(e.inEdges(n.v), function(a) {
    var l = e.edge(a), u = e.node(a.v);
    o && s.push({ v: a.v, w: a.w }), u.out -= l, _E(t, r, u);
  }), eo.forEach(e.outEdges(n.v), function(a) {
    var l = e.edge(a), u = a.w, f = e.node(u);
    f.in -= l, _E(t, r, f);
  }), e.removeNode(n.v), s;
}
function T_e(e, t) {
  var r = new __e(), n = 0, o = 0;
  eo.forEach(e.nodes(), function(l) {
    r.setNode(l, { v: l, in: 0, out: 0 });
  }), eo.forEach(e.edges(), function(l) {
    var u = r.edge(l.v, l.w) || 0, f = t(l), c = u + f;
    r.setEdge(l.v, l.w, c), o = Math.max(o, r.node(l.v).out += f), n = Math.max(n, r.node(l.w).in += f);
  });
  var s = eo.range(o + n + 3).map(function() {
    return new S_e();
  }), a = n + 1;
  return eo.forEach(r.nodes(), function(l) {
    _E(s, a, r.node(l));
  }), { graph: r, buckets: s, zeroIdx: a };
}
function _E(e, t, r) {
  r.out ? r.in ? e[r.out - r.in + t].enqueue(r) : e[e.length - 1].enqueue(r) : e[0].enqueue(r);
}
var ra = Ot, $_e = E_e, C_e = {
  run: k_e,
  undo: M_e
};
function k_e(e) {
  var t = e.graph().acyclicer === "greedy" ? $_e(e, r(e)) : I_e(e);
  ra.forEach(t, function(n) {
    var o = e.edge(n);
    e.removeEdge(n), o.forwardName = n.name, o.reversed = !0, e.setEdge(n.w, n.v, o, ra.uniqueId("rev"));
  });
  function r(n) {
    return function(o) {
      return n.edge(o).weight;
    };
  }
}
function I_e(e) {
  var t = [], r = {}, n = {};
  function o(s) {
    ra.has(n, s) || (n[s] = !0, r[s] = !0, ra.forEach(e.outEdges(s), function(a) {
      ra.has(r, a.w) ? t.push(a) : o(a.w);
    }), delete r[s]);
  }
  return ra.forEach(e.nodes(), o), t;
}
function M_e(e) {
  ra.forEach(e.edges(), function(t) {
    var r = e.edge(t);
    if (r.reversed) {
      e.removeEdge(t);
      var n = r.forwardName;
      delete r.reversed, delete r.forwardName, e.setEdge(t.w, t.v, r, n);
    }
  });
}
var bt = Ot, F6 = oi.Graph, rn = {
  addDummyNode: j6,
  simplify: N_e,
  asNonCompoundGraph: L_e,
  successorWeights: O_e,
  predecessorWeights: P_e,
  intersectRect: D_e,
  buildLayerMatrix: F_e,
  normalizeRanks: j_e,
  removeEmptyRanks: B_e,
  addBorderNode: q_e,
  maxRank: B6,
  partition: W_e,
  time: U_e,
  notime: H_e
};
function j6(e, t, r, n) {
  var o;
  do
    o = bt.uniqueId(n);
  while (e.hasNode(o));
  return r.dummy = t, e.setNode(o, r), o;
}
function N_e(e) {
  var t = new F6().setGraph(e.graph());
  return bt.forEach(e.nodes(), function(r) {
    t.setNode(r, e.node(r));
  }), bt.forEach(e.edges(), function(r) {
    var n = t.edge(r.v, r.w) || { weight: 0, minlen: 1 }, o = e.edge(r);
    t.setEdge(r.v, r.w, {
      weight: n.weight + o.weight,
      minlen: Math.max(n.minlen, o.minlen)
    });
  }), t;
}
function L_e(e) {
  var t = new F6({ multigraph: e.isMultigraph() }).setGraph(e.graph());
  return bt.forEach(e.nodes(), function(r) {
    e.children(r).length || t.setNode(r, e.node(r));
  }), bt.forEach(e.edges(), function(r) {
    t.setEdge(r, e.edge(r));
  }), t;
}
function O_e(e) {
  var t = bt.map(e.nodes(), function(r) {
    var n = {};
    return bt.forEach(e.outEdges(r), function(o) {
      n[o.w] = (n[o.w] || 0) + e.edge(o).weight;
    }), n;
  });
  return bt.zipObject(e.nodes(), t);
}
function P_e(e) {
  var t = bt.map(e.nodes(), function(r) {
    var n = {};
    return bt.forEach(e.inEdges(r), function(o) {
      n[o.v] = (n[o.v] || 0) + e.edge(o).weight;
    }), n;
  });
  return bt.zipObject(e.nodes(), t);
}
function D_e(e, t) {
  var r = e.x, n = e.y, o = t.x - r, s = t.y - n, a = e.width / 2, l = e.height / 2;
  if (!o && !s)
    throw new Error("Not possible to find intersection inside of the rectangle");
  var u, f;
  return Math.abs(s) * a > Math.abs(o) * l ? (s < 0 && (l = -l), u = l * o / s, f = l) : (o < 0 && (a = -a), u = a, f = a * s / o), { x: r + u, y: n + f };
}
function F_e(e) {
  var t = bt.map(bt.range(B6(e) + 1), function() {
    return [];
  });
  return bt.forEach(e.nodes(), function(r) {
    var n = e.node(r), o = n.rank;
    bt.isUndefined(o) || (t[o][n.order] = r);
  }), t;
}
function j_e(e) {
  var t = bt.min(bt.map(e.nodes(), function(r) {
    return e.node(r).rank;
  }));
  bt.forEach(e.nodes(), function(r) {
    var n = e.node(r);
    bt.has(n, "rank") && (n.rank -= t);
  });
}
function B_e(e) {
  var t = bt.min(bt.map(e.nodes(), function(s) {
    return e.node(s).rank;
  })), r = [];
  bt.forEach(e.nodes(), function(s) {
    var a = e.node(s).rank - t;
    r[a] || (r[a] = []), r[a].push(s);
  });
  var n = 0, o = e.graph().nodeRankFactor;
  bt.forEach(r, function(s, a) {
    bt.isUndefined(s) && a % o !== 0 ? --n : n && bt.forEach(s, function(l) {
      e.node(l).rank += n;
    });
  });
}
function q_e(e, t, r, n) {
  var o = {
    width: 0,
    height: 0
  };
  return arguments.length >= 4 && (o.rank = r, o.order = n), j6(e, "border", o, t);
}
function B6(e) {
  return bt.max(bt.map(e.nodes(), function(t) {
    var r = e.node(t).rank;
    if (!bt.isUndefined(r))
      return r;
  }));
}
function W_e(e, t) {
  var r = { lhs: [], rhs: [] };
  return bt.forEach(e, function(n) {
    t(n) ? r.lhs.push(n) : r.rhs.push(n);
  }), r;
}
function U_e(e, t) {
  var r = bt.now();
  try {
    return t();
  } finally {
    console.log(e + " time: " + (bt.now() - r) + "ms");
  }
}
function H_e(e, t) {
  return t();
}
var q6 = Ot, z_e = rn, G_e = {
  run: V_e,
  undo: Y_e
};
function V_e(e) {
  e.graph().dummyChains = [], q6.forEach(e.edges(), function(t) {
    K_e(e, t);
  });
}
function K_e(e, t) {
  var r = t.v, n = e.node(r).rank, o = t.w, s = e.node(o).rank, a = t.name, l = e.edge(t), u = l.labelRank;
  if (s !== n + 1) {
    e.removeEdge(t);
    var f, c, d;
    for (d = 0, ++n; n < s; ++d, ++n)
      l.points = [], c = {
        width: 0,
        height: 0,
        edgeLabel: l,
        edgeObj: t,
        rank: n
      }, f = z_e.addDummyNode(e, "edge", c, "_d"), n === u && (c.width = l.width, c.height = l.height, c.dummy = "edge-label", c.labelpos = l.labelpos), e.setEdge(r, f, { weight: l.weight }, a), d === 0 && e.graph().dummyChains.push(f), r = f;
    e.setEdge(r, o, { weight: l.weight }, a);
  }
}
function Y_e(e) {
  q6.forEach(e.graph().dummyChains, function(t) {
    var r = e.node(t), n = r.edgeLabel, o;
    for (e.setEdge(r.edgeObj, n); r.dummy; )
      o = e.successors(t)[0], e.removeNode(t), n.points.push({ x: r.x, y: r.y }), r.dummy === "edge-label" && (n.x = r.x, n.y = r.y, n.width = r.width, n.height = r.height), t = o, r = e.node(t);
  });
}
var Cd = Ot, cb = {
  longestPath: X_e,
  slack: J_e
};
function X_e(e) {
  var t = {};
  function r(n) {
    var o = e.node(n);
    if (Cd.has(t, n))
      return o.rank;
    t[n] = !0;
    var s = Cd.min(Cd.map(e.outEdges(n), function(a) {
      return r(a.w) - e.edge(a).minlen;
    }));
    return (s === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3
    s === void 0 || // return value of _.map([]) for Lodash 4
    s === null) && (s = 0), o.rank = s;
  }
  Cd.forEach(e.sources(), r);
}
function J_e(e, t) {
  return e.node(t.w).rank - e.node(t.v).rank - e.edge(t).minlen;
}
var Jh = Ot, Q_e = oi.Graph, Qh = cb.slack, W6 = Z_e;
function Z_e(e) {
  var t = new Q_e({ directed: !1 }), r = e.nodes()[0], n = e.nodeCount();
  t.setNode(r, {});
  for (var o, s; e1e(t, e) < n; )
    o = t1e(t, e), s = t.hasNode(o.v) ? Qh(e, o) : -Qh(e, o), r1e(t, e, s);
  return t;
}
function e1e(e, t) {
  function r(n) {
    Jh.forEach(t.nodeEdges(n), function(o) {
      var s = o.v, a = n === s ? o.w : s;
      !e.hasNode(a) && !Qh(t, o) && (e.setNode(a, {}), e.setEdge(n, a, {}), r(a));
    });
  }
  return Jh.forEach(e.nodes(), r), e.nodeCount();
}
function t1e(e, t) {
  return Jh.minBy(t.edges(), function(r) {
    if (e.hasNode(r.v) !== e.hasNode(r.w))
      return Qh(t, r);
  });
}
function r1e(e, t, r) {
  Jh.forEach(e.nodes(), function(n) {
    t.node(n).rank += r;
  });
}
var _o = Ot, n1e = W6, i1e = cb.slack, o1e = cb.longestPath, s1e = oi.alg.preorder, a1e = oi.alg.postorder, l1e = rn.simplify, u1e = ll;
ll.initLowLimValues = EA;
ll.initCutValues = SA;
ll.calcCutValue = U6;
ll.leaveEdge = z6;
ll.enterEdge = G6;
ll.exchangeEdges = V6;
function ll(e) {
  e = l1e(e), o1e(e);
  var t = n1e(e);
  EA(t), SA(t, e);
  for (var r, n; r = z6(t); )
    n = G6(t, e, r), V6(t, e, r, n);
}
function SA(e, t) {
  var r = a1e(e, e.nodes());
  r = r.slice(0, r.length - 1), _o.forEach(r, function(n) {
    f1e(e, t, n);
  });
}
function f1e(e, t, r) {
  var n = e.node(r), o = n.parent;
  e.edge(r, o).cutvalue = U6(e, t, r);
}
function U6(e, t, r) {
  var n = e.node(r), o = n.parent, s = !0, a = t.edge(r, o), l = 0;
  return a || (s = !1, a = t.edge(o, r)), l = a.weight, _o.forEach(t.nodeEdges(r), function(u) {
    var f = u.v === r, c = f ? u.w : u.v;
    if (c !== o) {
      var d = f === s, h = t.edge(u).weight;
      if (l += d ? h : -h, d1e(e, r, c)) {
        var p = e.edge(r, c).cutvalue;
        l += d ? -p : p;
      }
    }
  }), l;
}
function EA(e, t) {
  arguments.length < 2 && (t = e.nodes()[0]), H6(e, {}, 1, t);
}
function H6(e, t, r, n, o) {
  var s = r, a = e.node(n);
  return t[n] = !0, _o.forEach(e.neighbors(n), function(l) {
    _o.has(t, l) || (r = H6(e, t, r, l, n));
  }), a.low = s, a.lim = r++, o ? a.parent = o : delete a.parent, r;
}
function z6(e) {
  return _o.find(e.edges(), function(t) {
    return e.edge(t).cutvalue < 0;
  });
}
function G6(e, t, r) {
  var n = r.v, o = r.w;
  t.hasEdge(n, o) || (n = r.w, o = r.v);
  var s = e.node(n), a = e.node(o), l = s, u = !1;
  s.lim > a.lim && (l = a, u = !0);
  var f = _o.filter(t.edges(), function(c) {
    return u === IP(e, e.node(c.v), l) && u !== IP(e, e.node(c.w), l);
  });
  return _o.minBy(f, function(c) {
    return i1e(t, c);
  });
}
function V6(e, t, r, n) {
  var o = r.v, s = r.w;
  e.removeEdge(o, s), e.setEdge(n.v, n.w, {}), EA(e), SA(e, t), c1e(e, t);
}
function c1e(e, t) {
  var r = _o.find(e.nodes(), function(o) {
    return !t.node(o).parent;
  }), n = s1e(e, r);
  n = n.slice(1), _o.forEach(n, function(o) {
    var s = e.node(o).parent, a = t.edge(o, s), l = !1;
    a || (a = t.edge(s, o), l = !0), t.node(o).rank = t.node(s).rank + (l ? a.minlen : -a.minlen);
  });
}
function d1e(e, t, r) {
  return e.hasEdge(t, r);
}
function IP(e, t, r) {
  return r.low <= t.lim && t.lim <= r.lim;
}
var h1e = cb, K6 = h1e.longestPath, p1e = W6, g1e = u1e, b1e = y1e;
function y1e(e) {
  switch (e.graph().ranker) {
    case "network-simplex":
      MP(e);
      break;
    case "tight-tree":
      v1e(e);
      break;
    case "longest-path":
      m1e(e);
      break;
    default:
      MP(e);
  }
}
var m1e = K6;
function v1e(e) {
  K6(e), p1e(e);
}
function MP(e) {
  g1e(e);
}
var SE = Ot, w1e = _1e;
function _1e(e) {
  var t = E1e(e);
  SE.forEach(e.graph().dummyChains, function(r) {
    for (var n = e.node(r), o = n.edgeObj, s = S1e(e, t, o.v, o.w), a = s.path, l = s.lca, u = 0, f = a[u], c = !0; r !== o.w; ) {
      if (n = e.node(r), c) {
        for (; (f = a[u]) !== l && e.node(f).maxRank < n.rank; )
          u++;
        f === l && (c = !1);
      }
      if (!c) {
        for (; u < a.length - 1 && e.node(f = a[u + 1]).minRank <= n.rank; )
          u++;
        f = a[u];
      }
      e.setParent(r, f), r = e.successors(r)[0];
    }
  });
}
function S1e(e, t, r, n) {
  var o = [], s = [], a = Math.min(t[r].low, t[n].low), l = Math.max(t[r].lim, t[n].lim), u, f;
  u = r;
  do
    u = e.parent(u), o.push(u);
  while (u && (t[u].low > a || l > t[u].lim));
  for (f = u, u = n; (u = e.parent(u)) !== f; )
    s.push(u);
  return { path: o.concat(s.reverse()), lca: f };
}
function E1e(e) {
  var t = {}, r = 0;
  function n(o) {
    var s = r;
    SE.forEach(e.children(o), n), t[o] = { low: s, lim: r++ };
  }
  return SE.forEach(e.children(), n), t;
}
var to = Ot, EE = rn, x1e = {
  run: R1e,
  cleanup: $1e
};
function R1e(e) {
  var t = EE.addDummyNode(e, "root", {}, "_root"), r = A1e(e), n = to.max(to.values(r)) - 1, o = 2 * n + 1;
  e.graph().nestingRoot = t, to.forEach(e.edges(), function(a) {
    e.edge(a).minlen *= o;
  });
  var s = T1e(e) + 1;
  to.forEach(e.children(), function(a) {
    Y6(e, t, o, s, n, r, a);
  }), e.graph().nodeRankFactor = o;
}
function Y6(e, t, r, n, o, s, a) {
  var l = e.children(a);
  if (!l.length) {
    a !== t && e.setEdge(t, a, { weight: 0, minlen: r });
    return;
  }
  var u = EE.addBorderNode(e, "_bt"), f = EE.addBorderNode(e, "_bb"), c = e.node(a);
  e.setParent(u, a), c.borderTop = u, e.setParent(f, a), c.borderBottom = f, to.forEach(l, function(d) {
    Y6(e, t, r, n, o, s, d);
    var h = e.node(d), p = h.borderTop ? h.borderTop : d, m = h.borderBottom ? h.borderBottom : d, y = h.borderTop ? n : 2 * n, _ = p !== m ? 1 : o - s[a] + 1;
    e.setEdge(u, p, {
      weight: y,
      minlen: _,
      nestingEdge: !0
    }), e.setEdge(m, f, {
      weight: y,
      minlen: _,
      nestingEdge: !0
    });
  }), e.parent(a) || e.setEdge(t, u, { weight: 0, minlen: o + s[a] });
}
function A1e(e) {
  var t = {};
  function r(n, o) {
    var s = e.children(n);
    s && s.length && to.forEach(s, function(a) {
      r(a, o + 1);
    }), t[n] = o;
  }
  return to.forEach(e.children(), function(n) {
    r(n, 1);
  }), t;
}
function T1e(e) {
  return to.reduce(e.edges(), function(t, r) {
    return t + e.edge(r).weight;
  }, 0);
}
function $1e(e) {
  var t = e.graph();
  e.removeNode(t.nestingRoot), delete t.nestingRoot, to.forEach(e.edges(), function(r) {
    var n = e.edge(r);
    n.nestingEdge && e.removeEdge(r);
  });
}
var o1 = Ot, C1e = rn, k1e = I1e;
function I1e(e) {
  function t(r) {
    var n = e.children(r), o = e.node(r);
    if (n.length && o1.forEach(n, t), o1.has(o, "minRank")) {
      o.borderLeft = [], o.borderRight = [];
      for (var s = o.minRank, a = o.maxRank + 1; s < a; ++s)
        NP(e, "borderLeft", "_bl", r, o, s), NP(e, "borderRight", "_br", r, o, s);
    }
  }
  o1.forEach(e.children(), t);
}
function NP(e, t, r, n, o, s) {
  var a = { width: 0, height: 0, rank: s, borderType: t }, l = o[t][s - 1], u = C1e.addDummyNode(e, "border", a, r);
  o[t][s] = u, e.setParent(u, n), l && e.setEdge(l, u, { weight: 1 });
}
var yi = Ot, M1e = {
  adjust: N1e,
  undo: L1e
};
function N1e(e) {
  var t = e.graph().rankdir.toLowerCase();
  (t === "lr" || t === "rl") && X6(e);
}
function L1e(e) {
  var t = e.graph().rankdir.toLowerCase();
  (t === "bt" || t === "rl") && O1e(e), (t === "lr" || t === "rl") && (P1e(e), X6(e));
}
function X6(e) {
  yi.forEach(e.nodes(), function(t) {
    LP(e.node(t));
  }), yi.forEach(e.edges(), function(t) {
    LP(e.edge(t));
  });
}
function LP(e) {
  var t = e.width;
  e.width = e.height, e.height = t;
}
function O1e(e) {
  yi.forEach(e.nodes(), function(t) {
    s1(e.node(t));
  }), yi.forEach(e.edges(), function(t) {
    var r = e.edge(t);
    yi.forEach(r.points, s1), yi.has(r, "y") && s1(r);
  });
}
function s1(e) {
  e.y = -e.y;
}
function P1e(e) {
  yi.forEach(e.nodes(), function(t) {
    a1(e.node(t));
  }), yi.forEach(e.edges(), function(t) {
    var r = e.edge(t);
    yi.forEach(r.points, a1), yi.has(r, "x") && a1(r);
  });
}
function a1(e) {
  var t = e.x;
  e.x = e.y, e.y = t;
}
var Vi = Ot, D1e = F1e;
function F1e(e) {
  var t = {}, r = Vi.filter(e.nodes(), function(l) {
    return !e.children(l).length;
  }), n = Vi.max(Vi.map(r, function(l) {
    return e.node(l).rank;
  })), o = Vi.map(Vi.range(n + 1), function() {
    return [];
  });
  function s(l) {
    if (!Vi.has(t, l)) {
      t[l] = !0;
      var u = e.node(l);
      o[u.rank].push(l), Vi.forEach(e.successors(l), s);
    }
  }
  var a = Vi.sortBy(r, function(l) {
    return e.node(l).rank;
  });
  return Vi.forEach(a, s), o;
}
var Oo = Ot, j1e = B1e;
function B1e(e, t) {
  for (var r = 0, n = 1; n < t.length; ++n)
    r += q1e(e, t[n - 1], t[n]);
  return r;
}
function q1e(e, t, r) {
  for (var n = Oo.zipObject(
    r,
    Oo.map(r, function(f, c) {
      return c;
    })
  ), o = Oo.flatten(Oo.map(t, function(f) {
    return Oo.sortBy(Oo.map(e.outEdges(f), function(c) {
      return { pos: n[c.w], weight: e.edge(c).weight };
    }), "pos");
  }), !0), s = 1; s < r.length; )
    s <<= 1;
  var a = 2 * s - 1;
  s -= 1;
  var l = Oo.map(new Array(a), function() {
    return 0;
  }), u = 0;
  return Oo.forEach(o.forEach(function(f) {
    var c = f.pos + s;
    l[c] += f.weight;
    for (var d = 0; c > 0; )
      c % 2 && (d += l[c + 1]), c = c - 1 >> 1, l[c] += f.weight;
    u += f.weight * d;
  })), u;
}
var OP = Ot, W1e = U1e;
function U1e(e, t) {
  return OP.map(t, function(r) {
    var n = e.inEdges(r);
    if (n.length) {
      var o = OP.reduce(n, function(s, a) {
        var l = e.edge(a), u = e.node(a.v);
        return {
          sum: s.sum + l.weight * u.order,
          weight: s.weight + l.weight
        };
      }, { sum: 0, weight: 0 });
      return {
        v: r,
        barycenter: o.sum / o.weight,
        weight: o.weight
      };
    } else
      return { v: r };
  });
}
var fn = Ot, H1e = z1e;
function z1e(e, t) {
  var r = {};
  fn.forEach(e, function(o, s) {
    var a = r[o.v] = {
      indegree: 0,
      in: [],
      out: [],
      vs: [o.v],
      i: s
    };
    fn.isUndefined(o.barycenter) || (a.barycenter = o.barycenter, a.weight = o.weight);
  }), fn.forEach(t.edges(), function(o) {
    var s = r[o.v], a = r[o.w];
    !fn.isUndefined(s) && !fn.isUndefined(a) && (a.indegree++, s.out.push(r[o.w]));
  });
  var n = fn.filter(r, function(o) {
    return !o.indegree;
  });
  return G1e(n);
}
function G1e(e) {
  var t = [];
  function r(s) {
    return function(a) {
      a.merged || (fn.isUndefined(a.barycenter) || fn.isUndefined(s.barycenter) || a.barycenter >= s.barycenter) && V1e(s, a);
    };
  }
  function n(s) {
    return function(a) {
      a.in.push(s), --a.indegree === 0 && e.push(a);
    };
  }
  for (; e.length; ) {
    var o = e.pop();
    t.push(o), fn.forEach(o.in.reverse(), r(o)), fn.forEach(o.out, n(o));
  }
  return fn.map(
    fn.filter(t, function(s) {
      return !s.merged;
    }),
    function(s) {
      return fn.pick(s, ["vs", "i", "barycenter", "weight"]);
    }
  );
}
function V1e(e, t) {
  var r = 0, n = 0;
  e.weight && (r += e.barycenter * e.weight, n += e.weight), t.weight && (r += t.barycenter * t.weight, n += t.weight), e.vs = t.vs.concat(e.vs), e.barycenter = r / n, e.weight = n, e.i = Math.min(t.i, e.i), t.merged = !0;
}
var ff = Ot, K1e = rn, Y1e = X1e;
function X1e(e, t) {
  var r = K1e.partition(e, function(c) {
    return ff.has(c, "barycenter");
  }), n = r.lhs, o = ff.sortBy(r.rhs, function(c) {
    return -c.i;
  }), s = [], a = 0, l = 0, u = 0;
  n.sort(J1e(!!t)), u = PP(s, o, u), ff.forEach(n, function(c) {
    u += c.vs.length, s.push(c.vs), a += c.barycenter * c.weight, l += c.weight, u = PP(s, o, u);
  });
  var f = { vs: ff.flatten(s, !0) };
  return l && (f.barycenter = a / l, f.weight = l), f;
}
function PP(e, t, r) {
  for (var n; t.length && (n = ff.last(t)).i <= r; )
    t.pop(), e.push(n.vs), r++;
  return r;
}
function J1e(e) {
  return function(t, r) {
    return t.barycenter < r.barycenter ? -1 : t.barycenter > r.barycenter ? 1 : e ? r.i - t.i : t.i - r.i;
  };
}
var Ko = Ot, Q1e = W1e, Z1e = H1e, eSe = Y1e, tSe = J6;
function J6(e, t, r, n) {
  var o = e.children(t), s = e.node(t), a = s ? s.borderLeft : void 0, l = s ? s.borderRight : void 0, u = {};
  a && (o = Ko.filter(o, function(m) {
    return m !== a && m !== l;
  }));
  var f = Q1e(e, o);
  Ko.forEach(f, function(m) {
    if (e.children(m.v).length) {
      var y = J6(e, m.v, r, n);
      u[m.v] = y, Ko.has(y, "barycenter") && nSe(m, y);
    }
  });
  var c = Z1e(f, r);
  rSe(c, u);
  var d = eSe(c, n);
  if (a && (d.vs = Ko.flatten([a, d.vs, l], !0), e.predecessors(a).length)) {
    var h = e.node(e.predecessors(a)[0]), p = e.node(e.predecessors(l)[0]);
    Ko.has(d, "barycenter") || (d.barycenter = 0, d.weight = 0), d.barycenter = (d.barycenter * d.weight + h.order + p.order) / (d.weight + 2), d.weight += 2;
  }
  return d;
}
function rSe(e, t) {
  Ko.forEach(e, function(r) {
    r.vs = Ko.flatten(r.vs.map(function(n) {
      return t[n] ? t[n].vs : n;
    }), !0);
  });
}
function nSe(e, t) {
  Ko.isUndefined(e.barycenter) ? (e.barycenter = t.barycenter, e.weight = t.weight) : (e.barycenter = (e.barycenter * e.weight + t.barycenter * t.weight) / (e.weight + t.weight), e.weight += t.weight);
}
var cf = Ot, iSe = oi.Graph, oSe = sSe;
function sSe(e, t, r) {
  var n = aSe(e), o = new iSe({ compound: !0 }).setGraph({ root: n }).setDefaultNodeLabel(function(s) {
    return e.node(s);
  });
  return cf.forEach(e.nodes(), function(s) {
    var a = e.node(s), l = e.parent(s);
    (a.rank === t || a.minRank <= t && t <= a.maxRank) && (o.setNode(s), o.setParent(s, l || n), cf.forEach(e[r](s), function(u) {
      var f = u.v === s ? u.w : u.v, c = o.edge(f, s), d = cf.isUndefined(c) ? 0 : c.weight;
      o.setEdge(f, s, { weight: e.edge(u).weight + d });
    }), cf.has(a, "minRank") && o.setNode(s, {
      borderLeft: a.borderLeft[t],
      borderRight: a.borderRight[t]
    }));
  }), o;
}
function aSe(e) {
  for (var t; e.hasNode(t = cf.uniqueId("_root")); )
    ;
  return t;
}
var lSe = Ot, uSe = fSe;
function fSe(e, t, r) {
  var n = {}, o;
  lSe.forEach(r, function(s) {
    for (var a = e.parent(s), l, u; a; ) {
      if (l = e.parent(a), l ? (u = n[l], n[l] = a) : (u = o, o = a), u && u !== a) {
        t.setEdge(u, a);
        return;
      }
      a = l;
    }
  });
}
var ns = Ot, cSe = D1e, dSe = j1e, hSe = tSe, pSe = oSe, gSe = uSe, bSe = oi.Graph, DP = rn, ySe = mSe;
function mSe(e) {
  var t = DP.maxRank(e), r = FP(e, ns.range(1, t + 1), "inEdges"), n = FP(e, ns.range(t - 1, -1, -1), "outEdges"), o = cSe(e);
  jP(e, o);
  for (var s = Number.POSITIVE_INFINITY, a, l = 0, u = 0; u < 4; ++l, ++u) {
    vSe(l % 2 ? r : n, l % 4 >= 2), o = DP.buildLayerMatrix(e);
    var f = dSe(e, o);
    f < s && (u = 0, a = ns.cloneDeep(o), s = f);
  }
  jP(e, a);
}
function FP(e, t, r) {
  return ns.map(t, function(n) {
    return pSe(e, n, r);
  });
}
function vSe(e, t) {
  var r = new bSe();
  ns.forEach(e, function(n) {
    var o = n.graph().root, s = hSe(n, o, r, t);
    ns.forEach(s.vs, function(a, l) {
      n.node(a).order = l;
    }), gSe(n, r, s.vs);
  });
}
function jP(e, t) {
  ns.forEach(t, function(r) {
    ns.forEach(r, function(n, o) {
      e.node(n).order = o;
    });
  });
}
var et = Ot, wSe = oi.Graph, _Se = rn, SSe = {
  positionX: RSe,
  findType1Conflicts: Q6,
  findType2Conflicts: Z6,
  addConflict: xA,
  hasConflict: eW,
  verticalAlignment: tW,
  horizontalCompaction: rW,
  alignCoordinates: iW,
  findSmallestWidthAlignment: nW,
  balance: oW
};
function Q6(e, t) {
  var r = {};
  function n(o, s) {
    var a = 0, l = 0, u = o.length, f = et.last(s);
    return et.forEach(s, function(c, d) {
      var h = ESe(e, c), p = h ? e.node(h).order : u;
      (h || c === f) && (et.forEach(s.slice(l, d + 1), function(m) {
        et.forEach(e.predecessors(m), function(y) {
          var _ = e.node(y), S = _.order;
          (S < a || p < S) && !(_.dummy && e.node(m).dummy) && xA(r, y, m);
        });
      }), l = d + 1, a = p);
    }), s;
  }
  return et.reduce(t, n), r;
}
function Z6(e, t) {
  var r = {};
  function n(s, a, l, u, f) {
    var c;
    et.forEach(et.range(a, l), function(d) {
      c = s[d], e.node(c).dummy && et.forEach(e.predecessors(c), function(h) {
        var p = e.node(h);
        p.dummy && (p.order < u || p.order > f) && xA(r, h, c);
      });
    });
  }
  function o(s, a) {
    var l = -1, u, f = 0;
    return et.forEach(a, function(c, d) {
      if (e.node(c).dummy === "border") {
        var h = e.predecessors(c);
        h.length && (u = e.node(h[0]).order, n(a, f, d, l, u), f = d, l = u);
      }
      n(a, f, a.length, u, s.length);
    }), a;
  }
  return et.reduce(t, o), r;
}
function ESe(e, t) {
  if (e.node(t).dummy)
    return et.find(e.predecessors(t), function(r) {
      return e.node(r).dummy;
    });
}
function xA(e, t, r) {
  if (t > r) {
    var n = t;
    t = r, r = n;
  }
  var o = e[t];
  o || (e[t] = o = {}), o[r] = !0;
}
function eW(e, t, r) {
  if (t > r) {
    var n = t;
    t = r, r = n;
  }
  return et.has(e[t], r);
}
function tW(e, t, r, n) {
  var o = {}, s = {}, a = {};
  return et.forEach(t, function(l) {
    et.forEach(l, function(u, f) {
      o[u] = u, s[u] = u, a[u] = f;
    });
  }), et.forEach(t, function(l) {
    var u = -1;
    et.forEach(l, function(f) {
      var c = n(f);
      if (c.length) {
        c = et.sortBy(c, function(y) {
          return a[y];
        });
        for (var d = (c.length - 1) / 2, h = Math.floor(d), p = Math.ceil(d); h <= p; ++h) {
          var m = c[h];
          s[f] === f && u < a[m] && !eW(r, f, m) && (s[m] = f, s[f] = o[f] = o[m], u = a[m]);
        }
      }
    });
  }), { root: o, align: s };
}
function rW(e, t, r, n, o) {
  var s = {}, a = xSe(e, t, r, o), l = o ? "borderLeft" : "borderRight";
  function u(d, h) {
    for (var p = a.nodes(), m = p.pop(), y = {}; m; )
      y[m] ? d(m) : (y[m] = !0, p.push(m), p = p.concat(h(m))), m = p.pop();
  }
  function f(d) {
    s[d] = a.inEdges(d).reduce(function(h, p) {
      return Math.max(h, s[p.v] + a.edge(p));
    }, 0);
  }
  function c(d) {
    var h = a.outEdges(d).reduce(function(m, y) {
      return Math.min(m, s[y.w] - a.edge(y));
    }, Number.POSITIVE_INFINITY), p = e.node(d);
    h !== Number.POSITIVE_INFINITY && p.borderType !== l && (s[d] = Math.max(s[d], h));
  }
  return u(f, a.predecessors.bind(a)), u(c, a.successors.bind(a)), et.forEach(n, function(d) {
    s[d] = s[r[d]];
  }), s;
}
function xSe(e, t, r, n) {
  var o = new wSe(), s = e.graph(), a = ASe(s.nodesep, s.edgesep, n);
  return et.forEach(t, function(l) {
    var u;
    et.forEach(l, function(f) {
      var c = r[f];
      if (o.setNode(c), u) {
        var d = r[u], h = o.edge(d, c);
        o.setEdge(d, c, Math.max(a(e, f, u), h || 0));
      }
      u = f;
    });
  }), o;
}
function nW(e, t) {
  return et.minBy(et.values(t), function(r) {
    var n = Number.NEGATIVE_INFINITY, o = Number.POSITIVE_INFINITY;
    return et.forIn(r, function(s, a) {
      var l = TSe(e, a) / 2;
      n = Math.max(s + l, n), o = Math.min(s - l, o);
    }), n - o;
  });
}
function iW(e, t) {
  var r = et.values(t), n = et.min(r), o = et.max(r);
  et.forEach(["u", "d"], function(s) {
    et.forEach(["l", "r"], function(a) {
      var l = s + a, u = e[l], f;
      if (u !== t) {
        var c = et.values(u);
        f = a === "l" ? n - et.min(c) : o - et.max(c), f && (e[l] = et.mapValues(u, function(d) {
          return d + f;
        }));
      }
    });
  });
}
function oW(e, t) {
  return et.mapValues(e.ul, function(r, n) {
    if (t)
      return e[t.toLowerCase()][n];
    var o = et.sortBy(et.map(e, n));
    return (o[1] + o[2]) / 2;
  });
}
function RSe(e) {
  var t = _Se.buildLayerMatrix(e), r = et.merge(
    Q6(e, t),
    Z6(e, t)
  ), n = {}, o;
  et.forEach(["u", "d"], function(a) {
    o = a === "u" ? t : et.values(t).reverse(), et.forEach(["l", "r"], function(l) {
      l === "r" && (o = et.map(o, function(d) {
        return et.values(d).reverse();
      }));
      var u = (a === "u" ? e.predecessors : e.successors).bind(e), f = tW(e, o, r, u), c = rW(
        e,
        o,
        f.root,
        f.align,
        l === "r"
      );
      l === "r" && (c = et.mapValues(c, function(d) {
        return -d;
      })), n[a + l] = c;
    });
  });
  var s = nW(e, n);
  return iW(n, s), oW(n, e.graph().align);
}
function ASe(e, t, r) {
  return function(n, o, s) {
    var a = n.node(o), l = n.node(s), u = 0, f;
    if (u += a.width / 2, et.has(a, "labelpos"))
      switch (a.labelpos.toLowerCase()) {
        case "l":
          f = -a.width / 2;
          break;
        case "r":
          f = a.width / 2;
          break;
      }
    if (f && (u += r ? f : -f), f = 0, u += (a.dummy ? t : e) / 2, u += (l.dummy ? t : e) / 2, u += l.width / 2, et.has(l, "labelpos"))
      switch (l.labelpos.toLowerCase()) {
        case "l":
          f = l.width / 2;
          break;
        case "r":
          f = -l.width / 2;
          break;
      }
    return f && (u += r ? f : -f), f = 0, u;
  };
}
function TSe(e, t) {
  return e.node(t).width;
}
var df = Ot, sW = rn, $Se = SSe.positionX, CSe = kSe;
function kSe(e) {
  e = sW.asNonCompoundGraph(e), ISe(e), df.forEach($Se(e), function(t, r) {
    e.node(r).x = t;
  });
}
function ISe(e) {
  var t = sW.buildLayerMatrix(e), r = e.graph().ranksep, n = 0;
  df.forEach(t, function(o) {
    var s = df.max(df.map(o, function(a) {
      return e.node(a).height;
    }));
    df.forEach(o, function(a) {
      e.node(a).y = n + s / 2;
    }), n += s + r;
  });
}
var ot = Ot, BP = C_e, qP = G_e, MSe = b1e, NSe = rn.normalizeRanks, LSe = w1e, OSe = rn.removeEmptyRanks, WP = x1e, PSe = k1e, UP = M1e, DSe = ySe, FSe = CSe, gs = rn, jSe = oi.Graph, BSe = qSe;
function qSe(e, t) {
  var r = t && t.debugTiming ? gs.time : gs.notime;
  r("layout", function() {
    var n = r("  buildLayoutGraph", function() {
      return QSe(e);
    });
    r("  runLayout", function() {
      WSe(n, r);
    }), r("  updateInputGraph", function() {
      USe(e, n);
    });
  });
}
function WSe(e, t) {
  t("    makeSpaceForEdgeLabels", function() {
    ZSe(e);
  }), t("    removeSelfEdges", function() {
    lEe(e);
  }), t("    acyclic", function() {
    BP.run(e);
  }), t("    nestingGraph.run", function() {
    WP.run(e);
  }), t("    rank", function() {
    MSe(gs.asNonCompoundGraph(e));
  }), t("    injectEdgeLabelProxies", function() {
    eEe(e);
  }), t("    removeEmptyRanks", function() {
    OSe(e);
  }), t("    nestingGraph.cleanup", function() {
    WP.cleanup(e);
  }), t("    normalizeRanks", function() {
    NSe(e);
  }), t("    assignRankMinMax", function() {
    tEe(e);
  }), t("    removeEdgeLabelProxies", function() {
    rEe(e);
  }), t("    normalize.run", function() {
    qP.run(e);
  }), t("    parentDummyChains", function() {
    LSe(e);
  }), t("    addBorderSegments", function() {
    PSe(e);
  }), t("    order", function() {
    DSe(e);
  }), t("    insertSelfEdges", function() {
    uEe(e);
  }), t("    adjustCoordinateSystem", function() {
    UP.adjust(e);
  }), t("    position", function() {
    FSe(e);
  }), t("    positionSelfEdges", function() {
    fEe(e);
  }), t("    removeBorderNodes", function() {
    aEe(e);
  }), t("    normalize.undo", function() {
    qP.undo(e);
  }), t("    fixupEdgeLabelCoords", function() {
    oEe(e);
  }), t("    undoCoordinateSystem", function() {
    UP.undo(e);
  }), t("    translateGraph", function() {
    nEe(e);
  }), t("    assignNodeIntersects", function() {
    iEe(e);
  }), t("    reversePoints", function() {
    sEe(e);
  }), t("    acyclic.undo", function() {
    BP.undo(e);
  });
}
function USe(e, t) {
  ot.forEach(e.nodes(), function(r) {
    var n = e.node(r), o = t.node(r);
    n && (n.x = o.x, n.y = o.y, t.children(r).length && (n.width = o.width, n.height = o.height));
  }), ot.forEach(e.edges(), function(r) {
    var n = e.edge(r), o = t.edge(r);
    n.points = o.points, ot.has(o, "x") && (n.x = o.x, n.y = o.y);
  }), e.graph().width = t.graph().width, e.graph().height = t.graph().height;
}
var HSe = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"], zSe = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" }, GSe = ["acyclicer", "ranker", "rankdir", "align"], VSe = ["width", "height"], KSe = { width: 0, height: 0 }, YSe = ["minlen", "weight", "width", "height", "labeloffset"], XSe = {
  minlen: 1,
  weight: 1,
  width: 0,
  height: 0,
  labeloffset: 10,
  labelpos: "r"
}, JSe = ["labelpos"];
function QSe(e) {
  var t = new jSe({ multigraph: !0, compound: !0 }), r = u1(e.graph());
  return t.setGraph(ot.merge(
    {},
    zSe,
    l1(r, HSe),
    ot.pick(r, GSe)
  )), ot.forEach(e.nodes(), function(n) {
    var o = u1(e.node(n));
    t.setNode(n, ot.defaults(l1(o, VSe), KSe)), t.setParent(n, e.parent(n));
  }), ot.forEach(e.edges(), function(n) {
    var o = u1(e.edge(n));
    t.setEdge(n, ot.merge(
      {},
      XSe,
      l1(o, YSe),
      ot.pick(o, JSe)
    ));
  }), t;
}
function ZSe(e) {
  var t = e.graph();
  t.ranksep /= 2, ot.forEach(e.edges(), function(r) {
    var n = e.edge(r);
    n.minlen *= 2, n.labelpos.toLowerCase() !== "c" && (t.rankdir === "TB" || t.rankdir === "BT" ? n.width += n.labeloffset : n.height += n.labeloffset);
  });
}
function eEe(e) {
  ot.forEach(e.edges(), function(t) {
    var r = e.edge(t);
    if (r.width && r.height) {
      var n = e.node(t.v), o = e.node(t.w), s = { rank: (o.rank - n.rank) / 2 + n.rank, e: t };
      gs.addDummyNode(e, "edge-proxy", s, "_ep");
    }
  });
}
function tEe(e) {
  var t = 0;
  ot.forEach(e.nodes(), function(r) {
    var n = e.node(r);
    n.borderTop && (n.minRank = e.node(n.borderTop).rank, n.maxRank = e.node(n.borderBottom).rank, t = ot.max(t, n.maxRank));
  }), e.graph().maxRank = t;
}
function rEe(e) {
  ot.forEach(e.nodes(), function(t) {
    var r = e.node(t);
    r.dummy === "edge-proxy" && (e.edge(r.e).labelRank = r.rank, e.removeNode(t));
  });
}
function nEe(e) {
  var t = Number.POSITIVE_INFINITY, r = 0, n = Number.POSITIVE_INFINITY, o = 0, s = e.graph(), a = s.marginx || 0, l = s.marginy || 0;
  function u(f) {
    var c = f.x, d = f.y, h = f.width, p = f.height;
    t = Math.min(t, c - h / 2), r = Math.max(r, c + h / 2), n = Math.min(n, d - p / 2), o = Math.max(o, d + p / 2);
  }
  ot.forEach(e.nodes(), function(f) {
    u(e.node(f));
  }), ot.forEach(e.edges(), function(f) {
    var c = e.edge(f);
    ot.has(c, "x") && u(c);
  }), t -= a, n -= l, ot.forEach(e.nodes(), function(f) {
    var c = e.node(f);
    c.x -= t, c.y -= n;
  }), ot.forEach(e.edges(), function(f) {
    var c = e.edge(f);
    ot.forEach(c.points, function(d) {
      d.x -= t, d.y -= n;
    }), ot.has(c, "x") && (c.x -= t), ot.has(c, "y") && (c.y -= n);
  }), s.width = r - t + a, s.height = o - n + l;
}
function iEe(e) {
  ot.forEach(e.edges(), function(t) {
    var r = e.edge(t), n = e.node(t.v), o = e.node(t.w), s, a;
    r.points ? (s = r.points[0], a = r.points[r.points.length - 1]) : (r.points = [], s = o, a = n), r.points.unshift(gs.intersectRect(n, s)), r.points.push(gs.intersectRect(o, a));
  });
}
function oEe(e) {
  ot.forEach(e.edges(), function(t) {
    var r = e.edge(t);
    if (ot.has(r, "x"))
      switch ((r.labelpos === "l" || r.labelpos === "r") && (r.width -= r.labeloffset), r.labelpos) {
        case "l":
          r.x -= r.width / 2 + r.labeloffset;
          break;
        case "r":
          r.x += r.width / 2 + r.labeloffset;
          break;
      }
  });
}
function sEe(e) {
  ot.forEach(e.edges(), function(t) {
    var r = e.edge(t);
    r.reversed && r.points.reverse();
  });
}
function aEe(e) {
  ot.forEach(e.nodes(), function(t) {
    if (e.children(t).length) {
      var r = e.node(t), n = e.node(r.borderTop), o = e.node(r.borderBottom), s = e.node(ot.last(r.borderLeft)), a = e.node(ot.last(r.borderRight));
      r.width = Math.abs(a.x - s.x), r.height = Math.abs(o.y - n.y), r.x = s.x + r.width / 2, r.y = n.y + r.height / 2;
    }
  }), ot.forEach(e.nodes(), function(t) {
    e.node(t).dummy === "border" && e.removeNode(t);
  });
}
function lEe(e) {
  ot.forEach(e.edges(), function(t) {
    if (t.v === t.w) {
      var r = e.node(t.v);
      r.selfEdges || (r.selfEdges = []), r.selfEdges.push({ e: t, label: e.edge(t) }), e.removeEdge(t);
    }
  });
}
function uEe(e) {
  var t = gs.buildLayerMatrix(e);
  ot.forEach(t, function(r) {
    var n = 0;
    ot.forEach(r, function(o, s) {
      var a = e.node(o);
      a.order = s + n, ot.forEach(a.selfEdges, function(l) {
        gs.addDummyNode(e, "selfedge", {
          width: l.label.width,
          height: l.label.height,
          rank: a.rank,
          order: s + ++n,
          e: l.e,
          label: l.label
        }, "_se");
      }), delete a.selfEdges;
    });
  });
}
function fEe(e) {
  ot.forEach(e.nodes(), function(t) {
    var r = e.node(t);
    if (r.dummy === "selfedge") {
      var n = e.node(r.e.v), o = n.x + n.width / 2, s = n.y, a = r.x - o, l = n.height / 2;
      e.setEdge(r.e, r.label), e.removeNode(t), r.label.points = [
        { x: o + 2 * a / 3, y: s - l },
        { x: o + 5 * a / 6, y: s - l },
        { x: o + a, y: s },
        { x: o + 5 * a / 6, y: s + l },
        { x: o + 2 * a / 3, y: s + l }
      ], r.label.x = r.x, r.label.y = r.y;
    }
  });
}
function l1(e, t) {
  return ot.mapValues(ot.pick(e, t), Number);
}
function u1(e) {
  var t = {};
  return ot.forEach(e, function(r, n) {
    t[n.toLowerCase()] = r;
  }), t;
}
var kd = Ot, cEe = rn, dEe = oi.Graph, hEe = {
  debugOrdering: pEe
};
function pEe(e) {
  var t = cEe.buildLayerMatrix(e), r = new dEe({ compound: !0, multigraph: !0 }).setGraph({});
  return kd.forEach(e.nodes(), function(n) {
    r.setNode(n, { label: n }), r.setParent(n, "layer" + e.node(n).rank);
  }), kd.forEach(e.edges(), function(n) {
    r.setEdge(n.v, n.w, {}, n.name);
  }), kd.forEach(t, function(n, o) {
    var s = "layer" + o;
    r.setNode(s, { rank: "same" }), kd.reduce(n, function(a, l) {
      return r.setEdge(a, l, { style: "invis" }), l;
    });
  }), r;
}
var gEe = "0.8.5", bEe = {
  graphlib: oi,
  layout: BSe,
  debug: hEe,
  util: {
    time: rn.time,
    notime: rn.notime
  },
  version: gEe
};
const HP = /* @__PURE__ */ $n(bEe), yEe = {
  name: "GraphLayout",
  props: {
    // List of objects with an `id` property
    nodes: { required: !0, type: Array },
    // List of objects with `label`, `source` and `target` properties
    links: { required: !0, type: Array },
    // List of currently highlighted links
    activeLinks: { required: !0, type: Array },
    // Adjust zoom level when nodes change
    autoZoom: { default: !0 },
    layoutCfg: {
      type: Object,
      /**
             rankdir: The direction in which the graph is laid out. Can be "TB" (top to bottom), "BT" (bottom to top), "LR" (left to right), or "RL" (right to left).
             align: Determines how the nodes are aligned within their rank. Can be "UL" (up and left), "UR" (up and right), "DL" (down and left), "DR" (down and right), or undefined.
             nodesep: The minimum distance between nodes on the same rank.
             ranksep: The minimum distance between ranks.
             marginx: The margin to be added to the left and right of the graph.
             marginy: The margin to be added to the top and bottom of the graph.
      
             */
      default: function() {
        return {
          rankdir: "RL",
          align: void 0,
          nodesep: 20,
          ranksep: 50,
          marginx: 10,
          marginy: 10
        };
      }
    }
  },
  emits: ["link-enter", "link-out"],
  mounted() {
    this.renderGraph();
  },
  watch: {
    nodes() {
      this.renderGraph();
    },
    layoutCfg: {
      handler: "onLayoutCfgChange",
      deep: !0
    }
  },
  methods: {
    onLayoutCfgChange() {
      this.renderGraph();
    },
    async renderGraph() {
      if (this.nodes.length === 0)
        return;
      await gr();
      const e = this.$el, t = wn(e), r = wn(this.$refs.layout), n = this.nodes.map((E) => ({ ...E })), o = this.links.map((E) => ({ ...E })), s = _Ee(r, n, o, this.layoutCfg), a = gme().nodes(n);
      a.force(
        "links",
        ume(o).id(({ id: E }) => E).strength(0)
      ).force(
        "posX",
        bme().strength(1).x((E) => s.nodes[E.id].x)
      ).force(
        "posY",
        yme().strength(1).y((E) => s.nodes[E.id].y)
      ).stop(), r.style("width", `${s.width}px`), r.style("height", `${s.height}px`);
      const l = e.clientWidth / s.width, u = e.clientHeight / s.height, f = Math.min(l, u, 1), c = Math.max(
        (e.clientWidth - s.width * f) / 2,
        0
      ), d = Math.max(
        (e.clientHeight - s.height * f) / 2,
        0
      ), h = Lme().scaleExtent([0.1, 1.2]).on("zoom", ({ transform: E }) => {
        r.style(
          "transform",
          `translate(${E.x}px, ${E.y}px) scale(${E.k})`
        ), r.style("transform-origin", "0 0");
      });
      t.call(h), SEe(t, h), this.autoZoom && t.call(
        h.transform,
        Gg.translate(c, d).scale(f)
      );
      const p = (E) => this.links.find(
        ({ source: C, target: I }) => C === E.source.id && I === E.target.id
      ), m = r.select(".links").selectAll(".link").data(o).on("mouseover", (E, C) => {
        const I = p(C);
        this.$emit("link-enter", I);
      }).on("mouseout", (E, C) => {
        const I = p(C);
        this.$emit("link-out", I);
      }), y = r.select(".links").selectAll(".arrow-head").data(o).on("mouseover", (E, C) => {
        const I = p(C);
        this.$emit("link-enter", I);
      }).on("mouseout", (E, C) => {
        const I = p(C);
        this.$emit("link-out", I);
      }), _ = () => mEe(
        x,
        m,
        t,
        y
      ), S = t.node(), x = r.selectAll(".node").data(n).call(vEe(a, _, S));
      for (let E = 0, C = Math.ceil(
        Math.log(a.alphaMin()) / Math.log(1 - a.alphaDecay())
      ); E < C; ++E)
        a.tick();
      _(), a.force("posX", null).force("posY", null);
    }
  }
};
function mEe(e, t, r, n) {
  const o = r.node(), s = nA(o).k;
  e.join().attr(
    "style",
    (f) => ((isNaN(f.x) || isNaN(f.y)) && (f.x = 300, f.y = 300), `left: ${f.x}px; top: ${f.y}px`)
  );
  const a = Tme().source((f) => aW(f, o, s)).target((f) => zP(f, o, s)).x(({ x: f }) => f).y(({ y: f }) => f), l = (f) => (zP(f, o, s), "M -10 -5 L 0 0 L -10 5 z"), u = (f) => {
    const c = a(f), d = c.split("C")[1].split(",").map((S) => new Number(S.trim()).valueOf()), h = c.split("C")[0].replace("M", "").split(",").map((S) => new Number(S.trim()).valueOf()), p = [d[0], d[1]], m = [d[2], d[3]], y = [d[4], d[5]], _ = EEe(h, p, m, y);
    return `translate(${y[0]}, ${y[1]}) rotate(${_(0.95)})`;
  };
  t.attr("d", a), n.attr("d", l), n.attr("transform", u);
}
function vEe(e, t, r) {
  let n = 0, o = 0;
  function s(u, f) {
    u.active || e.alphaTarget(0.3).restart(), n = u.x, o = u.y, f.fx = f.x, f.fy = f.y;
  }
  function a(u, f) {
    const c = nA(r).k;
    f.fx = n + (u.x - n) / c, f.fy = o + (u.y - o) / c, t();
  }
  function l(u, f) {
    u.active || e.alphaTarget(0), f.fx = null, f.fy = null, t();
  }
  return _ye().on("start", s).on("drag", a).on("end", l);
}
function aW(e, t, r) {
  const o = t.querySelector(`[data-id="${e.source.id}"]`), s = o.querySelector(
    `[data-id="${e.sourceProperty}"]`
  ), a = s ?? o, l = e.target.x > e.source.x ? a.clientWidth + 3 : -3, u = s ? s.getBoundingClientRect().y / r - o.getBoundingClientRect().y / r + s.clientHeight / 2 : o.clientHeight / 2;
  return {
    x: e.source.x + l,
    y: e.source.y + u
  };
}
function zP(e, t, r) {
  const n = t.querySelector(`[data-id="${e.target.id}"]`), o = aW(e, t, r);
  return wEe(
    o,
    e.target,
    n.clientWidth,
    n.clientHeight
  );
}
function GP(e, t, r) {
  return Math.max(t, Math.min(r, e));
}
function wEe(e, t, r, n) {
  const o = {
    x: t.x + r,
    y: t.y + n
  }, s = GP(e.x, t.x, o.x), a = GP(e.y, t.y, o.y), l = Math.abs(s - t.x), u = Math.abs(s - o.x), f = Math.abs(a - t.y), c = Math.abs(a - o.y), d = Math.min(l, u, f, c);
  return d === f ? { x: s, y: t.y } : d === c ? { x: s, y: o.y } : d === l ? { x: t.x, y: a } : { x: o.x, y: a };
}
function _Ee(e, t, r, n) {
  const o = new HP.graphlib.Graph();
  return o.setGraph(n), o.setDefaultEdgeLabel(() => ({})), t.forEach((s) => {
    const a = e.select(`[data-id="${s.id}"]`), l = a.style("width").replace("px", ""), u = a.style("height").replace("px", "");
    o.setNode(s.id, { width: l, height: u });
  }), r.forEach(({ source: s, target: a }) => {
    o.setEdge(s, a);
  }), HP.layout(o), {
    width: o._label.width,
    height: o._label.height,
    nodes: o.nodes().reduce((s, a) => {
      const l = o.node(a);
      return {
        ...s,
        [a]: {
          id: a,
          x: l.x - l.width / 2,
          y: l.y - l.height / 2
        }
      };
    }, {})
  };
}
function SEe(e, t) {
  wn("body").on("keydown", (r) => {
    if (r.target.localName !== "body")
      return;
    const n = 50, o = {
      ArrowUp: [0, n],
      ArrowRight: [-n, 0],
      ArrowDown: [0, -n],
      ArrowLeft: [n, 0]
    }[r.key];
    o && e.call(t.translateBy, ...o);
  });
}
function EEe(e, t, r, n) {
  return function(s) {
    const a = 3 * Math.pow(1 - s, 2) * (t[0] - e[0]) + 6 * (1 - s) * s * (r[0] - t[0]) + 3 * Math.pow(s, 2) * (n[0] - r[0]), l = 3 * Math.pow(1 - s, 2) * (t[1] - e[1]) + 6 * (1 - s) * s * (r[1] - t[1]) + 3 * Math.pow(s, 2) * (n[1] - r[1]);
    return Math.atan2(l, a) * (180 / Math.PI);
  };
}
const xEe = { class: "graph-layout" }, REe = {
  ref: "layout",
  class: "layout"
}, AEe = ["data-id"], TEe = { class: "links" }, $Ee = /* @__PURE__ */ ie("defs", null, [
  /* @__PURE__ */ ie("marker", {
    id: "dot",
    viewBox: "0 0 100 100",
    refX: "50",
    refY: "50",
    markerUnits: "userSpaceOnUse",
    markerWidth: "6",
    markerHeight: "6",
    orient: "auto",
    class: "fill-gray-600 dark:fill-gray-100"
  }, [
    /* @__PURE__ */ ie("circle", {
      cx: "50",
      cy: "50",
      r: "50",
      class: "link-start"
    })
  ]),
  /* @__PURE__ */ ie("marker", {
    id: "dot-active",
    viewBox: "0 0 100 100",
    refX: "50",
    refY: "50",
    markerUnits: "userSpaceOnUse",
    markerWidth: "6",
    markerHeight: "6",
    orient: "auto",
    class: "fill-primary-300"
  }, [
    /* @__PURE__ */ ie("circle", {
      cx: "50",
      cy: "50",
      r: "50",
      class: "link-start"
    })
  ])
], -1);
function CEe(e, t, r, n, o, s) {
  return we(), Te("div", xEe, [
    ie("div", REe, [
      (we(!0), Te(lt, null, pr(r.nodes, (a) => (we(), Te("div", {
        key: a.id,
        class: "node",
        "data-id": a.id
      }, [
        io(e.$slots, "node", { node: a }, () => [
          tn(" Missing slot ")
        ])
      ], 8, AEe))), 128)),
      (we(), Te("svg", TEe, [
        $Ee,
        (we(!0), Te(lt, null, pr(r.links, (a, l) => (we(), Te("g", {
          class: "link-container",
          key: l
        }, [
          ie("path", {
            class: lr(["link stroke-gray-700 dark:stroke-gray-100", { active: r.activeLinks.includes(a) }])
          }, [
            ie("title", null, pt(a.label), 1)
          ], 2),
          ie("path", {
            class: lr(["arrow-head fill-gray-600 dark:fill-gray-100", { active: r.activeLinks.includes(a) }])
          }, null, 2)
        ]))), 128))
      ]))
    ], 512),
    io(e.$slots, "default")
  ]);
}
const lW = /* @__PURE__ */ ni(yEe, [["render", CEe]]), kEe = { class: "z-10 absolute bottom-2 right-2 text-sm text-gray-400" }, IEe = {
  key: 1,
  class: "flex-grow bg-light dark:bg-dark flex flex-col items-center justify-center"
}, MEe = /* @__PURE__ */ ie("p", { class: "pb-4" }, "No classes to show", -1), NEe = [
  MEe
], LEe = {
  name: "DataModelComponent"
}, OEe = /* @__PURE__ */ nt({
  ...LEe,
  props: {
    datamodel: {}
  },
  emits: ["explore", "toggle-shape", "export"],
  setup(e, { emit: t }) {
    const r = e, n = $e([]), o = Ne(() => r.datamodel.tables.filter(({ isShown: d }) => d)), s = {
      rankdir: "LR",
      align: "UR",
      nodesep: 40,
      ranksep: 500,
      marginx: 10,
      marginy: 10
    }, a = Ne(
      () => {
        const d = new Set(o.value.map(({ id: h }) => h));
        return o.value.flatMap((h) => h.properties.map((p) => ({ ...p, table: h }))).reduce((h, p) => (p.values.forEach((m) => {
          const y = p.table.id, _ = m.id;
          d.has(_) && h.push({ source: y, target: _, sourceProperty: p.id, label: p.name });
        }), h), []);
      }
    );
    function l(d) {
      n.value = a.value.filter((h) => h.source === d.id);
    }
    function u(d, h) {
      n.value = a.value.filter((p) => p.source === d.id && p.sourceProperty === h.id);
    }
    function f() {
      n.value = [];
    }
    function c(d) {
      n.value = [d];
    }
    return (d, h) => o.value.length > 0 ? (we(), Et(Pe(lW), {
      key: 0,
      nodes: o.value,
      links: a.value,
      "active-links": n.value,
      layoutCfg: s,
      onLinkEnter: c,
      onLinkOut: f,
      class: "bg-light dark:bg-dark flex-grow"
    }, {
      node: Ge(({ node: p }) => [
        Ee(Nge, {
          table: p,
          "active-links": n.value,
          onExplore: h[0] || (h[0] = (m) => d.$emit("explore", m)),
          onHide: h[1] || (h[1] = (m) => d.$emit("toggle-shape", m, !1)),
          onExport: h[2] || (h[2] = (m) => d.$emit("export", m)),
          onHoverTitle: l,
          onUnhoverTitle: f,
          onHoverProperty: u,
          onUnhoverProperty: f
        }, null, 8, ["table", "active-links"])
      ]),
      default: Ge(() => [
        io(d.$slots, "default"),
        Fr(ie("p", kEe, " introspected ", 512), [
          [Ea, d.datamodel.isIntrospected]
        ])
      ]),
      _: 3
    }, 8, ["nodes", "links", "active-links"])) : (we(), Te("div", IEe, NEe));
  }
}), PEe = { class: "font-bold" }, DEe = { class: "flex flex-nowrap" }, FEe = { class: "w-full" }, jEe = ["data-id", "onMouseenter", "onMouseleave"], BEe = { class: "border-b dark:border-gray-500 px-3 py-2 text-gray-800 dark:text-gray-50" }, qEe = { class: "border-b dark:border-gray-500 px-3 py-2" }, WEe = {
  name: "ResourceCard"
}, UEe = /* @__PURE__ */ nt({
  ...WEe,
  props: {
    resource: {},
    activeLinks: {}
  },
  emits: ["hover-title", "unhover-title", "hover-property", "unhover-property"],
  setup(e, { emit: t }) {
    const r = e;
    function n(a) {
      a.stopPropagation();
    }
    const o = Ne(() => r.activeLinks.some((a) => a.target === r.resource.id));
    function s(a) {
      return r.activeLinks.some((l) => l.source === r.resource.id && l.sourceProperty === a.id);
    }
    return (a, l) => (we(), Te("div", {
      class: lr(["border dark:border-gray-500 rounded shadow-md bg-white dark:bg-gray-800 opacity-90 text-sm", { active: o.value }])
    }, [
      ie("header", {
        class: "bg-gray-100 dark:bg-gray-900 flex items-center gap-4 justify-between px-3 py-2",
        onMouseenter: l[0] || (l[0] = (u) => a.$emit("hover-title", a.resource)),
        onMouseleave: l[1] || (l[1] = (u) => a.$emit("unhover-title", a.resource))
      }, [
        ie("h3", PEe, [
          Ee(Wr, {
            label: a.resource.id
          }, {
            default: Ge(() => [
              tn(pt(a.resource.name), 1)
            ]),
            _: 1
          }, 8, ["label"])
        ]),
        ie("span", DEe, [
          io(a.$slots, "actions", {}, void 0, !0)
        ])
      ], 32),
      ie("table", FEe, [
        (we(!0), Te(lt, null, pr(a.resource.properties, (u, f) => (we(), Te("tr", {
          key: f,
          "data-id": u.id,
          class: lr({ active: s(u) }),
          onMouseenter: (c) => a.$emit("hover-property", a.resource, u),
          onMouseleave: (c) => a.$emit("unhover-property", a.resource, u)
        }, [
          ie("th", BEe, [
            Ee(Wr, {
              label: u.id
            }, {
              default: Ge(() => [
                ie("span", { onMousedown: n }, pt(u.name), 33)
              ]),
              _: 2
            }, 1032, ["label"])
          ]),
          ie("td", qEe, [
            (we(!0), Te(lt, null, pr(u.values, (c) => (we(), Te("div", {
              key: c.id
            }, [
              io(a.$slots, "property-value", { value: c }, () => [
                Ee(Wr, {
                  label: c.id
                }, {
                  default: Ge(() => [
                    ie("span", { onMousedown: n }, pt(c.name), 33)
                  ]),
                  _: 2
                }, 1032, ["label"])
              ], !0)
            ]))), 128))
          ])
        ], 42, jEe))), 128))
      ])
    ], 2));
  }
}), HEe = /* @__PURE__ */ ni(UEe, [["__scopeId", "data-v-e05bd27a"]]), zEe = {
  key: 0,
  class: "has-text-grey"
}, GEe = {
  name: "SpexTerm"
}, xE = /* @__PURE__ */ nt({
  ...GEe,
  props: {
    term: {}
  },
  setup(e) {
    const t = e, r = co.getInstance(), n = $e(l(r, t.term)), o = u(r, t.term), s = $e(t.term && t.term.language), a = $e(o !== n.value ? o : "");
    function l(f, c) {
      return c && (c.termType === "NamedNode" ? f.shrink(c.value) : c.value);
    }
    function u(f, c) {
      if (c.termType === "Literal") {
        const d = c.datatype ? `^^${f.shrink(c.datatype.value)}` : "", h = c.language ? `@${c.language}` : "";
        return `${c.value}${d}${h}`;
      }
      return c.value;
    }
    return (f, c) => (we(), Et(Wr, { label: a.value }, {
      default: Ge(() => [
        tn(pt(n.value), 1),
        s.value ? (we(), Te("small", zEe, "@" + pt(s.value), 1)) : gt("", !0)
      ]),
      _: 1
    }, 8, ["label"]));
  }
}), VEe = {
  name: "TermExploreButton"
}, RE = /* @__PURE__ */ nt({
  ...VEe,
  props: {
    term: {}
  },
  emits: ["explore-resource"],
  setup(e, { emit: t }) {
    const r = e, n = Ne(() => ["NamedNode", "BlankNode"].includes(r.term.termType)), o = Ne(
      () => ({ id: r.term.value, name: r.term.value, term: r.term })
    );
    return (s, a) => n.value ? (we(), Et(Wr, {
      key: 0,
      label: "Explore"
    }, {
      default: Ge(() => [
        ie("button", {
          class: "button is-white is-small",
          onClick: a[0] || (a[0] = (l) => s.$emit("explore-resource", o.value))
        }, [
          Ee(Pe(KH), { class: "icon" })
        ])
      ]),
      _: 1
    })) : gt("", !0);
  }
});
var VP;
(function(e) {
  e.pop = "pop", e.push = "push";
})(VP || (VP = {}));
var KP;
(function(e) {
  e.back = "back", e.forward = "forward", e.unknown = "";
})(KP || (KP = {}));
var YP;
(function(e) {
  e[e.aborted = 4] = "aborted", e[e.cancelled = 8] = "cancelled", e[e.duplicated = 16] = "duplicated";
})(YP || (YP = {}));
const KEe = Symbol("route location");
function YEe() {
  return yr(KEe);
}
const XEe = { class: "card h-full flex flex-col" }, JEe = { class: "card-header has-background-light" }, QEe = /* @__PURE__ */ ie("h3", { class: "card-header-title" }, " Resources Explorer ", -1), ZEe = { class: "card-header-icon py-0 px-1" }, exe = ["href"], txe = ["onClick"], rxe = { class: "flex items-center" }, nxe = {
  name: "ResourcesExplorer"
}, ixe = /* @__PURE__ */ nt({
  ...nxe,
  props: {
    resources: {}
  },
  emits: ["explore-resource", "unexplore-resource", "close"],
  setup(e, { emit: t }) {
    const r = e, n = YEe(), o = co.getInstance(), s = Ne(() => {
      const h = new Set(r.resources.map(({ id: p }) => p));
      return r.resources.filter((p) => p.properties).flatMap((p) => p.properties.map((m) => ({ ...m, resource: p }))).reduce((p, m) => (m.values.forEach((y) => {
        const _ = m.resource.id, S = y.value;
        h.has(S) && p.push({ source: _, target: S, sourceProperty: m.id, label: m.name });
      }), p), []);
    }), a = $e([]);
    function l(h) {
      a.value.push(h);
    }
    function u() {
      a.value = [];
    }
    function f(h) {
      a.value = s.value.filter((p) => p.source === h.id);
    }
    function c(h, p) {
      a.value = s.value.filter((m) => m.source === h.id && m.sourceProperty === p.id);
    }
    async function d() {
      r.resources.forEach(
        async (h) => {
          if (!h.isFetched)
            try {
              const m = { ...await o.fetchResource(h.id), isFetched: !0 };
              t("explore-resource", m);
            } catch {
              const m = { ...h, isFetched: !0 };
              t("explore-resource", m);
            }
        }
      );
    }
    return Dt(() => {
      d();
    }), br(r.resources, d), Ne(() => n.params.uri), (h, p) => (we(), Te("div", XEe, [
      ie("div", JEe, [
        QEe,
        ie("p", ZEe, [
          ie("button", {
            class: "button is-light",
            onClick: p[0] || (p[0] = (m) => h.$emit("close")),
            title: "Close"
          }, [
            Ee(Pe(as), { class: "icon" })
          ])
        ])
      ]),
      Ee(Pe(lW), {
        class: "card-content p-0",
        nodes: h.resources,
        links: s.value,
        "active-links": a.value,
        "auto-zoom": !1,
        onLinkEnter: l,
        onLinkOut: u
      }, {
        node: Ge(({ node: m }) => [
          Ee(HEe, {
            resource: m,
            "active-links": a.value,
            onHoverTitle: f,
            onUnhoverTitle: u,
            onHoverProperty: c,
            onUnhoverProperty: u
          }, {
            actions: Ge(() => [
              Ee(Wr, { label: "Open URI in new tab" }, {
                default: Ge(() => [
                  ie("a", {
                    href: m.id,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    class: "button is-light"
                  }, [
                    Ee(Pe(BH), { class: "icon" })
                  ], 8, exe)
                ]),
                _: 2
              }, 1024),
              Ee(Wr, { label: "Hide" }, {
                default: Ge(() => [
                  ie("button", {
                    class: "button is-light",
                    onClick: (y) => h.$emit("unexplore-resource", m)
                  }, [
                    Ee(Pe(lD), { class: "icon" })
                  ], 8, txe)
                ]),
                _: 2
              }, 1024)
            ]),
            "property-value": Ge(({ value: y }) => [
              ie("div", rxe, [
                Ee(xE, {
                  term: y,
                  endpoint: Pe(o)
                }, null, 8, ["term", "endpoint"]),
                Ee(RE, {
                  term: y,
                  onExploreResource: p[1] || (p[1] = (_) => h.$emit("explore-resource", _))
                }, null, 8, ["term"])
              ])
            ]),
            _: 2
          }, 1032, ["resource", "active-links"])
        ]),
        _: 1
      }, 8, ["nodes", "links", "active-links"])
    ]));
  }
}), oxe = {}, sxe = {
  class: "animate-spin h-8 w-8",
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 24 24"
}, axe = /* @__PURE__ */ ie("circle", {
  class: "opacity-25",
  cx: "12",
  cy: "12",
  r: "10",
  stroke: "#ffb15e",
  "stroke-width": "4"
}, null, -1), lxe = /* @__PURE__ */ ie("path", {
  class: "opacity-75",
  fill: "#ffb15e",
  d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
}, null, -1), uxe = [
  axe,
  lxe
];
function fxe(e, t) {
  return we(), Te("svg", sxe, uxe);
}
const RA = /* @__PURE__ */ ni(oxe, [["render", fxe]]), cxe = ["id", "value"], dxe = { key: 0 }, hxe = /* @__PURE__ */ ie("span", null, "Load more", -1), pxe = {
  name: "SelectGraph"
}, gxe = /* @__PURE__ */ nt({
  ...pxe,
  props: {
    id: {},
    modelValue: {},
    graphs: {},
    loading: { type: Boolean },
    hasMoreGraphs: { type: Boolean }
  },
  emits: ["update:modelValue", "fetch-more"],
  setup(e, { emit: t }) {
    return (r, n) => (we(), Et(Pe(Cpe), {
      as: "div",
      class: "control",
      modelValue: r.modelValue,
      "onUpdate:modelValue": n[2] || (n[2] = (o) => r.$emit("update:modelValue", o))
    }, {
      default: Ge(() => [
        Ee(Pe(kpe), {
          as: "div",
          class: "relative"
        }, {
          default: Ge(() => [
            ie("input", {
              id: r.id,
              placeholder: "DEFAULT",
              class: "input",
              value: r.modelValue,
              onInput: n[0] || (n[0] = (o) => r.$emit("update:modelValue", o.target.value)),
              autocomplete: "off"
            }, null, 40, cxe),
            Fr(Ee(RA, { class: "absolute top-2 right-2" }, null, 512), [
              [Ea, r.loading]
            ])
          ]),
          _: 1
        }),
        Ee(yp, {
          "enter-active-class": "transition duration-100 ease-out",
          "enter-from-class": "scale-95 opacity-0",
          "enter-to-class": "scale-100 opacity-100",
          "leave-active-class": "transition duration-75 ease-out",
          "leave-from-class": "scale-100 opacity-100",
          "leave-to-class": "scale-95 opacity-0"
        }, {
          default: Ge(() => [
            Ee(Pe(Ipe), {
              as: "ul",
              class: "bg-white border border-gray-100 shadow-md absolute w-full z-10 max-h-64 overflow-y-scroll"
            }, {
              default: Ge(() => [
                (we(!0), Te(lt, null, pr(r.graphs, (o) => (we(), Et(Pe(Mpe), {
                  as: "template",
                  key: o,
                  value: o
                }, {
                  default: Ge(({ active: s, selected: a }) => [
                    ie("li", {
                      class: lr(["px-2 py-2", {
                        "bg-gray-100": s,
                        "bg-primary-300": a
                      }])
                    }, pt(o), 3)
                  ]),
                  _: 2
                }, 1032, ["value"]))), 128)),
                r.hasMoreGraphs ? (we(), Te("li", dxe, [
                  ie("button", {
                    type: "button",
                    class: lr(["button is-light justify-start w-full", { "is-loading": r.loading }]),
                    onClick: n[1] || (n[1] = (o) => r.$emit("fetch-more"))
                  }, [
                    Ee(Pe(jH), { class: "icon" }),
                    hxe
                  ], 2)
                ])) : gt("", !0)
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["modelValue"]));
  }
}), bxe = {
  name: "SpexSwitch"
}, AA = /* @__PURE__ */ nt({
  ...bxe,
  props: {
    modelValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    return (r, n) => (we(), Et(Pe(zpe), {
      modelValue: r.modelValue,
      "onUpdate:modelValue": n[0] || (n[0] = (o) => r.$emit("update:modelValue", o)),
      class: lr([r.modelValue ? "bg-primary-400" : "bg-gray-300", "relative inline-flex shrink-0 items-center h-6 w-10 rounded-full shadow-inner"])
    }, {
      default: Ge(() => [
        ie("span", {
          class: lr([r.modelValue ? "translate-x-5" : "translate-x-1", "inline-block w-4 h-4 bg-white rounded-full shadow transition duration-200 ease-in-out"])
        }, null, 2)
      ]),
      _: 1
    }, 8, ["modelValue", "class"]));
  }
}), yxe = { class: "card is-shadowless h-full overflow-y-auto" }, mxe = { class: "card-header has-background-light" }, vxe = /* @__PURE__ */ ie("h3", { class: "card-header-title" }, "Options", -1), wxe = { class: "card-header-icon py-0 px-1" }, _xe = { class: "card-content" }, Sxe = { class: "field" }, Exe = /* @__PURE__ */ ie("label", {
  class: "label",
  for: "endpoint"
}, "Sparql Endpoint URL", -1), xxe = { class: "control has-icons-right" }, Rxe = {
  key: 0,
  class: "icon is-small is-right",
  CheckIcon: ""
}, Axe = { class: "field" }, Txe = /* @__PURE__ */ ie("label", {
  class: "label",
  for: "username"
}, "Username", -1), $xe = { class: "field" }, Cxe = /* @__PURE__ */ ie("label", {
  class: "label",
  for: "password"
}, "Password", -1), kxe = /* @__PURE__ */ ie("label", {
  class: "label",
  for: "graph"
}, "Named Graph", -1), Ixe = { class: "field" }, Mxe = {
  key: 0,
  class: "message is-danger"
}, Nxe = { class: "message-body" }, Lxe = { class: "field" }, Oxe = /* @__PURE__ */ ie("label", { class: "label" }, "Custom prefixes", -1), Pxe = { class: "flex flex-col gap-1" }, Dxe = ["onUpdate:modelValue"], Fxe = ["onUpdate:modelValue"], jxe = ["onClick"], Bxe = {
  key: 0,
  class: "has-text-grey"
}, qxe = { class: "field" }, Wxe = { class: "label flex items-center gap-2" }, Uxe = /* @__PURE__ */ ie("p", { class: "help" }, [
  /* @__PURE__ */ tn(" By default, the explorer will use the endpoint schema provided at "),
  /* @__PURE__ */ ie("code", null, "endpoint/.well-known/void"),
  /* @__PURE__ */ tn(" (if any). Use this option to force an introspection. ")
], -1), Hxe = {
  name: "SettingsPane"
}, zxe = /* @__PURE__ */ nt({
  ...Hxe,
  props: {
    settings: {}
  },
  emits: ["settingsChanged", "close"],
  setup(e, { emit: t }) {
    const r = e, n = 10, o = $e({
      sparqlEndpoint: r.settings.sparqlEndpoint,
      namedGraph: r.settings.namedGraph,
      prefixes: r.settings.prefixes,
      username: r.settings.username,
      password: r.settings.password,
      forceIntrospection: r.settings.forceIntrospection
    }), s = $e(!1), a = $e(!1);
    let l = null;
    r.settings.sparqlEndpoint && S();
    const u = $e([]), f = $e(!1), c = $e(!1), d = $e(null), h = $e(0);
    Dt(async () => {
      r.settings.sparqlEndpoint !== null && await x();
    });
    function p(G) {
      G.preventDefault(), G.stopPropagation(), t("settingsChanged", o.value);
    }
    function m() {
      t("close");
    }
    function y(G) {
      o.value.namedGraph = null, S();
    }
    function _(G) {
      var $, V, M, W;
      (((($ = o.value.username) == null ? void 0 : $.length) ?? 0) > 0 && (((V = o.value.username) == null ? void 0 : V.length) ?? 0) > 0 || (((M = o.value.username) == null ? void 0 : M.length) ?? 0) === 0 && (((W = o.value.username) == null ? void 0 : W.length) ?? 0) === 0) && S();
    }
    async function S() {
      const G = co.getInstance(o.value);
      s.value = await G.canFetchOne(), a.value = !1, s.value && x();
    }
    async function x() {
      c.value = !0, l = co.getInstance(o.value), h.value = 0, u.value = await C() ?? [];
    }
    async function E() {
      const G = await C() ?? [];
      u.value = u.value.concat(G);
    }
    async function C() {
      c.value = !0, d.value = "";
      try {
        const G = { offset: h.value, limit: n }, $ = await (l == null ? void 0 : l.fetchGraphs(G));
        return h.value = h.value + n, f.value = (($ == null ? void 0 : $.length) ?? 0) >= n, $;
      } catch (G) {
        return d.value = G.toString(), [];
      } finally {
        c.value = !1;
      }
    }
    function I() {
      o.value.prefixes.push({ prefix: "", namespace: "" });
    }
    function j(G) {
      o.value.prefixes.splice(G, 1);
    }
    function J() {
      a.value = !0, l = null;
    }
    return (G, $) => (we(), Te("div", yxe, [
      ie("div", mxe, [
        vxe,
        ie("p", wxe, [
          ie("button", {
            type: "button",
            class: "button is-light",
            onClick: m,
            title: "Close"
          }, [
            Ee(Pe(as), { class: "icon" })
          ])
        ])
      ]),
      ie("form", _xe, [
        ie("div", Sxe, [
          Exe,
          ie("p", xxe, [
            Fr(ie("input", {
              id: "endpoint",
              type: "text",
              class: "input",
              "onUpdate:modelValue": $[0] || ($[0] = (V) => o.value.sparqlEndpoint = V),
              onBlur: y,
              onFocusin: J
            }, null, 544), [
              [zo, o.value.sparqlEndpoint]
            ]),
            a.value ? gt("", !0) : (we(), Te("span", Rxe, [
              s.value ? (we(), Et(Pe(UH), {
                key: 0,
                class: "icon",
                style: { color: "green" }
              })) : gt("", !0),
              s.value ? gt("", !0) : (we(), Et(Pe(as), {
                key: 1,
                class: "icon",
                style: { color: "red" }
              }))
            ]))
          ])
        ]),
        ie("div", Axe, [
          Txe,
          Fr(ie("input", {
            id: "username",
            type: "text",
            class: "input",
            "onUpdate:modelValue": $[1] || ($[1] = (V) => o.value.username = V),
            onBlur: _
          }, null, 544), [
            [zo, o.value.username]
          ])
        ]),
        ie("div", $xe, [
          Cxe,
          Fr(ie("input", {
            id: "password",
            type: "password",
            class: "input",
            "onUpdate:modelValue": $[2] || ($[2] = (V) => o.value.password = V),
            onBlur: _
          }, null, 544), [
            [zo, o.value.password]
          ])
        ]),
        ie("div", {
          class: lr(["field", d.value ? "is-danger" : ""])
        }, [
          kxe,
          Ee(gxe, {
            id: "graph",
            modelValue: o.value.namedGraph,
            "onUpdate:modelValue": $[3] || ($[3] = (V) => o.value.namedGraph = V),
            graphs: u.value,
            loading: c.value,
            "has-more-graphs": f.value,
            onFetchMore: E
          }, null, 8, ["modelValue", "graphs", "loading", "has-more-graphs"])
        ], 2),
        ie("div", Ixe, [
          d.value ? (we(), Te("div", Mxe, [
            ie("div", Nxe, pt(d.value), 1)
          ])) : gt("", !0)
        ]),
        ie("div", Lxe, [
          Oxe,
          ie("div", Pxe, [
            (we(!0), Te(lt, null, pr(o.value.prefixes, (V, M) => (we(), Te("div", {
              key: M,
              class: "flex gap-1"
            }, [
              Fr(ie("input", {
                type: "text",
                "onUpdate:modelValue": (W) => V.prefix = W,
                placeholder: "schema",
                class: "input w-24",
                required: ""
              }, null, 8, Dxe), [
                [zo, V.prefix]
              ]),
              Fr(ie("input", {
                type: "text",
                "onUpdate:modelValue": (W) => V.namespace = W,
                placeholder: "http://schema.org/",
                class: "input flex-grow",
                required: ""
              }, null, 8, Fxe), [
                [zo, V.namespace]
              ]),
              ie("button", {
                type: "button",
                class: "button is-white",
                title: "Remove prefix",
                onClick: (W) => j(M)
              }, [
                Ee(Pe(YH), { class: "icon" })
              ], 8, jxe)
            ]))), 128)),
            o.value.prefixes.length === 0 ? (we(), Te("p", Bxe, " No custom prefix ")) : gt("", !0),
            ie("p", null, [
              ie("button", {
                type: "button",
                class: "button is-white",
                title: "Add prefix",
                onClick: I
              }, [
                Ee(Pe(XH), { class: "icon" })
              ])
            ])
          ])
        ]),
        ie("div", qxe, [
          ie("label", Wxe, [
            Ee(AA, {
              modelValue: o.value.forceIntrospection,
              "onUpdate:modelValue": $[4] || ($[4] = (V) => o.value.forceIntrospection = V)
            }, null, 8, ["modelValue"]),
            tn(" Force introspection ")
          ]),
          Uxe
        ]),
        ie("div", { class: "field" }, [
          ie("button", {
            class: "button is-primary",
            type: "submit",
            onClick: p
          }, "Load")
        ])
      ])
    ]));
  }
}), Gxe = { class: "card h-full flex flex-col" }, Vxe = { class: "card-header has-background-light" }, Kxe = { class: "card-header-title" }, Yxe = { key: 0 }, Xxe = { key: 1 }, Jxe = { class: "card-header-icon py-0 px-1" }, Qxe = { class: "card-content h-full p-0 overflow-auto flex flex-col" }, Zxe = {
  key: 0,
  class: "table is-fullwidth mb-0"
}, eRe = /* @__PURE__ */ ie("th", null, "URI", -1), tRe = { class: "border-b" }, rRe = { class: "flex items-center" }, nRe = { class: "sticky bottom-0" }, iRe = { class: "bg-gray-50" }, oRe = ["colspan"], sRe = { class: "flex items-center gap-2" }, aRe = ["disabled"], lRe = {
  key: 1,
  class: "flex-grow flex justify-center items-center"
}, uRe = {
  key: 2,
  class: "message is-danger"
}, fRe = { class: "message-body" }, cRe = {
  name: "TableExplorer"
}, dRe = /* @__PURE__ */ nt({
  ...cRe,
  props: {
    table: {},
    tables: {}
  },
  emits: ["close", "explore-resource"],
  setup(e, { emit: t }) {
    const r = e, n = co.getInstance(), o = $e([]), s = $e(null), a = $e(!1), l = 10, u = $e(1), f = async () => {
      if (o.value = [], s.value = null, !r.table)
        return;
      const d = (u.value - 1) * l, h = l;
      a.value = !0;
      try {
        n && (o.value = await n.fetchTableData(r.table, { offset: d, limit: h }));
      } catch (p) {
        s.value = p, console.error(p);
      } finally {
        a.value = !1;
      }
    };
    br(() => r.table, (d, h) => {
      c(1);
    });
    const c = (d) => {
      u.value = d, f();
    };
    return Dt(() => {
      c(1);
    }), (d, h) => (we(), Te("div", Gxe, [
      ie("div", Vxe, [
        ie("h3", Kxe, [
          d.table ? (we(), Te("span", Yxe, pt(d.table.name), 1)) : (we(), Te("span", Xxe, "No table selected"))
        ]),
        ie("p", Jxe, [
          ie("button", {
            class: "button is-light",
            onClick: h[0] || (h[0] = (p) => d.$emit("close")),
            title: "Close"
          }, [
            Ee(Pe(as), { class: "icon" })
          ])
        ])
      ]),
      ie("div", Qxe, [
        d.table ? (we(), Te("table", Zxe, [
          ie("thead", null, [
            ie("tr", null, [
              eRe,
              (we(!0), Te(lt, null, pr(d.table.properties, (p, m) => (we(), Te("th", { key: m }, pt(p.name), 1))), 128))
            ])
          ]),
          ie("tbody", tRe, [
            (we(!0), Te(lt, null, pr(o.value, (p, m) => (we(), Te("tr", { key: m }, [
              ie("td", null, [
                ie("p", rRe, [
                  Ee(xE, {
                    term: p.term,
                    endpoint: Pe(n)
                  }, null, 8, ["term", "endpoint"]),
                  Ee(RE, {
                    term: p.term,
                    onExploreResource: h[1] || (h[1] = (y) => d.$emit("explore-resource", y))
                  }, null, 8, ["term"])
                ])
              ]),
              (we(!0), Te(lt, null, pr(d.table.properties, (y, _) => (we(), Te("td", { key: _ }, [
                (we(!0), Te(lt, null, pr(p[y.id] || [], (S, x) => (we(), Te("p", {
                  class: "flex items-center",
                  key: x
                }, [
                  Ee(xE, {
                    term: S,
                    endpoint: Pe(n)
                  }, null, 8, ["term", "endpoint"]),
                  Ee(RE, {
                    term: S,
                    onExploreResource: h[2] || (h[2] = (E) => d.$emit("explore-resource", E))
                  }, null, 8, ["term"])
                ]))), 128))
              ]))), 128))
            ]))), 128))
          ]),
          Fr(ie("tfoot", nRe, [
            ie("tr", iRe, [
              ie("td", {
                colspan: 1 + d.table.properties.length
              }, [
                ie("div", sRe, [
                  ie("button", {
                    class: "button px-2",
                    disabled: u.value === 1,
                    onClick: h[3] || (h[3] = (p) => c(u.value - 1))
                  }, [
                    Ee(Pe(HH), { class: "w-5 h-5" })
                  ], 8, aRe),
                  ie("span", null, "Page " + pt(u.value), 1),
                  ie("button", {
                    class: "button px-2",
                    onClick: h[4] || (h[4] = (p) => c(u.value + 1))
                  }, [
                    Ee(Pe(zH), { class: "w-5 h-5" })
                  ])
                ])
              ], 8, oRe)
            ])
          ], 512), [
            [Ea, !a.value]
          ])
        ])) : gt("", !0),
        a.value ? (we(), Te("div", lRe, [
          Ee(RA)
        ])) : gt("", !0),
        s.value ? (we(), Te("div", uRe, [
          ie("div", fRe, " Error loading data: " + pt(s.value), 1)
        ])) : gt("", !0)
      ])
    ]));
  }
});
function hRe(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M12 6.042A8.967 8.967 0 006 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 016 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 016-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0018 18a8.967 8.967 0 00-6 2.292m0-14.25v14.25"
    })
  ]);
}
function pRe(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M19.5 8.25l-7.5 7.5-7.5-7.5"
    })
  ]);
}
function gRe(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M4.5 15.75l7.5-7.5 7.5 7.5"
    })
  ]);
}
function bRe(e, t) {
  return we(), Te("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    ie("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"
    })
  ]);
}
const yRe = { class: "panel-block is-justify-content-space-between" }, mRe = { style: { "flex-grow": "1", "overflow-x": "clip", "text-overflow": "ellipsis" } }, vRe = {
  style: { "flex-grow": "0" },
  class: "badge"
}, wRe = {
  name: "TableListItem"
}, _Re = /* @__PURE__ */ nt({
  ...wRe,
  props: {
    table: {}
  },
  emits: ["toggle-table", "select-viewport"],
  setup(e, { emit: t }) {
    const r = e, n = Ne(() => {
      const s = r.table.count ?? 0;
      return s > 1e3 && s < 1e6 ? o(s / 1e3, 1) + "K" : s > 1e6 ? o(s / 1e6, 1) + "M" : `${s}`;
    });
    function o(s, a) {
      const l = Math.pow(10, a || 0);
      return Math.round(s * l) / l;
    }
    return (s, a) => (we(), Te("div", yRe, [
      ie("span", mRe, pt(s.table.name), 1),
      Ee(Wr, { label: "Instances" }, {
        default: Ge(() => [
          ie("div", vRe, pt(n.value), 1)
        ]),
        _: 1
      }),
      Ee(AA, {
        style: { "flex-grow": "0" },
        modelValue: s.table.isShown,
        "onUpdate:modelValue": a[0] || (a[0] = (l) => s.$emit("toggle-table", s.table, l))
      }, null, 8, ["modelValue"])
    ]));
  }
}), SRe = /* @__PURE__ */ ni(_Re, [["__scopeId", "data-v-f6057106"]]), ERe = { class: "card is-shadowless overflow-y-auto" }, xRe = { class: "card-header has-background-light" }, RRe = /* @__PURE__ */ ie("h3", { class: "card-header-title" }, "Classes", -1), ARe = { class: "card-header-icon py-0 px-1" }, TRe = { class: "card-content px-0 py-1" }, $Re = { class: "field m-0 px-2 py-2 border-b flex flex-wrap justify-end items-center gap-2" }, CRe = /* @__PURE__ */ ie("label", {
  class: "label m-0",
  for: "predefined-views"
}, "Predefined views", -1), kRe = { class: "select" }, IRe = /* @__PURE__ */ ie("option", { value: "" }, "-", -1), MRe = ["value"], NRe = { class: "panel-block is-justify-content-space-between" }, LRe = { style: { "flex-grow": "1", display: "flex", "flex-direction": "row", "align-items": "center" } }, ORe = {
  name: "TableList"
}, PRe = /* @__PURE__ */ nt({
  ...ORe,
  props: {
    datamodel: {}
  },
  emits: ["toggle-table", "select-viewport", "close"],
  setup(e, { emit: t }) {
    const r = e, n = $e(!0), o = $e(!1), s = $e(""), a = $e(r.datamodel.tables);
    Dt(() => {
      a.value = a.value.sort((c, d) => (d.count ?? 0) - (c.count ?? 0));
    }), br(s, (c, d) => {
      o.value ? a.value = r.datamodel.tables.filter((h) => h.name.toLocaleLowerCase().indexOf(c.toLocaleLowerCase()) > -1).sort((h, p) => (h.count ?? 0) - (p.count ?? 0)) : a.value = r.datamodel.tables.filter((h) => h.name.toLocaleLowerCase().indexOf(c.toLocaleLowerCase()) > -1).sort((h, p) => (p.count ?? 0) - (h.count ?? 0));
    }), br(o, (c, d) => {
      c ? a.value = r.datamodel.tables.filter((h) => h.name.toLocaleLowerCase().indexOf(s.value.toLocaleLowerCase()) > -1).sort((h, p) => (h.count ?? 0) - (p.count ?? 0)) : a.value = r.datamodel.tables.filter((h) => h.name.toLocaleLowerCase().indexOf(s.value.toLocaleLowerCase()) > -1).sort((h, p) => (p.count ?? 0) - (h.count ?? 0));
    });
    const l = (c) => {
      const d = c.target.value, h = r.datamodel.viewports.find((p) => p.id === d) ?? null;
      t("select-viewport", h);
    };
    function u() {
      o.value = !o.value;
    }
    const f = (c) => {
      n.value = c, r.datamodel.tables.forEach((d) => {
        d.isShown = c;
      });
    };
    return (c, d) => (we(), Te("div", ERe, [
      ie("div", xRe, [
        RRe,
        ie("p", ARe, [
          ie("button", {
            class: "button is-light",
            onClick: d[0] || (d[0] = (h) => c.$emit("close"))
          }, [
            Ee(Pe(as), { class: "icon" })
          ])
        ])
      ]),
      ie("div", TRe, [
        Fr(ie("div", $Re, [
          CRe,
          ie("div", kRe, [
            ie("select", {
              id: "predefined-views",
              onInput: l
            }, [
              IRe,
              (we(!0), Te(lt, null, pr(c.datamodel.viewports, (h) => (we(), Te("option", {
                key: h.id,
                value: h.id
              }, pt(h.name), 9, MRe))), 128))
            ], 32)
          ])
        ], 512), [
          [Ea, c.datamodel.viewports.length > 0]
        ]),
        ie("ul", null, [
          ie("li", NRe, [
            ie("div", LRe, [
              Ee(Pe(bRe), {
                class: "icon",
                style: { "margin-right": "5px" }
              }),
              Fr(ie("input", {
                type: "text",
                class: "input",
                "onUpdate:modelValue": d[1] || (d[1] = (h) => s.value = h)
              }, null, 512), [
                [zo, s.value]
              ])
            ]),
            ie("button", {
              onClick: u,
              style: { "flex-grow": "0", "margin-left": "5px", "margin-right": "5px", width: "35px" }
            }, [
              o.value ? (we(), Et(Pe(pRe), {
                key: 0,
                class: "icon"
              })) : gt("", !0),
              o.value ? gt("", !0) : (we(), Et(Pe(gRe), {
                key: 1,
                class: "icon"
              }))
            ]),
            Ee(AA, {
              style: { "flex-grow": "0" },
              modelValue: n.value,
              "onUpdate:modelValue": f
            }, null, 8, ["modelValue"])
          ]),
          (we(!0), Te(lt, null, pr(a.value, (h) => (we(), Et(SRe, {
            key: h.id,
            table: h,
            onToggleTable: (p) => c.$emit("toggle-table", h, p)
          }, null, 8, ["table", "onToggleTable"]))), 128))
        ])
      ])
    ]));
  }
}), DRe = {
  name: "GitHubLogo"
}, FRe = {
  href: "https://github.com/zazuko/SPEX",
  target: "_blank",
  rel: "noopener noreferer",
  title: "Github repository"
}, jRe = /* @__PURE__ */ ie("svg", {
  class: "w-5 h-5 opacity-100 dark:fill-white hover:opacity-70",
  "aria-hidden": "true",
  viewBox: "0 0 16 16",
  version: "1.1",
  "data-view-component": "true"
}, [
  /* @__PURE__ */ ie("path", {
    "fill-rule": "evenodd",
    d: "M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
  })
], -1), BRe = [
  jRe
];
function qRe(e, t, r, n, o, s) {
  return we(), Te("a", FRe, BRe);
}
const WRe = /* @__PURE__ */ ni(DRe, [["render", qRe]]), URe = {
  name: "ZazukoLogo"
}, HRe = {
  href: "https://zazuko.com",
  target: "_blank",
  rel: "noopener"
}, zRe = /* @__PURE__ */ rD('<svg class="h-8 dark:fill-white opacity-100 hover:opacity-70" clip-rule="evenodd" fill-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="1.41421" viewBox="0 0 768 260" xmlns="http://www.w3.org/2000/svg"><path d="m2137 3767c1-1-44-1-42-1h240c6-2 12-7 12-14s-5-13-12-14h-195c-35 0-63-29-63-64 0-31 23-57 53-62 2-1-14-1-13-1h223c7-1 12-7 12-14 0-8-7-14-15-14-80 0-161 2-242 2-16 0-27-17-31-30-21-62-34-144-80-190-121-121-165-296-94-456 66-149 211-240 374-241 336-3 529 388 328 654 16 21 25 47 25 74 0 65-53 119-118 119-66 0-119-54-119-119 0-66 53-119 119-119 19 0 37 5 53 13 175-233 5-574-287-571-143 1-270 80-329 211-62 140-23 293 84 399 56 56 66 131 90 204v1h227c35 0 64 28 64 63 0 31-23 58-53 63-2 0-32 0-34 0h29c-2 0-4 0-6 0h-199c-7 2-12 8-12 14 0 7 5 13 12 14h194c35 0 64 29 64 64 0 31-23 57-54 62-1 1 27 1 25 1h-29c-2 0-4 0-6 0h-188c-6 1-11 7-11 14 0 8 6 14 14 14 21 0 73-1 94 0 206 15 363-55 512-199 135-131 211-315 211-502 0-69-10-136-29-200h-1c-25-86-67-167-123-238h-2c-85-108-201-190-335-233v-3l-1 2c-34-11-69-19-105-24-3 11-8 22-15 33-37 54-110 69-165 33-23-16-40-39-48-65-333 56-587 346-587 695 0 89 17 178 50 261 14-7 30-10 46-10 66 0 119 53 119 119 0 65-53 118-119 118-65 0-118-53-118-118 0-30 10-58 30-80-38-92-58-190-58-290 0-374 273-685 631-744 0-2 1-5 1-7h2c3-15 9-30 18-44 36-54 110-69 165-33 29 20 47 50 51 82 43 6 85 17 126 30v1c77 26 149 64 213 112v-1c70 53 129 115 176 186h1c80 120 126 263 126 418 0 237-111 459-301 603-205 141-324 151-565 147-35 0-64-28-64-63 0-31 23-58 54-62zm183-1327v-1c1-1 1-2 1-3l1-1v-1-1-1l1-1v-1-1l1-2v-1-1-1-1-1l1-1v-1c0-1 0-2 0-3v-1-1-1-1-1-1-1-1-1-1-1-1l-1-1v-1-1-2-1l-1-2v-1-1l-1-1v-1-1-1h-1v-1c-5-14-14-27-28-36-32-22-77-13-99 20-3 5-6 11-8 17v2h-1v3h-1v5h-1v23l1 1v4l1 1v3l1 1v2l1 1v2l1 1c5 13 14 24 26 32 33 22 77 13 99-19 3-5 5-9 7-13zm234 910c-7-7-15-13-23-18-10-5-21-7-32-7-39 0-71 32-71 71s31 71 71 71c39 0 71-32 71-71 0-17-6-33-16-46zm-905 233c40 0 71-32 71-71 0-40-31-72-71-72-39 0-71 32-71 72 0 39 32 71 71 71z" transform="matrix(.14637844056 0 0 .14637844056 -192.39293319 -322.90052908)"></path><g fill="#ff441c"><path d="m3509 3401.22c-4 5-6 10-6 17 0 3 1 6 2 10l6 9c2 2 5 4 8 5s7 2 11 2h417c7 0 13-2 18-7 5-6 8-12 8-20s-3-13-8-19c-5-5-11-7-18-7h-343c-4 0-7-2-8-5s-1-7 1-9l371-443c4-5 6-11 6-18 0-3-1-6-2-9s-4-7-6-9-5-4-8-6c-4-1-7-2-11-2h-417c-8 0-13 3-18 8-6 5-8 11-8 18 0 8 2 14 8 20 5 5 10 8 18 8h342c3 0 6 1 8 4 1 3 1 7-2 9z" transform="matrix(.12790089092 0 0 .12790089092 -128.22109287 -266.58431113)"></path><path d="m4479 3418.22c0 7 2 13 7 18 6 6 12 8 20 8 7 0 13-2 18-8 6-5 8-11 8-18v-251c0-77-27-142-81-196s-119-81-196-81-142 27-196 81c-54 55-81 119-81 196s27 142 81 196 119 81 196 81c32 0 63-5 93-16 29-10 56-26 81-45l36-29c2-2 6-3 9-1 3 1 5 4 5 7zm-224-474c30 0 60 5 88 17 26 12 50 28 70 49 21 20 37 44 48 70 12 28 18 57 18 87s-6 59-18 87c-11 26-27 50-48 70-20 21-44 37-71 49s-57 18-87 18-60-6-88-18c-27-12-50-28-71-48-20-21-36-45-47-71-12-28-18-57-18-87s6-59 18-87c11-26 27-50 47-70 21-21 44-37 71-49 28-12 57-17 88-17z" transform="matrix(.12790089092 0 0 .12790089092 -128.22109287 -266.58431113)"></path><path d="m4597 3401.22c-4 5-5 10-5 17 0 3 0 6 2 10 1 3 3 6 5 9 3 2 5 4 8 5s7 2 11 2h417c7 0 13-2 18-7 6-6 8-12 8-20s-2-13-8-19c-5-5-10-7-18-7h-343c-4 0-6-2-8-5-1-3-1-7 1-9l371-443c5-5 6-11 6-18 0-3-1-6-2-9s-3-7-6-9c-2-2-5-4-8-6-3-1-7-2-11-2h-417c-7 0-13 3-18 8-6 5-8 11-8 18 0 8 2 14 8 20 5 5 11 8 18 8h342c3 0 6 1 8 4 1 3 1 7-1 9z" transform="matrix(.12790089092 0 0 .12790089092 -128.22109287 -266.58431113)"></path><path d="m5609 3444.22c8 0 14-2 20-7 5-6 7-12 7-19v-502c0-7-2-13-7-18-6-5-11-8-19-8s-14 2-19 8c-6 5-8 11-8 18v272c0 27-5 54-16 79-10 24-25 46-43 64-19 19-41 33-65 44-25 11-51 16-79 16-27 0-54-5-79-16-24-11-46-25-64-43-19-19-33-41-43-65-11-25-16-52-16-79v-272c0-7-3-13-8-18-6-5-11-8-19-8s-13 2-19 8c-5 5-8 11-8 18v272c0 34 7 67 20 99 14 30 32 58 56 82 24 23 51 41 82 55 31 13 64 20 98 20 28 0 56-3 83-12 26-8 49-21 70-38l35-27c3-2 6-3 9-1 3 1 5 4 5 7l1 44c0 8 3 14 8 20 5 5 11 7 18 7z" transform="matrix(.12790089092 0 0 .12790089092 -128.22109287 -266.58431113)"></path><path d="m6162 3439.22c4 4 10 5 16 5 4 0 8 0 11-2 3-1 5-3 8-5 3-3 5-6 6-10 2-3 2-6 2-9 0-8-3-14-8-20l-253-285c-2-2-3-5-2-7 0-3 1-5 3-6l252-163c7-5 8-12 8-21 0-3 0-6-1-9-2-3-4-7-7-9-2-2-5-4-8-6-3-1-7-2-11-2-5 0-9 1-14 4l-363 236c-2 2-5 2-8 0-3-1-5-4-5-7v-470c0-7-2-13-7-19-6-5-12-8-19-8-8 0-14 3-19 8-6 6-8 12-8 19v764c0 8 2 14 8 19 5 6 11 8 19 8 7 0 13-2 18-8 6-5 8-11 8-19v-210c0-3 2-6 4-7l93-61c4-3 8-2 11 1z" transform="matrix(.12790089092 0 0 .12790089092 -128.22109287 -266.58431113)"></path><path d="m6802.94 3171.21c0-39.08-6.34-76.05-21.12-111.96-14.79-35.91-36.97-67.59-64.43-95.06-57.04-57.03-125.69-85.55-207.02-85.55-80.27 0-148.92 28.52-207.01 85.55-57.04 58.09-85.55 125.69-85.55 207.02 0 81.32 28.51 149.98 85.55 207.01 58.09 57.04 126.74 85.55 207.01 85.55 81.33 0 149.98-28.51 207.02-85.55 58.09-57.03 86.6-125.69 85.55-207.01zm-292.57-235.53c32.74 0 63.37 5.28 92.95 17.95 27.46 12.68 52.81 29.58 74.99 51.76 21.12 21.12 38.02 46.47 49.64 73.93 12.67 29.57 19.01 60.2 19.01 91.89 0 31.68-6.34 62.31-19.01 91.89-11.62 27.46-28.52 52.81-49.64 73.93-22.18 22.18-47.53 39.08-74.99 51.75-29.58 12.68-60.21 19.02-92.95 19.02-31.68 0-63.37-6.34-92.94-19.02-27.46-12.67-52.81-29.57-73.94-50.69-22.18-22.18-39.08-47.53-50.69-74.99-12.68-29.58-17.96-60.21-17.96-91.89 0-31.69 5.28-62.32 17.96-91.89 11.61-27.46 28.51-52.81 50.69-73.93 21.13-22.18 46.48-39.08 73.94-51.76 29.57-12.67 61.26-17.95 92.94-17.95z" transform="matrix(.12790089092 0 0 .12790089092 -129.98018937 -266.58431113)"></path></g></svg>', 1), GRe = [
  zRe
];
function VRe(e, t, r, n, o, s) {
  return we(), Te("a", HRe, GRe);
}
const KRe = /* @__PURE__ */ ni(URe, [["render", VRe]]), YRe = {
  name: "SpexLogo"
}, XRe = {
  width: "100%",
  height: "100%",
  viewBox: "0 0 284 284",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "xml:space": "preserve",
  "xmlns:serif": "http://www.serif.com/",
  style: { "fill-rule": "evenodd", "clip-rule": "evenodd", "stroke-linejoin": "round", "stroke-miterlimit": "2", fill: "rgba(0,0,0,0.3)" }
}, JRe = /* @__PURE__ */ rD('<path d="M283.465,55.991c-0,-30.902 -25.089,-55.991 -55.992,-55.991l-171.482,0c-30.902,0 -55.991,25.089 -55.991,55.991l-0,171.482c-0,30.903 25.089,55.992 55.991,55.992l171.482,-0c30.903,-0 55.992,-25.089 55.992,-55.992l-0,-171.482Z"></path><clipPath id="_clip1"><path d="M141.732,34.873l92.543,53.43l-0,106.859l-92.543,53.429l-92.542,-53.429l-0,-106.859l92.542,-53.43Zm0,18.209l-76.773,44.325l0,88.65l76.773,44.325l76.773,-44.325l0,-88.65l-76.773,-44.325Z"></path></clipPath><g clip-path="url(#_clip1)"><use xlink:href="#_Image2" x="49.19" y="34.873" width="186px" height="214px"></use></g><defs><image id="_Image2" width="186px" height="214px" xlink:href="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQIBAQEBAQIBAQECAgICAgICAgIDAwQDAwMDAwICAwQDAwQEBAQEAgMFBQQEBQQEBAT/2wBDAQEBAQEBAQIBAQIEAwIDBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAT/wAARCADWALoDAREAAhEBAxEB/8QAHgAAAgMBAQEBAQEAAAAAAAAABAYDBQcIAgkKAQD/xABAEAABAgQDBQUHAgQEBwEAAAABAAIDBBEhBTFBBhIiUWFxgZGh8AcTIzKxwdFS4QgUYvFCgpKiCRUWJENTcmP/xAAfAQACAgIDAQEBAAAAAAAAAAAFBgMHBAgCCQsKAQD/xAA3EQABAwQCAQIFAgUEAgIDAAABAAIEAwURIQYxEkFhBxMiQlEVMggUcYGhCVKRwSMzYuGx0fD/2gAMAwEAAhEDEQA/APjJNymdv3X2TUay6So9fOEqTspY2pflkjFCttH40jYSjPSlK2zzRqPWTBFkdbSbPyvzWRyPWTHEr9JTjQzDedL2RljvJqbLfJLXA5XqG7LwK/Hj1VjWiX0Mo6G6vqqx3j1VoWeUDhHQzp5FY7x6q1bLJBxtHQnZX8Bmsd6tiyV/27VjDNdajzKxn9q3bHVGso2F/hWM79yuGxP6VrLH8fVYdb9yt+ynNI/2/wC1awr0/wDlCJHSdIIyrqXbWnU5pXnO7TtbG5IKYpVtSEnz34BVkWqmSQmaUh5JFuFXZVoWehoEppk4VaJDudfGVa9mik+KapODWlkhXKTjKtmyw840muUgi3RV/cpXe1bdng6GlaE7ooO5JMyvknKdKbABgdBDudQdUsyq/anAycIdxoOuiXpNftTAYGFC45k/3S/JkHala31Kh33c/JCjXP5UixGbk6VtZd5tCvleU9Hk/hKk5J03rWKMUK/uj0aRnCUZ6T+a1e6qNx66YosjPqkuflKb1uxHY1ZMkSR1kpIxCUpU0TBGrBNEORsKiHC6h50KIEZCerRMwQMoyE5QOGsK07PL+obVhDdl9qBYrhkK2rLKyRtHwnEc6c81juGQrgscjY2rGERao7KZhYz+lclirZI2rCFanU3WK/tXRYKnkWhW0vp2flYNXtXVZP8A1H+ytYGh9ZoPKP0lPEAdFX8q27fEUSlPd2E/WpgLgUzSbK0tqki5VMZwrPs9HpNUnDy/CQLlWwCVbdljE4TbJQcrfhV5cpHZVv2SHnGk3yMCu7ZV1dJWyrjsUDo4TNCYIbOSr64Sck7VpwY/yaYHqV4c7MlKUuR2iYGNBDudqUsSpHama3AQ7nalLkmT2pWtzsqBztT3BL8mSpe9BQ755BCzIOVJ8v3SHOSWdB+670aFdeT3Hk9JUnJL5hTyuEYoSEfjSekoT0nnVvbyRuhX62mKLJ6OUmYhJfNZHY1fraZIknraRsRk/mtTuTDFr9JphyekiTkuYbyaUGtkwUKge3Cb7fK8XAhQQn9fNSPHqrPss7ONqxhOy86myxnjat+xTMgKwhOyy5LFcN4V0WGVnx2rOCeVe0rFeNEK7LBXz4qyhZ94WJU9FeXHquS1W8sbgLCrDeVelidmjj+iuZcXA7EClnAT/bfRMUo3w9FJlwdjIKsaz084wmuSh13fVUgXWt2rbsdDPjpN8jCrT1VVxdpGAVcthiE+Ok5yMCu7bVVrdpWMq67BAz46TlJwA0AkeIVaXWXs4KuqyQAxocRpHPdp4pEmye03MbgIV7q62CVJkntTsb6lDOdW+QCWJcnana3Oyh3u1OQyS5Lk+6lA9Ah3Orc/2S/Ik+6ma3Cj3x1Qwyd9rkoJuRz4e6i706EheStHlY9Uqzsjnb1yRihIR6NK90oT0jmCEajyPRMMWUkvEJH5hu+OiPxpA1tM0SV0kTEpH5rFMMWR1hNMKV0s+xSS+bhPgmSJI903wZPST3NMKIQdCjjSHtyn+zTi1wGUZCdl/aigeNYVx2Gdtu1ZQj+RqsR49Vd/HpmfEZVnBP8A9LFeNq9+NychuFaQqeSwqnSv3jVb9quJb5u2qwqyv/j5yz/hX0uKu70vTTohWVbGg4JTPJMy7aV5JEuVTAO1aNkpE+Ok4yEOtLX5Kt7tX2Vc/H42caTth8H5bZ9yq+7ytnavPjsLPjpPOHS/y2VV3mbs7V8cct2fHSZQBDYAM6UVZ3GX5ElWvFoClTDAh3u011SZNld7Wc1uShnu8B5pTmSu9rIa3KFe/U5aBK8uV2pgPQIdzq3OX0S5Jk97UzW4UDnV6BL8mV7qVrc7Ki3x1Qz+b91J4j8J1m5CteHuyXexRkryKo8v0StOYfna6L0JPujsaX7pQnsPrvcPlkjVCT1tMMWX1tJWIYf81r9iPRpKZokzpIuIyB4uHyTFEk77TVCl9bWeYph9nVCZocnpOEGXjG1muKSRY4uAv6smmJXDhgp2t0zBByqmE+h3Tancs149VbPH7jnx2rSE7LNYjx2FfHHJwPjtWsB3d1F1hVAthOMy8lu1bQTWnl4LCqDGVsVxWvnxV3KmpHYh9fQytjeNOzT/ALBMEoN4ivO6WrgcNJVq2lvkQm6QZXdsOaru61QAVcHH6GS1PWHQa7tvuqqvEjAccq+eNw/Lx0n7DZb5bevFVHepmA7a2E41bc+Ok9ykEQ2bxtZVHeJxJIBV/WSA2jSD8bUj3687BV7Pl7O0zNb6BCPdpXtKTZsvvayWtzoIV7/D6pRmS+9qcD0CFc7U9wSxKmd7UzW4UDnanuCXJMtTNZ6lQOdXOwS/Il+6lAJ6UW+OqGGWFz+X7rdZrDs6N8vXNd7tGUvH9jzfTKWJzDs+GnWmSL0JPujsaZ65SjPYb83Dra1UZjyuto/Fm9bSZiGG3dw3zCOxpaZIk3raRcSw35uFMMWUNbTXCm9bWdYrhvzcOvqyZ4crracIE0ZG1mOL4ceOjTrfNNkKV1tPFumdZKzaagOloxsQK8qJqo1BUYrIslw8Ht3pTQH9fuo6jdK+eMXEEtBKuIDsr6f2WDUHa2R4pO8vHauoBrTtGqwaq2d4jIz47V7KGpHYhsj9uVtDxZ3lS/t/2maSbUi3YlK6OwCrjsrPItTvh0KtK0VXXuv4g7V6cajeRaFoeFy9d23lRU3fpYGRlbHcUt5cWkhaRhcpZpI68lSt/uGC7a2Y4paNNJCYnkAboyGaqW5zcknKtmjTDGBrUE9/ifJIc+b3tZjG+gQb3jnb6pLnTe9rJa30CFe/n3BKUyaN7UzW4/qhnP53PJK8qb3tTtbjZQ7n6m55JckzFM1mdlQOfzPcgUiZ3tSgY0FH7zp5oYZ4z2uXg5ddTWG2PDTuqu+GjMXjmUJnulucwzOrfAXRahL90ajzSMbSpO4Wb8Nq8skZoS/dHo04a2k6fwuu9w539etUcjTPdMkWd1kpFxLCvmq1MEWZ1tNMOf1tZ1iuFfNw30NM0zw5nW04wJ/W1mOM4VZ3CRnVNsGZ1tPFtnjW1kOOYYRvndoRqnW3ywcDKsK1TxkbSZDJhvLDm05eu5HXAOHkFdXFrrhzW5VzAfkc1g1G4W0HDrkHFu1eyzrU08EOqhbY8Kl+RZhMUnSo7EKkftW3fDnh1D+3/YTbh4qQKapKvD8NOFe/HaXk5q0PCYNd235VN8hkhudrY7iEIvLNLUcHlK7llRHI7gG+RJW1nDLSX+H0rRZeGIEIfqIy5Kib7cfN7trZezwGxY4BG1FEf+3VVjc5/eCmBjfVAxImd+080gXGeN5KymM9B2g3xL9dBoElzp+ztZLW+gQrn8jU6lKUyf3tTtbjpDOfy7yliVO91M1mNlDuicvEpelTwPVShpKHdE/uUuSrls7UzWfhRe8H6j5oOZ4O8qT5fuvoZM4VWvD5LvsozsdFeMpRmY2ClubwrPh8rIxQne6L0J3ulicwnM7vr1RGqE73RyNP90oz2EfNw+SOR5vW0wRbj1tJGI4OTvcHkj8Wd7poh3EDG1nuK4NQO4OeiZYc7rJTdAuWxtZjjOC2dweVKJtgz+tp3t1y2NrHsfwY8fBzOSd7dOyRtWParj+3axTGZB0rFMRrbV4k+QZIqs8SrX4/dCyo0goSVeLHyU1Zq2g4ReA4sw5Mco7JC6wW53AZ4eWbTPIXI+iDyuv+Vu9wN/zKH9v+wnjC27xb9VXl+qeLStlOK0C+o1argktvblvwqA5RODPLa2z4LbDULNLYMGk9xoe4UAFVrdym6jLmgrc7hNkDKbarxoK6ixNNFR94uOztW1TZrA6VfFiZ+H7KsrpctnazGMP90BEiZ9PAJBn3LZ2spjPwg3xOtvMpLm3H3WS1n4Qr4n9glSXcQNkqdrfQIV8Xv+gStMugGcFTNpod0Tv+gSvKune1OGflDuid58kuSbnvtTNYovef1DyQv9S91z8Gr6xTGFf0+IXfxSn+68VmjPx0VQzOE2PB1yy0RWjcPdFaNwB0Sl2bwb5qMHhZGKFwxjaL0Lh+ClSdwXPg8qo5GuXW0cj3LHqkyfwM0PBXuTBFuI1tMcS54OikLE8Ds7g7hZMkS4jI2myDdetrM8YwAkPqw9lE1wbjsbTtbrsARgrIMewB1H0ZXuyTrbrlsYKsO03cZG1gu0+AENicHPRWNaLiPp2rYsd2BxtY4+E+UmHQnAjiq3qnhrxXpB7VsPwa/BlVjCVdycQVF6+dVgV2rez4aXdtQ08FOGH3cBXNApX7SuxD4aV/mUB/RaRgcIuLBSqqblMgU2uW4HBohrVGLcdm5HfLLctFqxzO7CmHbW9/w1sBrGngfhaiGtgQhDFBQXWrfJLv5vccrcC2QmxI7aLR0gI0Wnq6pm83bZ2jdOmq2JF6+uirG53cDIBWYymgXxev4SFcLrknay20/wAoN8b1qkudeGtztZDaZKDfF9ZBJs28g52shtNDPi9fGwSnLvHe1O2mh3Rete3JLcq7Z9VO2moHRa+qBAZF1znakDAovef1DyQ03Xfak8Hfhfb+NhBvw1Glrkr6CKdw914jFOcR6qmj4Pnw+SI0rh7ohSuOD2qOZwU34PAInRuXuidG5e6XZvAya8GfRGKF0wRkozQuuPVKk7gFd7g7wEcjXXraOxrqNbSRiOzjjvD3Z7gmWJdxrJTJEu4bjazvFtmyQ4+78AmuFdhkbThb71gjaybHdmCd74Z10TnbruBjasC1XwDG1g21GyzqRKQz/pVi2i8DI2rVsd+GR9S5f2x2diwHPishneYSQaUyVt2O5sqgMcVfHFb8G1GODtpJkYpJFbEWOlDkj0lmtLfD4R8lbVfSHl+E+YW7ecw+skuTdMcu1v4PSRJjsxvS2XZeVMV0O2o7lr7zyeKDH7XYh8K7W6VVp4HeF0dgMk2WlhFeBvEDdWj3PuQA1HsDl2afDjjzYMBsmo3fojpiPndawcivrcuHkrfpUlURY+d1TV5voydojTpKuiR+vRVldL61ucuWYymgIkx1VfXLkLd4cstlFBPj9Uizr+Dn6lkspIR8fP6pRmXzOdrIbT9EO6N18LnxS3JvWT2pm01A6L1+5QGReM+qkFNROi+ickHrXb3UoplePe9WrA/Vl+/L91+h+JhF6bmWlKL6GGXH1yvDZp3Deiq6LgxI+XXlVZlO4+6y6dy91Vx8DrXg1rlQlZ1O549VnU7kPyqWY2frXg7bWoiVK7Y9UQpXTH3JfmtnC4H4da9EVoXgD1RWhd8eqVp3ZgnepD8kdjXrB/cjka9+P3JJxLZPeDvhZ60TJCv2CPqTNCv4BAys0xrYxzmupCz/AKaFOVv5CMjLk523kQBB8lie0mw7i2J8E3B0VhWrkLcg+Ssuy8oAI+pcu7dbBvLI3wb3yard4/yMeTfqV6cW5W0OaPJcbbQ4PHwLE3B7C2DFeQKjIq8rbOp3CIMH6gFuj8I+aNoTqTXP0SPVX2BvD3Mv0Qu5/RTcV3ifw4XVtzjUy050F1FsBhJmDCcW8IG8SchzWlvxf5DTgMqAux2u7L+HjiNS5PpVC3WitqmIzITBDZZrRutC65ubcsaatRxf+V2NwITI9FtGmMNAwFQTE1nda0ci5WzLsuR2lQVPGmxehVL3rl9ME4ciNOPpVkWazuqtunLQ4n6lnMjoF8z1SFP5P5Z+pZTaKFdH6/slOXyPJP1KdtFQOj9ful2Rf8/cpW0lA6OOdfNBK97ye1KKXsozGOlfohVW85Pa5hn5URi9R9ShtW759VzFMfhefe/1eSxv1Y/lcvln8L9QbsHN6sPgvoqbcMbyvCSbPOO0K7Bq14LHpVStuQzklTNuR6yhH4HpuZ5Gl1kMueD2sht0I7KBi7P1qNzvospl2x9yyWXcDeVXRtm6/wDj8qrMp3jHqs2nesfcqiPssTX4fkiFK+4PaIUr7jtyX5vY7er8Lnk1FaHIvH7kVociA+5KWIbBmJvUg1/y5JgicpDMfUj8TlAZ09ZvjXs0dFDqS9ag5MzThbuZhhB80423mQpkEuWCbX+yGLHhxd2VN6/4FaNi57SY4eT1anH/AIgspObmp/lcE+2T2Hzn8tNRIUnEDmguaQw1BzC2T4N8QI5qsa6oMf1W1/w2+KNBkin5VfUeq432el5mUxV2FzbHw5qXj+5iMcN2vI99ldd7r0alsdOpHLC0kH+y+if+ADnFDl9alApvDqgAGM/0XdWzMmzBcElzEAbMTEMPIdm1tLeOa6c/4ivijEo3SvGbVGGkjv1/+l9dHwI4OePcQjVq7MVqrQfcNI1/z3/woJ3FG1dx1Nea6zOb/FaIKj//AC5/uti40FxHSXo+JAk31WtPIPigyq52Kmv6oxShEeiqok9WvEqmufPvmE/Ws9kXCDfOV1STN5mHknzWQ2PhDumuuaW5HKw7P1KYUMKF0xfNBq3JfL7lIKKiMfv60QuryDP3KQUl4Mfr50WBUvmfVchS9l4MbqPqsR96z6rkKeF5971p3LFfeM/cv35fuv5749fAKH9WH5X74BfrmOGQjy7xVfR3+pY6K8FH+eevJwqHoR4UX9+p49V/fzz14OEwznumvrkv0XUA7d/lchcaoXn/AJNB5NXMXgDef8r9/Uqo6UZwKA7Ms8F/frjf9y5i6VBvCjds9LHN0MdoK5DkLW681zF2qAYUTtmJR4u5lOgK5DlFNv3qRt5qs9Chomx8i+xfDv0I+y5DmVNh/wDYFM2/yBsZVfG2Dw2KDV8P/SfrRTD4hUKIz80f8rKp8omU9gFUU37LMFmg4RIkC4/TVZDPjBEh7dXAx7olH5zcaBy0FZttH/DfsjjsGJDmZmWYHgh29COvcikX+K6z8ZIrSJgAb7pytHxjv1rqNfRY4491wTt5/wALTEdvfaHgU/7IdqNm37QOfMR5nZvGTMYdAxxkvLxpmHLwplkF7GRosSEyDDMbdh70wN97BxBL+OH+vN/Dt/DZ8I7s7nFKZPlFgp0GwqdOo5lWq4Uw+r82tRaKNMONSqWOfV8GH5dKo7DT32/6I/8AHFbLb/GjxHgXxWjV6fH5tSoyRIptFT5Ip0alVjns8mnwfVYyiXNyWfN8g12PE8ue0f8Ahz/iI2HxKaw7an2ez2Ex5WIYT4bY7I8Ju6acL28JFrEWXQnyr/VO498ZZNS72OR40qpJAJ3ve/f8r00uD/Gj4Lcmt9KRxy7sqUyBj6S3AxoeJwRj8YWDz2xO3ks4iZwWYhEfMHHJVVM/iTbeHF4r5z7q3YnKuI12h1CU0hUEXZvaZh+Jh8VtOaCVfi5/NHPzf8otTvlid/66wKCfgmOD5pOI3vosN3xCNU/v/wArKbdbSf21QhnYTi4zlnHTKqx3c0NT71MLjbT09RHDMTGcBw71EeVl33KQT4J6evBw7ENYLvquB5IXdOUn87C/3heDh88M4ZHbZcf18u+5folxDsOXn+Rnv/WPH9lxN8J9VyEqL0HBef5Gd/8AWfE/hcTec9uX7/NRvyv5/JTn6P8Acfwvz9Xz9y/f5mh+V/v5Kc/R/uP4X9+rH/cv3+ao/lfr096PVV9GTr6R25eCJ4D1X89+B+5/dY77+R9y/vALyZjvCxX8iI+5fvg1eDMch30Cw6nJiM/Uv0MHovJmSNfOhQ+ryrx6cuXhn0UTpo6uHfdC6/MPH7lyFI9gKJ03S9T10CByudeH3/5XMUSh3ztzeumdSlad8R/lg/8Ak/ypGxxnaDiYjT/F36n1dV/d/i06g0n5n+VO2KD6KqmMWIrR/bQqjeVfHevQa5tOqc/1WZTh59EtzuLRSHcZHetSPiD8ar3Op1A6QQ38An/KLR4Lc9LX/YJKvh7SwsciV96xwbANbsbXMdv4XUR/FVy6RySE631ahLM9LtJ/07+LG1c7ZzN7cVBph9Q32/r/APjC769pHst2c9qGADFJjDpaZnjBAnt+C174hIp7zLM6nn2rro4zy658Quf8nSqltPP04PQ/H/6/+l9ivwF+Mt1oW2OachzXgDor5d+1D+EvBjFmYklh0Npq4+790ARfTmttuI/GecGNZXqk9eq7IuC/xC3RlNjJdYn3yuI9rv4bYcnEi0kGihNPhq/bL8VHSGgGp/lbR8c+N75TG5q/5WD4z7D2y5fSTAof0KxoPxAdUAPn/lW5bPisawB+Z/lZviHsl90SP5b/AGppjc1c/H1p3h/EU1Pv/wApQm/ZruV/7el/0I5R5YXb8kyR+c+YH1pdmPZ/uZQKU5tRSlybP3I1Q5iXfcqaPsPSo9yf9NlnU+Q5+5E6XKs7LlWRdjQ0Ee68s1lsvwP3LOZyYHB8kBE2SpUe7p/luFlNvWfuWY3kQIz5IJ+y1P8AxnvGSnbd8+qymX/X7kP/ANLj9DPBS/q/uVL+uj/cv06GIMzXtOq+h2revdeFCKa8GMNPzVDqt+xvyXMUl4MY6IVX5CB9y5ikFC6Na7h9UFkclx9y5hgULpgaVKXpXKSB+5cwz8BDumTpQdl0rTeWlufrUgp5Qr5rma9qR7lzXwBPmpW0UDFnKa66GgVX3vnzmg4esltEKrjTbjrQKm77zaTI8g1+AsplFVUaYN76qm75yN58iXbWfSoqtY185MQ4La8TuKmgWvnM+ROFF58kz2C1PuVwpxGDsjP9F1j7LZNsn/L7raEU6UXXp8Wp7ptV/kfVdzv8KdkZZqNH5YxoLv8A2ExTdgw4USjob2br2OuHAi4K0w5NCDqhe3RBXd78IOSPi0qbfLWkNt3sRLTbHzMCE10OK3faQK0roo+PX+rQIpVTsLfHifKXGm0hy5E2w9nEtH96Iks0k5O3LhXXZOUVaYBa9X/x7mEih4mnUK5e2s9kkL4jocu0i+TakK3LNzSpoFyvTj/xEqDDXvwf6rnrH/Zc1hfSWFq5sorMtvLy8D6lcln56XgZesixf2dNYX/9vr+iydoXJ/ID6lY1u5oXAfWs7xHYIN3vg9flTNF5FnGHJ0hcuLsfUkud2K3an3XZbsR2hfifVM8XlPlj6krzWx+7vfC8kXo3zONo/Q5LkD6kvTGygBp7rwF0SpXnP3IzR5Dn7lSx9lwK/Dp3VRCnd99opSv2eygP+mf/AMz5rJ/V/dZf67/8l93TFaF9B1e9ne14ieFEY50QWRfCPVcvAlQuinU/dAZN+x9y5BigdGA69c0ty+RYB+pStp/gId8Y80oT+TeIP1KVtPKEfMUyNSkS58qOD9SmFMBAxI5OvnYKt7ryio/IYVO2mekFEi9exV/cbw9+XPdlZDaYCBiRc+ngEh3O76O1lMpqtjRc7qrr3dT4u2s2lTTHszImLHbFc27nZ0yWvXNLtljmgq/fhPx01pjJNRuyQusNiYPu/daEUWmfOq3zqjt/ldu/wQhiJRp4H4XVWyc2YYh3I+y13vtDzLiuyX4e3E0RTwfwt8w6NCxCT/lotCHDgJFd0qr5lJ8av86n6LdHh19Py2AuWW7V7LDei/D1OQsE1Wa7kAbWwNkvRAbtYBj2y4BifDqKkZKybdd9DDlaNsvJwNrFse2Lgxt/4IBv/hpX190+W++1GY+pWPauS1qGPq0sSx7YNoL6QbXpaqfbdyJ2vqVn2jlxIH1LIcY2IDd/4VP8tk7weQl2MlWPbeVZx9SzfEtjab3wq5n5U1RL6HYw5O8HkxIH1JEn9kqV+FQ9iYo969CU2xORZ6clCd2Vz+H22qjVC759UyRr/wC6WJrZkAn4fZayLUbr7o9HvufVVB2ZufhnPsWZ+qn8oiL9rtfUsxQP3X0ASbxjO14voaT0FC6KTbP1yS/KvePuUgZ+VA6LzPcleZftfuUraf4Qz49Ms0oT7+d/UpAwBCPjE5nuGaR7jyBxyA5ShhPaGfE59wCTJt0qVM+RUzaf4Qr4n7DQJWmXDvJU7W+gQr4nXtPJKM+4nB2p2M9B2gokT9vykS5zyM7WUxiHhQzMRmtvStyqwvlwwxxyjtogumy208aWtbNSYYYdByoVr3yucXh2St0fhdZRSdT+ldFbLs3BDWsnKX/MqE+67J/hbQFGiz+y6A2ejbm5fKmqpi7Uw4nAW7XDJXgGbW3YFO0DL9RdVzco+c6W0/EroWNbtO85LQ8TlN6gMRreKgzCWqNR0Svj0Ww9huvk1u1ju0GAir6Mz6WTtbbkRjJVp2y6HA2sdxjAab53L15Zp4hXDONp+t9zOAcrMsUwFrt8GHUUy3U1w7iRg5TjCuZGC0rMcY2VZEDt2GK8qJthXhzcZKdrdyCpT09yyzF9kgN/4XlVN0K9HRyn+28jJxhyzfE9lQC6sIf6U1RLycDBTtB5BnALkhz+y93UZ4iyZI13BA2m6HfTgYck2d2cpvfDNB0R2hc8+qZYt8zjJVEdnbn4Zz5fsiIueu0XF7/+S7AdEAvX8Lvul3nvBXjyhhPaHfGz6+sksTLyd7UgaAhnxSczQeaU5t672uYaSh3PJysEpS7m+pnalazHSgL+Xil6RM91MGY7Q7n5geKX5U33UgaSh3vrUA9p5pZmTe9qdrfQIR7/AA06pQnzTvayGt9Ag4jvE5/hI1ymdrJY3JwFe4NKEva5wuTU1yVV3+cSCMq2eE2cuqte4bK2TAJfd3PE2oqJ5JJLvLC3Z+HtuFMswPwttwAbohilLKguQO8nkre34fU/Cm1bNgkSm7Uqrri3LVtbxet4hpWuYPMkBmed0i3CiCSFsTxqaW+IytQwqcs29QbGuqTJsfOfyr74/ciA05XrGMNZMQzFYBR1bDRQwpTqTvBxVuWu4ZAOdLJMZwcDf4agkitMk5wZx1tPtvnnW1l+K4OL1b30TdDm5A2nOFPOBkrP8Qwi54RnQUHromSLNx6ppiz+slI+I4Kx+9vMy1GaYYs8txgpliXF7MFpWe4ps2071GVHZdMkS6fkpvgXwjAcVneJbN03iIfgEzRbpkDJTnBvecYckaf2eHF8PttdMUa6HW02RL11kpdOz4qeDXoPsioupx2jYvAx2nl0Qmt6dV3xy7t7ryRACelA6Jy8UsS7m5/RUgYB2oXOpmalAK8snsqVrSVC5/M0HJB68r3UoAHSgc6vQIJJlrm1udqBz65WH1S9Kl97UwHoEM99egHmlmZL7U7W40EK9+vcAlCdK0VO1uAvMCGYsUWNAanqUjXSXhpyUatMMyZAbjS0DB5am5bNVRe5efI5WyPDLZ4lmlq+CwqbpAvl2Kmb9WLg5be8HhhhZgLXcFbTc7Kql727Lytx+EsDKbVquEvoWU18qqvZ7dOWx3HKmAFpmFRqbv5SbOp5V6WCTgNK0XDJizbpSmUt5V12GaQG7T3KRmxofu30IIoa3S1Iplj/ADardtE/Q2l3GMLB3zu2zFNURgy+lYlvmnSzDFMLoXcFtLJshy8Y2nGFNx6rPMSwwcXD5Jniy+tpqiTcY2keewyleG1a5I/Hl+6ZI0wjGClCdwwcXDz0qjdCX7o9HmA9FJ8/gzHhw3ADzojkec5vqmCLcn0yNpGxHABV1WDPkmCNcvwU1Qrz1kpYOAXPAc/0hFf1Eo8Lu3HaQC4nM/hd89eW53ZXlPgZ0FEX8vFC60n3UoYB2onOAzuUJryVzULnVuTkg0iTrtSNZ6lQOdW2Q+qCSZKkA9AoHurYZfVLsuSpmtwh3urbQeaWZknvanY31Qr3VNuwJTnSO1PTaXFXeGyx3m2qa3SBd5eiMqyuL23bSRsrRsKgULTS1u9VbeZGiFsvxKAGlgwtMwmHTc7R2lVPe6uQQtpuHxvEtK1DCBTd6CiqW7nLltVxJnjTAWj4YSN2iSJgySr6sL8YWh4bEoWHK+ZSlLZkEK5LHXwAn7D49C2/Q1SxKp5BVu2WXjCeJCYpu3yNEuSaWQQrYtE3Q2mN7GTUGhu4C2tUHBdRqZVkW2ZloBKScVw6pdw+SPQ5XunOFL0ASs8xLDfm4UyxJXQymqJK6BKR8Qw6lTu5dEwxZWUyxpWANpMncOu6jdfFHKEn3R+PL/BSrNyAvwoxQkn8o3Hl+hSzN4cDUboPSiL0ZX4KM0JRGwVRnCGVPBryCICa4ayiInnHa5YLiezku/6rIXl4AAdKJz6WGfPkhlaR7r9URNLkoRXkKVrMbKhc6vYg0iQufegoXOrYd55oHJkFTNbhDvdoO9L0qR3lSsbnZQ73aDvS1Lr9qYDJwvUvD95EBzDcko3CTgFGrVFNeuNaCcsNgAUJVfXSRnO1eHGYABbpP+GQabuncq2u1fJO1sTxaHgtOFoeGMpuZ1+qrC8VM5WyXFKHj4rR8LtloB9FWN1OXLZXjDcMan7D3WYK2oCUnygMlXTZHY8U9Ye/5ezPQJYlN2VbNmqkEJ4kItm36cktymbKtO0SMEJzkY1m+B1S/JpYJVoWmV1tN8lMZCvRApNL1VjW2X0QUTOyzY0PfaNLgLGoVTTd4lPUKVkAhIeIyA4rV7rpiiyMYTVEkkpHn5H5gWpgjyPUFMkWV6JMnpClRu+SOx5OUfjSkpzkhXet2FGaMhHY8nKWJqRzq0orRke6MUJOFUGRHIf6VnfzLvyiIlLhdz62GX1X0D1a68xUAk4CjJAFShdauVK1uFCSSUIr11y70FG52gz1KC166ma3Cgc6g66IHJr+65tGSoHOoK6pflV/dT9aCHNTYZuS3Lr4BU1JhJ16q6kYNN0JNuMjR2rD4/AwGkhO0hC+UX5m4SDca/e1efHYXiG6Tzh0K7fuq8uVXOdq/ONRsBoT7hzaObqbCqri6v8AInK2E4zSx44T9h2Q7FXVzOXLYTjgw1qd5B1A3mRRKsofUVbtndjxTpIPFG8vqlyW36irPtVTGE5yEU0Arl3JflM9VZdrr6CbpKLSl7HwQKTTyFY9rkaCa5SNYXyQOsxWLbJWgmeWih7aG4NiEGrU/F2k82+VjAVdiEmDUgAg3BWRGr40U3xZHRCSJ+Sz4f2R+PXTJFkZ3lJs7JZgt7DTJHKFdH40n0KUp2R+bh/CN0JGUdoSNaStNyQvY/hFqNdGaEhU5kbng1Wd8/3/AMoh8/3/AMr5ykgBfQVWrLzOgAOlCSTmhVauV+qNzqWGepQivWUzW4ChJoKoNIrLl3oKEmtygcispwAAh3Oqa6IBJrLm0ZKlloe+/ep2JZm1+0btkU1qocU1SEHI068vNJNwr5yrdsUMZbpOMhDqQadlQki5VtFXVYIuPHSdcPh5WqPokG41NFXnx6PjxTthzRUWpfNV9cjnKvbjtLHineRy7/ukK4ZLsK9rFpjf7J0kTQN6BLMkfUValqdjGU3SLsunr7oBKb6qyLY86TdJRKFvL6IFJbkFWJbKuAE1ykTL0UErNVg2ytjCaJSL8pqgleng4T9bpHW0yykahCE16eQnqBI6V4N2ND3TyshZyx2QnKDJyAlyfk7utz0RSNXTLGr4wk6dkxe2aN0KyYI9bPqlKblPmBH3RmjWRuPISvNyYFeFGKFfOkaoVyPVUxlLng15LPFb/wDsogK6+WZJJqV9BlasvNXUbnUsM/ohVaspWtxsqI8yhNesuahcanpog1espWtxtQvOnigcir2uaiu4hg1zQGVWwCsmlTLiGjtXMrCyCVZ1fRT5ZYeANJsk4VALUJt1SZOrZyresUTrSbZGHQDL7FJNxqZyrjsMbrScZBlKaU8Cki41NFXTYaOCE44e00aCL6JEuDgCSFdlgp48QnGSH1H2STO2/Kuqyj6AU3yZ+Xtp9Utye1Z1sOQCmuSdces0ElN+nSsG2uwAmmUf8vqiCVm5T9bKvSaZWJ8p5oJXbgp7t9XBATLKRdOaESGaynu31+kxy0XK6EVWJ2t8jpMUrGsBXsQqvTxtOMKRjCLjwmxodaXpfqsam803YTXFr5ASpOymdkZoVkfjV8eqU52UqTb90YoVkdoVkrzUrnZFqNZGY8hUxlLng15IgJBRIVgvkQ51B1X0H1qq83NrcbKhQutWXNRPdWwy16oRXqqRjfUqNxoOuiD16qkUBNKkoLIqrmwZ2p5aGXHeKXpdbtG7ZHNSp5Jjk4Vxa/0SlOrZyFaFniYwMJplId2imXqyUZtXtWxZo2MaTXKM+UWzrTmkydUySrdskfGE2yTLDyKTLg/SuCxUsYTdItpunUZpJnHOcK5LEzBGE2yfyt9cknTTlyuK0jDQmqUNB3pek7P9lYdt9E0SjqEdMkGkNyCn+3HACZpV1KfZBKw0ni3VOslMso+wCESG4OQnmDU6THLRPlv539flCqrU6wK3QymKWifKa9qEVWYJBTnBr4wr6Xi0pfsQ2qz8pxh11fwIgIHWxQqqzBwmqHIxhDzkuHAlorW650KuDgplj1sgbSpOSw4reWSM0KqNx6+e0rzktWvDfVFqNVGaNX1CpjLXNteSzvnFZ4rL4vZ3K+hOtVXnILw91LDPXohdaquTW5KiQmvVUyhcanpog9eqv0DJwvAG84N01QWTVwCsqlT83BgVxLQqUCWplZPFpiYwUyykLI0SnMq9qzrRFORpMsnDuO2pSrNq6KtO0R9gYTRKMuPVEnzKmcq17NR6TVKtoAOZSfPeMq2rJSx4prkm5V5eYSbNd3hW5ZGYwmmUsGjkfuEoy/34Vs2r9oTRKZDt+4QKR/0rBt5wAmOVdl2evqhNYJ4t7sYKZJVwt2evogtYb2nSA/GAmOUfQjO9kLrt0nWDU0Ewyz9PXr8ITVanGDV6V/KxNELrt9U4wq3SvZeJle+SGVGpuhV+ley0XLSqHVqeek1RK/RVu0h7d0696HuHifIJmiV+lUTktnRtvqsyhW9Cj1Gr7pXm5Y3t2IvRqozHrKnMs2p4df0rOFUoh80L4duNBVfQtWqFedIN6UCFVnntTgADAUbzp3lCq7yv1RE0BKEV6h2pWDWURLMqanOt0ClVDtGbbRDnglX8qwEhLEyockKx7XQAATHLMFGjmb9yWJbztWXaaAGEySjRbtSrOedqzLRSGQmWUb8vXuSpMcVadopgYTPKtruDndKE55ycq1bMwHBTRKWoO9KUw9q1bM0DGEzSmQ7fuEqS/wB5Vp2zQATLKuq2nT90Er+hT3AOwExSxy6evshNUaTrAd6pilTUN6WQiuPqKcoLiFfSzsvXrJDKrc5TjBf0mKXcbH1zQmsNlNsJ50Fey7yCPXRDqrQdflN8KocAq8gPy6oVUCbIVQ6V1AiGoWDVamqHVOldy8QkUvY0Q2swA/1TJFqlFxGCIypF1jNJa7CY41UkApdm4Dan1RFKFQlGaNQ6KqPcdfNZvzPZZ/z1/9k="></image></defs>', 4), QRe = [
  JRe
];
function ZRe(e, t, r, n, o, s) {
  return we(), Te("svg", XRe, QRe);
}
const eAe = /* @__PURE__ */ ni(YRe, [["render", ZRe]]), tAe = {
  class: "z-10 py-1 shadow-sm flex justify-between items-center",
  style: { "background-color": "rgba(0,0,0,0.1)" }
}, rAe = { class: "flex flex-row ml-2 items-center gap-3" }, nAe = /* @__PURE__ */ ie("h1", { class: "py-2 text-2xl text-black dark:text-white font-bold font-title" }, " SPEX ", -1), iAe = { class: "flex flex-row items-center gap-3" }, oAe = { key: 0 }, sAe = { key: 1 }, aAe = {
  key: 0,
  class: "flex flex-row items-center mr-2"
}, lAe = /* @__PURE__ */ ie("div", { style: { height: "15px", "border-left": "1px solid", "margin-left": "6px", "margin-right": "8px", width: "1px" } }, null, -1), uAe = { key: 1 }, fAe = {
  name: "SpexHeader"
}, cAe = /* @__PURE__ */ nt({
  ...fAe,
  props: {
    isSettingsEditorShown: { type: Boolean },
    sparqlEndpointUrl: {}
  },
  emits: ["toggle-settings-editor", "toggle-prefix-help"],
  setup(e, { emit: t }) {
    const r = e;
    function n() {
      t("toggle-settings-editor", !r.isSettingsEditorShown);
    }
    function o() {
      t("toggle-prefix-help");
    }
    return (s, a) => (we(), Te("div", tAe, [
      ie("div", rAe, [
        Ee(eAe, { style: { width: "30px", height: "30px" } }),
        nAe
      ]),
      ie("div", iAe, [
        ie("button", {
          class: "button is-white dark:is-dark flex items-center gap-1",
          title: "Options",
          onClick: n
        }, [
          ie("h2", null, [
            s.sparqlEndpointUrl ? (we(), Te("span", oAe, pt(s.sparqlEndpointUrl), 1)) : (we(), Te("span", sAe, "No endpoint configured yet"))
          ]),
          Ee(Pe(GH), { class: "icon" })
        ]),
        ie("button", {
          class: "button is-white dark:is-dark",
          title: "Prefix Zazuko",
          onClick: o
        }, [
          Ee(Pe(hRe), { class: "icon" })
        ])
      ]),
      s.isSettingsEditorShown ? gt("", !0) : (we(), Te("div", aAe, [
        Ee(KRe),
        lAe,
        Ee(WRe)
      ])),
      s.isSettingsEditorShown ? (we(), Te("div", uAe)) : gt("", !0)
    ]));
  }
});
var dAe = "Expected a function", XP = NaN, hAe = "[object Symbol]", pAe = /^\s+|\s+$/g, gAe = /^[-+]0x[0-9a-f]+$/i, bAe = /^0b[01]+$/i, yAe = /^0o[0-7]+$/i, mAe = parseInt, vAe = typeof window == "object" && window && window.Object === Object && window, wAe = typeof self == "object" && self && self.Object === Object && self, _Ae = vAe || wAe || Function("return this")(), SAe = Object.prototype, EAe = SAe.toString, xAe = Math.max, RAe = Math.min, f1 = function() {
  return _Ae.Date.now();
};
function AAe(e, t, r) {
  var n, o, s, a, l, u, f = 0, c = !1, d = !1, h = !0;
  if (typeof e != "function")
    throw new TypeError(dAe);
  t = JP(t) || 0, AE(r) && (c = !!r.leading, d = "maxWait" in r, s = d ? xAe(JP(r.maxWait) || 0, t) : s, h = "trailing" in r ? !!r.trailing : h);
  function p(j) {
    var J = n, G = o;
    return n = o = void 0, f = j, a = e.apply(G, J), a;
  }
  function m(j) {
    return f = j, l = setTimeout(S, t), c ? p(j) : a;
  }
  function y(j) {
    var J = j - u, G = j - f, $ = t - J;
    return d ? RAe($, s - G) : $;
  }
  function _(j) {
    var J = j - u, G = j - f;
    return u === void 0 || J >= t || J < 0 || d && G >= s;
  }
  function S() {
    var j = f1();
    if (_(j))
      return x(j);
    l = setTimeout(S, y(j));
  }
  function x(j) {
    return l = void 0, h && n ? p(j) : (n = o = void 0, a);
  }
  function E() {
    l !== void 0 && clearTimeout(l), f = 0, n = u = o = l = void 0;
  }
  function C() {
    return l === void 0 ? a : x(f1());
  }
  function I() {
    var j = f1(), J = _(j);
    if (n = arguments, o = this, u = j, J) {
      if (l === void 0)
        return m(u);
      if (d)
        return l = setTimeout(S, t), p(u);
    }
    return l === void 0 && (l = setTimeout(S, t)), a;
  }
  return I.cancel = E, I.flush = C, I;
}
function AE(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function TAe(e) {
  return !!e && typeof e == "object";
}
function $Ae(e) {
  return typeof e == "symbol" || TAe(e) && EAe.call(e) == hAe;
}
function JP(e) {
  if (typeof e == "number")
    return e;
  if ($Ae(e))
    return XP;
  if (AE(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = AE(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(pAe, "");
  var r = bAe.test(e);
  return r || yAe.test(e) ? mAe(e.slice(2), r ? 2 : 8) : gAe.test(e) ? XP : +e;
}
var CAe = AAe;
const kAe = /* @__PURE__ */ $n(CAe);
class IAe {
  constructor(t) {
    As(this, "_type");
    As(this, "_comment");
    As(this, "_serverResponseItem");
    var n, o, s;
    this._serverResponseItem = t, this._type = ((n = t.parts.filter((a) => a.predicate === "rdf:type")[0]) == null ? void 0 : n.object) ?? "";
    const r = t.parts.filter((a) => a.predicate === "rdfs:comment");
    if (r.length < 2)
      this._comment = Zh(((o = r[0]) == null ? void 0 : o.object) ?? "no comment");
    else {
      const a = r.filter((l) => l.object.language === "en");
      a.length === 1 ? this._comment = Zh(((s = a[0]) == null ? void 0 : s.object) ?? "no comment") : this._comment = "no comment";
    }
  }
  get type() {
    return this._type;
  }
  get avatar() {
    const t = this.type.split(":");
    return t.length < 2 ? "NT" : (t[0].charAt(0) + t[1].charAt(0)).toUpperCase();
  }
  get itemText() {
    return this._serverResponseItem.itemText;
  }
  get ontologyTitle() {
    return this._serverResponseItem.ontologyTitle;
  }
  get label() {
    return this._serverResponseItem.label;
  }
  get splitA() {
    return this._serverResponseItem.prefixedSplitA;
  }
  get splitB() {
    return this._serverResponseItem.prefixedSplitB;
  }
  get comment() {
    return this._comment;
  }
  get parts() {
    return this._serverResponseItem.parts;
  }
}
function Zh(e) {
  return typeof e == "string" ? e : e.datatype && e.datatype.value === "http://www.w3.org/2001/XMLSchema#string" || e.datatype && e.datatype.value === "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" ? e.value : "";
}
const MAe = { class: "avatar" }, NAe = { class: "card-text" }, LAe = { class: "card-title" }, OAe = { class: "card-comment" }, PAe = {
  name: "PrefixZazukoListItem"
}, DAe = /* @__PURE__ */ nt({
  ...PAe,
  props: {
    item: {}
  },
  emits: ["item-selected"],
  setup(e, { emit: t }) {
    const r = e;
    return (n, o) => (we(), Te("div", {
      class: "card",
      onClick: o[0] || (o[0] = (s) => n.$emit("item-selected", r.item))
    }, [
      Ee(Wr, {
        label: r.item.type
      }, {
        default: Ge(() => [
          ie("div", MAe, pt(r.item.avatar), 1)
        ]),
        _: 1
      }, 8, ["label"]),
      ie("div", NAe, [
        ie("div", LAe, pt(r.item.itemText), 1),
        ie("div", OAe, pt(r.item.comment), 1)
      ])
    ]));
  }
}), FAe = /* @__PURE__ */ ni(DAe, [["__scopeId", "data-v-9c005fb0"]]), jAe = {
  name: "PrefixZazukoList"
}, BAe = /* @__PURE__ */ nt({
  ...jAe,
  props: {
    items: {}
  },
  emits: ["item-selected"],
  setup(e, { emit: t }) {
    const r = e;
    function n(o) {
      t("item-selected", o);
    }
    return (o, s) => (we(!0), Te(lt, null, pr(r.items, (a) => (we(), Et(FAe, {
      key: a.itemText,
      item: a,
      onItemSelected: n
    }, null, 8, ["item"]))), 128));
  }
}), qAe = ["item"], WAe = {
  name: "PrefixZazukoDetail"
}, UAe = /* @__PURE__ */ nt({
  ...WAe,
  props: {
    item: {}
  },
  emits: ["item-selected"],
  setup(e, { emit: t }) {
    const r = e;
    return (n, o) => (we(), Te("table", null, [
      (we(!0), Te(lt, null, pr(r.item.parts, (s) => (we(), Te("tr", {
        key: s.predicate,
        item: s
      }, [
        ie("th", null, pt(Pe(Zh)(s.predicate)), 1),
        ie("td", null, pt(Pe(Zh)(s.object)), 1)
      ], 8, qAe))), 128))
    ]));
  }
}), HAe = /* @__PURE__ */ ni(UAe, [["__scopeId", "data-v-2dcbeccb"]]), zAe = { class: "card is-shadowless h-full overflow-y-auto" }, GAe = { class: "card-header has-background-light" }, VAe = /* @__PURE__ */ ie("h3", { class: "card-header-title" }, "Resolve RDF Terms", -1), KAe = { class: "card-header-icon py-0 px-1" }, YAe = {
  key: 0,
  style: { padding: "21px" }
}, XAe = { class: "field" }, JAe = /* @__PURE__ */ ie("div", { class: "flex flex-row" }, [
  /* @__PURE__ */ ie("label", {
    class: "label",
    for: "prefix"
  }, "Prefix"),
  /* @__PURE__ */ tn("("),
  /* @__PURE__ */ ie("a", {
    target: "_blank",
    href: "https://prefix.zazuko.com/"
  }, "prefix.zazuko.com"),
  /* @__PURE__ */ tn(") ")
], -1), QAe = {
  key: 1,
  style: { padding: "21px" }
}, ZAe = { class: "flex flex-row items-center mb-4" }, eTe = {
  style: { display: "flex", "flex-direction": "column" },
  class: "pl-4"
}, tTe = { class: "title mb-0" }, rTe = {
  name: "PrefixHelp"
}, nTe = /* @__PURE__ */ nt({
  ...rTe,
  props: {
    searchString: {}
  },
  emits: ["close"],
  setup(e, { emit: t }) {
    const n = $e(e.searchString), o = $e([]), s = $e(null);
    br(n, kAe((c) => {
      a(c);
    }, 300));
    async function a(c) {
      const d = "https://prefix.zazuko.com/api/v1/search", h = `q=${encodeURIComponent(c)}`, y = (await (await fetch(d + "?" + h)).json()).map((_) => new IAe(_));
      o.value = y;
    }
    function l() {
      t("close");
    }
    function u(c) {
      s.value = c;
    }
    function f() {
      s.value = null;
    }
    return (c, d) => (we(), Te("div", zAe, [
      ie("div", GAe, [
        VAe,
        ie("p", KAe, [
          ie("button", {
            type: "button",
            class: "button is-light",
            onClick: l,
            title: "Close"
          }, [
            Ee(Pe(as), { class: "icon" })
          ])
        ])
      ]),
      s.value === null ? (we(), Te("div", YAe, [
        ie("div", XAe, [
          JAe,
          Fr(ie("input", {
            type: "text",
            "onUpdate:modelValue": d[0] || (d[0] = (h) => n.value = h),
            placeholder: "Start typing to search... eg. sh:name",
            class: "input",
            required: ""
          }, null, 512), [
            [zo, n.value]
          ])
        ]),
        Ee(BAe, {
          items: o.value,
          onItemSelected: u
        }, null, 8, ["items"])
      ])) : gt("", !0),
      s.value !== null ? (we(), Te("div", QAe, [
        ie("div", ZAe, [
          ie("button", {
            class: "flex flex-grow-0",
            onClick: f
          }, [
            Ee(Pe(FH), { class: "icon" })
          ]),
          ie("div", eTe, [
            ie("h1", tTe, pt(s.value.splitA) + ":" + pt(s.value.splitB), 1),
            ie("div", null, pt(s.value.type), 1)
          ])
        ]),
        Ee(HAe, {
          item: s.value
        }, null, 8, ["item"])
      ])) : gt("", !0)
    ]));
  }
}), iTe = { class: "z-10 absolute m-3" }, oTe = /* @__PURE__ */ ie("span", null, "Classes", -1), sTe = { class: "z-10 absolute bottom-2 left-2 text-sm bg-gray-50 dark:bg-gray-700 flex items-center gap-2" }, aTe = { class: "bg-light dark:bg-dark flex-grow flex items-center" }, lTe = {
  key: 0,
  class: "m-auto"
}, uTe = {
  key: 1,
  class: "section"
}, fTe = { class: "message is-danger" }, cTe = { class: "message-body" }, dTe = {
  name: "SpexMain"
}, hTe = /* @__PURE__ */ nt({
  ...dTe,
  props: {
    settings: {}
  },
  emits: ["settingsChanged"],
  setup(e, { emit: t }) {
    const r = e, n = $e(""), o = $e(!1), s = co.getInstance(r.settings), a = Ne(() => p.value.length > 0);
    br(() => r.settings, (H) => {
      var pe;
      (((pe = H.sparqlEndpoint) == null ? void 0 : pe.length) ?? 0) > 0 ? (l.value = !1, fe(H)) : l.value = !0;
    }), Dt(async () => {
      r.settings.sparqlEndpoint ? await fe(r.settings) : l.value = !0;
    });
    const l = $e(!1), u = $e(!1), f = $e(!1), c = $e(!1), d = $e(!1), h = $e(null), p = $e([]), m = $e(null), y = $e(!1), _ = $e(null);
    function S() {
      o.value = !o.value;
    }
    function x() {
      o.value = !1;
    }
    function E(H) {
      if (typeof H > "u") {
        l.value = !l.value;
        return;
      }
      l.value = H;
    }
    function C(H) {
      I(H), p.value.push(H);
    }
    function I(H) {
      p.value = p.value.filter((pe) => pe.id !== H.id);
    }
    function j() {
      p.value = [];
    }
    function J(H) {
      H.isShown = !H.isShown;
    }
    function G(H) {
      var ke, le;
      const pe = H ? H.tables : new Set((ke = m.value) == null ? void 0 : ke.tables.map(({ id: ee }) => ee));
      (le = m.value) == null || le.tables.forEach((ee) => {
        pe.has(ee.id) ? ee.isShown = !0 : ee.isShown = !1;
      });
    }
    function $() {
      f.value = !0;
    }
    function V() {
      f.value = !1;
    }
    function M() {
      u.value = !1;
    }
    function W() {
      h.value = null, u.value = !1;
    }
    function k() {
      c.value = !0;
    }
    function U() {
      d.value = !0;
    }
    function Z(H) {
      m.value = H;
    }
    function Y() {
      c.value = !1;
    }
    function te() {
      d.value = !1;
    }
    async function se() {
      W(), _.value = null, y.value = !0, m.value = null;
      try {
        m.value = await s.fetchDataModel();
      } catch (H) {
        _.value = H, E(!0), console.error(H);
      } finally {
        y.value = !1;
      }
    }
    async function fe(H) {
      s.applySettings(H), await se();
    }
    function he(H) {
      u.value = !0, h.value = H;
    }
    async function ae(H) {
      const pe = s.dataModelToSHACL(m.value).namedNode(H.id).in(Pt.targetClass), ke = pe.value, le = pe.out(Pt.targetClass).value;
      let ee = `_:${ke} a <http://www.w3.org/ns/shacl#NodeShape> ;`;
      ee += `
	<${Pt.targetClass.value}> <${le}> ;`;
      const ge = pe.out(Pt.property);
      ge.values.length > 0 && (ee += `
	<${Pt.property.value}> `, ge.toArray().forEach((Ae, Oe) => {
        ee += `
		[`;
        const K = Ae.out(Un.type).value, z = Ae.out(Pt.path).value, b = Ae.out(Pt.class).value, w = Ae.out(Pt.datatype).value, T = Ae.out(Pt.or);
        let O = `			<${Un.type}> <${K}> ;
			<http://www.w3.org/ns/shacl#path> <${z}> ;
`;
        if (O += b ? `			<http://www.w3.org/ns/shacl#class> <${b}> ;
` : "", O += w ? `			<http://www.w3.org/ns/shacl#datatype> <${w}> ;
` : "", T.values.length > 0) {
          let L = `			<http://www.w3.org/ns/shacl#shOr> (
`;
          const ne = T.list();
          (ne === null ? [] : [...ne]).forEach((oe) => {
            const ye = [];
            oe.dataset.match(oe.term, null, null, null).filter((B) => !(B.predicate.equals(Un.last) || B.predicate.equals(Un.last) || B.predicate.equals(Un.nil))).forEach((B) => ye.push(`					<${B.predicate.value}> <${B.object.value}> ;`)), L += `				[
${ye.join(` 
`)}`, L += ` 
				]
`;
          }), O += `${L}`, O += `			) 
`;
        }
        ee += `
${O}		] ${Oe === ge.values.length - 1 ? "." : ","}`;
      })), await navigator.clipboard.writeText(ee);
    }
    function be(H) {
      t("settingsChanged", H);
    }
    return (H, pe) => (we(), Et(Pe(Gc), { class: "default-theme flex-grow overflow-hidden" }, {
      default: Ge(() => [
        Ee(Pe(Hi), null, {
          default: Ge(() => [
            Ee(Pe(Gc), {
              horizontal: "",
              class: "h-full"
            }, {
              default: Ge(() => [
                Ee(Pe(Hi), { class: "flex flex-col bg-light dark:bg-dark" }, {
                  default: Ge(() => [
                    Ee(cAe, {
                      isSettingsEditorShown: l.value,
                      sparqlEndpointUrl: Pe(s).sparqlEndpoint,
                      onToggleSettingsEditor: E,
                      onTogglePrefixHelp: S
                    }, null, 8, ["isSettingsEditorShown", "sparqlEndpointUrl"]),
                    m.value ? (we(), Et(Pe(Gc), {
                      key: 0,
                      vertical: "",
                      class: "overflow-hidden"
                    }, {
                      default: Ge(() => [
                        f.value ? (we(), Et(Pe(Hi), {
                          key: 0,
                          size: "30"
                        }, {
                          default: Ge(() => [
                            Ee(PRe, {
                              datamodel: m.value,
                              onToggleTable: J,
                              onSelectViewport: G,
                              onClose: V
                            }, null, 8, ["datamodel"])
                          ]),
                          _: 1
                        })) : gt("", !0),
                        Ee(Pe(Hi), { class: "relative h-full" }, {
                          default: Ge(() => [
                            ie("div", iTe, [
                              Fr(ie("button", {
                                class: "button",
                                onClick: $
                              }, [
                                Ee(Pe(WH), { class: "icon" }),
                                oTe
                              ], 512), [
                                [Ea, !f.value]
                              ])
                            ]),
                            Ee(OEe, {
                              datamodel: m.value,
                              onExplore: he,
                              onExport: ae,
                              onToggleShape: J
                            }, {
                              default: Ge(() => [
                                Fr(ie("p", sTe, [
                                  Pe(s) && !_.value ? (we(), Te("button", {
                                    key: 0,
                                    class: "button is-white is-small",
                                    onClick: k
                                  }, " SHACL ")) : gt("", !0)
                                ], 512), [
                                  [Ea, !(u.value || a.value)]
                                ])
                              ]),
                              _: 1
                            }, 8, ["datamodel"])
                          ]),
                          _: 1
                        }),
                        o.value ? (we(), Et(Pe(Hi), {
                          key: 1,
                          size: "30"
                        }, {
                          default: Ge(() => [
                            Ee(nTe, {
                              onClose: x,
                              "search-string": n.value
                            }, null, 8, ["search-string"])
                          ]),
                          _: 1
                        })) : gt("", !0)
                      ]),
                      _: 1
                    })) : gt("", !0),
                    ie("div", aTe, [
                      y.value ? (we(), Te("div", lTe, [
                        Ee(RA)
                      ])) : gt("", !0)
                    ]),
                    _.value ? (we(), Te("div", uTe, [
                      ie("div", fTe, [
                        ie("div", cTe, " Error loading data: " + pt(_.value), 1)
                      ])
                    ])) : gt("", !0)
                  ]),
                  _: 1
                }),
                u.value || a.value ? (we(), Et(Pe(Hi), { key: 0 }, {
                  default: Ge(() => [
                    Ee(Pe(Gc), { vertical: "" }, {
                      default: Ge(() => [
                        u.value ? (we(), Et(Pe(Hi), { key: 0 }, {
                          default: Ge(() => [
                            Ee(dRe, {
                              table: h.value,
                              onClose: M,
                              onExploreResource: C
                            }, null, 8, ["table"])
                          ]),
                          _: 1
                        })) : gt("", !0),
                        a.value ? (we(), Et(Pe(Hi), { key: 1 }, {
                          default: Ge(() => [
                            Ee(ixe, {
                              resources: p.value,
                              onClose: j,
                              onExploreResource: C,
                              onUnexploreResource: I
                            }, null, 8, ["resources"])
                          ]),
                          _: 1
                        })) : gt("", !0)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })) : gt("", !0)
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        l.value ? (we(), Et(Pe(Hi), {
          key: 0,
          size: "30"
        }, {
          default: Ge(() => [
            Ee(zxe, {
              settings: H.settings,
              onSettingsChanged: be,
              onClose: E
            }, null, 8, ["settings"])
          ]),
          _: 1
        })) : gt("", !0),
        c.value && m.value !== null ? (we(), Et(uge, {
          key: 1,
          open: c.value,
          onClose: Y,
          endpoint: Pe(s),
          datamodel: m.value,
          onOpenLoadShacl: U
        }, null, 8, ["open", "endpoint", "datamodel"])) : gt("", !0),
        d.value ? (we(), Et(wge, {
          key: 2,
          open: d.value,
          onClose: te,
          endpoint: Pe(s),
          load: Z
        }, null, 8, ["open", "endpoint"])) : gt("", !0)
      ]),
      _: 1
    }));
  }
});
function i$e(e, t) {
  NH(hTe, { settings: t }).mount(e);
}
export {
  iY as S,
  hTe as _,
  Kt as a,
  ut as b,
  RTe as c,
  _t as d,
  ur as e,
  Hl as f,
  $n as g,
  AD as h,
  gD as i,
  gre as j,
  Vx as k,
  F1 as l,
  Bfe as m,
  i$e as n,
  $t as p,
  M8 as r
};
//# sourceMappingURL=index-BhI9pmWG.js.map
