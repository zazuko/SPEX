{"version":3,"file":"index-CeD6y882.js","sources":["../node_modules/cross-fetch/dist/browser-polyfill.js","../node_modules/jsonld-context-parser/lib/ErrorCoded.js","../node_modules/http-link-header/lib/link.js","../node_modules/jsonld-context-parser/lib/FetchDocumentLoader.js","../node_modules/jsonld-context-parser/lib/Util.js","../node_modules/jsonld-context-parser/lib/JsonLdContextNormalized.js","../node_modules/jsonld-context-parser/lib/ContextParser.js","../node_modules/jsonld-context-parser/lib/IDocumentLoader.js","../node_modules/jsonld-context-parser/lib/JsonLdContext.js","../node_modules/jsonld-context-parser/index.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/ours/primordials.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/ours/util.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/ours/errors.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/validators.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/utils.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/destroy.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/legacy.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/buffer_list.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/state.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/from.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/readable.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/writable.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/duplexify.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/duplex.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/transform.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/passthrough.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/pipeline.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/compose.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/internal/streams/operators.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/stream/promises.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/stream.js","../node_modules/jsonld-streaming-parser/node_modules/readable-stream/lib/ours/browser.js","../node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerIdentifier.js","../node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerPredicate.js","../node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerIndex.js","../node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerLanguage.js","../node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerType.js","../node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerContainer.js","../node_modules/jsonld-streaming-parser/lib/Util.js","../node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerArrayValue.js","../node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerInvalidFallback.js","../node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeyword.js","../node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordContext.js","../node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordGraph.js","../node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordId.js","../node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordIncluded.js","../node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordNest.js","../node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordType.js","../node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordUnknownFallback.js","../node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordValue.js","../node_modules/jsonld-streaming-parser/lib/ContextTree.js","../node_modules/jsonld-streaming-parser/lib/ParsingContext.js","../node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordAnnotation.js","../node_modules/jsonld-streaming-parser/lib/JsonLdParser.js","../node_modules/jsonld-streaming-parser/index.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/ours/primordials.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/ours/util.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/ours/errors.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/validators.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/utils.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/destroy.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/legacy.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/buffer_list.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/state.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/from.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/readable.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/writable.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/duplexify.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/duplex.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/transform.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/passthrough.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/pipeline.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/compose.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/internal/streams/operators.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/stream/promises.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/stream.js","../node_modules/@rdfjs/parser-jsonld/node_modules/readable-stream/lib/ours/browser.js","../node_modules/@rdfjs/parser-jsonld/lib/ParserStream.js","../node_modules/@rdfjs/parser-jsonld/index.js"],"sourcesContent":["(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n})({});\n})(typeof self !== 'undefined' ? self : this);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ERROR_CODES = exports.ErrorCoded = void 0;\n/**\n * An error that has a certain error code.\n *\n * The error code can be any string.\n * All standardized error codes are listed in {@link ERROR_CODES}.\n */\nclass ErrorCoded extends Error {\n    /* istanbul ignore next */\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n    }\n}\nexports.ErrorCoded = ErrorCoded;\n/**\n * All standardized JSON-LD error codes.\n * @see https://w3c.github.io/json-ld-api/#dom-jsonlderrorcode\n */\n// tslint:disable:object-literal-sort-keys\nvar ERROR_CODES;\n(function (ERROR_CODES) {\n    ERROR_CODES[\"COLLIDING_KEYWORDS\"] = \"colliding keywords\";\n    ERROR_CODES[\"CONFLICTING_INDEXES\"] = \"conflicting indexes\";\n    ERROR_CODES[\"CYCLIC_IRI_MAPPING\"] = \"cyclic IRI mapping\";\n    ERROR_CODES[\"INVALID_ID_VALUE\"] = \"invalid @id value\";\n    ERROR_CODES[\"INVALID_INDEX_VALUE\"] = \"invalid @index value\";\n    ERROR_CODES[\"INVALID_NEST_VALUE\"] = \"invalid @nest value\";\n    ERROR_CODES[\"INVALID_PREFIX_VALUE\"] = \"invalid @prefix value\";\n    ERROR_CODES[\"INVALID_PROPAGATE_VALUE\"] = \"invalid @propagate value\";\n    ERROR_CODES[\"INVALID_REVERSE_VALUE\"] = \"invalid @reverse value\";\n    ERROR_CODES[\"INVALID_IMPORT_VALUE\"] = \"invalid @import value\";\n    ERROR_CODES[\"INVALID_VERSION_VALUE\"] = \"invalid @version value\";\n    ERROR_CODES[\"INVALID_BASE_IRI\"] = \"invalid base IRI\";\n    ERROR_CODES[\"INVALID_CONTAINER_MAPPING\"] = \"invalid container mapping\";\n    ERROR_CODES[\"INVALID_CONTEXT_ENTRY\"] = \"invalid context entry\";\n    ERROR_CODES[\"INVALID_CONTEXT_NULLIFICATION\"] = \"invalid context nullification\";\n    ERROR_CODES[\"INVALID_DEFAULT_LANGUAGE\"] = \"invalid default language\";\n    ERROR_CODES[\"INVALID_INCLUDED_VALUE\"] = \"invalid @included value\";\n    ERROR_CODES[\"INVALID_IRI_MAPPING\"] = \"invalid IRI mapping\";\n    ERROR_CODES[\"INVALID_JSON_LITERAL\"] = \"invalid JSON literal\";\n    ERROR_CODES[\"INVALID_KEYWORD_ALIAS\"] = \"invalid keyword alias\";\n    ERROR_CODES[\"INVALID_LANGUAGE_MAP_VALUE\"] = \"invalid language map value\";\n    ERROR_CODES[\"INVALID_LANGUAGE_MAPPING\"] = \"invalid language mapping\";\n    ERROR_CODES[\"INVALID_LANGUAGE_TAGGED_STRING\"] = \"invalid language-tagged string\";\n    ERROR_CODES[\"INVALID_LANGUAGE_TAGGED_VALUE\"] = \"invalid language-tagged value\";\n    ERROR_CODES[\"INVALID_LOCAL_CONTEXT\"] = \"invalid local context\";\n    ERROR_CODES[\"INVALID_REMOTE_CONTEXT\"] = \"invalid remote context\";\n    ERROR_CODES[\"INVALID_REVERSE_PROPERTY\"] = \"invalid reverse property\";\n    ERROR_CODES[\"INVALID_REVERSE_PROPERTY_MAP\"] = \"invalid reverse property map\";\n    ERROR_CODES[\"INVALID_REVERSE_PROPERTY_VALUE\"] = \"invalid reverse property value\";\n    ERROR_CODES[\"INVALID_SCOPED_CONTEXT\"] = \"invalid scoped context\";\n    ERROR_CODES[\"INVALID_SCRIPT_ELEMENT\"] = \"invalid script element\";\n    ERROR_CODES[\"INVALID_SET_OR_LIST_OBJECT\"] = \"invalid set or list object\";\n    ERROR_CODES[\"INVALID_TERM_DEFINITION\"] = \"invalid term definition\";\n    ERROR_CODES[\"INVALID_TYPE_MAPPING\"] = \"invalid type mapping\";\n    ERROR_CODES[\"INVALID_TYPE_VALUE\"] = \"invalid type value\";\n    ERROR_CODES[\"INVALID_TYPED_VALUE\"] = \"invalid typed value\";\n    ERROR_CODES[\"INVALID_VALUE_OBJECT\"] = \"invalid value object\";\n    ERROR_CODES[\"INVALID_VALUE_OBJECT_VALUE\"] = \"invalid value object value\";\n    ERROR_CODES[\"INVALID_VOCAB_MAPPING\"] = \"invalid vocab mapping\";\n    ERROR_CODES[\"IRI_CONFUSED_WITH_PREFIX\"] = \"IRI confused with prefix\";\n    ERROR_CODES[\"KEYWORD_REDEFINITION\"] = \"keyword redefinition\";\n    ERROR_CODES[\"LOADING_DOCUMENT_FAILED\"] = \"loading document failed\";\n    ERROR_CODES[\"LOADING_REMOTE_CONTEXT_FAILED\"] = \"loading remote context failed\";\n    ERROR_CODES[\"MULTIPLE_CONTEXT_LINK_HEADERS\"] = \"multiple context link headers\";\n    ERROR_CODES[\"PROCESSING_MODE_CONFLICT\"] = \"processing mode conflict\";\n    ERROR_CODES[\"PROTECTED_TERM_REDEFINITION\"] = \"protected term redefinition\";\n    ERROR_CODES[\"CONTEXT_OVERFLOW\"] = \"context overflow\";\n    ERROR_CODES[\"INVALID_BASE_DIRECTION\"] = \"invalid base direction\";\n    ERROR_CODES[\"RECURSIVE_CONTEXT_INCLUSION\"] = \"recursive context inclusion\";\n    ERROR_CODES[\"INVALID_STREAMING_KEY_ORDER\"] = \"invalid streaming key order\";\n    /**\n     * JSON-LD-star\n     */\n    ERROR_CODES[\"INVALID_EMBEDDED_NODE\"] = \"invalid embedded node\";\n    ERROR_CODES[\"INVALID_ANNOTATION\"] = \"invalid annotation\";\n})(ERROR_CODES = exports.ERROR_CODES || (exports.ERROR_CODES = {}));\n//# sourceMappingURL=ErrorCoded.js.map","'use strict'\n\nvar COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i\nvar WS_TRIM_PATTERN = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g\nvar WS_CHAR_PATTERN = /\\s|\\uFEFF|\\xA0/\nvar WS_FOLD_PATTERN = /\\r?\\n[\\x20\\x09]+/g\nvar DELIMITER_PATTERN = /[;,\"]/\nvar WS_DELIMITER_PATTERN = /[;,\"]|\\s/\n\n/**\n * Token character pattern\n * @type {RegExp}\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\nvar TOKEN_PATTERN = /^[!#$%&'*+\\-\\.^_`|~\\da-zA-Z]+$/\n\nvar STATE = {\n  IDLE: 1 << 0,\n  URI: 1 << 1,\n  ATTR: 1 << 2,\n}\n\nfunction trim( value ) {\n  return value.replace( WS_TRIM_PATTERN, '' )\n}\n\nfunction hasWhitespace( value ) {\n  return WS_CHAR_PATTERN.test( value )\n}\n\nfunction skipWhitespace( value, offset ) {\n  while( hasWhitespace( value[offset] ) ) {\n    offset++\n  }\n  return offset\n}\n\nfunction needsQuotes( value ) {\n  return WS_DELIMITER_PATTERN.test( value ) ||\n    !TOKEN_PATTERN.test( value )\n}\n\n/**\n * Shallow compares two objects to check if their properties match.\n * @param {object} object1 First object to compare.\n * @param {object} object2 Second object to compare.\n * @returns {boolean} Do the objects have matching properties.\n */\nfunction shallowCompareObjects( object1, object2 ) {\n  return (\n    Object.keys( object1 ).length === Object.keys( object2 ).length &&\n    Object.keys( object1 ).every(\n      ( key ) => key in object2 && object1[ key ] === object2[ key ]\n    )\n  );\n}\n\nclass Link {\n\n  /**\n   * Link\n   * @constructor\n   * @param {String} [value]\n   * @returns {Link}\n   */\n  constructor( value ) {\n\n    /** @type {Array} URI references */\n    this.refs = []\n\n    if( value ) {\n      this.parse( value )\n    }\n\n  }\n\n  /**\n   * Get refs with given relation type\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  rel( value ) {\n\n    var links = []\n    var type = value.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ].rel.toLowerCase() === type ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /**\n   * Get refs where given attribute has a given value\n   * @param {String} attr\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  get( attr, value ) {\n\n    attr = attr.toLowerCase()\n\n    var links = []\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ][ attr ] === value ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /** Sets a reference. */\n  set( link ) {\n    this.refs.push( link )\n    return this\n  }\n\n  /**\n   * Sets a reference if a reference with similar properties isn’t already set.\n   */\n  setUnique( link ) {\n\n    if( !this.refs.some(( ref ) => shallowCompareObjects( ref, link )) ) {\n      this.refs.push( link )\n    }\n\n    return this\n\n  }\n\n  has( attr, value ) {\n\n    attr = attr.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ][ attr ] === value ) {\n        return true\n      }\n    }\n\n    return false\n\n  }\n\n  parse( value, offset ) {\n\n    offset = offset || 0\n    value = offset ? value.slice( offset ) : value\n\n    // Trim & unfold folded lines\n    value = trim( value ).replace( WS_FOLD_PATTERN, '' )\n\n    var state = STATE.IDLE\n    var length = value.length\n    var offset = 0\n    var ref = null\n\n    while( offset < length ) {\n      if( state === STATE.IDLE ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === '<' ) {\n          if( ref != null ) {\n            ref.rel != null ?\n              this.refs.push( ...Link.expandRelations( ref ) ) :\n              this.refs.push( ref )\n          }\n          var end = value.indexOf( '>', offset )\n          if( end === -1 ) throw new Error( 'Expected end of URI delimiter at offset ' + offset )\n          ref = { uri: value.slice( offset + 1, end ) }\n          // this.refs.push( ref )\n          offset = end\n          state = STATE.URI\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n        offset++\n      } else if( state === STATE.URI ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === ';' ) {\n          state = STATE.ATTR\n          offset++\n        } else if( value[offset] === ',' ) {\n          state = STATE.IDLE\n          offset++\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n      } else if( state === STATE.ATTR ) {\n        if( value[offset] ===';' || hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        }\n        var end = value.indexOf( '=', offset )\n        if( end === -1 ) end = value.indexOf( ';', offset )\n        if( end === -1 ) end = value.length\n        var attr = trim( value.slice( offset, end ) ).toLowerCase()\n        var attrValue = ''\n        offset = end + 1\n        offset = skipWhitespace( value, offset )\n        if( value[offset] === '\"' ) {\n          offset++\n          while( offset < length ) {\n            if( value[offset] === '\"' ) {\n              offset++; break\n            }\n            if( value[offset] === '\\\\' ) {\n              offset++\n            }\n            attrValue += value[offset]\n            offset++\n          }\n        } else {\n          var end = offset + 1\n          while( !DELIMITER_PATTERN.test( value[end] ) && end < length ) {\n            end++\n          }\n          attrValue = value.slice( offset, end )\n          offset = end\n        }\n        if( ref[ attr ] && Link.isSingleOccurenceAttr( attr ) ) {\n          // Ignore multiples of attributes which may only appear once\n        } else if( attr[ attr.length - 1 ] === '*' ) {\n          ref[ attr ] = Link.parseExtendedValue( attrValue )\n        } else {\n          attrValue = attr === 'type' ?\n            attrValue.toLowerCase() : attrValue\n          if( ref[ attr ] != null ) {\n            if( Array.isArray( ref[ attr ] ) ) {\n              ref[ attr ].push( attrValue )\n            } else {\n              ref[ attr ] = [ ref[ attr ], attrValue ]\n            }\n          } else {\n            ref[ attr ] = attrValue\n          }\n        }\n        switch( value[offset] ) {\n          case ',': state = STATE.IDLE; break\n          case ';': state = STATE.ATTR; break\n        }\n        offset++\n      } else {\n        throw new Error( 'Unknown parser state \"' + state + '\"' )\n      }\n    }\n\n    if( ref != null ) {\n      ref.rel != null ?\n        this.refs.push( ...Link.expandRelations( ref ) ) :\n        this.refs.push( ref )\n    }\n\n    ref = null\n\n    return this\n\n  }\n\n  toString() {\n\n    var refs = []\n    var link = ''\n    var ref = null\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      ref = this.refs[i]\n      link = Object.keys( this.refs[i] ).reduce( function( link, attr ) {\n        if( attr === 'uri' ) return link\n        return link + '; ' + Link.formatAttribute( attr, ref[ attr ] )\n      }, '<' + ref.uri + '>' )\n      refs.push( link )\n    }\n\n    return refs.join( ', ' )\n\n  }\n\n}\n\n/**\n * Determines whether an encoding can be\n * natively handled with a `Buffer`\n * @param {String} value\n * @returns {Boolean}\n */\nLink.isCompatibleEncoding = function( value ) {\n  return COMPATIBLE_ENCODING_PATTERN.test( value )\n}\n\nLink.parse = function( value, offset ) {\n  return new Link().parse( value, offset )\n}\n\nLink.isSingleOccurenceAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'media' ||\n    attr === 'title' || attr === 'title*'\n}\n\nLink.isTokenAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'anchor'\n}\n\nLink.escapeQuotes = function( value ) {\n  return value.replace( /\"/g, '\\\\\"' )\n}\n\nLink.expandRelations = function( ref ) {\n  var rels = ref.rel.split( ' ' )\n  return rels.map( function( rel ) {\n    var value = Object.assign( {}, ref )\n    value.rel = rel\n    return value\n  })\n}\n\n/**\n * Parses an extended value and attempts to decode it\n * @internal\n * @param {String} value\n * @return {Object}\n */\nLink.parseExtendedValue = function( value ) {\n  var parts = /([^']+)?(?:'([^']*)')?(.+)/.exec( value )\n  return {\n    language: parts[2].toLowerCase(),\n    encoding: Link.isCompatibleEncoding( parts[1] ) ?\n      null : parts[1].toLowerCase(),\n    value: Link.isCompatibleEncoding( parts[1] ) ?\n      decodeURIComponent( parts[3] ) : parts[3]\n  }\n}\n\n/**\n * Format a given extended attribute and it's value\n * @param {String} attr\n * @param {Object} data\n * @return {String}\n */\nLink.formatExtendedAttribute = function( attr, data ) {\n\n  var encoding = ( data.encoding || 'utf-8' ).toUpperCase()\n  var language = data.language || 'en'\n\n  var encodedValue = ''\n\n  if( Buffer.isBuffer( data.value ) && Link.isCompatibleEncoding( encoding ) ) {\n    encodedValue = data.value.toString( encoding )\n  } else if( Buffer.isBuffer( data.value ) ) {\n    encodedValue = data.value.toString( 'hex' )\n      .replace( /[0-9a-f]{2}/gi, '%$1' )\n  } else {\n    encodedValue = encodeURIComponent( data.value )\n  }\n\n  return attr + '=' + encoding + '\\'' +\n    language + '\\'' + encodedValue\n\n}\n\n/**\n * Format a given attribute and it's value\n * @param {String} attr\n * @param {String|Object} value\n * @return {String}\n */\nLink.formatAttribute = function( attr, value ) {\n\n  if( Array.isArray( value ) ) {\n    return value.map(( item ) => {\n      return Link.formatAttribute( attr, item )\n    }).join( '; ' )\n  }\n\n  if( attr[ attr.length - 1 ] === '*' || typeof value !== 'string' ) {\n    return Link.formatExtendedAttribute( attr, value )\n  }\n\n  if( Link.isTokenAttr( attr ) ) {\n    value = needsQuotes( value ) ?\n      '\"' + Link.escapeQuotes( value ) + '\"' :\n      Link.escapeQuotes( value )\n  } else if( needsQuotes( value ) ) {\n    value = encodeURIComponent( value )\n    // We don't need to escape <SP> <,> <;> within quotes\n    value = value\n      .replace( /%20/g, ' ' )\n      .replace( /%2C/g, ',' )\n      .replace( /%3B/g, ';' )\n\n    value = '\"' + value + '\"'\n  }\n\n  return attr + '=' + value\n\n}\n\nmodule.exports = Link\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FetchDocumentLoader = void 0;\nrequire(\"cross-fetch/polyfill\");\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\nconst http_link_header_1 = require(\"http-link-header\");\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\n/**\n * Loads documents via the fetch API.\n */\nclass FetchDocumentLoader {\n    constructor(fetcher) {\n        this.fetcher = fetcher;\n    }\n    async load(url) {\n        const response = await (this.fetcher || fetch)(url, { headers: new Headers({ accept: 'application/ld+json' }) });\n        if (response.ok && response.headers) {\n            let mediaType = response.headers.get('Content-Type');\n            if (mediaType) {\n                const colonPos = mediaType.indexOf(';');\n                if (colonPos > 0) {\n                    mediaType = mediaType.substr(0, colonPos);\n                }\n            }\n            if (mediaType === 'application/ld+json') {\n                // Return JSON-LD if proper content type was returned\n                return (await response.json());\n            }\n            else {\n                // Check for alternate link for a non-JSON-LD response\n                if (response.headers.has('Link')) {\n                    let alternateUrl;\n                    response.headers.forEach((value, key) => {\n                        if (key === 'link') {\n                            const linkHeader = (0, http_link_header_1.parse)(value);\n                            for (const link of linkHeader.get('type', 'application/ld+json')) {\n                                if (link.rel === 'alternate') {\n                                    if (alternateUrl) {\n                                        throw new Error('Multiple JSON-LD alternate links were found on ' + url);\n                                    }\n                                    alternateUrl = (0, relative_to_absolute_iri_1.resolve)(link.uri, url);\n                                }\n                            }\n                        }\n                    });\n                    if (alternateUrl) {\n                        return this.load(alternateUrl);\n                    }\n                }\n                throw new ErrorCoded_1.ErrorCoded(`Unsupported JSON-LD media type ${mediaType}`, ErrorCoded_1.ERROR_CODES.LOADING_DOCUMENT_FAILED);\n            }\n        }\n        else {\n            throw new Error(response.statusText || `Status code: ${response.status}`);\n        }\n    }\n}\nexports.FetchDocumentLoader = FetchDocumentLoader;\n//# sourceMappingURL=FetchDocumentLoader.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Util = void 0;\nclass Util {\n    /**\n     * Check if the given term is a valid compact IRI.\n     * Otherwise, it may be an IRI.\n     * @param {string} term A term.\n     * @return {boolean} If it is a compact IRI.\n     */\n    static isCompactIri(term) {\n        return term.indexOf(':') > 0 && !(term && term[0] === '#');\n    }\n    /**\n     * Get the prefix from the given term.\n     * @see https://json-ld.org/spec/latest/json-ld/#compact-iris\n     * @param {string} term A term that is an URL or a prefixed URL.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @return {string} The prefix or null.\n     */\n    static getPrefix(term, context) {\n        // Do not consider relative IRIs starting with a hash as compact IRIs\n        if (term && term[0] === '#') {\n            return null;\n        }\n        const separatorPos = term.indexOf(':');\n        if (separatorPos >= 0) {\n            // Suffix can not begin with two slashes\n            if (term.length > separatorPos + 1\n                && term.charAt(separatorPos + 1) === '/'\n                && term.charAt(separatorPos + 2) === '/') {\n                return null;\n            }\n            const prefix = term.substr(0, separatorPos);\n            // Prefix can not be an underscore (this is a blank node)\n            if (prefix === '_') {\n                return null;\n            }\n            // Prefix must match a term in the active context\n            if (context[prefix]) {\n                return prefix;\n            }\n        }\n        return null;\n    }\n    /**\n     * From a given context entry value, get the string value, or the @id field.\n     * @param contextValue A value for a term in a context.\n     * @return {string} The id value, or null.\n     */\n    static getContextValueId(contextValue) {\n        if (contextValue === null || typeof contextValue === 'string') {\n            return contextValue;\n        }\n        const id = contextValue['@id'];\n        return id ? id : null;\n    }\n    /**\n     * Check if the given simple term definition (string-based value of a context term)\n     * should be considered a prefix.\n     * @param value A simple term definition value.\n     * @param options Options that define the way how expansion must be done.\n     */\n    static isSimpleTermDefinitionPrefix(value, options) {\n        return !Util.isPotentialKeyword(value)\n            && (options.allowPrefixNonGenDelims || (typeof value === 'string' && (value[0] === '_' || Util.isPrefixIriEndingWithGenDelim(value))));\n    }\n    /**\n     * Check if the given keyword is of the keyword format \"@\"1*ALPHA.\n     * @param {string} keyword A potential keyword.\n     * @return {boolean} If the given keyword is of the keyword format.\n     */\n    static isPotentialKeyword(keyword) {\n        return typeof keyword === 'string' && Util.KEYWORD_REGEX.test(keyword);\n    }\n    /**\n     * Check if the given prefix ends with a gen-delim character.\n     * @param {string} prefixIri A prefix IRI.\n     * @return {boolean} If the given prefix IRI is valid.\n     */\n    static isPrefixIriEndingWithGenDelim(prefixIri) {\n        return Util.ENDS_WITH_GEN_DELIM.test(prefixIri);\n    }\n    /**\n     * Check if the given context value can be a prefix value.\n     * @param value A context value.\n     * @return {boolean} If it can be a prefix value.\n     */\n    static isPrefixValue(value) {\n        return value && (typeof value === 'string' || (value && typeof value === 'object'));\n    }\n    /**\n     * Check if the given IRI is valid.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIri(iri) {\n        return Boolean(iri && Util.IRI_REGEX.test(iri));\n    }\n    /**\n     * Check if the given IRI is valid, this includes the possibility of being a relative IRI.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIriWeak(iri) {\n        return !!iri && iri[0] !== ':' && Util.IRI_REGEX_WEAK.test(iri);\n    }\n    /**\n     * Check if the given keyword is a defined according to the JSON-LD specification.\n     * @param {string} keyword A potential keyword.\n     * @return {boolean} If the given keyword is valid.\n     */\n    static isValidKeyword(keyword) {\n        return Util.VALID_KEYWORDS[keyword];\n    }\n    /**\n     * Check if the given term is protected in the context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {string} key A context term.\n     * @return {boolean} If the given term has an @protected flag.\n     */\n    static isTermProtected(context, key) {\n        const value = context[key];\n        return !(typeof value === 'string') && value && value['@protected'];\n    }\n    /**\n     * Check if the given context has at least one protected term.\n     * @param context A context.\n     * @return If the context has a protected term.\n     */\n    static hasProtectedTerms(context) {\n        for (const key of Object.keys(context)) {\n            if (Util.isTermProtected(context, key)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Check if the given key is an internal reserved keyword.\n     * @param key A context key.\n     */\n    static isReservedInternalKeyword(key) {\n        return key.startsWith('@__');\n    }\n    /**\n     * Check if two objects are deepEqual to on another.\n     * @param object1 The first object to test.\n     * @param object2 The second object to test.\n     */\n    static deepEqual(object1, object2) {\n        const objKeys1 = Object.keys(object1);\n        const objKeys2 = Object.keys(object2);\n        if (objKeys1.length !== objKeys2.length)\n            return false;\n        return objKeys1.every((key) => {\n            const value1 = object1[key];\n            const value2 = object2[key];\n            return (value1 === value2) || (value1 !== null &&\n                value2 !== null &&\n                typeof value1 === \"object\" &&\n                typeof value2 === \"object\" &&\n                this.deepEqual(value1, value2));\n        });\n    }\n    ;\n}\n// Regex for valid IRIs\nUtil.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ \"<>{}|\\\\\\[\\]`#]*(#[^#]*)?$/;\n// Weaker regex for valid IRIs, this includes relative IRIs\nUtil.IRI_REGEX_WEAK = /(?::[^:])|\\//;\n// Regex for keyword form\nUtil.KEYWORD_REGEX = /^@[a-z]+$/i;\n// Regex to see if an IRI ends with a gen-delim character (see RFC 3986)\nUtil.ENDS_WITH_GEN_DELIM = /[:/?#\\[\\]@]$/;\n// Regex for language tags\nUtil.REGEX_LANGUAGE_TAG = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/;\n// Regex for base directions\nUtil.REGEX_DIRECTION_TAG = /^(ltr)|(rtl)$/;\n// All known valid JSON-LD keywords\n// @see https://www.w3.org/TR/json-ld11/#keywords\nUtil.VALID_KEYWORDS = {\n    '@annotation': true,\n    '@base': true,\n    '@container': true,\n    '@context': true,\n    '@direction': true,\n    '@graph': true,\n    '@id': true,\n    '@import': true,\n    '@included': true,\n    '@index': true,\n    '@json': true,\n    '@language': true,\n    '@list': true,\n    '@nest': true,\n    '@none': true,\n    '@prefix': true,\n    '@propagate': true,\n    '@protected': true,\n    '@reverse': true,\n    '@set': true,\n    '@type': true,\n    '@value': true,\n    '@version': true,\n    '@vocab': true,\n};\n// Keys in the contexts that will not be expanded based on the base IRI\nUtil.EXPAND_KEYS_BLACKLIST = [\n    '@base',\n    '@vocab',\n    '@language',\n    '@version',\n    '@direction',\n];\n// Keys in the contexts that may not be aliased from\nUtil.ALIAS_DOMAIN_BLACKLIST = [\n    '@container',\n    '@graph',\n    '@id',\n    '@index',\n    '@list',\n    '@nest',\n    '@none',\n    '@prefix',\n    '@reverse',\n    '@set',\n    '@type',\n    '@value',\n    '@version',\n];\n// Keys in the contexts that may not be aliased to\nUtil.ALIAS_RANGE_BLACKLIST = [\n    '@context',\n    '@preserve',\n];\n// All valid @container values\nUtil.CONTAINERS = [\n    '@list',\n    '@set',\n    '@index',\n    '@language',\n    '@graph',\n    '@id',\n    '@type',\n];\n// All valid @container values under processing mode 1.0\nUtil.CONTAINERS_1_0 = [\n    '@list',\n    '@set',\n    '@index',\n];\nexports.Util = Util;\n//# sourceMappingURL=Util.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultExpandOptions = exports.JsonLdContextNormalized = void 0;\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\nconst Util_1 = require(\"./Util\");\n/**\n * A class exposing operations over a normalized JSON-LD context.\n */\nclass JsonLdContextNormalized {\n    constructor(contextRaw) {\n        this.contextRaw = contextRaw;\n    }\n    /**\n     * @return The raw inner context.\n     */\n    getContextRaw() {\n        return this.contextRaw;\n    }\n    /**\n     * Expand the term or prefix of the given term if it has one,\n     * otherwise return the term as-is.\n     *\n     * This will try to expand the IRI as much as possible.\n     *\n     * Iff in vocab-mode, then other references to other terms in the context can be used,\n     * such as to `myTerm`:\n     * ```\n     * {\n     *   \"myTerm\": \"http://example.org/myLongTerm\"\n     * }\n     * ```\n     *\n     * @param {string} term A term that is an URL or a prefixed URL.\n     * @param {boolean} expandVocab If the term is a predicate or type and should be expanded based on @vocab,\n     *                              otherwise it is considered a regular term that is expanded based on @base.\n     * @param {IExpandOptions} options Options that define the way how expansion must be done.\n     * @return {string} The expanded term, the term as-is, or null if it was explicitly disabled in the context.\n     * @throws If the term is aliased to an invalid value (not a string, IRI or keyword).\n     */\n    expandTerm(term, expandVocab, options = exports.defaultExpandOptions) {\n        const contextValue = this.contextRaw[term];\n        // Immediately return if the term was disabled in the context\n        if (contextValue === null || (contextValue && contextValue['@id'] === null)) {\n            return null;\n        }\n        // Check the @id\n        let validIriMapping = true;\n        if (contextValue && expandVocab) {\n            const value = Util_1.Util.getContextValueId(contextValue);\n            if (value && value !== term) {\n                if (typeof value !== 'string' || (!Util_1.Util.isValidIri(value) && !Util_1.Util.isValidKeyword(value))) {\n                    // Don't mark this mapping as invalid if we have an unknown keyword, but of the correct form.\n                    if (!Util_1.Util.isPotentialKeyword(value)) {\n                        validIriMapping = false;\n                    }\n                }\n                else {\n                    return value;\n                }\n            }\n        }\n        // Check if the term is prefixed\n        const prefix = Util_1.Util.getPrefix(term, this.contextRaw);\n        const vocab = this.contextRaw['@vocab'];\n        const vocabRelative = (!!vocab || vocab === '') && vocab.indexOf(':') < 0;\n        const base = this.contextRaw['@base'];\n        const potentialKeyword = Util_1.Util.isPotentialKeyword(term);\n        if (prefix) {\n            const contextPrefixValue = this.contextRaw[prefix];\n            const value = Util_1.Util.getContextValueId(contextPrefixValue);\n            if (value) {\n                if (typeof contextPrefixValue === 'string' || !options.allowPrefixForcing) {\n                    // If we have a simple term definition,\n                    // check the last character of the prefix to determine whether or not it is a prefix.\n                    // Validate that prefix ends with gen-delim character, unless @prefix is true\n                    if (!Util_1.Util.isSimpleTermDefinitionPrefix(value, options)) {\n                        // Treat the term as an absolute IRI\n                        return term;\n                    }\n                }\n                else {\n                    // If we have an expanded term definition, default to @prefix: false\n                    if (value[0] !== '_' && !potentialKeyword && !contextPrefixValue['@prefix'] && !(term in this.contextRaw)) {\n                        // Treat the term as an absolute IRI\n                        return term;\n                    }\n                }\n                return value + term.substr(prefix.length + 1);\n            }\n        }\n        else if (expandVocab && ((vocab || vocab === '') || (options.allowVocabRelativeToBase && (base && vocabRelative)))\n            && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {\n            if (vocabRelative) {\n                if (options.allowVocabRelativeToBase) {\n                    return ((vocab || base) ? (0, relative_to_absolute_iri_1.resolve)(vocab, base) : '') + term;\n                }\n                else {\n                    throw new ErrorCoded_1.ErrorCoded(`Relative vocab expansion for term '${term}' with vocab '${vocab}' is not allowed.`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);\n                }\n            }\n            else {\n                return vocab + term;\n            }\n        }\n        else if (!expandVocab && base && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {\n            return (0, relative_to_absolute_iri_1.resolve)(term, base);\n        }\n        // Return the term as-is, unless we discovered an invalid IRI mapping for this term in the context earlier.\n        if (validIriMapping) {\n            return term;\n        }\n        else {\n            throw new ErrorCoded_1.ErrorCoded(`Invalid IRI mapping found for context entry '${term}': '${JSON.stringify(contextValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n        }\n    }\n    /**\n     * Compact the given term using @base, @vocab, an aliased term, or a prefixed term.\n     *\n     * This will try to compact the IRI as much as possible.\n     *\n     * @param {string} iri An IRI to compact.\n     * @param {boolean} vocab If the term is a predicate or type and should be compacted based on @vocab,\n     *                        otherwise it is considered a regular term that is compacted based on @base.\n     * @return {string} The compacted term or the IRI as-is.\n     */\n    compactIri(iri, vocab) {\n        // Try @vocab compacting\n        if (vocab && this.contextRaw['@vocab'] && iri.startsWith(this.contextRaw['@vocab'])) {\n            return iri.substr(this.contextRaw['@vocab'].length);\n        }\n        // Try @base compacting\n        if (!vocab && this.contextRaw['@base'] && iri.startsWith(this.contextRaw['@base'])) {\n            return iri.substr(this.contextRaw['@base'].length);\n        }\n        // Loop over all terms in the context\n        // This will try to prefix as short as possible.\n        // Once a fully compacted alias is found, return immediately, as we can not go any shorter.\n        const shortestPrefixing = { prefix: '', suffix: iri };\n        for (const key in this.contextRaw) {\n            const value = this.contextRaw[key];\n            if (value && !Util_1.Util.isPotentialKeyword(key)) {\n                const contextIri = Util_1.Util.getContextValueId(value);\n                if (iri.startsWith(contextIri)) {\n                    const suffix = iri.substr(contextIri.length);\n                    if (!suffix) {\n                        if (vocab) {\n                            // Immediately return on compacted alias\n                            return key;\n                        }\n                    }\n                    else if (suffix.length < shortestPrefixing.suffix.length) {\n                        // Overwrite the shortest prefix\n                        shortestPrefixing.prefix = key;\n                        shortestPrefixing.suffix = suffix;\n                    }\n                }\n            }\n        }\n        // Return the shortest prefix\n        if (shortestPrefixing.prefix) {\n            return shortestPrefixing.prefix + ':' + shortestPrefixing.suffix;\n        }\n        return iri;\n    }\n}\nexports.JsonLdContextNormalized = JsonLdContextNormalized;\nexports.defaultExpandOptions = {\n    allowPrefixForcing: true,\n    allowPrefixNonGenDelims: false,\n    allowVocabRelativeToBase: true,\n};\n//# sourceMappingURL=JsonLdContextNormalized.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContextParser = void 0;\nrequire(\"cross-fetch/polyfill\");\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\nconst FetchDocumentLoader_1 = require(\"./FetchDocumentLoader\");\nconst JsonLdContextNormalized_1 = require(\"./JsonLdContextNormalized\");\nconst Util_1 = require(\"./Util\");\n/**\n * Parses JSON-LD contexts.\n */\nclass ContextParser {\n    constructor(options) {\n        options = options || {};\n        this.documentLoader = options.documentLoader || new FetchDocumentLoader_1.FetchDocumentLoader();\n        this.documentCache = {};\n        this.validateContext = !options.skipValidation;\n        this.expandContentTypeToBase = !!options.expandContentTypeToBase;\n        this.remoteContextsDepthLimit = options.remoteContextsDepthLimit || 32;\n        this.redirectSchemaOrgHttps = 'redirectSchemaOrgHttps' in options ? !!options.redirectSchemaOrgHttps : true;\n    }\n    /**\n     * Validate the given @language value.\n     * An error will be thrown if it is invalid.\n     * @param value An @language value.\n     * @param {boolean} strictRange If the string value should be strictly checked against a regex.\n     * @param {string} errorCode The error code to emit on errors.\n     * @return {boolean} If validation passed.\n     *                   Can only be false if strictRange is false and the string value did not pass the regex.\n     */\n    static validateLanguage(value, strictRange, errorCode) {\n        if (typeof value !== 'string') {\n            throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a string, got '${JSON.stringify(value)}'`, errorCode);\n        }\n        if (!Util_1.Util.REGEX_LANGUAGE_TAG.test(value)) {\n            if (strictRange) {\n                throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a valid language tag, got '${JSON.stringify(value)}'`, errorCode);\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Validate the given @direction value.\n     * An error will be thrown if it is invalid.\n     * @param value An @direction value.\n     * @param {boolean} strictValues If the string value should be strictly checked against a regex.\n     * @return {boolean} If validation passed.\n     *                   Can only be false if strictRange is false and the string value did not pass the regex.\n     */\n    static validateDirection(value, strictValues) {\n        if (typeof value !== 'string') {\n            throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be a string, got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);\n        }\n        if (!Util_1.Util.REGEX_DIRECTION_TAG.test(value)) {\n            if (strictValues) {\n                throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be 'ltr' or 'rtl', got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Add an @id term for all @reverse terms.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @return {IJsonLdContextNormalizedRaw} The mutated input context.\n     */\n    idifyReverseTerms(context) {\n        for (const key of Object.keys(context)) {\n            let value = context[key];\n            if (value && typeof value === 'object') {\n                if (value['@reverse'] && !value['@id']) {\n                    if (typeof value['@reverse'] !== 'string' || Util_1.Util.isValidKeyword(value['@reverse'])) {\n                        throw new ErrorCoded_1.ErrorCoded(`Invalid @reverse value, must be absolute IRI or blank node: '${value['@reverse']}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                    }\n                    value = context[key] = Object.assign(Object.assign({}, value), { '@id': value['@reverse'] });\n                    value['@id'] = value['@reverse'];\n                    if (Util_1.Util.isPotentialKeyword(value['@reverse'])) {\n                        delete value['@reverse'];\n                    }\n                    else {\n                        value['@reverse'] = true;\n                    }\n                }\n            }\n        }\n        return context;\n    }\n    /**\n     * Expand all prefixed terms in the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {boolean} expandContentTypeToBase If @type inside the context may be expanded\n     *                                          via @base if @vocab is set to null.\n     * @param {string[]} keys Optional set of keys from the context to expand. If left undefined, all\n     * keys in the context will be expanded.\n     */\n    expandPrefixedTerms(context, expandContentTypeToBase, keys) {\n        const contextRaw = context.getContextRaw();\n        for (const key of (keys || Object.keys(contextRaw))) {\n            // Only expand allowed keys\n            if (Util_1.Util.EXPAND_KEYS_BLACKLIST.indexOf(key) < 0 && !Util_1.Util.isReservedInternalKeyword(key)) {\n                // Error if we try to alias a keyword to something else.\n                const keyValue = contextRaw[key];\n                if (Util_1.Util.isPotentialKeyword(key) && Util_1.Util.ALIAS_DOMAIN_BLACKLIST.indexOf(key) >= 0) {\n                    if (key !== '@type' || typeof contextRaw[key] === 'object'\n                        && !(contextRaw[key]['@protected'] || contextRaw[key]['@container'] === '@set')) {\n                        throw new ErrorCoded_1.ErrorCoded(`Keywords can not be aliased to something else.\nTried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);\n                    }\n                }\n                // Error if we try to alias to an illegal keyword\n                if (Util_1.Util.ALIAS_RANGE_BLACKLIST.indexOf(Util_1.Util.getContextValueId(keyValue)) >= 0) {\n                    throw new ErrorCoded_1.ErrorCoded(`Aliasing to certain keywords is not allowed.\nTried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.INVALID_KEYWORD_ALIAS);\n                }\n                // Error if this term was marked as prefix as well\n                if (keyValue && Util_1.Util.isPotentialKeyword(Util_1.Util.getContextValueId(keyValue))\n                    && keyValue['@prefix'] === true) {\n                    throw new ErrorCoded_1.ErrorCoded(`Tried to use keyword aliases as prefix: '${key}': '${JSON.stringify(keyValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n                // Loop because prefixes might be nested\n                while (Util_1.Util.isPrefixValue(contextRaw[key])) {\n                    const value = contextRaw[key];\n                    let changed = false;\n                    if (typeof value === 'string') {\n                        contextRaw[key] = context.expandTerm(value, true);\n                        changed = changed || value !== contextRaw[key];\n                    }\n                    else {\n                        const id = value['@id'];\n                        const type = value['@type'];\n                        // If @id is missing, don't allow @id to be added if @prefix: true and key not being a valid IRI.\n                        const canAddIdEntry = !('@prefix' in value) || Util_1.Util.isValidIri(key);\n                        if ('@id' in value) {\n                            // Use @id value for expansion\n                            if (id !== undefined && id !== null && typeof id === 'string') {\n                                contextRaw[key] = Object.assign(Object.assign({}, contextRaw[key]), { '@id': context.expandTerm(id, true) });\n                                changed = changed || id !== contextRaw[key]['@id'];\n                            }\n                        }\n                        else if (!Util_1.Util.isPotentialKeyword(key) && canAddIdEntry) {\n                            // Add an explicit @id value based on the expanded key value\n                            const newId = context.expandTerm(key, true);\n                            if (newId !== key) {\n                                // Don't set @id if expansion failed\n                                contextRaw[key] = Object.assign(Object.assign({}, contextRaw[key]), { '@id': newId });\n                                changed = true;\n                            }\n                        }\n                        if (type && typeof type === 'string' && type !== '@vocab'\n                            && (!value['@container'] || !value['@container']['@type'])\n                            && canAddIdEntry) {\n                            // First check @vocab, then fallback to @base\n                            let expandedType = context.expandTerm(type, true);\n                            if (expandContentTypeToBase && type === expandedType) {\n                                expandedType = context.expandTerm(type, false);\n                            }\n                            if (expandedType !== type) {\n                                changed = true;\n                                contextRaw[key] = Object.assign(Object.assign({}, contextRaw[key]), { '@type': expandedType });\n                            }\n                        }\n                    }\n                    if (!changed) {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Normalize the @language entries in the given context to lowercase.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} parseOptions The parsing options.\n     */\n    normalize(context, { processingMode, normalizeLanguageTags }) {\n        // Lowercase language keys in 1.0\n        if (normalizeLanguageTags || processingMode === 1.0) {\n            for (const key of Object.keys(context)) {\n                if (key === '@language' && typeof context[key] === 'string') {\n                    context[key] = context[key].toLowerCase();\n                }\n                else {\n                    const value = context[key];\n                    if (value && typeof value === 'object') {\n                        if (typeof value['@language'] === 'string') {\n                            const lowercase = value['@language'].toLowerCase();\n                            if (lowercase !== value['@language']) {\n                                context[key] = Object.assign(Object.assign({}, value), { '@language': lowercase });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Convert all @container strings and array values to hash-based values.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     */\n    containersToHash(context) {\n        for (const key of Object.keys(context)) {\n            const value = context[key];\n            if (value && typeof value === 'object') {\n                if (typeof value['@container'] === 'string') {\n                    context[key] = Object.assign(Object.assign({}, value), { '@container': { [value['@container']]: true } });\n                }\n                else if (Array.isArray(value['@container'])) {\n                    const newValue = {};\n                    for (const containerValue of value['@container']) {\n                        newValue[containerValue] = true;\n                    }\n                    context[key] = Object.assign(Object.assign({}, value), { '@container': newValue });\n                }\n            }\n        }\n    }\n    /**\n     * Normalize and apply context-level @protected terms onto each term separately.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {number} processingMode The processing mode.\n     */\n    applyScopedProtected(context, { processingMode }, expandOptions) {\n        if (processingMode && processingMode >= 1.1) {\n            if (context['@protected']) {\n                for (const key of Object.keys(context)) {\n                    if (Util_1.Util.isReservedInternalKeyword(key)) {\n                        continue;\n                    }\n                    if (!Util_1.Util.isPotentialKeyword(key) && !Util_1.Util.isTermProtected(context, key)) {\n                        const value = context[key];\n                        if (value && typeof value === 'object') {\n                            if (!('@protected' in context[key])) {\n                                // Mark terms with object values as protected if they don't have an @protected: false annotation\n                                context[key] = Object.assign(Object.assign({}, context[key]), { '@protected': true });\n                            }\n                        }\n                        else {\n                            // Convert string-based term values to object-based values with @protected: true\n                            context[key] = {\n                                '@id': value,\n                                '@protected': true,\n                            };\n                            if (Util_1.Util.isSimpleTermDefinitionPrefix(value, expandOptions)) {\n                                context[key] = Object.assign(Object.assign({}, context[key]), { '@prefix': true });\n                            }\n                        }\n                    }\n                }\n                delete context['@protected'];\n            }\n        }\n    }\n    /**\n     * Check if the given context inheritance does not contain any overrides of protected terms.\n     * @param {IJsonLdContextNormalizedRaw} contextBefore The context that may contain some protected terms.\n     * @param {IJsonLdContextNormalizedRaw} contextAfter A new context that is being applied on the first one.\n     * @param {IExpandOptions} expandOptions Options that are needed for any expansions during this validation.\n     * @param {string[]} keys Optional set of keys from the context to validate. If left undefined, all\n     * keys defined in contextAfter will be checked.\n     */\n    validateKeywordRedefinitions(contextBefore, contextAfter, expandOptions, keys) {\n        for (const key of (keys !== null && keys !== void 0 ? keys : Object.keys(contextAfter))) {\n            if (Util_1.Util.isTermProtected(contextBefore, key)) {\n                // The entry in the context before will always be in object-mode\n                // If the new entry is in string-mode, convert it to object-mode\n                // before checking if it is identical.\n                if (typeof contextAfter[key] === 'string') {\n                    contextAfter[key] = { '@id': contextAfter[key], '@protected': true };\n                }\n                else {\n                    // We modify this deliberately,\n                    // as we need it for the value comparison (they must be identical modulo '@protected')),\n                    // and for the fact that this new value will override the first one.\n                    contextAfter[key] = Object.assign(Object.assign({}, contextAfter[key]), { '@protected': true });\n                }\n                // Error if they are not identical\n                if (!Util_1.Util.deepEqual(contextBefore[key], contextAfter[key])) {\n                    throw new ErrorCoded_1.ErrorCoded(`Attempted to override the protected keyword ${key} from ${JSON.stringify(Util_1.Util.getContextValueId(contextBefore[key]))} to ${JSON.stringify(Util_1.Util.getContextValueId(contextAfter[key]))}`, ErrorCoded_1.ERROR_CODES.PROTECTED_TERM_REDEFINITION);\n                }\n            }\n        }\n    }\n    /**\n     * Validate the entries of the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} options The parse options.\n     */\n    validate(context, { processingMode }) {\n        for (const key of Object.keys(context)) {\n            // Ignore reserved internal keywords.\n            if (Util_1.Util.isReservedInternalKeyword(key)) {\n                continue;\n            }\n            // Do not allow empty term\n            if (key === '') {\n                throw new ErrorCoded_1.ErrorCoded(`The empty term is not allowed, got: '${key}': '${JSON.stringify(context[key])}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n            }\n            const value = context[key];\n            const valueType = typeof value;\n            // First check if the key is a keyword\n            if (Util_1.Util.isPotentialKeyword(key)) {\n                switch (key.substr(1)) {\n                    case 'vocab':\n                        if (value !== null && valueType !== 'string') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @vocab IRI: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);\n                        }\n                        break;\n                    case 'base':\n                        if (value !== null && valueType !== 'string') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @base IRI: ${context[key]}`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_IRI);\n                        }\n                        break;\n                    case 'language':\n                        if (value !== null) {\n                            ContextParser.validateLanguage(value, true, ErrorCoded_1.ERROR_CODES.INVALID_DEFAULT_LANGUAGE);\n                        }\n                        break;\n                    case 'version':\n                        if (value !== null && valueType !== 'number') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @version number: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VERSION_VALUE);\n                        }\n                        break;\n                    case 'direction':\n                        if (value !== null) {\n                            ContextParser.validateDirection(value, true);\n                        }\n                        break;\n                    case 'propagate':\n                        if (processingMode === 1.0) {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an illegal @propagate keyword: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n                        }\n                        if (value !== null && valueType !== 'boolean') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @propagate value: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_PROPAGATE_VALUE);\n                        }\n                        break;\n                }\n                // Don't allow keywords to be overridden\n                if (Util_1.Util.isValidKeyword(key) && Util_1.Util.isValidKeyword(Util_1.Util.getContextValueId(value))) {\n                    throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${Util_1.Util\n                        .getContextValueId(value)}'`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);\n                }\n                continue;\n            }\n            // Otherwise, consider the key a term\n            if (value !== null) {\n                switch (valueType) {\n                    case 'string':\n                        if (Util_1.Util.getPrefix(value, context) === key) {\n                            throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON\n                                .stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);\n                        }\n                        if (Util_1.Util.isValidIriWeak(key)) {\n                            if (value === '@type') {\n                                throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                            }\n                            else if (Util_1.Util.isValidIri(value) && value !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {\n                                throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                            }\n                        }\n                        break;\n                    case 'object':\n                        if (!Util_1.Util.isCompactIri(key) && !('@id' in value)\n                            && (value['@type'] === '@id' ? !context['@base'] : !context['@vocab'])) {\n                            throw new ErrorCoded_1.ErrorCoded(`Missing @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                        }\n                        for (const objectKey of Object.keys(value)) {\n                            const objectValue = value[objectKey];\n                            if (!objectValue) {\n                                continue;\n                            }\n                            switch (objectKey) {\n                                case '@id':\n                                    if (Util_1.Util.isValidKeyword(objectValue)\n                                        && objectValue !== '@type' && objectValue !== '@id' && objectValue !== '@graph' && objectValue !== '@nest') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                    }\n                                    if (Util_1.Util.isValidIriWeak(key)) {\n                                        if (objectValue === '@type') {\n                                            throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                        }\n                                        else if (Util_1.Util.isValidIri(objectValue)\n                                            && objectValue !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {\n                                            throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                        }\n                                    }\n                                    if (typeof objectValue !== 'string') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Detected non-string @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                    }\n                                    if (Util_1.Util.getPrefix(objectValue, context) === key) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON\n                                            .stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);\n                                    }\n                                    break;\n                                case '@type':\n                                    if (value['@container'] === '@type' && objectValue !== '@id' && objectValue !== '@vocab') {\n                                        throw new ErrorCoded_1.ErrorCoded(`@container: @type only allows @type: @id or @vocab, but got: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    if (typeof objectValue !== 'string') {\n                                        throw new ErrorCoded_1.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(valueType)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    if (objectValue !== '@id' && objectValue !== '@vocab'\n                                        && (processingMode === 1.0 || objectValue !== '@json')\n                                        && (processingMode === 1.0 || objectValue !== '@none')\n                                        && (objectValue[0] === '_' || !Util_1.Util.isValidIri(objectValue))) {\n                                        throw new ErrorCoded_1.ErrorCoded(`A context @type must be an absolute IRI, found: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    break;\n                                case '@reverse':\n                                    if (typeof objectValue === 'string' && value['@id'] && value['@id'] !== objectValue) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found non-matching @id and @reverse term values in '${key}':\\\n'${objectValue}' and '${value['@id']}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                    }\n                                    if ('@nest' in value) {\n                                        throw new ErrorCoded_1.ErrorCoded(`@nest is not allowed in the reverse property '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                    }\n                                    break;\n                                case '@container':\n                                    if (processingMode === 1.0) {\n                                        if (Object.keys(objectValue).length > 1\n                                            || Util_1.Util.CONTAINERS_1_0.indexOf(Object.keys(objectValue)[0]) < 0) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${Object.keys(objectValue)}') in 1.0, \\\nmust be only one of ${Util_1.Util.CONTAINERS_1_0.join(', ')}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);\n                                        }\n                                    }\n                                    for (const containerValue of Object.keys(objectValue)) {\n                                        if (containerValue === '@list' && value['@reverse']) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Term value can not be @container: @list and @reverse at the same time on '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                        }\n                                        if (Util_1.Util.CONTAINERS.indexOf(containerValue) < 0) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${containerValue}'), \\\nmust be one of ${Util_1.Util.CONTAINERS.join(', ')}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);\n                                        }\n                                    }\n                                    break;\n                                case '@language':\n                                    ContextParser.validateLanguage(objectValue, true, ErrorCoded_1.ERROR_CODES.INVALID_LANGUAGE_MAPPING);\n                                    break;\n                                case '@direction':\n                                    ContextParser.validateDirection(objectValue, true);\n                                    break;\n                                case '@prefix':\n                                    if (objectValue !== null && typeof objectValue !== 'boolean') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @prefix boolean in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_PREFIX_VALUE);\n                                    }\n                                    if (!('@id' in value) && !Util_1.Util.isValidIri(key)) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Invalid @prefix definition for '${key}' ('${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                                    }\n                                    break;\n                                case '@index':\n                                    if (processingMode === 1.0 || !value['@container'] || !value['@container']['@index']) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Attempt to add illegal key to value object: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                                    }\n                                    break;\n                                case '@nest':\n                                    if (Util_1.Util.isPotentialKeyword(objectValue) && objectValue !== '@nest') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @nest value in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_NEST_VALUE);\n                                    }\n                            }\n                        }\n                        break;\n                    default:\n                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term value: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n            }\n        }\n    }\n    /**\n     * Apply the @base context entry to the given context under certain circumstances.\n     * @param context A context.\n     * @param options Parsing options.\n     * @param inheritFromParent If the @base value from the parent context can be inherited.\n     * @return The given context.\n     */\n    applyBaseEntry(context, options, inheritFromParent) {\n        // In some special cases, this can be a string, so ignore those.\n        if (typeof context === 'string') {\n            return context;\n        }\n        // Give priority to @base in the parent context\n        if (inheritFromParent && !('@base' in context) && options.parentContext\n            && typeof options.parentContext === 'object' && '@base' in options.parentContext) {\n            context['@base'] = options.parentContext['@base'];\n            if (options.parentContext['@__baseDocument']) {\n                context['@__baseDocument'] = true;\n            }\n        }\n        // Override the base IRI if provided.\n        if (options.baseIRI && !options.external) {\n            if (!('@base' in context)) {\n                // The context base is the document base\n                context['@base'] = options.baseIRI;\n                context['@__baseDocument'] = true;\n            }\n            else if (context['@base'] !== null && typeof context['@base'] === 'string'\n                && !Util_1.Util.isValidIri(context['@base'])) {\n                // The context base is relative to the document base\n                context['@base'] = (0, relative_to_absolute_iri_1.resolve)(context['@base'], options.parentContext && options.parentContext['@base'] || options.baseIRI);\n            }\n        }\n        return context;\n    }\n    /**\n     * Resolve relative context IRIs, or return full IRIs as-is.\n     * @param {string} contextIri A context IRI.\n     * @param {string} baseIRI A base IRI.\n     * @return {string} The normalized context IRI.\n     */\n    normalizeContextIri(contextIri, baseIRI) {\n        if (!Util_1.Util.isValidIri(contextIri)) {\n            try {\n                contextIri = (0, relative_to_absolute_iri_1.resolve)(contextIri, baseIRI);\n            }\n            catch (_a) {\n                throw new Error(`Invalid context IRI: ${contextIri}`);\n            }\n        }\n        // TODO: Temporary workaround for fixing schema.org CORS issues (https://github.com/schemaorg/schemaorg/issues/2578#issuecomment-652324465)\n        if (this.redirectSchemaOrgHttps && contextIri.startsWith('http://schema.org')) {\n            contextIri = 'https://schema.org/';\n        }\n        return contextIri;\n    }\n    /**\n     * Parse scoped contexts in the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} options Parsing options.\n     * @return {IJsonLdContextNormalizedRaw} The mutated input context.\n     * @param {string[]} keys Optional set of keys from the context to parseInnerContexts of. If left undefined, all\n     * keys in the context will be iterated over.\n     */\n    async parseInnerContexts(context, options, keys) {\n        for (const key of (keys !== null && keys !== void 0 ? keys : Object.keys(context))) {\n            const value = context[key];\n            if (value && typeof value === 'object') {\n                if ('@context' in value && value['@context'] !== null && !options.ignoreScopedContexts) {\n                    // Simulate a processing based on the parent context to check if there are any (potential errors).\n                    // Honestly, I find it a bit weird to do this here, as the context may be unused,\n                    // and the final effective context may differ based on any other embedded/scoped contexts.\n                    // But hey, it's part of the spec, so we have no choice...\n                    // https://w3c.github.io/json-ld-api/#h-note-10\n                    if (this.validateContext) {\n                        try {\n                            const parentContext = Object.assign(Object.assign({}, context), { [key]: Object.assign({}, context[key]) });\n                            delete parentContext[key]['@context'];\n                            await this.parse(value['@context'], Object.assign(Object.assign({}, options), { external: false, parentContext, ignoreProtection: true, ignoreRemoteScopedContexts: true, ignoreScopedContexts: true }));\n                        }\n                        catch (e) {\n                            throw new ErrorCoded_1.ErrorCoded(e.message, ErrorCoded_1.ERROR_CODES.INVALID_SCOPED_CONTEXT);\n                        }\n                    }\n                    context[key] = Object.assign(Object.assign({}, value), { '@context': (await this.parse(value['@context'], Object.assign(Object.assign({}, options), { external: false, minimalProcessing: true, ignoreRemoteScopedContexts: true, parentContext: context })))\n                            .getContextRaw() });\n                }\n            }\n        }\n        return context;\n    }\n    async parse(context, options = {}, \n    // These options are only for internal use on recursive calls and should not be used by\n    // libraries consuming this function\n    internalOptions = {}) {\n        const { baseIRI, parentContext, external, processingMode = ContextParser.DEFAULT_PROCESSING_MODE, normalizeLanguageTags, ignoreProtection, minimalProcessing, } = options;\n        const remoteContexts = options.remoteContexts || {};\n        // Avoid remote context overflows\n        if (Object.keys(remoteContexts).length >= this.remoteContextsDepthLimit) {\n            throw new ErrorCoded_1.ErrorCoded('Detected an overflow in remote context inclusions: ' + Object.keys(remoteContexts), ErrorCoded_1.ERROR_CODES.CONTEXT_OVERFLOW);\n        }\n        if (context === null || context === undefined) {\n            // Don't allow context nullification and there are protected terms\n            if (!ignoreProtection && parentContext && Util_1.Util.hasProtectedTerms(parentContext)) {\n                throw new ErrorCoded_1.ErrorCoded('Illegal context nullification when terms are protected', ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_NULLIFICATION);\n            }\n            // Context that are explicitly set to null are empty.\n            return new JsonLdContextNormalized_1.JsonLdContextNormalized(this.applyBaseEntry({}, options, false));\n        }\n        else if (typeof context === 'string') {\n            const contextIri = this.normalizeContextIri(context, baseIRI);\n            const overriddenLoad = this.getOverriddenLoad(contextIri, options);\n            if (overriddenLoad) {\n                return new JsonLdContextNormalized_1.JsonLdContextNormalized(overriddenLoad);\n            }\n            const parsedStringContext = await this.parse(await this.load(contextIri), Object.assign(Object.assign({}, options), { baseIRI: contextIri, external: true, remoteContexts: Object.assign(Object.assign({}, remoteContexts), { [contextIri]: true }) }));\n            this.applyBaseEntry(parsedStringContext.getContextRaw(), options, true);\n            return parsedStringContext;\n        }\n        else if (Array.isArray(context)) {\n            // As a performance consideration, first load all external contexts in parallel.\n            const contextIris = [];\n            const contexts = await Promise.all(context.map((subContext, i) => {\n                if (typeof subContext === 'string') {\n                    const contextIri = this.normalizeContextIri(subContext, baseIRI);\n                    contextIris[i] = contextIri;\n                    const overriddenLoad = this.getOverriddenLoad(contextIri, options);\n                    if (overriddenLoad) {\n                        return overriddenLoad;\n                    }\n                    return this.load(contextIri);\n                }\n                else {\n                    return subContext;\n                }\n            }));\n            // Don't apply inheritance logic on minimal processing\n            if (minimalProcessing) {\n                return new JsonLdContextNormalized_1.JsonLdContextNormalized(contexts);\n            }\n            const reducedContexts = await contexts.reduce((accContextPromise, contextEntry, i) => accContextPromise\n                .then((accContext) => this.parse(contextEntry, Object.assign(Object.assign({}, options), { baseIRI: contextIris[i] || options.baseIRI, external: !!contextIris[i] || options.external, parentContext: accContext.getContextRaw(), remoteContexts: contextIris[i] ? Object.assign(Object.assign({}, remoteContexts), { [contextIris[i]]: true }) : remoteContexts }), \n            // @ts-expect-error: This third argument causes a type error because we have hidden it from consumers\n            {\n                skipValidation: i < contexts.length - 1,\n            })), Promise.resolve(new JsonLdContextNormalized_1.JsonLdContextNormalized(parentContext || {})));\n            // Override the base IRI if provided.\n            this.applyBaseEntry(reducedContexts.getContextRaw(), options, true);\n            return reducedContexts;\n        }\n        else if (typeof context === 'object') {\n            if ('@context' in context) {\n                return await this.parse(context['@context'], options);\n            }\n            // Make a deep clone of the given context, to avoid modifying it.\n            context = Object.assign({}, context);\n            // According to the JSON-LD spec, @base must be ignored from external contexts.\n            if (external) {\n                delete context['@base'];\n            }\n            // Override the base IRI if provided.\n            this.applyBaseEntry(context, options, true);\n            // Hashify container entries\n            // Do this before protected term validation as that influences term format\n            this.containersToHash(context);\n            // Don't perform any other modifications if only minimal processing is needed.\n            if (minimalProcessing) {\n                return new JsonLdContextNormalized_1.JsonLdContextNormalized(context);\n            }\n            // In JSON-LD 1.1, load @import'ed context prior to processing.\n            let importContext = {};\n            if ('@import' in context) {\n                if (processingMode >= 1.1) {\n                    // Only accept string values\n                    if (typeof context['@import'] !== 'string') {\n                        throw new ErrorCoded_1.ErrorCoded('An @import value must be a string, but got ' + typeof context['@import'], ErrorCoded_1.ERROR_CODES.INVALID_IMPORT_VALUE);\n                    }\n                    // Load context\n                    importContext = await this.loadImportContext(this.normalizeContextIri(context['@import'], baseIRI));\n                    delete context['@import'];\n                }\n                else {\n                    throw new ErrorCoded_1.ErrorCoded('Context importing is not supported in JSON-LD 1.0', ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n                }\n            }\n            this.applyScopedProtected(importContext, { processingMode }, JsonLdContextNormalized_1.defaultExpandOptions);\n            const newContext = Object.assign(importContext, context);\n            // Handle terms (before protection checks)\n            this.idifyReverseTerms(newContext);\n            this.normalize(newContext, { processingMode, normalizeLanguageTags });\n            this.applyScopedProtected(newContext, { processingMode }, JsonLdContextNormalized_1.defaultExpandOptions);\n            const keys = Object.keys(newContext);\n            const overlappingKeys = [];\n            if (typeof parentContext === 'object') {\n                // Merge different parts of the final context in order\n                for (const key in parentContext) {\n                    if (key in newContext) {\n                        overlappingKeys.push(key);\n                    }\n                    else {\n                        newContext[key] = parentContext[key];\n                    }\n                }\n            }\n            // Parse inner contexts with minimal processing\n            await this.parseInnerContexts(newContext, options, keys);\n            const newContextWrapped = new JsonLdContextNormalized_1.JsonLdContextNormalized(newContext);\n            // In JSON-LD 1.1, @vocab can be relative to @vocab in the parent context, or a compact IRI.\n            if ((newContext && newContext['@version'] || ContextParser.DEFAULT_PROCESSING_MODE) >= 1.1\n                && ((context['@vocab'] && typeof context['@vocab'] === 'string') || context['@vocab'] === '')) {\n                if (parentContext && '@vocab' in parentContext && context['@vocab'].indexOf(':') < 0) {\n                    newContext['@vocab'] = parentContext['@vocab'] + context['@vocab'];\n                }\n                else if (Util_1.Util.isCompactIri(context['@vocab']) || context['@vocab'] in newContext) {\n                    // @vocab is a compact IRI or refers exactly to a prefix\n                    newContext['@vocab'] = newContextWrapped.expandTerm(context['@vocab'], true);\n                }\n            }\n            this.expandPrefixedTerms(newContextWrapped, this.expandContentTypeToBase, keys);\n            // In JSON-LD 1.1, check if we are not redefining any protected keywords\n            if (!ignoreProtection && parentContext && processingMode >= 1.1) {\n                this.validateKeywordRedefinitions(parentContext, newContext, JsonLdContextNormalized_1.defaultExpandOptions, overlappingKeys);\n            }\n            if (this.validateContext && !internalOptions.skipValidation) {\n                this.validate(newContext, { processingMode });\n            }\n            return newContextWrapped;\n        }\n        else {\n            throw new ErrorCoded_1.ErrorCoded(`Tried parsing a context that is not a string, array or object, but got ${context}`, ErrorCoded_1.ERROR_CODES.INVALID_LOCAL_CONTEXT);\n        }\n    }\n    /**\n     * Fetch the given URL as a raw JSON-LD context.\n     * @param url An URL.\n     * @return A promise resolving to a raw JSON-LD context.\n     */\n    async load(url) {\n        // First try to retrieve the context from cache\n        const cached = this.documentCache[url];\n        if (cached) {\n            return cached;\n        }\n        // If not in cache, load it\n        let document;\n        try {\n            document = await this.documentLoader.load(url);\n        }\n        catch (e) {\n            throw new ErrorCoded_1.ErrorCoded(`Failed to load remote context ${url}: ${e.message}`, ErrorCoded_1.ERROR_CODES.LOADING_REMOTE_CONTEXT_FAILED);\n        }\n        // Validate the context\n        if (!('@context' in document)) {\n            throw new ErrorCoded_1.ErrorCoded(`Missing @context in remote context at ${url}`, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);\n        }\n        return this.documentCache[url] = document['@context'];\n    }\n    /**\n     * Override the given context that may be loaded.\n     *\n     * This will check whether or not the url is recursively being loaded.\n     * @param url An URL.\n     * @param options Parsing options.\n     * @return An overridden context, or null.\n     *         Optionally an error can be thrown if a cyclic context is detected.\n     */\n    getOverriddenLoad(url, options) {\n        if (url in (options.remoteContexts || {})) {\n            if (options.ignoreRemoteScopedContexts) {\n                return url;\n            }\n            else {\n                throw new ErrorCoded_1.ErrorCoded('Detected a cyclic context inclusion of ' + url, ErrorCoded_1.ERROR_CODES.RECURSIVE_CONTEXT_INCLUSION);\n            }\n        }\n        return null;\n    }\n    /**\n     * Load an @import'ed context.\n     * @param importContextIri The full URI of an @import value.\n     */\n    async loadImportContext(importContextIri) {\n        // Load the context - and do a deep clone since we are about to mutate it\n        let importContext = await this.load(importContextIri);\n        // Require the context to be a non-array object\n        if (typeof importContext !== 'object' || Array.isArray(importContext)) {\n            throw new ErrorCoded_1.ErrorCoded('An imported context must be a single object: ' + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);\n        }\n        // Error if the context contains another @import\n        if ('@import' in importContext) {\n            throw new ErrorCoded_1.ErrorCoded('An imported context can not import another context: ' + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n        }\n        importContext = Object.assign({}, importContext);\n        // Containers have to be converted into hash values the same way as for the importing context\n        // Otherwise context validation will fail for container values\n        this.containersToHash(importContext);\n        return importContext;\n    }\n}\nContextParser.DEFAULT_PROCESSING_MODE = 1.1;\nexports.ContextParser = ContextParser;\n//# sourceMappingURL=ContextParser.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=IDocumentLoader.js.map","\"use strict\";\n// tslint:disable:max-line-length\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=JsonLdContext.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/ContextParser\"), exports);\n__exportStar(require(\"./lib/ErrorCoded\"), exports);\n__exportStar(require(\"./lib/FetchDocumentLoader\"), exports);\n__exportStar(require(\"./lib/IDocumentLoader\"), exports);\n__exportStar(require(\"./lib/JsonLdContext\"), exports);\n__exportStar(require(\"./lib/JsonLdContextNormalized\"), exports);\n__exportStar(require(\"./lib/Util\"), exports);\n//# sourceMappingURL=index.js.map","'use strict'\n\n/*\n  This file is a reduced and adapted version of the main lib/internal/per_context/primordials.js file defined at\n\n  https://github.com/nodejs/node/blob/master/lib/internal/per_context/primordials.js\n\n  Don't try to replace with the original file and keep it up to date with the upstream file.\n*/\nmodule.exports = {\n  ArrayIsArray(self) {\n    return Array.isArray(self)\n  },\n  ArrayPrototypeIncludes(self, el) {\n    return self.includes(el)\n  },\n  ArrayPrototypeIndexOf(self, el) {\n    return self.indexOf(el)\n  },\n  ArrayPrototypeJoin(self, sep) {\n    return self.join(sep)\n  },\n  ArrayPrototypeMap(self, fn) {\n    return self.map(fn)\n  },\n  ArrayPrototypePop(self, el) {\n    return self.pop(el)\n  },\n  ArrayPrototypePush(self, el) {\n    return self.push(el)\n  },\n  ArrayPrototypeSlice(self, start, end) {\n    return self.slice(start, end)\n  },\n  Error,\n  FunctionPrototypeCall(fn, thisArgs, ...args) {\n    return fn.call(thisArgs, ...args)\n  },\n  FunctionPrototypeSymbolHasInstance(self, instance) {\n    return Function.prototype[Symbol.hasInstance].call(self, instance)\n  },\n  MathFloor: Math.floor,\n  Number,\n  NumberIsInteger: Number.isInteger,\n  NumberIsNaN: Number.isNaN,\n  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,\n  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,\n  NumberParseInt: Number.parseInt,\n  ObjectDefineProperties(self, props) {\n    return Object.defineProperties(self, props)\n  },\n  ObjectDefineProperty(self, name, prop) {\n    return Object.defineProperty(self, name, prop)\n  },\n  ObjectGetOwnPropertyDescriptor(self, name) {\n    return Object.getOwnPropertyDescriptor(self, name)\n  },\n  ObjectKeys(obj) {\n    return Object.keys(obj)\n  },\n  ObjectSetPrototypeOf(target, proto) {\n    return Object.setPrototypeOf(target, proto)\n  },\n  Promise,\n  PromisePrototypeCatch(self, fn) {\n    return self.catch(fn)\n  },\n  PromisePrototypeThen(self, thenFn, catchFn) {\n    return self.then(thenFn, catchFn)\n  },\n  PromiseReject(err) {\n    return Promise.reject(err)\n  },\n  PromiseResolve(val) {\n    return Promise.resolve(val)\n  },\n  ReflectApply: Reflect.apply,\n  RegExpPrototypeTest(self, value) {\n    return self.test(value)\n  },\n  SafeSet: Set,\n  String,\n  StringPrototypeSlice(self, start, end) {\n    return self.slice(start, end)\n  },\n  StringPrototypeToLowerCase(self) {\n    return self.toLowerCase()\n  },\n  StringPrototypeToUpperCase(self) {\n    return self.toUpperCase()\n  },\n  StringPrototypeTrim(self) {\n    return self.trim()\n  },\n  Symbol,\n  SymbolFor: Symbol.for,\n  SymbolAsyncIterator: Symbol.asyncIterator,\n  SymbolHasInstance: Symbol.hasInstance,\n  SymbolIterator: Symbol.iterator,\n  SymbolDispose: Symbol.dispose || Symbol('Symbol.dispose'),\n  SymbolAsyncDispose: Symbol.asyncDispose || Symbol('Symbol.asyncDispose'),\n  TypedArrayPrototypeSet(self, buf, len) {\n    return self.set(buf, len)\n  },\n  Boolean: Boolean,\n  Uint8Array\n}\n","'use strict'\n\nconst bufferModule = require('buffer')\nconst { kResistStopPropagation, SymbolDispose } = require('./primordials')\nconst AbortSignal = globalThis.AbortSignal || require('abort-controller').AbortSignal\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nconst AsyncFunction = Object.getPrototypeOf(async function () {}).constructor\nconst Blob = globalThis.Blob || bufferModule.Blob\n/* eslint-disable indent */\nconst isBlob =\n  typeof Blob !== 'undefined'\n    ? function isBlob(b) {\n        // eslint-disable-next-line indent\n        return b instanceof Blob\n      }\n    : function isBlob(b) {\n        return false\n      }\n/* eslint-enable indent */\n\nconst validateAbortSignal = (signal, name) => {\n  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)\n  }\n}\nconst validateFunction = (value, name) => {\n  if (typeof value !== 'function') throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)\n}\n\n// This is a simplified version of AggregateError\nclass AggregateError extends Error {\n  constructor(errors) {\n    if (!Array.isArray(errors)) {\n      throw new TypeError(`Expected input to be an Array, got ${typeof errors}`)\n    }\n    let message = ''\n    for (let i = 0; i < errors.length; i++) {\n      message += `    ${errors[i].stack}\\n`\n    }\n    super(message)\n    this.name = 'AggregateError'\n    this.errors = errors\n  }\n}\nmodule.exports = {\n  AggregateError,\n  kEmptyObject: Object.freeze({}),\n  once(callback) {\n    let called = false\n    return function (...args) {\n      if (called) {\n        return\n      }\n      called = true\n      callback.apply(this, args)\n    }\n  },\n  createDeferredPromise: function () {\n    let resolve\n    let reject\n\n    // eslint-disable-next-line promise/param-names\n    const promise = new Promise((res, rej) => {\n      resolve = res\n      reject = rej\n    })\n    return {\n      promise,\n      resolve,\n      reject\n    }\n  },\n  promisify(fn) {\n    return new Promise((resolve, reject) => {\n      fn((err, ...args) => {\n        if (err) {\n          return reject(err)\n        }\n        return resolve(...args)\n      })\n    })\n  },\n  debuglog() {\n    return function () {}\n  },\n  format(format, ...args) {\n    // Simplified version of https://nodejs.org/api/util.html#utilformatformat-args\n    return format.replace(/%([sdifj])/g, function (...[_unused, type]) {\n      const replacement = args.shift()\n      if (type === 'f') {\n        return replacement.toFixed(6)\n      } else if (type === 'j') {\n        return JSON.stringify(replacement)\n      } else if (type === 's' && typeof replacement === 'object') {\n        const ctor = replacement.constructor !== Object ? replacement.constructor.name : ''\n        return `${ctor} {}`.trim()\n      } else {\n        return replacement.toString()\n      }\n    })\n  },\n  inspect(value) {\n    // Vastly simplified version of https://nodejs.org/api/util.html#utilinspectobject-options\n    switch (typeof value) {\n      case 'string':\n        if (value.includes(\"'\")) {\n          if (!value.includes('\"')) {\n            return `\"${value}\"`\n          } else if (!value.includes('`') && !value.includes('${')) {\n            return `\\`${value}\\``\n          }\n        }\n        return `'${value}'`\n      case 'number':\n        if (isNaN(value)) {\n          return 'NaN'\n        } else if (Object.is(value, -0)) {\n          return String(value)\n        }\n        return value\n      case 'bigint':\n        return `${String(value)}n`\n      case 'boolean':\n      case 'undefined':\n        return String(value)\n      case 'object':\n        return '{}'\n    }\n  },\n  types: {\n    isAsyncFunction(fn) {\n      return fn instanceof AsyncFunction\n    },\n    isArrayBufferView(arr) {\n      return ArrayBuffer.isView(arr)\n    }\n  },\n  isBlob,\n  deprecate(fn, message) {\n    return fn\n  },\n  addAbortListener:\n    require('events').addAbortListener ||\n    function addAbortListener(signal, listener) {\n      if (signal === undefined) {\n        throw new ERR_INVALID_ARG_TYPE('signal', 'AbortSignal', signal)\n      }\n      validateAbortSignal(signal, 'signal')\n      validateFunction(listener, 'listener')\n      let removeEventListener\n      if (signal.aborted) {\n        queueMicrotask(() => listener())\n      } else {\n        signal.addEventListener('abort', listener, {\n          __proto__: null,\n          once: true,\n          [kResistStopPropagation]: true\n        })\n        removeEventListener = () => {\n          signal.removeEventListener('abort', listener)\n        }\n      }\n      return {\n        __proto__: null,\n        [SymbolDispose]() {\n          var _removeEventListener\n          ;(_removeEventListener = removeEventListener) === null || _removeEventListener === undefined\n            ? undefined\n            : _removeEventListener()\n        }\n      }\n    },\n  AbortSignalAny:\n    AbortSignal.any ||\n    function AbortSignalAny(signals) {\n      // Fast path if there is only one signal.\n      if (signals.length === 1) {\n        return signals[0]\n      }\n      const ac = new AbortController()\n      const abort = () => ac.abort()\n      signals.forEach((signal) => {\n        validateAbortSignal(signal, 'signals')\n        signal.addEventListener('abort', abort, {\n          once: true\n        })\n      })\n      ac.signal.addEventListener(\n        'abort',\n        () => {\n          signals.forEach((signal) => signal.removeEventListener('abort', abort))\n        },\n        {\n          once: true\n        }\n      )\n      return ac.signal\n    }\n}\nmodule.exports.promisify.custom = Symbol.for('nodejs.util.promisify.custom')\n","'use strict'\n\nconst { format, inspect, AggregateError: CustomAggregateError } = require('./util')\n\n/*\n  This file is a reduced and adapted version of the main lib/internal/errors.js file defined at\n\n  https://github.com/nodejs/node/blob/master/lib/internal/errors.js\n\n  Don't try to replace with the original file and keep it up to date (starting from E(...) definitions)\n  with the upstream file.\n*/\n\nconst AggregateError = globalThis.AggregateError || CustomAggregateError\nconst kIsNodeError = Symbol('kIsNodeError')\nconst kTypes = [\n  'string',\n  'function',\n  'number',\n  'object',\n  // Accept 'Function' and 'Object' as alternative to the lower cased version.\n  'Function',\n  'Object',\n  'boolean',\n  'bigint',\n  'symbol'\n]\nconst classRegExp = /^([A-Z][a-z0-9]*)+$/\nconst nodeInternalPrefix = '__node_internal_'\nconst codes = {}\nfunction assert(value, message) {\n  if (!value) {\n    throw new codes.ERR_INTERNAL_ASSERTION(message)\n  }\n}\n\n// Only use this for integers! Decimal numbers do not work with this function.\nfunction addNumericalSeparator(val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\nfunction getMessage(key, msg, args) {\n  if (typeof msg === 'function') {\n    assert(\n      msg.length <= args.length,\n      // Default options do not count.\n      `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`\n    )\n    return msg(...args)\n  }\n  const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length\n  assert(\n    expectedLength === args.length,\n    `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`\n  )\n  if (args.length === 0) {\n    return msg\n  }\n  return format(msg, ...args)\n}\nfunction E(code, message, Base) {\n  if (!Base) {\n    Base = Error\n  }\n  class NodeError extends Base {\n    constructor(...args) {\n      super(getMessage(code, message, args))\n    }\n    toString() {\n      return `${this.name} [${code}]: ${this.message}`\n    }\n  }\n  Object.defineProperties(NodeError.prototype, {\n    name: {\n      value: Base.name,\n      writable: true,\n      enumerable: false,\n      configurable: true\n    },\n    toString: {\n      value() {\n        return `${this.name} [${code}]: ${this.message}`\n      },\n      writable: true,\n      enumerable: false,\n      configurable: true\n    }\n  })\n  NodeError.prototype.code = code\n  NodeError.prototype[kIsNodeError] = true\n  codes[code] = NodeError\n}\nfunction hideStackFrames(fn) {\n  // We rename the functions that will be hidden to cut off the stacktrace\n  // at the outermost one\n  const hidden = nodeInternalPrefix + fn.name\n  Object.defineProperty(fn, 'name', {\n    value: hidden\n  })\n  return fn\n}\nfunction aggregateTwoErrors(innerError, outerError) {\n  if (innerError && outerError && innerError !== outerError) {\n    if (Array.isArray(outerError.errors)) {\n      // If `outerError` is already an `AggregateError`.\n      outerError.errors.push(innerError)\n      return outerError\n    }\n    const err = new AggregateError([outerError, innerError], outerError.message)\n    err.code = outerError.code\n    return err\n  }\n  return innerError || outerError\n}\nclass AbortError extends Error {\n  constructor(message = 'The operation was aborted', options = undefined) {\n    if (options !== undefined && typeof options !== 'object') {\n      throw new codes.ERR_INVALID_ARG_TYPE('options', 'Object', options)\n    }\n    super(message, options)\n    this.code = 'ABORT_ERR'\n    this.name = 'AbortError'\n  }\n}\nE('ERR_ASSERTION', '%s', Error)\nE(\n  'ERR_INVALID_ARG_TYPE',\n  (name, expected, actual) => {\n    assert(typeof name === 'string', \"'name' must be a string\")\n    if (!Array.isArray(expected)) {\n      expected = [expected]\n    }\n    let msg = 'The '\n    if (name.endsWith(' argument')) {\n      // For cases like 'first argument'\n      msg += `${name} `\n    } else {\n      msg += `\"${name}\" ${name.includes('.') ? 'property' : 'argument'} `\n    }\n    msg += 'must be '\n    const types = []\n    const instances = []\n    const other = []\n    for (const value of expected) {\n      assert(typeof value === 'string', 'All expected entries have to be of type string')\n      if (kTypes.includes(value)) {\n        types.push(value.toLowerCase())\n      } else if (classRegExp.test(value)) {\n        instances.push(value)\n      } else {\n        assert(value !== 'object', 'The value \"object\" should be written as \"Object\"')\n        other.push(value)\n      }\n    }\n\n    // Special handle `object` in case other instances are allowed to outline\n    // the differences between each other.\n    if (instances.length > 0) {\n      const pos = types.indexOf('object')\n      if (pos !== -1) {\n        types.splice(types, pos, 1)\n        instances.push('Object')\n      }\n    }\n    if (types.length > 0) {\n      switch (types.length) {\n        case 1:\n          msg += `of type ${types[0]}`\n          break\n        case 2:\n          msg += `one of type ${types[0]} or ${types[1]}`\n          break\n        default: {\n          const last = types.pop()\n          msg += `one of type ${types.join(', ')}, or ${last}`\n        }\n      }\n      if (instances.length > 0 || other.length > 0) {\n        msg += ' or '\n      }\n    }\n    if (instances.length > 0) {\n      switch (instances.length) {\n        case 1:\n          msg += `an instance of ${instances[0]}`\n          break\n        case 2:\n          msg += `an instance of ${instances[0]} or ${instances[1]}`\n          break\n        default: {\n          const last = instances.pop()\n          msg += `an instance of ${instances.join(', ')}, or ${last}`\n        }\n      }\n      if (other.length > 0) {\n        msg += ' or '\n      }\n    }\n    switch (other.length) {\n      case 0:\n        break\n      case 1:\n        if (other[0].toLowerCase() !== other[0]) {\n          msg += 'an '\n        }\n        msg += `${other[0]}`\n        break\n      case 2:\n        msg += `one of ${other[0]} or ${other[1]}`\n        break\n      default: {\n        const last = other.pop()\n        msg += `one of ${other.join(', ')}, or ${last}`\n      }\n    }\n    if (actual == null) {\n      msg += `. Received ${actual}`\n    } else if (typeof actual === 'function' && actual.name) {\n      msg += `. Received function ${actual.name}`\n    } else if (typeof actual === 'object') {\n      var _actual$constructor\n      if (\n        (_actual$constructor = actual.constructor) !== null &&\n        _actual$constructor !== undefined &&\n        _actual$constructor.name\n      ) {\n        msg += `. Received an instance of ${actual.constructor.name}`\n      } else {\n        const inspected = inspect(actual, {\n          depth: -1\n        })\n        msg += `. Received ${inspected}`\n      }\n    } else {\n      let inspected = inspect(actual, {\n        colors: false\n      })\n      if (inspected.length > 25) {\n        inspected = `${inspected.slice(0, 25)}...`\n      }\n      msg += `. Received type ${typeof actual} (${inspected})`\n    }\n    return msg\n  },\n  TypeError\n)\nE(\n  'ERR_INVALID_ARG_VALUE',\n  (name, value, reason = 'is invalid') => {\n    let inspected = inspect(value)\n    if (inspected.length > 128) {\n      inspected = inspected.slice(0, 128) + '...'\n    }\n    const type = name.includes('.') ? 'property' : 'argument'\n    return `The ${type} '${name}' ${reason}. Received ${inspected}`\n  },\n  TypeError\n)\nE(\n  'ERR_INVALID_RETURN_VALUE',\n  (input, name, value) => {\n    var _value$constructor\n    const type =\n      value !== null &&\n      value !== undefined &&\n      (_value$constructor = value.constructor) !== null &&\n      _value$constructor !== undefined &&\n      _value$constructor.name\n        ? `instance of ${value.constructor.name}`\n        : `type ${typeof value}`\n    return `Expected ${input} to be returned from the \"${name}\"` + ` function but got ${type}.`\n  },\n  TypeError\n)\nE(\n  'ERR_MISSING_ARGS',\n  (...args) => {\n    assert(args.length > 0, 'At least one arg needs to be specified')\n    let msg\n    const len = args.length\n    args = (Array.isArray(args) ? args : [args]).map((a) => `\"${a}\"`).join(' or ')\n    switch (len) {\n      case 1:\n        msg += `The ${args[0]} argument`\n        break\n      case 2:\n        msg += `The ${args[0]} and ${args[1]} arguments`\n        break\n      default:\n        {\n          const last = args.pop()\n          msg += `The ${args.join(', ')}, and ${last} arguments`\n        }\n        break\n    }\n    return `${msg} must be specified`\n  },\n  TypeError\n)\nE(\n  'ERR_OUT_OF_RANGE',\n  (str, range, input) => {\n    assert(range, 'Missing \"range\" argument')\n    let received\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > 2n ** 32n || input < -(2n ** 32n)) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    } else {\n      received = inspect(input)\n    }\n    return `The value of \"${str}\" is out of range. It must be ${range}. Received ${received}`\n  },\n  RangeError\n)\nE('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times', Error)\nE('ERR_METHOD_NOT_IMPLEMENTED', 'The %s method is not implemented', Error)\nE('ERR_STREAM_ALREADY_FINISHED', 'Cannot call %s after a stream was finished', Error)\nE('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable', Error)\nE('ERR_STREAM_DESTROYED', 'Cannot call %s after a stream was destroyed', Error)\nE('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError)\nE('ERR_STREAM_PREMATURE_CLOSE', 'Premature close', Error)\nE('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF', Error)\nE('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event', Error)\nE('ERR_STREAM_WRITE_AFTER_END', 'write after end', Error)\nE('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s', TypeError)\nmodule.exports = {\n  AbortError,\n  aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),\n  hideStackFrames,\n  codes\n}\n","/* eslint jsdoc/require-jsdoc: \"error\" */\n\n'use strict'\n\nconst {\n  ArrayIsArray,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberMAX_SAFE_INTEGER,\n  NumberMIN_SAFE_INTEGER,\n  NumberParseInt,\n  ObjectPrototypeHasOwnProperty,\n  RegExpPrototypeExec,\n  String,\n  StringPrototypeToUpperCase,\n  StringPrototypeTrim\n} = require('../ours/primordials')\nconst {\n  hideStackFrames,\n  codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }\n} = require('../ours/errors')\nconst { normalizeEncoding } = require('../ours/util')\nconst { isAsyncFunction, isArrayBufferView } = require('../ours/util').types\nconst signals = {}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isInt32(value) {\n  return value === (value | 0)\n}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isUint32(value) {\n  return value === value >>> 0\n}\nconst octalReg = /^[0-7]+$/\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string'\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land, but any value higher than 0o777 will result in platform-specific\n * behaviors.\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified, will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value, name, def) {\n  if (typeof value === 'undefined') {\n    value = def\n  }\n  if (typeof value === 'string') {\n    if (RegExpPrototypeExec(octalReg, value) === null) {\n      throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc)\n    }\n    value = NumberParseInt(value, 8)\n  }\n  validateUint32(value, name)\n  return value\n}\n\n/**\n * @callback validateInteger\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInteger} */\nconst validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {\n  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, 'an integer', value)\n  if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)\n})\n\n/**\n * @callback validateInt32\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInt32} */\nconst validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {\n  // The defaults for min and max correspond to the limits of 32-bit integers.\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)\n  }\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)\n  }\n})\n\n/**\n * @callback validateUint32\n * @param {*} value\n * @param {string} name\n * @param {number|boolean} [positive=false]\n * @returns {asserts value is number}\n */\n\n/** @type {validateUint32} */\nconst validateUint32 = hideStackFrames((value, name, positive = false) => {\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)\n  }\n  const min = positive ? 1 : 0\n  // 2 ** 32 === 4294967296\n  const max = 4294967295\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)\n  }\n})\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value, name) {\n  if (typeof value !== 'string') throw new ERR_INVALID_ARG_TYPE(name, 'string', value)\n}\n\n/**\n * @callback validateNumber\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateNumber} */\nfunction validateNumber(value, name, min = undefined, max) {\n  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  if (\n    (min != null && value < min) ||\n    (max != null && value > max) ||\n    ((min != null || max != null) && NumberIsNaN(value))\n  ) {\n    throw new ERR_OUT_OF_RANGE(\n      name,\n      `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`,\n      value\n    )\n  }\n}\n\n/**\n * @callback validateOneOf\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} oneOf\n */\n\n/** @type {validateOneOf} */\nconst validateOneOf = hideStackFrames((value, name, oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf, value)) {\n    const allowed = ArrayPrototypeJoin(\n      ArrayPrototypeMap(oneOf, (v) => (typeof v === 'string' ? `'${v}'` : String(v))),\n      ', '\n    )\n    const reason = 'must be one of: ' + allowed\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason)\n  }\n})\n\n/**\n * @callback validateBoolean\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean}\n */\n\n/** @type {validateBoolean} */\nfunction validateBoolean(value, name) {\n  if (typeof value !== 'boolean') throw new ERR_INVALID_ARG_TYPE(name, 'boolean', value)\n}\n\n/**\n * @param {any} options\n * @param {string} key\n * @param {boolean} defaultValue\n * @returns {boolean}\n */\nfunction getOwnPropertyValueOrDefault(options, key, defaultValue) {\n  return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key]\n}\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = hideStackFrames((value, name, options = null) => {\n  const allowArray = getOwnPropertyValueOrDefault(options, 'allowArray', false)\n  const allowFunction = getOwnPropertyValueOrDefault(options, 'allowFunction', false)\n  const nullable = getOwnPropertyValueOrDefault(options, 'nullable', false)\n  if (\n    (!nullable && value === null) ||\n    (!allowArray && ArrayIsArray(value)) ||\n    (typeof value !== 'object' && (!allowFunction || typeof value !== 'function'))\n  ) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Object', value)\n  }\n})\n\n/**\n * @callback validateDictionary - We are using the Web IDL Standard definition\n *                                of \"dictionary\" here, which means any value\n *                                whose Type is either Undefined, Null, or\n *                                Object (which includes functions).\n * @param {*} value\n * @param {string} name\n * @see https://webidl.spec.whatwg.org/#es-dictionary\n * @see https://tc39.es/ecma262/#table-typeof-operator-results\n */\n\n/** @type {validateDictionary} */\nconst validateDictionary = hideStackFrames((value, name) => {\n  if (value != null && typeof value !== 'object' && typeof value !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'a dictionary', value)\n  }\n})\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\n\n/** @type {validateArray} */\nconst validateArray = hideStackFrames((value, name, minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Array', value)\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason)\n  }\n})\n\n/**\n * @callback validateStringArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string[]}\n */\n\n/** @type {validateStringArray} */\nfunction validateStringArray(value, name) {\n  validateArray(value, name)\n  for (let i = 0; i < value.length; i++) {\n    validateString(value[i], `${name}[${i}]`)\n  }\n}\n\n/**\n * @callback validateBooleanArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean[]}\n */\n\n/** @type {validateBooleanArray} */\nfunction validateBooleanArray(value, name) {\n  validateArray(value, name)\n  for (let i = 0; i < value.length; i++) {\n    validateBoolean(value[i], `${name}[${i}]`)\n  }\n}\n\n/**\n * @callback validateAbortSignalArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is AbortSignal[]}\n */\n\n/** @type {validateAbortSignalArray} */\nfunction validateAbortSignalArray(value, name) {\n  validateArray(value, name)\n  for (let i = 0; i < value.length; i++) {\n    const signal = value[i]\n    const indexedName = `${name}[${i}]`\n    if (signal == null) {\n      throw new ERR_INVALID_ARG_TYPE(indexedName, 'AbortSignal', signal)\n    }\n    validateAbortSignal(signal, indexedName)\n  }\n}\n\n/**\n * @param {*} signal\n * @param {string} [name='signal']\n * @returns {asserts signal is keyof signals}\n */\nfunction validateSignalName(signal, name = 'signal') {\n  validateString(signal, name)\n  if (signals[signal] === undefined) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal + ' (signals must use all capital letters)')\n    }\n    throw new ERR_UNKNOWN_SIGNAL(signal)\n  }\n}\n\n/**\n * @callback validateBuffer\n * @param {*} buffer\n * @param {string} [name='buffer']\n * @returns {asserts buffer is ArrayBufferView}\n */\n\n/** @type {validateBuffer} */\nconst validateBuffer = hideStackFrames((buffer, name = 'buffer') => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name, ['Buffer', 'TypedArray', 'DataView'], buffer)\n  }\n})\n\n/**\n * @param {string} data\n * @param {string} encoding\n */\nfunction validateEncoding(data, encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding)\n  const length = data.length\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding', encoding, `is invalid for data of length ${length}`)\n  }\n}\n\n/**\n * Check that the port number is not NaN when coerced to a number,\n * is an integer and that it falls within the legal range of port numbers.\n * @param {*} port\n * @param {string} [name='Port']\n * @param {boolean} [allowZero=true]\n * @returns {number}\n */\nfunction validatePort(port, name = 'Port', allowZero = true) {\n  if (\n    (typeof port !== 'number' && typeof port !== 'string') ||\n    (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||\n    +port !== +port >>> 0 ||\n    port > 0xffff ||\n    (port === 0 && !allowZero)\n  ) {\n    throw new ERR_SOCKET_BAD_PORT(name, port, allowZero)\n  }\n  return port | 0\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\n\n/** @type {validateAbortSignal} */\nconst validateAbortSignal = hideStackFrames((signal, name) => {\n  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)\n  }\n})\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validateFunction} */\nconst validateFunction = hideStackFrames((value, name) => {\n  if (typeof value !== 'function') throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)\n})\n\n/**\n * @callback validatePlainFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validatePlainFunction} */\nconst validatePlainFunction = hideStackFrames((value, name) => {\n  if (typeof value !== 'function' || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)\n})\n\n/**\n * @callback validateUndefined\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is undefined}\n */\n\n/** @type {validateUndefined} */\nconst validateUndefined = hideStackFrames((value, name) => {\n  if (value !== undefined) throw new ERR_INVALID_ARG_TYPE(name, 'undefined', value)\n})\n\n/**\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} union\n */\nfunction validateUnion(value, name, union) {\n  if (!ArrayPrototypeIncludes(union, value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, '|')}')`, value)\n  }\n}\n\n/*\n  The rules for the Link header field are described here:\n  https://www.rfc-editor.org/rfc/rfc8288.html#section-3\n\n  This regex validates any string surrounded by angle brackets\n  (not necessarily a valid URI reference) followed by zero or more\n  link-params separated by semicolons.\n*/\nconst linkValueRegExp = /^(?:<[^>]*>)(?:\\s*;\\s*[^;\"\\s]+(?:=(\")?[^;\"\\s]*\\1)?)*$/\n\n/**\n * @param {any} value\n * @param {string} name\n */\nfunction validateLinkHeaderFormat(value, name) {\n  if (typeof value === 'undefined' || !RegExpPrototypeExec(linkValueRegExp, value)) {\n    throw new ERR_INVALID_ARG_VALUE(\n      name,\n      value,\n      'must be an array or string of format \"</styles.css>; rel=preload; as=style\"'\n    )\n  }\n}\n\n/**\n * @param {any} hints\n * @return {string}\n */\nfunction validateLinkHeaderValue(hints) {\n  if (typeof hints === 'string') {\n    validateLinkHeaderFormat(hints, 'hints')\n    return hints\n  } else if (ArrayIsArray(hints)) {\n    const hintsLength = hints.length\n    let result = ''\n    if (hintsLength === 0) {\n      return result\n    }\n    for (let i = 0; i < hintsLength; i++) {\n      const link = hints[i]\n      validateLinkHeaderFormat(link, 'hints')\n      result += link\n      if (i !== hintsLength - 1) {\n        result += ', '\n      }\n    }\n    return result\n  }\n  throw new ERR_INVALID_ARG_VALUE(\n    'hints',\n    hints,\n    'must be an array or string of format \"</styles.css>; rel=preload; as=style\"'\n  )\n}\nmodule.exports = {\n  isInt32,\n  isUint32,\n  parseFileMode,\n  validateArray,\n  validateStringArray,\n  validateBooleanArray,\n  validateAbortSignalArray,\n  validateBoolean,\n  validateBuffer,\n  validateDictionary,\n  validateEncoding,\n  validateFunction,\n  validateInt32,\n  validateInteger,\n  validateNumber,\n  validateObject,\n  validateOneOf,\n  validatePlainFunction,\n  validatePort,\n  validateSignalName,\n  validateString,\n  validateUint32,\n  validateUndefined,\n  validateUnion,\n  validateAbortSignal,\n  validateLinkHeaderValue\n}\n","'use strict'\n\nconst { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require('../../ours/primordials')\n\n// We need to use SymbolFor to make these globally available\n// for interopt with readable-stream, i.e. readable-stream\n// and node core needs to be able to read/write private state\n// from each other for proper interoperability.\nconst kIsDestroyed = SymbolFor('nodejs.stream.destroyed')\nconst kIsErrored = SymbolFor('nodejs.stream.errored')\nconst kIsReadable = SymbolFor('nodejs.stream.readable')\nconst kIsWritable = SymbolFor('nodejs.stream.writable')\nconst kIsDisturbed = SymbolFor('nodejs.stream.disturbed')\nconst kIsClosedPromise = SymbolFor('nodejs.webstream.isClosedPromise')\nconst kControllerErrorFunction = SymbolFor('nodejs.webstream.controllerErrorFunction')\nfunction isReadableNodeStream(obj, strict = false) {\n  var _obj$_readableState\n  return !!(\n    (\n      obj &&\n      typeof obj.pipe === 'function' &&\n      typeof obj.on === 'function' &&\n      (!strict || (typeof obj.pause === 'function' && typeof obj.resume === 'function')) &&\n      (!obj._writableState ||\n        ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined\n          ? undefined\n          : _obj$_readableState.readable) !== false) &&\n      // Duplex\n      (!obj._writableState || obj._readableState)\n    ) // Writable has .pipe.\n  )\n}\n\nfunction isWritableNodeStream(obj) {\n  var _obj$_writableState\n  return !!(\n    (\n      obj &&\n      typeof obj.write === 'function' &&\n      typeof obj.on === 'function' &&\n      (!obj._readableState ||\n        ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined\n          ? undefined\n          : _obj$_writableState.writable) !== false)\n    ) // Duplex\n  )\n}\n\nfunction isDuplexNodeStream(obj) {\n  return !!(\n    obj &&\n    typeof obj.pipe === 'function' &&\n    obj._readableState &&\n    typeof obj.on === 'function' &&\n    typeof obj.write === 'function'\n  )\n}\nfunction isNodeStream(obj) {\n  return (\n    obj &&\n    (obj._readableState ||\n      obj._writableState ||\n      (typeof obj.write === 'function' && typeof obj.on === 'function') ||\n      (typeof obj.pipe === 'function' && typeof obj.on === 'function'))\n  )\n}\nfunction isReadableStream(obj) {\n  return !!(\n    obj &&\n    !isNodeStream(obj) &&\n    typeof obj.pipeThrough === 'function' &&\n    typeof obj.getReader === 'function' &&\n    typeof obj.cancel === 'function'\n  )\n}\nfunction isWritableStream(obj) {\n  return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === 'function' && typeof obj.abort === 'function')\n}\nfunction isTransformStream(obj) {\n  return !!(obj && !isNodeStream(obj) && typeof obj.readable === 'object' && typeof obj.writable === 'object')\n}\nfunction isWebStream(obj) {\n  return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj)\n}\nfunction isIterable(obj, isAsync) {\n  if (obj == null) return false\n  if (isAsync === true) return typeof obj[SymbolAsyncIterator] === 'function'\n  if (isAsync === false) return typeof obj[SymbolIterator] === 'function'\n  return typeof obj[SymbolAsyncIterator] === 'function' || typeof obj[SymbolIterator] === 'function'\n}\nfunction isDestroyed(stream) {\n  if (!isNodeStream(stream)) return null\n  const wState = stream._writableState\n  const rState = stream._readableState\n  const state = wState || rState\n  return !!(stream.destroyed || stream[kIsDestroyed] || (state !== null && state !== undefined && state.destroyed))\n}\n\n// Have been end():d.\nfunction isWritableEnded(stream) {\n  if (!isWritableNodeStream(stream)) return null\n  if (stream.writableEnded === true) return true\n  const wState = stream._writableState\n  if (wState !== null && wState !== undefined && wState.errored) return false\n  if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== 'boolean') return null\n  return wState.ended\n}\n\n// Have emitted 'finish'.\nfunction isWritableFinished(stream, strict) {\n  if (!isWritableNodeStream(stream)) return null\n  if (stream.writableFinished === true) return true\n  const wState = stream._writableState\n  if (wState !== null && wState !== undefined && wState.errored) return false\n  if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== 'boolean') return null\n  return !!(wState.finished || (strict === false && wState.ended === true && wState.length === 0))\n}\n\n// Have been push(null):d.\nfunction isReadableEnded(stream) {\n  if (!isReadableNodeStream(stream)) return null\n  if (stream.readableEnded === true) return true\n  const rState = stream._readableState\n  if (!rState || rState.errored) return false\n  if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== 'boolean') return null\n  return rState.ended\n}\n\n// Have emitted 'end'.\nfunction isReadableFinished(stream, strict) {\n  if (!isReadableNodeStream(stream)) return null\n  const rState = stream._readableState\n  if (rState !== null && rState !== undefined && rState.errored) return false\n  if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== 'boolean') return null\n  return !!(rState.endEmitted || (strict === false && rState.ended === true && rState.length === 0))\n}\nfunction isReadable(stream) {\n  if (stream && stream[kIsReadable] != null) return stream[kIsReadable]\n  if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== 'boolean') return null\n  if (isDestroyed(stream)) return false\n  return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream)\n}\nfunction isWritable(stream) {\n  if (stream && stream[kIsWritable] != null) return stream[kIsWritable]\n  if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== 'boolean') return null\n  if (isDestroyed(stream)) return false\n  return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream)\n}\nfunction isFinished(stream, opts) {\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (isDestroyed(stream)) {\n    return true\n  }\n  if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream)) {\n    return false\n  }\n  if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream)) {\n    return false\n  }\n  return true\n}\nfunction isWritableErrored(stream) {\n  var _stream$_writableStat, _stream$_writableStat2\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (stream.writableErrored) {\n    return stream.writableErrored\n  }\n  return (_stream$_writableStat =\n    (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined\n      ? undefined\n      : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined\n    ? _stream$_writableStat\n    : null\n}\nfunction isReadableErrored(stream) {\n  var _stream$_readableStat, _stream$_readableStat2\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (stream.readableErrored) {\n    return stream.readableErrored\n  }\n  return (_stream$_readableStat =\n    (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined\n      ? undefined\n      : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined\n    ? _stream$_readableStat\n    : null\n}\nfunction isClosed(stream) {\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (typeof stream.closed === 'boolean') {\n    return stream.closed\n  }\n  const wState = stream._writableState\n  const rState = stream._readableState\n  if (\n    typeof (wState === null || wState === undefined ? undefined : wState.closed) === 'boolean' ||\n    typeof (rState === null || rState === undefined ? undefined : rState.closed) === 'boolean'\n  ) {\n    return (\n      (wState === null || wState === undefined ? undefined : wState.closed) ||\n      (rState === null || rState === undefined ? undefined : rState.closed)\n    )\n  }\n  if (typeof stream._closed === 'boolean' && isOutgoingMessage(stream)) {\n    return stream._closed\n  }\n  return null\n}\nfunction isOutgoingMessage(stream) {\n  return (\n    typeof stream._closed === 'boolean' &&\n    typeof stream._defaultKeepAlive === 'boolean' &&\n    typeof stream._removedConnection === 'boolean' &&\n    typeof stream._removedContLen === 'boolean'\n  )\n}\nfunction isServerResponse(stream) {\n  return typeof stream._sent100 === 'boolean' && isOutgoingMessage(stream)\n}\nfunction isServerRequest(stream) {\n  var _stream$req\n  return (\n    typeof stream._consuming === 'boolean' &&\n    typeof stream._dumped === 'boolean' &&\n    ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) ===\n      undefined\n  )\n}\nfunction willEmitClose(stream) {\n  if (!isNodeStream(stream)) return null\n  const wState = stream._writableState\n  const rState = stream._readableState\n  const state = wState || rState\n  return (\n    (!state && isServerResponse(stream)) || !!(state && state.autoDestroy && state.emitClose && state.closed === false)\n  )\n}\nfunction isDisturbed(stream) {\n  var _stream$kIsDisturbed\n  return !!(\n    stream &&\n    ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined\n      ? _stream$kIsDisturbed\n      : stream.readableDidRead || stream.readableAborted)\n  )\n}\nfunction isErrored(stream) {\n  var _ref,\n    _ref2,\n    _ref3,\n    _ref4,\n    _ref5,\n    _stream$kIsErrored,\n    _stream$_readableStat3,\n    _stream$_writableStat3,\n    _stream$_readableStat4,\n    _stream$_writableStat4\n  return !!(\n    stream &&\n    ((_ref =\n      (_ref2 =\n        (_ref3 =\n          (_ref4 =\n            (_ref5 =\n              (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== undefined\n                ? _stream$kIsErrored\n                : stream.readableErrored) !== null && _ref5 !== undefined\n              ? _ref5\n              : stream.writableErrored) !== null && _ref4 !== undefined\n            ? _ref4\n            : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined\n            ? undefined\n            : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined\n          ? _ref3\n          : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined\n          ? undefined\n          : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined\n        ? _ref2\n        : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined\n        ? undefined\n        : _stream$_readableStat4.errored) !== null && _ref !== undefined\n      ? _ref\n      : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined\n      ? undefined\n      : _stream$_writableStat4.errored)\n  )\n}\nmodule.exports = {\n  isDestroyed,\n  kIsDestroyed,\n  isDisturbed,\n  kIsDisturbed,\n  isErrored,\n  kIsErrored,\n  isReadable,\n  kIsReadable,\n  kIsClosedPromise,\n  kControllerErrorFunction,\n  kIsWritable,\n  isClosed,\n  isDuplexNodeStream,\n  isFinished,\n  isIterable,\n  isReadableNodeStream,\n  isReadableStream,\n  isReadableEnded,\n  isReadableFinished,\n  isReadableErrored,\n  isNodeStream,\n  isWebStream,\n  isWritable,\n  isWritableNodeStream,\n  isWritableStream,\n  isWritableEnded,\n  isWritableFinished,\n  isWritableErrored,\n  isServerRequest,\n  isServerResponse,\n  willEmitClose,\n  isTransformStream\n}\n","/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n;('use strict')\nconst { AbortError, codes } = require('../../ours/errors')\nconst { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes\nconst { kEmptyObject, once } = require('../../ours/util')\nconst { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require('../validators')\nconst { Promise, PromisePrototypeThen, SymbolDispose } = require('../../ours/primordials')\nconst {\n  isClosed,\n  isReadable,\n  isReadableNodeStream,\n  isReadableStream,\n  isReadableFinished,\n  isReadableErrored,\n  isWritable,\n  isWritableNodeStream,\n  isWritableStream,\n  isWritableFinished,\n  isWritableErrored,\n  isNodeStream,\n  willEmitClose: _willEmitClose,\n  kIsClosedPromise\n} = require('./utils')\nlet addAbortListener\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function'\n}\nconst nop = () => {}\nfunction eos(stream, options, callback) {\n  var _options$readable, _options$writable\n  if (arguments.length === 2) {\n    callback = options\n    options = kEmptyObject\n  } else if (options == null) {\n    options = kEmptyObject\n  } else {\n    validateObject(options, 'options')\n  }\n  validateFunction(callback, 'callback')\n  validateAbortSignal(options.signal, 'options.signal')\n  callback = once(callback)\n  if (isReadableStream(stream) || isWritableStream(stream)) {\n    return eosWeb(stream, options, callback)\n  }\n  if (!isNodeStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)\n  }\n  const readable =\n    (_options$readable = options.readable) !== null && _options$readable !== undefined\n      ? _options$readable\n      : isReadableNodeStream(stream)\n  const writable =\n    (_options$writable = options.writable) !== null && _options$writable !== undefined\n      ? _options$writable\n      : isWritableNodeStream(stream)\n  const wState = stream._writableState\n  const rState = stream._readableState\n  const onlegacyfinish = () => {\n    if (!stream.writable) {\n      onfinish()\n    }\n  }\n\n  // TODO (ronag): Improve soft detection to include core modules and\n  // common ecosystem modules that do properly emit 'close' but fail\n  // this generic check.\n  let willEmitClose =\n    _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable\n  let writableFinished = isWritableFinished(stream, false)\n  const onfinish = () => {\n    writableFinished = true\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false\n    }\n    if (willEmitClose && (!stream.readable || readable)) {\n      return\n    }\n    if (!readable || readableFinished) {\n      callback.call(stream)\n    }\n  }\n  let readableFinished = isReadableFinished(stream, false)\n  const onend = () => {\n    readableFinished = true\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false\n    }\n    if (willEmitClose && (!stream.writable || writable)) {\n      return\n    }\n    if (!writable || writableFinished) {\n      callback.call(stream)\n    }\n  }\n  const onerror = (err) => {\n    callback.call(stream, err)\n  }\n  let closed = isClosed(stream)\n  const onclose = () => {\n    closed = true\n    const errored = isWritableErrored(stream) || isReadableErrored(stream)\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored)\n    }\n    if (readable && !readableFinished && isReadableNodeStream(stream, true)) {\n      if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())\n    }\n    if (writable && !writableFinished) {\n      if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())\n    }\n    callback.call(stream)\n  }\n  const onclosed = () => {\n    closed = true\n    const errored = isWritableErrored(stream) || isReadableErrored(stream)\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored)\n    }\n    callback.call(stream)\n  }\n  const onrequest = () => {\n    stream.req.on('finish', onfinish)\n  }\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish)\n    if (!willEmitClose) {\n      stream.on('abort', onclose)\n    }\n    if (stream.req) {\n      onrequest()\n    } else {\n      stream.on('request', onrequest)\n    }\n  } else if (writable && !wState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish)\n    stream.on('close', onlegacyfinish)\n  }\n\n  // Not all streams will emit 'close' after 'aborted'.\n  if (!willEmitClose && typeof stream.aborted === 'boolean') {\n    stream.on('aborted', onclose)\n  }\n  stream.on('end', onend)\n  stream.on('finish', onfinish)\n  if (options.error !== false) {\n    stream.on('error', onerror)\n  }\n  stream.on('close', onclose)\n  if (closed) {\n    process.nextTick(onclose)\n  } else if (\n    (wState !== null && wState !== undefined && wState.errorEmitted) ||\n    (rState !== null && rState !== undefined && rState.errorEmitted)\n  ) {\n    if (!willEmitClose) {\n      process.nextTick(onclosed)\n    }\n  } else if (\n    !readable &&\n    (!willEmitClose || isReadable(stream)) &&\n    (writableFinished || isWritable(stream) === false)\n  ) {\n    process.nextTick(onclosed)\n  } else if (\n    !writable &&\n    (!willEmitClose || isWritable(stream)) &&\n    (readableFinished || isReadable(stream) === false)\n  ) {\n    process.nextTick(onclosed)\n  } else if (rState && stream.req && stream.aborted) {\n    process.nextTick(onclosed)\n  }\n  const cleanup = () => {\n    callback = nop\n    stream.removeListener('aborted', onclose)\n    stream.removeListener('complete', onfinish)\n    stream.removeListener('abort', onclose)\n    stream.removeListener('request', onrequest)\n    if (stream.req) stream.req.removeListener('finish', onfinish)\n    stream.removeListener('end', onlegacyfinish)\n    stream.removeListener('close', onlegacyfinish)\n    stream.removeListener('finish', onfinish)\n    stream.removeListener('end', onend)\n    stream.removeListener('error', onerror)\n    stream.removeListener('close', onclose)\n  }\n  if (options.signal && !closed) {\n    const abort = () => {\n      // Keep it because cleanup removes it.\n      const endCallback = callback\n      cleanup()\n      endCallback.call(\n        stream,\n        new AbortError(undefined, {\n          cause: options.signal.reason\n        })\n      )\n    }\n    if (options.signal.aborted) {\n      process.nextTick(abort)\n    } else {\n      addAbortListener = addAbortListener || require('../../ours/util').addAbortListener\n      const disposable = addAbortListener(options.signal, abort)\n      const originalCallback = callback\n      callback = once((...args) => {\n        disposable[SymbolDispose]()\n        originalCallback.apply(stream, args)\n      })\n    }\n  }\n  return cleanup\n}\nfunction eosWeb(stream, options, callback) {\n  let isAborted = false\n  let abort = nop\n  if (options.signal) {\n    abort = () => {\n      isAborted = true\n      callback.call(\n        stream,\n        new AbortError(undefined, {\n          cause: options.signal.reason\n        })\n      )\n    }\n    if (options.signal.aborted) {\n      process.nextTick(abort)\n    } else {\n      addAbortListener = addAbortListener || require('../../ours/util').addAbortListener\n      const disposable = addAbortListener(options.signal, abort)\n      const originalCallback = callback\n      callback = once((...args) => {\n        disposable[SymbolDispose]()\n        originalCallback.apply(stream, args)\n      })\n    }\n  }\n  const resolverFn = (...args) => {\n    if (!isAborted) {\n      process.nextTick(() => callback.apply(stream, args))\n    }\n  }\n  PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn)\n  return nop\n}\nfunction finished(stream, opts) {\n  var _opts\n  let autoCleanup = false\n  if (opts === null) {\n    opts = kEmptyObject\n  }\n  if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {\n    validateBoolean(opts.cleanup, 'cleanup')\n    autoCleanup = opts.cleanup\n  }\n  return new Promise((resolve, reject) => {\n    const cleanup = eos(stream, opts, (err) => {\n      if (autoCleanup) {\n        cleanup()\n      }\n      if (err) {\n        reject(err)\n      } else {\n        resolve()\n      }\n    })\n  })\n}\nmodule.exports = eos\nmodule.exports.finished = finished\n","'use strict'\n\n/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n\nconst {\n  aggregateTwoErrors,\n  codes: { ERR_MULTIPLE_CALLBACK },\n  AbortError\n} = require('../../ours/errors')\nconst { Symbol } = require('../../ours/primordials')\nconst { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require('./utils')\nconst kDestroy = Symbol('kDestroy')\nconst kConstruct = Symbol('kConstruct')\nfunction checkError(err, w, r) {\n  if (err) {\n    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err\n    }\n    if (r && !r.errored) {\n      r.errored = err\n    }\n  }\n}\n\n// Backwards compat. cb() is undocumented and unused in core but\n// unfortunately might be used by modules.\nfunction destroy(err, cb) {\n  const r = this._readableState\n  const w = this._writableState\n  // With duplex streams we use the writable side for state.\n  const s = w || r\n  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {\n    if (typeof cb === 'function') {\n      cb()\n    }\n    return this\n  }\n\n  // We set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n  checkError(err, w, r)\n  if (w) {\n    w.destroyed = true\n  }\n  if (r) {\n    r.destroyed = true\n  }\n\n  // If still constructing then defer calling _destroy.\n  if (!s.constructed) {\n    this.once(kDestroy, function (er) {\n      _destroy(this, aggregateTwoErrors(er, err), cb)\n    })\n  } else {\n    _destroy(this, err, cb)\n  }\n  return this\n}\nfunction _destroy(self, err, cb) {\n  let called = false\n  function onDestroy(err) {\n    if (called) {\n      return\n    }\n    called = true\n    const r = self._readableState\n    const w = self._writableState\n    checkError(err, w, r)\n    if (w) {\n      w.closed = true\n    }\n    if (r) {\n      r.closed = true\n    }\n    if (typeof cb === 'function') {\n      cb(err)\n    }\n    if (err) {\n      process.nextTick(emitErrorCloseNT, self, err)\n    } else {\n      process.nextTick(emitCloseNT, self)\n    }\n  }\n  try {\n    self._destroy(err || null, onDestroy)\n  } catch (err) {\n    onDestroy(err)\n  }\n}\nfunction emitErrorCloseNT(self, err) {\n  emitErrorNT(self, err)\n  emitCloseNT(self)\n}\nfunction emitCloseNT(self) {\n  const r = self._readableState\n  const w = self._writableState\n  if (w) {\n    w.closeEmitted = true\n  }\n  if (r) {\n    r.closeEmitted = true\n  }\n  if ((w !== null && w !== undefined && w.emitClose) || (r !== null && r !== undefined && r.emitClose)) {\n    self.emit('close')\n  }\n}\nfunction emitErrorNT(self, err) {\n  const r = self._readableState\n  const w = self._writableState\n  if ((w !== null && w !== undefined && w.errorEmitted) || (r !== null && r !== undefined && r.errorEmitted)) {\n    return\n  }\n  if (w) {\n    w.errorEmitted = true\n  }\n  if (r) {\n    r.errorEmitted = true\n  }\n  self.emit('error', err)\n}\nfunction undestroy() {\n  const r = this._readableState\n  const w = this._writableState\n  if (r) {\n    r.constructed = true\n    r.closed = false\n    r.closeEmitted = false\n    r.destroyed = false\n    r.errored = null\n    r.errorEmitted = false\n    r.reading = false\n    r.ended = r.readable === false\n    r.endEmitted = r.readable === false\n  }\n  if (w) {\n    w.constructed = true\n    w.destroyed = false\n    w.closed = false\n    w.closeEmitted = false\n    w.errored = null\n    w.errorEmitted = false\n    w.finalCalled = false\n    w.prefinished = false\n    w.ended = w.writable === false\n    w.ending = w.writable === false\n    w.finished = w.writable === false\n  }\n}\nfunction errorOrDestroy(stream, err, sync) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  const r = stream._readableState\n  const w = stream._writableState\n  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {\n    return this\n  }\n  if ((r !== null && r !== undefined && r.autoDestroy) || (w !== null && w !== undefined && w.autoDestroy))\n    stream.destroy(err)\n  else if (err) {\n    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err\n    }\n    if (r && !r.errored) {\n      r.errored = err\n    }\n    if (sync) {\n      process.nextTick(emitErrorNT, stream, err)\n    } else {\n      emitErrorNT(stream, err)\n    }\n  }\n}\nfunction construct(stream, cb) {\n  if (typeof stream._construct !== 'function') {\n    return\n  }\n  const r = stream._readableState\n  const w = stream._writableState\n  if (r) {\n    r.constructed = false\n  }\n  if (w) {\n    w.constructed = false\n  }\n  stream.once(kConstruct, cb)\n  if (stream.listenerCount(kConstruct) > 1) {\n    // Duplex\n    return\n  }\n  process.nextTick(constructNT, stream)\n}\nfunction constructNT(stream) {\n  let called = false\n  function onConstruct(err) {\n    if (called) {\n      errorOrDestroy(stream, err !== null && err !== undefined ? err : new ERR_MULTIPLE_CALLBACK())\n      return\n    }\n    called = true\n    const r = stream._readableState\n    const w = stream._writableState\n    const s = w || r\n    if (r) {\n      r.constructed = true\n    }\n    if (w) {\n      w.constructed = true\n    }\n    if (s.destroyed) {\n      stream.emit(kDestroy, err)\n    } else if (err) {\n      errorOrDestroy(stream, err, true)\n    } else {\n      process.nextTick(emitConstructNT, stream)\n    }\n  }\n  try {\n    stream._construct((err) => {\n      process.nextTick(onConstruct, err)\n    })\n  } catch (err) {\n    process.nextTick(onConstruct, err)\n  }\n}\nfunction emitConstructNT(stream) {\n  stream.emit(kConstruct)\n}\nfunction isRequest(stream) {\n  return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === 'function'\n}\nfunction emitCloseLegacy(stream) {\n  stream.emit('close')\n}\nfunction emitErrorCloseLegacy(stream, err) {\n  stream.emit('error', err)\n  process.nextTick(emitCloseLegacy, stream)\n}\n\n// Normalize destroy for legacy.\nfunction destroyer(stream, err) {\n  if (!stream || isDestroyed(stream)) {\n    return\n  }\n  if (!err && !isFinished(stream)) {\n    err = new AbortError()\n  }\n\n  // TODO: Remove isRequest branches.\n  if (isServerRequest(stream)) {\n    stream.socket = null\n    stream.destroy(err)\n  } else if (isRequest(stream)) {\n    stream.abort()\n  } else if (isRequest(stream.req)) {\n    stream.req.abort()\n  } else if (typeof stream.destroy === 'function') {\n    stream.destroy(err)\n  } else if (typeof stream.close === 'function') {\n    // TODO: Don't lose err?\n    stream.close()\n  } else if (err) {\n    process.nextTick(emitErrorCloseLegacy, stream, err)\n  } else {\n    process.nextTick(emitCloseLegacy, stream)\n  }\n  if (!stream.destroyed) {\n    stream[kIsDestroyed] = true\n  }\n}\nmodule.exports = {\n  construct,\n  destroyer,\n  destroy,\n  undestroy,\n  errorOrDestroy\n}\n","'use strict'\n\nconst { ArrayIsArray, ObjectSetPrototypeOf } = require('../../ours/primordials')\nconst { EventEmitter: EE } = require('events')\nfunction Stream(opts) {\n  EE.call(this, opts)\n}\nObjectSetPrototypeOf(Stream.prototype, EE.prototype)\nObjectSetPrototypeOf(Stream, EE)\nStream.prototype.pipe = function (dest, options) {\n  const source = this\n  function ondata(chunk) {\n    if (dest.writable && dest.write(chunk) === false && source.pause) {\n      source.pause()\n    }\n  }\n  source.on('data', ondata)\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume()\n    }\n  }\n  dest.on('drain', ondrain)\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend)\n    source.on('close', onclose)\n  }\n  let didOnEnd = false\n  function onend() {\n    if (didOnEnd) return\n    didOnEnd = true\n    dest.end()\n  }\n  function onclose() {\n    if (didOnEnd) return\n    didOnEnd = true\n    if (typeof dest.destroy === 'function') dest.destroy()\n  }\n\n  // Don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup()\n    if (EE.listenerCount(this, 'error') === 0) {\n      this.emit('error', er)\n    }\n  }\n  prependListener(source, 'error', onerror)\n  prependListener(dest, 'error', onerror)\n\n  // Remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata)\n    dest.removeListener('drain', ondrain)\n    source.removeListener('end', onend)\n    source.removeListener('close', onclose)\n    source.removeListener('error', onerror)\n    dest.removeListener('error', onerror)\n    source.removeListener('end', cleanup)\n    source.removeListener('close', cleanup)\n    dest.removeListener('close', cleanup)\n  }\n  source.on('end', cleanup)\n  source.on('close', cleanup)\n  dest.on('close', cleanup)\n  dest.emit('pipe', source)\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest\n}\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn)\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn)\n  else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn)\n  else emitter._events[event] = [fn, emitter._events[event]]\n}\nmodule.exports = {\n  Stream,\n  prependListener\n}\n","'use strict'\n\nconst { SymbolDispose } = require('../../ours/primordials')\nconst { AbortError, codes } = require('../../ours/errors')\nconst { isNodeStream, isWebStream, kControllerErrorFunction } = require('./utils')\nconst eos = require('./end-of-stream')\nconst { ERR_INVALID_ARG_TYPE } = codes\nlet addAbortListener\n\n// This method is inlined here for readable-stream\n// It also does not allow for signal to not exist on the stream\n// https://github.com/nodejs/node/pull/36061#discussion_r533718029\nconst validateAbortSignal = (signal, name) => {\n  if (typeof signal !== 'object' || !('aborted' in signal)) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)\n  }\n}\nmodule.exports.addAbortSignal = function addAbortSignal(signal, stream) {\n  validateAbortSignal(signal, 'signal')\n  if (!isNodeStream(stream) && !isWebStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)\n  }\n  return module.exports.addAbortSignalNoValidate(signal, stream)\n}\nmodule.exports.addAbortSignalNoValidate = function (signal, stream) {\n  if (typeof signal !== 'object' || !('aborted' in signal)) {\n    return stream\n  }\n  const onAbort = isNodeStream(stream)\n    ? () => {\n        stream.destroy(\n          new AbortError(undefined, {\n            cause: signal.reason\n          })\n        )\n      }\n    : () => {\n        stream[kControllerErrorFunction](\n          new AbortError(undefined, {\n            cause: signal.reason\n          })\n        )\n      }\n  if (signal.aborted) {\n    onAbort()\n  } else {\n    addAbortListener = addAbortListener || require('../../ours/util').addAbortListener\n    const disposable = addAbortListener(signal, onAbort)\n    eos(stream, disposable[SymbolDispose])\n  }\n  return stream\n}\n","'use strict'\n\nconst { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array } = require('../../ours/primordials')\nconst { Buffer } = require('buffer')\nconst { inspect } = require('../../ours/util')\nmodule.exports = class BufferList {\n  constructor() {\n    this.head = null\n    this.tail = null\n    this.length = 0\n  }\n  push(v) {\n    const entry = {\n      data: v,\n      next: null\n    }\n    if (this.length > 0) this.tail.next = entry\n    else this.head = entry\n    this.tail = entry\n    ++this.length\n  }\n  unshift(v) {\n    const entry = {\n      data: v,\n      next: this.head\n    }\n    if (this.length === 0) this.tail = entry\n    this.head = entry\n    ++this.length\n  }\n  shift() {\n    if (this.length === 0) return\n    const ret = this.head.data\n    if (this.length === 1) this.head = this.tail = null\n    else this.head = this.head.next\n    --this.length\n    return ret\n  }\n  clear() {\n    this.head = this.tail = null\n    this.length = 0\n  }\n  join(s) {\n    if (this.length === 0) return ''\n    let p = this.head\n    let ret = '' + p.data\n    while ((p = p.next) !== null) ret += s + p.data\n    return ret\n  }\n  concat(n) {\n    if (this.length === 0) return Buffer.alloc(0)\n    const ret = Buffer.allocUnsafe(n >>> 0)\n    let p = this.head\n    let i = 0\n    while (p) {\n      TypedArrayPrototypeSet(ret, p.data, i)\n      i += p.data.length\n      p = p.next\n    }\n    return ret\n  }\n\n  // Consumes a specified amount of bytes or characters from the buffered data.\n  consume(n, hasStrings) {\n    const data = this.head.data\n    if (n < data.length) {\n      // `slice` is the same for buffers and strings.\n      const slice = data.slice(0, n)\n      this.head.data = data.slice(n)\n      return slice\n    }\n    if (n === data.length) {\n      // First chunk is a perfect match.\n      return this.shift()\n    }\n    // Result spans more than one buffer.\n    return hasStrings ? this._getString(n) : this._getBuffer(n)\n  }\n  first() {\n    return this.head.data\n  }\n  *[SymbolIterator]() {\n    for (let p = this.head; p; p = p.next) {\n      yield p.data\n    }\n  }\n\n  // Consumes a specified amount of characters from the buffered data.\n  _getString(n) {\n    let ret = ''\n    let p = this.head\n    let c = 0\n    do {\n      const str = p.data\n      if (n > str.length) {\n        ret += str\n        n -= str.length\n      } else {\n        if (n === str.length) {\n          ret += str\n          ++c\n          if (p.next) this.head = p.next\n          else this.head = this.tail = null\n        } else {\n          ret += StringPrototypeSlice(str, 0, n)\n          this.head = p\n          p.data = StringPrototypeSlice(str, n)\n        }\n        break\n      }\n      ++c\n    } while ((p = p.next) !== null)\n    this.length -= c\n    return ret\n  }\n\n  // Consumes a specified amount of bytes from the buffered data.\n  _getBuffer(n) {\n    const ret = Buffer.allocUnsafe(n)\n    const retLen = n\n    let p = this.head\n    let c = 0\n    do {\n      const buf = p.data\n      if (n > buf.length) {\n        TypedArrayPrototypeSet(ret, buf, retLen - n)\n        n -= buf.length\n      } else {\n        if (n === buf.length) {\n          TypedArrayPrototypeSet(ret, buf, retLen - n)\n          ++c\n          if (p.next) this.head = p.next\n          else this.head = this.tail = null\n        } else {\n          TypedArrayPrototypeSet(ret, new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n)\n          this.head = p\n          p.data = buf.slice(n)\n        }\n        break\n      }\n      ++c\n    } while ((p = p.next) !== null)\n    this.length -= c\n    return ret\n  }\n\n  // Make sure the linked list only shows the minimal necessary information.\n  [Symbol.for('nodejs.util.inspect.custom')](_, options) {\n    return inspect(this, {\n      ...options,\n      // Only inspect one level.\n      depth: 0,\n      // It should not recurse.\n      customInspect: false\n    })\n  }\n}\n","'use strict'\n\nconst { MathFloor, NumberIsInteger } = require('../../ours/primordials')\nconst { validateInteger } = require('../validators')\nconst { ERR_INVALID_ARG_VALUE } = require('../../ours/errors').codes\nlet defaultHighWaterMarkBytes = 16 * 1024\nlet defaultHighWaterMarkObjectMode = 16\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null\n}\nfunction getDefaultHighWaterMark(objectMode) {\n  return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes\n}\nfunction setDefaultHighWaterMark(objectMode, value) {\n  validateInteger(value, 'value', 0)\n  if (objectMode) {\n    defaultHighWaterMarkObjectMode = value\n  } else {\n    defaultHighWaterMarkBytes = value\n  }\n}\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  const hwm = highWaterMarkFrom(options, isDuplex, duplexKey)\n  if (hwm != null) {\n    if (!NumberIsInteger(hwm) || hwm < 0) {\n      const name = isDuplex ? `options.${duplexKey}` : 'options.highWaterMark'\n      throw new ERR_INVALID_ARG_VALUE(name, hwm)\n    }\n    return MathFloor(hwm)\n  }\n\n  // Default value\n  return getDefaultHighWaterMark(state.objectMode)\n}\nmodule.exports = {\n  getHighWaterMark,\n  getDefaultHighWaterMark,\n  setDefaultHighWaterMark\n}\n","'use strict'\n\n/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n\nconst { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require('../../ours/primordials')\nconst { Buffer } = require('buffer')\nconst { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require('../../ours/errors').codes\nfunction from(Readable, iterable, opts) {\n  let iterator\n  if (typeof iterable === 'string' || iterable instanceof Buffer) {\n    return new Readable({\n      objectMode: true,\n      ...opts,\n      read() {\n        this.push(iterable)\n        this.push(null)\n      }\n    })\n  }\n  let isAsync\n  if (iterable && iterable[SymbolAsyncIterator]) {\n    isAsync = true\n    iterator = iterable[SymbolAsyncIterator]()\n  } else if (iterable && iterable[SymbolIterator]) {\n    isAsync = false\n    iterator = iterable[SymbolIterator]()\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable)\n  }\n  const readable = new Readable({\n    objectMode: true,\n    highWaterMark: 1,\n    // TODO(ronag): What options should be allowed?\n    ...opts\n  })\n\n  // Flag to protect against _read\n  // being called before last iteration completion.\n  let reading = false\n  readable._read = function () {\n    if (!reading) {\n      reading = true\n      next()\n    }\n  }\n  readable._destroy = function (error, cb) {\n    PromisePrototypeThen(\n      close(error),\n      () => process.nextTick(cb, error),\n      // nextTick is here in case cb throws\n      (e) => process.nextTick(cb, e || error)\n    )\n  }\n  async function close(error) {\n    const hadError = error !== undefined && error !== null\n    const hasThrow = typeof iterator.throw === 'function'\n    if (hadError && hasThrow) {\n      const { value, done } = await iterator.throw(error)\n      await value\n      if (done) {\n        return\n      }\n    }\n    if (typeof iterator.return === 'function') {\n      const { value } = await iterator.return()\n      await value\n    }\n  }\n  async function next() {\n    for (;;) {\n      try {\n        const { value, done } = isAsync ? await iterator.next() : iterator.next()\n        if (done) {\n          readable.push(null)\n        } else {\n          const res = value && typeof value.then === 'function' ? await value : value\n          if (res === null) {\n            reading = false\n            throw new ERR_STREAM_NULL_VALUES()\n          } else if (readable.push(res)) {\n            continue\n          } else {\n            reading = false\n          }\n        }\n      } catch (err) {\n        readable.destroy(err)\n      }\n      break\n    }\n  }\n  return readable\n}\nmodule.exports = from\n","/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n;('use strict')\nconst {\n  ArrayPrototypeIndexOf,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberParseInt,\n  ObjectDefineProperties,\n  ObjectKeys,\n  ObjectSetPrototypeOf,\n  Promise,\n  SafeSet,\n  SymbolAsyncDispose,\n  SymbolAsyncIterator,\n  Symbol\n} = require('../../ours/primordials')\nmodule.exports = Readable\nReadable.ReadableState = ReadableState\nconst { EventEmitter: EE } = require('events')\nconst { Stream, prependListener } = require('./legacy')\nconst { Buffer } = require('buffer')\nconst { addAbortSignal } = require('./add-abort-signal')\nconst eos = require('./end-of-stream')\nlet debug = require('../../ours/util').debuglog('stream', (fn) => {\n  debug = fn\n})\nconst BufferList = require('./buffer_list')\nconst destroyImpl = require('./destroy')\nconst { getHighWaterMark, getDefaultHighWaterMark } = require('./state')\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_OUT_OF_RANGE,\n    ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT\n  },\n  AbortError\n} = require('../../ours/errors')\nconst { validateObject } = require('../validators')\nconst kPaused = Symbol('kPaused')\nconst { StringDecoder } = require('string_decoder')\nconst from = require('./from')\nObjectSetPrototypeOf(Readable.prototype, Stream.prototype)\nObjectSetPrototypeOf(Readable, Stream)\nconst nop = () => {}\nconst { errorOrDestroy } = destroyImpl\nconst kObjectMode = 1 << 0\nconst kEnded = 1 << 1\nconst kEndEmitted = 1 << 2\nconst kReading = 1 << 3\nconst kConstructed = 1 << 4\nconst kSync = 1 << 5\nconst kNeedReadable = 1 << 6\nconst kEmittedReadable = 1 << 7\nconst kReadableListening = 1 << 8\nconst kResumeScheduled = 1 << 9\nconst kErrorEmitted = 1 << 10\nconst kEmitClose = 1 << 11\nconst kAutoDestroy = 1 << 12\nconst kDestroyed = 1 << 13\nconst kClosed = 1 << 14\nconst kCloseEmitted = 1 << 15\nconst kMultiAwaitDrain = 1 << 16\nconst kReadingMore = 1 << 17\nconst kDataEmitted = 1 << 18\n\n// TODO(benjamingr) it is likely slower to do it this way than with free functions\nfunction makeBitMapDescriptor(bit) {\n  return {\n    enumerable: false,\n    get() {\n      return (this.state & bit) !== 0\n    },\n    set(value) {\n      if (value) this.state |= bit\n      else this.state &= ~bit\n    }\n  }\n}\nObjectDefineProperties(ReadableState.prototype, {\n  objectMode: makeBitMapDescriptor(kObjectMode),\n  ended: makeBitMapDescriptor(kEnded),\n  endEmitted: makeBitMapDescriptor(kEndEmitted),\n  reading: makeBitMapDescriptor(kReading),\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in, therefore we start as\n  // constructed.\n  constructed: makeBitMapDescriptor(kConstructed),\n  // A flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  sync: makeBitMapDescriptor(kSync),\n  // Whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  needReadable: makeBitMapDescriptor(kNeedReadable),\n  emittedReadable: makeBitMapDescriptor(kEmittedReadable),\n  readableListening: makeBitMapDescriptor(kReadableListening),\n  resumeScheduled: makeBitMapDescriptor(kResumeScheduled),\n  // True if the error was already emitted and should not be thrown again.\n  errorEmitted: makeBitMapDescriptor(kErrorEmitted),\n  emitClose: makeBitMapDescriptor(kEmitClose),\n  autoDestroy: makeBitMapDescriptor(kAutoDestroy),\n  // Has it been destroyed.\n  destroyed: makeBitMapDescriptor(kDestroyed),\n  // Indicates whether the stream has finished destroying.\n  closed: makeBitMapDescriptor(kClosed),\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  closeEmitted: makeBitMapDescriptor(kCloseEmitted),\n  multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),\n  // If true, a maybeReadMore has been scheduled.\n  readingMore: makeBitMapDescriptor(kReadingMore),\n  dataEmitted: makeBitMapDescriptor(kDataEmitted)\n})\nfunction ReadableState(options, stream, isDuplex) {\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof require('./duplex')\n\n  // Bit map field to store ReadableState more effciently with 1 bit per field\n  // instead of a V8 slot per field.\n  this.state = kEmitClose | kAutoDestroy | kConstructed | kSync\n  // Object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away.\n  if (options && options.objectMode) this.state |= kObjectMode\n  if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode\n\n  // The point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = options\n    ? getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex)\n    : getDefaultHighWaterMark(false)\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift().\n  this.buffer = new BufferList()\n  this.length = 0\n  this.pipes = []\n  this.flowing = null\n  this[kPaused] = null\n\n  // Should close be emitted on destroy. Defaults to true.\n  if (options && options.emitClose === false) this.state &= ~kEmitClose\n\n  // Should .destroy() be called after 'end' (and potentially 'finish').\n  if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy\n\n  // Indicates whether the stream has errored. When true no further\n  // _read calls, 'data' or 'readable' events should occur. This is needed\n  // since when autoDestroy is disabled we need a way to tell whether the\n  // stream has failed.\n  this.errored = null\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8'\n\n  // Ref the piped dest which we need a drain event on it\n  // type: null | Writable | Set<Writable>.\n  this.awaitDrainWriters = null\n  this.decoder = null\n  this.encoding = null\n  if (options && options.encoding) {\n    this.decoder = new StringDecoder(options.encoding)\n    this.encoding = options.encoding\n  }\n}\nfunction Readable(options) {\n  if (!(this instanceof Readable)) return new Readable(options)\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5.\n  const isDuplex = this instanceof require('./duplex')\n  this._readableState = new ReadableState(options, this, isDuplex)\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read\n    if (typeof options.destroy === 'function') this._destroy = options.destroy\n    if (typeof options.construct === 'function') this._construct = options.construct\n    if (options.signal && !isDuplex) addAbortSignal(options.signal, this)\n  }\n  Stream.call(this, options)\n  destroyImpl.construct(this, () => {\n    if (this._readableState.needReadable) {\n      maybeReadMore(this, this._readableState)\n    }\n  })\n}\nReadable.prototype.destroy = destroyImpl.destroy\nReadable.prototype._undestroy = destroyImpl.undestroy\nReadable.prototype._destroy = function (err, cb) {\n  cb(err)\n}\nReadable.prototype[EE.captureRejectionSymbol] = function (err) {\n  this.destroy(err)\n}\nReadable.prototype[SymbolAsyncDispose] = function () {\n  let error\n  if (!this.destroyed) {\n    error = this.readableEnded ? null : new AbortError()\n    this.destroy(error)\n  }\n  return new Promise((resolve, reject) => eos(this, (err) => (err && err !== error ? reject(err) : resolve(null))))\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, false)\n}\n\n// Unshift should *always* be something directly out of read().\nReadable.prototype.unshift = function (chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, true)\n}\nfunction readableAddChunk(stream, chunk, encoding, addToFront) {\n  debug('readableAddChunk', chunk)\n  const state = stream._readableState\n  let err\n  if ((state.state & kObjectMode) === 0) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding\n      if (state.encoding !== encoding) {\n        if (addToFront && state.encoding) {\n          // When unshifting, if state.encoding is set, we have to save\n          // the string in the BufferList with the state encoding.\n          chunk = Buffer.from(chunk, encoding).toString(state.encoding)\n        } else {\n          chunk = Buffer.from(chunk, encoding)\n          encoding = ''\n        }\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = ''\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk)\n      encoding = ''\n    } else if (chunk != null) {\n      err = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)\n    }\n  }\n  if (err) {\n    errorOrDestroy(stream, err)\n  } else if (chunk === null) {\n    state.state &= ~kReading\n    onEofChunk(stream, state)\n  } else if ((state.state & kObjectMode) !== 0 || (chunk && chunk.length > 0)) {\n    if (addToFront) {\n      if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT())\n      else if (state.destroyed || state.errored) return false\n      else addChunk(stream, state, chunk, true)\n    } else if (state.ended) {\n      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF())\n    } else if (state.destroyed || state.errored) {\n      return false\n    } else {\n      state.state &= ~kReading\n      if (state.decoder && !encoding) {\n        chunk = state.decoder.write(chunk)\n        if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false)\n        else maybeReadMore(stream, state)\n      } else {\n        addChunk(stream, state, chunk, false)\n      }\n    }\n  } else if (!addToFront) {\n    state.state &= ~kReading\n    maybeReadMore(stream, state)\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0)\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount('data') > 0) {\n    // Use the guard to avoid creating `Set()` repeatedly\n    // when we have multiple pipes.\n    if ((state.state & kMultiAwaitDrain) !== 0) {\n      state.awaitDrainWriters.clear()\n    } else {\n      state.awaitDrainWriters = null\n    }\n    state.dataEmitted = true\n    stream.emit('data', chunk)\n  } else {\n    // Update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length\n    if (addToFront) state.buffer.unshift(chunk)\n    else state.buffer.push(chunk)\n    if ((state.state & kNeedReadable) !== 0) emitReadable(stream)\n  }\n  maybeReadMore(stream, state)\n}\nReadable.prototype.isPaused = function () {\n  const state = this._readableState\n  return state[kPaused] === true || state.flowing === false\n}\n\n// Backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  const decoder = new StringDecoder(enc)\n  this._readableState.decoder = decoder\n  // If setEncoding(null), decoder.encoding equals utf8.\n  this._readableState.encoding = this._readableState.decoder.encoding\n  const buffer = this._readableState.buffer\n  // Iterate over current buffer to convert already stored Buffers:\n  let content = ''\n  for (const data of buffer) {\n    content += decoder.write(data)\n  }\n  buffer.clear()\n  if (content !== '') buffer.push(content)\n  this._readableState.length = content.length\n  return this\n}\n\n// Don't raise the hwm > 1GB.\nconst MAX_HWM = 0x40000000\nfunction computeNewHighWaterMark(n) {\n  if (n > MAX_HWM) {\n    throw new ERR_OUT_OF_RANGE('size', '<= 1GiB', n)\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts.\n    n--\n    n |= n >>> 1\n    n |= n >>> 2\n    n |= n >>> 4\n    n |= n >>> 8\n    n |= n >>> 16\n    n++\n  }\n  return n\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || (state.length === 0 && state.ended)) return 0\n  if ((state.state & kObjectMode) !== 0) return 1\n  if (NumberIsNaN(n)) {\n    // Only flow one buffer at a time.\n    if (state.flowing && state.length) return state.buffer.first().length\n    return state.length\n  }\n  if (n <= state.length) return n\n  return state.ended ? state.length : 0\n}\n\n// You can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n)\n  // Same as parseInt(undefined, 10), however V8 7.3 performance regressed\n  // in this scenario, so we are doing it manually.\n  if (n === undefined) {\n    n = NaN\n  } else if (!NumberIsInteger(n)) {\n    n = NumberParseInt(n, 10)\n  }\n  const state = this._readableState\n  const nOrig = n\n\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n)\n  if (n !== 0) state.state &= ~kEmittedReadable\n\n  // If we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (\n    n === 0 &&\n    state.needReadable &&\n    ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)\n  ) {\n    debug('read: emitReadable', state.length, state.ended)\n    if (state.length === 0 && state.ended) endReadable(this)\n    else emitReadable(this)\n    return null\n  }\n  n = howMuchToRead(n, state)\n\n  // If we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this)\n    return null\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  let doRead = (state.state & kNeedReadable) !== 0\n  debug('need readable', doRead)\n\n  // If we currently have less than the highWaterMark, then also read some.\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true\n    debug('length less than watermark', doRead)\n  }\n\n  // However, if we've ended, then there's no point, if we're already\n  // reading, then it's unnecessary, if we're constructing we have to wait,\n  // and if we're destroyed or errored, then it's not allowed,\n  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {\n    doRead = false\n    debug('reading, ended or constructing', doRead)\n  } else if (doRead) {\n    debug('do read')\n    state.state |= kReading | kSync\n    // If the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.state |= kNeedReadable\n\n    // Call internal read method\n    try {\n      this._read(state.highWaterMark)\n    } catch (err) {\n      errorOrDestroy(this, err)\n    }\n    state.state &= ~kSync\n\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state)\n  }\n  let ret\n  if (n > 0) ret = fromList(n, state)\n  else ret = null\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark\n    n = 0\n  } else {\n    state.length -= n\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear()\n    } else {\n      state.awaitDrainWriters = null\n    }\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this)\n  }\n  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n    state.dataEmitted = true\n    this.emit('data', ret)\n  }\n  return ret\n}\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk')\n  if (state.ended) return\n  if (state.decoder) {\n    const chunk = state.decoder.end()\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk)\n      state.length += state.objectMode ? 1 : chunk.length\n    }\n  }\n  state.ended = true\n  if (state.sync) {\n    // If we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call.\n    emitReadable(stream)\n  } else {\n    // Emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false\n    state.emittedReadable = true\n    // We have to emit readable now that we are EOF. Modules\n    // in the ecosystem (e.g. dicer) rely on this event being sync.\n    emitReadable_(stream)\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  const state = stream._readableState\n  debug('emitReadable', state.needReadable, state.emittedReadable)\n  state.needReadable = false\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing)\n    state.emittedReadable = true\n    process.nextTick(emitReadable_, stream)\n  }\n}\nfunction emitReadable_(stream) {\n  const state = stream._readableState\n  debug('emitReadable_', state.destroyed, state.length, state.ended)\n  if (!state.destroyed && !state.errored && (state.length || state.ended)) {\n    stream.emit('readable')\n    state.emittedReadable = false\n  }\n\n  // The stream needs another readable event if:\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark\n  flow(stream)\n}\n\n// At this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore && state.constructed) {\n    state.readingMore = true\n    process.nextTick(maybeReadMore_, stream, state)\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (\n    !state.reading &&\n    !state.ended &&\n    (state.length < state.highWaterMark || (state.flowing && state.length === 0))\n  ) {\n    const len = state.length\n    debug('maybeReadMore read 0')\n    stream.read(0)\n    if (len === state.length)\n      // Didn't get any data, stop spinning.\n      break\n  }\n  state.readingMore = false\n}\n\n// Abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()')\n}\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  const src = this\n  const state = this._readableState\n  if (state.pipes.length === 1) {\n    if (!state.multiAwaitDrain) {\n      state.multiAwaitDrain = true\n      state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : [])\n    }\n  }\n  state.pipes.push(dest)\n  debug('pipe count=%d opts=%j', state.pipes.length, pipeOpts)\n  const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr\n  const endFn = doEnd ? onend : unpipe\n  if (state.endEmitted) process.nextTick(endFn)\n  else src.once('end', endFn)\n  dest.on('unpipe', onunpipe)\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe')\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true\n        cleanup()\n      }\n    }\n  }\n  function onend() {\n    debug('onend')\n    dest.end()\n  }\n  let ondrain\n  let cleanedUp = false\n  function cleanup() {\n    debug('cleanup')\n    // Cleanup event handlers once the pipe is broken.\n    dest.removeListener('close', onclose)\n    dest.removeListener('finish', onfinish)\n    if (ondrain) {\n      dest.removeListener('drain', ondrain)\n    }\n    dest.removeListener('error', onerror)\n    dest.removeListener('unpipe', onunpipe)\n    src.removeListener('end', onend)\n    src.removeListener('end', unpipe)\n    src.removeListener('data', ondata)\n    cleanedUp = true\n\n    // If the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain()\n  }\n  function pause() {\n    // If the user unpiped during `dest.write()`, it is possible\n    // to get stuck in a permanently paused state if that write\n    // also returned false.\n    // => Check whether `dest` is still a piping destination.\n    if (!cleanedUp) {\n      if (state.pipes.length === 1 && state.pipes[0] === dest) {\n        debug('false write response, pause', 0)\n        state.awaitDrainWriters = dest\n        state.multiAwaitDrain = false\n      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n        debug('false write response, pause', state.awaitDrainWriters.size)\n        state.awaitDrainWriters.add(dest)\n      }\n      src.pause()\n    }\n    if (!ondrain) {\n      // When the dest drains, it reduces the awaitDrain counter\n      // on the source.  This would be more elegant with a .once()\n      // handler in flow(), but adding and removing repeatedly is\n      // too slow.\n      ondrain = pipeOnDrain(src, dest)\n      dest.on('drain', ondrain)\n    }\n  }\n  src.on('data', ondata)\n  function ondata(chunk) {\n    debug('ondata')\n    const ret = dest.write(chunk)\n    debug('dest.write', ret)\n    if (ret === false) {\n      pause()\n    }\n  }\n\n  // If the dest has an error, then stop piping into it.\n  // However, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er)\n    unpipe()\n    dest.removeListener('error', onerror)\n    if (dest.listenerCount('error') === 0) {\n      const s = dest._writableState || dest._readableState\n      if (s && !s.errorEmitted) {\n        // User incorrectly emitted 'error' directly on the stream.\n        errorOrDestroy(dest, er)\n      } else {\n        dest.emit('error', er)\n      }\n    }\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror)\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish)\n    unpipe()\n  }\n  dest.once('close', onclose)\n  function onfinish() {\n    debug('onfinish')\n    dest.removeListener('close', onclose)\n    unpipe()\n  }\n  dest.once('finish', onfinish)\n  function unpipe() {\n    debug('unpipe')\n    src.unpipe(dest)\n  }\n\n  // Tell the dest that it's being piped to.\n  dest.emit('pipe', src)\n\n  // Start the flow if it hasn't been started already.\n\n  if (dest.writableNeedDrain === true) {\n    pause()\n  } else if (!state.flowing) {\n    debug('pipe resume')\n    src.resume()\n  }\n  return dest\n}\nfunction pipeOnDrain(src, dest) {\n  return function pipeOnDrainFunctionResult() {\n    const state = src._readableState\n\n    // `ondrain` will call directly,\n    // `this` maybe not a reference to dest,\n    // so we use the real dest here.\n    if (state.awaitDrainWriters === dest) {\n      debug('pipeOnDrain', 1)\n      state.awaitDrainWriters = null\n    } else if (state.multiAwaitDrain) {\n      debug('pipeOnDrain', state.awaitDrainWriters.size)\n      state.awaitDrainWriters.delete(dest)\n    }\n    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount('data')) {\n      src.resume()\n    }\n  }\n}\nReadable.prototype.unpipe = function (dest) {\n  const state = this._readableState\n  const unpipeInfo = {\n    hasUnpiped: false\n  }\n\n  // If we're not piping anywhere, then do nothing.\n  if (state.pipes.length === 0) return this\n  if (!dest) {\n    // remove all.\n    const dests = state.pipes\n    state.pipes = []\n    this.pause()\n    for (let i = 0; i < dests.length; i++)\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      })\n    return this\n  }\n\n  // Try to find the right one.\n  const index = ArrayPrototypeIndexOf(state.pipes, dest)\n  if (index === -1) return this\n  state.pipes.splice(index, 1)\n  if (state.pipes.length === 0) this.pause()\n  dest.emit('unpipe', this, unpipeInfo)\n  return this\n}\n\n// Set up data events if they are asked for\n// Ensure readable listeners eventually get something.\nReadable.prototype.on = function (ev, fn) {\n  const res = Stream.prototype.on.call(this, ev, fn)\n  const state = this._readableState\n  if (ev === 'data') {\n    // Update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0\n\n    // Try start flowing on next tick if stream isn't explicitly paused.\n    if (state.flowing !== false) this.resume()\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true\n      state.flowing = false\n      state.emittedReadable = false\n      debug('on readable', state.length, state.reading)\n      if (state.length) {\n        emitReadable(this)\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this)\n      }\n    }\n  }\n  return res\n}\nReadable.prototype.addListener = Readable.prototype.on\nReadable.prototype.removeListener = function (ev, fn) {\n  const res = Stream.prototype.removeListener.call(this, ev, fn)\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this)\n  }\n  return res\n}\nReadable.prototype.off = Readable.prototype.removeListener\nReadable.prototype.removeAllListeners = function (ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this, arguments)\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this)\n  }\n  return res\n}\nfunction updateReadableListening(self) {\n  const state = self._readableState\n  state.readableListening = self.listenerCount('readable') > 0\n  if (state.resumeScheduled && state[kPaused] === false) {\n    // Flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true\n\n    // Crude way to check if we should resume.\n  } else if (self.listenerCount('data') > 0) {\n    self.resume()\n  } else if (!state.readableListening) {\n    state.flowing = null\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0')\n  self.read(0)\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  const state = this._readableState\n  if (!state.flowing) {\n    debug('resume')\n    // We flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume().\n    state.flowing = !state.readableListening\n    resume(this, state)\n  }\n  state[kPaused] = false\n  return this\n}\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true\n    process.nextTick(resume_, stream, state)\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading)\n  if (!state.reading) {\n    stream.read(0)\n  }\n  state.resumeScheduled = false\n  stream.emit('resume')\n  flow(stream)\n  if (state.flowing && !state.reading) stream.read(0)\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing)\n  if (this._readableState.flowing !== false) {\n    debug('pause')\n    this._readableState.flowing = false\n    this.emit('pause')\n  }\n  this._readableState[kPaused] = true\n  return this\n}\nfunction flow(stream) {\n  const state = stream._readableState\n  debug('flow', state.flowing)\n  while (state.flowing && stream.read() !== null);\n}\n\n// Wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  let paused = false\n\n  // TODO (ronag): Should this.destroy(err) emit\n  // 'error' on the wrapped stream? Would require\n  // a static factory method, e.g. Readable.wrap(stream).\n\n  stream.on('data', (chunk) => {\n    if (!this.push(chunk) && stream.pause) {\n      paused = true\n      stream.pause()\n    }\n  })\n  stream.on('end', () => {\n    this.push(null)\n  })\n  stream.on('error', (err) => {\n    errorOrDestroy(this, err)\n  })\n  stream.on('close', () => {\n    this.destroy()\n  })\n  stream.on('destroy', () => {\n    this.destroy()\n  })\n  this._read = () => {\n    if (paused && stream.resume) {\n      paused = false\n      stream.resume()\n    }\n  }\n\n  // Proxy all the other methods. Important when wrapping filters and duplexes.\n  const streamKeys = ObjectKeys(stream)\n  for (let j = 1; j < streamKeys.length; j++) {\n    const i = streamKeys[j]\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = stream[i].bind(stream)\n    }\n  }\n  return this\n}\nReadable.prototype[SymbolAsyncIterator] = function () {\n  return streamToAsyncIterator(this)\n}\nReadable.prototype.iterator = function (options) {\n  if (options !== undefined) {\n    validateObject(options, 'options')\n  }\n  return streamToAsyncIterator(this, options)\n}\nfunction streamToAsyncIterator(stream, options) {\n  if (typeof stream.read !== 'function') {\n    stream = Readable.wrap(stream, {\n      objectMode: true\n    })\n  }\n  const iter = createAsyncIterator(stream, options)\n  iter.stream = stream\n  return iter\n}\nasync function* createAsyncIterator(stream, options) {\n  let callback = nop\n  function next(resolve) {\n    if (this === stream) {\n      callback()\n      callback = nop\n    } else {\n      callback = resolve\n    }\n  }\n  stream.on('readable', next)\n  let error\n  const cleanup = eos(\n    stream,\n    {\n      writable: false\n    },\n    (err) => {\n      error = err ? aggregateTwoErrors(error, err) : null\n      callback()\n      callback = nop\n    }\n  )\n  try {\n    while (true) {\n      const chunk = stream.destroyed ? null : stream.read()\n      if (chunk !== null) {\n        yield chunk\n      } else if (error) {\n        throw error\n      } else if (error === null) {\n        return\n      } else {\n        await new Promise(next)\n      }\n    }\n  } catch (err) {\n    error = aggregateTwoErrors(error, err)\n    throw error\n  } finally {\n    if (\n      (error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) &&\n      (error === undefined || stream._readableState.autoDestroy)\n    ) {\n      destroyImpl.destroyer(stream, null)\n    } else {\n      stream.off('readable', next)\n      cleanup()\n    }\n  }\n}\n\n// Making it explicit these properties are not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail.\nObjectDefineProperties(Readable.prototype, {\n  readable: {\n    __proto__: null,\n    get() {\n      const r = this._readableState\n      // r.readable === false means that this is part of a Duplex stream\n      // where the readable side was disabled upon construction.\n      // Compat. The user might manually disable readable side through\n      // deprecated setter.\n      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted\n    },\n    set(val) {\n      // Backwards compat.\n      if (this._readableState) {\n        this._readableState.readable = !!val\n      }\n    }\n  },\n  readableDidRead: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.dataEmitted\n    }\n  },\n  readableAborted: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return !!(\n        this._readableState.readable !== false &&\n        (this._readableState.destroyed || this._readableState.errored) &&\n        !this._readableState.endEmitted\n      )\n    }\n  },\n  readableHighWaterMark: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.highWaterMark\n    }\n  },\n  readableBuffer: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState && this._readableState.buffer\n    }\n  },\n  readableFlowing: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.flowing\n    },\n    set: function (state) {\n      if (this._readableState) {\n        this._readableState.flowing = state\n      }\n    }\n  },\n  readableLength: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState.length\n    }\n  },\n  readableObjectMode: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.objectMode : false\n    }\n  },\n  readableEncoding: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.encoding : null\n    }\n  },\n  errored: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.errored : null\n    }\n  },\n  closed: {\n    __proto__: null,\n    get() {\n      return this._readableState ? this._readableState.closed : false\n    }\n  },\n  destroyed: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.destroyed : false\n    },\n    set(value) {\n      // We ignore the value if the stream\n      // has not been initialized yet.\n      if (!this._readableState) {\n        return\n      }\n\n      // Backward compatibility, the user is explicitly\n      // managing destroyed.\n      this._readableState.destroyed = value\n    }\n  },\n  readableEnded: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.endEmitted : false\n    }\n  }\n})\nObjectDefineProperties(ReadableState.prototype, {\n  // Legacy getter for `pipesCount`.\n  pipesCount: {\n    __proto__: null,\n    get() {\n      return this.pipes.length\n    }\n  },\n  // Legacy property for `paused`.\n  paused: {\n    __proto__: null,\n    get() {\n      return this[kPaused] !== false\n    },\n    set(value) {\n      this[kPaused] = !!value\n    }\n  }\n})\n\n// Exposed for testing purposes only.\nReadable._fromList = fromList\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered.\n  if (state.length === 0) return null\n  let ret\n  if (state.objectMode) ret = state.buffer.shift()\n  else if (!n || n >= state.length) {\n    // Read it all, truncate the list.\n    if (state.decoder) ret = state.buffer.join('')\n    else if (state.buffer.length === 1) ret = state.buffer.first()\n    else ret = state.buffer.concat(state.length)\n    state.buffer.clear()\n  } else {\n    // read part of list.\n    ret = state.buffer.consume(n, state.decoder)\n  }\n  return ret\n}\nfunction endReadable(stream) {\n  const state = stream._readableState\n  debug('endReadable', state.endEmitted)\n  if (!state.endEmitted) {\n    state.ended = true\n    process.nextTick(endReadableNT, state, stream)\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length)\n\n  // Check that we didn't get one last unshift.\n  if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {\n    state.endEmitted = true\n    stream.emit('end')\n    if (stream.writable && stream.allowHalfOpen === false) {\n      process.nextTick(endWritableNT, stream)\n    } else if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well.\n      const wState = stream._writableState\n      const autoDestroy =\n        !wState ||\n        (wState.autoDestroy &&\n          // We don't expect the writable to ever 'finish'\n          // if writable is explicitly set to false.\n          (wState.finished || wState.writable === false))\n      if (autoDestroy) {\n        stream.destroy()\n      }\n    }\n  }\n}\nfunction endWritableNT(stream) {\n  const writable = stream.writable && !stream.writableEnded && !stream.destroyed\n  if (writable) {\n    stream.end()\n  }\n}\nReadable.from = function (iterable, opts) {\n  return from(Readable, iterable, opts)\n}\nlet webStreamsAdapters\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined) webStreamsAdapters = {}\n  return webStreamsAdapters\n}\nReadable.fromWeb = function (readableStream, options) {\n  return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options)\n}\nReadable.toWeb = function (streamReadable, options) {\n  return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options)\n}\nReadable.wrap = function (src, options) {\n  var _ref, _src$readableObjectMo\n  return new Readable({\n    objectMode:\n      (_ref =\n        (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined\n          ? _src$readableObjectMo\n          : src.objectMode) !== null && _ref !== undefined\n        ? _ref\n        : true,\n    ...options,\n    destroy(err, callback) {\n      destroyImpl.destroyer(src, err)\n      callback(err)\n    }\n  }).wrap(src)\n}\n","/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n;('use strict')\nconst {\n  ArrayPrototypeSlice,\n  Error,\n  FunctionPrototypeSymbolHasInstance,\n  ObjectDefineProperty,\n  ObjectDefineProperties,\n  ObjectSetPrototypeOf,\n  StringPrototypeToLowerCase,\n  Symbol,\n  SymbolHasInstance\n} = require('../../ours/primordials')\nmodule.exports = Writable\nWritable.WritableState = WritableState\nconst { EventEmitter: EE } = require('events')\nconst Stream = require('./legacy').Stream\nconst { Buffer } = require('buffer')\nconst destroyImpl = require('./destroy')\nconst { addAbortSignal } = require('./add-abort-signal')\nconst { getHighWaterMark, getDefaultHighWaterMark } = require('./state')\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED,\n  ERR_STREAM_ALREADY_FINISHED,\n  ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING\n} = require('../../ours/errors').codes\nconst { errorOrDestroy } = destroyImpl\nObjectSetPrototypeOf(Writable.prototype, Stream.prototype)\nObjectSetPrototypeOf(Writable, Stream)\nfunction nop() {}\nconst kOnFinished = Symbol('kOnFinished')\nfunction WritableState(options, stream, isDuplex) {\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof require('./duplex')\n\n  // Object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!(options && options.objectMode)\n  if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode)\n\n  // The point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write().\n  this.highWaterMark = options\n    ? getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex)\n    : getDefaultHighWaterMark(false)\n\n  // if _final has been called.\n  this.finalCalled = false\n\n  // drain event flag.\n  this.needDrain = false\n  // At the start of calling end()\n  this.ending = false\n  // When end() has been called, and returned.\n  this.ended = false\n  // When 'finish' is emitted.\n  this.finished = false\n\n  // Has it been destroyed\n  this.destroyed = false\n\n  // Should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  const noDecode = !!(options && options.decodeStrings === false)\n  this.decodeStrings = !noDecode\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8'\n\n  // Not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0\n\n  // A flag to see when we're in the middle of a write.\n  this.writing = false\n\n  // When true all writes will be buffered until .uncork() call.\n  this.corked = 0\n\n  // A flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true\n\n  // A flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false\n\n  // The callback that's passed to _write(chunk, cb).\n  this.onwrite = onwrite.bind(undefined, stream)\n\n  // The callback that the user supplies to write(chunk, encoding, cb).\n  this.writecb = null\n\n  // The amount that is being written when _write is called.\n  this.writelen = 0\n\n  // Storage for data passed to the afterWrite() callback in case of\n  // synchronous _write() completion.\n  this.afterWriteTickInfo = null\n  resetBuffer(this)\n\n  // Number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted.\n  this.pendingcb = 0\n\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in, therefore we start as\n  // constructed.\n  this.constructed = true\n\n  // Emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams.\n  this.prefinished = false\n\n  // True if the error was already emitted and should not be thrown again.\n  this.errorEmitted = false\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = !options || options.emitClose !== false\n\n  // Should .destroy() be called after 'finish' (and potentially 'end').\n  this.autoDestroy = !options || options.autoDestroy !== false\n\n  // Indicates whether the stream has errored. When true all write() calls\n  // should return false. This is needed since when autoDestroy\n  // is disabled we need a way to tell whether the stream has failed.\n  this.errored = null\n\n  // Indicates whether the stream has finished destroying.\n  this.closed = false\n\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  this.closeEmitted = false\n  this[kOnFinished] = []\n}\nfunction resetBuffer(state) {\n  state.buffered = []\n  state.bufferedIndex = 0\n  state.allBuffers = true\n  state.allNoop = true\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  return ArrayPrototypeSlice(this.buffered, this.bufferedIndex)\n}\nObjectDefineProperty(WritableState.prototype, 'bufferedRequestCount', {\n  __proto__: null,\n  get() {\n    return this.buffered.length - this.bufferedIndex\n  }\n})\nfunction Writable(options) {\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5.\n  const isDuplex = this instanceof require('./duplex')\n  if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options)\n  this._writableState = new WritableState(options, this, isDuplex)\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write\n    if (typeof options.writev === 'function') this._writev = options.writev\n    if (typeof options.destroy === 'function') this._destroy = options.destroy\n    if (typeof options.final === 'function') this._final = options.final\n    if (typeof options.construct === 'function') this._construct = options.construct\n    if (options.signal) addAbortSignal(options.signal, this)\n  }\n  Stream.call(this, options)\n  destroyImpl.construct(this, () => {\n    const state = this._writableState\n    if (!state.writing) {\n      clearBuffer(this, state)\n    }\n    finishMaybe(this, state)\n  })\n}\nObjectDefineProperty(Writable, SymbolHasInstance, {\n  __proto__: null,\n  value: function (object) {\n    if (FunctionPrototypeSymbolHasInstance(this, object)) return true\n    if (this !== Writable) return false\n    return object && object._writableState instanceof WritableState\n  }\n})\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE())\n}\nfunction _write(stream, chunk, encoding, cb) {\n  const state = stream._writableState\n  if (typeof encoding === 'function') {\n    cb = encoding\n    encoding = state.defaultEncoding\n  } else {\n    if (!encoding) encoding = state.defaultEncoding\n    else if (encoding !== 'buffer' && !Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)\n    if (typeof cb !== 'function') cb = nop\n  }\n  if (chunk === null) {\n    throw new ERR_STREAM_NULL_VALUES()\n  } else if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      if (state.decodeStrings !== false) {\n        chunk = Buffer.from(chunk, encoding)\n        encoding = 'buffer'\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = 'buffer'\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk)\n      encoding = 'buffer'\n    } else {\n      throw new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)\n    }\n  }\n  let err\n  if (state.ending) {\n    err = new ERR_STREAM_WRITE_AFTER_END()\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('write')\n  }\n  if (err) {\n    process.nextTick(cb, err)\n    errorOrDestroy(stream, err, true)\n    return err\n  }\n  state.pendingcb++\n  return writeOrBuffer(stream, state, chunk, encoding, cb)\n}\nWritable.prototype.write = function (chunk, encoding, cb) {\n  return _write(this, chunk, encoding, cb) === true\n}\nWritable.prototype.cork = function () {\n  this._writableState.corked++\n}\nWritable.prototype.uncork = function () {\n  const state = this._writableState\n  if (state.corked) {\n    state.corked--\n    if (!state.writing) clearBuffer(this, state)\n  }\n}\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = StringPrototypeToLowerCase(encoding)\n  if (!Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)\n  this._writableState.defaultEncoding = encoding\n  return this\n}\n\n// If we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, callback) {\n  const len = state.objectMode ? 1 : chunk.length\n  state.length += len\n\n  // stream._write resets state.length\n  const ret = state.length < state.highWaterMark\n  // We must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true\n  if (state.writing || state.corked || state.errored || !state.constructed) {\n    state.buffered.push({\n      chunk,\n      encoding,\n      callback\n    })\n    if (state.allBuffers && encoding !== 'buffer') {\n      state.allBuffers = false\n    }\n    if (state.allNoop && callback !== nop) {\n      state.allNoop = false\n    }\n  } else {\n    state.writelen = len\n    state.writecb = callback\n    state.writing = true\n    state.sync = true\n    stream._write(chunk, encoding, state.onwrite)\n    state.sync = false\n  }\n\n  // Return false if errored or destroyed in order to break\n  // any synchronous while(stream.write(data)) loops.\n  return ret && !state.errored && !state.destroyed\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len\n  state.writecb = cb\n  state.writing = true\n  state.sync = true\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'))\n  else if (writev) stream._writev(chunk, state.onwrite)\n  else stream._write(chunk, encoding, state.onwrite)\n  state.sync = false\n}\nfunction onwriteError(stream, state, er, cb) {\n  --state.pendingcb\n  cb(er)\n  // Ensure callbacks are invoked even when autoDestroy is\n  // not enabled. Passing `er` here doesn't make sense since\n  // it's related to one specific write, not to the buffered\n  // writes.\n  errorBuffer(state)\n  // This can emit error, but error must always follow cb.\n  errorOrDestroy(stream, er)\n}\nfunction onwrite(stream, er) {\n  const state = stream._writableState\n  const sync = state.sync\n  const cb = state.writecb\n  if (typeof cb !== 'function') {\n    errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK())\n    return\n  }\n  state.writing = false\n  state.writecb = null\n  state.length -= state.writelen\n  state.writelen = 0\n  if (er) {\n    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    er.stack // eslint-disable-line no-unused-expressions\n\n    if (!state.errored) {\n      state.errored = er\n    }\n\n    // In case of duplex streams we need to notify the readable side of the\n    // error.\n    if (stream._readableState && !stream._readableState.errored) {\n      stream._readableState.errored = er\n    }\n    if (sync) {\n      process.nextTick(onwriteError, stream, state, er, cb)\n    } else {\n      onwriteError(stream, state, er, cb)\n    }\n  } else {\n    if (state.buffered.length > state.bufferedIndex) {\n      clearBuffer(stream, state)\n    }\n    if (sync) {\n      // It is a common case that the callback passed to .write() is always\n      // the same. In that case, we do not schedule a new nextTick(), but\n      // rather just increase a counter, to improve performance and avoid\n      // memory allocations.\n      if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {\n        state.afterWriteTickInfo.count++\n      } else {\n        state.afterWriteTickInfo = {\n          count: 1,\n          cb,\n          stream,\n          state\n        }\n        process.nextTick(afterWriteTick, state.afterWriteTickInfo)\n      }\n    } else {\n      afterWrite(stream, state, 1, cb)\n    }\n  }\n}\nfunction afterWriteTick({ stream, state, count, cb }) {\n  state.afterWriteTickInfo = null\n  return afterWrite(stream, state, count, cb)\n}\nfunction afterWrite(stream, state, count, cb) {\n  const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain\n  if (needDrain) {\n    state.needDrain = false\n    stream.emit('drain')\n  }\n  while (count-- > 0) {\n    state.pendingcb--\n    cb()\n  }\n  if (state.destroyed) {\n    errorBuffer(state)\n  }\n  finishMaybe(stream, state)\n}\n\n// If there's something in the buffer waiting, then invoke callbacks.\nfunction errorBuffer(state) {\n  if (state.writing) {\n    return\n  }\n  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {\n    var _state$errored\n    const { chunk, callback } = state.buffered[n]\n    const len = state.objectMode ? 1 : chunk.length\n    state.length -= len\n    callback(\n      (_state$errored = state.errored) !== null && _state$errored !== undefined\n        ? _state$errored\n        : new ERR_STREAM_DESTROYED('write')\n    )\n  }\n  const onfinishCallbacks = state[kOnFinished].splice(0)\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    var _state$errored2\n    onfinishCallbacks[i](\n      (_state$errored2 = state.errored) !== null && _state$errored2 !== undefined\n        ? _state$errored2\n        : new ERR_STREAM_DESTROYED('end')\n    )\n  }\n  resetBuffer(state)\n}\n\n// If there's something in the buffer waiting, then process it.\nfunction clearBuffer(stream, state) {\n  if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {\n    return\n  }\n  const { buffered, bufferedIndex, objectMode } = state\n  const bufferedLength = buffered.length - bufferedIndex\n  if (!bufferedLength) {\n    return\n  }\n  let i = bufferedIndex\n  state.bufferProcessing = true\n  if (bufferedLength > 1 && stream._writev) {\n    state.pendingcb -= bufferedLength - 1\n    const callback = state.allNoop\n      ? nop\n      : (err) => {\n          for (let n = i; n < buffered.length; ++n) {\n            buffered[n].callback(err)\n          }\n        }\n    // Make a copy of `buffered` if it's going to be used by `callback` above,\n    // since `doWrite` will mutate the array.\n    const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i)\n    chunks.allBuffers = state.allBuffers\n    doWrite(stream, state, true, state.length, chunks, '', callback)\n    resetBuffer(state)\n  } else {\n    do {\n      const { chunk, encoding, callback } = buffered[i]\n      buffered[i++] = null\n      const len = objectMode ? 1 : chunk.length\n      doWrite(stream, state, false, len, chunk, encoding, callback)\n    } while (i < buffered.length && !state.writing)\n    if (i === buffered.length) {\n      resetBuffer(state)\n    } else if (i > 256) {\n      buffered.splice(0, i)\n      state.bufferedIndex = 0\n    } else {\n      state.bufferedIndex = i\n    }\n  }\n  state.bufferProcessing = false\n}\nWritable.prototype._write = function (chunk, encoding, cb) {\n  if (this._writev) {\n    this._writev(\n      [\n        {\n          chunk,\n          encoding\n        }\n      ],\n      cb\n    )\n  } else {\n    throw new ERR_METHOD_NOT_IMPLEMENTED('_write()')\n  }\n}\nWritable.prototype._writev = null\nWritable.prototype.end = function (chunk, encoding, cb) {\n  const state = this._writableState\n  if (typeof chunk === 'function') {\n    cb = chunk\n    chunk = null\n    encoding = null\n  } else if (typeof encoding === 'function') {\n    cb = encoding\n    encoding = null\n  }\n  let err\n  if (chunk !== null && chunk !== undefined) {\n    const ret = _write(this, chunk, encoding)\n    if (ret instanceof Error) {\n      err = ret\n    }\n  }\n\n  // .end() fully uncorks.\n  if (state.corked) {\n    state.corked = 1\n    this.uncork()\n  }\n  if (err) {\n    // Do nothing...\n  } else if (!state.errored && !state.ending) {\n    // This is forgiving in terms of unnecessary calls to end() and can hide\n    // logic errors. However, usually such errors are harmless and causing a\n    // hard error can be disproportionately destructive. It is not always\n    // trivial for the user to determine whether end() needs to be called\n    // or not.\n\n    state.ending = true\n    finishMaybe(this, state, true)\n    state.ended = true\n  } else if (state.finished) {\n    err = new ERR_STREAM_ALREADY_FINISHED('end')\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('end')\n  }\n  if (typeof cb === 'function') {\n    if (err || state.finished) {\n      process.nextTick(cb, err)\n    } else {\n      state[kOnFinished].push(cb)\n    }\n  }\n  return this\n}\nfunction needFinish(state) {\n  return (\n    state.ending &&\n    !state.destroyed &&\n    state.constructed &&\n    state.length === 0 &&\n    !state.errored &&\n    state.buffered.length === 0 &&\n    !state.finished &&\n    !state.writing &&\n    !state.errorEmitted &&\n    !state.closeEmitted\n  )\n}\nfunction callFinal(stream, state) {\n  let called = false\n  function onFinish(err) {\n    if (called) {\n      errorOrDestroy(stream, err !== null && err !== undefined ? err : ERR_MULTIPLE_CALLBACK())\n      return\n    }\n    called = true\n    state.pendingcb--\n    if (err) {\n      const onfinishCallbacks = state[kOnFinished].splice(0)\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\n        onfinishCallbacks[i](err)\n      }\n      errorOrDestroy(stream, err, state.sync)\n    } else if (needFinish(state)) {\n      state.prefinished = true\n      stream.emit('prefinish')\n      // Backwards compat. Don't check state.sync here.\n      // Some streams assume 'finish' will be emitted\n      // asynchronously relative to _final callback.\n      state.pendingcb++\n      process.nextTick(finish, stream, state)\n    }\n  }\n  state.sync = true\n  state.pendingcb++\n  try {\n    stream._final(onFinish)\n  } catch (err) {\n    onFinish(err)\n  }\n  state.sync = false\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.finalCalled = true\n      callFinal(stream, state)\n    } else {\n      state.prefinished = true\n      stream.emit('prefinish')\n    }\n  }\n}\nfunction finishMaybe(stream, state, sync) {\n  if (needFinish(state)) {\n    prefinish(stream, state)\n    if (state.pendingcb === 0) {\n      if (sync) {\n        state.pendingcb++\n        process.nextTick(\n          (stream, state) => {\n            if (needFinish(state)) {\n              finish(stream, state)\n            } else {\n              state.pendingcb--\n            }\n          },\n          stream,\n          state\n        )\n      } else if (needFinish(state)) {\n        state.pendingcb++\n        finish(stream, state)\n      }\n    }\n  }\n}\nfunction finish(stream, state) {\n  state.pendingcb--\n  state.finished = true\n  const onfinishCallbacks = state[kOnFinished].splice(0)\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    onfinishCallbacks[i]()\n  }\n  stream.emit('finish')\n  if (state.autoDestroy) {\n    // In case of duplex streams we need a way to detect\n    // if the readable side is ready for autoDestroy as well.\n    const rState = stream._readableState\n    const autoDestroy =\n      !rState ||\n      (rState.autoDestroy &&\n        // We don't expect the readable to ever 'end'\n        // if readable is explicitly set to false.\n        (rState.endEmitted || rState.readable === false))\n    if (autoDestroy) {\n      stream.destroy()\n    }\n  }\n}\nObjectDefineProperties(Writable.prototype, {\n  closed: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.closed : false\n    }\n  },\n  destroyed: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.destroyed : false\n    },\n    set(value) {\n      // Backward compatibility, the user is explicitly managing destroyed.\n      if (this._writableState) {\n        this._writableState.destroyed = value\n      }\n    }\n  },\n  writable: {\n    __proto__: null,\n    get() {\n      const w = this._writableState\n      // w.writable === false means that this is part of a Duplex stream\n      // where the writable side was disabled upon construction.\n      // Compat. The user might manually disable writable side through\n      // deprecated setter.\n      return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended\n    },\n    set(val) {\n      // Backwards compatible.\n      if (this._writableState) {\n        this._writableState.writable = !!val\n      }\n    }\n  },\n  writableFinished: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.finished : false\n    }\n  },\n  writableObjectMode: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.objectMode : false\n    }\n  },\n  writableBuffer: {\n    __proto__: null,\n    get() {\n      return this._writableState && this._writableState.getBuffer()\n    }\n  },\n  writableEnded: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.ending : false\n    }\n  },\n  writableNeedDrain: {\n    __proto__: null,\n    get() {\n      const wState = this._writableState\n      if (!wState) return false\n      return !wState.destroyed && !wState.ending && wState.needDrain\n    }\n  },\n  writableHighWaterMark: {\n    __proto__: null,\n    get() {\n      return this._writableState && this._writableState.highWaterMark\n    }\n  },\n  writableCorked: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.corked : 0\n    }\n  },\n  writableLength: {\n    __proto__: null,\n    get() {\n      return this._writableState && this._writableState.length\n    }\n  },\n  errored: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._writableState ? this._writableState.errored : null\n    }\n  },\n  writableAborted: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return !!(\n        this._writableState.writable !== false &&\n        (this._writableState.destroyed || this._writableState.errored) &&\n        !this._writableState.finished\n      )\n    }\n  }\n})\nconst destroy = destroyImpl.destroy\nWritable.prototype.destroy = function (err, cb) {\n  const state = this._writableState\n\n  // Invoke pending callbacks.\n  if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {\n    process.nextTick(errorBuffer, state)\n  }\n  destroy.call(this, err, cb)\n  return this\n}\nWritable.prototype._undestroy = destroyImpl.undestroy\nWritable.prototype._destroy = function (err, cb) {\n  cb(err)\n}\nWritable.prototype[EE.captureRejectionSymbol] = function (err) {\n  this.destroy(err)\n}\nlet webStreamsAdapters\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined) webStreamsAdapters = {}\n  return webStreamsAdapters\n}\nWritable.fromWeb = function (writableStream, options) {\n  return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options)\n}\nWritable.toWeb = function (streamWritable) {\n  return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable)\n}\n","/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n\n;('use strict')\nconst bufferModule = require('buffer')\nconst {\n  isReadable,\n  isWritable,\n  isIterable,\n  isNodeStream,\n  isReadableNodeStream,\n  isWritableNodeStream,\n  isDuplexNodeStream,\n  isReadableStream,\n  isWritableStream\n} = require('./utils')\nconst eos = require('./end-of-stream')\nconst {\n  AbortError,\n  codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }\n} = require('../../ours/errors')\nconst { destroyer } = require('./destroy')\nconst Duplex = require('./duplex')\nconst Readable = require('./readable')\nconst Writable = require('./writable')\nconst { createDeferredPromise } = require('../../ours/util')\nconst from = require('./from')\nconst Blob = globalThis.Blob || bufferModule.Blob\nconst isBlob =\n  typeof Blob !== 'undefined'\n    ? function isBlob(b) {\n        return b instanceof Blob\n      }\n    : function isBlob(b) {\n        return false\n      }\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nconst { FunctionPrototypeCall } = require('../../ours/primordials')\n\n// This is needed for pre node 17.\nclass Duplexify extends Duplex {\n  constructor(options) {\n    super(options)\n\n    // https://github.com/nodejs/node/pull/34385\n\n    if ((options === null || options === undefined ? undefined : options.readable) === false) {\n      this._readableState.readable = false\n      this._readableState.ended = true\n      this._readableState.endEmitted = true\n    }\n    if ((options === null || options === undefined ? undefined : options.writable) === false) {\n      this._writableState.writable = false\n      this._writableState.ending = true\n      this._writableState.ended = true\n      this._writableState.finished = true\n    }\n  }\n}\nmodule.exports = function duplexify(body, name) {\n  if (isDuplexNodeStream(body)) {\n    return body\n  }\n  if (isReadableNodeStream(body)) {\n    return _duplexify({\n      readable: body\n    })\n  }\n  if (isWritableNodeStream(body)) {\n    return _duplexify({\n      writable: body\n    })\n  }\n  if (isNodeStream(body)) {\n    return _duplexify({\n      writable: false,\n      readable: false\n    })\n  }\n  if (isReadableStream(body)) {\n    return _duplexify({\n      readable: Readable.fromWeb(body)\n    })\n  }\n  if (isWritableStream(body)) {\n    return _duplexify({\n      writable: Writable.fromWeb(body)\n    })\n  }\n  if (typeof body === 'function') {\n    const { value, write, final, destroy } = fromAsyncGen(body)\n    if (isIterable(value)) {\n      return from(Duplexify, value, {\n        // TODO (ronag): highWaterMark?\n        objectMode: true,\n        write,\n        final,\n        destroy\n      })\n    }\n    const then = value === null || value === undefined ? undefined : value.then\n    if (typeof then === 'function') {\n      let d\n      const promise = FunctionPrototypeCall(\n        then,\n        value,\n        (val) => {\n          if (val != null) {\n            throw new ERR_INVALID_RETURN_VALUE('nully', 'body', val)\n          }\n        },\n        (err) => {\n          destroyer(d, err)\n        }\n      )\n      return (d = new Duplexify({\n        // TODO (ronag): highWaterMark?\n        objectMode: true,\n        readable: false,\n        write,\n        final(cb) {\n          final(async () => {\n            try {\n              await promise\n              process.nextTick(cb, null)\n            } catch (err) {\n              process.nextTick(cb, err)\n            }\n          })\n        },\n        destroy\n      }))\n    }\n    throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or AsyncFunction', name, value)\n  }\n  if (isBlob(body)) {\n    return duplexify(body.arrayBuffer())\n  }\n  if (isIterable(body)) {\n    return from(Duplexify, body, {\n      // TODO (ronag): highWaterMark?\n      objectMode: true,\n      writable: false\n    })\n  }\n  if (\n    isReadableStream(body === null || body === undefined ? undefined : body.readable) &&\n    isWritableStream(body === null || body === undefined ? undefined : body.writable)\n  ) {\n    return Duplexify.fromWeb(body)\n  }\n  if (\n    typeof (body === null || body === undefined ? undefined : body.writable) === 'object' ||\n    typeof (body === null || body === undefined ? undefined : body.readable) === 'object'\n  ) {\n    const readable =\n      body !== null && body !== undefined && body.readable\n        ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable)\n          ? body === null || body === undefined\n            ? undefined\n            : body.readable\n          : duplexify(body.readable)\n        : undefined\n    const writable =\n      body !== null && body !== undefined && body.writable\n        ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable)\n          ? body === null || body === undefined\n            ? undefined\n            : body.writable\n          : duplexify(body.writable)\n        : undefined\n    return _duplexify({\n      readable,\n      writable\n    })\n  }\n  const then = body === null || body === undefined ? undefined : body.then\n  if (typeof then === 'function') {\n    let d\n    FunctionPrototypeCall(\n      then,\n      body,\n      (val) => {\n        if (val != null) {\n          d.push(val)\n        }\n        d.push(null)\n      },\n      (err) => {\n        destroyer(d, err)\n      }\n    )\n    return (d = new Duplexify({\n      objectMode: true,\n      writable: false,\n      read() {}\n    }))\n  }\n  throw new ERR_INVALID_ARG_TYPE(\n    name,\n    [\n      'Blob',\n      'ReadableStream',\n      'WritableStream',\n      'Stream',\n      'Iterable',\n      'AsyncIterable',\n      'Function',\n      '{ readable, writable } pair',\n      'Promise'\n    ],\n    body\n  )\n}\nfunction fromAsyncGen(fn) {\n  let { promise, resolve } = createDeferredPromise()\n  const ac = new AbortController()\n  const signal = ac.signal\n  const value = fn(\n    (async function* () {\n      while (true) {\n        const _promise = promise\n        promise = null\n        const { chunk, done, cb } = await _promise\n        process.nextTick(cb)\n        if (done) return\n        if (signal.aborted)\n          throw new AbortError(undefined, {\n            cause: signal.reason\n          })\n        ;({ promise, resolve } = createDeferredPromise())\n        yield chunk\n      }\n    })(),\n    {\n      signal\n    }\n  )\n  return {\n    value,\n    write(chunk, encoding, cb) {\n      const _resolve = resolve\n      resolve = null\n      _resolve({\n        chunk,\n        done: false,\n        cb\n      })\n    },\n    final(cb) {\n      const _resolve = resolve\n      resolve = null\n      _resolve({\n        done: true,\n        cb\n      })\n    },\n    destroy(err, cb) {\n      ac.abort()\n      cb(err)\n    }\n  }\n}\nfunction _duplexify(pair) {\n  const r = pair.readable && typeof pair.readable.read !== 'function' ? Readable.wrap(pair.readable) : pair.readable\n  const w = pair.writable\n  let readable = !!isReadable(r)\n  let writable = !!isWritable(w)\n  let ondrain\n  let onfinish\n  let onreadable\n  let onclose\n  let d\n  function onfinished(err) {\n    const cb = onclose\n    onclose = null\n    if (cb) {\n      cb(err)\n    } else if (err) {\n      d.destroy(err)\n    }\n  }\n\n  // TODO(ronag): Avoid double buffering.\n  // Implement Writable/Readable/Duplex traits.\n  // See, https://github.com/nodejs/node/pull/33515.\n  d = new Duplexify({\n    // TODO (ronag): highWaterMark?\n    readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode),\n    writableObjectMode: !!(w !== null && w !== undefined && w.writableObjectMode),\n    readable,\n    writable\n  })\n  if (writable) {\n    eos(w, (err) => {\n      writable = false\n      if (err) {\n        destroyer(r, err)\n      }\n      onfinished(err)\n    })\n    d._write = function (chunk, encoding, callback) {\n      if (w.write(chunk, encoding)) {\n        callback()\n      } else {\n        ondrain = callback\n      }\n    }\n    d._final = function (callback) {\n      w.end()\n      onfinish = callback\n    }\n    w.on('drain', function () {\n      if (ondrain) {\n        const cb = ondrain\n        ondrain = null\n        cb()\n      }\n    })\n    w.on('finish', function () {\n      if (onfinish) {\n        const cb = onfinish\n        onfinish = null\n        cb()\n      }\n    })\n  }\n  if (readable) {\n    eos(r, (err) => {\n      readable = false\n      if (err) {\n        destroyer(r, err)\n      }\n      onfinished(err)\n    })\n    r.on('readable', function () {\n      if (onreadable) {\n        const cb = onreadable\n        onreadable = null\n        cb()\n      }\n    })\n    r.on('end', function () {\n      d.push(null)\n    })\n    d._read = function () {\n      while (true) {\n        const buf = r.read()\n        if (buf === null) {\n          onreadable = d._read\n          return\n        }\n        if (!d.push(buf)) {\n          return\n        }\n      }\n    }\n  }\n  d._destroy = function (err, callback) {\n    if (!err && onclose !== null) {\n      err = new AbortError()\n    }\n    onreadable = null\n    ondrain = null\n    onfinish = null\n    if (onclose === null) {\n      callback(err)\n    } else {\n      onclose = callback\n      destroyer(w, err)\n      destroyer(r, err)\n    }\n  }\n  return d\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototype inheritance, this class\n// prototypically inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict'\n\nconst {\n  ObjectDefineProperties,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectKeys,\n  ObjectSetPrototypeOf\n} = require('../../ours/primordials')\nmodule.exports = Duplex\nconst Readable = require('./readable')\nconst Writable = require('./writable')\nObjectSetPrototypeOf(Duplex.prototype, Readable.prototype)\nObjectSetPrototypeOf(Duplex, Readable)\n{\n  const keys = ObjectKeys(Writable.prototype)\n  // Allow the keys array to be GC'ed.\n  for (let i = 0; i < keys.length; i++) {\n    const method = keys[i]\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method]\n  }\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options)\n  Readable.call(this, options)\n  Writable.call(this, options)\n  if (options) {\n    this.allowHalfOpen = options.allowHalfOpen !== false\n    if (options.readable === false) {\n      this._readableState.readable = false\n      this._readableState.ended = true\n      this._readableState.endEmitted = true\n    }\n    if (options.writable === false) {\n      this._writableState.writable = false\n      this._writableState.ending = true\n      this._writableState.ended = true\n      this._writableState.finished = true\n    }\n  } else {\n    this.allowHalfOpen = true\n  }\n}\nObjectDefineProperties(Duplex.prototype, {\n  writable: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writable')\n  },\n  writableHighWaterMark: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableHighWaterMark')\n  },\n  writableObjectMode: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableObjectMode')\n  },\n  writableBuffer: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableBuffer')\n  },\n  writableLength: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableLength')\n  },\n  writableFinished: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableFinished')\n  },\n  writableCorked: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableCorked')\n  },\n  writableEnded: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableEnded')\n  },\n  writableNeedDrain: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableNeedDrain')\n  },\n  destroyed: {\n    __proto__: null,\n    get() {\n      if (this._readableState === undefined || this._writableState === undefined) {\n        return false\n      }\n      return this._readableState.destroyed && this._writableState.destroyed\n    },\n    set(value) {\n      // Backward compatibility, the user is explicitly\n      // managing destroyed.\n      if (this._readableState && this._writableState) {\n        this._readableState.destroyed = value\n        this._writableState.destroyed = value\n      }\n    }\n  }\n})\nlet webStreamsAdapters\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined) webStreamsAdapters = {}\n  return webStreamsAdapters\n}\nDuplex.fromWeb = function (pair, options) {\n  return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options)\n}\nDuplex.toWeb = function (duplex) {\n  return lazyWebStreams().newReadableWritablePairFromDuplex(duplex)\n}\nlet duplexify\nDuplex.from = function (body) {\n  if (!duplexify) {\n    duplexify = require('./duplexify')\n  }\n  return duplexify(body, 'body')\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict'\n\nconst { ObjectSetPrototypeOf, Symbol } = require('../../ours/primordials')\nmodule.exports = Transform\nconst { ERR_METHOD_NOT_IMPLEMENTED } = require('../../ours/errors').codes\nconst Duplex = require('./duplex')\nconst { getHighWaterMark } = require('./state')\nObjectSetPrototypeOf(Transform.prototype, Duplex.prototype)\nObjectSetPrototypeOf(Transform, Duplex)\nconst kCallback = Symbol('kCallback')\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options)\n\n  // TODO (ronag): This should preferably always be\n  // applied but would be semver-major. Or even better;\n  // make Transform a Readable with the Writable interface.\n  const readableHighWaterMark = options ? getHighWaterMark(this, options, 'readableHighWaterMark', true) : null\n  if (readableHighWaterMark === 0) {\n    // A Duplex will buffer both on the writable and readable side while\n    // a Transform just wants to buffer hwm number of elements. To avoid\n    // buffering twice we disable buffering on the writable side.\n    options = {\n      ...options,\n      highWaterMark: null,\n      readableHighWaterMark,\n      // TODO (ronag): 0 is not optimal since we have\n      // a \"bug\" where we check needDrain before calling _write and not after.\n      // Refs: https://github.com/nodejs/node/pull/32887\n      // Refs: https://github.com/nodejs/node/pull/35941\n      writableHighWaterMark: options.writableHighWaterMark || 0\n    }\n  }\n  Duplex.call(this, options)\n\n  // We have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false\n  this[kCallback] = null\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform\n    if (typeof options.flush === 'function') this._flush = options.flush\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  // Backwards compat. Some Transform streams incorrectly implement _final\n  // instead of or in addition to _flush. By using 'prefinish' instead of\n  // implementing _final we continue supporting this unfortunate use case.\n  this.on('prefinish', prefinish)\n}\nfunction final(cb) {\n  if (typeof this._flush === 'function' && !this.destroyed) {\n    this._flush((er, data) => {\n      if (er) {\n        if (cb) {\n          cb(er)\n        } else {\n          this.destroy(er)\n        }\n        return\n      }\n      if (data != null) {\n        this.push(data)\n      }\n      this.push(null)\n      if (cb) {\n        cb()\n      }\n    })\n  } else {\n    this.push(null)\n    if (cb) {\n      cb()\n    }\n  }\n}\nfunction prefinish() {\n  if (this._final !== final) {\n    final.call(this)\n  }\n}\nTransform.prototype._final = final\nTransform.prototype._transform = function (chunk, encoding, callback) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_transform()')\n}\nTransform.prototype._write = function (chunk, encoding, callback) {\n  const rState = this._readableState\n  const wState = this._writableState\n  const length = rState.length\n  this._transform(chunk, encoding, (err, val) => {\n    if (err) {\n      callback(err)\n      return\n    }\n    if (val != null) {\n      this.push(val)\n    }\n    if (\n      wState.ended ||\n      // Backwards compat.\n      length === rState.length ||\n      // Backwards compat.\n      rState.length < rState.highWaterMark\n    ) {\n      callback()\n    } else {\n      this[kCallback] = callback\n    }\n  })\n}\nTransform.prototype._read = function () {\n  if (this[kCallback]) {\n    const callback = this[kCallback]\n    this[kCallback] = null\n    callback()\n  }\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict'\n\nconst { ObjectSetPrototypeOf } = require('../../ours/primordials')\nmodule.exports = PassThrough\nconst Transform = require('./transform')\nObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype)\nObjectSetPrototypeOf(PassThrough, Transform)\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options)\n  Transform.call(this, options)\n}\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk)\n}\n","/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n;('use strict')\nconst { ArrayIsArray, Promise, SymbolAsyncIterator, SymbolDispose } = require('../../ours/primordials')\nconst eos = require('./end-of-stream')\nconst { once } = require('../../ours/util')\nconst destroyImpl = require('./destroy')\nconst Duplex = require('./duplex')\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_RETURN_VALUE,\n    ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED,\n    ERR_STREAM_PREMATURE_CLOSE\n  },\n  AbortError\n} = require('../../ours/errors')\nconst { validateFunction, validateAbortSignal } = require('../validators')\nconst {\n  isIterable,\n  isReadable,\n  isReadableNodeStream,\n  isNodeStream,\n  isTransformStream,\n  isWebStream,\n  isReadableStream,\n  isReadableFinished\n} = require('./utils')\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nlet PassThrough\nlet Readable\nlet addAbortListener\nfunction destroyer(stream, reading, writing) {\n  let finished = false\n  stream.on('close', () => {\n    finished = true\n  })\n  const cleanup = eos(\n    stream,\n    {\n      readable: reading,\n      writable: writing\n    },\n    (err) => {\n      finished = !err\n    }\n  )\n  return {\n    destroy: (err) => {\n      if (finished) return\n      finished = true\n      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'))\n    },\n    cleanup\n  }\n}\nfunction popCallback(streams) {\n  // Streams should never be an empty array. It should always contain at least\n  // a single stream. Therefore optimize for the average case instead of\n  // checking for length === 0 as well.\n  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]')\n  return streams.pop()\n}\nfunction makeAsyncIterable(val) {\n  if (isIterable(val)) {\n    return val\n  } else if (isReadableNodeStream(val)) {\n    // Legacy streams are not Iterable.\n    return fromReadable(val)\n  }\n  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val)\n}\nasync function* fromReadable(val) {\n  if (!Readable) {\n    Readable = require('./readable')\n  }\n  yield* Readable.prototype[SymbolAsyncIterator].call(val)\n}\nasync function pumpToNode(iterable, writable, finish, { end }) {\n  let error\n  let onresolve = null\n  const resume = (err) => {\n    if (err) {\n      error = err\n    }\n    if (onresolve) {\n      const callback = onresolve\n      onresolve = null\n      callback()\n    }\n  }\n  const wait = () =>\n    new Promise((resolve, reject) => {\n      if (error) {\n        reject(error)\n      } else {\n        onresolve = () => {\n          if (error) {\n            reject(error)\n          } else {\n            resolve()\n          }\n        }\n      }\n    })\n  writable.on('drain', resume)\n  const cleanup = eos(\n    writable,\n    {\n      readable: false\n    },\n    resume\n  )\n  try {\n    if (writable.writableNeedDrain) {\n      await wait()\n    }\n    for await (const chunk of iterable) {\n      if (!writable.write(chunk)) {\n        await wait()\n      }\n    }\n    if (end) {\n      writable.end()\n      await wait()\n    }\n    finish()\n  } catch (err) {\n    finish(error !== err ? aggregateTwoErrors(error, err) : err)\n  } finally {\n    cleanup()\n    writable.off('drain', resume)\n  }\n}\nasync function pumpToWeb(readable, writable, finish, { end }) {\n  if (isTransformStream(writable)) {\n    writable = writable.writable\n  }\n  // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure\n  const writer = writable.getWriter()\n  try {\n    for await (const chunk of readable) {\n      await writer.ready\n      writer.write(chunk).catch(() => {})\n    }\n    await writer.ready\n    if (end) {\n      await writer.close()\n    }\n    finish()\n  } catch (err) {\n    try {\n      await writer.abort(err)\n      finish(err)\n    } catch (err) {\n      finish(err)\n    }\n  }\n}\nfunction pipeline(...streams) {\n  return pipelineImpl(streams, once(popCallback(streams)))\n}\nfunction pipelineImpl(streams, callback, opts) {\n  if (streams.length === 1 && ArrayIsArray(streams[0])) {\n    streams = streams[0]\n  }\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams')\n  }\n  const ac = new AbortController()\n  const signal = ac.signal\n  const outerSignal = opts === null || opts === undefined ? undefined : opts.signal\n\n  // Need to cleanup event listeners if last stream is readable\n  // https://github.com/nodejs/node/issues/35452\n  const lastStreamCleanup = []\n  validateAbortSignal(outerSignal, 'options.signal')\n  function abort() {\n    finishImpl(new AbortError())\n  }\n  addAbortListener = addAbortListener || require('../../ours/util').addAbortListener\n  let disposable\n  if (outerSignal) {\n    disposable = addAbortListener(outerSignal, abort)\n  }\n  let error\n  let value\n  const destroys = []\n  let finishCount = 0\n  function finish(err) {\n    finishImpl(err, --finishCount === 0)\n  }\n  function finishImpl(err, final) {\n    var _disposable\n    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {\n      error = err\n    }\n    if (!error && !final) {\n      return\n    }\n    while (destroys.length) {\n      destroys.shift()(error)\n    }\n    ;(_disposable = disposable) === null || _disposable === undefined ? undefined : _disposable[SymbolDispose]()\n    ac.abort()\n    if (final) {\n      if (!error) {\n        lastStreamCleanup.forEach((fn) => fn())\n      }\n      process.nextTick(callback, error, value)\n    }\n  }\n  let ret\n  for (let i = 0; i < streams.length; i++) {\n    const stream = streams[i]\n    const reading = i < streams.length - 1\n    const writing = i > 0\n    const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false\n    const isLastStream = i === streams.length - 1\n    if (isNodeStream(stream)) {\n      if (end) {\n        const { destroy, cleanup } = destroyer(stream, reading, writing)\n        destroys.push(destroy)\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n\n      // Catch stream errors that occur after pipe/pump has completed.\n      function onError(err) {\n        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n          finish(err)\n        }\n      }\n      stream.on('error', onError)\n      if (isReadable(stream) && isLastStream) {\n        lastStreamCleanup.push(() => {\n          stream.removeListener('error', onError)\n        })\n      }\n    }\n    if (i === 0) {\n      if (typeof stream === 'function') {\n        ret = stream({\n          signal\n        })\n        if (!isIterable(ret)) {\n          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret)\n        }\n      } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {\n        ret = stream\n      } else {\n        ret = Duplex.from(stream)\n      }\n    } else if (typeof stream === 'function') {\n      if (isTransformStream(ret)) {\n        var _ret\n        ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable)\n      } else {\n        ret = makeAsyncIterable(ret)\n      }\n      ret = stream(ret, {\n        signal\n      })\n      if (reading) {\n        if (!isIterable(ret, true)) {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', `transform[${i - 1}]`, ret)\n        }\n      } else {\n        var _ret2\n        if (!PassThrough) {\n          PassThrough = require('./passthrough')\n        }\n\n        // If the last argument to pipeline is not a stream\n        // we must create a proxy stream so that pipeline(...)\n        // always returns a stream which can be further\n        // composed through `.pipe(stream)`.\n\n        const pt = new PassThrough({\n          objectMode: true\n        })\n\n        // Handle Promises/A+ spec, `then` could be a getter that throws on\n        // second use.\n        const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then\n        if (typeof then === 'function') {\n          finishCount++\n          then.call(\n            ret,\n            (val) => {\n              value = val\n              if (val != null) {\n                pt.write(val)\n              }\n              if (end) {\n                pt.end()\n              }\n              process.nextTick(finish)\n            },\n            (err) => {\n              pt.destroy(err)\n              process.nextTick(finish, err)\n            }\n          )\n        } else if (isIterable(ret, true)) {\n          finishCount++\n          pumpToNode(ret, pt, finish, {\n            end\n          })\n        } else if (isReadableStream(ret) || isTransformStream(ret)) {\n          const toRead = ret.readable || ret\n          finishCount++\n          pumpToNode(toRead, pt, finish, {\n            end\n          })\n        } else {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret)\n        }\n        ret = pt\n        const { destroy, cleanup } = destroyer(ret, false, true)\n        destroys.push(destroy)\n        if (isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n    } else if (isNodeStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount += 2\n        const cleanup = pipe(ret, stream, finish, {\n          end\n        })\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      } else if (isTransformStream(ret) || isReadableStream(ret)) {\n        const toRead = ret.readable || ret\n        finishCount++\n        pumpToNode(toRead, stream, finish, {\n          end\n        })\n      } else if (isIterable(ret)) {\n        finishCount++\n        pumpToNode(ret, stream, finish, {\n          end\n        })\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val',\n          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],\n          ret\n        )\n      }\n      ret = stream\n    } else if (isWebStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount++\n        pumpToWeb(makeAsyncIterable(ret), stream, finish, {\n          end\n        })\n      } else if (isReadableStream(ret) || isIterable(ret)) {\n        finishCount++\n        pumpToWeb(ret, stream, finish, {\n          end\n        })\n      } else if (isTransformStream(ret)) {\n        finishCount++\n        pumpToWeb(ret.readable, stream, finish, {\n          end\n        })\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val',\n          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],\n          ret\n        )\n      }\n      ret = stream\n    } else {\n      ret = Duplex.from(stream)\n    }\n  }\n  if (\n    (signal !== null && signal !== undefined && signal.aborted) ||\n    (outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)\n  ) {\n    process.nextTick(abort)\n  }\n  return ret\n}\nfunction pipe(src, dst, finish, { end }) {\n  let ended = false\n  dst.on('close', () => {\n    if (!ended) {\n      // Finish if the destination closes before the source has completed.\n      finish(new ERR_STREAM_PREMATURE_CLOSE())\n    }\n  })\n  src.pipe(dst, {\n    end: false\n  }) // If end is true we already will have a listener to end dst.\n\n  if (end) {\n    // Compat. Before node v10.12.0 stdio used to throw an error so\n    // pipe() did/does not end() stdio destinations.\n    // Now they allow it but \"secretly\" don't close the underlying fd.\n\n    function endFn() {\n      ended = true\n      dst.end()\n    }\n    if (isReadableFinished(src)) {\n      // End the destination if the source has already ended.\n      process.nextTick(endFn)\n    } else {\n      src.once('end', endFn)\n    }\n  } else {\n    finish()\n  }\n  eos(\n    src,\n    {\n      readable: true,\n      writable: false\n    },\n    (err) => {\n      const rState = src._readableState\n      if (\n        err &&\n        err.code === 'ERR_STREAM_PREMATURE_CLOSE' &&\n        rState &&\n        rState.ended &&\n        !rState.errored &&\n        !rState.errorEmitted\n      ) {\n        // Some readable streams will emit 'close' before 'end'. However, since\n        // this is on the readable side 'end' should still be emitted if the\n        // stream has been ended and no error emitted. This should be allowed in\n        // favor of backwards compatibility. Since the stream is piped to a\n        // destination this should not result in any observable difference.\n        // We don't need to check if this is a writable premature close since\n        // eos will only fail with premature close on the reading side for\n        // duplex streams.\n        src.once('end', finish).once('error', finish)\n      } else {\n        finish(err)\n      }\n    }\n  )\n  return eos(\n    dst,\n    {\n      readable: false,\n      writable: true\n    },\n    finish\n  )\n}\nmodule.exports = {\n  pipelineImpl,\n  pipeline\n}\n","'use strict'\n\nconst { pipeline } = require('./pipeline')\nconst Duplex = require('./duplex')\nconst { destroyer } = require('./destroy')\nconst {\n  isNodeStream,\n  isReadable,\n  isWritable,\n  isWebStream,\n  isTransformStream,\n  isWritableStream,\n  isReadableStream\n} = require('./utils')\nconst {\n  AbortError,\n  codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }\n} = require('../../ours/errors')\nconst eos = require('./end-of-stream')\nmodule.exports = function compose(...streams) {\n  if (streams.length === 0) {\n    throw new ERR_MISSING_ARGS('streams')\n  }\n  if (streams.length === 1) {\n    return Duplex.from(streams[0])\n  }\n  const orgStreams = [...streams]\n  if (typeof streams[0] === 'function') {\n    streams[0] = Duplex.from(streams[0])\n  }\n  if (typeof streams[streams.length - 1] === 'function') {\n    const idx = streams.length - 1\n    streams[idx] = Duplex.from(streams[idx])\n  }\n  for (let n = 0; n < streams.length; ++n) {\n    if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {\n      // TODO(ronag): Add checks for non streams.\n      continue\n    }\n    if (\n      n < streams.length - 1 &&\n      !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))\n    ) {\n      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be readable')\n    }\n    if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {\n      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be writable')\n    }\n  }\n  let ondrain\n  let onfinish\n  let onreadable\n  let onclose\n  let d\n  function onfinished(err) {\n    const cb = onclose\n    onclose = null\n    if (cb) {\n      cb(err)\n    } else if (err) {\n      d.destroy(err)\n    } else if (!readable && !writable) {\n      d.destroy()\n    }\n  }\n  const head = streams[0]\n  const tail = pipeline(streams, onfinished)\n  const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head))\n  const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail))\n\n  // TODO(ronag): Avoid double buffering.\n  // Implement Writable/Readable/Duplex traits.\n  // See, https://github.com/nodejs/node/pull/33515.\n  d = new Duplex({\n    // TODO (ronag): highWaterMark?\n    writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode),\n    readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode),\n    writable,\n    readable\n  })\n  if (writable) {\n    if (isNodeStream(head)) {\n      d._write = function (chunk, encoding, callback) {\n        if (head.write(chunk, encoding)) {\n          callback()\n        } else {\n          ondrain = callback\n        }\n      }\n      d._final = function (callback) {\n        head.end()\n        onfinish = callback\n      }\n      head.on('drain', function () {\n        if (ondrain) {\n          const cb = ondrain\n          ondrain = null\n          cb()\n        }\n      })\n    } else if (isWebStream(head)) {\n      const writable = isTransformStream(head) ? head.writable : head\n      const writer = writable.getWriter()\n      d._write = async function (chunk, encoding, callback) {\n        try {\n          await writer.ready\n          writer.write(chunk).catch(() => {})\n          callback()\n        } catch (err) {\n          callback(err)\n        }\n      }\n      d._final = async function (callback) {\n        try {\n          await writer.ready\n          writer.close().catch(() => {})\n          onfinish = callback\n        } catch (err) {\n          callback(err)\n        }\n      }\n    }\n    const toRead = isTransformStream(tail) ? tail.readable : tail\n    eos(toRead, () => {\n      if (onfinish) {\n        const cb = onfinish\n        onfinish = null\n        cb()\n      }\n    })\n  }\n  if (readable) {\n    if (isNodeStream(tail)) {\n      tail.on('readable', function () {\n        if (onreadable) {\n          const cb = onreadable\n          onreadable = null\n          cb()\n        }\n      })\n      tail.on('end', function () {\n        d.push(null)\n      })\n      d._read = function () {\n        while (true) {\n          const buf = tail.read()\n          if (buf === null) {\n            onreadable = d._read\n            return\n          }\n          if (!d.push(buf)) {\n            return\n          }\n        }\n      }\n    } else if (isWebStream(tail)) {\n      const readable = isTransformStream(tail) ? tail.readable : tail\n      const reader = readable.getReader()\n      d._read = async function () {\n        while (true) {\n          try {\n            const { value, done } = await reader.read()\n            if (!d.push(value)) {\n              return\n            }\n            if (done) {\n              d.push(null)\n              return\n            }\n          } catch {\n            return\n          }\n        }\n      }\n    }\n  }\n  d._destroy = function (err, callback) {\n    if (!err && onclose !== null) {\n      err = new AbortError()\n    }\n    onreadable = null\n    ondrain = null\n    onfinish = null\n    if (onclose === null) {\n      callback(err)\n    } else {\n      onclose = callback\n      if (isNodeStream(tail)) {\n        destroyer(tail, err)\n      }\n    }\n  }\n  return d\n}\n","'use strict'\n\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nconst {\n  codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },\n  AbortError\n} = require('../../ours/errors')\nconst { validateAbortSignal, validateInteger, validateObject } = require('../validators')\nconst kWeakHandler = require('../../ours/primordials').Symbol('kWeak')\nconst kResistStopPropagation = require('../../ours/primordials').Symbol('kResistStopPropagation')\nconst { finished } = require('./end-of-stream')\nconst staticCompose = require('./compose')\nconst { addAbortSignalNoValidate } = require('./add-abort-signal')\nconst { isWritable, isNodeStream } = require('./utils')\nconst { deprecate } = require('../../ours/util')\nconst {\n  ArrayPrototypePush,\n  Boolean,\n  MathFloor,\n  Number,\n  NumberIsNaN,\n  Promise,\n  PromiseReject,\n  PromiseResolve,\n  PromisePrototypeThen,\n  Symbol\n} = require('../../ours/primordials')\nconst kEmpty = Symbol('kEmpty')\nconst kEof = Symbol('kEof')\nfunction compose(stream, options) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  if (isNodeStream(stream) && !isWritable(stream)) {\n    throw new ERR_INVALID_ARG_VALUE('stream', stream, 'must be writable')\n  }\n  const composedStream = staticCompose(this, stream)\n  if (options !== null && options !== undefined && options.signal) {\n    // Not validating as we already validated before\n    addAbortSignalNoValidate(options.signal, composedStream)\n  }\n  return composedStream\n}\nfunction map(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  let concurrency = 1\n  if ((options === null || options === undefined ? undefined : options.concurrency) != null) {\n    concurrency = MathFloor(options.concurrency)\n  }\n  let highWaterMark = concurrency - 1\n  if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) {\n    highWaterMark = MathFloor(options.highWaterMark)\n  }\n  validateInteger(concurrency, 'options.concurrency', 1)\n  validateInteger(highWaterMark, 'options.highWaterMark', 0)\n  highWaterMark += concurrency\n  return async function* map() {\n    const signal = require('../../ours/util').AbortSignalAny(\n      [options === null || options === undefined ? undefined : options.signal].filter(Boolean)\n    )\n    const stream = this\n    const queue = []\n    const signalOpt = {\n      signal\n    }\n    let next\n    let resume\n    let done = false\n    let cnt = 0\n    function onCatch() {\n      done = true\n      afterItemProcessed()\n    }\n    function afterItemProcessed() {\n      cnt -= 1\n      maybeResume()\n    }\n    function maybeResume() {\n      if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {\n        resume()\n        resume = null\n      }\n    }\n    async function pump() {\n      try {\n        for await (let val of stream) {\n          if (done) {\n            return\n          }\n          if (signal.aborted) {\n            throw new AbortError()\n          }\n          try {\n            val = fn(val, signalOpt)\n            if (val === kEmpty) {\n              continue\n            }\n            val = PromiseResolve(val)\n          } catch (err) {\n            val = PromiseReject(err)\n          }\n          cnt += 1\n          PromisePrototypeThen(val, afterItemProcessed, onCatch)\n          queue.push(val)\n          if (next) {\n            next()\n            next = null\n          }\n          if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {\n            await new Promise((resolve) => {\n              resume = resolve\n            })\n          }\n        }\n        queue.push(kEof)\n      } catch (err) {\n        const val = PromiseReject(err)\n        PromisePrototypeThen(val, afterItemProcessed, onCatch)\n        queue.push(val)\n      } finally {\n        done = true\n        if (next) {\n          next()\n          next = null\n        }\n      }\n    }\n    pump()\n    try {\n      while (true) {\n        while (queue.length > 0) {\n          const val = await queue[0]\n          if (val === kEof) {\n            return\n          }\n          if (signal.aborted) {\n            throw new AbortError()\n          }\n          if (val !== kEmpty) {\n            yield val\n          }\n          queue.shift()\n          maybeResume()\n        }\n        await new Promise((resolve) => {\n          next = resolve\n        })\n      }\n    } finally {\n      done = true\n      if (resume) {\n        resume()\n        resume = null\n      }\n    }\n  }.call(this)\n}\nfunction asIndexedPairs(options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  return async function* asIndexedPairs() {\n    let index = 0\n    for await (const val of this) {\n      var _options$signal\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal = options.signal) !== null &&\n        _options$signal !== undefined &&\n        _options$signal.aborted\n      ) {\n        throw new AbortError({\n          cause: options.signal.reason\n        })\n      }\n      yield [index++, val]\n    }\n  }.call(this)\n}\nasync function some(fn, options = undefined) {\n  for await (const unused of filter.call(this, fn, options)) {\n    return true\n  }\n  return false\n}\nasync function every(fn, options = undefined) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  // https://en.wikipedia.org/wiki/De_Morgan%27s_laws\n  return !(await some.call(\n    this,\n    async (...args) => {\n      return !(await fn(...args))\n    },\n    options\n  ))\n}\nasync function find(fn, options) {\n  for await (const result of filter.call(this, fn, options)) {\n    return result\n  }\n  return undefined\n}\nasync function forEach(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  async function forEachFn(value, options) {\n    await fn(value, options)\n    return kEmpty\n  }\n  // eslint-disable-next-line no-unused-vars\n  for await (const unused of map.call(this, forEachFn, options));\n}\nfunction filter(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  async function filterFn(value, options) {\n    if (await fn(value, options)) {\n      return value\n    }\n    return kEmpty\n  }\n  return map.call(this, filterFn, options)\n}\n\n// Specific to provide better error to reduce since the argument is only\n// missing if the stream has no items in it - but the code is still appropriate\nclass ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {\n  constructor() {\n    super('reduce')\n    this.message = 'Reduce of an empty stream requires an initial value'\n  }\n}\nasync function reduce(reducer, initialValue, options) {\n  var _options$signal2\n  if (typeof reducer !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('reducer', ['Function', 'AsyncFunction'], reducer)\n  }\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  let hasInitialValue = arguments.length > 1\n  if (\n    options !== null &&\n    options !== undefined &&\n    (_options$signal2 = options.signal) !== null &&\n    _options$signal2 !== undefined &&\n    _options$signal2.aborted\n  ) {\n    const err = new AbortError(undefined, {\n      cause: options.signal.reason\n    })\n    this.once('error', () => {}) // The error is already propagated\n    await finished(this.destroy(err))\n    throw err\n  }\n  const ac = new AbortController()\n  const signal = ac.signal\n  if (options !== null && options !== undefined && options.signal) {\n    const opts = {\n      once: true,\n      [kWeakHandler]: this,\n      [kResistStopPropagation]: true\n    }\n    options.signal.addEventListener('abort', () => ac.abort(), opts)\n  }\n  let gotAnyItemFromStream = false\n  try {\n    for await (const value of this) {\n      var _options$signal3\n      gotAnyItemFromStream = true\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal3 = options.signal) !== null &&\n        _options$signal3 !== undefined &&\n        _options$signal3.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (!hasInitialValue) {\n        initialValue = value\n        hasInitialValue = true\n      } else {\n        initialValue = await reducer(initialValue, value, {\n          signal\n        })\n      }\n    }\n    if (!gotAnyItemFromStream && !hasInitialValue) {\n      throw new ReduceAwareErrMissingArgs()\n    }\n  } finally {\n    ac.abort()\n  }\n  return initialValue\n}\nasync function toArray(options) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  const result = []\n  for await (const val of this) {\n    var _options$signal4\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal4 = options.signal) !== null &&\n      _options$signal4 !== undefined &&\n      _options$signal4.aborted\n    ) {\n      throw new AbortError(undefined, {\n        cause: options.signal.reason\n      })\n    }\n    ArrayPrototypePush(result, val)\n  }\n  return result\n}\nfunction flatMap(fn, options) {\n  const values = map.call(this, fn, options)\n  return async function* flatMap() {\n    for await (const val of values) {\n      yield* val\n    }\n  }.call(this)\n}\nfunction toIntegerOrInfinity(number) {\n  // We coerce here to align with the spec\n  // https://github.com/tc39/proposal-iterator-helpers/issues/169\n  number = Number(number)\n  if (NumberIsNaN(number)) {\n    return 0\n  }\n  if (number < 0) {\n    throw new ERR_OUT_OF_RANGE('number', '>= 0', number)\n  }\n  return number\n}\nfunction drop(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  number = toIntegerOrInfinity(number)\n  return async function* drop() {\n    var _options$signal5\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal5 = options.signal) !== null &&\n      _options$signal5 !== undefined &&\n      _options$signal5.aborted\n    ) {\n      throw new AbortError()\n    }\n    for await (const val of this) {\n      var _options$signal6\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal6 = options.signal) !== null &&\n        _options$signal6 !== undefined &&\n        _options$signal6.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (number-- <= 0) {\n        yield val\n      }\n    }\n  }.call(this)\n}\nfunction take(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  number = toIntegerOrInfinity(number)\n  return async function* take() {\n    var _options$signal7\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal7 = options.signal) !== null &&\n      _options$signal7 !== undefined &&\n      _options$signal7.aborted\n    ) {\n      throw new AbortError()\n    }\n    for await (const val of this) {\n      var _options$signal8\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal8 = options.signal) !== null &&\n        _options$signal8 !== undefined &&\n        _options$signal8.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (number-- > 0) {\n        yield val\n      }\n\n      // Don't get another item from iterator in case we reached the end\n      if (number <= 0) {\n        return\n      }\n    }\n  }.call(this)\n}\nmodule.exports.streamReturningOperators = {\n  asIndexedPairs: deprecate(asIndexedPairs, 'readable.asIndexedPairs will be removed in a future version.'),\n  drop,\n  filter,\n  flatMap,\n  map,\n  take,\n  compose\n}\nmodule.exports.promiseReturningOperators = {\n  every,\n  forEach,\n  reduce,\n  toArray,\n  some,\n  find\n}\n","'use strict'\n\nconst { ArrayPrototypePop, Promise } = require('../ours/primordials')\nconst { isIterable, isNodeStream, isWebStream } = require('../internal/streams/utils')\nconst { pipelineImpl: pl } = require('../internal/streams/pipeline')\nconst { finished } = require('../internal/streams/end-of-stream')\nrequire('../../lib/stream.js')\nfunction pipeline(...streams) {\n  return new Promise((resolve, reject) => {\n    let signal\n    let end\n    const lastArg = streams[streams.length - 1]\n    if (\n      lastArg &&\n      typeof lastArg === 'object' &&\n      !isNodeStream(lastArg) &&\n      !isIterable(lastArg) &&\n      !isWebStream(lastArg)\n    ) {\n      const options = ArrayPrototypePop(streams)\n      signal = options.signal\n      end = options.end\n    }\n    pl(\n      streams,\n      (err, value) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(value)\n        }\n      },\n      {\n        signal,\n        end\n      }\n    )\n  })\n}\nmodule.exports = {\n  finished,\n  pipeline\n}\n","/* replacement start */\n\nconst { Buffer } = require('buffer')\n\n/* replacement end */\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n;('use strict')\nconst { ObjectDefineProperty, ObjectKeys, ReflectApply } = require('./ours/primordials')\nconst {\n  promisify: { custom: customPromisify }\n} = require('./ours/util')\nconst { streamReturningOperators, promiseReturningOperators } = require('./internal/streams/operators')\nconst {\n  codes: { ERR_ILLEGAL_CONSTRUCTOR }\n} = require('./ours/errors')\nconst compose = require('./internal/streams/compose')\nconst { setDefaultHighWaterMark, getDefaultHighWaterMark } = require('./internal/streams/state')\nconst { pipeline } = require('./internal/streams/pipeline')\nconst { destroyer } = require('./internal/streams/destroy')\nconst eos = require('./internal/streams/end-of-stream')\nconst internalBuffer = {}\nconst promises = require('./stream/promises')\nconst utils = require('./internal/streams/utils')\nconst Stream = (module.exports = require('./internal/streams/legacy').Stream)\nStream.isDestroyed = utils.isDestroyed\nStream.isDisturbed = utils.isDisturbed\nStream.isErrored = utils.isErrored\nStream.isReadable = utils.isReadable\nStream.isWritable = utils.isWritable\nStream.Readable = require('./internal/streams/readable')\nfor (const key of ObjectKeys(streamReturningOperators)) {\n  const op = streamReturningOperators[key]\n  function fn(...args) {\n    if (new.target) {\n      throw ERR_ILLEGAL_CONSTRUCTOR()\n    }\n    return Stream.Readable.from(ReflectApply(op, this, args))\n  }\n  ObjectDefineProperty(fn, 'name', {\n    __proto__: null,\n    value: op.name\n  })\n  ObjectDefineProperty(fn, 'length', {\n    __proto__: null,\n    value: op.length\n  })\n  ObjectDefineProperty(Stream.Readable.prototype, key, {\n    __proto__: null,\n    value: fn,\n    enumerable: false,\n    configurable: true,\n    writable: true\n  })\n}\nfor (const key of ObjectKeys(promiseReturningOperators)) {\n  const op = promiseReturningOperators[key]\n  function fn(...args) {\n    if (new.target) {\n      throw ERR_ILLEGAL_CONSTRUCTOR()\n    }\n    return ReflectApply(op, this, args)\n  }\n  ObjectDefineProperty(fn, 'name', {\n    __proto__: null,\n    value: op.name\n  })\n  ObjectDefineProperty(fn, 'length', {\n    __proto__: null,\n    value: op.length\n  })\n  ObjectDefineProperty(Stream.Readable.prototype, key, {\n    __proto__: null,\n    value: fn,\n    enumerable: false,\n    configurable: true,\n    writable: true\n  })\n}\nStream.Writable = require('./internal/streams/writable')\nStream.Duplex = require('./internal/streams/duplex')\nStream.Transform = require('./internal/streams/transform')\nStream.PassThrough = require('./internal/streams/passthrough')\nStream.pipeline = pipeline\nconst { addAbortSignal } = require('./internal/streams/add-abort-signal')\nStream.addAbortSignal = addAbortSignal\nStream.finished = eos\nStream.destroy = destroyer\nStream.compose = compose\nStream.setDefaultHighWaterMark = setDefaultHighWaterMark\nStream.getDefaultHighWaterMark = getDefaultHighWaterMark\nObjectDefineProperty(Stream, 'promises', {\n  __proto__: null,\n  configurable: true,\n  enumerable: true,\n  get() {\n    return promises\n  }\n})\nObjectDefineProperty(pipeline, customPromisify, {\n  __proto__: null,\n  enumerable: true,\n  get() {\n    return promises.pipeline\n  }\n})\nObjectDefineProperty(eos, customPromisify, {\n  __proto__: null,\n  enumerable: true,\n  get() {\n    return promises.finished\n  }\n})\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream\nStream._isUint8Array = function isUint8Array(value) {\n  return value instanceof Uint8Array\n}\nStream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n}\n","'use strict'\n\nconst CustomStream = require('../stream')\nconst promises = require('../stream/promises')\nconst originalDestroy = CustomStream.Readable.destroy\nmodule.exports = CustomStream.Readable\n\n// Explicit export naming is needed for ESM\nmodule.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer\nmodule.exports._isUint8Array = CustomStream._isUint8Array\nmodule.exports.isDisturbed = CustomStream.isDisturbed\nmodule.exports.isErrored = CustomStream.isErrored\nmodule.exports.isReadable = CustomStream.isReadable\nmodule.exports.Readable = CustomStream.Readable\nmodule.exports.Writable = CustomStream.Writable\nmodule.exports.Duplex = CustomStream.Duplex\nmodule.exports.Transform = CustomStream.Transform\nmodule.exports.PassThrough = CustomStream.PassThrough\nmodule.exports.addAbortSignal = CustomStream.addAbortSignal\nmodule.exports.finished = CustomStream.finished\nmodule.exports.destroy = CustomStream.destroy\nmodule.exports.destroy = originalDestroy\nmodule.exports.pipeline = CustomStream.pipeline\nmodule.exports.compose = CustomStream.compose\nObject.defineProperty(CustomStream, 'promises', {\n  configurable: true,\n  enumerable: true,\n  get() {\n    return promises\n  }\n})\nmodule.exports.Stream = CustomStream.Stream\n\n// Allow default importing\nmodule.exports.default = module.exports\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContainerHandlerIdentifier = void 0;\n/**\n * Container handler for @id.\n *\n * It assumes that the current key is the identifier of the current value.\n * This will add this value to the parent node.\n */\nclass ContainerHandlerIdentifier {\n    canCombineWithGraph() {\n        return true;\n    }\n    async handle(containers, parsingContext, util, keys, value, depth) {\n        let id;\n        // First check if the child node already has a defined id.\n        if (parsingContext.emittedStack[depth + 1] && parsingContext.idStack[depth + 1]) {\n            // Use the existing identifier\n            id = parsingContext.idStack[depth + 1][0];\n        }\n        else {\n            // Create the identifier\n            const keyUnaliased = await util.getContainerKey(keys[depth], keys, depth);\n            const maybeId = keyUnaliased !== null\n                ? await util.resourceToTerm(await parsingContext.getContext(keys), keys[depth])\n                : util.dataFactory.blankNode();\n            // Do nothing if the id is invalid\n            if (!maybeId) {\n                parsingContext.emittedStack[depth] = false; // Don't emit the predicate owning this container.\n                return;\n            }\n            id = maybeId;\n            // Insert the id into the stack so that buffered children can make us of it.\n            parsingContext.idStack[depth + 1] = [id];\n        }\n        // Insert the id into the stack so that parents can make use of it.\n        // Insert it as an array because multiple id container entries may exist\n        let ids = parsingContext.idStack[depth];\n        if (!ids) {\n            ids = parsingContext.idStack[depth] = [];\n        }\n        // Only insert the term if it does not exist yet in the array.\n        if (!ids.some((term) => term.equals(id))) {\n            ids.push(id);\n        }\n        // Flush any pending flush buffers\n        if (!await parsingContext.handlePendingContainerFlushBuffers()) {\n            parsingContext.emittedStack[depth] = false; // Don't emit the predicate owning this container.\n        }\n    }\n}\nexports.ContainerHandlerIdentifier = ContainerHandlerIdentifier;\n//# sourceMappingURL=ContainerHandlerIdentifier.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerPredicate = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst Util_1 = require(\"../Util\");\n/**\n * Interprets keys as predicates.\n * The most common case in JSON-LD processing.\n */\nclass EntryHandlerPredicate {\n    /**\n     * Handle the given predicate-object by either emitting it,\n     * or by placing it in the appropriate stack for later emission when no @graph and/or @id has been defined.\n     * @param {ParsingContext} parsingContext A parsing context.\n     * @param {Util} util A utility instance.\n     * @param {any[]} keys A stack of keys.\n     * @param {number} depth The current depth.\n     * @param {Term} predicate The predicate.\n     * @param {Term} object The object.\n     * @param {boolean} reverse If the property is reversed.\n     * @param {boolean} isEmbedded If the property exists in an embedded node as direct child.\n     * @param {boolean} isAnnotation If the property exists in an annotation object.\n     * @return {Promise<void>} A promise resolving when handling is done.\n     */\n    static async handlePredicateObject(parsingContext, util, keys, depth, predicate, object, reverse, isEmbedded, isAnnotation) {\n        const depthProperties = await util.getPropertiesDepth(keys, depth);\n        const depthOffsetGraph = await util.getDepthOffsetGraph(depth, keys);\n        const depthPropertiesGraph = depth - depthOffsetGraph;\n        const subjects = parsingContext.idStack[depthProperties];\n        if (subjects && !isAnnotation) {\n            // Emit directly if the @id was already defined\n            for (const subject of subjects) {\n                // Check if we're in a @graph context\n                const atGraph = depthOffsetGraph >= 0;\n                if (atGraph) {\n                    const graphs = parsingContext.idStack[depthPropertiesGraph - 1];\n                    if (graphs) {\n                        for (const graph of graphs) {\n                            // Emit our quad if graph @id is known\n                            util.emitQuadChecked(depth, subject, predicate, object, graph, reverse, isEmbedded);\n                        }\n                    }\n                    else {\n                        // Buffer our triple if graph @id is not known yet.\n                        if (reverse) {\n                            util.validateReverseSubject(object);\n                            parsingContext.getUnidentifiedGraphBufferSafe(depthPropertiesGraph - 1).push({ subject: object, predicate, object: subject, isEmbedded });\n                        }\n                        else {\n                            parsingContext.getUnidentifiedGraphBufferSafe(depthPropertiesGraph - 1)\n                                .push({ subject, predicate, object, isEmbedded });\n                        }\n                    }\n                }\n                else {\n                    // Emit if no @graph was applicable\n                    const graph = await util.getGraphContainerValue(keys, depthProperties);\n                    util.emitQuadChecked(depth, subject, predicate, object, graph, reverse, isEmbedded);\n                }\n            }\n        }\n        else {\n            // Buffer until our @id becomes known, or we go up the stack\n            if (reverse) {\n                util.validateReverseSubject(object);\n            }\n            // Either push to the annotations or the actual value buffer\n            if (isAnnotation) {\n                // Only add to buffer if rdfstar is enabled\n                if (parsingContext.rdfstar) {\n                    // Error if an @id was defined\n                    if (parsingContext.idStack[depth]) {\n                        parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an illegal @id inside an annotation: ${parsingContext.idStack[depth][0].value}`, jsonld_context_parser_1.ERROR_CODES.INVALID_ANNOTATION));\n                    }\n                    // Error if we're in an embedded node\n                    for (let i = 0; i < depth; i++) {\n                        if (await util.unaliasKeyword(keys[i], keys, i) === '@id') {\n                            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an illegal annotation inside an embedded node`, jsonld_context_parser_1.ERROR_CODES.INVALID_ANNOTATION));\n                        }\n                    }\n                    // Store new annotation in the buffer\n                    const annotationsBuffer = parsingContext.getAnnotationsBufferSafe(depthProperties);\n                    const newAnnotation = { predicate, object, reverse, nestedAnnotations: [], depth: depthProperties };\n                    annotationsBuffer.push(newAnnotation);\n                    // Check in the buffer if any annotations were defined at a deeper depth,\n                    // if so, they are considered nested annotations.\n                    for (let i = annotationsBuffer.length - 2; i >= 0; i--) {\n                        // We iterate in reverse order, to enable easy item removal from the back.\n                        const existingAnnotation = annotationsBuffer[i];\n                        if (existingAnnotation.depth > depthProperties) {\n                            newAnnotation.nestedAnnotations.push(existingAnnotation);\n                            annotationsBuffer.splice(i, 1);\n                        }\n                    }\n                }\n            }\n            else {\n                parsingContext.getUnidentifiedValueBufferSafe(depthProperties).push({ predicate, object, reverse, isEmbedded });\n            }\n        }\n    }\n    isPropertyHandler() {\n        return true;\n    }\n    isStackProcessor() {\n        return true;\n    }\n    async validate(parsingContext, util, keys, depth, inProperty) {\n        const key = keys[depth];\n        if (key) {\n            const context = await parsingContext.getContext(keys);\n            if (!parsingContext.jsonLiteralStack[depth] && await util.predicateToTerm(context, keys[depth])) {\n                // If this valid predicate is of type @json, mark it so in the stack so that no deeper handling of nodes occurs.\n                if (Util_1.Util.getContextValueType(context, key) === '@json') {\n                    parsingContext.jsonLiteralStack[depth + 1] = true;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    async test(parsingContext, util, key, keys, depth) {\n        return keys[depth];\n    }\n    async handle(parsingContext, util, key, keys, value, depth, testResult) {\n        const keyOriginal = keys[depth];\n        const context = await parsingContext.getContext(keys);\n        const predicate = await util.predicateToTerm(context, key);\n        if (predicate) {\n            const objects = await util.valueToTerm(context, key, value, depth, keys);\n            if (objects.length) {\n                for (let object of objects) {\n                    // Based on parent key, check if reverse, embedded, and annotation.\n                    let parentKey = await util.unaliasKeywordParent(keys, depth);\n                    const reverse = Util_1.Util.isPropertyReverse(context, keyOriginal, parentKey);\n                    let parentDepthOffset = 0;\n                    while (parentKey === '@reverse' || typeof parentKey === 'number') {\n                        // Check parent of parent when checking while we're in an array or in @reverse\n                        if (typeof parentKey === 'number') {\n                            parentDepthOffset++;\n                        }\n                        else {\n                            depth--;\n                        }\n                        parentKey = await util.unaliasKeywordParent(keys, depth - parentDepthOffset);\n                    }\n                    const isEmbedded = Util_1.Util.isPropertyInEmbeddedNode(parentKey);\n                    util.validateReverseInEmbeddedNode(key, reverse, isEmbedded);\n                    const isAnnotation = Util_1.Util.isPropertyInAnnotationObject(parentKey);\n                    if (value) {\n                        // Special case if our term was defined as an @list, but does not occur in an array,\n                        // In that case we just emit it as an RDF list with a single element.\n                        const listValueContainer = '@list' in Util_1.Util.getContextValueContainer(context, key);\n                        if (listValueContainer || value['@list']) {\n                            if (((listValueContainer && !Array.isArray(value) && !value['@list'])\n                                || (value['@list'] && !Array.isArray(value['@list'])))\n                                && object !== util.rdfNil) {\n                                const listPointer = util.dataFactory.blankNode();\n                                parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer, util.rdfRest, util.rdfNil, util.getDefaultGraph()));\n                                parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer, util.rdfFirst, object, util.getDefaultGraph()));\n                                object = listPointer;\n                            }\n                            // Lists are not allowed in @reverse'd properties\n                            if (reverse && !parsingContext.allowSubjectList) {\n                                throw new jsonld_context_parser_1.ErrorCoded(`Found illegal list value in subject position at ${key}`, jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_PROPERTY_VALUE);\n                            }\n                        }\n                    }\n                    await EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth, predicate, object, reverse, isEmbedded, isAnnotation);\n                }\n            }\n        }\n    }\n}\nexports.EntryHandlerPredicate = EntryHandlerPredicate;\n//# sourceMappingURL=EntryHandlerPredicate.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContainerHandlerIndex = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst EntryHandlerPredicate_1 = require(\"../entryhandler/EntryHandlerPredicate\");\nconst Util_1 = require(\"../Util\");\n/**\n * Container handler for @index.\n *\n * This will ignore the current key and add this entry to the parent node.\n */\nclass ContainerHandlerIndex {\n    canCombineWithGraph() {\n        return true;\n    }\n    async handle(containers, parsingContext, util, keys, value, depth) {\n        if (!Array.isArray(value)) {\n            const graphContainer = '@graph' in containers;\n            // Check if the container is a property-based container by checking if there is a valid @index.\n            const context = await parsingContext.getContext(keys);\n            const indexKey = keys[depth - 1];\n            const indexPropertyRaw = Util_1.Util.getContextValueIndex(context, indexKey);\n            if (indexPropertyRaw) {\n                // Validate the @index value\n                if (jsonld_context_parser_1.Util.isPotentialKeyword(indexPropertyRaw)) {\n                    throw new jsonld_context_parser_1.ErrorCoded(`Keywords can not be used as @index value, got: ${indexPropertyRaw}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n                if (typeof indexPropertyRaw !== 'string') {\n                    throw new jsonld_context_parser_1.ErrorCoded(`@index values must be strings, got: ${indexPropertyRaw}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n                // When @index is used, values must be node values, unless @type: @id is defined in the context\n                if (typeof value !== 'object') {\n                    // Error if we don't have @type: @id\n                    if (Util_1.Util.getContextValueType(context, indexKey) !== '@id') {\n                        throw new jsonld_context_parser_1.ErrorCoded(`Property-based index containers require nodes as values or strings with @type: @id, but got: ${value}`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n                    }\n                    // Add an @id to the stack, so our expanded @index value can make use of it\n                    const id = util.resourceToTerm(context, value);\n                    if (id) {\n                        parsingContext.idStack[depth + 1] = [id];\n                    }\n                }\n                // Expand the @index value\n                const indexProperty = util.createVocabOrBaseTerm(context, indexPropertyRaw);\n                if (indexProperty) {\n                    const indexValues = await util.valueToTerm(context, indexPropertyRaw, await util.getContainerKey(keys[depth], keys, depth), depth, keys);\n                    if (graphContainer) {\n                        // When we're in a graph container, attach the index to the graph identifier\n                        const graphId = await util.getGraphContainerValue(keys, depth + 1);\n                        for (const indexValue of indexValues) {\n                            parsingContext.emitQuad(depth, util.dataFactory.quad(graphId, indexProperty, indexValue, util.getDefaultGraph()));\n                        }\n                    }\n                    else {\n                        // Otherwise, attach the index to the node identifier\n                        for (const indexValue of indexValues) {\n                            await EntryHandlerPredicate_1.EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth + 1, indexProperty, indexValue, false, false, false);\n                        }\n                    }\n                }\n            }\n            const depthOffset = graphContainer ? 2 : 1;\n            await parsingContext.newOnValueJob(keys.slice(0, keys.length - depthOffset), value, depth - depthOffset, true);\n            // Flush any pending flush buffers\n            await parsingContext.handlePendingContainerFlushBuffers();\n        }\n        parsingContext.emittedStack[depth] = false; // We have emitted a level higher\n    }\n}\nexports.ContainerHandlerIndex = ContainerHandlerIndex;\n//# sourceMappingURL=ContainerHandlerIndex.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContainerHandlerLanguage = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\n/**\n * Container handler for @language.\n *\n * It assumes that the current key is the language of the current value.\n * This will add this value to the parent node.\n */\nclass ContainerHandlerLanguage {\n    canCombineWithGraph() {\n        return false;\n    }\n    async handle(containers, parsingContext, util, keys, value, depth) {\n        const language = await util.getContainerKey(keys[depth], keys, depth);\n        if (Array.isArray(value)) {\n            // No type-checking needed, will be handled on each value when this handler is called recursively.\n            value = value.map((subValue) => ({ '@value': subValue, '@language': language }));\n        }\n        else {\n            if (typeof value !== 'string') {\n                throw new jsonld_context_parser_1.ErrorCoded(`Got invalid language map value, got '${JSON.stringify(value)}', but expected string`, jsonld_context_parser_1.ERROR_CODES.INVALID_LANGUAGE_MAP_VALUE);\n            }\n            value = { '@value': value, '@language': language };\n        }\n        await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), value, depth - 1, true);\n        parsingContext.emittedStack[depth] = false; // We have emitted a level higher\n    }\n}\nexports.ContainerHandlerLanguage = ContainerHandlerLanguage;\n//# sourceMappingURL=ContainerHandlerLanguage.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContainerHandlerType = void 0;\nconst EntryHandlerPredicate_1 = require(\"../entryhandler/EntryHandlerPredicate\");\nconst Util_1 = require(\"../Util\");\n/**\n * Container handler for @type.\n *\n * This will add this entry to the parent node, and use the current key as an rdf:type value.\n */\nclass ContainerHandlerType {\n    canCombineWithGraph() {\n        return false;\n    }\n    async handle(containers, parsingContext, util, keys, value, depth) {\n        if (!Array.isArray(value)) {\n            if (typeof value === 'string') {\n                // Determine the @type of the container\n                const context = await parsingContext.getContext(keys);\n                const containerTypeType = Util_1.Util.getContextValueType(context, keys[depth - 1]);\n                // String values refer to node references\n                const id = containerTypeType === '@vocab'\n                    ? await util.createVocabOrBaseTerm(context, value)\n                    : await util.resourceToTerm(context, value);\n                if (id) {\n                    // Handle the value of this node as @id, which will also cause the predicate from above to be emitted.\n                    const subValue = { '@id': id.termType === 'NamedNode' ? id.value : value };\n                    await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), subValue, depth - 1, true);\n                    // Set the id in the stack so it can be used for the rdf:type handling later on\n                    parsingContext.idStack[depth + 1] = [id];\n                }\n            }\n            else {\n                // Other values are handled by handling them as a proper job\n                // Check needed for cases where entries don't have an explicit @id\n                const entryHasIdentifier = !!parsingContext.idStack[depth + 1];\n                // Handle the value of this node, which will also cause the predicate from above to be emitted.\n                if (!entryHasIdentifier) {\n                    delete parsingContext.idStack[depth]; // Force new (blank node) identifier\n                }\n                await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), value, depth - 1, true);\n                if (!entryHasIdentifier) {\n                    parsingContext.idStack[depth + 1] = parsingContext.idStack[depth]; // Copy the id to the child node, for @type\n                }\n            }\n            // Identify the type to emit.\n            const keyOriginal = await util.getContainerKey(keys[depth], keys, depth);\n            const type = keyOriginal !== null\n                ? util.createVocabOrBaseTerm(await parsingContext.getContext(keys), keyOriginal)\n                : null;\n            if (type) {\n                // Push the type to the stack using the rdf:type predicate\n                await EntryHandlerPredicate_1.EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth + 1, util.rdfType, type, false, false, false);\n            }\n            // Flush any pending flush buffers\n            await parsingContext.handlePendingContainerFlushBuffers();\n        }\n        parsingContext.emittedStack[depth] = false; // Don't emit the predicate owning this container.\n    }\n}\nexports.ContainerHandlerType = ContainerHandlerType;\n//# sourceMappingURL=ContainerHandlerType.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerContainer = void 0;\nconst ContainerHandlerIdentifier_1 = require(\"../containerhandler/ContainerHandlerIdentifier\");\nconst ContainerHandlerIndex_1 = require(\"../containerhandler/ContainerHandlerIndex\");\nconst ContainerHandlerLanguage_1 = require(\"../containerhandler/ContainerHandlerLanguage\");\nconst ContainerHandlerType_1 = require(\"../containerhandler/ContainerHandlerType\");\nconst Util_1 = require(\"../Util\");\n/**\n * Handles values that are part of a container type (like @index),\n * as specified by {@link IContainerHandler}.\n */\nclass EntryHandlerContainer {\n    /**\n     * Check fit the given container is a simple @graph container.\n     * Concretely, it will check if no @index or @id is active as well.\n     * @param containers A container hash.\n     */\n    static isSimpleGraphContainer(containers) {\n        return '@graph' in containers\n            && (('@set' in containers && Object.keys(containers).length === 2) || Object.keys(containers).length === 1);\n    }\n    /**\n     * Check fit the given container is a complex @graph container.\n     * Concretely, it will check if @index or @id is active as well next to @graph.\n     * @param containers A container hash.\n     */\n    static isComplexGraphContainer(containers) {\n        return '@graph' in containers\n            && (('@set' in containers && Object.keys(containers).length > 2)\n                || (!('@set' in containers) && Object.keys(containers).length > 1));\n    }\n    /**\n     * Create an graph container index that can be used for identifying a graph term inside the graphContainerTermStack.\n     * @param containers The applicable containers.\n     * @param depth The container depth.\n     * @param keys The array of keys.\n     * @return The graph index.\n     */\n    static getContainerGraphIndex(containers, depth, keys) {\n        let isSimpleGraphContainer = EntryHandlerContainer.isSimpleGraphContainer(containers);\n        let index = '';\n        for (let i = depth; i < keys.length; i++) {\n            if (!isSimpleGraphContainer || typeof keys[i] === 'number') {\n                index += ':' + keys[i];\n            }\n            // Only allow a second 'real' key if in a non-simple graph container.\n            if (!isSimpleGraphContainer && typeof keys[i] !== 'number') {\n                isSimpleGraphContainer = true;\n            }\n        }\n        return index;\n    }\n    /**\n     * Return the applicable container type at the given depth.\n     *\n     * This will ignore any arrays in the key chain.\n     *\n     * @param {ParsingContext} parsingContext A parsing context.\n     * @param {any[]} keys The array of keys.\n     * @param {number} depth The current depth.\n     * @return {Promise<{ containers: {[typeName: string]: boolean}, depth: number, fallback: boolean }>}\n     *          All applicable containers for the given depth,\n     *          the `depth` of the container root (can change when arrays are in the key chain),\n     *          and the `fallback` flag that indicates if the default container type was returned\n     *            (i.e., no dedicated container type is defined).\n     */\n    static async getContainerHandler(parsingContext, keys, depth) {\n        const fallback = {\n            containers: { '@set': true },\n            depth,\n            fallback: true,\n        };\n        // A flag that is enabled when @graph container should be tested in next iteration\n        let checkGraphContainer = false;\n        // Iterate from deeper to higher\n        const context = await parsingContext.getContext(keys, 2);\n        for (let i = depth - 1; i >= 0; i--) {\n            if (typeof keys[i] !== 'number') { // Skip array keys\n                // @graph containers without any other types are one level less deep, and require special handling\n                const containersSelf = Util_1.Util.getContextValue(context, '@container', keys[i], false);\n                if (containersSelf && EntryHandlerContainer.isSimpleGraphContainer(containersSelf)) {\n                    return {\n                        containers: containersSelf,\n                        depth: i + 1,\n                        fallback: false,\n                    };\n                }\n                const containersParent = Util_1.Util.getContextValue(context, '@container', keys[i - 1], false);\n                if (!containersParent) { // If we have the fallback container value\n                    if (checkGraphContainer) {\n                        // Return false if we were already expecting a @graph-@id of @graph-@index container\n                        return fallback;\n                    }\n                    // Check parent-parent, we may be in a @graph-@id of @graph-@index container, which have two levels\n                    checkGraphContainer = true;\n                }\n                else {\n                    // We had an invalid container next iteration, so we now have to check if we were in an @graph container\n                    const graphContainer = '@graph' in containersParent;\n                    // We're in a regular container\n                    for (const containerHandleName in EntryHandlerContainer.CONTAINER_HANDLERS) {\n                        if (containersParent[containerHandleName]) {\n                            if (graphContainer) {\n                                // Only accept graph containers if their combined handlers can handle them.\n                                if (EntryHandlerContainer.CONTAINER_HANDLERS[containerHandleName].canCombineWithGraph()) {\n                                    return {\n                                        containers: containersParent,\n                                        depth: i,\n                                        fallback: false,\n                                    };\n                                }\n                                else {\n                                    return fallback;\n                                }\n                            }\n                            else {\n                                // Only accept if we were not expecting a @graph-@id of @graph-@index container\n                                if (checkGraphContainer) {\n                                    return fallback;\n                                }\n                                else {\n                                    return {\n                                        containers: containersParent,\n                                        depth: i,\n                                        fallback: false,\n                                    };\n                                }\n                            }\n                        }\n                    }\n                    // Fail if no valid container handlers were found\n                    return fallback;\n                }\n            }\n        }\n        return fallback;\n    }\n    /**\n     * Check if we are handling a value at the given depth\n     * that is part of something that should be handled as a container,\n     * AND if this container should be buffered, so that it can be handled by a dedicated container handler.\n     *\n     * For instance, any container with @graph will NOT be buffered.\n     *\n     * This will ignore any arrays in the key chain.\n     *\n     * @param {ParsingContext} parsingContext A parsing context.\n     * @param {any[]} keys The array of keys.\n     * @param {number} depth The current depth.\n     * @return {Promise<boolean>} If we are in the scope of a container handler.\n     */\n    static async isBufferableContainerHandler(parsingContext, keys, depth) {\n        const handler = await EntryHandlerContainer.getContainerHandler(parsingContext, keys, depth);\n        return !handler.fallback && !('@graph' in handler.containers);\n    }\n    isPropertyHandler() {\n        return false;\n    }\n    isStackProcessor() {\n        return true;\n    }\n    async validate(parsingContext, util, keys, depth, inProperty) {\n        return !!await this.test(parsingContext, util, null, keys, depth);\n    }\n    async test(parsingContext, util, key, keys, depth) {\n        const containers = Util_1.Util.getContextValueContainer(await parsingContext.getContext(keys, 2), keys[depth - 1]);\n        for (const containerName in EntryHandlerContainer.CONTAINER_HANDLERS) {\n            if (containers[containerName]) {\n                return {\n                    containers,\n                    handler: EntryHandlerContainer.CONTAINER_HANDLERS[containerName],\n                };\n            }\n        }\n        return null;\n    }\n    async handle(parsingContext, util, key, keys, value, depth, testResult) {\n        return testResult.handler.handle(testResult.containers, parsingContext, util, keys, value, depth);\n    }\n}\nEntryHandlerContainer.CONTAINER_HANDLERS = {\n    '@id': new ContainerHandlerIdentifier_1.ContainerHandlerIdentifier(),\n    '@index': new ContainerHandlerIndex_1.ContainerHandlerIndex(),\n    '@language': new ContainerHandlerLanguage_1.ContainerHandlerLanguage(),\n    '@type': new ContainerHandlerType_1.ContainerHandlerType(),\n};\nexports.EntryHandlerContainer = EntryHandlerContainer;\n//# sourceMappingURL=EntryHandlerContainer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Util = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst EntryHandlerContainer_1 = require(\"./entryhandler/EntryHandlerContainer\");\n// tslint:disable-next-line:no-var-requires\nconst canonicalizeJson = require('canonicalize');\n/**\n * Utility functions and methods.\n */\nclass Util {\n    constructor(options) {\n        this.parsingContext = options.parsingContext;\n        this.dataFactory = options.dataFactory || new rdf_data_factory_1.DataFactory();\n        this.rdfFirst = this.dataFactory.namedNode(Util.RDF + 'first');\n        this.rdfRest = this.dataFactory.namedNode(Util.RDF + 'rest');\n        this.rdfNil = this.dataFactory.namedNode(Util.RDF + 'nil');\n        this.rdfType = this.dataFactory.namedNode(Util.RDF + 'type');\n        this.rdfJson = this.dataFactory.namedNode(Util.RDF + 'JSON');\n    }\n    /**\n     * Helper function to get the value of a context entry,\n     * or fallback to a certain value.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} contextKey A pre-defined JSON-LD key in context entries.\n     * @param {string} key A context entry key.\n     * @param {string} fallback A fallback value for when the given contextKey\n     *                          could not be found in the value with the given key.\n     * @return {string} The value of the given contextKey in the entry behind key in the given context,\n     *                  or the given fallback value.\n     */\n    static getContextValue(context, contextKey, key, fallback) {\n        const entry = context.getContextRaw()[key];\n        if (!entry) {\n            return fallback;\n        }\n        const type = entry[contextKey];\n        return type === undefined ? fallback : type;\n    }\n    /**\n     * Get the container type of the given key in the context.\n     *\n     * Should any context-scoping bugs should occur related to this in the future,\n     * it may be required to increase the offset from the depth at which the context is retrieved by one (to 2).\n     * This is because containers act 2 levels deep.\n     *\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key A context entry key.\n     * @return {string} The container type.\n     */\n    static getContextValueContainer(context, key) {\n        return Util.getContextValue(context, '@container', key, { '@set': true });\n    }\n    /**\n     * Get the value type of the given key in the context.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key A context entry key.\n     * @return {string} The node type.\n     */\n    static getContextValueType(context, key) {\n        const valueType = Util.getContextValue(context, '@type', key, null);\n        if (valueType === '@none') {\n            return null;\n        }\n        return valueType;\n    }\n    /**\n     * Get the language of the given key in the context.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key A context entry key.\n     * @return {string} The node type.\n     */\n    static getContextValueLanguage(context, key) {\n        return Util.getContextValue(context, '@language', key, context.getContextRaw()['@language'] || null);\n    }\n    /**\n     * Get the direction of the given key in the context.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key A context entry key.\n     * @return {string} The node type.\n     */\n    static getContextValueDirection(context, key) {\n        return Util.getContextValue(context, '@direction', key, context.getContextRaw()['@direction'] || null);\n    }\n    /**\n     * Check if the given key in the context is a reversed property.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key A context entry key.\n     * @return {boolean} If the context value has a @reverse key.\n     */\n    static isContextValueReverse(context, key) {\n        return !!Util.getContextValue(context, '@reverse', key, null);\n    }\n    /**\n     * Get the @index of the given key in the context.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key A context entry key.\n     * @return {string} The index.\n     */\n    static getContextValueIndex(context, key) {\n        return Util.getContextValue(context, '@index', key, context.getContextRaw()['@index'] || null);\n    }\n    /**\n     * Check if the given key refers to a reversed property.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key The property key.\n     * @param {string} parentKey The parent key.\n     * @return {boolean} If the property must be reversed.\n     */\n    static isPropertyReverse(context, key, parentKey) {\n        // '!==' is needed because reversed properties in a @reverse container should cancel each other out.\n        return parentKey === '@reverse' !== Util.isContextValueReverse(context, key);\n    }\n    /**\n     * Check if the given key exists inside an embedded node as direct child.\n     * @param {string} parentKey The parent key.\n     * @return {boolean} If the property is embedded.\n     */\n    static isPropertyInEmbeddedNode(parentKey) {\n        return parentKey === '@id';\n    }\n    /**\n     * Check if the given key exists inside an annotation object as direct child.\n     * @param {string} parentKey The parent key.\n     * @return {boolean} If the property is an annotation.\n     */\n    static isPropertyInAnnotationObject(parentKey) {\n        return parentKey === '@annotation';\n    }\n    /**\n     * Check if the given IRI is valid.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIri(iri) {\n        return iri !== null && jsonld_context_parser_1.Util.isValidIri(iri);\n    }\n    /**\n     * Check if the given first array (needle) is a prefix of the given second array (haystack).\n     * @param needle An array to check if it is a prefix.\n     * @param haystack An array to look in.\n     */\n    static isPrefixArray(needle, haystack) {\n        if (needle.length > haystack.length) {\n            return false;\n        }\n        for (let i = 0; i < needle.length; i++) {\n            if (needle[i] !== haystack[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Make sure that @id-@index pairs are equal over all array values.\n     * Reject otherwise.\n     * @param {any[]} value An array value.\n     * @return {Promise<void>} A promise rejecting if conflicts are present.\n     */\n    async validateValueIndexes(value) {\n        if (this.parsingContext.validateValueIndexes) {\n            const indexHashes = {};\n            for (const entry of value) {\n                if (entry && typeof entry === 'object') {\n                    const id = entry['@id'];\n                    const index = entry['@index'];\n                    if (id && index) {\n                        const existingIndexValue = indexHashes[id];\n                        if (existingIndexValue && existingIndexValue !== index) {\n                            throw new jsonld_context_parser_1.ErrorCoded(`Conflicting @index value for ${id}`, jsonld_context_parser_1.ERROR_CODES.CONFLICTING_INDEXES);\n                        }\n                        indexHashes[id] = index;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Convert a given JSON value to an RDF term.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key The current JSON key.\n     * @param value A JSON value.\n     * @param {number} depth The depth the value is at.\n     * @param {string[]} keys The path of keys.\n     * @return {Promise<RDF.Term[]>} An RDF term array.\n     */\n    async valueToTerm(context, key, value, depth, keys) {\n        // Skip further processing if we have an @type: @json\n        if (Util.getContextValueType(context, key) === '@json') {\n            return [this.dataFactory.literal(this.valueToJsonString(value), this.rdfJson)];\n        }\n        const type = typeof value;\n        switch (type) {\n            case 'object':\n                // Skip if we have a null or undefined object\n                if (value === null || value === undefined) {\n                    return [];\n                }\n                // Special case for arrays\n                if (Array.isArray(value)) {\n                    // We handle arrays at value level so we can emit earlier, so this is handled already when we get here.\n                    // Empty context-based lists are emitted at this place, because our streaming algorithm doesn't detect those.\n                    if ('@list' in Util.getContextValueContainer(context, key)) {\n                        if (value.length === 0) {\n                            return [this.rdfNil];\n                        }\n                        else {\n                            return this.parsingContext.idStack[depth + 1] || [];\n                        }\n                    }\n                    await this.validateValueIndexes(value);\n                    return [];\n                }\n                // Handle property-scoped contexts\n                context = await this.getContextSelfOrPropertyScoped(context, key);\n                // Handle local context in the value\n                if ('@context' in value) {\n                    context = await this.parsingContext.parseContext(value['@context'], (await this.parsingContext.getContext(keys, 0)).getContextRaw());\n                }\n                // In all other cases, we have a hash\n                value = await this.unaliasKeywords(value, keys, depth, context); // Un-alias potential keywords in this hash\n                if ('@value' in value) {\n                    let val;\n                    let valueLanguage;\n                    let valueDirection;\n                    let valueType;\n                    let valueIndex; // We don't use the index, but we need to check its type for spec-compliance\n                    for (key in value) {\n                        const subValue = value[key];\n                        switch (key) {\n                            case '@value':\n                                val = subValue;\n                                break;\n                            case '@language':\n                                valueLanguage = subValue;\n                                break;\n                            case '@direction':\n                                valueDirection = subValue;\n                                break;\n                            case '@type':\n                                valueType = subValue;\n                                break;\n                            case '@index':\n                                valueIndex = subValue;\n                                break;\n                            case '@annotation':\n                                // This keyword is allowed, but is processed like normal nodes\n                                break;\n                            default:\n                                throw new jsonld_context_parser_1.ErrorCoded(`Unknown value entry '${key}' in @value: ${JSON.stringify(value)}`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n                        }\n                    }\n                    // Skip further processing if we have an @type: @json\n                    if (await this.unaliasKeyword(valueType, keys, depth, true, context) === '@json') {\n                        return [this.dataFactory.literal(this.valueToJsonString(val), this.rdfJson)];\n                    }\n                    // Validate @value\n                    if (val === null) {\n                        return [];\n                    }\n                    if (typeof val === 'object') {\n                        throw new jsonld_context_parser_1.ErrorCoded(`The value of an '@value' can not be an object, got '${JSON.stringify(val)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT_VALUE);\n                    }\n                    // Validate @index\n                    if (this.parsingContext.validateValueIndexes && valueIndex && typeof valueIndex !== 'string') {\n                        throw new jsonld_context_parser_1.ErrorCoded(`The value of an '@index' must be a string, got '${JSON.stringify(valueIndex)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_INDEX_VALUE);\n                    }\n                    // Validate @language and @direction\n                    if (valueLanguage) {\n                        if (typeof val !== 'string') {\n                            throw new jsonld_context_parser_1.ErrorCoded(`When an '@language' is set, the value of '@value' must be a string, got '${JSON.stringify(val)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_LANGUAGE_TAGGED_VALUE);\n                        }\n                        if (!jsonld_context_parser_1.ContextParser.validateLanguage(valueLanguage, this.parsingContext.strictValues, jsonld_context_parser_1.ERROR_CODES.INVALID_LANGUAGE_TAGGED_STRING)) {\n                            return [];\n                        }\n                        // Language tags are always normalized to lowercase in 1.0.\n                        if (this.parsingContext.normalizeLanguageTags || this.parsingContext.activeProcessingMode === 1.0) {\n                            valueLanguage = valueLanguage.toLowerCase();\n                        }\n                    }\n                    if (valueDirection) {\n                        if (typeof val !== 'string') {\n                            throw new Error(`When an '@direction' is set, the value of '@value' must be a string, got '${JSON.stringify(val)}'`);\n                        }\n                        if (!jsonld_context_parser_1.ContextParser.validateDirection(valueDirection, this.parsingContext.strictValues)) {\n                            return [];\n                        }\n                    }\n                    // Check @language and @direction\n                    if (valueLanguage && valueDirection && this.parsingContext.rdfDirection) {\n                        if (valueType) {\n                            throw new jsonld_context_parser_1.ErrorCoded(`Can not have '@language', '@direction' and '@type' in a value: '${JSON\n                                .stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n                        }\n                        return this.nullableTermToArray(this\n                            .createLanguageDirectionLiteral(depth, val, valueLanguage, valueDirection));\n                    }\n                    else if (valueLanguage) { // Check @language\n                        if (valueType) {\n                            throw new jsonld_context_parser_1.ErrorCoded(`Can not have both '@language' and '@type' in a value: '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n                        }\n                        return [this.dataFactory.literal(val, valueLanguage)];\n                    }\n                    else if (valueDirection && this.parsingContext.rdfDirection) { // Check @direction\n                        if (valueType) {\n                            throw new jsonld_context_parser_1.ErrorCoded(`Can not have both '@direction' and '@type' in a value: '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n                        }\n                        return this.nullableTermToArray(this\n                            .createLanguageDirectionLiteral(depth, val, valueLanguage, valueDirection));\n                    }\n                    else if (valueType) { // Validate @type\n                        if (typeof valueType !== 'string') {\n                            throw new jsonld_context_parser_1.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(valueType)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPED_VALUE);\n                        }\n                        const typeTerm = this.createVocabOrBaseTerm(context, valueType);\n                        if (!typeTerm) {\n                            throw new jsonld_context_parser_1.ErrorCoded(`Invalid '@type' value, got '${JSON.stringify(valueType)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPED_VALUE);\n                        }\n                        if (typeTerm.termType !== 'NamedNode') {\n                            throw new jsonld_context_parser_1.ErrorCoded(`Illegal value type (${typeTerm.termType}): ${valueType}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPED_VALUE);\n                        }\n                        return [this.dataFactory.literal(val, typeTerm)];\n                    }\n                    // We don't pass the context, because context-based things like @language should be ignored\n                    return await this.valueToTerm(new jsonld_context_parser_1.JsonLdContextNormalized({}), key, val, depth, keys);\n                }\n                else if ('@set' in value) {\n                    // No other entries are allow in this value\n                    if (Object.keys(value).length > 1) {\n                        throw new jsonld_context_parser_1.ErrorCoded(`Found illegal neighbouring entries next to @set for key: '${key}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT);\n                    }\n                    // No need to do anything here, this is handled at the deeper level.\n                    return [];\n                }\n                else if ('@list' in value) {\n                    // No other entries are allowed in this value\n                    if (Object.keys(value).length > 1) {\n                        throw new jsonld_context_parser_1.ErrorCoded(`Found illegal neighbouring entries next to @list for key: '${key}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT);\n                    }\n                    const listValue = value[\"@list\"];\n                    // We handle lists at value level so we can emit earlier, so this is handled already when we get here.\n                    // Empty anonymous lists are emitted at this place, because our streaming algorithm doesn't detect those.\n                    if (Array.isArray(listValue)) {\n                        if (listValue.length === 0) {\n                            return [this.rdfNil];\n                        }\n                        else {\n                            return this.parsingContext.idStack[depth + 1] || [];\n                        }\n                    }\n                    else {\n                        // We only have a single list element here, so emit this directly as single element\n                        return await this.valueToTerm(await this.parsingContext.getContext(keys), key, listValue, depth - 1, keys.slice(0, -1));\n                    }\n                }\n                else if ('@reverse' in value && typeof value['@reverse'] === 'boolean') {\n                    // We handle reverse properties at value level so we can emit earlier,\n                    // so this is handled already when we get here.\n                    return [];\n                }\n                else if ('@graph' in Util.getContextValueContainer(await this.parsingContext.getContext(keys), key)) {\n                    // We are processing a graph container\n                    const graphContainerEntries = this.parsingContext.graphContainerTermStack[depth + 1];\n                    return graphContainerEntries ? Object.values(graphContainerEntries) : [this.dataFactory.blankNode()];\n                }\n                else if (\"@id\" in value) {\n                    // Use deeper context if the value node contains other properties next to @id.\n                    if (Object.keys(value).length > 1) {\n                        context = await this.parsingContext.getContext(keys, 0);\n                    }\n                    // Handle local context in the value\n                    if ('@context' in value) {\n                        context = await this.parsingContext.parseContext(value['@context'], context.getContextRaw());\n                    }\n                    if (value[\"@type\"] === '@vocab') {\n                        return this.nullableTermToArray(this.createVocabOrBaseTerm(context, value[\"@id\"]));\n                    }\n                    else {\n                        const valueId = value[\"@id\"];\n                        let valueTerm;\n                        if (typeof valueId === 'object') {\n                            if (this.parsingContext.rdfstar) {\n                                valueTerm = this.parsingContext.idStack[depth + 1][0];\n                            }\n                            else {\n                                throw new jsonld_context_parser_1.ErrorCoded(`Found illegal @id '${value}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_ID_VALUE);\n                            }\n                        }\n                        else {\n                            valueTerm = this.resourceToTerm(context, valueId);\n                        }\n                        return this.nullableTermToArray(valueTerm);\n                    }\n                }\n                else {\n                    // Only make a blank node if at least one triple was emitted at the value's level.\n                    if (this.parsingContext.emittedStack[depth + 1]\n                        || (value && typeof value === 'object' && Object.keys(value).length === 0)) {\n                        return (this.parsingContext.idStack[depth + 1]\n                            || (this.parsingContext.idStack[depth + 1] = [this.dataFactory.blankNode()]));\n                    }\n                    else {\n                        return [];\n                    }\n                }\n            case 'string':\n                return this.nullableTermToArray(this.stringValueToTerm(depth, await this.getContextSelfOrPropertyScoped(context, key), key, value, null));\n            case 'boolean':\n                return this.nullableTermToArray(this.stringValueToTerm(depth, await this.getContextSelfOrPropertyScoped(context, key), key, Boolean(value).toString(), this.dataFactory.namedNode(Util.XSD_BOOLEAN)));\n            case 'number':\n                return this.nullableTermToArray(this.stringValueToTerm(depth, await this.getContextSelfOrPropertyScoped(context, key), key, value, this.dataFactory.namedNode(value % 1 === 0 && value < 1e21 ? Util.XSD_INTEGER : Util.XSD_DOUBLE)));\n            default:\n                this.parsingContext.emitError(new Error(`Could not determine the RDF type of a ${type}`));\n                return [];\n        }\n    }\n    /**\n     * If the context defines a property-scoped context for the given key,\n     * that context will be returned.\n     * Otherwise, the given context will be returned as-is.\n     *\n     * This should be used for valueToTerm cases that are not objects.\n     * @param context A context.\n     * @param key A JSON key.\n     */\n    async getContextSelfOrPropertyScoped(context, key) {\n        const contextKeyEntry = context.getContextRaw()[key];\n        if (contextKeyEntry && typeof contextKeyEntry === 'object' && '@context' in contextKeyEntry) {\n            context = await this.parsingContext.parseContext(contextKeyEntry, context.getContextRaw(), true);\n        }\n        return context;\n    }\n    /**\n     * If the given term is null, return an empty array, otherwise return an array with the single given term.\n     * @param term A term.\n     */\n    nullableTermToArray(term) {\n        return term ? [term] : [];\n    }\n    /**\n     * Convert a given JSON key to an RDF predicate term,\n     * based on @vocab.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param key A JSON key.\n     * @return {RDF.NamedNode} An RDF named node.\n     */\n    predicateToTerm(context, key) {\n        const expanded = context.expandTerm(key, true, this.parsingContext.getExpandOptions());\n        // Immediately return if the predicate was disabled in the context\n        if (!expanded) {\n            return null;\n        }\n        // Check if the predicate is a blank node\n        if (expanded[0] === '_' && expanded[1] === ':') {\n            if (this.parsingContext.produceGeneralizedRdf) {\n                return this.dataFactory.blankNode(expanded.substr(2));\n            }\n            else {\n                return null;\n            }\n        }\n        // Check if the predicate is a valid IRI\n        if (Util.isValidIri(expanded)) {\n            return this.dataFactory.namedNode(expanded);\n        }\n        else {\n            if (expanded && this.parsingContext.strictValues) {\n                this.parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Invalid predicate IRI: ${expanded}`, jsonld_context_parser_1.ERROR_CODES.INVALID_IRI_MAPPING));\n            }\n            else {\n                return null;\n            }\n        }\n        return null;\n    }\n    /**\n     * Convert a given JSON key to an RDF resource term or blank node,\n     * based on @base.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param key A JSON key.\n     * @return {RDF.NamedNode} An RDF named node or null.\n     */\n    resourceToTerm(context, key) {\n        if (key.startsWith('_:')) {\n            return this.dataFactory.blankNode(key.substr(2));\n        }\n        const iri = context.expandTerm(key, false, this.parsingContext.getExpandOptions());\n        if (!Util.isValidIri(iri)) {\n            if (iri && this.parsingContext.strictValues) {\n                this.parsingContext.emitError(new Error(`Invalid resource IRI: ${iri}`));\n            }\n            else {\n                return null;\n            }\n        }\n        return this.dataFactory.namedNode(iri);\n    }\n    /**\n     * Convert a given JSON key to an RDF resource term.\n     * It will do this based on the @vocab,\n     * and fallback to @base.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param key A JSON key.\n     * @return {RDF.NamedNode} An RDF named node or null.\n     */\n    createVocabOrBaseTerm(context, key) {\n        if (key.startsWith('_:')) {\n            return this.dataFactory.blankNode(key.substr(2));\n        }\n        const expandOptions = this.parsingContext.getExpandOptions();\n        let expanded = context.expandTerm(key, true, expandOptions);\n        if (expanded === key) {\n            expanded = context.expandTerm(key, false, expandOptions);\n        }\n        if (!Util.isValidIri(expanded)) {\n            if (expanded && this.parsingContext.strictValues && !expanded.startsWith('@')) {\n                this.parsingContext.emitError(new Error(`Invalid term IRI: ${expanded}`));\n            }\n            else {\n                return null;\n            }\n        }\n        return this.dataFactory.namedNode(expanded);\n    }\n    /**\n     * Ensure that the given value becomes a string.\n     * @param {string | number} value A string or number.\n     * @param {NamedNode} datatype The intended datatype.\n     * @return {string} The returned string.\n     */\n    intToString(value, datatype) {\n        if (typeof value === 'number') {\n            if (Number.isFinite(value)) {\n                const isInteger = value % 1 === 0;\n                if (isInteger && (!datatype || datatype.value !== Util.XSD_DOUBLE)) {\n                    return Number(value).toString();\n                }\n                else {\n                    return value.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n                }\n            }\n            else {\n                return value > 0 ? 'INF' : '-INF';\n            }\n        }\n        else {\n            return value;\n        }\n    }\n    /**\n     * Convert a given JSON string value to an RDF term.\n     * @param {number} depth The current stack depth.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key The current JSON key.\n     * @param {string} value A JSON value.\n     * @param {NamedNode} defaultDatatype The default datatype for the given value.\n     * @return {RDF.Term} An RDF term or null.\n     */\n    stringValueToTerm(depth, context, key, value, defaultDatatype) {\n        // Check the datatype from the context\n        const contextType = Util.getContextValueType(context, key);\n        if (contextType) {\n            if (contextType === '@id') {\n                if (!defaultDatatype) {\n                    return this.resourceToTerm(context, this.intToString(value, defaultDatatype));\n                }\n            }\n            else if (contextType === '@vocab') {\n                if (!defaultDatatype) {\n                    return this.createVocabOrBaseTerm(context, this.intToString(value, defaultDatatype));\n                }\n            }\n            else {\n                defaultDatatype = this.dataFactory.namedNode(contextType);\n            }\n        }\n        // If we don't find such a datatype, check the language from the context\n        if (!defaultDatatype) {\n            const contextLanguage = Util.getContextValueLanguage(context, key);\n            const contextDirection = Util.getContextValueDirection(context, key);\n            if (contextDirection && this.parsingContext.rdfDirection) {\n                return this.createLanguageDirectionLiteral(depth, this.intToString(value, defaultDatatype), contextLanguage, contextDirection);\n            }\n            else {\n                return this.dataFactory.literal(this.intToString(value, defaultDatatype), contextLanguage);\n            }\n        }\n        // If all else fails, make a literal based on the default content type\n        return this.dataFactory.literal(this.intToString(value, defaultDatatype), defaultDatatype);\n    }\n    /**\n     * Create a literal for the given value with the given language and direction.\n     * Auxiliary quads may be emitted.\n     * @param {number} depth The current stack depth.\n     * @param {string} value A string value.\n     * @param {string} language A language tag.\n     * @param {string} direction A direction.\n     * @return {Term} An RDF term.\n     */\n    createLanguageDirectionLiteral(depth, value, language, direction) {\n        if (this.parsingContext.rdfDirection === 'i18n-datatype') {\n            // Create a datatyped literal, by encoding the language and direction into https://www.w3.org/ns/i18n#.\n            if (!language) {\n                language = '';\n            }\n            return this.dataFactory.literal(value, this.dataFactory.namedNode(`https://www.w3.org/ns/i18n#${language}_${direction}`));\n        }\n        else {\n            // Reify the literal.\n            const valueNode = this.dataFactory.blankNode();\n            const graph = this.getDefaultGraph();\n            this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode, this.dataFactory.namedNode(Util.RDF + 'value'), this.dataFactory.literal(value), graph));\n            if (language) {\n                this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode, this.dataFactory.namedNode(Util.RDF + 'language'), this.dataFactory.literal(language), graph));\n            }\n            this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode, this.dataFactory.namedNode(Util.RDF + 'direction'), this.dataFactory.literal(direction), graph));\n            return valueNode;\n        }\n    }\n    /**\n     * Stringify the given JSON object to a canonical JSON string.\n     * @param value Any valid JSON value.\n     * @return {string} A canonical JSON string.\n     */\n    valueToJsonString(value) {\n        return canonicalizeJson(value);\n    }\n    /**\n     * If the key is not a keyword, try to check if it is an alias for a keyword,\n     * and if so, un-alias it.\n     * @param {string} key A key, can be falsy.\n     * @param {string[]} keys The path of keys.\n     * @param {number} depth The depth to\n     * @param {boolean} disableCache If the cache should be disabled\n     * @param {JsonLdContextNormalized} context A context to unalias with,\n     *                                           will fallback to retrieving the context for the given keys.\n     * @return {Promise<string>} A promise resolving to the key itself, or another key.\n     */\n    async unaliasKeyword(key, keys, depth, disableCache, context) {\n        // Numbers can not be an alias\n        if (Number.isInteger(key)) {\n            return key;\n        }\n        // Try to grab from cache if it was already un-aliased before.\n        if (!disableCache) {\n            const cachedUnaliasedKeyword = this.parsingContext.unaliasedKeywordCacheStack[depth];\n            if (cachedUnaliasedKeyword) {\n                return cachedUnaliasedKeyword;\n            }\n        }\n        if (!jsonld_context_parser_1.Util.isPotentialKeyword(key)) {\n            context = context || await this.parsingContext.getContext(keys);\n            let unliased = context.getContextRaw()[key];\n            if (unliased && typeof unliased === 'object') {\n                unliased = unliased['@id'];\n            }\n            if (jsonld_context_parser_1.Util.isValidKeyword(unliased)) {\n                key = unliased;\n            }\n        }\n        return disableCache ? key : (this.parsingContext.unaliasedKeywordCacheStack[depth] = key);\n    }\n    /**\n     * Unalias the keyword of the parent.\n     * This adds a safety check if no parent exist.\n     * @param {any[]} keys A stack of keys.\n     * @param {number} depth The current depth.\n     * @return {Promise<any>} A promise resolving to the parent key, or another key.\n     */\n    async unaliasKeywordParent(keys, depth) {\n        return await this.unaliasKeyword(depth > 0 && keys[depth - 1], keys, depth - 1);\n    }\n    /**\n     * Un-alias all keywords in the given hash.\n     * @param {{[p: string]: any}} hash A hash object.\n     * @param {string[]} keys The path of keys.\n     * @param {number} depth The depth.\n     * @param {JsonLdContextNormalized} context A context to unalias with,\n     *                                           will fallback to retrieving the context for the given keys.\n     * @return {Promise<{[p: string]: any}>} A promise resolving to the new hash.\n     */\n    async unaliasKeywords(hash, keys, depth, context) {\n        const newHash = {};\n        for (const key in hash) {\n            newHash[await this.unaliasKeyword(key, keys, depth + 1, true, context)] = hash[key];\n        }\n        return newHash;\n    }\n    /**\n     * Check if we are processing a literal (including JSON literals) at the given depth.\n     * This will also check higher levels,\n     * because if a parent is a literal,\n     * then the deeper levels are definitely a literal as well.\n     * @param {any[]} keys The keys.\n     * @param {number} depth The depth.\n     * @return {boolean} If we are processing a literal.\n     */\n    async isLiteral(keys, depth) {\n        for (let i = depth; i >= 0; i--) {\n            if (await this.unaliasKeyword(keys[i], keys, i) === '@annotation') {\n                // Literals may have annotations, which require processing of inner nodes.\n                return false;\n            }\n            if (this.parsingContext.literalStack[i] || this.parsingContext.jsonLiteralStack[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Check how many parents should be skipped for checking the @graph for the given node.\n     *\n     * @param {number} depth The depth of the node.\n     * @param {any[]} keys An array of keys.\n     * @return {number} The graph depth offset.\n     */\n    async getDepthOffsetGraph(depth, keys) {\n        for (let i = depth - 1; i > 0; i--) {\n            if (await this.unaliasKeyword(keys[i], keys, i) === '@graph') {\n                // Skip further processing if we are already in an @graph-@id or @graph-@index container\n                const containers = (await EntryHandlerContainer_1.EntryHandlerContainer.getContainerHandler(this.parsingContext, keys, i)).containers;\n                if (EntryHandlerContainer_1.EntryHandlerContainer.isComplexGraphContainer(containers)) {\n                    return -1;\n                }\n                return depth - i - 1;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Check if the given subject is of a valid type.\n     * This should be called when applying @reverse'd properties.\n     * @param {Term} subject A subject.\n     */\n    validateReverseSubject(subject) {\n        if (subject.termType === 'Literal') {\n            throw new jsonld_context_parser_1.ErrorCoded(`Found illegal literal in subject position: ${subject.value}`, jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_PROPERTY_VALUE);\n        }\n    }\n    /**\n     * Get the default graph.\n     * @return {Term} An RDF term.\n     */\n    getDefaultGraph() {\n        return this.parsingContext.defaultGraph || this.dataFactory.defaultGraph();\n    }\n    /**\n     * Get the current graph, while taking into account a graph that can be defined via @container: @graph.\n     * If not within a graph container, the default graph will be returned.\n     * @param keys The current keys.\n     * @param depth The current depth.\n     */\n    async getGraphContainerValue(keys, depth) {\n        // Default to default graph\n        let graph = this.getDefaultGraph();\n        // Check if we are in an @container: @graph.\n        const { containers, depth: depthContainer } = await EntryHandlerContainer_1.EntryHandlerContainer\n            .getContainerHandler(this.parsingContext, keys, depth);\n        if ('@graph' in containers) {\n            // Get the graph from the stack.\n            const graphContainerIndex = EntryHandlerContainer_1.EntryHandlerContainer.getContainerGraphIndex(containers, depthContainer, keys);\n            const entry = this.parsingContext.graphContainerTermStack[depthContainer];\n            graph = entry ? entry[graphContainerIndex] : null;\n            // Set the graph in the stack if none has been set yet.\n            if (!graph) {\n                let graphId = null;\n                if ('@id' in containers) {\n                    const keyUnaliased = await this.getContainerKey(keys[depthContainer], keys, depthContainer);\n                    if (keyUnaliased !== null) {\n                        graphId = await this.resourceToTerm(await this.parsingContext.getContext(keys), keyUnaliased);\n                    }\n                }\n                if (!graphId) {\n                    graphId = this.dataFactory.blankNode();\n                }\n                if (!this.parsingContext.graphContainerTermStack[depthContainer]) {\n                    this.parsingContext.graphContainerTermStack[depthContainer] = {};\n                }\n                graph = this.parsingContext.graphContainerTermStack[depthContainer][graphContainerIndex] = graphId;\n            }\n        }\n        return graph;\n    }\n    /**\n     * Get the properties depth for retrieving properties.\n     *\n     * Typically, the properties depth will be identical to the given depth.\n     *\n     * The following exceptions apply:\n     * * When the parent is @reverse, the depth is decremented by one.\n     * * When @nest parents are found, the depth is decremented by the number of @nest parents.\n     * If in combination with the exceptions above an intermediary array is discovered,\n     * the depth is also decremented by this number of arrays.\n     *\n     * @param keys The current key chain.\n     * @param depth The current depth.\n     */\n    async getPropertiesDepth(keys, depth) {\n        let lastValidDepth = depth;\n        for (let i = depth - 1; i > 0; i--) {\n            if (typeof keys[i] !== 'number') { // Skip array keys\n                const parentKey = await this.unaliasKeyword(keys[i], keys, i);\n                if (parentKey === '@reverse') {\n                    return i;\n                }\n                else if (parentKey === '@nest') {\n                    lastValidDepth = i;\n                }\n                else {\n                    return lastValidDepth;\n                }\n            }\n        }\n        return lastValidDepth;\n    }\n    /**\n     * Get the key for the current container entry.\n     * @param key A key, can be falsy.\n     * @param keys The key chain.\n     * @param depth The current depth to get the key from.\n     * @return Promise resolving to the key.\n     *         Null will be returned for @none entries, with aliasing taken into account.\n     */\n    async getContainerKey(key, keys, depth) {\n        const keyUnaliased = await this.unaliasKeyword(key, keys, depth);\n        return keyUnaliased === '@none' ? null : keyUnaliased;\n    }\n    /**\n     * Check if no reverse properties are present in embedded nodes.\n     * @param key The current key.\n     * @param reverse If a reverse property is active.\n     * @param isEmbedded If we're in an embedded node.\n     */\n    validateReverseInEmbeddedNode(key, reverse, isEmbedded) {\n        if (isEmbedded && reverse && !this.parsingContext.rdfstarReverseInEmbedded) {\n            throw new jsonld_context_parser_1.ErrorCoded(`Illegal reverse property in embedded node in ${key}`, jsonld_context_parser_1.ERROR_CODES.INVALID_EMBEDDED_NODE);\n        }\n    }\n    /**\n     * Emit a quad, with checks.\n     * @param depth The current depth.\n     * @param subject S\n     * @param predicate P\n     * @param object O\n     * @param graph G\n     * @param reverse If a reverse property is active.\n     * @param isEmbedded If we're in an embedded node.\n     */\n    emitQuadChecked(depth, subject, predicate, object, graph, reverse, isEmbedded) {\n        // Create a quad\n        let quad;\n        if (reverse) {\n            this.validateReverseSubject(object);\n            quad = this.dataFactory.quad(object, predicate, subject, graph);\n        }\n        else {\n            quad = this.dataFactory.quad(subject, predicate, object, graph);\n        }\n        // Emit the quad, unless it was created in an embedded node\n        if (isEmbedded) {\n            // Embedded nodes don't inherit the active graph\n            if (quad.graph.termType !== 'DefaultGraph') {\n                quad = this.dataFactory.quad(quad.subject, quad.predicate, quad.object);\n            }\n            // Multiple embedded nodes are not allowed\n            if (this.parsingContext.idStack[depth - 1]) {\n                throw new jsonld_context_parser_1.ErrorCoded(`Illegal multiple properties in an embedded node`, jsonld_context_parser_1.ERROR_CODES.INVALID_EMBEDDED_NODE);\n            }\n            this.parsingContext.idStack[depth - 1] = [quad];\n        }\n        else {\n            this.parsingContext.emitQuad(depth, quad);\n        }\n        // Flush annotations\n        const annotationsBuffer = this.parsingContext.annotationsBuffer[depth];\n        if (annotationsBuffer) {\n            for (const annotation of annotationsBuffer) {\n                this.emitAnnotation(depth, quad, annotation);\n            }\n            delete this.parsingContext.annotationsBuffer[depth];\n        }\n    }\n    // This is a separate function to enable recursion\n    emitAnnotation(depth, quad, annotation) {\n        // Construct annotation quad\n        let annotationQuad;\n        if (annotation.reverse) {\n            this.validateReverseSubject(annotation.object);\n            annotationQuad = this.dataFactory.quad(annotation.object, annotation.predicate, quad);\n        }\n        else {\n            annotationQuad = this.dataFactory.quad(quad, annotation.predicate, annotation.object);\n        }\n        // Emit annotated quad\n        this.parsingContext.emitQuad(depth, annotationQuad);\n        // Also emit nested annotations\n        for (const nestedAnnotation of annotation.nestedAnnotations) {\n            this.emitAnnotation(depth, annotationQuad, nestedAnnotation);\n        }\n    }\n}\nUtil.XSD = 'http://www.w3.org/2001/XMLSchema#';\nUtil.XSD_BOOLEAN = Util.XSD + 'boolean';\nUtil.XSD_INTEGER = Util.XSD + 'integer';\nUtil.XSD_DOUBLE = Util.XSD + 'double';\nUtil.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nexports.Util = Util;\n//# sourceMappingURL=Util.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerArrayValue = void 0;\nconst Util_1 = require(\"../Util\");\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\n/**\n * Handles values that are part of an array.\n */\nclass EntryHandlerArrayValue {\n    isPropertyHandler() {\n        return false;\n    }\n    isStackProcessor() {\n        return true;\n    }\n    async validate(parsingContext, util, keys, depth, inProperty) {\n        return this.test(parsingContext, util, null, keys, depth);\n    }\n    async test(parsingContext, util, key, keys, depth) {\n        return typeof keys[depth] === 'number';\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        let parentKey = await util.unaliasKeywordParent(keys, depth);\n        // Check if we have an anonymous list\n        if (parentKey === '@list') {\n            // Our value is part of an array\n            // Determine the list root key\n            let listRootKey = null;\n            let listRootDepth = 0;\n            for (let i = depth - 2; i > 0; i--) {\n                const keyOption = keys[i];\n                if (typeof keyOption === 'string' || typeof keyOption === 'number') {\n                    listRootDepth = i;\n                    listRootKey = keyOption;\n                    break;\n                }\n            }\n            if (listRootKey !== null) {\n                // Emit the given objects as list elements\n                const values = await util.valueToTerm(await parsingContext.getContext(keys), listRootKey, value, depth, keys);\n                for (const object of values) {\n                    await this.handleListElement(parsingContext, util, object, value, depth, keys.slice(0, listRootDepth), listRootDepth);\n                }\n                // If no values were found, emit a falsy list element to force an empty RDF list to be emitted.\n                if (values.length === 0) {\n                    await this.handleListElement(parsingContext, util, null, value, depth, keys.slice(0, listRootDepth), listRootDepth);\n                }\n            }\n        }\n        else if (parentKey === '@set') {\n            // Our value is part of a set, so we just add it to the parent-parent\n            await parsingContext.newOnValueJob(keys.slice(0, -2), value, depth - 2, false);\n        }\n        else if (parentKey !== undefined && parentKey !== '@type') {\n            // Buffer our value using the parent key as predicate\n            // Determine the first parent key that is *not* an array key\n            // This is needed in case we have an @list container with nested arrays,\n            // where each of them should produce nested RDF lists.\n            for (let i = depth - 1; i > 0; i--) {\n                if (typeof keys[i] !== 'number') {\n                    parentKey = await util.unaliasKeyword(keys[i], keys, i);\n                    break;\n                }\n            }\n            // Check if the predicate is marked as an @list in the context\n            const parentContext = await parsingContext.getContext(keys.slice(0, -1));\n            if ('@list' in Util_1.Util.getContextValueContainer(parentContext, parentKey)) {\n                // Our value is part of an array\n                // Emit the given objects as list elements\n                parsingContext.emittedStack[depth + 1] = true; // Ensure the creation of bnodes for empty nodes\n                const values = await util.valueToTerm(await parsingContext.getContext(keys), parentKey, value, depth, keys);\n                for (const object of values) {\n                    await this.handleListElement(parsingContext, util, object, value, depth, keys.slice(0, -1), depth - 1);\n                }\n                // If no values were found, emit a falsy list element to force an empty RDF list to be emitted.\n                if (values.length === 0) {\n                    await this.handleListElement(parsingContext, util, null, value, depth, keys.slice(0, -1), depth - 1);\n                }\n            }\n            else {\n                // Copy the stack values up one level so that the next job can access them.\n                parsingContext.shiftStack(depth, 1);\n                // Execute the job one level higher\n                await parsingContext.newOnValueJob(keys.slice(0, -1), value, depth - 1, false);\n                // Remove any defined contexts at this level to avoid it to propagate to the next array element.\n                parsingContext.contextTree.removeContext(keys.slice(0, -1));\n            }\n        }\n    }\n    async handleListElement(parsingContext, util, value, valueOriginal, depth, listRootKeys, listRootDepth) {\n        // Buffer our value as an RDF list using the listRootKey as predicate\n        let listPointer = parsingContext.listPointerStack[depth];\n        if (valueOriginal !== null && (await util.unaliasKeywords(valueOriginal, listRootKeys, depth))['@value'] !== null) {\n            if (!listPointer || !listPointer.value) {\n                const linkTerm = util.dataFactory.blankNode();\n                listPointer = { value: linkTerm, listRootDepth, listId: linkTerm };\n            }\n            else {\n                // rdf:rest links are always emitted before the next element,\n                // as the blank node identifier is only created at that point.\n                // Because of this reason, the final rdf:nil is emitted when the stack depth is decreased.\n                const newLinkTerm = util.dataFactory.blankNode();\n                parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer.value, util.rdfRest, newLinkTerm, util.getDefaultGraph()));\n                // Update the list pointer for the next element\n                listPointer.value = newLinkTerm;\n            }\n            // Emit a list element for the current value\n            // Omit rdf:first if the value is invalid\n            if (value) {\n                parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer.value, util.rdfFirst, value, util.getDefaultGraph()));\n            }\n        }\n        else {\n            // A falsy list element if found.\n            // Mark it as an rdf:nil list until another valid list element comes in\n            if (!listPointer) {\n                listPointer = { listRootDepth, listId: util.rdfNil };\n            }\n        }\n        parsingContext.listPointerStack[depth] = listPointer;\n        // Error if an annotation was defined\n        if (parsingContext.rdfstar && parsingContext.annotationsBuffer[depth]) {\n            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an illegal annotation inside a list`, jsonld_context_parser_1.ERROR_CODES.INVALID_ANNOTATION));\n        }\n    }\n}\nexports.EntryHandlerArrayValue = EntryHandlerArrayValue;\n//# sourceMappingURL=EntryHandlerArrayValue.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerInvalidFallback = void 0;\n/**\n * A catch-all for properties, that will either emit an error or ignore,\n * depending on whether or not the `strictValues` property is set.\n */\nclass EntryHandlerInvalidFallback {\n    isPropertyHandler() {\n        return false;\n    }\n    isStackProcessor() {\n        return true;\n    }\n    async validate(parsingContext, util, keys, depth, inProperty) {\n        return false;\n    }\n    async test(parsingContext, util, key, keys, depth) {\n        return true;\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        parsingContext.emittedStack[depth] = false;\n    }\n}\nexports.EntryHandlerInvalidFallback = EntryHandlerInvalidFallback;\n//# sourceMappingURL=EntryHandlerInvalidFallback.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeyword = void 0;\n/**\n * An abstract keyword entry handler.\n */\nclass EntryHandlerKeyword {\n    constructor(keyword) {\n        this.keyword = keyword;\n    }\n    isPropertyHandler() {\n        return false;\n    }\n    isStackProcessor() {\n        return true;\n    }\n    async validate(parsingContext, util, keys, depth, inProperty) {\n        return false;\n    }\n    async test(parsingContext, util, key, keys, depth) {\n        return key === this.keyword;\n    }\n}\nexports.EntryHandlerKeyword = EntryHandlerKeyword;\n//# sourceMappingURL=EntryHandlerKeyword.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeywordContext = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst EntryHandlerKeyword_1 = require(\"./EntryHandlerKeyword\");\n/**\n * Handles @context entries.\n */\nclass EntryHandlerKeywordContext extends EntryHandlerKeyword_1.EntryHandlerKeyword {\n    constructor() {\n        super('@context');\n    }\n    isStackProcessor() {\n        return false;\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        // Error if an out-of-order context was found when support is not enabled.\n        if (parsingContext.streamingProfile\n            && (parsingContext.processingStack[depth]\n                || parsingContext.processingType[depth]\n                || parsingContext.idStack[depth] !== undefined)) {\n            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded('Found an out-of-order context, while streaming is enabled.' +\n                '(disable `streamingProfile`)', jsonld_context_parser_1.ERROR_CODES.INVALID_STREAMING_KEY_ORDER));\n        }\n        // Find the parent context to inherit from.\n        // We actually request a context for the current depth (with fallback to parent)\n        // because we want to take into account any property-scoped contexts that are defined for this depth.\n        const parentContext = parsingContext.getContext(keys);\n        // Set the context for this scope\n        const context = parsingContext.parseContext(value, (await parentContext).getContextRaw());\n        parsingContext.contextTree.setContext(keys.slice(0, -1), context);\n        parsingContext.emitContext(value);\n        await parsingContext.validateContext(await context);\n    }\n}\nexports.EntryHandlerKeywordContext = EntryHandlerKeywordContext;\n//# sourceMappingURL=EntryHandlerKeywordContext.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeywordGraph = void 0;\nconst EntryHandlerKeyword_1 = require(\"./EntryHandlerKeyword\");\n/**\n * Handles @graph entries.\n */\nclass EntryHandlerKeywordGraph extends EntryHandlerKeyword_1.EntryHandlerKeyword {\n    constructor() {\n        super('@graph');\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        // The current identifier identifies a graph for the deeper level.\n        parsingContext.graphStack[depth + 1] = true;\n    }\n}\nexports.EntryHandlerKeywordGraph = EntryHandlerKeywordGraph;\n//# sourceMappingURL=EntryHandlerKeywordGraph.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeywordId = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst EntryHandlerKeyword_1 = require(\"./EntryHandlerKeyword\");\n/**\n * Handles @id entries.\n */\nclass EntryHandlerKeywordId extends EntryHandlerKeyword_1.EntryHandlerKeyword {\n    constructor() {\n        super('@id');\n    }\n    isStackProcessor() {\n        return false;\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        if (typeof value !== 'string') {\n            // JSON-LD-star allows @id object values\n            if (parsingContext.rdfstar && typeof value === 'object') {\n                const valueKeys = Object.keys(value);\n                if (valueKeys.length === 1 && valueKeys[0] === '@id') {\n                    parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Invalid embedded node without property with @id ${value['@id']}`, jsonld_context_parser_1.ERROR_CODES.INVALID_EMBEDDED_NODE));\n                }\n            }\n            else {\n                parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal @id '${value}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_ID_VALUE));\n            }\n            return;\n        }\n        // Determine the canonical place for this id.\n        // For example, @nest parents should be ignored.\n        const depthProperties = await util.getPropertiesDepth(keys, depth);\n        // Error if an @id for this node already existed.\n        if (parsingContext.idStack[depthProperties] !== undefined) {\n            if (parsingContext.idStack[depthProperties][0].listHead) {\n                // Error if an @list was already defined for this node\n                parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal neighbouring entries next to @list for key: '${keys[depth - 1]}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT));\n            }\n            else {\n                // Otherwise, the previous id was just because of an @id entry.\n                parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found duplicate @ids '${parsingContext\n                    .idStack[depthProperties][0].value}' and '${value}'`, jsonld_context_parser_1.ERROR_CODES.COLLIDING_KEYWORDS));\n            }\n        }\n        // Error if an annotation was defined\n        if (parsingContext.rdfstar && parsingContext.annotationsBuffer[depth]) {\n            for (const annotation of parsingContext.annotationsBuffer[depth]) {\n                if (annotation.depth === depth) {\n                    parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an illegal @id inside an annotation: ${value}`, jsonld_context_parser_1.ERROR_CODES.INVALID_ANNOTATION));\n                }\n            }\n        }\n        // Save our @id on the stack\n        parsingContext.idStack[depthProperties] = util.nullableTermToArray(await util.resourceToTerm(await parsingContext.getContext(keys), value));\n    }\n}\nexports.EntryHandlerKeywordId = EntryHandlerKeywordId;\n//# sourceMappingURL=EntryHandlerKeywordId.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeywordIncluded = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst EntryHandlerKeyword_1 = require(\"./EntryHandlerKeyword\");\n/**\n * Handles @included entries.\n */\nclass EntryHandlerKeywordIncluded extends EntryHandlerKeyword_1.EntryHandlerKeyword {\n    constructor() {\n        super('@included');\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        if (typeof value !== 'object') {\n            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal @included '${value}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_INCLUDED_VALUE));\n        }\n        const valueUnliased = await util.unaliasKeywords(value, keys, depth, await parsingContext.getContext(keys));\n        if ('@value' in valueUnliased) {\n            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an illegal @included @value node '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_INCLUDED_VALUE));\n        }\n        if ('@list' in valueUnliased) {\n            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an illegal @included @list node '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_INCLUDED_VALUE));\n        }\n        parsingContext.emittedStack[depth] = false;\n    }\n}\nexports.EntryHandlerKeywordIncluded = EntryHandlerKeywordIncluded;\n//# sourceMappingURL=EntryHandlerKeywordIncluded.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeywordNest = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst EntryHandlerKeyword_1 = require(\"./EntryHandlerKeyword\");\n/**\n * Handles @nest entries.\n */\nclass EntryHandlerKeywordNest extends EntryHandlerKeyword_1.EntryHandlerKeyword {\n    constructor() {\n        super('@nest');\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        if (typeof value !== 'object') {\n            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found invalid @nest entry for '${key}': '${value}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_NEST_VALUE));\n        }\n        if ('@value' in await util.unaliasKeywords(value, keys, depth, await parsingContext.getContext(keys))) {\n            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found an invalid @value node for '${key}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_NEST_VALUE));\n        }\n        parsingContext.emittedStack[depth] = false;\n    }\n}\nexports.EntryHandlerKeywordNest = EntryHandlerKeywordNest;\n//# sourceMappingURL=EntryHandlerKeywordNest.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeywordType = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst Util_1 = require(\"../../Util\");\nconst EntryHandlerPredicate_1 = require(\"../EntryHandlerPredicate\");\nconst EntryHandlerKeyword_1 = require(\"./EntryHandlerKeyword\");\n/**\n * Handles @graph entries.\n */\nclass EntryHandlerKeywordType extends EntryHandlerKeyword_1.EntryHandlerKeyword {\n    constructor() {\n        super('@type');\n    }\n    isStackProcessor() {\n        return false;\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        const keyOriginal = keys[depth];\n        // The current identifier identifies an rdf:type predicate.\n        // But we only emit it once the node closes,\n        // as it's possible that the @type is used to identify the datatype of a literal, which we ignore here.\n        const context = await parsingContext.getContext(keys);\n        const predicate = util.rdfType;\n        const parentKey = await util.unaliasKeywordParent(keys, depth);\n        const reverse = Util_1.Util.isPropertyReverse(context, keyOriginal, parentKey);\n        const isEmbedded = Util_1.Util.isPropertyInEmbeddedNode(parentKey);\n        util.validateReverseInEmbeddedNode(key, reverse, isEmbedded);\n        const isAnnotation = Util_1.Util.isPropertyInAnnotationObject(parentKey);\n        // Handle multiple values if the value is an array\n        const elements = Array.isArray(value) ? value : [value];\n        for (const element of elements) {\n            if (typeof element !== 'string') {\n                parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal @type '${element}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPE_VALUE));\n            }\n            const type = util.createVocabOrBaseTerm(context, element);\n            if (type) {\n                await EntryHandlerPredicate_1.EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth, predicate, type, reverse, isEmbedded, isAnnotation);\n            }\n        }\n        // Collect type-scoped contexts if they exist\n        let scopedContext = Promise.resolve(context);\n        let hasTypedScopedContext = false;\n        for (const element of elements.sort()) { // Spec requires lexicographical ordering\n            const typeContext = Util_1.Util.getContextValue(context, '@context', element, null);\n            if (typeContext) {\n                hasTypedScopedContext = true;\n                scopedContext = scopedContext.then((c) => parsingContext.parseContext(typeContext, c.getContextRaw()));\n            }\n        }\n        // Error if an out-of-order type-scoped context was found when support is not enabled.\n        if (parsingContext.streamingProfile\n            && (hasTypedScopedContext || !parsingContext.streamingProfileAllowOutOfOrderPlainType)\n            && (parsingContext.processingStack[depth] || parsingContext.idStack[depth])) {\n            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded('Found an out-of-order type-scoped context, while streaming is enabled.' +\n                '(disable `streamingProfile`)', jsonld_context_parser_1.ERROR_CODES.INVALID_STREAMING_KEY_ORDER));\n        }\n        // If at least least one type-scoped context applies, set them in the tree.\n        if (hasTypedScopedContext) {\n            // Do not propagate by default\n            scopedContext = scopedContext.then((c) => {\n                // Set the original context at this depth as a fallback\n                // This is needed when a context was already defined at the given depth,\n                // and this context needs to remain accessible from child nodes when propagation is disabled.\n                if (c.getContextRaw()['@propagate'] !== true) {\n                    return new jsonld_context_parser_1.JsonLdContextNormalized(Object.assign(Object.assign({}, c.getContextRaw()), { '@propagate': false, '@__propagateFallback': context.getContextRaw() }));\n                }\n                return c;\n            });\n            // Set the new context in the context tree\n            parsingContext.contextTree.setContext(keys.slice(0, keys.length - 1), scopedContext);\n        }\n        // Flag that type has been processed at this depth\n        parsingContext.processingType[depth] = true;\n    }\n}\nexports.EntryHandlerKeywordType = EntryHandlerKeywordType;\n//# sourceMappingURL=EntryHandlerKeywordType.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeywordUnknownFallback = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\n/**\n * A catch-all for keywords, that will either emit an error or ignore,\n * depending on whether or not the `strictValues` property is set.\n */\nclass EntryHandlerKeywordUnknownFallback {\n    isPropertyHandler() {\n        return false;\n    }\n    isStackProcessor() {\n        return true;\n    }\n    async validate(parsingContext, util, keys, depth, inProperty) {\n        const key = await util.unaliasKeyword(keys[depth], keys, depth);\n        if (jsonld_context_parser_1.Util.isPotentialKeyword(key)) {\n            // Don't emit anything inside free-floating lists\n            if (!inProperty) {\n                if (key === '@list') {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    async test(parsingContext, util, key, keys, depth) {\n        return jsonld_context_parser_1.Util.isPotentialKeyword(key);\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        const keywordType = EntryHandlerKeywordUnknownFallback.VALID_KEYWORDS_TYPES[key];\n        if (keywordType !== undefined) {\n            if (keywordType && typeof value !== keywordType.type) {\n                parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Invalid value type for '${key}' with value '${value}'`, keywordType.errorCode));\n            }\n        }\n        else if (parsingContext.strictValues) {\n            parsingContext.emitError(new Error(`Unknown keyword '${key}' with value '${value}'`));\n        }\n        parsingContext.emittedStack[depth] = false;\n    }\n}\nEntryHandlerKeywordUnknownFallback.VALID_KEYWORDS_TYPES = {\n    '@index': { type: 'string', errorCode: jsonld_context_parser_1.ERROR_CODES.INVALID_INDEX_VALUE },\n    '@list': null,\n    '@reverse': { type: 'object', errorCode: jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_VALUE },\n    '@set': null,\n    '@value': null,\n};\nexports.EntryHandlerKeywordUnknownFallback = EntryHandlerKeywordUnknownFallback;\n//# sourceMappingURL=EntryHandlerKeywordUnknownFallback.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeywordValue = void 0;\nconst EntryHandlerKeyword_1 = require(\"./EntryHandlerKeyword\");\n/**\n * Handles @value entries.\n */\nclass EntryHandlerKeywordValue extends EntryHandlerKeyword_1.EntryHandlerKeyword {\n    constructor() {\n        super('@value');\n    }\n    async validate(parsingContext, util, keys, depth, inProperty) {\n        // If this is @value, mark it so in the stack so that no deeper handling of nodes occurs.\n        const key = keys[depth];\n        if (key && !parsingContext.literalStack[depth] && await this.test(parsingContext, util, key, keys, depth)) {\n            parsingContext.literalStack[depth] = true;\n        }\n        return super.validate(parsingContext, util, keys, depth, inProperty);\n    }\n    async test(parsingContext, util, key, keys, depth) {\n        return await util.unaliasKeyword(keys[depth], keys.slice(0, keys.length - 1), depth - 1, true) === '@value';\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        // If the value is valid, indicate that we are processing a literal.\n        // The actual value will be determined at the parent level when the @value is part of an object,\n        // because we may want to take into account additional entries such as @language.\n        // See {@link Util.valueToTerm}\n        // Indicate that we are processing a literal, and that no later predicates should be parsed at this depth.\n        parsingContext.literalStack[depth] = true;\n        // Void any buffers that we may have accumulated up until now\n        delete parsingContext.unidentifiedValuesBuffer[depth];\n        delete parsingContext.unidentifiedGraphsBuffer[depth];\n        // Indicate that we have not emitted at this depth\n        parsingContext.emittedStack[depth] = false;\n    }\n}\nexports.EntryHandlerKeywordValue = EntryHandlerKeywordValue;\n//# sourceMappingURL=EntryHandlerKeywordValue.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContextTree = void 0;\n/**\n * A tree structure that holds all contexts,\n * based on their position in the JSON object.\n *\n * Positions are identified by a path of keys.\n */\nclass ContextTree {\n    constructor() {\n        this.subTrees = {};\n    }\n    getContext(keys) {\n        if (keys.length > 0) {\n            const [head, ...tail] = keys;\n            const subTree = this.subTrees[head];\n            if (subTree) {\n                const subContext = subTree.getContext(tail);\n                if (subContext) {\n                    return subContext.then(({ context, depth }) => ({ context, depth: depth + 1 }));\n                }\n            }\n        }\n        return this.context ? this.context.then((context) => ({ context, depth: 0 })) : null;\n    }\n    setContext(keys, context) {\n        if (keys.length === 0) {\n            this.context = context;\n        }\n        else {\n            const [head, ...tail] = keys;\n            let subTree = this.subTrees[head];\n            if (!subTree) {\n                subTree = this.subTrees[head] = new ContextTree();\n            }\n            subTree.setContext(tail, context);\n        }\n    }\n    removeContext(path) {\n        this.setContext(path, null);\n    }\n}\nexports.ContextTree = ContextTree;\n//# sourceMappingURL=ContextTree.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParsingContext = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst ErrorCoded_1 = require(\"jsonld-context-parser/lib/ErrorCoded\");\nconst ContextTree_1 = require(\"./ContextTree\");\nconst JsonLdParser_1 = require(\"./JsonLdParser\");\n/**\n * Data holder for parsing information.\n */\nclass ParsingContext {\n    constructor(options) {\n        // Initialize settings\n        this.contextParser = new jsonld_context_parser_1.ContextParser({ documentLoader: options.documentLoader, skipValidation: options.skipContextValidation });\n        this.streamingProfile = !!options.streamingProfile;\n        this.baseIRI = options.baseIRI;\n        this.produceGeneralizedRdf = !!options.produceGeneralizedRdf;\n        this.allowSubjectList = !!options.allowSubjectList;\n        this.processingMode = options.processingMode || JsonLdParser_1.JsonLdParser.DEFAULT_PROCESSING_MODE;\n        this.strictValues = !!options.strictValues;\n        this.validateValueIndexes = !!options.validateValueIndexes;\n        this.defaultGraph = options.defaultGraph;\n        this.rdfDirection = options.rdfDirection;\n        this.normalizeLanguageTags = options.normalizeLanguageTags;\n        this.streamingProfileAllowOutOfOrderPlainType = options.streamingProfileAllowOutOfOrderPlainType;\n        this.rdfstar = options.rdfstar !== false;\n        this.rdfstarReverseInEmbedded = options.rdfstarReverseInEmbedded;\n        this.topLevelProperties = false;\n        this.activeProcessingMode = parseFloat(this.processingMode);\n        // Initialize stacks\n        this.processingStack = [];\n        this.processingType = [];\n        this.emittedStack = [];\n        this.idStack = [];\n        this.graphStack = [];\n        this.graphContainerTermStack = [];\n        this.listPointerStack = [];\n        this.contextTree = new ContextTree_1.ContextTree();\n        this.literalStack = [];\n        this.validationStack = [];\n        this.unaliasedKeywordCacheStack = [];\n        this.jsonLiteralStack = [];\n        this.unidentifiedValuesBuffer = [];\n        this.unidentifiedGraphsBuffer = [];\n        this.annotationsBuffer = [];\n        this.pendingContainerFlushBuffers = [];\n        this.parser = options.parser;\n        if (options.context) {\n            this.rootContext = this.parseContext(options.context);\n            this.rootContext.then((context) => this.validateContext(context));\n        }\n        else {\n            this.rootContext = Promise.resolve(new jsonld_context_parser_1.JsonLdContextNormalized(this.baseIRI ? { '@base': this.baseIRI, '@__baseDocument': true } : {}));\n        }\n    }\n    /**\n     * Parse the given context with the configured options.\n     * @param {JsonLdContext} context A context to parse.\n     * @param {JsonLdContextNormalized} parentContext An optional parent context.\n     * @param {boolean} ignoreProtection If @protected term checks should be ignored.\n     * @return {Promise<JsonLdContextNormalized>} A promise resolving to the parsed context.\n     */\n    async parseContext(context, parentContext, ignoreProtection) {\n        return this.contextParser.parse(context, {\n            baseIRI: this.baseIRI,\n            ignoreProtection,\n            normalizeLanguageTags: this.normalizeLanguageTags,\n            parentContext,\n            processingMode: this.activeProcessingMode,\n        });\n    }\n    /**\n     * Check if the given context is valid.\n     * If not, an error will be thrown.\n     * @param {JsonLdContextNormalized} context A context.\n     */\n    validateContext(context) {\n        const activeVersion = context.getContextRaw()['@version'];\n        if (activeVersion) {\n            if (this.activeProcessingMode && activeVersion > this.activeProcessingMode) {\n                throw new ErrorCoded_1.ErrorCoded(`Unsupported JSON-LD version '${activeVersion}' under active processing mode ${this.activeProcessingMode}.`, ErrorCoded_1.ERROR_CODES.PROCESSING_MODE_CONFLICT);\n            }\n            else {\n                if (this.activeProcessingMode && activeVersion < this.activeProcessingMode) {\n                    throw new ErrorCoded_1.ErrorCoded(`Invalid JSON-LD version ${activeVersion} under active processing mode ${this.activeProcessingMode}.`, ErrorCoded_1.ERROR_CODES.INVALID_VERSION_VALUE);\n                }\n                this.activeProcessingMode = activeVersion;\n            }\n        }\n    }\n    /**\n     * Get the context at the given path.\n     * @param {keys} keys The path of keys to get the context at.\n     * @param {number} offset The path offset, defaults to 1.\n     * @return {Promise<JsonLdContextNormalized>} A promise resolving to a context.\n     */\n    async getContext(keys, offset = 1) {\n        const keysOriginal = keys;\n        // Ignore array keys at the end\n        while (typeof keys[keys.length - 1] === 'number') {\n            keys = keys.slice(0, keys.length - 1);\n        }\n        // Handle offset on keys\n        if (offset) {\n            keys = keys.slice(0, -offset);\n        }\n        // Determine the closest context\n        const contextData = await this.getContextPropagationAware(keys);\n        const context = contextData.context;\n        // Process property-scoped contexts (high-to-low)\n        let contextRaw = context.getContextRaw();\n        for (let i = contextData.depth; i < keysOriginal.length - offset; i++) {\n            const key = keysOriginal[i];\n            const contextKeyEntry = contextRaw[key];\n            if (contextKeyEntry && typeof contextKeyEntry === 'object' && '@context' in contextKeyEntry) {\n                const scopedContext = (await this.parseContext(contextKeyEntry, contextRaw, true)).getContextRaw();\n                const propagate = !(key in scopedContext)\n                    || scopedContext[key]['@context']['@propagate']; // Propagation is true by default\n                if (propagate !== false || i === keysOriginal.length - 1 - offset) {\n                    contextRaw = Object.assign({}, scopedContext);\n                    // Clean up final context\n                    delete contextRaw['@propagate'];\n                    contextRaw[key] = Object.assign({}, contextRaw[key]);\n                    if ('@id' in contextKeyEntry) {\n                        contextRaw[key]['@id'] = contextKeyEntry['@id'];\n                    }\n                    delete contextRaw[key]['@context'];\n                    if (propagate !== false) {\n                        this.contextTree.setContext(keysOriginal.slice(0, i + offset), Promise.resolve(new jsonld_context_parser_1.JsonLdContextNormalized(contextRaw)));\n                    }\n                }\n            }\n        }\n        return new jsonld_context_parser_1.JsonLdContextNormalized(contextRaw);\n    }\n    /**\n     * Get the context at the given path.\n     * Non-propagating contexts will be skipped,\n     * unless the context at that exact depth is retrieved.\n     *\n     * This ONLY takes into account context propagation logic,\n     * so this should usually not be called directly,\n     * call {@link #getContext} instead.\n     *\n     * @param keys The path of keys to get the context at.\n     * @return {Promise<{ context: JsonLdContextNormalized, depth: number }>} A context and its depth.\n     */\n    async getContextPropagationAware(keys) {\n        const originalDepth = keys.length;\n        let contextData = null;\n        let hasApplicablePropertyScopedContext;\n        do {\n            hasApplicablePropertyScopedContext = false;\n            if (contextData && '@__propagateFallback' in contextData.context.getContextRaw()) {\n                // If a propagation fallback context has been set,\n                // fallback to that context and retry for the same depth.\n                contextData.context = new jsonld_context_parser_1.JsonLdContextNormalized(contextData.context.getContextRaw()['@__propagateFallback']);\n            }\n            else {\n                if (contextData) {\n                    // If we had a previous iteration, jump to the parent of context depth.\n                    // We must do this because once we get here, last context had propagation disabled,\n                    // so we check its first parent instead.\n                    keys = keys.slice(0, contextData.depth - 1);\n                }\n                contextData = await this.contextTree.getContext(keys) || { context: await this.rootContext, depth: 0 };\n            }\n            // Allow non-propagating contexts to propagate one level deeper\n            // if it defines a property-scoped context that is applicable for the current key.\n            // @see https://w3c.github.io/json-ld-api/tests/toRdf-manifest#tc012\n            const lastKey = keys[keys.length - 1];\n            if (lastKey in contextData.context.getContextRaw()) {\n                const lastKeyValue = contextData.context.getContextRaw()[lastKey];\n                if (lastKeyValue && typeof lastKeyValue === 'object' && '@context' in lastKeyValue) {\n                    hasApplicablePropertyScopedContext = true;\n                }\n            }\n        } while (contextData.depth > 0 // Root context has a special case\n            && contextData.context.getContextRaw()['@propagate'] === false // Stop loop if propagation is true\n            && contextData.depth !== originalDepth // Stop loop if requesting exact depth of non-propagating\n            && !hasApplicablePropertyScopedContext);\n        // Special case for root context that does not allow propagation.\n        // Fallback to empty context in that case.\n        if (contextData.depth === 0\n            && contextData.context.getContextRaw()['@propagate'] === false\n            && contextData.depth !== originalDepth) {\n            contextData.context = new jsonld_context_parser_1.JsonLdContextNormalized({});\n        }\n        return contextData;\n    }\n    /**\n     * Start a new job for parsing the given value.\n     * @param {any[]} keys The stack of keys.\n     * @param value The value to parse.\n     * @param {number} depth The depth to parse at.\n     * @param {boolean} lastDepthCheck If the lastDepth check should be done for buffer draining.\n     * @return {Promise<void>} A promise resolving when the job is done.\n     */\n    async newOnValueJob(keys, value, depth, lastDepthCheck) {\n        await this.parser.newOnValueJob(keys, value, depth, lastDepthCheck);\n    }\n    /**\n     * Flush the pending container flush buffers\n     * @return {boolean} If any pending buffers were flushed.\n     */\n    async handlePendingContainerFlushBuffers() {\n        if (this.pendingContainerFlushBuffers.length > 0) {\n            for (const pendingFlushBuffer of this.pendingContainerFlushBuffers) {\n                await this.parser.flushBuffer(pendingFlushBuffer.depth, pendingFlushBuffer.keys);\n                this.parser.flushStacks(pendingFlushBuffer.depth);\n            }\n            this.pendingContainerFlushBuffers.splice(0, this.pendingContainerFlushBuffers.length);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Emit the given quad into the output stream.\n     * @param {number} depth The depth the quad was generated at.\n     * @param {Quad} quad A quad to emit.\n     */\n    emitQuad(depth, quad) {\n        if (depth === 1) {\n            this.topLevelProperties = true;\n        }\n        this.parser.push(quad);\n    }\n    /**\n     * Emit the given error into the output stream.\n     * @param {Error} error An error to emit.\n     */\n    emitError(error) {\n        this.parser.emit('error', error);\n    }\n    /**\n     * Emit the given context into the output stream under the 'context' event.\n     * @param {JsonLdContext} context A context to emit.\n     */\n    emitContext(context) {\n        this.parser.emit('context', context);\n    }\n    /**\n     * Safely get or create the depth value of {@link ParsingContext.unidentifiedValuesBuffer}.\n     * @param {number} depth A depth.\n     * @return {{predicate: Term; object: Term; reverse: boolean}[]} An element of\n     *                                                               {@link ParsingContext.unidentifiedValuesBuffer}.\n     */\n    getUnidentifiedValueBufferSafe(depth) {\n        let buffer = this.unidentifiedValuesBuffer[depth];\n        if (!buffer) {\n            buffer = [];\n            this.unidentifiedValuesBuffer[depth] = buffer;\n        }\n        return buffer;\n    }\n    /**\n     * Safely get or create the depth value of {@link ParsingContext.unidentifiedGraphsBuffer}.\n     * @param {number} depth A depth.\n     * @return {{predicate: Term; object: Term; reverse: boolean}[]} An element of\n     *                                                               {@link ParsingContext.unidentifiedGraphsBuffer}.\n     */\n    getUnidentifiedGraphBufferSafe(depth) {\n        let buffer = this.unidentifiedGraphsBuffer[depth];\n        if (!buffer) {\n            buffer = [];\n            this.unidentifiedGraphsBuffer[depth] = buffer;\n        }\n        return buffer;\n    }\n    /**\n     * Safely get or create the depth value of {@link ParsingContext.annotationsBuffer}.\n     * @param {number} depth A depth.\n     * @return {} An element of {@link ParsingContext.annotationsBuffer}.\n     */\n    getAnnotationsBufferSafe(depth) {\n        let buffer = this.annotationsBuffer[depth];\n        if (!buffer) {\n            buffer = [];\n            this.annotationsBuffer[depth] = buffer;\n        }\n        return buffer;\n    }\n    /**\n     * @return IExpandOptions The expand options for the active processing mode.\n     */\n    getExpandOptions() {\n        return ParsingContext.EXPAND_OPTIONS[this.activeProcessingMode];\n    }\n    /**\n     * Shift the stack at the given offset to the given depth.\n     *\n     * This will override anything in the stack at `depth`,\n     * and this will remove anything at `depth + depthOffset`\n     *\n     * @param depth The target depth.\n     * @param depthOffset The origin depth, relative to `depth`.\n     */\n    shiftStack(depth, depthOffset) {\n        // Copy the id stack value up one level so that the next job can access the id.\n        const deeperIdStack = this.idStack[depth + depthOffset];\n        if (deeperIdStack) {\n            this.idStack[depth] = deeperIdStack;\n            this.emittedStack[depth] = true;\n            delete this.idStack[depth + depthOffset];\n        }\n        // Shorten key stack\n        if (this.pendingContainerFlushBuffers.length) {\n            for (const buffer of this.pendingContainerFlushBuffers) {\n                if (buffer.depth >= depth + depthOffset) {\n                    buffer.depth -= depthOffset;\n                    buffer.keys.splice(depth, depthOffset);\n                }\n            }\n        }\n        // Splice stacks\n        if (this.unidentifiedValuesBuffer[depth + depthOffset]) {\n            this.unidentifiedValuesBuffer[depth] = this.unidentifiedValuesBuffer[depth + depthOffset];\n            delete this.unidentifiedValuesBuffer[depth + depthOffset];\n        }\n        if (this.annotationsBuffer[depth + depthOffset - 1]) {\n            if (!this.annotationsBuffer[depth - 1]) {\n                this.annotationsBuffer[depth - 1] = [];\n            }\n            this.annotationsBuffer[depth - 1] = [\n                ...this.annotationsBuffer[depth - 1],\n                ...this.annotationsBuffer[depth + depthOffset - 1],\n            ];\n            delete this.annotationsBuffer[depth + depthOffset - 1];\n        }\n        // TODO: also do the same for other stacks\n    }\n}\nParsingContext.EXPAND_OPTIONS = {\n    1.0: {\n        allowPrefixForcing: false,\n        allowPrefixNonGenDelims: false,\n        allowVocabRelativeToBase: false,\n    },\n    1.1: {\n        allowPrefixForcing: true,\n        allowPrefixNonGenDelims: false,\n        allowVocabRelativeToBase: true,\n    },\n};\nexports.ParsingContext = ParsingContext;\n//# sourceMappingURL=ParsingContext.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeywordAnnotation = void 0;\nconst EntryHandlerKeyword_1 = require(\"./EntryHandlerKeyword\");\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\n/**\n * Handles @annotation entries.\n */\nclass EntryHandlerKeywordAnnotation extends EntryHandlerKeyword_1.EntryHandlerKeyword {\n    constructor() {\n        super('@annotation');\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        // Validate value\n        if (typeof value === 'string' || (typeof value === 'object' && value['@value'])) {\n            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal annotation value: ${JSON.stringify(value)}`, jsonld_context_parser_1.ERROR_CODES.INVALID_ANNOTATION));\n        }\n        // Rest of the processing is done as regular nodes\n    }\n}\nexports.EntryHandlerKeywordAnnotation = EntryHandlerKeywordAnnotation;\n//# sourceMappingURL=EntryHandlerKeywordAnnotation.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JsonLdParser = void 0;\n// tslint:disable-next-line:no-var-requires\nconst Parser = require('@bergos/jsonparse');\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst readable_stream_1 = require(\"readable-stream\");\nconst EntryHandlerArrayValue_1 = require(\"./entryhandler/EntryHandlerArrayValue\");\nconst EntryHandlerContainer_1 = require(\"./entryhandler/EntryHandlerContainer\");\nconst EntryHandlerInvalidFallback_1 = require(\"./entryhandler/EntryHandlerInvalidFallback\");\nconst EntryHandlerPredicate_1 = require(\"./entryhandler/EntryHandlerPredicate\");\nconst EntryHandlerKeywordContext_1 = require(\"./entryhandler/keyword/EntryHandlerKeywordContext\");\nconst EntryHandlerKeywordGraph_1 = require(\"./entryhandler/keyword/EntryHandlerKeywordGraph\");\nconst EntryHandlerKeywordId_1 = require(\"./entryhandler/keyword/EntryHandlerKeywordId\");\nconst EntryHandlerKeywordIncluded_1 = require(\"./entryhandler/keyword/EntryHandlerKeywordIncluded\");\nconst EntryHandlerKeywordNest_1 = require(\"./entryhandler/keyword/EntryHandlerKeywordNest\");\nconst EntryHandlerKeywordType_1 = require(\"./entryhandler/keyword/EntryHandlerKeywordType\");\nconst EntryHandlerKeywordUnknownFallback_1 = require(\"./entryhandler/keyword/EntryHandlerKeywordUnknownFallback\");\nconst EntryHandlerKeywordValue_1 = require(\"./entryhandler/keyword/EntryHandlerKeywordValue\");\nconst ParsingContext_1 = require(\"./ParsingContext\");\nconst Util_1 = require(\"./Util\");\nconst http_link_header_1 = require(\"http-link-header\");\nconst EntryHandlerKeywordAnnotation_1 = require(\"./entryhandler/keyword/EntryHandlerKeywordAnnotation\");\n/**\n * A stream transformer that parses JSON-LD (text) streams to an {@link RDF.Stream}.\n */\nclass JsonLdParser extends readable_stream_1.Transform {\n    constructor(options) {\n        super({ readableObjectMode: true });\n        options = options || {};\n        this.options = options;\n        this.parsingContext = new ParsingContext_1.ParsingContext(Object.assign({ parser: this }, options));\n        this.util = new Util_1.Util({ dataFactory: options.dataFactory, parsingContext: this.parsingContext });\n        this.jsonParser = new Parser();\n        this.contextJobs = [];\n        this.typeJobs = [];\n        this.contextAwaitingJobs = [];\n        this.lastDepth = 0;\n        this.lastKeys = [];\n        this.lastOnValueJob = Promise.resolve();\n        this.attachJsonParserListeners();\n        this.on('end', () => {\n            if (typeof this.jsonParser.mode !== 'undefined') {\n                this.emit('error', new Error('Unclosed document'));\n            }\n        });\n    }\n    /**\n     * Construct a JsonLdParser from the given HTTP response.\n     *\n     * This will throw an error if no valid JSON response is received\n     * (application/ld+json, application/json, or something+json).\n     *\n     * For raw JSON responses, exactly one link header pointing to a JSON-LD context is required.\n     *\n     * This method is not responsible for handling redirects.\n     *\n     * @param baseIRI The URI of the received response.\n     * @param mediaType The received content type.\n     * @param headers Optional HTTP headers.\n     * @param options Optional parser options.\n     */\n    static fromHttpResponse(baseIRI, mediaType, headers, options) {\n        let context;\n        let wellKnownMediaTypes = ['application/activity+json'];\n        if (options && options.wellKnownMediaTypes) {\n            wellKnownMediaTypes = options.wellKnownMediaTypes;\n        }\n        // Special cases when receiving something else than the JSON-LD media type or the wellKnownMediaTypes\n        if (mediaType !== 'application/ld+json' && !wellKnownMediaTypes.includes(mediaType)) {\n            // Only accept JSON or JSON extension types\n            if (mediaType !== 'application/json' && !mediaType.endsWith('+json')) {\n                throw new jsonld_context_parser_1.ErrorCoded(`Unsupported JSON-LD media type ${mediaType}`, jsonld_context_parser_1.ERROR_CODES.LOADING_DOCUMENT_FAILED);\n            }\n            // We need exactly one JSON-LD context in the link header\n            if (headers && headers.has('Link')) {\n                headers.forEach((value, key) => {\n                    if (key === 'link') {\n                        const linkHeader = (0, http_link_header_1.parse)(value);\n                        for (const link of linkHeader.get('rel', 'http://www.w3.org/ns/json-ld#context')) {\n                            if (context) {\n                                throw new jsonld_context_parser_1.ErrorCoded('Multiple JSON-LD context link headers were found on ' + baseIRI, jsonld_context_parser_1.ERROR_CODES.MULTIPLE_CONTEXT_LINK_HEADERS);\n                            }\n                            context = link.uri;\n                        }\n                    }\n                });\n            }\n            if (!context && !(options === null || options === void 0 ? void 0 : options.ignoreMissingContextLinkHeader)) {\n                throw new jsonld_context_parser_1.ErrorCoded(`Missing context link header for media type ${mediaType} on ${baseIRI}`, jsonld_context_parser_1.ERROR_CODES.LOADING_DOCUMENT_FAILED);\n            }\n        }\n        // Check if the streaming profile is present\n        let streamingProfile;\n        if (headers && headers.has('Content-Type')) {\n            const contentType = headers.get('Content-Type');\n            const match = /; *profile=([^\"]*)/.exec(contentType);\n            if (match && match[1] === 'http://www.w3.org/ns/json-ld#streaming') {\n                streamingProfile = true;\n            }\n        }\n        return new JsonLdParser(Object.assign({ baseIRI,\n            context,\n            streamingProfile }, options ? options : {}));\n    }\n    /**\n     * Parses the given text stream into a quad stream.\n     * @param {NodeJS.EventEmitter} stream A text stream.\n     * @return {RDF.Stream} A quad stream.\n     */\n    import(stream) {\n        if ('pipe' in stream) {\n            stream.on('error', (error) => parsed.emit('error', error));\n            const parsed = stream.pipe(new JsonLdParser(this.options));\n            return parsed;\n        }\n        else {\n            const output = new readable_stream_1.PassThrough({ readableObjectMode: true });\n            stream.on('error', (error) => parsed.emit('error', error));\n            stream.on('data', (data) => output.push(data));\n            stream.on('end', () => output.push(null));\n            const parsed = output.pipe(new JsonLdParser(this.options));\n            return parsed;\n        }\n    }\n    _transform(chunk, encoding, callback) {\n        this.jsonParser.write(chunk);\n        this.lastOnValueJob\n            .then(() => callback(), (error) => callback(error));\n    }\n    /**\n     * Start a new job for parsing the given value.\n     *\n     * This will let the first valid {@link IEntryHandler} handle the entry.\n     *\n     * @param {any[]} keys The stack of keys.\n     * @param value The value to parse.\n     * @param {number} depth The depth to parse at.\n     * @param {boolean} lastDepthCheck If the lastDepth check should be done for buffer draining.\n     * @return {Promise<void>} A promise resolving when the job is done.\n     */\n    async newOnValueJob(keys, value, depth, lastDepthCheck) {\n        let flushStacks = true;\n        // When we go up the stack, emit all unidentified values\n        // We need to do this before the new job, because the new job may require determined values from the flushed jobs.\n        if (lastDepthCheck && depth < this.lastDepth) {\n            // Check if we had any RDF lists that need to be terminated with an rdf:nil\n            const listPointer = this.parsingContext.listPointerStack[this.lastDepth];\n            if (listPointer) {\n                // Terminate the list if the had at least one value\n                if (listPointer.value) {\n                    this.push(this.util.dataFactory.quad(listPointer.value, this.util.rdfRest, this.util.rdfNil, this.util.getDefaultGraph()));\n                }\n                // Add the list id to the id stack, so it can be used higher up in the stack\n                listPointer.listId.listHead = true;\n                this.parsingContext.idStack[listPointer.listRootDepth + 1] = [listPointer.listId];\n                this.parsingContext.listPointerStack.splice(this.lastDepth, 1);\n            }\n            // Flush the buffer for lastDepth\n            // If the parent key is a special type of container, postpone flushing until that parent is handled.\n            if (await EntryHandlerContainer_1.EntryHandlerContainer.isBufferableContainerHandler(this.parsingContext, this.lastKeys, this.lastDepth)) {\n                this.parsingContext.pendingContainerFlushBuffers\n                    .push({ depth: this.lastDepth, keys: this.lastKeys.slice(0, this.lastKeys.length) });\n                flushStacks = false;\n            }\n            else {\n                await this.flushBuffer(this.lastDepth, this.lastKeys);\n            }\n        }\n        const key = await this.util.unaliasKeyword(keys[depth], keys, depth);\n        const parentKey = await this.util.unaliasKeywordParent(keys, depth);\n        this.parsingContext.emittedStack[depth] = true;\n        let handleKey = true;\n        // Keywords inside @reverse is not allowed apart from @context\n        if (jsonld_context_parser_1.Util.isValidKeyword(key) && parentKey === '@reverse' && key !== '@context') {\n            this.emit('error', new jsonld_context_parser_1.ErrorCoded(`Found the @id '${value}' inside an @reverse property`, jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_PROPERTY_MAP));\n        }\n        // Skip further processing if one of the parent nodes are invalid.\n        // We use the validationStack to reuse validation results that were produced before with common key stacks.\n        let inProperty = false;\n        if (this.parsingContext.validationStack.length > 1) {\n            inProperty = this.parsingContext.validationStack[this.parsingContext.validationStack.length - 1].property;\n        }\n        for (let i = Math.max(1, this.parsingContext.validationStack.length - 1); i < keys.length - 1; i++) {\n            const validationResult = this.parsingContext.validationStack[i]\n                || (this.parsingContext.validationStack[i] = await this.validateKey(keys.slice(0, i + 1), i, inProperty));\n            if (!validationResult.valid) {\n                this.parsingContext.emittedStack[depth] = false;\n                handleKey = false;\n                break;\n            }\n            else if (!inProperty && validationResult.property) {\n                inProperty = true;\n            }\n        }\n        // Skip further processing if this node is part of a literal\n        if (await this.util.isLiteral(keys, depth)) {\n            handleKey = false;\n        }\n        // Get handler\n        if (handleKey) {\n            for (const entryHandler of JsonLdParser.ENTRY_HANDLERS) {\n                const testResult = await entryHandler.test(this.parsingContext, this.util, key, keys, depth);\n                if (testResult) {\n                    // Pass processing over to the handler\n                    await entryHandler.handle(this.parsingContext, this.util, key, keys, value, depth, testResult);\n                    // Flag that this depth is processed\n                    if (entryHandler.isStackProcessor()) {\n                        this.parsingContext.processingStack[depth] = true;\n                    }\n                    break;\n                }\n            }\n        }\n        // Validate value indexes on the root.\n        if (depth === 0 && Array.isArray(value)) {\n            await this.util.validateValueIndexes(value);\n        }\n        // When we go up the stack, flush the old stack\n        if (flushStacks && depth < this.lastDepth) {\n            // Reset our stacks\n            this.flushStacks(this.lastDepth);\n        }\n        this.lastDepth = depth;\n        this.lastKeys = keys;\n        // Clear the keyword cache at this depth, and everything underneath.\n        this.parsingContext.unaliasedKeywordCacheStack.splice(depth - 1);\n    }\n    /**\n     * Flush the processing stacks at the given depth.\n     * @param {number} depth A depth.\n     */\n    flushStacks(depth) {\n        this.parsingContext.processingStack.splice(depth, 1);\n        this.parsingContext.processingType.splice(depth, 1);\n        this.parsingContext.emittedStack.splice(depth, 1);\n        this.parsingContext.idStack.splice(depth, 1);\n        this.parsingContext.graphStack.splice(depth + 1, 1);\n        this.parsingContext.graphContainerTermStack.splice(depth, 1);\n        this.parsingContext.jsonLiteralStack.splice(depth, 1);\n        this.parsingContext.validationStack.splice(depth - 1, 2);\n        this.parsingContext.literalStack.splice(depth, this.parsingContext.literalStack.length - depth);\n        this.parsingContext.annotationsBuffer.splice(depth, 1);\n        // TODO: just like the literal stack, splice all other stack until the end as well?\n    }\n    /**\n     * Flush buffers for the given depth.\n     *\n     * This should be called after the last entry at a given depth was processed.\n     *\n     * @param {number} depth A depth.\n     * @param {any[]} keys A stack of keys.\n     * @return {Promise<void>} A promise resolving if flushing is done.\n     */\n    async flushBuffer(depth, keys) {\n        let subjects = this.parsingContext.idStack[depth];\n        const subjectsWasDefined = !!subjects;\n        if (!subjectsWasDefined) {\n            subjects = this.parsingContext.idStack[depth] = [this.util.dataFactory.blankNode()];\n        }\n        // Flush values at this level\n        const valueBuffer = this.parsingContext.unidentifiedValuesBuffer[depth];\n        if (valueBuffer) {\n            for (const subject of subjects) {\n                const depthOffsetGraph = await this.util.getDepthOffsetGraph(depth, keys);\n                const graphs = (this.parsingContext.graphStack[depth] || depthOffsetGraph >= 0)\n                    ? this.parsingContext.idStack[depth - depthOffsetGraph - 1]\n                    : [await this.util.getGraphContainerValue(keys, depth)];\n                if (graphs) {\n                    for (const graph of graphs) {\n                        // Flush values to stream if the graph @id is known\n                        this.parsingContext.emittedStack[depth] = true;\n                        for (const bufferedValue of valueBuffer) {\n                            this.util.emitQuadChecked(depth, subject, bufferedValue.predicate, bufferedValue.object, graph, bufferedValue.reverse, bufferedValue.isEmbedded);\n                        }\n                    }\n                }\n                else {\n                    // Place the values in the graphs buffer if the graph @id is not yet known\n                    const subGraphBuffer = this.parsingContext.getUnidentifiedGraphBufferSafe(depth - await this.util.getDepthOffsetGraph(depth, keys) - 1);\n                    for (const bufferedValue of valueBuffer) {\n                        if (bufferedValue.reverse) {\n                            subGraphBuffer.push({\n                                object: subject,\n                                predicate: bufferedValue.predicate,\n                                subject: bufferedValue.object,\n                                isEmbedded: bufferedValue.isEmbedded,\n                            });\n                        }\n                        else {\n                            subGraphBuffer.push({\n                                object: bufferedValue.object,\n                                predicate: bufferedValue.predicate,\n                                subject,\n                                isEmbedded: bufferedValue.isEmbedded,\n                            });\n                        }\n                    }\n                }\n            }\n            this.parsingContext.unidentifiedValuesBuffer.splice(depth, 1);\n            this.parsingContext.literalStack.splice(depth, 1);\n            this.parsingContext.jsonLiteralStack.splice(depth, 1);\n        }\n        // Flush graphs at this level\n        const graphBuffer = this.parsingContext.unidentifiedGraphsBuffer[depth];\n        if (graphBuffer) {\n            for (const subject of subjects) {\n                // A @graph statement at the root without @id relates to the default graph,\n                // unless there are top-level properties,\n                // others relate to blank nodes.\n                const graph = depth === 1 && subject.termType === 'BlankNode'\n                    && !this.parsingContext.topLevelProperties ? this.util.getDefaultGraph() : subject;\n                this.parsingContext.emittedStack[depth] = true;\n                for (const bufferedValue of graphBuffer) {\n                    this.parsingContext.emitQuad(depth, this.util.dataFactory.quad(bufferedValue.subject, bufferedValue.predicate, bufferedValue.object, graph));\n                }\n            }\n            this.parsingContext.unidentifiedGraphsBuffer.splice(depth, 1);\n        }\n        // Push unhandled annotations up the stack as nested annotations\n        const annotationsBuffer = this.parsingContext.annotationsBuffer[depth];\n        if (annotationsBuffer) {\n            // Throw an error if we reach the top, and still have annotations\n            if (annotationsBuffer.length > 0 && depth === 1) {\n                this.parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Annotations can not be made on top-level nodes`, jsonld_context_parser_1.ERROR_CODES.INVALID_ANNOTATION));\n            }\n            // Pass the annotations buffer up one level in the stack\n            const annotationsBufferParent = this.parsingContext.getAnnotationsBufferSafe(depth - 1);\n            for (const annotation of annotationsBuffer) {\n                annotationsBufferParent.push(annotation);\n            }\n            delete this.parsingContext.annotationsBuffer[depth];\n        }\n    }\n    /**\n     * Check if at least one {@link IEntryHandler} validates the entry to true.\n     * @param {any[]} keys A stack of keys.\n     * @param {number} depth A depth.\n     * @param {boolean} inProperty If the current depth is part of a valid property node.\n     * @return {Promise<{ valid: boolean, property: boolean }>} A promise resolving to true or false.\n     */\n    async validateKey(keys, depth, inProperty) {\n        for (const entryHandler of JsonLdParser.ENTRY_HANDLERS) {\n            if (await entryHandler.validate(this.parsingContext, this.util, keys, depth, inProperty)) {\n                return { valid: true, property: inProperty || entryHandler.isPropertyHandler() };\n            }\n        }\n        return { valid: false, property: false };\n    }\n    /**\n     * Attach all required listeners to the JSON parser.\n     *\n     * This should only be called once.\n     */\n    attachJsonParserListeners() {\n        // Listen to json parser events\n        this.jsonParser.onValue = (value) => {\n            const depth = this.jsonParser.stack.length;\n            const keys = (new Array(depth + 1).fill(0)).map((v, i) => {\n                return i === depth ? this.jsonParser.key : this.jsonParser.stack[i].key;\n            });\n            if (!this.isParsingContextInner(depth)) { // Don't parse inner nodes inside @context\n                const valueJobCb = () => this.newOnValueJob(keys, value, depth, true);\n                if (!this.parsingContext.streamingProfile\n                    && !this.parsingContext.contextTree.getContext(keys.slice(0, -1))) {\n                    // If an out-of-order context is allowed,\n                    // we have to buffer everything.\n                    // We store jobs for @context's and @type's separately,\n                    // because at the end, we have to process them first.\n                    // We also handle @type because these *could* introduce a type-scoped context.\n                    if (keys[depth] === '@context') {\n                        let jobs = this.contextJobs[depth];\n                        if (!jobs) {\n                            jobs = this.contextJobs[depth] = [];\n                        }\n                        jobs.push(valueJobCb);\n                    }\n                    else {\n                        this.contextAwaitingJobs.push({ job: valueJobCb, keys, depth });\n                    }\n                }\n                else {\n                    // Make sure that our value jobs are chained synchronously\n                    this.lastOnValueJob = this.lastOnValueJob.then(valueJobCb);\n                }\n                // Execute all buffered jobs on deeper levels\n                if (!this.parsingContext.streamingProfile && depth === 0) {\n                    this.lastOnValueJob = this.lastOnValueJob\n                        .then(() => this.executeBufferedJobs());\n                }\n            }\n        };\n        this.jsonParser.onError = (error) => {\n            this.emit('error', error);\n        };\n    }\n    /**\n     * Check if the parser is currently parsing an element that is part of an @context entry.\n     * @param {number} depth A depth.\n     * @return {boolean} A boolean.\n     */\n    isParsingContextInner(depth) {\n        for (let i = depth; i > 0; i--) {\n            if (this.jsonParser.stack[i - 1].key === '@context') {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Execute all buffered jobs.\n     * @return {Promise<void>} A promise resolving if all jobs are finished.\n     */\n    async executeBufferedJobs() {\n        // Handle context jobs\n        for (const jobs of this.contextJobs) {\n            if (jobs) {\n                for (const job of jobs) {\n                    await job();\n                }\n            }\n        }\n        // Clear the keyword cache.\n        this.parsingContext.unaliasedKeywordCacheStack.splice(0);\n        const contextAwaitingJobs = [];\n        for (const job of this.contextAwaitingJobs) {\n            if ((await this.util.unaliasKeyword(job.keys[job.depth], job.keys, job.depth, true)) === '@type'\n                || typeof job.keys[job.depth] === 'number' && (await this.util.unaliasKeyword(job.keys[job.depth - 1], job.keys, job.depth - 1, true)) === '@type') { // Also capture @type with array values\n                // Remove @type from keys, because we want it to apply to parent later on\n                this.typeJobs.push({ job: job.job, keys: job.keys.slice(0, job.keys.length - 1) });\n            }\n            else {\n                contextAwaitingJobs.push(job);\n            }\n        }\n        // Handle non-context jobs\n        for (const job of contextAwaitingJobs) {\n            // Check if we have a type (with possible type-scoped context) that should be handled before.\n            // We check all possible parent nodes for the current job, from root to leaves.\n            if (this.typeJobs.length > 0) {\n                // First collect all applicable type jobs\n                const applicableTypeJobs = [];\n                const applicableTypeJobIds = [];\n                for (let i = 0; i < this.typeJobs.length; i++) {\n                    const typeJob = this.typeJobs[i];\n                    if (Util_1.Util.isPrefixArray(typeJob.keys, job.keys)) {\n                        applicableTypeJobs.push(typeJob);\n                        applicableTypeJobIds.push(i);\n                    }\n                }\n                // Next, sort the jobs from short to long key length (to ensure types higher up in the tree to be handled first)\n                const sortedTypeJobs = applicableTypeJobs.sort((job1, job2) => job1.keys.length - job2.keys.length);\n                // Finally, execute the jobs in order\n                for (const typeJob of sortedTypeJobs) {\n                    await typeJob.job();\n                }\n                // Remove the executed type jobs\n                // Sort first, so we can efficiently splice\n                const sortedApplicableTypeJobIds = applicableTypeJobIds.sort().reverse();\n                for (const jobId of sortedApplicableTypeJobIds) {\n                    this.typeJobs.splice(jobId, 1);\n                }\n            }\n            await job.job();\n        }\n    }\n}\nJsonLdParser.DEFAULT_PROCESSING_MODE = '1.1';\nJsonLdParser.ENTRY_HANDLERS = [\n    new EntryHandlerArrayValue_1.EntryHandlerArrayValue(),\n    new EntryHandlerKeywordContext_1.EntryHandlerKeywordContext(),\n    new EntryHandlerKeywordId_1.EntryHandlerKeywordId(),\n    new EntryHandlerKeywordIncluded_1.EntryHandlerKeywordIncluded(),\n    new EntryHandlerKeywordGraph_1.EntryHandlerKeywordGraph(),\n    new EntryHandlerKeywordNest_1.EntryHandlerKeywordNest(),\n    new EntryHandlerKeywordType_1.EntryHandlerKeywordType(),\n    new EntryHandlerKeywordValue_1.EntryHandlerKeywordValue(),\n    new EntryHandlerKeywordAnnotation_1.EntryHandlerKeywordAnnotation(),\n    new EntryHandlerContainer_1.EntryHandlerContainer(),\n    new EntryHandlerKeywordUnknownFallback_1.EntryHandlerKeywordUnknownFallback(),\n    new EntryHandlerPredicate_1.EntryHandlerPredicate(),\n    new EntryHandlerInvalidFallback_1.EntryHandlerInvalidFallback(),\n];\nexports.JsonLdParser = JsonLdParser;\n//# sourceMappingURL=JsonLdParser.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/JsonLdParser\"), exports);\n//# sourceMappingURL=index.js.map","'use strict'\n\n/*\n  This file is a reduced and adapted version of the main lib/internal/per_context/primordials.js file defined at\n\n  https://github.com/nodejs/node/blob/master/lib/internal/per_context/primordials.js\n\n  Don't try to replace with the original file and keep it up to date with the upstream file.\n*/\nmodule.exports = {\n  ArrayIsArray(self) {\n    return Array.isArray(self)\n  },\n  ArrayPrototypeIncludes(self, el) {\n    return self.includes(el)\n  },\n  ArrayPrototypeIndexOf(self, el) {\n    return self.indexOf(el)\n  },\n  ArrayPrototypeJoin(self, sep) {\n    return self.join(sep)\n  },\n  ArrayPrototypeMap(self, fn) {\n    return self.map(fn)\n  },\n  ArrayPrototypePop(self, el) {\n    return self.pop(el)\n  },\n  ArrayPrototypePush(self, el) {\n    return self.push(el)\n  },\n  ArrayPrototypeSlice(self, start, end) {\n    return self.slice(start, end)\n  },\n  Error,\n  FunctionPrototypeCall(fn, thisArgs, ...args) {\n    return fn.call(thisArgs, ...args)\n  },\n  FunctionPrototypeSymbolHasInstance(self, instance) {\n    return Function.prototype[Symbol.hasInstance].call(self, instance)\n  },\n  MathFloor: Math.floor,\n  Number,\n  NumberIsInteger: Number.isInteger,\n  NumberIsNaN: Number.isNaN,\n  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,\n  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,\n  NumberParseInt: Number.parseInt,\n  ObjectDefineProperties(self, props) {\n    return Object.defineProperties(self, props)\n  },\n  ObjectDefineProperty(self, name, prop) {\n    return Object.defineProperty(self, name, prop)\n  },\n  ObjectGetOwnPropertyDescriptor(self, name) {\n    return Object.getOwnPropertyDescriptor(self, name)\n  },\n  ObjectKeys(obj) {\n    return Object.keys(obj)\n  },\n  ObjectSetPrototypeOf(target, proto) {\n    return Object.setPrototypeOf(target, proto)\n  },\n  Promise,\n  PromisePrototypeCatch(self, fn) {\n    return self.catch(fn)\n  },\n  PromisePrototypeThen(self, thenFn, catchFn) {\n    return self.then(thenFn, catchFn)\n  },\n  PromiseReject(err) {\n    return Promise.reject(err)\n  },\n  PromiseResolve(val) {\n    return Promise.resolve(val)\n  },\n  ReflectApply: Reflect.apply,\n  RegExpPrototypeTest(self, value) {\n    return self.test(value)\n  },\n  SafeSet: Set,\n  String,\n  StringPrototypeSlice(self, start, end) {\n    return self.slice(start, end)\n  },\n  StringPrototypeToLowerCase(self) {\n    return self.toLowerCase()\n  },\n  StringPrototypeToUpperCase(self) {\n    return self.toUpperCase()\n  },\n  StringPrototypeTrim(self) {\n    return self.trim()\n  },\n  Symbol,\n  SymbolFor: Symbol.for,\n  SymbolAsyncIterator: Symbol.asyncIterator,\n  SymbolHasInstance: Symbol.hasInstance,\n  SymbolIterator: Symbol.iterator,\n  SymbolDispose: Symbol.dispose || Symbol('Symbol.dispose'),\n  SymbolAsyncDispose: Symbol.asyncDispose || Symbol('Symbol.asyncDispose'),\n  TypedArrayPrototypeSet(self, buf, len) {\n    return self.set(buf, len)\n  },\n  Boolean: Boolean,\n  Uint8Array\n}\n","'use strict'\n\nconst bufferModule = require('buffer')\nconst { kResistStopPropagation, SymbolDispose } = require('./primordials')\nconst AbortSignal = globalThis.AbortSignal || require('abort-controller').AbortSignal\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nconst AsyncFunction = Object.getPrototypeOf(async function () {}).constructor\nconst Blob = globalThis.Blob || bufferModule.Blob\n/* eslint-disable indent */\nconst isBlob =\n  typeof Blob !== 'undefined'\n    ? function isBlob(b) {\n        // eslint-disable-next-line indent\n        return b instanceof Blob\n      }\n    : function isBlob(b) {\n        return false\n      }\n/* eslint-enable indent */\n\nconst validateAbortSignal = (signal, name) => {\n  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)\n  }\n}\nconst validateFunction = (value, name) => {\n  if (typeof value !== 'function') throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)\n}\n\n// This is a simplified version of AggregateError\nclass AggregateError extends Error {\n  constructor(errors) {\n    if (!Array.isArray(errors)) {\n      throw new TypeError(`Expected input to be an Array, got ${typeof errors}`)\n    }\n    let message = ''\n    for (let i = 0; i < errors.length; i++) {\n      message += `    ${errors[i].stack}\\n`\n    }\n    super(message)\n    this.name = 'AggregateError'\n    this.errors = errors\n  }\n}\nmodule.exports = {\n  AggregateError,\n  kEmptyObject: Object.freeze({}),\n  once(callback) {\n    let called = false\n    return function (...args) {\n      if (called) {\n        return\n      }\n      called = true\n      callback.apply(this, args)\n    }\n  },\n  createDeferredPromise: function () {\n    let resolve\n    let reject\n\n    // eslint-disable-next-line promise/param-names\n    const promise = new Promise((res, rej) => {\n      resolve = res\n      reject = rej\n    })\n    return {\n      promise,\n      resolve,\n      reject\n    }\n  },\n  promisify(fn) {\n    return new Promise((resolve, reject) => {\n      fn((err, ...args) => {\n        if (err) {\n          return reject(err)\n        }\n        return resolve(...args)\n      })\n    })\n  },\n  debuglog() {\n    return function () {}\n  },\n  format(format, ...args) {\n    // Simplified version of https://nodejs.org/api/util.html#utilformatformat-args\n    return format.replace(/%([sdifj])/g, function (...[_unused, type]) {\n      const replacement = args.shift()\n      if (type === 'f') {\n        return replacement.toFixed(6)\n      } else if (type === 'j') {\n        return JSON.stringify(replacement)\n      } else if (type === 's' && typeof replacement === 'object') {\n        const ctor = replacement.constructor !== Object ? replacement.constructor.name : ''\n        return `${ctor} {}`.trim()\n      } else {\n        return replacement.toString()\n      }\n    })\n  },\n  inspect(value) {\n    // Vastly simplified version of https://nodejs.org/api/util.html#utilinspectobject-options\n    switch (typeof value) {\n      case 'string':\n        if (value.includes(\"'\")) {\n          if (!value.includes('\"')) {\n            return `\"${value}\"`\n          } else if (!value.includes('`') && !value.includes('${')) {\n            return `\\`${value}\\``\n          }\n        }\n        return `'${value}'`\n      case 'number':\n        if (isNaN(value)) {\n          return 'NaN'\n        } else if (Object.is(value, -0)) {\n          return String(value)\n        }\n        return value\n      case 'bigint':\n        return `${String(value)}n`\n      case 'boolean':\n      case 'undefined':\n        return String(value)\n      case 'object':\n        return '{}'\n    }\n  },\n  types: {\n    isAsyncFunction(fn) {\n      return fn instanceof AsyncFunction\n    },\n    isArrayBufferView(arr) {\n      return ArrayBuffer.isView(arr)\n    }\n  },\n  isBlob,\n  deprecate(fn, message) {\n    return fn\n  },\n  addAbortListener:\n    require('events').addAbortListener ||\n    function addAbortListener(signal, listener) {\n      if (signal === undefined) {\n        throw new ERR_INVALID_ARG_TYPE('signal', 'AbortSignal', signal)\n      }\n      validateAbortSignal(signal, 'signal')\n      validateFunction(listener, 'listener')\n      let removeEventListener\n      if (signal.aborted) {\n        queueMicrotask(() => listener())\n      } else {\n        signal.addEventListener('abort', listener, {\n          __proto__: null,\n          once: true,\n          [kResistStopPropagation]: true\n        })\n        removeEventListener = () => {\n          signal.removeEventListener('abort', listener)\n        }\n      }\n      return {\n        __proto__: null,\n        [SymbolDispose]() {\n          var _removeEventListener\n          ;(_removeEventListener = removeEventListener) === null || _removeEventListener === undefined\n            ? undefined\n            : _removeEventListener()\n        }\n      }\n    },\n  AbortSignalAny:\n    AbortSignal.any ||\n    function AbortSignalAny(signals) {\n      // Fast path if there is only one signal.\n      if (signals.length === 1) {\n        return signals[0]\n      }\n      const ac = new AbortController()\n      const abort = () => ac.abort()\n      signals.forEach((signal) => {\n        validateAbortSignal(signal, 'signals')\n        signal.addEventListener('abort', abort, {\n          once: true\n        })\n      })\n      ac.signal.addEventListener(\n        'abort',\n        () => {\n          signals.forEach((signal) => signal.removeEventListener('abort', abort))\n        },\n        {\n          once: true\n        }\n      )\n      return ac.signal\n    }\n}\nmodule.exports.promisify.custom = Symbol.for('nodejs.util.promisify.custom')\n","'use strict'\n\nconst { format, inspect, AggregateError: CustomAggregateError } = require('./util')\n\n/*\n  This file is a reduced and adapted version of the main lib/internal/errors.js file defined at\n\n  https://github.com/nodejs/node/blob/master/lib/internal/errors.js\n\n  Don't try to replace with the original file and keep it up to date (starting from E(...) definitions)\n  with the upstream file.\n*/\n\nconst AggregateError = globalThis.AggregateError || CustomAggregateError\nconst kIsNodeError = Symbol('kIsNodeError')\nconst kTypes = [\n  'string',\n  'function',\n  'number',\n  'object',\n  // Accept 'Function' and 'Object' as alternative to the lower cased version.\n  'Function',\n  'Object',\n  'boolean',\n  'bigint',\n  'symbol'\n]\nconst classRegExp = /^([A-Z][a-z0-9]*)+$/\nconst nodeInternalPrefix = '__node_internal_'\nconst codes = {}\nfunction assert(value, message) {\n  if (!value) {\n    throw new codes.ERR_INTERNAL_ASSERTION(message)\n  }\n}\n\n// Only use this for integers! Decimal numbers do not work with this function.\nfunction addNumericalSeparator(val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\nfunction getMessage(key, msg, args) {\n  if (typeof msg === 'function') {\n    assert(\n      msg.length <= args.length,\n      // Default options do not count.\n      `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`\n    )\n    return msg(...args)\n  }\n  const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length\n  assert(\n    expectedLength === args.length,\n    `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`\n  )\n  if (args.length === 0) {\n    return msg\n  }\n  return format(msg, ...args)\n}\nfunction E(code, message, Base) {\n  if (!Base) {\n    Base = Error\n  }\n  class NodeError extends Base {\n    constructor(...args) {\n      super(getMessage(code, message, args))\n    }\n    toString() {\n      return `${this.name} [${code}]: ${this.message}`\n    }\n  }\n  Object.defineProperties(NodeError.prototype, {\n    name: {\n      value: Base.name,\n      writable: true,\n      enumerable: false,\n      configurable: true\n    },\n    toString: {\n      value() {\n        return `${this.name} [${code}]: ${this.message}`\n      },\n      writable: true,\n      enumerable: false,\n      configurable: true\n    }\n  })\n  NodeError.prototype.code = code\n  NodeError.prototype[kIsNodeError] = true\n  codes[code] = NodeError\n}\nfunction hideStackFrames(fn) {\n  // We rename the functions that will be hidden to cut off the stacktrace\n  // at the outermost one\n  const hidden = nodeInternalPrefix + fn.name\n  Object.defineProperty(fn, 'name', {\n    value: hidden\n  })\n  return fn\n}\nfunction aggregateTwoErrors(innerError, outerError) {\n  if (innerError && outerError && innerError !== outerError) {\n    if (Array.isArray(outerError.errors)) {\n      // If `outerError` is already an `AggregateError`.\n      outerError.errors.push(innerError)\n      return outerError\n    }\n    const err = new AggregateError([outerError, innerError], outerError.message)\n    err.code = outerError.code\n    return err\n  }\n  return innerError || outerError\n}\nclass AbortError extends Error {\n  constructor(message = 'The operation was aborted', options = undefined) {\n    if (options !== undefined && typeof options !== 'object') {\n      throw new codes.ERR_INVALID_ARG_TYPE('options', 'Object', options)\n    }\n    super(message, options)\n    this.code = 'ABORT_ERR'\n    this.name = 'AbortError'\n  }\n}\nE('ERR_ASSERTION', '%s', Error)\nE(\n  'ERR_INVALID_ARG_TYPE',\n  (name, expected, actual) => {\n    assert(typeof name === 'string', \"'name' must be a string\")\n    if (!Array.isArray(expected)) {\n      expected = [expected]\n    }\n    let msg = 'The '\n    if (name.endsWith(' argument')) {\n      // For cases like 'first argument'\n      msg += `${name} `\n    } else {\n      msg += `\"${name}\" ${name.includes('.') ? 'property' : 'argument'} `\n    }\n    msg += 'must be '\n    const types = []\n    const instances = []\n    const other = []\n    for (const value of expected) {\n      assert(typeof value === 'string', 'All expected entries have to be of type string')\n      if (kTypes.includes(value)) {\n        types.push(value.toLowerCase())\n      } else if (classRegExp.test(value)) {\n        instances.push(value)\n      } else {\n        assert(value !== 'object', 'The value \"object\" should be written as \"Object\"')\n        other.push(value)\n      }\n    }\n\n    // Special handle `object` in case other instances are allowed to outline\n    // the differences between each other.\n    if (instances.length > 0) {\n      const pos = types.indexOf('object')\n      if (pos !== -1) {\n        types.splice(types, pos, 1)\n        instances.push('Object')\n      }\n    }\n    if (types.length > 0) {\n      switch (types.length) {\n        case 1:\n          msg += `of type ${types[0]}`\n          break\n        case 2:\n          msg += `one of type ${types[0]} or ${types[1]}`\n          break\n        default: {\n          const last = types.pop()\n          msg += `one of type ${types.join(', ')}, or ${last}`\n        }\n      }\n      if (instances.length > 0 || other.length > 0) {\n        msg += ' or '\n      }\n    }\n    if (instances.length > 0) {\n      switch (instances.length) {\n        case 1:\n          msg += `an instance of ${instances[0]}`\n          break\n        case 2:\n          msg += `an instance of ${instances[0]} or ${instances[1]}`\n          break\n        default: {\n          const last = instances.pop()\n          msg += `an instance of ${instances.join(', ')}, or ${last}`\n        }\n      }\n      if (other.length > 0) {\n        msg += ' or '\n      }\n    }\n    switch (other.length) {\n      case 0:\n        break\n      case 1:\n        if (other[0].toLowerCase() !== other[0]) {\n          msg += 'an '\n        }\n        msg += `${other[0]}`\n        break\n      case 2:\n        msg += `one of ${other[0]} or ${other[1]}`\n        break\n      default: {\n        const last = other.pop()\n        msg += `one of ${other.join(', ')}, or ${last}`\n      }\n    }\n    if (actual == null) {\n      msg += `. Received ${actual}`\n    } else if (typeof actual === 'function' && actual.name) {\n      msg += `. Received function ${actual.name}`\n    } else if (typeof actual === 'object') {\n      var _actual$constructor\n      if (\n        (_actual$constructor = actual.constructor) !== null &&\n        _actual$constructor !== undefined &&\n        _actual$constructor.name\n      ) {\n        msg += `. Received an instance of ${actual.constructor.name}`\n      } else {\n        const inspected = inspect(actual, {\n          depth: -1\n        })\n        msg += `. Received ${inspected}`\n      }\n    } else {\n      let inspected = inspect(actual, {\n        colors: false\n      })\n      if (inspected.length > 25) {\n        inspected = `${inspected.slice(0, 25)}...`\n      }\n      msg += `. Received type ${typeof actual} (${inspected})`\n    }\n    return msg\n  },\n  TypeError\n)\nE(\n  'ERR_INVALID_ARG_VALUE',\n  (name, value, reason = 'is invalid') => {\n    let inspected = inspect(value)\n    if (inspected.length > 128) {\n      inspected = inspected.slice(0, 128) + '...'\n    }\n    const type = name.includes('.') ? 'property' : 'argument'\n    return `The ${type} '${name}' ${reason}. Received ${inspected}`\n  },\n  TypeError\n)\nE(\n  'ERR_INVALID_RETURN_VALUE',\n  (input, name, value) => {\n    var _value$constructor\n    const type =\n      value !== null &&\n      value !== undefined &&\n      (_value$constructor = value.constructor) !== null &&\n      _value$constructor !== undefined &&\n      _value$constructor.name\n        ? `instance of ${value.constructor.name}`\n        : `type ${typeof value}`\n    return `Expected ${input} to be returned from the \"${name}\"` + ` function but got ${type}.`\n  },\n  TypeError\n)\nE(\n  'ERR_MISSING_ARGS',\n  (...args) => {\n    assert(args.length > 0, 'At least one arg needs to be specified')\n    let msg\n    const len = args.length\n    args = (Array.isArray(args) ? args : [args]).map((a) => `\"${a}\"`).join(' or ')\n    switch (len) {\n      case 1:\n        msg += `The ${args[0]} argument`\n        break\n      case 2:\n        msg += `The ${args[0]} and ${args[1]} arguments`\n        break\n      default:\n        {\n          const last = args.pop()\n          msg += `The ${args.join(', ')}, and ${last} arguments`\n        }\n        break\n    }\n    return `${msg} must be specified`\n  },\n  TypeError\n)\nE(\n  'ERR_OUT_OF_RANGE',\n  (str, range, input) => {\n    assert(range, 'Missing \"range\" argument')\n    let received\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > 2n ** 32n || input < -(2n ** 32n)) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    } else {\n      received = inspect(input)\n    }\n    return `The value of \"${str}\" is out of range. It must be ${range}. Received ${received}`\n  },\n  RangeError\n)\nE('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times', Error)\nE('ERR_METHOD_NOT_IMPLEMENTED', 'The %s method is not implemented', Error)\nE('ERR_STREAM_ALREADY_FINISHED', 'Cannot call %s after a stream was finished', Error)\nE('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable', Error)\nE('ERR_STREAM_DESTROYED', 'Cannot call %s after a stream was destroyed', Error)\nE('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError)\nE('ERR_STREAM_PREMATURE_CLOSE', 'Premature close', Error)\nE('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF', Error)\nE('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event', Error)\nE('ERR_STREAM_WRITE_AFTER_END', 'write after end', Error)\nE('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s', TypeError)\nmodule.exports = {\n  AbortError,\n  aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),\n  hideStackFrames,\n  codes\n}\n","/* eslint jsdoc/require-jsdoc: \"error\" */\n\n'use strict'\n\nconst {\n  ArrayIsArray,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberMAX_SAFE_INTEGER,\n  NumberMIN_SAFE_INTEGER,\n  NumberParseInt,\n  ObjectPrototypeHasOwnProperty,\n  RegExpPrototypeExec,\n  String,\n  StringPrototypeToUpperCase,\n  StringPrototypeTrim\n} = require('../ours/primordials')\nconst {\n  hideStackFrames,\n  codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }\n} = require('../ours/errors')\nconst { normalizeEncoding } = require('../ours/util')\nconst { isAsyncFunction, isArrayBufferView } = require('../ours/util').types\nconst signals = {}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isInt32(value) {\n  return value === (value | 0)\n}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isUint32(value) {\n  return value === value >>> 0\n}\nconst octalReg = /^[0-7]+$/\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string'\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land, but any value higher than 0o777 will result in platform-specific\n * behaviors.\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified, will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value, name, def) {\n  if (typeof value === 'undefined') {\n    value = def\n  }\n  if (typeof value === 'string') {\n    if (RegExpPrototypeExec(octalReg, value) === null) {\n      throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc)\n    }\n    value = NumberParseInt(value, 8)\n  }\n  validateUint32(value, name)\n  return value\n}\n\n/**\n * @callback validateInteger\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInteger} */\nconst validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {\n  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, 'an integer', value)\n  if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)\n})\n\n/**\n * @callback validateInt32\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInt32} */\nconst validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {\n  // The defaults for min and max correspond to the limits of 32-bit integers.\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)\n  }\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)\n  }\n})\n\n/**\n * @callback validateUint32\n * @param {*} value\n * @param {string} name\n * @param {number|boolean} [positive=false]\n * @returns {asserts value is number}\n */\n\n/** @type {validateUint32} */\nconst validateUint32 = hideStackFrames((value, name, positive = false) => {\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)\n  }\n  const min = positive ? 1 : 0\n  // 2 ** 32 === 4294967296\n  const max = 4294967295\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)\n  }\n})\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value, name) {\n  if (typeof value !== 'string') throw new ERR_INVALID_ARG_TYPE(name, 'string', value)\n}\n\n/**\n * @callback validateNumber\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateNumber} */\nfunction validateNumber(value, name, min = undefined, max) {\n  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)\n  if (\n    (min != null && value < min) ||\n    (max != null && value > max) ||\n    ((min != null || max != null) && NumberIsNaN(value))\n  ) {\n    throw new ERR_OUT_OF_RANGE(\n      name,\n      `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`,\n      value\n    )\n  }\n}\n\n/**\n * @callback validateOneOf\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} oneOf\n */\n\n/** @type {validateOneOf} */\nconst validateOneOf = hideStackFrames((value, name, oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf, value)) {\n    const allowed = ArrayPrototypeJoin(\n      ArrayPrototypeMap(oneOf, (v) => (typeof v === 'string' ? `'${v}'` : String(v))),\n      ', '\n    )\n    const reason = 'must be one of: ' + allowed\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason)\n  }\n})\n\n/**\n * @callback validateBoolean\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean}\n */\n\n/** @type {validateBoolean} */\nfunction validateBoolean(value, name) {\n  if (typeof value !== 'boolean') throw new ERR_INVALID_ARG_TYPE(name, 'boolean', value)\n}\n\n/**\n * @param {any} options\n * @param {string} key\n * @param {boolean} defaultValue\n * @returns {boolean}\n */\nfunction getOwnPropertyValueOrDefault(options, key, defaultValue) {\n  return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key]\n}\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = hideStackFrames((value, name, options = null) => {\n  const allowArray = getOwnPropertyValueOrDefault(options, 'allowArray', false)\n  const allowFunction = getOwnPropertyValueOrDefault(options, 'allowFunction', false)\n  const nullable = getOwnPropertyValueOrDefault(options, 'nullable', false)\n  if (\n    (!nullable && value === null) ||\n    (!allowArray && ArrayIsArray(value)) ||\n    (typeof value !== 'object' && (!allowFunction || typeof value !== 'function'))\n  ) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Object', value)\n  }\n})\n\n/**\n * @callback validateDictionary - We are using the Web IDL Standard definition\n *                                of \"dictionary\" here, which means any value\n *                                whose Type is either Undefined, Null, or\n *                                Object (which includes functions).\n * @param {*} value\n * @param {string} name\n * @see https://webidl.spec.whatwg.org/#es-dictionary\n * @see https://tc39.es/ecma262/#table-typeof-operator-results\n */\n\n/** @type {validateDictionary} */\nconst validateDictionary = hideStackFrames((value, name) => {\n  if (value != null && typeof value !== 'object' && typeof value !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(name, 'a dictionary', value)\n  }\n})\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\n\n/** @type {validateArray} */\nconst validateArray = hideStackFrames((value, name, minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'Array', value)\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason)\n  }\n})\n\n/**\n * @callback validateStringArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string[]}\n */\n\n/** @type {validateStringArray} */\nfunction validateStringArray(value, name) {\n  validateArray(value, name)\n  for (let i = 0; i < value.length; i++) {\n    validateString(value[i], `${name}[${i}]`)\n  }\n}\n\n/**\n * @callback validateBooleanArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean[]}\n */\n\n/** @type {validateBooleanArray} */\nfunction validateBooleanArray(value, name) {\n  validateArray(value, name)\n  for (let i = 0; i < value.length; i++) {\n    validateBoolean(value[i], `${name}[${i}]`)\n  }\n}\n\n/**\n * @callback validateAbortSignalArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is AbortSignal[]}\n */\n\n/** @type {validateAbortSignalArray} */\nfunction validateAbortSignalArray(value, name) {\n  validateArray(value, name)\n  for (let i = 0; i < value.length; i++) {\n    const signal = value[i]\n    const indexedName = `${name}[${i}]`\n    if (signal == null) {\n      throw new ERR_INVALID_ARG_TYPE(indexedName, 'AbortSignal', signal)\n    }\n    validateAbortSignal(signal, indexedName)\n  }\n}\n\n/**\n * @param {*} signal\n * @param {string} [name='signal']\n * @returns {asserts signal is keyof signals}\n */\nfunction validateSignalName(signal, name = 'signal') {\n  validateString(signal, name)\n  if (signals[signal] === undefined) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal + ' (signals must use all capital letters)')\n    }\n    throw new ERR_UNKNOWN_SIGNAL(signal)\n  }\n}\n\n/**\n * @callback validateBuffer\n * @param {*} buffer\n * @param {string} [name='buffer']\n * @returns {asserts buffer is ArrayBufferView}\n */\n\n/** @type {validateBuffer} */\nconst validateBuffer = hideStackFrames((buffer, name = 'buffer') => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name, ['Buffer', 'TypedArray', 'DataView'], buffer)\n  }\n})\n\n/**\n * @param {string} data\n * @param {string} encoding\n */\nfunction validateEncoding(data, encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding)\n  const length = data.length\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding', encoding, `is invalid for data of length ${length}`)\n  }\n}\n\n/**\n * Check that the port number is not NaN when coerced to a number,\n * is an integer and that it falls within the legal range of port numbers.\n * @param {*} port\n * @param {string} [name='Port']\n * @param {boolean} [allowZero=true]\n * @returns {number}\n */\nfunction validatePort(port, name = 'Port', allowZero = true) {\n  if (\n    (typeof port !== 'number' && typeof port !== 'string') ||\n    (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||\n    +port !== +port >>> 0 ||\n    port > 0xffff ||\n    (port === 0 && !allowZero)\n  ) {\n    throw new ERR_SOCKET_BAD_PORT(name, port, allowZero)\n  }\n  return port | 0\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\n\n/** @type {validateAbortSignal} */\nconst validateAbortSignal = hideStackFrames((signal, name) => {\n  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)\n  }\n})\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validateFunction} */\nconst validateFunction = hideStackFrames((value, name) => {\n  if (typeof value !== 'function') throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)\n})\n\n/**\n * @callback validatePlainFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validatePlainFunction} */\nconst validatePlainFunction = hideStackFrames((value, name) => {\n  if (typeof value !== 'function' || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)\n})\n\n/**\n * @callback validateUndefined\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is undefined}\n */\n\n/** @type {validateUndefined} */\nconst validateUndefined = hideStackFrames((value, name) => {\n  if (value !== undefined) throw new ERR_INVALID_ARG_TYPE(name, 'undefined', value)\n})\n\n/**\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} union\n */\nfunction validateUnion(value, name, union) {\n  if (!ArrayPrototypeIncludes(union, value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, '|')}')`, value)\n  }\n}\n\n/*\n  The rules for the Link header field are described here:\n  https://www.rfc-editor.org/rfc/rfc8288.html#section-3\n\n  This regex validates any string surrounded by angle brackets\n  (not necessarily a valid URI reference) followed by zero or more\n  link-params separated by semicolons.\n*/\nconst linkValueRegExp = /^(?:<[^>]*>)(?:\\s*;\\s*[^;\"\\s]+(?:=(\")?[^;\"\\s]*\\1)?)*$/\n\n/**\n * @param {any} value\n * @param {string} name\n */\nfunction validateLinkHeaderFormat(value, name) {\n  if (typeof value === 'undefined' || !RegExpPrototypeExec(linkValueRegExp, value)) {\n    throw new ERR_INVALID_ARG_VALUE(\n      name,\n      value,\n      'must be an array or string of format \"</styles.css>; rel=preload; as=style\"'\n    )\n  }\n}\n\n/**\n * @param {any} hints\n * @return {string}\n */\nfunction validateLinkHeaderValue(hints) {\n  if (typeof hints === 'string') {\n    validateLinkHeaderFormat(hints, 'hints')\n    return hints\n  } else if (ArrayIsArray(hints)) {\n    const hintsLength = hints.length\n    let result = ''\n    if (hintsLength === 0) {\n      return result\n    }\n    for (let i = 0; i < hintsLength; i++) {\n      const link = hints[i]\n      validateLinkHeaderFormat(link, 'hints')\n      result += link\n      if (i !== hintsLength - 1) {\n        result += ', '\n      }\n    }\n    return result\n  }\n  throw new ERR_INVALID_ARG_VALUE(\n    'hints',\n    hints,\n    'must be an array or string of format \"</styles.css>; rel=preload; as=style\"'\n  )\n}\nmodule.exports = {\n  isInt32,\n  isUint32,\n  parseFileMode,\n  validateArray,\n  validateStringArray,\n  validateBooleanArray,\n  validateAbortSignalArray,\n  validateBoolean,\n  validateBuffer,\n  validateDictionary,\n  validateEncoding,\n  validateFunction,\n  validateInt32,\n  validateInteger,\n  validateNumber,\n  validateObject,\n  validateOneOf,\n  validatePlainFunction,\n  validatePort,\n  validateSignalName,\n  validateString,\n  validateUint32,\n  validateUndefined,\n  validateUnion,\n  validateAbortSignal,\n  validateLinkHeaderValue\n}\n","'use strict'\n\nconst { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require('../../ours/primordials')\n\n// We need to use SymbolFor to make these globally available\n// for interopt with readable-stream, i.e. readable-stream\n// and node core needs to be able to read/write private state\n// from each other for proper interoperability.\nconst kIsDestroyed = SymbolFor('nodejs.stream.destroyed')\nconst kIsErrored = SymbolFor('nodejs.stream.errored')\nconst kIsReadable = SymbolFor('nodejs.stream.readable')\nconst kIsWritable = SymbolFor('nodejs.stream.writable')\nconst kIsDisturbed = SymbolFor('nodejs.stream.disturbed')\nconst kIsClosedPromise = SymbolFor('nodejs.webstream.isClosedPromise')\nconst kControllerErrorFunction = SymbolFor('nodejs.webstream.controllerErrorFunction')\nfunction isReadableNodeStream(obj, strict = false) {\n  var _obj$_readableState\n  return !!(\n    (\n      obj &&\n      typeof obj.pipe === 'function' &&\n      typeof obj.on === 'function' &&\n      (!strict || (typeof obj.pause === 'function' && typeof obj.resume === 'function')) &&\n      (!obj._writableState ||\n        ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined\n          ? undefined\n          : _obj$_readableState.readable) !== false) &&\n      // Duplex\n      (!obj._writableState || obj._readableState)\n    ) // Writable has .pipe.\n  )\n}\n\nfunction isWritableNodeStream(obj) {\n  var _obj$_writableState\n  return !!(\n    (\n      obj &&\n      typeof obj.write === 'function' &&\n      typeof obj.on === 'function' &&\n      (!obj._readableState ||\n        ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined\n          ? undefined\n          : _obj$_writableState.writable) !== false)\n    ) // Duplex\n  )\n}\n\nfunction isDuplexNodeStream(obj) {\n  return !!(\n    obj &&\n    typeof obj.pipe === 'function' &&\n    obj._readableState &&\n    typeof obj.on === 'function' &&\n    typeof obj.write === 'function'\n  )\n}\nfunction isNodeStream(obj) {\n  return (\n    obj &&\n    (obj._readableState ||\n      obj._writableState ||\n      (typeof obj.write === 'function' && typeof obj.on === 'function') ||\n      (typeof obj.pipe === 'function' && typeof obj.on === 'function'))\n  )\n}\nfunction isReadableStream(obj) {\n  return !!(\n    obj &&\n    !isNodeStream(obj) &&\n    typeof obj.pipeThrough === 'function' &&\n    typeof obj.getReader === 'function' &&\n    typeof obj.cancel === 'function'\n  )\n}\nfunction isWritableStream(obj) {\n  return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === 'function' && typeof obj.abort === 'function')\n}\nfunction isTransformStream(obj) {\n  return !!(obj && !isNodeStream(obj) && typeof obj.readable === 'object' && typeof obj.writable === 'object')\n}\nfunction isWebStream(obj) {\n  return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj)\n}\nfunction isIterable(obj, isAsync) {\n  if (obj == null) return false\n  if (isAsync === true) return typeof obj[SymbolAsyncIterator] === 'function'\n  if (isAsync === false) return typeof obj[SymbolIterator] === 'function'\n  return typeof obj[SymbolAsyncIterator] === 'function' || typeof obj[SymbolIterator] === 'function'\n}\nfunction isDestroyed(stream) {\n  if (!isNodeStream(stream)) return null\n  const wState = stream._writableState\n  const rState = stream._readableState\n  const state = wState || rState\n  return !!(stream.destroyed || stream[kIsDestroyed] || (state !== null && state !== undefined && state.destroyed))\n}\n\n// Have been end():d.\nfunction isWritableEnded(stream) {\n  if (!isWritableNodeStream(stream)) return null\n  if (stream.writableEnded === true) return true\n  const wState = stream._writableState\n  if (wState !== null && wState !== undefined && wState.errored) return false\n  if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== 'boolean') return null\n  return wState.ended\n}\n\n// Have emitted 'finish'.\nfunction isWritableFinished(stream, strict) {\n  if (!isWritableNodeStream(stream)) return null\n  if (stream.writableFinished === true) return true\n  const wState = stream._writableState\n  if (wState !== null && wState !== undefined && wState.errored) return false\n  if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== 'boolean') return null\n  return !!(wState.finished || (strict === false && wState.ended === true && wState.length === 0))\n}\n\n// Have been push(null):d.\nfunction isReadableEnded(stream) {\n  if (!isReadableNodeStream(stream)) return null\n  if (stream.readableEnded === true) return true\n  const rState = stream._readableState\n  if (!rState || rState.errored) return false\n  if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== 'boolean') return null\n  return rState.ended\n}\n\n// Have emitted 'end'.\nfunction isReadableFinished(stream, strict) {\n  if (!isReadableNodeStream(stream)) return null\n  const rState = stream._readableState\n  if (rState !== null && rState !== undefined && rState.errored) return false\n  if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== 'boolean') return null\n  return !!(rState.endEmitted || (strict === false && rState.ended === true && rState.length === 0))\n}\nfunction isReadable(stream) {\n  if (stream && stream[kIsReadable] != null) return stream[kIsReadable]\n  if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== 'boolean') return null\n  if (isDestroyed(stream)) return false\n  return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream)\n}\nfunction isWritable(stream) {\n  if (stream && stream[kIsWritable] != null) return stream[kIsWritable]\n  if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== 'boolean') return null\n  if (isDestroyed(stream)) return false\n  return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream)\n}\nfunction isFinished(stream, opts) {\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (isDestroyed(stream)) {\n    return true\n  }\n  if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream)) {\n    return false\n  }\n  if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream)) {\n    return false\n  }\n  return true\n}\nfunction isWritableErrored(stream) {\n  var _stream$_writableStat, _stream$_writableStat2\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (stream.writableErrored) {\n    return stream.writableErrored\n  }\n  return (_stream$_writableStat =\n    (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined\n      ? undefined\n      : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined\n    ? _stream$_writableStat\n    : null\n}\nfunction isReadableErrored(stream) {\n  var _stream$_readableStat, _stream$_readableStat2\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (stream.readableErrored) {\n    return stream.readableErrored\n  }\n  return (_stream$_readableStat =\n    (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined\n      ? undefined\n      : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined\n    ? _stream$_readableStat\n    : null\n}\nfunction isClosed(stream) {\n  if (!isNodeStream(stream)) {\n    return null\n  }\n  if (typeof stream.closed === 'boolean') {\n    return stream.closed\n  }\n  const wState = stream._writableState\n  const rState = stream._readableState\n  if (\n    typeof (wState === null || wState === undefined ? undefined : wState.closed) === 'boolean' ||\n    typeof (rState === null || rState === undefined ? undefined : rState.closed) === 'boolean'\n  ) {\n    return (\n      (wState === null || wState === undefined ? undefined : wState.closed) ||\n      (rState === null || rState === undefined ? undefined : rState.closed)\n    )\n  }\n  if (typeof stream._closed === 'boolean' && isOutgoingMessage(stream)) {\n    return stream._closed\n  }\n  return null\n}\nfunction isOutgoingMessage(stream) {\n  return (\n    typeof stream._closed === 'boolean' &&\n    typeof stream._defaultKeepAlive === 'boolean' &&\n    typeof stream._removedConnection === 'boolean' &&\n    typeof stream._removedContLen === 'boolean'\n  )\n}\nfunction isServerResponse(stream) {\n  return typeof stream._sent100 === 'boolean' && isOutgoingMessage(stream)\n}\nfunction isServerRequest(stream) {\n  var _stream$req\n  return (\n    typeof stream._consuming === 'boolean' &&\n    typeof stream._dumped === 'boolean' &&\n    ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) ===\n      undefined\n  )\n}\nfunction willEmitClose(stream) {\n  if (!isNodeStream(stream)) return null\n  const wState = stream._writableState\n  const rState = stream._readableState\n  const state = wState || rState\n  return (\n    (!state && isServerResponse(stream)) || !!(state && state.autoDestroy && state.emitClose && state.closed === false)\n  )\n}\nfunction isDisturbed(stream) {\n  var _stream$kIsDisturbed\n  return !!(\n    stream &&\n    ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined\n      ? _stream$kIsDisturbed\n      : stream.readableDidRead || stream.readableAborted)\n  )\n}\nfunction isErrored(stream) {\n  var _ref,\n    _ref2,\n    _ref3,\n    _ref4,\n    _ref5,\n    _stream$kIsErrored,\n    _stream$_readableStat3,\n    _stream$_writableStat3,\n    _stream$_readableStat4,\n    _stream$_writableStat4\n  return !!(\n    stream &&\n    ((_ref =\n      (_ref2 =\n        (_ref3 =\n          (_ref4 =\n            (_ref5 =\n              (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== undefined\n                ? _stream$kIsErrored\n                : stream.readableErrored) !== null && _ref5 !== undefined\n              ? _ref5\n              : stream.writableErrored) !== null && _ref4 !== undefined\n            ? _ref4\n            : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined\n            ? undefined\n            : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined\n          ? _ref3\n          : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined\n          ? undefined\n          : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined\n        ? _ref2\n        : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined\n        ? undefined\n        : _stream$_readableStat4.errored) !== null && _ref !== undefined\n      ? _ref\n      : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined\n      ? undefined\n      : _stream$_writableStat4.errored)\n  )\n}\nmodule.exports = {\n  isDestroyed,\n  kIsDestroyed,\n  isDisturbed,\n  kIsDisturbed,\n  isErrored,\n  kIsErrored,\n  isReadable,\n  kIsReadable,\n  kIsClosedPromise,\n  kControllerErrorFunction,\n  kIsWritable,\n  isClosed,\n  isDuplexNodeStream,\n  isFinished,\n  isIterable,\n  isReadableNodeStream,\n  isReadableStream,\n  isReadableEnded,\n  isReadableFinished,\n  isReadableErrored,\n  isNodeStream,\n  isWebStream,\n  isWritable,\n  isWritableNodeStream,\n  isWritableStream,\n  isWritableEnded,\n  isWritableFinished,\n  isWritableErrored,\n  isServerRequest,\n  isServerResponse,\n  willEmitClose,\n  isTransformStream\n}\n","/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n;('use strict')\nconst { AbortError, codes } = require('../../ours/errors')\nconst { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes\nconst { kEmptyObject, once } = require('../../ours/util')\nconst { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require('../validators')\nconst { Promise, PromisePrototypeThen, SymbolDispose } = require('../../ours/primordials')\nconst {\n  isClosed,\n  isReadable,\n  isReadableNodeStream,\n  isReadableStream,\n  isReadableFinished,\n  isReadableErrored,\n  isWritable,\n  isWritableNodeStream,\n  isWritableStream,\n  isWritableFinished,\n  isWritableErrored,\n  isNodeStream,\n  willEmitClose: _willEmitClose,\n  kIsClosedPromise\n} = require('./utils')\nlet addAbortListener\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function'\n}\nconst nop = () => {}\nfunction eos(stream, options, callback) {\n  var _options$readable, _options$writable\n  if (arguments.length === 2) {\n    callback = options\n    options = kEmptyObject\n  } else if (options == null) {\n    options = kEmptyObject\n  } else {\n    validateObject(options, 'options')\n  }\n  validateFunction(callback, 'callback')\n  validateAbortSignal(options.signal, 'options.signal')\n  callback = once(callback)\n  if (isReadableStream(stream) || isWritableStream(stream)) {\n    return eosWeb(stream, options, callback)\n  }\n  if (!isNodeStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)\n  }\n  const readable =\n    (_options$readable = options.readable) !== null && _options$readable !== undefined\n      ? _options$readable\n      : isReadableNodeStream(stream)\n  const writable =\n    (_options$writable = options.writable) !== null && _options$writable !== undefined\n      ? _options$writable\n      : isWritableNodeStream(stream)\n  const wState = stream._writableState\n  const rState = stream._readableState\n  const onlegacyfinish = () => {\n    if (!stream.writable) {\n      onfinish()\n    }\n  }\n\n  // TODO (ronag): Improve soft detection to include core modules and\n  // common ecosystem modules that do properly emit 'close' but fail\n  // this generic check.\n  let willEmitClose =\n    _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable\n  let writableFinished = isWritableFinished(stream, false)\n  const onfinish = () => {\n    writableFinished = true\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false\n    }\n    if (willEmitClose && (!stream.readable || readable)) {\n      return\n    }\n    if (!readable || readableFinished) {\n      callback.call(stream)\n    }\n  }\n  let readableFinished = isReadableFinished(stream, false)\n  const onend = () => {\n    readableFinished = true\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false\n    }\n    if (willEmitClose && (!stream.writable || writable)) {\n      return\n    }\n    if (!writable || writableFinished) {\n      callback.call(stream)\n    }\n  }\n  const onerror = (err) => {\n    callback.call(stream, err)\n  }\n  let closed = isClosed(stream)\n  const onclose = () => {\n    closed = true\n    const errored = isWritableErrored(stream) || isReadableErrored(stream)\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored)\n    }\n    if (readable && !readableFinished && isReadableNodeStream(stream, true)) {\n      if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())\n    }\n    if (writable && !writableFinished) {\n      if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())\n    }\n    callback.call(stream)\n  }\n  const onclosed = () => {\n    closed = true\n    const errored = isWritableErrored(stream) || isReadableErrored(stream)\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored)\n    }\n    callback.call(stream)\n  }\n  const onrequest = () => {\n    stream.req.on('finish', onfinish)\n  }\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish)\n    if (!willEmitClose) {\n      stream.on('abort', onclose)\n    }\n    if (stream.req) {\n      onrequest()\n    } else {\n      stream.on('request', onrequest)\n    }\n  } else if (writable && !wState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish)\n    stream.on('close', onlegacyfinish)\n  }\n\n  // Not all streams will emit 'close' after 'aborted'.\n  if (!willEmitClose && typeof stream.aborted === 'boolean') {\n    stream.on('aborted', onclose)\n  }\n  stream.on('end', onend)\n  stream.on('finish', onfinish)\n  if (options.error !== false) {\n    stream.on('error', onerror)\n  }\n  stream.on('close', onclose)\n  if (closed) {\n    process.nextTick(onclose)\n  } else if (\n    (wState !== null && wState !== undefined && wState.errorEmitted) ||\n    (rState !== null && rState !== undefined && rState.errorEmitted)\n  ) {\n    if (!willEmitClose) {\n      process.nextTick(onclosed)\n    }\n  } else if (\n    !readable &&\n    (!willEmitClose || isReadable(stream)) &&\n    (writableFinished || isWritable(stream) === false)\n  ) {\n    process.nextTick(onclosed)\n  } else if (\n    !writable &&\n    (!willEmitClose || isWritable(stream)) &&\n    (readableFinished || isReadable(stream) === false)\n  ) {\n    process.nextTick(onclosed)\n  } else if (rState && stream.req && stream.aborted) {\n    process.nextTick(onclosed)\n  }\n  const cleanup = () => {\n    callback = nop\n    stream.removeListener('aborted', onclose)\n    stream.removeListener('complete', onfinish)\n    stream.removeListener('abort', onclose)\n    stream.removeListener('request', onrequest)\n    if (stream.req) stream.req.removeListener('finish', onfinish)\n    stream.removeListener('end', onlegacyfinish)\n    stream.removeListener('close', onlegacyfinish)\n    stream.removeListener('finish', onfinish)\n    stream.removeListener('end', onend)\n    stream.removeListener('error', onerror)\n    stream.removeListener('close', onclose)\n  }\n  if (options.signal && !closed) {\n    const abort = () => {\n      // Keep it because cleanup removes it.\n      const endCallback = callback\n      cleanup()\n      endCallback.call(\n        stream,\n        new AbortError(undefined, {\n          cause: options.signal.reason\n        })\n      )\n    }\n    if (options.signal.aborted) {\n      process.nextTick(abort)\n    } else {\n      addAbortListener = addAbortListener || require('../../ours/util').addAbortListener\n      const disposable = addAbortListener(options.signal, abort)\n      const originalCallback = callback\n      callback = once((...args) => {\n        disposable[SymbolDispose]()\n        originalCallback.apply(stream, args)\n      })\n    }\n  }\n  return cleanup\n}\nfunction eosWeb(stream, options, callback) {\n  let isAborted = false\n  let abort = nop\n  if (options.signal) {\n    abort = () => {\n      isAborted = true\n      callback.call(\n        stream,\n        new AbortError(undefined, {\n          cause: options.signal.reason\n        })\n      )\n    }\n    if (options.signal.aborted) {\n      process.nextTick(abort)\n    } else {\n      addAbortListener = addAbortListener || require('../../ours/util').addAbortListener\n      const disposable = addAbortListener(options.signal, abort)\n      const originalCallback = callback\n      callback = once((...args) => {\n        disposable[SymbolDispose]()\n        originalCallback.apply(stream, args)\n      })\n    }\n  }\n  const resolverFn = (...args) => {\n    if (!isAborted) {\n      process.nextTick(() => callback.apply(stream, args))\n    }\n  }\n  PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn)\n  return nop\n}\nfunction finished(stream, opts) {\n  var _opts\n  let autoCleanup = false\n  if (opts === null) {\n    opts = kEmptyObject\n  }\n  if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {\n    validateBoolean(opts.cleanup, 'cleanup')\n    autoCleanup = opts.cleanup\n  }\n  return new Promise((resolve, reject) => {\n    const cleanup = eos(stream, opts, (err) => {\n      if (autoCleanup) {\n        cleanup()\n      }\n      if (err) {\n        reject(err)\n      } else {\n        resolve()\n      }\n    })\n  })\n}\nmodule.exports = eos\nmodule.exports.finished = finished\n","'use strict'\n\n/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n\nconst {\n  aggregateTwoErrors,\n  codes: { ERR_MULTIPLE_CALLBACK },\n  AbortError\n} = require('../../ours/errors')\nconst { Symbol } = require('../../ours/primordials')\nconst { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require('./utils')\nconst kDestroy = Symbol('kDestroy')\nconst kConstruct = Symbol('kConstruct')\nfunction checkError(err, w, r) {\n  if (err) {\n    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err\n    }\n    if (r && !r.errored) {\n      r.errored = err\n    }\n  }\n}\n\n// Backwards compat. cb() is undocumented and unused in core but\n// unfortunately might be used by modules.\nfunction destroy(err, cb) {\n  const r = this._readableState\n  const w = this._writableState\n  // With duplex streams we use the writable side for state.\n  const s = w || r\n  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {\n    if (typeof cb === 'function') {\n      cb()\n    }\n    return this\n  }\n\n  // We set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n  checkError(err, w, r)\n  if (w) {\n    w.destroyed = true\n  }\n  if (r) {\n    r.destroyed = true\n  }\n\n  // If still constructing then defer calling _destroy.\n  if (!s.constructed) {\n    this.once(kDestroy, function (er) {\n      _destroy(this, aggregateTwoErrors(er, err), cb)\n    })\n  } else {\n    _destroy(this, err, cb)\n  }\n  return this\n}\nfunction _destroy(self, err, cb) {\n  let called = false\n  function onDestroy(err) {\n    if (called) {\n      return\n    }\n    called = true\n    const r = self._readableState\n    const w = self._writableState\n    checkError(err, w, r)\n    if (w) {\n      w.closed = true\n    }\n    if (r) {\n      r.closed = true\n    }\n    if (typeof cb === 'function') {\n      cb(err)\n    }\n    if (err) {\n      process.nextTick(emitErrorCloseNT, self, err)\n    } else {\n      process.nextTick(emitCloseNT, self)\n    }\n  }\n  try {\n    self._destroy(err || null, onDestroy)\n  } catch (err) {\n    onDestroy(err)\n  }\n}\nfunction emitErrorCloseNT(self, err) {\n  emitErrorNT(self, err)\n  emitCloseNT(self)\n}\nfunction emitCloseNT(self) {\n  const r = self._readableState\n  const w = self._writableState\n  if (w) {\n    w.closeEmitted = true\n  }\n  if (r) {\n    r.closeEmitted = true\n  }\n  if ((w !== null && w !== undefined && w.emitClose) || (r !== null && r !== undefined && r.emitClose)) {\n    self.emit('close')\n  }\n}\nfunction emitErrorNT(self, err) {\n  const r = self._readableState\n  const w = self._writableState\n  if ((w !== null && w !== undefined && w.errorEmitted) || (r !== null && r !== undefined && r.errorEmitted)) {\n    return\n  }\n  if (w) {\n    w.errorEmitted = true\n  }\n  if (r) {\n    r.errorEmitted = true\n  }\n  self.emit('error', err)\n}\nfunction undestroy() {\n  const r = this._readableState\n  const w = this._writableState\n  if (r) {\n    r.constructed = true\n    r.closed = false\n    r.closeEmitted = false\n    r.destroyed = false\n    r.errored = null\n    r.errorEmitted = false\n    r.reading = false\n    r.ended = r.readable === false\n    r.endEmitted = r.readable === false\n  }\n  if (w) {\n    w.constructed = true\n    w.destroyed = false\n    w.closed = false\n    w.closeEmitted = false\n    w.errored = null\n    w.errorEmitted = false\n    w.finalCalled = false\n    w.prefinished = false\n    w.ended = w.writable === false\n    w.ending = w.writable === false\n    w.finished = w.writable === false\n  }\n}\nfunction errorOrDestroy(stream, err, sync) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  const r = stream._readableState\n  const w = stream._writableState\n  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {\n    return this\n  }\n  if ((r !== null && r !== undefined && r.autoDestroy) || (w !== null && w !== undefined && w.autoDestroy))\n    stream.destroy(err)\n  else if (err) {\n    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err\n    }\n    if (r && !r.errored) {\n      r.errored = err\n    }\n    if (sync) {\n      process.nextTick(emitErrorNT, stream, err)\n    } else {\n      emitErrorNT(stream, err)\n    }\n  }\n}\nfunction construct(stream, cb) {\n  if (typeof stream._construct !== 'function') {\n    return\n  }\n  const r = stream._readableState\n  const w = stream._writableState\n  if (r) {\n    r.constructed = false\n  }\n  if (w) {\n    w.constructed = false\n  }\n  stream.once(kConstruct, cb)\n  if (stream.listenerCount(kConstruct) > 1) {\n    // Duplex\n    return\n  }\n  process.nextTick(constructNT, stream)\n}\nfunction constructNT(stream) {\n  let called = false\n  function onConstruct(err) {\n    if (called) {\n      errorOrDestroy(stream, err !== null && err !== undefined ? err : new ERR_MULTIPLE_CALLBACK())\n      return\n    }\n    called = true\n    const r = stream._readableState\n    const w = stream._writableState\n    const s = w || r\n    if (r) {\n      r.constructed = true\n    }\n    if (w) {\n      w.constructed = true\n    }\n    if (s.destroyed) {\n      stream.emit(kDestroy, err)\n    } else if (err) {\n      errorOrDestroy(stream, err, true)\n    } else {\n      process.nextTick(emitConstructNT, stream)\n    }\n  }\n  try {\n    stream._construct((err) => {\n      process.nextTick(onConstruct, err)\n    })\n  } catch (err) {\n    process.nextTick(onConstruct, err)\n  }\n}\nfunction emitConstructNT(stream) {\n  stream.emit(kConstruct)\n}\nfunction isRequest(stream) {\n  return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === 'function'\n}\nfunction emitCloseLegacy(stream) {\n  stream.emit('close')\n}\nfunction emitErrorCloseLegacy(stream, err) {\n  stream.emit('error', err)\n  process.nextTick(emitCloseLegacy, stream)\n}\n\n// Normalize destroy for legacy.\nfunction destroyer(stream, err) {\n  if (!stream || isDestroyed(stream)) {\n    return\n  }\n  if (!err && !isFinished(stream)) {\n    err = new AbortError()\n  }\n\n  // TODO: Remove isRequest branches.\n  if (isServerRequest(stream)) {\n    stream.socket = null\n    stream.destroy(err)\n  } else if (isRequest(stream)) {\n    stream.abort()\n  } else if (isRequest(stream.req)) {\n    stream.req.abort()\n  } else if (typeof stream.destroy === 'function') {\n    stream.destroy(err)\n  } else if (typeof stream.close === 'function') {\n    // TODO: Don't lose err?\n    stream.close()\n  } else if (err) {\n    process.nextTick(emitErrorCloseLegacy, stream, err)\n  } else {\n    process.nextTick(emitCloseLegacy, stream)\n  }\n  if (!stream.destroyed) {\n    stream[kIsDestroyed] = true\n  }\n}\nmodule.exports = {\n  construct,\n  destroyer,\n  destroy,\n  undestroy,\n  errorOrDestroy\n}\n","'use strict'\n\nconst { ArrayIsArray, ObjectSetPrototypeOf } = require('../../ours/primordials')\nconst { EventEmitter: EE } = require('events')\nfunction Stream(opts) {\n  EE.call(this, opts)\n}\nObjectSetPrototypeOf(Stream.prototype, EE.prototype)\nObjectSetPrototypeOf(Stream, EE)\nStream.prototype.pipe = function (dest, options) {\n  const source = this\n  function ondata(chunk) {\n    if (dest.writable && dest.write(chunk) === false && source.pause) {\n      source.pause()\n    }\n  }\n  source.on('data', ondata)\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume()\n    }\n  }\n  dest.on('drain', ondrain)\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend)\n    source.on('close', onclose)\n  }\n  let didOnEnd = false\n  function onend() {\n    if (didOnEnd) return\n    didOnEnd = true\n    dest.end()\n  }\n  function onclose() {\n    if (didOnEnd) return\n    didOnEnd = true\n    if (typeof dest.destroy === 'function') dest.destroy()\n  }\n\n  // Don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup()\n    if (EE.listenerCount(this, 'error') === 0) {\n      this.emit('error', er)\n    }\n  }\n  prependListener(source, 'error', onerror)\n  prependListener(dest, 'error', onerror)\n\n  // Remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata)\n    dest.removeListener('drain', ondrain)\n    source.removeListener('end', onend)\n    source.removeListener('close', onclose)\n    source.removeListener('error', onerror)\n    dest.removeListener('error', onerror)\n    source.removeListener('end', cleanup)\n    source.removeListener('close', cleanup)\n    dest.removeListener('close', cleanup)\n  }\n  source.on('end', cleanup)\n  source.on('close', cleanup)\n  dest.on('close', cleanup)\n  dest.emit('pipe', source)\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest\n}\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn)\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn)\n  else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn)\n  else emitter._events[event] = [fn, emitter._events[event]]\n}\nmodule.exports = {\n  Stream,\n  prependListener\n}\n","'use strict'\n\nconst { SymbolDispose } = require('../../ours/primordials')\nconst { AbortError, codes } = require('../../ours/errors')\nconst { isNodeStream, isWebStream, kControllerErrorFunction } = require('./utils')\nconst eos = require('./end-of-stream')\nconst { ERR_INVALID_ARG_TYPE } = codes\nlet addAbortListener\n\n// This method is inlined here for readable-stream\n// It also does not allow for signal to not exist on the stream\n// https://github.com/nodejs/node/pull/36061#discussion_r533718029\nconst validateAbortSignal = (signal, name) => {\n  if (typeof signal !== 'object' || !('aborted' in signal)) {\n    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)\n  }\n}\nmodule.exports.addAbortSignal = function addAbortSignal(signal, stream) {\n  validateAbortSignal(signal, 'signal')\n  if (!isNodeStream(stream) && !isWebStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)\n  }\n  return module.exports.addAbortSignalNoValidate(signal, stream)\n}\nmodule.exports.addAbortSignalNoValidate = function (signal, stream) {\n  if (typeof signal !== 'object' || !('aborted' in signal)) {\n    return stream\n  }\n  const onAbort = isNodeStream(stream)\n    ? () => {\n        stream.destroy(\n          new AbortError(undefined, {\n            cause: signal.reason\n          })\n        )\n      }\n    : () => {\n        stream[kControllerErrorFunction](\n          new AbortError(undefined, {\n            cause: signal.reason\n          })\n        )\n      }\n  if (signal.aborted) {\n    onAbort()\n  } else {\n    addAbortListener = addAbortListener || require('../../ours/util').addAbortListener\n    const disposable = addAbortListener(signal, onAbort)\n    eos(stream, disposable[SymbolDispose])\n  }\n  return stream\n}\n","'use strict'\n\nconst { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array } = require('../../ours/primordials')\nconst { Buffer } = require('buffer')\nconst { inspect } = require('../../ours/util')\nmodule.exports = class BufferList {\n  constructor() {\n    this.head = null\n    this.tail = null\n    this.length = 0\n  }\n  push(v) {\n    const entry = {\n      data: v,\n      next: null\n    }\n    if (this.length > 0) this.tail.next = entry\n    else this.head = entry\n    this.tail = entry\n    ++this.length\n  }\n  unshift(v) {\n    const entry = {\n      data: v,\n      next: this.head\n    }\n    if (this.length === 0) this.tail = entry\n    this.head = entry\n    ++this.length\n  }\n  shift() {\n    if (this.length === 0) return\n    const ret = this.head.data\n    if (this.length === 1) this.head = this.tail = null\n    else this.head = this.head.next\n    --this.length\n    return ret\n  }\n  clear() {\n    this.head = this.tail = null\n    this.length = 0\n  }\n  join(s) {\n    if (this.length === 0) return ''\n    let p = this.head\n    let ret = '' + p.data\n    while ((p = p.next) !== null) ret += s + p.data\n    return ret\n  }\n  concat(n) {\n    if (this.length === 0) return Buffer.alloc(0)\n    const ret = Buffer.allocUnsafe(n >>> 0)\n    let p = this.head\n    let i = 0\n    while (p) {\n      TypedArrayPrototypeSet(ret, p.data, i)\n      i += p.data.length\n      p = p.next\n    }\n    return ret\n  }\n\n  // Consumes a specified amount of bytes or characters from the buffered data.\n  consume(n, hasStrings) {\n    const data = this.head.data\n    if (n < data.length) {\n      // `slice` is the same for buffers and strings.\n      const slice = data.slice(0, n)\n      this.head.data = data.slice(n)\n      return slice\n    }\n    if (n === data.length) {\n      // First chunk is a perfect match.\n      return this.shift()\n    }\n    // Result spans more than one buffer.\n    return hasStrings ? this._getString(n) : this._getBuffer(n)\n  }\n  first() {\n    return this.head.data\n  }\n  *[SymbolIterator]() {\n    for (let p = this.head; p; p = p.next) {\n      yield p.data\n    }\n  }\n\n  // Consumes a specified amount of characters from the buffered data.\n  _getString(n) {\n    let ret = ''\n    let p = this.head\n    let c = 0\n    do {\n      const str = p.data\n      if (n > str.length) {\n        ret += str\n        n -= str.length\n      } else {\n        if (n === str.length) {\n          ret += str\n          ++c\n          if (p.next) this.head = p.next\n          else this.head = this.tail = null\n        } else {\n          ret += StringPrototypeSlice(str, 0, n)\n          this.head = p\n          p.data = StringPrototypeSlice(str, n)\n        }\n        break\n      }\n      ++c\n    } while ((p = p.next) !== null)\n    this.length -= c\n    return ret\n  }\n\n  // Consumes a specified amount of bytes from the buffered data.\n  _getBuffer(n) {\n    const ret = Buffer.allocUnsafe(n)\n    const retLen = n\n    let p = this.head\n    let c = 0\n    do {\n      const buf = p.data\n      if (n > buf.length) {\n        TypedArrayPrototypeSet(ret, buf, retLen - n)\n        n -= buf.length\n      } else {\n        if (n === buf.length) {\n          TypedArrayPrototypeSet(ret, buf, retLen - n)\n          ++c\n          if (p.next) this.head = p.next\n          else this.head = this.tail = null\n        } else {\n          TypedArrayPrototypeSet(ret, new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n)\n          this.head = p\n          p.data = buf.slice(n)\n        }\n        break\n      }\n      ++c\n    } while ((p = p.next) !== null)\n    this.length -= c\n    return ret\n  }\n\n  // Make sure the linked list only shows the minimal necessary information.\n  [Symbol.for('nodejs.util.inspect.custom')](_, options) {\n    return inspect(this, {\n      ...options,\n      // Only inspect one level.\n      depth: 0,\n      // It should not recurse.\n      customInspect: false\n    })\n  }\n}\n","'use strict'\n\nconst { MathFloor, NumberIsInteger } = require('../../ours/primordials')\nconst { validateInteger } = require('../validators')\nconst { ERR_INVALID_ARG_VALUE } = require('../../ours/errors').codes\nlet defaultHighWaterMarkBytes = 16 * 1024\nlet defaultHighWaterMarkObjectMode = 16\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null\n}\nfunction getDefaultHighWaterMark(objectMode) {\n  return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes\n}\nfunction setDefaultHighWaterMark(objectMode, value) {\n  validateInteger(value, 'value', 0)\n  if (objectMode) {\n    defaultHighWaterMarkObjectMode = value\n  } else {\n    defaultHighWaterMarkBytes = value\n  }\n}\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  const hwm = highWaterMarkFrom(options, isDuplex, duplexKey)\n  if (hwm != null) {\n    if (!NumberIsInteger(hwm) || hwm < 0) {\n      const name = isDuplex ? `options.${duplexKey}` : 'options.highWaterMark'\n      throw new ERR_INVALID_ARG_VALUE(name, hwm)\n    }\n    return MathFloor(hwm)\n  }\n\n  // Default value\n  return getDefaultHighWaterMark(state.objectMode)\n}\nmodule.exports = {\n  getHighWaterMark,\n  getDefaultHighWaterMark,\n  setDefaultHighWaterMark\n}\n","'use strict'\n\n/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n\nconst { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require('../../ours/primordials')\nconst { Buffer } = require('buffer')\nconst { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require('../../ours/errors').codes\nfunction from(Readable, iterable, opts) {\n  let iterator\n  if (typeof iterable === 'string' || iterable instanceof Buffer) {\n    return new Readable({\n      objectMode: true,\n      ...opts,\n      read() {\n        this.push(iterable)\n        this.push(null)\n      }\n    })\n  }\n  let isAsync\n  if (iterable && iterable[SymbolAsyncIterator]) {\n    isAsync = true\n    iterator = iterable[SymbolAsyncIterator]()\n  } else if (iterable && iterable[SymbolIterator]) {\n    isAsync = false\n    iterator = iterable[SymbolIterator]()\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable)\n  }\n  const readable = new Readable({\n    objectMode: true,\n    highWaterMark: 1,\n    // TODO(ronag): What options should be allowed?\n    ...opts\n  })\n\n  // Flag to protect against _read\n  // being called before last iteration completion.\n  let reading = false\n  readable._read = function () {\n    if (!reading) {\n      reading = true\n      next()\n    }\n  }\n  readable._destroy = function (error, cb) {\n    PromisePrototypeThen(\n      close(error),\n      () => process.nextTick(cb, error),\n      // nextTick is here in case cb throws\n      (e) => process.nextTick(cb, e || error)\n    )\n  }\n  async function close(error) {\n    const hadError = error !== undefined && error !== null\n    const hasThrow = typeof iterator.throw === 'function'\n    if (hadError && hasThrow) {\n      const { value, done } = await iterator.throw(error)\n      await value\n      if (done) {\n        return\n      }\n    }\n    if (typeof iterator.return === 'function') {\n      const { value } = await iterator.return()\n      await value\n    }\n  }\n  async function next() {\n    for (;;) {\n      try {\n        const { value, done } = isAsync ? await iterator.next() : iterator.next()\n        if (done) {\n          readable.push(null)\n        } else {\n          const res = value && typeof value.then === 'function' ? await value : value\n          if (res === null) {\n            reading = false\n            throw new ERR_STREAM_NULL_VALUES()\n          } else if (readable.push(res)) {\n            continue\n          } else {\n            reading = false\n          }\n        }\n      } catch (err) {\n        readable.destroy(err)\n      }\n      break\n    }\n  }\n  return readable\n}\nmodule.exports = from\n","/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n;('use strict')\nconst {\n  ArrayPrototypeIndexOf,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberParseInt,\n  ObjectDefineProperties,\n  ObjectKeys,\n  ObjectSetPrototypeOf,\n  Promise,\n  SafeSet,\n  SymbolAsyncDispose,\n  SymbolAsyncIterator,\n  Symbol\n} = require('../../ours/primordials')\nmodule.exports = Readable\nReadable.ReadableState = ReadableState\nconst { EventEmitter: EE } = require('events')\nconst { Stream, prependListener } = require('./legacy')\nconst { Buffer } = require('buffer')\nconst { addAbortSignal } = require('./add-abort-signal')\nconst eos = require('./end-of-stream')\nlet debug = require('../../ours/util').debuglog('stream', (fn) => {\n  debug = fn\n})\nconst BufferList = require('./buffer_list')\nconst destroyImpl = require('./destroy')\nconst { getHighWaterMark, getDefaultHighWaterMark } = require('./state')\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_OUT_OF_RANGE,\n    ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT\n  },\n  AbortError\n} = require('../../ours/errors')\nconst { validateObject } = require('../validators')\nconst kPaused = Symbol('kPaused')\nconst { StringDecoder } = require('string_decoder')\nconst from = require('./from')\nObjectSetPrototypeOf(Readable.prototype, Stream.prototype)\nObjectSetPrototypeOf(Readable, Stream)\nconst nop = () => {}\nconst { errorOrDestroy } = destroyImpl\nconst kObjectMode = 1 << 0\nconst kEnded = 1 << 1\nconst kEndEmitted = 1 << 2\nconst kReading = 1 << 3\nconst kConstructed = 1 << 4\nconst kSync = 1 << 5\nconst kNeedReadable = 1 << 6\nconst kEmittedReadable = 1 << 7\nconst kReadableListening = 1 << 8\nconst kResumeScheduled = 1 << 9\nconst kErrorEmitted = 1 << 10\nconst kEmitClose = 1 << 11\nconst kAutoDestroy = 1 << 12\nconst kDestroyed = 1 << 13\nconst kClosed = 1 << 14\nconst kCloseEmitted = 1 << 15\nconst kMultiAwaitDrain = 1 << 16\nconst kReadingMore = 1 << 17\nconst kDataEmitted = 1 << 18\n\n// TODO(benjamingr) it is likely slower to do it this way than with free functions\nfunction makeBitMapDescriptor(bit) {\n  return {\n    enumerable: false,\n    get() {\n      return (this.state & bit) !== 0\n    },\n    set(value) {\n      if (value) this.state |= bit\n      else this.state &= ~bit\n    }\n  }\n}\nObjectDefineProperties(ReadableState.prototype, {\n  objectMode: makeBitMapDescriptor(kObjectMode),\n  ended: makeBitMapDescriptor(kEnded),\n  endEmitted: makeBitMapDescriptor(kEndEmitted),\n  reading: makeBitMapDescriptor(kReading),\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in, therefore we start as\n  // constructed.\n  constructed: makeBitMapDescriptor(kConstructed),\n  // A flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  sync: makeBitMapDescriptor(kSync),\n  // Whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  needReadable: makeBitMapDescriptor(kNeedReadable),\n  emittedReadable: makeBitMapDescriptor(kEmittedReadable),\n  readableListening: makeBitMapDescriptor(kReadableListening),\n  resumeScheduled: makeBitMapDescriptor(kResumeScheduled),\n  // True if the error was already emitted and should not be thrown again.\n  errorEmitted: makeBitMapDescriptor(kErrorEmitted),\n  emitClose: makeBitMapDescriptor(kEmitClose),\n  autoDestroy: makeBitMapDescriptor(kAutoDestroy),\n  // Has it been destroyed.\n  destroyed: makeBitMapDescriptor(kDestroyed),\n  // Indicates whether the stream has finished destroying.\n  closed: makeBitMapDescriptor(kClosed),\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  closeEmitted: makeBitMapDescriptor(kCloseEmitted),\n  multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),\n  // If true, a maybeReadMore has been scheduled.\n  readingMore: makeBitMapDescriptor(kReadingMore),\n  dataEmitted: makeBitMapDescriptor(kDataEmitted)\n})\nfunction ReadableState(options, stream, isDuplex) {\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof require('./duplex')\n\n  // Bit map field to store ReadableState more effciently with 1 bit per field\n  // instead of a V8 slot per field.\n  this.state = kEmitClose | kAutoDestroy | kConstructed | kSync\n  // Object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away.\n  if (options && options.objectMode) this.state |= kObjectMode\n  if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode\n\n  // The point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = options\n    ? getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex)\n    : getDefaultHighWaterMark(false)\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift().\n  this.buffer = new BufferList()\n  this.length = 0\n  this.pipes = []\n  this.flowing = null\n  this[kPaused] = null\n\n  // Should close be emitted on destroy. Defaults to true.\n  if (options && options.emitClose === false) this.state &= ~kEmitClose\n\n  // Should .destroy() be called after 'end' (and potentially 'finish').\n  if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy\n\n  // Indicates whether the stream has errored. When true no further\n  // _read calls, 'data' or 'readable' events should occur. This is needed\n  // since when autoDestroy is disabled we need a way to tell whether the\n  // stream has failed.\n  this.errored = null\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8'\n\n  // Ref the piped dest which we need a drain event on it\n  // type: null | Writable | Set<Writable>.\n  this.awaitDrainWriters = null\n  this.decoder = null\n  this.encoding = null\n  if (options && options.encoding) {\n    this.decoder = new StringDecoder(options.encoding)\n    this.encoding = options.encoding\n  }\n}\nfunction Readable(options) {\n  if (!(this instanceof Readable)) return new Readable(options)\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5.\n  const isDuplex = this instanceof require('./duplex')\n  this._readableState = new ReadableState(options, this, isDuplex)\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read\n    if (typeof options.destroy === 'function') this._destroy = options.destroy\n    if (typeof options.construct === 'function') this._construct = options.construct\n    if (options.signal && !isDuplex) addAbortSignal(options.signal, this)\n  }\n  Stream.call(this, options)\n  destroyImpl.construct(this, () => {\n    if (this._readableState.needReadable) {\n      maybeReadMore(this, this._readableState)\n    }\n  })\n}\nReadable.prototype.destroy = destroyImpl.destroy\nReadable.prototype._undestroy = destroyImpl.undestroy\nReadable.prototype._destroy = function (err, cb) {\n  cb(err)\n}\nReadable.prototype[EE.captureRejectionSymbol] = function (err) {\n  this.destroy(err)\n}\nReadable.prototype[SymbolAsyncDispose] = function () {\n  let error\n  if (!this.destroyed) {\n    error = this.readableEnded ? null : new AbortError()\n    this.destroy(error)\n  }\n  return new Promise((resolve, reject) => eos(this, (err) => (err && err !== error ? reject(err) : resolve(null))))\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, false)\n}\n\n// Unshift should *always* be something directly out of read().\nReadable.prototype.unshift = function (chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, true)\n}\nfunction readableAddChunk(stream, chunk, encoding, addToFront) {\n  debug('readableAddChunk', chunk)\n  const state = stream._readableState\n  let err\n  if ((state.state & kObjectMode) === 0) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding\n      if (state.encoding !== encoding) {\n        if (addToFront && state.encoding) {\n          // When unshifting, if state.encoding is set, we have to save\n          // the string in the BufferList with the state encoding.\n          chunk = Buffer.from(chunk, encoding).toString(state.encoding)\n        } else {\n          chunk = Buffer.from(chunk, encoding)\n          encoding = ''\n        }\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = ''\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk)\n      encoding = ''\n    } else if (chunk != null) {\n      err = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)\n    }\n  }\n  if (err) {\n    errorOrDestroy(stream, err)\n  } else if (chunk === null) {\n    state.state &= ~kReading\n    onEofChunk(stream, state)\n  } else if ((state.state & kObjectMode) !== 0 || (chunk && chunk.length > 0)) {\n    if (addToFront) {\n      if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT())\n      else if (state.destroyed || state.errored) return false\n      else addChunk(stream, state, chunk, true)\n    } else if (state.ended) {\n      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF())\n    } else if (state.destroyed || state.errored) {\n      return false\n    } else {\n      state.state &= ~kReading\n      if (state.decoder && !encoding) {\n        chunk = state.decoder.write(chunk)\n        if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false)\n        else maybeReadMore(stream, state)\n      } else {\n        addChunk(stream, state, chunk, false)\n      }\n    }\n  } else if (!addToFront) {\n    state.state &= ~kReading\n    maybeReadMore(stream, state)\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0)\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount('data') > 0) {\n    // Use the guard to avoid creating `Set()` repeatedly\n    // when we have multiple pipes.\n    if ((state.state & kMultiAwaitDrain) !== 0) {\n      state.awaitDrainWriters.clear()\n    } else {\n      state.awaitDrainWriters = null\n    }\n    state.dataEmitted = true\n    stream.emit('data', chunk)\n  } else {\n    // Update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length\n    if (addToFront) state.buffer.unshift(chunk)\n    else state.buffer.push(chunk)\n    if ((state.state & kNeedReadable) !== 0) emitReadable(stream)\n  }\n  maybeReadMore(stream, state)\n}\nReadable.prototype.isPaused = function () {\n  const state = this._readableState\n  return state[kPaused] === true || state.flowing === false\n}\n\n// Backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  const decoder = new StringDecoder(enc)\n  this._readableState.decoder = decoder\n  // If setEncoding(null), decoder.encoding equals utf8.\n  this._readableState.encoding = this._readableState.decoder.encoding\n  const buffer = this._readableState.buffer\n  // Iterate over current buffer to convert already stored Buffers:\n  let content = ''\n  for (const data of buffer) {\n    content += decoder.write(data)\n  }\n  buffer.clear()\n  if (content !== '') buffer.push(content)\n  this._readableState.length = content.length\n  return this\n}\n\n// Don't raise the hwm > 1GB.\nconst MAX_HWM = 0x40000000\nfunction computeNewHighWaterMark(n) {\n  if (n > MAX_HWM) {\n    throw new ERR_OUT_OF_RANGE('size', '<= 1GiB', n)\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts.\n    n--\n    n |= n >>> 1\n    n |= n >>> 2\n    n |= n >>> 4\n    n |= n >>> 8\n    n |= n >>> 16\n    n++\n  }\n  return n\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || (state.length === 0 && state.ended)) return 0\n  if ((state.state & kObjectMode) !== 0) return 1\n  if (NumberIsNaN(n)) {\n    // Only flow one buffer at a time.\n    if (state.flowing && state.length) return state.buffer.first().length\n    return state.length\n  }\n  if (n <= state.length) return n\n  return state.ended ? state.length : 0\n}\n\n// You can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n)\n  // Same as parseInt(undefined, 10), however V8 7.3 performance regressed\n  // in this scenario, so we are doing it manually.\n  if (n === undefined) {\n    n = NaN\n  } else if (!NumberIsInteger(n)) {\n    n = NumberParseInt(n, 10)\n  }\n  const state = this._readableState\n  const nOrig = n\n\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n)\n  if (n !== 0) state.state &= ~kEmittedReadable\n\n  // If we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (\n    n === 0 &&\n    state.needReadable &&\n    ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)\n  ) {\n    debug('read: emitReadable', state.length, state.ended)\n    if (state.length === 0 && state.ended) endReadable(this)\n    else emitReadable(this)\n    return null\n  }\n  n = howMuchToRead(n, state)\n\n  // If we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this)\n    return null\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  let doRead = (state.state & kNeedReadable) !== 0\n  debug('need readable', doRead)\n\n  // If we currently have less than the highWaterMark, then also read some.\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true\n    debug('length less than watermark', doRead)\n  }\n\n  // However, if we've ended, then there's no point, if we're already\n  // reading, then it's unnecessary, if we're constructing we have to wait,\n  // and if we're destroyed or errored, then it's not allowed,\n  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {\n    doRead = false\n    debug('reading, ended or constructing', doRead)\n  } else if (doRead) {\n    debug('do read')\n    state.state |= kReading | kSync\n    // If the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.state |= kNeedReadable\n\n    // Call internal read method\n    try {\n      this._read(state.highWaterMark)\n    } catch (err) {\n      errorOrDestroy(this, err)\n    }\n    state.state &= ~kSync\n\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state)\n  }\n  let ret\n  if (n > 0) ret = fromList(n, state)\n  else ret = null\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark\n    n = 0\n  } else {\n    state.length -= n\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear()\n    } else {\n      state.awaitDrainWriters = null\n    }\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this)\n  }\n  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n    state.dataEmitted = true\n    this.emit('data', ret)\n  }\n  return ret\n}\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk')\n  if (state.ended) return\n  if (state.decoder) {\n    const chunk = state.decoder.end()\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk)\n      state.length += state.objectMode ? 1 : chunk.length\n    }\n  }\n  state.ended = true\n  if (state.sync) {\n    // If we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call.\n    emitReadable(stream)\n  } else {\n    // Emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false\n    state.emittedReadable = true\n    // We have to emit readable now that we are EOF. Modules\n    // in the ecosystem (e.g. dicer) rely on this event being sync.\n    emitReadable_(stream)\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  const state = stream._readableState\n  debug('emitReadable', state.needReadable, state.emittedReadable)\n  state.needReadable = false\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing)\n    state.emittedReadable = true\n    process.nextTick(emitReadable_, stream)\n  }\n}\nfunction emitReadable_(stream) {\n  const state = stream._readableState\n  debug('emitReadable_', state.destroyed, state.length, state.ended)\n  if (!state.destroyed && !state.errored && (state.length || state.ended)) {\n    stream.emit('readable')\n    state.emittedReadable = false\n  }\n\n  // The stream needs another readable event if:\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark\n  flow(stream)\n}\n\n// At this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore && state.constructed) {\n    state.readingMore = true\n    process.nextTick(maybeReadMore_, stream, state)\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (\n    !state.reading &&\n    !state.ended &&\n    (state.length < state.highWaterMark || (state.flowing && state.length === 0))\n  ) {\n    const len = state.length\n    debug('maybeReadMore read 0')\n    stream.read(0)\n    if (len === state.length)\n      // Didn't get any data, stop spinning.\n      break\n  }\n  state.readingMore = false\n}\n\n// Abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()')\n}\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  const src = this\n  const state = this._readableState\n  if (state.pipes.length === 1) {\n    if (!state.multiAwaitDrain) {\n      state.multiAwaitDrain = true\n      state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : [])\n    }\n  }\n  state.pipes.push(dest)\n  debug('pipe count=%d opts=%j', state.pipes.length, pipeOpts)\n  const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr\n  const endFn = doEnd ? onend : unpipe\n  if (state.endEmitted) process.nextTick(endFn)\n  else src.once('end', endFn)\n  dest.on('unpipe', onunpipe)\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe')\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true\n        cleanup()\n      }\n    }\n  }\n  function onend() {\n    debug('onend')\n    dest.end()\n  }\n  let ondrain\n  let cleanedUp = false\n  function cleanup() {\n    debug('cleanup')\n    // Cleanup event handlers once the pipe is broken.\n    dest.removeListener('close', onclose)\n    dest.removeListener('finish', onfinish)\n    if (ondrain) {\n      dest.removeListener('drain', ondrain)\n    }\n    dest.removeListener('error', onerror)\n    dest.removeListener('unpipe', onunpipe)\n    src.removeListener('end', onend)\n    src.removeListener('end', unpipe)\n    src.removeListener('data', ondata)\n    cleanedUp = true\n\n    // If the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain()\n  }\n  function pause() {\n    // If the user unpiped during `dest.write()`, it is possible\n    // to get stuck in a permanently paused state if that write\n    // also returned false.\n    // => Check whether `dest` is still a piping destination.\n    if (!cleanedUp) {\n      if (state.pipes.length === 1 && state.pipes[0] === dest) {\n        debug('false write response, pause', 0)\n        state.awaitDrainWriters = dest\n        state.multiAwaitDrain = false\n      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n        debug('false write response, pause', state.awaitDrainWriters.size)\n        state.awaitDrainWriters.add(dest)\n      }\n      src.pause()\n    }\n    if (!ondrain) {\n      // When the dest drains, it reduces the awaitDrain counter\n      // on the source.  This would be more elegant with a .once()\n      // handler in flow(), but adding and removing repeatedly is\n      // too slow.\n      ondrain = pipeOnDrain(src, dest)\n      dest.on('drain', ondrain)\n    }\n  }\n  src.on('data', ondata)\n  function ondata(chunk) {\n    debug('ondata')\n    const ret = dest.write(chunk)\n    debug('dest.write', ret)\n    if (ret === false) {\n      pause()\n    }\n  }\n\n  // If the dest has an error, then stop piping into it.\n  // However, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er)\n    unpipe()\n    dest.removeListener('error', onerror)\n    if (dest.listenerCount('error') === 0) {\n      const s = dest._writableState || dest._readableState\n      if (s && !s.errorEmitted) {\n        // User incorrectly emitted 'error' directly on the stream.\n        errorOrDestroy(dest, er)\n      } else {\n        dest.emit('error', er)\n      }\n    }\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror)\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish)\n    unpipe()\n  }\n  dest.once('close', onclose)\n  function onfinish() {\n    debug('onfinish')\n    dest.removeListener('close', onclose)\n    unpipe()\n  }\n  dest.once('finish', onfinish)\n  function unpipe() {\n    debug('unpipe')\n    src.unpipe(dest)\n  }\n\n  // Tell the dest that it's being piped to.\n  dest.emit('pipe', src)\n\n  // Start the flow if it hasn't been started already.\n\n  if (dest.writableNeedDrain === true) {\n    pause()\n  } else if (!state.flowing) {\n    debug('pipe resume')\n    src.resume()\n  }\n  return dest\n}\nfunction pipeOnDrain(src, dest) {\n  return function pipeOnDrainFunctionResult() {\n    const state = src._readableState\n\n    // `ondrain` will call directly,\n    // `this` maybe not a reference to dest,\n    // so we use the real dest here.\n    if (state.awaitDrainWriters === dest) {\n      debug('pipeOnDrain', 1)\n      state.awaitDrainWriters = null\n    } else if (state.multiAwaitDrain) {\n      debug('pipeOnDrain', state.awaitDrainWriters.size)\n      state.awaitDrainWriters.delete(dest)\n    }\n    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount('data')) {\n      src.resume()\n    }\n  }\n}\nReadable.prototype.unpipe = function (dest) {\n  const state = this._readableState\n  const unpipeInfo = {\n    hasUnpiped: false\n  }\n\n  // If we're not piping anywhere, then do nothing.\n  if (state.pipes.length === 0) return this\n  if (!dest) {\n    // remove all.\n    const dests = state.pipes\n    state.pipes = []\n    this.pause()\n    for (let i = 0; i < dests.length; i++)\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      })\n    return this\n  }\n\n  // Try to find the right one.\n  const index = ArrayPrototypeIndexOf(state.pipes, dest)\n  if (index === -1) return this\n  state.pipes.splice(index, 1)\n  if (state.pipes.length === 0) this.pause()\n  dest.emit('unpipe', this, unpipeInfo)\n  return this\n}\n\n// Set up data events if they are asked for\n// Ensure readable listeners eventually get something.\nReadable.prototype.on = function (ev, fn) {\n  const res = Stream.prototype.on.call(this, ev, fn)\n  const state = this._readableState\n  if (ev === 'data') {\n    // Update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0\n\n    // Try start flowing on next tick if stream isn't explicitly paused.\n    if (state.flowing !== false) this.resume()\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true\n      state.flowing = false\n      state.emittedReadable = false\n      debug('on readable', state.length, state.reading)\n      if (state.length) {\n        emitReadable(this)\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this)\n      }\n    }\n  }\n  return res\n}\nReadable.prototype.addListener = Readable.prototype.on\nReadable.prototype.removeListener = function (ev, fn) {\n  const res = Stream.prototype.removeListener.call(this, ev, fn)\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this)\n  }\n  return res\n}\nReadable.prototype.off = Readable.prototype.removeListener\nReadable.prototype.removeAllListeners = function (ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this, arguments)\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this)\n  }\n  return res\n}\nfunction updateReadableListening(self) {\n  const state = self._readableState\n  state.readableListening = self.listenerCount('readable') > 0\n  if (state.resumeScheduled && state[kPaused] === false) {\n    // Flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true\n\n    // Crude way to check if we should resume.\n  } else if (self.listenerCount('data') > 0) {\n    self.resume()\n  } else if (!state.readableListening) {\n    state.flowing = null\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0')\n  self.read(0)\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  const state = this._readableState\n  if (!state.flowing) {\n    debug('resume')\n    // We flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume().\n    state.flowing = !state.readableListening\n    resume(this, state)\n  }\n  state[kPaused] = false\n  return this\n}\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true\n    process.nextTick(resume_, stream, state)\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading)\n  if (!state.reading) {\n    stream.read(0)\n  }\n  state.resumeScheduled = false\n  stream.emit('resume')\n  flow(stream)\n  if (state.flowing && !state.reading) stream.read(0)\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing)\n  if (this._readableState.flowing !== false) {\n    debug('pause')\n    this._readableState.flowing = false\n    this.emit('pause')\n  }\n  this._readableState[kPaused] = true\n  return this\n}\nfunction flow(stream) {\n  const state = stream._readableState\n  debug('flow', state.flowing)\n  while (state.flowing && stream.read() !== null);\n}\n\n// Wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  let paused = false\n\n  // TODO (ronag): Should this.destroy(err) emit\n  // 'error' on the wrapped stream? Would require\n  // a static factory method, e.g. Readable.wrap(stream).\n\n  stream.on('data', (chunk) => {\n    if (!this.push(chunk) && stream.pause) {\n      paused = true\n      stream.pause()\n    }\n  })\n  stream.on('end', () => {\n    this.push(null)\n  })\n  stream.on('error', (err) => {\n    errorOrDestroy(this, err)\n  })\n  stream.on('close', () => {\n    this.destroy()\n  })\n  stream.on('destroy', () => {\n    this.destroy()\n  })\n  this._read = () => {\n    if (paused && stream.resume) {\n      paused = false\n      stream.resume()\n    }\n  }\n\n  // Proxy all the other methods. Important when wrapping filters and duplexes.\n  const streamKeys = ObjectKeys(stream)\n  for (let j = 1; j < streamKeys.length; j++) {\n    const i = streamKeys[j]\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = stream[i].bind(stream)\n    }\n  }\n  return this\n}\nReadable.prototype[SymbolAsyncIterator] = function () {\n  return streamToAsyncIterator(this)\n}\nReadable.prototype.iterator = function (options) {\n  if (options !== undefined) {\n    validateObject(options, 'options')\n  }\n  return streamToAsyncIterator(this, options)\n}\nfunction streamToAsyncIterator(stream, options) {\n  if (typeof stream.read !== 'function') {\n    stream = Readable.wrap(stream, {\n      objectMode: true\n    })\n  }\n  const iter = createAsyncIterator(stream, options)\n  iter.stream = stream\n  return iter\n}\nasync function* createAsyncIterator(stream, options) {\n  let callback = nop\n  function next(resolve) {\n    if (this === stream) {\n      callback()\n      callback = nop\n    } else {\n      callback = resolve\n    }\n  }\n  stream.on('readable', next)\n  let error\n  const cleanup = eos(\n    stream,\n    {\n      writable: false\n    },\n    (err) => {\n      error = err ? aggregateTwoErrors(error, err) : null\n      callback()\n      callback = nop\n    }\n  )\n  try {\n    while (true) {\n      const chunk = stream.destroyed ? null : stream.read()\n      if (chunk !== null) {\n        yield chunk\n      } else if (error) {\n        throw error\n      } else if (error === null) {\n        return\n      } else {\n        await new Promise(next)\n      }\n    }\n  } catch (err) {\n    error = aggregateTwoErrors(error, err)\n    throw error\n  } finally {\n    if (\n      (error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) &&\n      (error === undefined || stream._readableState.autoDestroy)\n    ) {\n      destroyImpl.destroyer(stream, null)\n    } else {\n      stream.off('readable', next)\n      cleanup()\n    }\n  }\n}\n\n// Making it explicit these properties are not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail.\nObjectDefineProperties(Readable.prototype, {\n  readable: {\n    __proto__: null,\n    get() {\n      const r = this._readableState\n      // r.readable === false means that this is part of a Duplex stream\n      // where the readable side was disabled upon construction.\n      // Compat. The user might manually disable readable side through\n      // deprecated setter.\n      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted\n    },\n    set(val) {\n      // Backwards compat.\n      if (this._readableState) {\n        this._readableState.readable = !!val\n      }\n    }\n  },\n  readableDidRead: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.dataEmitted\n    }\n  },\n  readableAborted: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return !!(\n        this._readableState.readable !== false &&\n        (this._readableState.destroyed || this._readableState.errored) &&\n        !this._readableState.endEmitted\n      )\n    }\n  },\n  readableHighWaterMark: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.highWaterMark\n    }\n  },\n  readableBuffer: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState && this._readableState.buffer\n    }\n  },\n  readableFlowing: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return this._readableState.flowing\n    },\n    set: function (state) {\n      if (this._readableState) {\n        this._readableState.flowing = state\n      }\n    }\n  },\n  readableLength: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState.length\n    }\n  },\n  readableObjectMode: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.objectMode : false\n    }\n  },\n  readableEncoding: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.encoding : null\n    }\n  },\n  errored: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.errored : null\n    }\n  },\n  closed: {\n    __proto__: null,\n    get() {\n      return this._readableState ? this._readableState.closed : false\n    }\n  },\n  destroyed: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.destroyed : false\n    },\n    set(value) {\n      // We ignore the value if the stream\n      // has not been initialized yet.\n      if (!this._readableState) {\n        return\n      }\n\n      // Backward compatibility, the user is explicitly\n      // managing destroyed.\n      this._readableState.destroyed = value\n    }\n  },\n  readableEnded: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.endEmitted : false\n    }\n  }\n})\nObjectDefineProperties(ReadableState.prototype, {\n  // Legacy getter for `pipesCount`.\n  pipesCount: {\n    __proto__: null,\n    get() {\n      return this.pipes.length\n    }\n  },\n  // Legacy property for `paused`.\n  paused: {\n    __proto__: null,\n    get() {\n      return this[kPaused] !== false\n    },\n    set(value) {\n      this[kPaused] = !!value\n    }\n  }\n})\n\n// Exposed for testing purposes only.\nReadable._fromList = fromList\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered.\n  if (state.length === 0) return null\n  let ret\n  if (state.objectMode) ret = state.buffer.shift()\n  else if (!n || n >= state.length) {\n    // Read it all, truncate the list.\n    if (state.decoder) ret = state.buffer.join('')\n    else if (state.buffer.length === 1) ret = state.buffer.first()\n    else ret = state.buffer.concat(state.length)\n    state.buffer.clear()\n  } else {\n    // read part of list.\n    ret = state.buffer.consume(n, state.decoder)\n  }\n  return ret\n}\nfunction endReadable(stream) {\n  const state = stream._readableState\n  debug('endReadable', state.endEmitted)\n  if (!state.endEmitted) {\n    state.ended = true\n    process.nextTick(endReadableNT, state, stream)\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length)\n\n  // Check that we didn't get one last unshift.\n  if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {\n    state.endEmitted = true\n    stream.emit('end')\n    if (stream.writable && stream.allowHalfOpen === false) {\n      process.nextTick(endWritableNT, stream)\n    } else if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well.\n      const wState = stream._writableState\n      const autoDestroy =\n        !wState ||\n        (wState.autoDestroy &&\n          // We don't expect the writable to ever 'finish'\n          // if writable is explicitly set to false.\n          (wState.finished || wState.writable === false))\n      if (autoDestroy) {\n        stream.destroy()\n      }\n    }\n  }\n}\nfunction endWritableNT(stream) {\n  const writable = stream.writable && !stream.writableEnded && !stream.destroyed\n  if (writable) {\n    stream.end()\n  }\n}\nReadable.from = function (iterable, opts) {\n  return from(Readable, iterable, opts)\n}\nlet webStreamsAdapters\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined) webStreamsAdapters = {}\n  return webStreamsAdapters\n}\nReadable.fromWeb = function (readableStream, options) {\n  return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options)\n}\nReadable.toWeb = function (streamReadable, options) {\n  return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options)\n}\nReadable.wrap = function (src, options) {\n  var _ref, _src$readableObjectMo\n  return new Readable({\n    objectMode:\n      (_ref =\n        (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined\n          ? _src$readableObjectMo\n          : src.objectMode) !== null && _ref !== undefined\n        ? _ref\n        : true,\n    ...options,\n    destroy(err, callback) {\n      destroyImpl.destroyer(src, err)\n      callback(err)\n    }\n  }).wrap(src)\n}\n","/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n;('use strict')\nconst {\n  ArrayPrototypeSlice,\n  Error,\n  FunctionPrototypeSymbolHasInstance,\n  ObjectDefineProperty,\n  ObjectDefineProperties,\n  ObjectSetPrototypeOf,\n  StringPrototypeToLowerCase,\n  Symbol,\n  SymbolHasInstance\n} = require('../../ours/primordials')\nmodule.exports = Writable\nWritable.WritableState = WritableState\nconst { EventEmitter: EE } = require('events')\nconst Stream = require('./legacy').Stream\nconst { Buffer } = require('buffer')\nconst destroyImpl = require('./destroy')\nconst { addAbortSignal } = require('./add-abort-signal')\nconst { getHighWaterMark, getDefaultHighWaterMark } = require('./state')\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED,\n  ERR_STREAM_ALREADY_FINISHED,\n  ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING\n} = require('../../ours/errors').codes\nconst { errorOrDestroy } = destroyImpl\nObjectSetPrototypeOf(Writable.prototype, Stream.prototype)\nObjectSetPrototypeOf(Writable, Stream)\nfunction nop() {}\nconst kOnFinished = Symbol('kOnFinished')\nfunction WritableState(options, stream, isDuplex) {\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof require('./duplex')\n\n  // Object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!(options && options.objectMode)\n  if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode)\n\n  // The point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write().\n  this.highWaterMark = options\n    ? getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex)\n    : getDefaultHighWaterMark(false)\n\n  // if _final has been called.\n  this.finalCalled = false\n\n  // drain event flag.\n  this.needDrain = false\n  // At the start of calling end()\n  this.ending = false\n  // When end() has been called, and returned.\n  this.ended = false\n  // When 'finish' is emitted.\n  this.finished = false\n\n  // Has it been destroyed\n  this.destroyed = false\n\n  // Should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  const noDecode = !!(options && options.decodeStrings === false)\n  this.decodeStrings = !noDecode\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8'\n\n  // Not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0\n\n  // A flag to see when we're in the middle of a write.\n  this.writing = false\n\n  // When true all writes will be buffered until .uncork() call.\n  this.corked = 0\n\n  // A flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true\n\n  // A flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false\n\n  // The callback that's passed to _write(chunk, cb).\n  this.onwrite = onwrite.bind(undefined, stream)\n\n  // The callback that the user supplies to write(chunk, encoding, cb).\n  this.writecb = null\n\n  // The amount that is being written when _write is called.\n  this.writelen = 0\n\n  // Storage for data passed to the afterWrite() callback in case of\n  // synchronous _write() completion.\n  this.afterWriteTickInfo = null\n  resetBuffer(this)\n\n  // Number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted.\n  this.pendingcb = 0\n\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in, therefore we start as\n  // constructed.\n  this.constructed = true\n\n  // Emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams.\n  this.prefinished = false\n\n  // True if the error was already emitted and should not be thrown again.\n  this.errorEmitted = false\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = !options || options.emitClose !== false\n\n  // Should .destroy() be called after 'finish' (and potentially 'end').\n  this.autoDestroy = !options || options.autoDestroy !== false\n\n  // Indicates whether the stream has errored. When true all write() calls\n  // should return false. This is needed since when autoDestroy\n  // is disabled we need a way to tell whether the stream has failed.\n  this.errored = null\n\n  // Indicates whether the stream has finished destroying.\n  this.closed = false\n\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  this.closeEmitted = false\n  this[kOnFinished] = []\n}\nfunction resetBuffer(state) {\n  state.buffered = []\n  state.bufferedIndex = 0\n  state.allBuffers = true\n  state.allNoop = true\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  return ArrayPrototypeSlice(this.buffered, this.bufferedIndex)\n}\nObjectDefineProperty(WritableState.prototype, 'bufferedRequestCount', {\n  __proto__: null,\n  get() {\n    return this.buffered.length - this.bufferedIndex\n  }\n})\nfunction Writable(options) {\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5.\n  const isDuplex = this instanceof require('./duplex')\n  if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options)\n  this._writableState = new WritableState(options, this, isDuplex)\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write\n    if (typeof options.writev === 'function') this._writev = options.writev\n    if (typeof options.destroy === 'function') this._destroy = options.destroy\n    if (typeof options.final === 'function') this._final = options.final\n    if (typeof options.construct === 'function') this._construct = options.construct\n    if (options.signal) addAbortSignal(options.signal, this)\n  }\n  Stream.call(this, options)\n  destroyImpl.construct(this, () => {\n    const state = this._writableState\n    if (!state.writing) {\n      clearBuffer(this, state)\n    }\n    finishMaybe(this, state)\n  })\n}\nObjectDefineProperty(Writable, SymbolHasInstance, {\n  __proto__: null,\n  value: function (object) {\n    if (FunctionPrototypeSymbolHasInstance(this, object)) return true\n    if (this !== Writable) return false\n    return object && object._writableState instanceof WritableState\n  }\n})\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE())\n}\nfunction _write(stream, chunk, encoding, cb) {\n  const state = stream._writableState\n  if (typeof encoding === 'function') {\n    cb = encoding\n    encoding = state.defaultEncoding\n  } else {\n    if (!encoding) encoding = state.defaultEncoding\n    else if (encoding !== 'buffer' && !Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)\n    if (typeof cb !== 'function') cb = nop\n  }\n  if (chunk === null) {\n    throw new ERR_STREAM_NULL_VALUES()\n  } else if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      if (state.decodeStrings !== false) {\n        chunk = Buffer.from(chunk, encoding)\n        encoding = 'buffer'\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = 'buffer'\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk)\n      encoding = 'buffer'\n    } else {\n      throw new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)\n    }\n  }\n  let err\n  if (state.ending) {\n    err = new ERR_STREAM_WRITE_AFTER_END()\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('write')\n  }\n  if (err) {\n    process.nextTick(cb, err)\n    errorOrDestroy(stream, err, true)\n    return err\n  }\n  state.pendingcb++\n  return writeOrBuffer(stream, state, chunk, encoding, cb)\n}\nWritable.prototype.write = function (chunk, encoding, cb) {\n  return _write(this, chunk, encoding, cb) === true\n}\nWritable.prototype.cork = function () {\n  this._writableState.corked++\n}\nWritable.prototype.uncork = function () {\n  const state = this._writableState\n  if (state.corked) {\n    state.corked--\n    if (!state.writing) clearBuffer(this, state)\n  }\n}\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = StringPrototypeToLowerCase(encoding)\n  if (!Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)\n  this._writableState.defaultEncoding = encoding\n  return this\n}\n\n// If we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, callback) {\n  const len = state.objectMode ? 1 : chunk.length\n  state.length += len\n\n  // stream._write resets state.length\n  const ret = state.length < state.highWaterMark\n  // We must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true\n  if (state.writing || state.corked || state.errored || !state.constructed) {\n    state.buffered.push({\n      chunk,\n      encoding,\n      callback\n    })\n    if (state.allBuffers && encoding !== 'buffer') {\n      state.allBuffers = false\n    }\n    if (state.allNoop && callback !== nop) {\n      state.allNoop = false\n    }\n  } else {\n    state.writelen = len\n    state.writecb = callback\n    state.writing = true\n    state.sync = true\n    stream._write(chunk, encoding, state.onwrite)\n    state.sync = false\n  }\n\n  // Return false if errored or destroyed in order to break\n  // any synchronous while(stream.write(data)) loops.\n  return ret && !state.errored && !state.destroyed\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len\n  state.writecb = cb\n  state.writing = true\n  state.sync = true\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'))\n  else if (writev) stream._writev(chunk, state.onwrite)\n  else stream._write(chunk, encoding, state.onwrite)\n  state.sync = false\n}\nfunction onwriteError(stream, state, er, cb) {\n  --state.pendingcb\n  cb(er)\n  // Ensure callbacks are invoked even when autoDestroy is\n  // not enabled. Passing `er` here doesn't make sense since\n  // it's related to one specific write, not to the buffered\n  // writes.\n  errorBuffer(state)\n  // This can emit error, but error must always follow cb.\n  errorOrDestroy(stream, er)\n}\nfunction onwrite(stream, er) {\n  const state = stream._writableState\n  const sync = state.sync\n  const cb = state.writecb\n  if (typeof cb !== 'function') {\n    errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK())\n    return\n  }\n  state.writing = false\n  state.writecb = null\n  state.length -= state.writelen\n  state.writelen = 0\n  if (er) {\n    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    er.stack // eslint-disable-line no-unused-expressions\n\n    if (!state.errored) {\n      state.errored = er\n    }\n\n    // In case of duplex streams we need to notify the readable side of the\n    // error.\n    if (stream._readableState && !stream._readableState.errored) {\n      stream._readableState.errored = er\n    }\n    if (sync) {\n      process.nextTick(onwriteError, stream, state, er, cb)\n    } else {\n      onwriteError(stream, state, er, cb)\n    }\n  } else {\n    if (state.buffered.length > state.bufferedIndex) {\n      clearBuffer(stream, state)\n    }\n    if (sync) {\n      // It is a common case that the callback passed to .write() is always\n      // the same. In that case, we do not schedule a new nextTick(), but\n      // rather just increase a counter, to improve performance and avoid\n      // memory allocations.\n      if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {\n        state.afterWriteTickInfo.count++\n      } else {\n        state.afterWriteTickInfo = {\n          count: 1,\n          cb,\n          stream,\n          state\n        }\n        process.nextTick(afterWriteTick, state.afterWriteTickInfo)\n      }\n    } else {\n      afterWrite(stream, state, 1, cb)\n    }\n  }\n}\nfunction afterWriteTick({ stream, state, count, cb }) {\n  state.afterWriteTickInfo = null\n  return afterWrite(stream, state, count, cb)\n}\nfunction afterWrite(stream, state, count, cb) {\n  const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain\n  if (needDrain) {\n    state.needDrain = false\n    stream.emit('drain')\n  }\n  while (count-- > 0) {\n    state.pendingcb--\n    cb()\n  }\n  if (state.destroyed) {\n    errorBuffer(state)\n  }\n  finishMaybe(stream, state)\n}\n\n// If there's something in the buffer waiting, then invoke callbacks.\nfunction errorBuffer(state) {\n  if (state.writing) {\n    return\n  }\n  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {\n    var _state$errored\n    const { chunk, callback } = state.buffered[n]\n    const len = state.objectMode ? 1 : chunk.length\n    state.length -= len\n    callback(\n      (_state$errored = state.errored) !== null && _state$errored !== undefined\n        ? _state$errored\n        : new ERR_STREAM_DESTROYED('write')\n    )\n  }\n  const onfinishCallbacks = state[kOnFinished].splice(0)\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    var _state$errored2\n    onfinishCallbacks[i](\n      (_state$errored2 = state.errored) !== null && _state$errored2 !== undefined\n        ? _state$errored2\n        : new ERR_STREAM_DESTROYED('end')\n    )\n  }\n  resetBuffer(state)\n}\n\n// If there's something in the buffer waiting, then process it.\nfunction clearBuffer(stream, state) {\n  if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {\n    return\n  }\n  const { buffered, bufferedIndex, objectMode } = state\n  const bufferedLength = buffered.length - bufferedIndex\n  if (!bufferedLength) {\n    return\n  }\n  let i = bufferedIndex\n  state.bufferProcessing = true\n  if (bufferedLength > 1 && stream._writev) {\n    state.pendingcb -= bufferedLength - 1\n    const callback = state.allNoop\n      ? nop\n      : (err) => {\n          for (let n = i; n < buffered.length; ++n) {\n            buffered[n].callback(err)\n          }\n        }\n    // Make a copy of `buffered` if it's going to be used by `callback` above,\n    // since `doWrite` will mutate the array.\n    const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i)\n    chunks.allBuffers = state.allBuffers\n    doWrite(stream, state, true, state.length, chunks, '', callback)\n    resetBuffer(state)\n  } else {\n    do {\n      const { chunk, encoding, callback } = buffered[i]\n      buffered[i++] = null\n      const len = objectMode ? 1 : chunk.length\n      doWrite(stream, state, false, len, chunk, encoding, callback)\n    } while (i < buffered.length && !state.writing)\n    if (i === buffered.length) {\n      resetBuffer(state)\n    } else if (i > 256) {\n      buffered.splice(0, i)\n      state.bufferedIndex = 0\n    } else {\n      state.bufferedIndex = i\n    }\n  }\n  state.bufferProcessing = false\n}\nWritable.prototype._write = function (chunk, encoding, cb) {\n  if (this._writev) {\n    this._writev(\n      [\n        {\n          chunk,\n          encoding\n        }\n      ],\n      cb\n    )\n  } else {\n    throw new ERR_METHOD_NOT_IMPLEMENTED('_write()')\n  }\n}\nWritable.prototype._writev = null\nWritable.prototype.end = function (chunk, encoding, cb) {\n  const state = this._writableState\n  if (typeof chunk === 'function') {\n    cb = chunk\n    chunk = null\n    encoding = null\n  } else if (typeof encoding === 'function') {\n    cb = encoding\n    encoding = null\n  }\n  let err\n  if (chunk !== null && chunk !== undefined) {\n    const ret = _write(this, chunk, encoding)\n    if (ret instanceof Error) {\n      err = ret\n    }\n  }\n\n  // .end() fully uncorks.\n  if (state.corked) {\n    state.corked = 1\n    this.uncork()\n  }\n  if (err) {\n    // Do nothing...\n  } else if (!state.errored && !state.ending) {\n    // This is forgiving in terms of unnecessary calls to end() and can hide\n    // logic errors. However, usually such errors are harmless and causing a\n    // hard error can be disproportionately destructive. It is not always\n    // trivial for the user to determine whether end() needs to be called\n    // or not.\n\n    state.ending = true\n    finishMaybe(this, state, true)\n    state.ended = true\n  } else if (state.finished) {\n    err = new ERR_STREAM_ALREADY_FINISHED('end')\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('end')\n  }\n  if (typeof cb === 'function') {\n    if (err || state.finished) {\n      process.nextTick(cb, err)\n    } else {\n      state[kOnFinished].push(cb)\n    }\n  }\n  return this\n}\nfunction needFinish(state) {\n  return (\n    state.ending &&\n    !state.destroyed &&\n    state.constructed &&\n    state.length === 0 &&\n    !state.errored &&\n    state.buffered.length === 0 &&\n    !state.finished &&\n    !state.writing &&\n    !state.errorEmitted &&\n    !state.closeEmitted\n  )\n}\nfunction callFinal(stream, state) {\n  let called = false\n  function onFinish(err) {\n    if (called) {\n      errorOrDestroy(stream, err !== null && err !== undefined ? err : ERR_MULTIPLE_CALLBACK())\n      return\n    }\n    called = true\n    state.pendingcb--\n    if (err) {\n      const onfinishCallbacks = state[kOnFinished].splice(0)\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\n        onfinishCallbacks[i](err)\n      }\n      errorOrDestroy(stream, err, state.sync)\n    } else if (needFinish(state)) {\n      state.prefinished = true\n      stream.emit('prefinish')\n      // Backwards compat. Don't check state.sync here.\n      // Some streams assume 'finish' will be emitted\n      // asynchronously relative to _final callback.\n      state.pendingcb++\n      process.nextTick(finish, stream, state)\n    }\n  }\n  state.sync = true\n  state.pendingcb++\n  try {\n    stream._final(onFinish)\n  } catch (err) {\n    onFinish(err)\n  }\n  state.sync = false\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.finalCalled = true\n      callFinal(stream, state)\n    } else {\n      state.prefinished = true\n      stream.emit('prefinish')\n    }\n  }\n}\nfunction finishMaybe(stream, state, sync) {\n  if (needFinish(state)) {\n    prefinish(stream, state)\n    if (state.pendingcb === 0) {\n      if (sync) {\n        state.pendingcb++\n        process.nextTick(\n          (stream, state) => {\n            if (needFinish(state)) {\n              finish(stream, state)\n            } else {\n              state.pendingcb--\n            }\n          },\n          stream,\n          state\n        )\n      } else if (needFinish(state)) {\n        state.pendingcb++\n        finish(stream, state)\n      }\n    }\n  }\n}\nfunction finish(stream, state) {\n  state.pendingcb--\n  state.finished = true\n  const onfinishCallbacks = state[kOnFinished].splice(0)\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    onfinishCallbacks[i]()\n  }\n  stream.emit('finish')\n  if (state.autoDestroy) {\n    // In case of duplex streams we need a way to detect\n    // if the readable side is ready for autoDestroy as well.\n    const rState = stream._readableState\n    const autoDestroy =\n      !rState ||\n      (rState.autoDestroy &&\n        // We don't expect the readable to ever 'end'\n        // if readable is explicitly set to false.\n        (rState.endEmitted || rState.readable === false))\n    if (autoDestroy) {\n      stream.destroy()\n    }\n  }\n}\nObjectDefineProperties(Writable.prototype, {\n  closed: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.closed : false\n    }\n  },\n  destroyed: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.destroyed : false\n    },\n    set(value) {\n      // Backward compatibility, the user is explicitly managing destroyed.\n      if (this._writableState) {\n        this._writableState.destroyed = value\n      }\n    }\n  },\n  writable: {\n    __proto__: null,\n    get() {\n      const w = this._writableState\n      // w.writable === false means that this is part of a Duplex stream\n      // where the writable side was disabled upon construction.\n      // Compat. The user might manually disable writable side through\n      // deprecated setter.\n      return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended\n    },\n    set(val) {\n      // Backwards compatible.\n      if (this._writableState) {\n        this._writableState.writable = !!val\n      }\n    }\n  },\n  writableFinished: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.finished : false\n    }\n  },\n  writableObjectMode: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.objectMode : false\n    }\n  },\n  writableBuffer: {\n    __proto__: null,\n    get() {\n      return this._writableState && this._writableState.getBuffer()\n    }\n  },\n  writableEnded: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.ending : false\n    }\n  },\n  writableNeedDrain: {\n    __proto__: null,\n    get() {\n      const wState = this._writableState\n      if (!wState) return false\n      return !wState.destroyed && !wState.ending && wState.needDrain\n    }\n  },\n  writableHighWaterMark: {\n    __proto__: null,\n    get() {\n      return this._writableState && this._writableState.highWaterMark\n    }\n  },\n  writableCorked: {\n    __proto__: null,\n    get() {\n      return this._writableState ? this._writableState.corked : 0\n    }\n  },\n  writableLength: {\n    __proto__: null,\n    get() {\n      return this._writableState && this._writableState.length\n    }\n  },\n  errored: {\n    __proto__: null,\n    enumerable: false,\n    get() {\n      return this._writableState ? this._writableState.errored : null\n    }\n  },\n  writableAborted: {\n    __proto__: null,\n    enumerable: false,\n    get: function () {\n      return !!(\n        this._writableState.writable !== false &&\n        (this._writableState.destroyed || this._writableState.errored) &&\n        !this._writableState.finished\n      )\n    }\n  }\n})\nconst destroy = destroyImpl.destroy\nWritable.prototype.destroy = function (err, cb) {\n  const state = this._writableState\n\n  // Invoke pending callbacks.\n  if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {\n    process.nextTick(errorBuffer, state)\n  }\n  destroy.call(this, err, cb)\n  return this\n}\nWritable.prototype._undestroy = destroyImpl.undestroy\nWritable.prototype._destroy = function (err, cb) {\n  cb(err)\n}\nWritable.prototype[EE.captureRejectionSymbol] = function (err) {\n  this.destroy(err)\n}\nlet webStreamsAdapters\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined) webStreamsAdapters = {}\n  return webStreamsAdapters\n}\nWritable.fromWeb = function (writableStream, options) {\n  return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options)\n}\nWritable.toWeb = function (streamWritable) {\n  return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable)\n}\n","/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n\n;('use strict')\nconst bufferModule = require('buffer')\nconst {\n  isReadable,\n  isWritable,\n  isIterable,\n  isNodeStream,\n  isReadableNodeStream,\n  isWritableNodeStream,\n  isDuplexNodeStream,\n  isReadableStream,\n  isWritableStream\n} = require('./utils')\nconst eos = require('./end-of-stream')\nconst {\n  AbortError,\n  codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }\n} = require('../../ours/errors')\nconst { destroyer } = require('./destroy')\nconst Duplex = require('./duplex')\nconst Readable = require('./readable')\nconst Writable = require('./writable')\nconst { createDeferredPromise } = require('../../ours/util')\nconst from = require('./from')\nconst Blob = globalThis.Blob || bufferModule.Blob\nconst isBlob =\n  typeof Blob !== 'undefined'\n    ? function isBlob(b) {\n        return b instanceof Blob\n      }\n    : function isBlob(b) {\n        return false\n      }\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nconst { FunctionPrototypeCall } = require('../../ours/primordials')\n\n// This is needed for pre node 17.\nclass Duplexify extends Duplex {\n  constructor(options) {\n    super(options)\n\n    // https://github.com/nodejs/node/pull/34385\n\n    if ((options === null || options === undefined ? undefined : options.readable) === false) {\n      this._readableState.readable = false\n      this._readableState.ended = true\n      this._readableState.endEmitted = true\n    }\n    if ((options === null || options === undefined ? undefined : options.writable) === false) {\n      this._writableState.writable = false\n      this._writableState.ending = true\n      this._writableState.ended = true\n      this._writableState.finished = true\n    }\n  }\n}\nmodule.exports = function duplexify(body, name) {\n  if (isDuplexNodeStream(body)) {\n    return body\n  }\n  if (isReadableNodeStream(body)) {\n    return _duplexify({\n      readable: body\n    })\n  }\n  if (isWritableNodeStream(body)) {\n    return _duplexify({\n      writable: body\n    })\n  }\n  if (isNodeStream(body)) {\n    return _duplexify({\n      writable: false,\n      readable: false\n    })\n  }\n  if (isReadableStream(body)) {\n    return _duplexify({\n      readable: Readable.fromWeb(body)\n    })\n  }\n  if (isWritableStream(body)) {\n    return _duplexify({\n      writable: Writable.fromWeb(body)\n    })\n  }\n  if (typeof body === 'function') {\n    const { value, write, final, destroy } = fromAsyncGen(body)\n    if (isIterable(value)) {\n      return from(Duplexify, value, {\n        // TODO (ronag): highWaterMark?\n        objectMode: true,\n        write,\n        final,\n        destroy\n      })\n    }\n    const then = value === null || value === undefined ? undefined : value.then\n    if (typeof then === 'function') {\n      let d\n      const promise = FunctionPrototypeCall(\n        then,\n        value,\n        (val) => {\n          if (val != null) {\n            throw new ERR_INVALID_RETURN_VALUE('nully', 'body', val)\n          }\n        },\n        (err) => {\n          destroyer(d, err)\n        }\n      )\n      return (d = new Duplexify({\n        // TODO (ronag): highWaterMark?\n        objectMode: true,\n        readable: false,\n        write,\n        final(cb) {\n          final(async () => {\n            try {\n              await promise\n              process.nextTick(cb, null)\n            } catch (err) {\n              process.nextTick(cb, err)\n            }\n          })\n        },\n        destroy\n      }))\n    }\n    throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or AsyncFunction', name, value)\n  }\n  if (isBlob(body)) {\n    return duplexify(body.arrayBuffer())\n  }\n  if (isIterable(body)) {\n    return from(Duplexify, body, {\n      // TODO (ronag): highWaterMark?\n      objectMode: true,\n      writable: false\n    })\n  }\n  if (\n    isReadableStream(body === null || body === undefined ? undefined : body.readable) &&\n    isWritableStream(body === null || body === undefined ? undefined : body.writable)\n  ) {\n    return Duplexify.fromWeb(body)\n  }\n  if (\n    typeof (body === null || body === undefined ? undefined : body.writable) === 'object' ||\n    typeof (body === null || body === undefined ? undefined : body.readable) === 'object'\n  ) {\n    const readable =\n      body !== null && body !== undefined && body.readable\n        ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable)\n          ? body === null || body === undefined\n            ? undefined\n            : body.readable\n          : duplexify(body.readable)\n        : undefined\n    const writable =\n      body !== null && body !== undefined && body.writable\n        ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable)\n          ? body === null || body === undefined\n            ? undefined\n            : body.writable\n          : duplexify(body.writable)\n        : undefined\n    return _duplexify({\n      readable,\n      writable\n    })\n  }\n  const then = body === null || body === undefined ? undefined : body.then\n  if (typeof then === 'function') {\n    let d\n    FunctionPrototypeCall(\n      then,\n      body,\n      (val) => {\n        if (val != null) {\n          d.push(val)\n        }\n        d.push(null)\n      },\n      (err) => {\n        destroyer(d, err)\n      }\n    )\n    return (d = new Duplexify({\n      objectMode: true,\n      writable: false,\n      read() {}\n    }))\n  }\n  throw new ERR_INVALID_ARG_TYPE(\n    name,\n    [\n      'Blob',\n      'ReadableStream',\n      'WritableStream',\n      'Stream',\n      'Iterable',\n      'AsyncIterable',\n      'Function',\n      '{ readable, writable } pair',\n      'Promise'\n    ],\n    body\n  )\n}\nfunction fromAsyncGen(fn) {\n  let { promise, resolve } = createDeferredPromise()\n  const ac = new AbortController()\n  const signal = ac.signal\n  const value = fn(\n    (async function* () {\n      while (true) {\n        const _promise = promise\n        promise = null\n        const { chunk, done, cb } = await _promise\n        process.nextTick(cb)\n        if (done) return\n        if (signal.aborted)\n          throw new AbortError(undefined, {\n            cause: signal.reason\n          })\n        ;({ promise, resolve } = createDeferredPromise())\n        yield chunk\n      }\n    })(),\n    {\n      signal\n    }\n  )\n  return {\n    value,\n    write(chunk, encoding, cb) {\n      const _resolve = resolve\n      resolve = null\n      _resolve({\n        chunk,\n        done: false,\n        cb\n      })\n    },\n    final(cb) {\n      const _resolve = resolve\n      resolve = null\n      _resolve({\n        done: true,\n        cb\n      })\n    },\n    destroy(err, cb) {\n      ac.abort()\n      cb(err)\n    }\n  }\n}\nfunction _duplexify(pair) {\n  const r = pair.readable && typeof pair.readable.read !== 'function' ? Readable.wrap(pair.readable) : pair.readable\n  const w = pair.writable\n  let readable = !!isReadable(r)\n  let writable = !!isWritable(w)\n  let ondrain\n  let onfinish\n  let onreadable\n  let onclose\n  let d\n  function onfinished(err) {\n    const cb = onclose\n    onclose = null\n    if (cb) {\n      cb(err)\n    } else if (err) {\n      d.destroy(err)\n    }\n  }\n\n  // TODO(ronag): Avoid double buffering.\n  // Implement Writable/Readable/Duplex traits.\n  // See, https://github.com/nodejs/node/pull/33515.\n  d = new Duplexify({\n    // TODO (ronag): highWaterMark?\n    readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode),\n    writableObjectMode: !!(w !== null && w !== undefined && w.writableObjectMode),\n    readable,\n    writable\n  })\n  if (writable) {\n    eos(w, (err) => {\n      writable = false\n      if (err) {\n        destroyer(r, err)\n      }\n      onfinished(err)\n    })\n    d._write = function (chunk, encoding, callback) {\n      if (w.write(chunk, encoding)) {\n        callback()\n      } else {\n        ondrain = callback\n      }\n    }\n    d._final = function (callback) {\n      w.end()\n      onfinish = callback\n    }\n    w.on('drain', function () {\n      if (ondrain) {\n        const cb = ondrain\n        ondrain = null\n        cb()\n      }\n    })\n    w.on('finish', function () {\n      if (onfinish) {\n        const cb = onfinish\n        onfinish = null\n        cb()\n      }\n    })\n  }\n  if (readable) {\n    eos(r, (err) => {\n      readable = false\n      if (err) {\n        destroyer(r, err)\n      }\n      onfinished(err)\n    })\n    r.on('readable', function () {\n      if (onreadable) {\n        const cb = onreadable\n        onreadable = null\n        cb()\n      }\n    })\n    r.on('end', function () {\n      d.push(null)\n    })\n    d._read = function () {\n      while (true) {\n        const buf = r.read()\n        if (buf === null) {\n          onreadable = d._read\n          return\n        }\n        if (!d.push(buf)) {\n          return\n        }\n      }\n    }\n  }\n  d._destroy = function (err, callback) {\n    if (!err && onclose !== null) {\n      err = new AbortError()\n    }\n    onreadable = null\n    ondrain = null\n    onfinish = null\n    if (onclose === null) {\n      callback(err)\n    } else {\n      onclose = callback\n      destroyer(w, err)\n      destroyer(r, err)\n    }\n  }\n  return d\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototype inheritance, this class\n// prototypically inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict'\n\nconst {\n  ObjectDefineProperties,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectKeys,\n  ObjectSetPrototypeOf\n} = require('../../ours/primordials')\nmodule.exports = Duplex\nconst Readable = require('./readable')\nconst Writable = require('./writable')\nObjectSetPrototypeOf(Duplex.prototype, Readable.prototype)\nObjectSetPrototypeOf(Duplex, Readable)\n{\n  const keys = ObjectKeys(Writable.prototype)\n  // Allow the keys array to be GC'ed.\n  for (let i = 0; i < keys.length; i++) {\n    const method = keys[i]\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method]\n  }\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options)\n  Readable.call(this, options)\n  Writable.call(this, options)\n  if (options) {\n    this.allowHalfOpen = options.allowHalfOpen !== false\n    if (options.readable === false) {\n      this._readableState.readable = false\n      this._readableState.ended = true\n      this._readableState.endEmitted = true\n    }\n    if (options.writable === false) {\n      this._writableState.writable = false\n      this._writableState.ending = true\n      this._writableState.ended = true\n      this._writableState.finished = true\n    }\n  } else {\n    this.allowHalfOpen = true\n  }\n}\nObjectDefineProperties(Duplex.prototype, {\n  writable: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writable')\n  },\n  writableHighWaterMark: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableHighWaterMark')\n  },\n  writableObjectMode: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableObjectMode')\n  },\n  writableBuffer: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableBuffer')\n  },\n  writableLength: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableLength')\n  },\n  writableFinished: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableFinished')\n  },\n  writableCorked: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableCorked')\n  },\n  writableEnded: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableEnded')\n  },\n  writableNeedDrain: {\n    __proto__: null,\n    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableNeedDrain')\n  },\n  destroyed: {\n    __proto__: null,\n    get() {\n      if (this._readableState === undefined || this._writableState === undefined) {\n        return false\n      }\n      return this._readableState.destroyed && this._writableState.destroyed\n    },\n    set(value) {\n      // Backward compatibility, the user is explicitly\n      // managing destroyed.\n      if (this._readableState && this._writableState) {\n        this._readableState.destroyed = value\n        this._writableState.destroyed = value\n      }\n    }\n  }\n})\nlet webStreamsAdapters\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined) webStreamsAdapters = {}\n  return webStreamsAdapters\n}\nDuplex.fromWeb = function (pair, options) {\n  return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options)\n}\nDuplex.toWeb = function (duplex) {\n  return lazyWebStreams().newReadableWritablePairFromDuplex(duplex)\n}\nlet duplexify\nDuplex.from = function (body) {\n  if (!duplexify) {\n    duplexify = require('./duplexify')\n  }\n  return duplexify(body, 'body')\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict'\n\nconst { ObjectSetPrototypeOf, Symbol } = require('../../ours/primordials')\nmodule.exports = Transform\nconst { ERR_METHOD_NOT_IMPLEMENTED } = require('../../ours/errors').codes\nconst Duplex = require('./duplex')\nconst { getHighWaterMark } = require('./state')\nObjectSetPrototypeOf(Transform.prototype, Duplex.prototype)\nObjectSetPrototypeOf(Transform, Duplex)\nconst kCallback = Symbol('kCallback')\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options)\n\n  // TODO (ronag): This should preferably always be\n  // applied but would be semver-major. Or even better;\n  // make Transform a Readable with the Writable interface.\n  const readableHighWaterMark = options ? getHighWaterMark(this, options, 'readableHighWaterMark', true) : null\n  if (readableHighWaterMark === 0) {\n    // A Duplex will buffer both on the writable and readable side while\n    // a Transform just wants to buffer hwm number of elements. To avoid\n    // buffering twice we disable buffering on the writable side.\n    options = {\n      ...options,\n      highWaterMark: null,\n      readableHighWaterMark,\n      // TODO (ronag): 0 is not optimal since we have\n      // a \"bug\" where we check needDrain before calling _write and not after.\n      // Refs: https://github.com/nodejs/node/pull/32887\n      // Refs: https://github.com/nodejs/node/pull/35941\n      writableHighWaterMark: options.writableHighWaterMark || 0\n    }\n  }\n  Duplex.call(this, options)\n\n  // We have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false\n  this[kCallback] = null\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform\n    if (typeof options.flush === 'function') this._flush = options.flush\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  // Backwards compat. Some Transform streams incorrectly implement _final\n  // instead of or in addition to _flush. By using 'prefinish' instead of\n  // implementing _final we continue supporting this unfortunate use case.\n  this.on('prefinish', prefinish)\n}\nfunction final(cb) {\n  if (typeof this._flush === 'function' && !this.destroyed) {\n    this._flush((er, data) => {\n      if (er) {\n        if (cb) {\n          cb(er)\n        } else {\n          this.destroy(er)\n        }\n        return\n      }\n      if (data != null) {\n        this.push(data)\n      }\n      this.push(null)\n      if (cb) {\n        cb()\n      }\n    })\n  } else {\n    this.push(null)\n    if (cb) {\n      cb()\n    }\n  }\n}\nfunction prefinish() {\n  if (this._final !== final) {\n    final.call(this)\n  }\n}\nTransform.prototype._final = final\nTransform.prototype._transform = function (chunk, encoding, callback) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_transform()')\n}\nTransform.prototype._write = function (chunk, encoding, callback) {\n  const rState = this._readableState\n  const wState = this._writableState\n  const length = rState.length\n  this._transform(chunk, encoding, (err, val) => {\n    if (err) {\n      callback(err)\n      return\n    }\n    if (val != null) {\n      this.push(val)\n    }\n    if (\n      wState.ended ||\n      // Backwards compat.\n      length === rState.length ||\n      // Backwards compat.\n      rState.length < rState.highWaterMark\n    ) {\n      callback()\n    } else {\n      this[kCallback] = callback\n    }\n  })\n}\nTransform.prototype._read = function () {\n  if (this[kCallback]) {\n    const callback = this[kCallback]\n    this[kCallback] = null\n    callback()\n  }\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict'\n\nconst { ObjectSetPrototypeOf } = require('../../ours/primordials')\nmodule.exports = PassThrough\nconst Transform = require('./transform')\nObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype)\nObjectSetPrototypeOf(PassThrough, Transform)\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options)\n  Transform.call(this, options)\n}\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk)\n}\n","/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n;('use strict')\nconst { ArrayIsArray, Promise, SymbolAsyncIterator, SymbolDispose } = require('../../ours/primordials')\nconst eos = require('./end-of-stream')\nconst { once } = require('../../ours/util')\nconst destroyImpl = require('./destroy')\nconst Duplex = require('./duplex')\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_RETURN_VALUE,\n    ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED,\n    ERR_STREAM_PREMATURE_CLOSE\n  },\n  AbortError\n} = require('../../ours/errors')\nconst { validateFunction, validateAbortSignal } = require('../validators')\nconst {\n  isIterable,\n  isReadable,\n  isReadableNodeStream,\n  isNodeStream,\n  isTransformStream,\n  isWebStream,\n  isReadableStream,\n  isReadableFinished\n} = require('./utils')\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nlet PassThrough\nlet Readable\nlet addAbortListener\nfunction destroyer(stream, reading, writing) {\n  let finished = false\n  stream.on('close', () => {\n    finished = true\n  })\n  const cleanup = eos(\n    stream,\n    {\n      readable: reading,\n      writable: writing\n    },\n    (err) => {\n      finished = !err\n    }\n  )\n  return {\n    destroy: (err) => {\n      if (finished) return\n      finished = true\n      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'))\n    },\n    cleanup\n  }\n}\nfunction popCallback(streams) {\n  // Streams should never be an empty array. It should always contain at least\n  // a single stream. Therefore optimize for the average case instead of\n  // checking for length === 0 as well.\n  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]')\n  return streams.pop()\n}\nfunction makeAsyncIterable(val) {\n  if (isIterable(val)) {\n    return val\n  } else if (isReadableNodeStream(val)) {\n    // Legacy streams are not Iterable.\n    return fromReadable(val)\n  }\n  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val)\n}\nasync function* fromReadable(val) {\n  if (!Readable) {\n    Readable = require('./readable')\n  }\n  yield* Readable.prototype[SymbolAsyncIterator].call(val)\n}\nasync function pumpToNode(iterable, writable, finish, { end }) {\n  let error\n  let onresolve = null\n  const resume = (err) => {\n    if (err) {\n      error = err\n    }\n    if (onresolve) {\n      const callback = onresolve\n      onresolve = null\n      callback()\n    }\n  }\n  const wait = () =>\n    new Promise((resolve, reject) => {\n      if (error) {\n        reject(error)\n      } else {\n        onresolve = () => {\n          if (error) {\n            reject(error)\n          } else {\n            resolve()\n          }\n        }\n      }\n    })\n  writable.on('drain', resume)\n  const cleanup = eos(\n    writable,\n    {\n      readable: false\n    },\n    resume\n  )\n  try {\n    if (writable.writableNeedDrain) {\n      await wait()\n    }\n    for await (const chunk of iterable) {\n      if (!writable.write(chunk)) {\n        await wait()\n      }\n    }\n    if (end) {\n      writable.end()\n      await wait()\n    }\n    finish()\n  } catch (err) {\n    finish(error !== err ? aggregateTwoErrors(error, err) : err)\n  } finally {\n    cleanup()\n    writable.off('drain', resume)\n  }\n}\nasync function pumpToWeb(readable, writable, finish, { end }) {\n  if (isTransformStream(writable)) {\n    writable = writable.writable\n  }\n  // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure\n  const writer = writable.getWriter()\n  try {\n    for await (const chunk of readable) {\n      await writer.ready\n      writer.write(chunk).catch(() => {})\n    }\n    await writer.ready\n    if (end) {\n      await writer.close()\n    }\n    finish()\n  } catch (err) {\n    try {\n      await writer.abort(err)\n      finish(err)\n    } catch (err) {\n      finish(err)\n    }\n  }\n}\nfunction pipeline(...streams) {\n  return pipelineImpl(streams, once(popCallback(streams)))\n}\nfunction pipelineImpl(streams, callback, opts) {\n  if (streams.length === 1 && ArrayIsArray(streams[0])) {\n    streams = streams[0]\n  }\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams')\n  }\n  const ac = new AbortController()\n  const signal = ac.signal\n  const outerSignal = opts === null || opts === undefined ? undefined : opts.signal\n\n  // Need to cleanup event listeners if last stream is readable\n  // https://github.com/nodejs/node/issues/35452\n  const lastStreamCleanup = []\n  validateAbortSignal(outerSignal, 'options.signal')\n  function abort() {\n    finishImpl(new AbortError())\n  }\n  addAbortListener = addAbortListener || require('../../ours/util').addAbortListener\n  let disposable\n  if (outerSignal) {\n    disposable = addAbortListener(outerSignal, abort)\n  }\n  let error\n  let value\n  const destroys = []\n  let finishCount = 0\n  function finish(err) {\n    finishImpl(err, --finishCount === 0)\n  }\n  function finishImpl(err, final) {\n    var _disposable\n    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {\n      error = err\n    }\n    if (!error && !final) {\n      return\n    }\n    while (destroys.length) {\n      destroys.shift()(error)\n    }\n    ;(_disposable = disposable) === null || _disposable === undefined ? undefined : _disposable[SymbolDispose]()\n    ac.abort()\n    if (final) {\n      if (!error) {\n        lastStreamCleanup.forEach((fn) => fn())\n      }\n      process.nextTick(callback, error, value)\n    }\n  }\n  let ret\n  for (let i = 0; i < streams.length; i++) {\n    const stream = streams[i]\n    const reading = i < streams.length - 1\n    const writing = i > 0\n    const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false\n    const isLastStream = i === streams.length - 1\n    if (isNodeStream(stream)) {\n      if (end) {\n        const { destroy, cleanup } = destroyer(stream, reading, writing)\n        destroys.push(destroy)\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n\n      // Catch stream errors that occur after pipe/pump has completed.\n      function onError(err) {\n        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n          finish(err)\n        }\n      }\n      stream.on('error', onError)\n      if (isReadable(stream) && isLastStream) {\n        lastStreamCleanup.push(() => {\n          stream.removeListener('error', onError)\n        })\n      }\n    }\n    if (i === 0) {\n      if (typeof stream === 'function') {\n        ret = stream({\n          signal\n        })\n        if (!isIterable(ret)) {\n          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret)\n        }\n      } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {\n        ret = stream\n      } else {\n        ret = Duplex.from(stream)\n      }\n    } else if (typeof stream === 'function') {\n      if (isTransformStream(ret)) {\n        var _ret\n        ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable)\n      } else {\n        ret = makeAsyncIterable(ret)\n      }\n      ret = stream(ret, {\n        signal\n      })\n      if (reading) {\n        if (!isIterable(ret, true)) {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', `transform[${i - 1}]`, ret)\n        }\n      } else {\n        var _ret2\n        if (!PassThrough) {\n          PassThrough = require('./passthrough')\n        }\n\n        // If the last argument to pipeline is not a stream\n        // we must create a proxy stream so that pipeline(...)\n        // always returns a stream which can be further\n        // composed through `.pipe(stream)`.\n\n        const pt = new PassThrough({\n          objectMode: true\n        })\n\n        // Handle Promises/A+ spec, `then` could be a getter that throws on\n        // second use.\n        const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then\n        if (typeof then === 'function') {\n          finishCount++\n          then.call(\n            ret,\n            (val) => {\n              value = val\n              if (val != null) {\n                pt.write(val)\n              }\n              if (end) {\n                pt.end()\n              }\n              process.nextTick(finish)\n            },\n            (err) => {\n              pt.destroy(err)\n              process.nextTick(finish, err)\n            }\n          )\n        } else if (isIterable(ret, true)) {\n          finishCount++\n          pumpToNode(ret, pt, finish, {\n            end\n          })\n        } else if (isReadableStream(ret) || isTransformStream(ret)) {\n          const toRead = ret.readable || ret\n          finishCount++\n          pumpToNode(toRead, pt, finish, {\n            end\n          })\n        } else {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret)\n        }\n        ret = pt\n        const { destroy, cleanup } = destroyer(ret, false, true)\n        destroys.push(destroy)\n        if (isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n    } else if (isNodeStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount += 2\n        const cleanup = pipe(ret, stream, finish, {\n          end\n        })\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      } else if (isTransformStream(ret) || isReadableStream(ret)) {\n        const toRead = ret.readable || ret\n        finishCount++\n        pumpToNode(toRead, stream, finish, {\n          end\n        })\n      } else if (isIterable(ret)) {\n        finishCount++\n        pumpToNode(ret, stream, finish, {\n          end\n        })\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val',\n          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],\n          ret\n        )\n      }\n      ret = stream\n    } else if (isWebStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount++\n        pumpToWeb(makeAsyncIterable(ret), stream, finish, {\n          end\n        })\n      } else if (isReadableStream(ret) || isIterable(ret)) {\n        finishCount++\n        pumpToWeb(ret, stream, finish, {\n          end\n        })\n      } else if (isTransformStream(ret)) {\n        finishCount++\n        pumpToWeb(ret.readable, stream, finish, {\n          end\n        })\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val',\n          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],\n          ret\n        )\n      }\n      ret = stream\n    } else {\n      ret = Duplex.from(stream)\n    }\n  }\n  if (\n    (signal !== null && signal !== undefined && signal.aborted) ||\n    (outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)\n  ) {\n    process.nextTick(abort)\n  }\n  return ret\n}\nfunction pipe(src, dst, finish, { end }) {\n  let ended = false\n  dst.on('close', () => {\n    if (!ended) {\n      // Finish if the destination closes before the source has completed.\n      finish(new ERR_STREAM_PREMATURE_CLOSE())\n    }\n  })\n  src.pipe(dst, {\n    end: false\n  }) // If end is true we already will have a listener to end dst.\n\n  if (end) {\n    // Compat. Before node v10.12.0 stdio used to throw an error so\n    // pipe() did/does not end() stdio destinations.\n    // Now they allow it but \"secretly\" don't close the underlying fd.\n\n    function endFn() {\n      ended = true\n      dst.end()\n    }\n    if (isReadableFinished(src)) {\n      // End the destination if the source has already ended.\n      process.nextTick(endFn)\n    } else {\n      src.once('end', endFn)\n    }\n  } else {\n    finish()\n  }\n  eos(\n    src,\n    {\n      readable: true,\n      writable: false\n    },\n    (err) => {\n      const rState = src._readableState\n      if (\n        err &&\n        err.code === 'ERR_STREAM_PREMATURE_CLOSE' &&\n        rState &&\n        rState.ended &&\n        !rState.errored &&\n        !rState.errorEmitted\n      ) {\n        // Some readable streams will emit 'close' before 'end'. However, since\n        // this is on the readable side 'end' should still be emitted if the\n        // stream has been ended and no error emitted. This should be allowed in\n        // favor of backwards compatibility. Since the stream is piped to a\n        // destination this should not result in any observable difference.\n        // We don't need to check if this is a writable premature close since\n        // eos will only fail with premature close on the reading side for\n        // duplex streams.\n        src.once('end', finish).once('error', finish)\n      } else {\n        finish(err)\n      }\n    }\n  )\n  return eos(\n    dst,\n    {\n      readable: false,\n      writable: true\n    },\n    finish\n  )\n}\nmodule.exports = {\n  pipelineImpl,\n  pipeline\n}\n","'use strict'\n\nconst { pipeline } = require('./pipeline')\nconst Duplex = require('./duplex')\nconst { destroyer } = require('./destroy')\nconst {\n  isNodeStream,\n  isReadable,\n  isWritable,\n  isWebStream,\n  isTransformStream,\n  isWritableStream,\n  isReadableStream\n} = require('./utils')\nconst {\n  AbortError,\n  codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }\n} = require('../../ours/errors')\nconst eos = require('./end-of-stream')\nmodule.exports = function compose(...streams) {\n  if (streams.length === 0) {\n    throw new ERR_MISSING_ARGS('streams')\n  }\n  if (streams.length === 1) {\n    return Duplex.from(streams[0])\n  }\n  const orgStreams = [...streams]\n  if (typeof streams[0] === 'function') {\n    streams[0] = Duplex.from(streams[0])\n  }\n  if (typeof streams[streams.length - 1] === 'function') {\n    const idx = streams.length - 1\n    streams[idx] = Duplex.from(streams[idx])\n  }\n  for (let n = 0; n < streams.length; ++n) {\n    if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {\n      // TODO(ronag): Add checks for non streams.\n      continue\n    }\n    if (\n      n < streams.length - 1 &&\n      !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))\n    ) {\n      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be readable')\n    }\n    if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {\n      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be writable')\n    }\n  }\n  let ondrain\n  let onfinish\n  let onreadable\n  let onclose\n  let d\n  function onfinished(err) {\n    const cb = onclose\n    onclose = null\n    if (cb) {\n      cb(err)\n    } else if (err) {\n      d.destroy(err)\n    } else if (!readable && !writable) {\n      d.destroy()\n    }\n  }\n  const head = streams[0]\n  const tail = pipeline(streams, onfinished)\n  const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head))\n  const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail))\n\n  // TODO(ronag): Avoid double buffering.\n  // Implement Writable/Readable/Duplex traits.\n  // See, https://github.com/nodejs/node/pull/33515.\n  d = new Duplex({\n    // TODO (ronag): highWaterMark?\n    writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode),\n    readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode),\n    writable,\n    readable\n  })\n  if (writable) {\n    if (isNodeStream(head)) {\n      d._write = function (chunk, encoding, callback) {\n        if (head.write(chunk, encoding)) {\n          callback()\n        } else {\n          ondrain = callback\n        }\n      }\n      d._final = function (callback) {\n        head.end()\n        onfinish = callback\n      }\n      head.on('drain', function () {\n        if (ondrain) {\n          const cb = ondrain\n          ondrain = null\n          cb()\n        }\n      })\n    } else if (isWebStream(head)) {\n      const writable = isTransformStream(head) ? head.writable : head\n      const writer = writable.getWriter()\n      d._write = async function (chunk, encoding, callback) {\n        try {\n          await writer.ready\n          writer.write(chunk).catch(() => {})\n          callback()\n        } catch (err) {\n          callback(err)\n        }\n      }\n      d._final = async function (callback) {\n        try {\n          await writer.ready\n          writer.close().catch(() => {})\n          onfinish = callback\n        } catch (err) {\n          callback(err)\n        }\n      }\n    }\n    const toRead = isTransformStream(tail) ? tail.readable : tail\n    eos(toRead, () => {\n      if (onfinish) {\n        const cb = onfinish\n        onfinish = null\n        cb()\n      }\n    })\n  }\n  if (readable) {\n    if (isNodeStream(tail)) {\n      tail.on('readable', function () {\n        if (onreadable) {\n          const cb = onreadable\n          onreadable = null\n          cb()\n        }\n      })\n      tail.on('end', function () {\n        d.push(null)\n      })\n      d._read = function () {\n        while (true) {\n          const buf = tail.read()\n          if (buf === null) {\n            onreadable = d._read\n            return\n          }\n          if (!d.push(buf)) {\n            return\n          }\n        }\n      }\n    } else if (isWebStream(tail)) {\n      const readable = isTransformStream(tail) ? tail.readable : tail\n      const reader = readable.getReader()\n      d._read = async function () {\n        while (true) {\n          try {\n            const { value, done } = await reader.read()\n            if (!d.push(value)) {\n              return\n            }\n            if (done) {\n              d.push(null)\n              return\n            }\n          } catch {\n            return\n          }\n        }\n      }\n    }\n  }\n  d._destroy = function (err, callback) {\n    if (!err && onclose !== null) {\n      err = new AbortError()\n    }\n    onreadable = null\n    ondrain = null\n    onfinish = null\n    if (onclose === null) {\n      callback(err)\n    } else {\n      onclose = callback\n      if (isNodeStream(tail)) {\n        destroyer(tail, err)\n      }\n    }\n  }\n  return d\n}\n","'use strict'\n\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nconst {\n  codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },\n  AbortError\n} = require('../../ours/errors')\nconst { validateAbortSignal, validateInteger, validateObject } = require('../validators')\nconst kWeakHandler = require('../../ours/primordials').Symbol('kWeak')\nconst kResistStopPropagation = require('../../ours/primordials').Symbol('kResistStopPropagation')\nconst { finished } = require('./end-of-stream')\nconst staticCompose = require('./compose')\nconst { addAbortSignalNoValidate } = require('./add-abort-signal')\nconst { isWritable, isNodeStream } = require('./utils')\nconst { deprecate } = require('../../ours/util')\nconst {\n  ArrayPrototypePush,\n  Boolean,\n  MathFloor,\n  Number,\n  NumberIsNaN,\n  Promise,\n  PromiseReject,\n  PromiseResolve,\n  PromisePrototypeThen,\n  Symbol\n} = require('../../ours/primordials')\nconst kEmpty = Symbol('kEmpty')\nconst kEof = Symbol('kEof')\nfunction compose(stream, options) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  if (isNodeStream(stream) && !isWritable(stream)) {\n    throw new ERR_INVALID_ARG_VALUE('stream', stream, 'must be writable')\n  }\n  const composedStream = staticCompose(this, stream)\n  if (options !== null && options !== undefined && options.signal) {\n    // Not validating as we already validated before\n    addAbortSignalNoValidate(options.signal, composedStream)\n  }\n  return composedStream\n}\nfunction map(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  let concurrency = 1\n  if ((options === null || options === undefined ? undefined : options.concurrency) != null) {\n    concurrency = MathFloor(options.concurrency)\n  }\n  let highWaterMark = concurrency - 1\n  if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) {\n    highWaterMark = MathFloor(options.highWaterMark)\n  }\n  validateInteger(concurrency, 'options.concurrency', 1)\n  validateInteger(highWaterMark, 'options.highWaterMark', 0)\n  highWaterMark += concurrency\n  return async function* map() {\n    const signal = require('../../ours/util').AbortSignalAny(\n      [options === null || options === undefined ? undefined : options.signal].filter(Boolean)\n    )\n    const stream = this\n    const queue = []\n    const signalOpt = {\n      signal\n    }\n    let next\n    let resume\n    let done = false\n    let cnt = 0\n    function onCatch() {\n      done = true\n      afterItemProcessed()\n    }\n    function afterItemProcessed() {\n      cnt -= 1\n      maybeResume()\n    }\n    function maybeResume() {\n      if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {\n        resume()\n        resume = null\n      }\n    }\n    async function pump() {\n      try {\n        for await (let val of stream) {\n          if (done) {\n            return\n          }\n          if (signal.aborted) {\n            throw new AbortError()\n          }\n          try {\n            val = fn(val, signalOpt)\n            if (val === kEmpty) {\n              continue\n            }\n            val = PromiseResolve(val)\n          } catch (err) {\n            val = PromiseReject(err)\n          }\n          cnt += 1\n          PromisePrototypeThen(val, afterItemProcessed, onCatch)\n          queue.push(val)\n          if (next) {\n            next()\n            next = null\n          }\n          if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {\n            await new Promise((resolve) => {\n              resume = resolve\n            })\n          }\n        }\n        queue.push(kEof)\n      } catch (err) {\n        const val = PromiseReject(err)\n        PromisePrototypeThen(val, afterItemProcessed, onCatch)\n        queue.push(val)\n      } finally {\n        done = true\n        if (next) {\n          next()\n          next = null\n        }\n      }\n    }\n    pump()\n    try {\n      while (true) {\n        while (queue.length > 0) {\n          const val = await queue[0]\n          if (val === kEof) {\n            return\n          }\n          if (signal.aborted) {\n            throw new AbortError()\n          }\n          if (val !== kEmpty) {\n            yield val\n          }\n          queue.shift()\n          maybeResume()\n        }\n        await new Promise((resolve) => {\n          next = resolve\n        })\n      }\n    } finally {\n      done = true\n      if (resume) {\n        resume()\n        resume = null\n      }\n    }\n  }.call(this)\n}\nfunction asIndexedPairs(options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  return async function* asIndexedPairs() {\n    let index = 0\n    for await (const val of this) {\n      var _options$signal\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal = options.signal) !== null &&\n        _options$signal !== undefined &&\n        _options$signal.aborted\n      ) {\n        throw new AbortError({\n          cause: options.signal.reason\n        })\n      }\n      yield [index++, val]\n    }\n  }.call(this)\n}\nasync function some(fn, options = undefined) {\n  for await (const unused of filter.call(this, fn, options)) {\n    return true\n  }\n  return false\n}\nasync function every(fn, options = undefined) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  // https://en.wikipedia.org/wiki/De_Morgan%27s_laws\n  return !(await some.call(\n    this,\n    async (...args) => {\n      return !(await fn(...args))\n    },\n    options\n  ))\n}\nasync function find(fn, options) {\n  for await (const result of filter.call(this, fn, options)) {\n    return result\n  }\n  return undefined\n}\nasync function forEach(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  async function forEachFn(value, options) {\n    await fn(value, options)\n    return kEmpty\n  }\n  // eslint-disable-next-line no-unused-vars\n  for await (const unused of map.call(this, forEachFn, options));\n}\nfunction filter(fn, options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)\n  }\n  async function filterFn(value, options) {\n    if (await fn(value, options)) {\n      return value\n    }\n    return kEmpty\n  }\n  return map.call(this, filterFn, options)\n}\n\n// Specific to provide better error to reduce since the argument is only\n// missing if the stream has no items in it - but the code is still appropriate\nclass ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {\n  constructor() {\n    super('reduce')\n    this.message = 'Reduce of an empty stream requires an initial value'\n  }\n}\nasync function reduce(reducer, initialValue, options) {\n  var _options$signal2\n  if (typeof reducer !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('reducer', ['Function', 'AsyncFunction'], reducer)\n  }\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  let hasInitialValue = arguments.length > 1\n  if (\n    options !== null &&\n    options !== undefined &&\n    (_options$signal2 = options.signal) !== null &&\n    _options$signal2 !== undefined &&\n    _options$signal2.aborted\n  ) {\n    const err = new AbortError(undefined, {\n      cause: options.signal.reason\n    })\n    this.once('error', () => {}) // The error is already propagated\n    await finished(this.destroy(err))\n    throw err\n  }\n  const ac = new AbortController()\n  const signal = ac.signal\n  if (options !== null && options !== undefined && options.signal) {\n    const opts = {\n      once: true,\n      [kWeakHandler]: this,\n      [kResistStopPropagation]: true\n    }\n    options.signal.addEventListener('abort', () => ac.abort(), opts)\n  }\n  let gotAnyItemFromStream = false\n  try {\n    for await (const value of this) {\n      var _options$signal3\n      gotAnyItemFromStream = true\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal3 = options.signal) !== null &&\n        _options$signal3 !== undefined &&\n        _options$signal3.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (!hasInitialValue) {\n        initialValue = value\n        hasInitialValue = true\n      } else {\n        initialValue = await reducer(initialValue, value, {\n          signal\n        })\n      }\n    }\n    if (!gotAnyItemFromStream && !hasInitialValue) {\n      throw new ReduceAwareErrMissingArgs()\n    }\n  } finally {\n    ac.abort()\n  }\n  return initialValue\n}\nasync function toArray(options) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  const result = []\n  for await (const val of this) {\n    var _options$signal4\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal4 = options.signal) !== null &&\n      _options$signal4 !== undefined &&\n      _options$signal4.aborted\n    ) {\n      throw new AbortError(undefined, {\n        cause: options.signal.reason\n      })\n    }\n    ArrayPrototypePush(result, val)\n  }\n  return result\n}\nfunction flatMap(fn, options) {\n  const values = map.call(this, fn, options)\n  return async function* flatMap() {\n    for await (const val of values) {\n      yield* val\n    }\n  }.call(this)\n}\nfunction toIntegerOrInfinity(number) {\n  // We coerce here to align with the spec\n  // https://github.com/tc39/proposal-iterator-helpers/issues/169\n  number = Number(number)\n  if (NumberIsNaN(number)) {\n    return 0\n  }\n  if (number < 0) {\n    throw new ERR_OUT_OF_RANGE('number', '>= 0', number)\n  }\n  return number\n}\nfunction drop(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  number = toIntegerOrInfinity(number)\n  return async function* drop() {\n    var _options$signal5\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal5 = options.signal) !== null &&\n      _options$signal5 !== undefined &&\n      _options$signal5.aborted\n    ) {\n      throw new AbortError()\n    }\n    for await (const val of this) {\n      var _options$signal6\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal6 = options.signal) !== null &&\n        _options$signal6 !== undefined &&\n        _options$signal6.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (number-- <= 0) {\n        yield val\n      }\n    }\n  }.call(this)\n}\nfunction take(number, options = undefined) {\n  if (options != null) {\n    validateObject(options, 'options')\n  }\n  if ((options === null || options === undefined ? undefined : options.signal) != null) {\n    validateAbortSignal(options.signal, 'options.signal')\n  }\n  number = toIntegerOrInfinity(number)\n  return async function* take() {\n    var _options$signal7\n    if (\n      options !== null &&\n      options !== undefined &&\n      (_options$signal7 = options.signal) !== null &&\n      _options$signal7 !== undefined &&\n      _options$signal7.aborted\n    ) {\n      throw new AbortError()\n    }\n    for await (const val of this) {\n      var _options$signal8\n      if (\n        options !== null &&\n        options !== undefined &&\n        (_options$signal8 = options.signal) !== null &&\n        _options$signal8 !== undefined &&\n        _options$signal8.aborted\n      ) {\n        throw new AbortError()\n      }\n      if (number-- > 0) {\n        yield val\n      }\n\n      // Don't get another item from iterator in case we reached the end\n      if (number <= 0) {\n        return\n      }\n    }\n  }.call(this)\n}\nmodule.exports.streamReturningOperators = {\n  asIndexedPairs: deprecate(asIndexedPairs, 'readable.asIndexedPairs will be removed in a future version.'),\n  drop,\n  filter,\n  flatMap,\n  map,\n  take,\n  compose\n}\nmodule.exports.promiseReturningOperators = {\n  every,\n  forEach,\n  reduce,\n  toArray,\n  some,\n  find\n}\n","'use strict'\n\nconst { ArrayPrototypePop, Promise } = require('../ours/primordials')\nconst { isIterable, isNodeStream, isWebStream } = require('../internal/streams/utils')\nconst { pipelineImpl: pl } = require('../internal/streams/pipeline')\nconst { finished } = require('../internal/streams/end-of-stream')\nrequire('../../lib/stream.js')\nfunction pipeline(...streams) {\n  return new Promise((resolve, reject) => {\n    let signal\n    let end\n    const lastArg = streams[streams.length - 1]\n    if (\n      lastArg &&\n      typeof lastArg === 'object' &&\n      !isNodeStream(lastArg) &&\n      !isIterable(lastArg) &&\n      !isWebStream(lastArg)\n    ) {\n      const options = ArrayPrototypePop(streams)\n      signal = options.signal\n      end = options.end\n    }\n    pl(\n      streams,\n      (err, value) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(value)\n        }\n      },\n      {\n        signal,\n        end\n      }\n    )\n  })\n}\nmodule.exports = {\n  finished,\n  pipeline\n}\n","/* replacement start */\n\nconst { Buffer } = require('buffer')\n\n/* replacement end */\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n;('use strict')\nconst { ObjectDefineProperty, ObjectKeys, ReflectApply } = require('./ours/primordials')\nconst {\n  promisify: { custom: customPromisify }\n} = require('./ours/util')\nconst { streamReturningOperators, promiseReturningOperators } = require('./internal/streams/operators')\nconst {\n  codes: { ERR_ILLEGAL_CONSTRUCTOR }\n} = require('./ours/errors')\nconst compose = require('./internal/streams/compose')\nconst { setDefaultHighWaterMark, getDefaultHighWaterMark } = require('./internal/streams/state')\nconst { pipeline } = require('./internal/streams/pipeline')\nconst { destroyer } = require('./internal/streams/destroy')\nconst eos = require('./internal/streams/end-of-stream')\nconst internalBuffer = {}\nconst promises = require('./stream/promises')\nconst utils = require('./internal/streams/utils')\nconst Stream = (module.exports = require('./internal/streams/legacy').Stream)\nStream.isDestroyed = utils.isDestroyed\nStream.isDisturbed = utils.isDisturbed\nStream.isErrored = utils.isErrored\nStream.isReadable = utils.isReadable\nStream.isWritable = utils.isWritable\nStream.Readable = require('./internal/streams/readable')\nfor (const key of ObjectKeys(streamReturningOperators)) {\n  const op = streamReturningOperators[key]\n  function fn(...args) {\n    if (new.target) {\n      throw ERR_ILLEGAL_CONSTRUCTOR()\n    }\n    return Stream.Readable.from(ReflectApply(op, this, args))\n  }\n  ObjectDefineProperty(fn, 'name', {\n    __proto__: null,\n    value: op.name\n  })\n  ObjectDefineProperty(fn, 'length', {\n    __proto__: null,\n    value: op.length\n  })\n  ObjectDefineProperty(Stream.Readable.prototype, key, {\n    __proto__: null,\n    value: fn,\n    enumerable: false,\n    configurable: true,\n    writable: true\n  })\n}\nfor (const key of ObjectKeys(promiseReturningOperators)) {\n  const op = promiseReturningOperators[key]\n  function fn(...args) {\n    if (new.target) {\n      throw ERR_ILLEGAL_CONSTRUCTOR()\n    }\n    return ReflectApply(op, this, args)\n  }\n  ObjectDefineProperty(fn, 'name', {\n    __proto__: null,\n    value: op.name\n  })\n  ObjectDefineProperty(fn, 'length', {\n    __proto__: null,\n    value: op.length\n  })\n  ObjectDefineProperty(Stream.Readable.prototype, key, {\n    __proto__: null,\n    value: fn,\n    enumerable: false,\n    configurable: true,\n    writable: true\n  })\n}\nStream.Writable = require('./internal/streams/writable')\nStream.Duplex = require('./internal/streams/duplex')\nStream.Transform = require('./internal/streams/transform')\nStream.PassThrough = require('./internal/streams/passthrough')\nStream.pipeline = pipeline\nconst { addAbortSignal } = require('./internal/streams/add-abort-signal')\nStream.addAbortSignal = addAbortSignal\nStream.finished = eos\nStream.destroy = destroyer\nStream.compose = compose\nStream.setDefaultHighWaterMark = setDefaultHighWaterMark\nStream.getDefaultHighWaterMark = getDefaultHighWaterMark\nObjectDefineProperty(Stream, 'promises', {\n  __proto__: null,\n  configurable: true,\n  enumerable: true,\n  get() {\n    return promises\n  }\n})\nObjectDefineProperty(pipeline, customPromisify, {\n  __proto__: null,\n  enumerable: true,\n  get() {\n    return promises.pipeline\n  }\n})\nObjectDefineProperty(eos, customPromisify, {\n  __proto__: null,\n  enumerable: true,\n  get() {\n    return promises.finished\n  }\n})\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream\nStream._isUint8Array = function isUint8Array(value) {\n  return value instanceof Uint8Array\n}\nStream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n}\n","'use strict'\n\nconst CustomStream = require('../stream')\nconst promises = require('../stream/promises')\nconst originalDestroy = CustomStream.Readable.destroy\nmodule.exports = CustomStream.Readable\n\n// Explicit export naming is needed for ESM\nmodule.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer\nmodule.exports._isUint8Array = CustomStream._isUint8Array\nmodule.exports.isDisturbed = CustomStream.isDisturbed\nmodule.exports.isErrored = CustomStream.isErrored\nmodule.exports.isReadable = CustomStream.isReadable\nmodule.exports.Readable = CustomStream.Readable\nmodule.exports.Writable = CustomStream.Writable\nmodule.exports.Duplex = CustomStream.Duplex\nmodule.exports.Transform = CustomStream.Transform\nmodule.exports.PassThrough = CustomStream.PassThrough\nmodule.exports.addAbortSignal = CustomStream.addAbortSignal\nmodule.exports.finished = CustomStream.finished\nmodule.exports.destroy = CustomStream.destroy\nmodule.exports.destroy = originalDestroy\nmodule.exports.pipeline = CustomStream.pipeline\nmodule.exports.compose = CustomStream.compose\nObject.defineProperty(CustomStream, 'promises', {\n  configurable: true,\n  enumerable: true,\n  get() {\n    return promises\n  }\n})\nmodule.exports.Stream = CustomStream.Stream\n\n// Allow default importing\nmodule.exports.default = module.exports\n","import rdf from '@rdfjs/data-model'\nimport toReadable from 'duplex-to/readable.js'\nimport { JsonLdParser } from 'jsonld-streaming-parser'\nimport { Transform } from 'readable-stream'\n\nconst relativeIriProtocol = 'null:'\n\nfunction termCleanup (factory) {\n  return term => {\n    if (term.termType !== 'NamedNode') {\n      return null\n    }\n\n    if (!term.value.startsWith(relativeIriProtocol)) {\n      return null\n    }\n\n    // remove dummy protocol workaround for relative IRIs\n    return factory.namedNode(term.value.slice(relativeIriProtocol.length))\n  }\n}\n\nfunction quadCleanup (factory) {\n  const cleanup = termCleanup(factory)\n\n  return quad => {\n    const subject = cleanup(quad.subject)\n    const predicate = cleanup(quad.predicate)\n    const object = cleanup(quad.object)\n    const graph = cleanup(quad.graph)\n\n    if (subject || predicate || object || graph) {\n      return factory.quad(\n        subject || quad.subject,\n        predicate || quad.predicate,\n        object || quad.object,\n        graph || quad.graph\n      )\n    }\n\n    return quad\n  }\n}\n\nclass ParserStream {\n  constructor (input, { baseIRI = relativeIriProtocol, context = null, documentLoader, factory = rdf } = {}) {\n    const parser = new JsonLdParser({\n      baseIRI,\n      context,\n      dataFactory: factory,\n      documentLoader,\n      streamingProfile: false\n    })\n\n    input.pipe(parser)\n\n    const cleanup = quadCleanup(factory)\n\n    const transform = new Transform({\n      objectMode: true,\n      transform: (quad, encoding, callback) => {\n        callback(null, cleanup(quad))\n      }\n    })\n\n    parser.on('context', context => {\n      Object.entries(context).forEach(([prefix, iri]) => {\n        transform.emit('prefix', prefix, factory.namedNode(iri))\n      })\n    })\n    parser.on('error', err => transform.destroy(err))\n    parser.pipe(transform)\n\n    return toReadable(transform)\n  }\n}\n\nexport default ParserStream\n","import Sink from '@rdfjs/sink'\nimport ParserStream from './lib/ParserStream.js'\n\nclass Parser extends Sink {\n  constructor (options) {\n    super(ParserStream, options)\n  }\n}\n\nexport default Parser\n"],"names":["self","exports","support","isDataView","obj","viewClasses","isArrayBufferView","normalizeName","name","normalizeValue","value","iteratorFor","items","iterator","Headers","headers","header","oldValue","callback","thisArg","consumed","body","fileReaderReady","reader","resolve","reject","readBlobAsArrayBuffer","blob","promise","readBlobAsText","readArrayBufferAsText","buf","view","chars","i","bufferClone","Body","rejected","decode","methods","normalizeMethod","method","upcased","Request","input","options","form","bytes","split","parseHeaders","rawHeaders","preProcessedHeaders","line","parts","key","Response","bodyInit","response","redirectStatuses","url","status","message","error","fetch","init","request","xhr","abortXhr","this","ErrorCoded","code","ERROR_CODES","COMPATIBLE_ENCODING_PATTERN","WS_TRIM_PATTERN","WS_CHAR_PATTERN","WS_FOLD_PATTERN","DELIMITER_PATTERN","WS_DELIMITER_PATTERN","TOKEN_PATTERN","STATE","trim","hasWhitespace","skipWhitespace","offset","needsQuotes","shallowCompareObjects","object1","object2","Link","links","type","attr","link","ref","state","length","end","attrValue","refs","rels","rel","data","encoding","language","encodedValue","Buffer","item","FetchDocumentLoader_1","ErrorCoded_1","require$$1","http_link_header_1","require$$2","relative_to_absolute_iri_1","require$$3","FetchDocumentLoader","fetcher","mediaType","colonPos","alternateUrl","linkHeader","Util_1","Util$1","Util","term","context","separatorPos","prefix","contextValue","id","keyword","prefixIri","iri","objKeys1","objKeys2","value1","value2","require$$0","JsonLdContextNormalized","contextRaw","expandVocab","validIriMapping","vocab","vocabRelative","base","potentialKeyword","contextPrefixValue","shortestPrefixing","contextIri","suffix","ContextParser_1","JsonLdContextNormalized_1","require$$4","require$$5","ContextParser","strictRange","errorCode","strictValues","expandContentTypeToBase","keys","keyValue","changed","canAddIdEntry","newId","expandedType","processingMode","normalizeLanguageTags","lowercase","newValue","containerValue","expandOptions","contextBefore","contextAfter","valueType","objectKey","objectValue","inheritFromParent","baseIRI","parentContext","e","internalOptions","external","ignoreProtection","minimalProcessing","remoteContexts","overriddenLoad","parsedStringContext","contextIris","contexts","subContext","reducedContexts","accContextPromise","contextEntry","accContext","importContext","newContext","overlappingKeys","newContextWrapped","cached","document","importContextIri","IDocumentLoader","JsonLdContext","__createBinding","o","m","k","k2","desc","__exportStar","p","require$$6","primordials","el","sep","fn","start","thisArgs","args","instance","props","prop","target","proto","thenFn","catchFn","err","val","len","bufferModule","kResistStopPropagation","SymbolDispose","AbortSignal","AbortController","AsyncFunction","Blob","isBlob","b","validateAbortSignal","signal","validateFunction","AggregateError","errors","module","called","res","rej","format","_unused","replacement","arr","listener","removeEventListener","_removeEventListener","signals","ac","abort","inspect","CustomAggregateError","kIsNodeError","kTypes","classRegExp","nodeInternalPrefix","codes","assert","addNumericalSeparator","getMessage","msg","expectedLength","E","Base","NodeError","hideStackFrames","hidden","aggregateTwoErrors","innerError","outerError","expected","actual","types","instances","other","pos","last","_actual$constructor","inspected","reason","_value$constructor","a","str","range","received","AbortError","ArrayIsArray","ArrayPrototypeIncludes","ArrayPrototypeJoin","ArrayPrototypeMap","NumberIsInteger","NumberIsNaN","NumberMAX_SAFE_INTEGER","NumberMIN_SAFE_INTEGER","NumberParseInt","ObjectPrototypeHasOwnProperty","RegExpPrototypeExec","String","StringPrototypeToUpperCase","StringPrototypeTrim","ERR_SOCKET_BAD_PORT","ERR_INVALID_ARG_TYPE","ERR_INVALID_ARG_VALUE","ERR_OUT_OF_RANGE","ERR_UNKNOWN_SIGNAL","normalizeEncoding","isAsyncFunction","isInt32","isUint32","octalReg","modeDesc","parseFileMode","def","validateUint32","validateInteger","min","max","validateInt32","positive","validateString","validateNumber","validateOneOf","oneOf","v","validateBoolean","getOwnPropertyValueOrDefault","defaultValue","validateObject","allowArray","allowFunction","validateDictionary","validateArray","minLength","validateStringArray","validateBooleanArray","validateAbortSignalArray","indexedName","validateSignalName","validateBuffer","buffer","validateEncoding","normalizedEncoding","validatePort","port","allowZero","validatePlainFunction","validateUndefined","validateUnion","union","linkValueRegExp","validateLinkHeaderFormat","validateLinkHeaderValue","hints","hintsLength","result","validators","SymbolAsyncIterator","SymbolIterator","SymbolFor","kIsDestroyed","kIsErrored","kIsReadable","kIsWritable","kIsDisturbed","kIsClosedPromise","kControllerErrorFunction","isReadableNodeStream","strict","_obj$_readableState","isWritableNodeStream","_obj$_writableState","isDuplexNodeStream","isNodeStream","isReadableStream","isWritableStream","isTransformStream","isWebStream","isIterable","isAsync","isDestroyed","stream","wState","rState","isWritableEnded","isWritableFinished","isReadableEnded","isReadableFinished","isReadable","isWritable","isFinished","opts","isWritableErrored","_stream$_writableStat","_stream$_writableStat2","isReadableErrored","_stream$_readableStat","_stream$_readableStat2","isClosed","isOutgoingMessage","isServerResponse","isServerRequest","_stream$req","willEmitClose","isDisturbed","_stream$kIsDisturbed","isErrored","_ref","_ref2","_ref3","_ref4","_ref5","_stream$kIsErrored","_stream$_readableStat3","_stream$_writableStat3","_stream$_readableStat4","_stream$_writableStat4","utils","process","ERR_STREAM_PREMATURE_CLOSE","kEmptyObject","once","Promise","PromisePrototypeThen","_willEmitClose","addAbortListener","isRequest","nop","eos","_options$readable","_options$writable","eosWeb","readable","writable","onlegacyfinish","onfinish","writableFinished","readableFinished","onend","onerror","closed","onclose","errored","onclosed","onrequest","cleanup","endCallback","disposable","originalCallback","isAborted","resolverFn","finished","_opts","autoCleanup","endOfStreamModule","ERR_MULTIPLE_CALLBACK","Symbol","kDestroy","kConstruct","checkError","w","destroy","cb","s","_destroy","er","onDestroy","r","emitErrorCloseNT","emitCloseNT","emitErrorNT","undestroy","errorOrDestroy","sync","construct","constructNT","onConstruct","emitConstructNT","emitCloseLegacy","emitErrorCloseLegacy","destroyer","destroy_1","ObjectSetPrototypeOf","EE","Stream","dest","source","ondata","chunk","ondrain","didOnEnd","prependListener","emitter","event","legacy","onAbort","StringPrototypeSlice","TypedArrayPrototypeSet","Uint8Array","buffer_list","entry","ret","n","hasStrings","slice","c","retLen","_","MathFloor","defaultHighWaterMarkBytes","defaultHighWaterMarkObjectMode","highWaterMarkFrom","isDuplex","duplexKey","getDefaultHighWaterMark","objectMode","setDefaultHighWaterMark","getHighWaterMark","hwm","ERR_STREAM_NULL_VALUES","from","Readable","iterable","reading","next","close","hadError","hasThrow","done","from_1","ArrayPrototypeIndexOf","ObjectDefineProperties","ObjectKeys","SafeSet","SymbolAsyncDispose","ReadableState","addAbortSignal","debug","require$$7","BufferList","require$$8","destroyImpl","require$$9","require$$10","ERR_METHOD_NOT_IMPLEMENTED","ERR_STREAM_PUSH_AFTER_EOF","ERR_STREAM_UNSHIFT_AFTER_END_EVENT","require$$11","require$$12","kPaused","StringDecoder","require$$13","require$$14","kObjectMode","kEnded","kEndEmitted","kReading","kConstructed","kSync","kNeedReadable","kEmittedReadable","kReadableListening","kResumeScheduled","kErrorEmitted","kEmitClose","kAutoDestroy","kDestroyed","kClosed","kCloseEmitted","kMultiAwaitDrain","kReadingMore","kDataEmitted","makeBitMapDescriptor","bit","require$$15","maybeReadMore","readableAddChunk","addToFront","onEofChunk","addChunk","emitReadable","enc","decoder","content","MAX_HWM","computeNewHighWaterMark","howMuchToRead","nOrig","endReadable","doRead","fromList","emitReadable_","flow","maybeReadMore_","pipeOpts","src","endFn","unpipe","onunpipe","unpipeInfo","cleanedUp","pause","pipeOnDrain","dests","index","ev","nReadingNextTick","updateReadableListening","resume","resume_","paused","streamKeys","j","streamToAsyncIterator","iter","createAsyncIterator","endReadableNT","endWritableNT","webStreamsAdapters","lazyWebStreams","readableStream","streamReadable","_src$readableObjectMo","ArrayPrototypeSlice","Error","FunctionPrototypeSymbolHasInstance","ObjectDefineProperty","StringPrototypeToLowerCase","SymbolHasInstance","Writable","WritableState","ERR_STREAM_CANNOT_PIPE","ERR_STREAM_DESTROYED","ERR_STREAM_ALREADY_FINISHED","ERR_STREAM_WRITE_AFTER_END","ERR_UNKNOWN_ENCODING","kOnFinished","noDecode","onwrite","resetBuffer","clearBuffer","finishMaybe","object","_write","writeOrBuffer","doWrite","writev","onwriteError","errorBuffer","afterWriteTick","afterWrite","count","_state$errored","onfinishCallbacks","_state$errored2","buffered","bufferedIndex","bufferedLength","chunks","needFinish","callFinal","onFinish","finish","prefinish","writableStream","streamWritable","ERR_INVALID_RETURN_VALUE","Duplex","createDeferredPromise","FunctionPrototypeCall","Duplexify","duplexify","_duplexify","write","final","fromAsyncGen","then","d","_promise","_resolve","pair","onreadable","onfinished","ObjectGetOwnPropertyDescriptor","duplex","transform","Transform","kCallback","readableHighWaterMark","passthrough","PassThrough","ERR_MISSING_ARGS","writing","popCallback","streams","makeAsyncIterable","fromReadable","pumpToNode","onresolve","wait","pumpToWeb","writer","pipeline","pipelineImpl","outerSignal","lastStreamCleanup","finishImpl","destroys","finishCount","_disposable","isLastStream","onError","_ret","_ret2","pt","toRead","pipe","dst","ended","pipeline_1","compose","orgStreams","idx","head","tail","kWeakHandler","staticCompose","addAbortSignalNoValidate","deprecate","ArrayPrototypePush","Boolean","Number","PromiseReject","PromiseResolve","kEmpty","kEof","composedStream","map","concurrency","highWaterMark","queue","signalOpt","cnt","onCatch","afterItemProcessed","maybeResume","pump","asIndexedPairs","_options$signal","some","unused","filter","every","find","forEach","forEachFn","filterFn","reduce","reducer","initialValue","_options$signal2","hasInitialValue","gotAnyItemFromStream","_options$signal3","ReduceAwareErrMissingArgs","toArray","_options$signal4","flatMap","values","toIntegerOrInfinity","number","drop","_options$signal5","_options$signal6","take","_options$signal7","_options$signal8","operators","ArrayPrototypePop","pl","lastArg","promises","ReflectApply","customPromisify","streamReturningOperators","promiseReturningOperators","ERR_ILLEGAL_CONSTRUCTOR","streamModule","op","require$$16","require$$17","require$$18","CustomStream","originalDestroy","ContainerHandlerIdentifier_1","ContainerHandlerIdentifier","containers","parsingContext","util","depth","maybeId","ids","EntryHandlerPredicate_1","jsonld_context_parser_1","EntryHandlerPredicate$1","EntryHandlerPredicate","predicate","reverse","isEmbedded","isAnnotation","depthProperties","depthOffsetGraph","depthPropertiesGraph","subjects","subject","graphs","graph","annotationsBuffer","newAnnotation","existingAnnotation","inProperty","testResult","keyOriginal","objects","parentKey","parentDepthOffset","listValueContainer","listPointer","ContainerHandlerIndex_1","ContainerHandlerIndex$1","graphContainer","indexKey","indexPropertyRaw","indexProperty","indexValues","graphId","indexValue","depthOffset","ContainerHandlerIndex","ContainerHandlerLanguage_1","ContainerHandlerLanguage","subValue","ContainerHandlerType_1","ContainerHandlerType$1","entryHasIdentifier","ContainerHandlerType","EntryHandlerContainer_1","EntryHandlerContainer$1","EntryHandlerContainer","isSimpleGraphContainer","fallback","checkGraphContainer","containersSelf","containersParent","containerHandleName","handler","containerName","rdf_data_factory_1","canonicalizeJson","contextKey","needle","haystack","indexHashes","existingIndexValue","valueLanguage","valueDirection","valueIndex","typeTerm","listValue","graphContainerEntries","valueId","valueTerm","contextKeyEntry","expanded","datatype","defaultDatatype","contextType","contextLanguage","contextDirection","direction","valueNode","disableCache","cachedUnaliasedKeyword","unliased","hash","newHash","depthContainer","graphContainerIndex","keyUnaliased","lastValidDepth","quad","annotation","annotationQuad","nestedAnnotation","EntryHandlerArrayValue_1","EntryHandlerArrayValue","listRootKey","listRootDepth","keyOption","valueOriginal","listRootKeys","linkTerm","newLinkTerm","EntryHandlerInvalidFallback_1","EntryHandlerInvalidFallback","EntryHandlerKeyword_1","EntryHandlerKeyword","EntryHandlerKeywordContext_1","EntryHandlerKeywordContext","EntryHandlerKeywordGraph_1","EntryHandlerKeywordGraph","EntryHandlerKeywordId_1","EntryHandlerKeywordId","valueKeys","EntryHandlerKeywordIncluded_1","EntryHandlerKeywordIncluded","valueUnliased","EntryHandlerKeywordNest_1","EntryHandlerKeywordNest","EntryHandlerKeywordType_1","EntryHandlerKeywordType","elements","element","scopedContext","hasTypedScopedContext","typeContext","EntryHandlerKeywordUnknownFallback_1","EntryHandlerKeywordUnknownFallback","keywordType","EntryHandlerKeywordValue_1","EntryHandlerKeywordValue","ContextTree_1","ContextTree","subTree","path","ParsingContext_1","JsonLdParser_1","ParsingContext$1","ParsingContext","activeVersion","keysOriginal","contextData","propagate","originalDepth","hasApplicablePropertyScopedContext","lastKey","lastKeyValue","lastDepthCheck","pendingFlushBuffer","deeperIdStack","EntryHandlerKeywordAnnotation_1","EntryHandlerKeywordAnnotation","Parser","readable_stream_1","JsonLdParser$1","JsonLdParser","wellKnownMediaTypes","streamingProfile","contentType","match","parsed","output","flushStacks","handleKey","validationResult","entryHandler","valueBuffer","bufferedValue","subGraphBuffer","graphBuffer","annotationsBufferParent","valueJobCb","jobs","job","contextAwaitingJobs","applicableTypeJobs","applicableTypeJobIds","typeJob","sortedTypeJobs","job1","job2","sortedApplicableTypeJobIds","jobId","relativeIriProtocol","termCleanup","factory","quadCleanup","ParserStream","documentLoader","rdf","parser","toReadable","Sink"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82]}