{"version":3,"file":"main-BuhF8QYf.js","sources":["../node_modules/uri-js/dist/es5/uri.all.js","../node_modules/@graphy/content.trig.read/main.js"],"sourcesContent":["/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.URI = global.URI || {})));\n}(this, (function (exports) { 'use strict';\n\nfunction merge() {\n    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {\n        sets[_key] = arguments[_key];\n    }\n\n    if (sets.length > 1) {\n        sets[0] = sets[0].slice(0, -1);\n        var xl = sets.length - 1;\n        for (var x = 1; x < xl; ++x) {\n            sets[x] = sets[x].slice(1, -1);\n        }\n        sets[xl] = sets[xl].slice(1);\n        return sets.join('');\n    } else {\n        return sets[0];\n    }\n}\nfunction subexp(str) {\n    return \"(?:\" + str + \")\";\n}\nfunction typeOf(o) {\n    return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n}\nfunction toUpperCase(str) {\n    return str.toUpperCase();\n}\nfunction toArray(obj) {\n    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];\n}\nfunction assign(target, source) {\n    var obj = target;\n    if (source) {\n        for (var key in source) {\n            obj[key] = source[key];\n        }\n    }\n    return obj;\n}\n\nfunction buildExps(isIRI) {\n    var ALPHA$$ = \"[A-Za-z]\",\n        CR$ = \"[\\\\x0D]\",\n        DIGIT$$ = \"[0-9]\",\n        DQUOTE$$ = \"[\\\\x22]\",\n        HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),\n        //case-insensitive\n    LF$$ = \"[\\\\x0A]\",\n        SP$$ = \"[\\\\x20]\",\n        PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),\n        //expanded\n    GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n        SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n        UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",\n        //subset, excludes bidi control characters\n    IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",\n        //subset\n    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n        USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n        DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n        DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),\n        //relaxed parsing rules\n    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n        H16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n        LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n        IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$),\n        //                           6( h16 \":\" ) ls32\n    IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$),\n        //                      \"::\" 5( h16 \":\" ) ls32\n    IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$),\n        //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$),\n        //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$),\n        //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$),\n        //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$),\n        //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$),\n        //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"),\n        //[ *6( h16 \":\" ) h16 ] \"::\"\n    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n        ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),\n        //RFC 6874\n    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),\n        //RFC 6874\n    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),\n        //RFC 6874, with relaxed parsing rules\n    IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n        IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),\n        //RFC 6874\n    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n        HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n        PORT$ = subexp(DIGIT$$ + \"*\"),\n        AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n        PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n        SEGMENT$ = subexp(PCHAR$ + \"*\"),\n        SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n        PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n        PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),\n        //simplified\n    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n        PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n        FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n        HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n        RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n        ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n        GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n        SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n    return {\n        NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n        NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n        NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n        ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n        OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n        PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n        IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n        IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n    };\n}\nvar URI_PROTOCOL = buildExps(false);\n\nvar IRI_PROTOCOL = buildExps(true);\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/** Highest positive signed 32-bit float value */\n\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\nvar delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nvar regexPunycode = /^xn--/;\nvar regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nvar regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nvar errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nvar baseMinusTMin = base - tMin;\nvar floor = Math.floor;\nvar stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error$1(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tvar result = [];\n\tvar length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tvar parts = string.split('@');\n\tvar result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tvar labels = string.split('.');\n\tvar encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tvar output = [];\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t// Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nvar ucs2encode = function ucs2encode(array) {\n\treturn String.fromCodePoint.apply(String, toConsumableArray(array));\n};\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nvar basicToDigit = function basicToDigit(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nvar digitToBasic = function digitToBasic(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nvar adapt = function adapt(delta, numPoints, firstTime) {\n\tvar k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nvar decode = function decode(input) {\n\t// Don't use UCS-2.\n\tvar output = [];\n\tvar inputLength = input.length;\n\tvar i = 0;\n\tvar n = initialN;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tvar basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (var j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror$1('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tvar oldi = i;\n\t\tfor (var w = 1, k = base;; /* no condition */k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror$1('invalid-input');\n\t\t\t}\n\n\t\t\tvar digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\t\t}\n\n\t\tvar out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\t}\n\n\treturn String.fromCodePoint.apply(String, output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nvar encode = function encode(input) {\n\tvar output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tvar inputLength = input.length;\n\n\t// Initialize the state.\n\tvar n = initialN;\n\tvar delta = 0;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points.\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar _currentValue2 = _step.value;\n\n\t\t\tif (_currentValue2 < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(_currentValue2));\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar basicLength = output.length;\n\tvar handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tvar m = maxInt;\n\t\tvar _iteratorNormalCompletion2 = true;\n\t\tvar _didIteratorError2 = false;\n\t\tvar _iteratorError2 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\tvar currentValue = _step2.value;\n\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow.\n\t\t} catch (err) {\n\t\t\t_didIteratorError2 = true;\n\t\t\t_iteratorError2 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t_iterator2.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tvar _iteratorNormalCompletion3 = true;\n\t\tvar _didIteratorError3 = false;\n\t\tvar _iteratorError3 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\tvar _currentValue = _step3.value;\n\n\t\t\t\tif (_currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror$1('overflow');\n\t\t\t\t}\n\t\t\t\tif (_currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\t\tvar q = delta;\n\t\t\t\t\tfor (var k = base;; /* no condition */k += base) {\n\t\t\t\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar qMinusT = q - t;\n\t\t\t\t\t\tvar baseMinusT = base - t;\n\t\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError3 = true;\n\t\t\t_iteratorError3 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t_iterator3.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nvar toUnicode = function toUnicode(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nvar toASCII = function toASCII(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nvar punycode = {\n\t/**\n  * A string representing the current Punycode.js version number.\n  * @memberOf punycode\n  * @type String\n  */\n\t'version': '2.1.0',\n\t/**\n  * An object of methods to convert from JavaScript's internal character\n  * representation (UCS-2) to Unicode code points, and back.\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n  * @memberOf punycode\n  * @type Object\n  */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\n/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\nvar SCHEMES = {};\nfunction pctEncChar(chr) {\n    var c = chr.charCodeAt(0);\n    var e = void 0;\n    if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n    return e;\n}\nfunction pctDecChars(str) {\n    var newStr = \"\";\n    var i = 0;\n    var il = str.length;\n    while (i < il) {\n        var c = parseInt(str.substr(i + 1, 2), 16);\n        if (c < 128) {\n            newStr += String.fromCharCode(c);\n            i += 3;\n        } else if (c >= 194 && c < 224) {\n            if (il - i >= 6) {\n                var c2 = parseInt(str.substr(i + 4, 2), 16);\n                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n            } else {\n                newStr += str.substr(i, 6);\n            }\n            i += 6;\n        } else if (c >= 224) {\n            if (il - i >= 9) {\n                var _c = parseInt(str.substr(i + 4, 2), 16);\n                var c3 = parseInt(str.substr(i + 7, 2), 16);\n                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n            } else {\n                newStr += str.substr(i, 9);\n            }\n            i += 9;\n        } else {\n            newStr += str.substr(i, 3);\n            i += 3;\n        }\n    }\n    return newStr;\n}\nfunction _normalizeComponentEncoding(components, protocol) {\n    function decodeUnreserved(str) {\n        var decStr = pctDecChars(str);\n        return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n    }\n    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    return components;\n}\n\nfunction _stripLeadingZeros(str) {\n    return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\nfunction _normalizeIPv4(host, protocol) {\n    var matches = host.match(protocol.IPV4ADDRESS) || [];\n\n    var _matches = slicedToArray(matches, 2),\n        address = _matches[1];\n\n    if (address) {\n        return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n    } else {\n        return host;\n    }\n}\nfunction _normalizeIPv6(host, protocol) {\n    var matches = host.match(protocol.IPV6ADDRESS) || [];\n\n    var _matches2 = slicedToArray(matches, 3),\n        address = _matches2[1],\n        zone = _matches2[2];\n\n    if (address) {\n        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),\n            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),\n            last = _address$toLowerCase$2[0],\n            first = _address$toLowerCase$2[1];\n\n        var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n        var lastFields = last.split(\":\").map(_stripLeadingZeros);\n        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n        var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n        var lastFieldsStart = lastFields.length - fieldCount;\n        var fields = Array(fieldCount);\n        for (var x = 0; x < fieldCount; ++x) {\n            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n        }\n        if (isLastFieldIPv4Address) {\n            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n        }\n        var allZeroFields = fields.reduce(function (acc, field, index) {\n            if (!field || field === \"0\") {\n                var lastLongest = acc[acc.length - 1];\n                if (lastLongest && lastLongest.index + lastLongest.length === index) {\n                    lastLongest.length++;\n                } else {\n                    acc.push({ index: index, length: 1 });\n                }\n            }\n            return acc;\n        }, []);\n        var longestZeroFields = allZeroFields.sort(function (a, b) {\n            return b.length - a.length;\n        })[0];\n        var newHost = void 0;\n        if (longestZeroFields && longestZeroFields.length > 1) {\n            var newFirst = fields.slice(0, longestZeroFields.index);\n            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n            newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n        } else {\n            newHost = fields.join(\":\");\n        }\n        if (zone) {\n            newHost += \"%\" + zone;\n        }\n        return newHost;\n    } else {\n        return host;\n    }\n}\nvar URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nvar NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\nfunction parse(uriString) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var components = {};\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n    var matches = uriString.match(URI_PARSE);\n    if (matches) {\n        if (NO_MATCH_IS_UNDEFINED) {\n            //store each component\n            components.scheme = matches[1];\n            components.userinfo = matches[3];\n            components.host = matches[4];\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = matches[7];\n            components.fragment = matches[8];\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = matches[5];\n            }\n        } else {\n            //IE FIX for improper RegExp matching\n            //store each component\n            components.scheme = matches[1] || undefined;\n            components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n            components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n            components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n            }\n        }\n        if (components.host) {\n            //normalize IP hosts\n            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n        }\n        //determine reference type\n        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n            components.reference = \"same-document\";\n        } else if (components.scheme === undefined) {\n            components.reference = \"relative\";\n        } else if (components.fragment === undefined) {\n            components.reference = \"absolute\";\n        } else {\n            components.reference = \"uri\";\n        }\n        //check for reference errors\n        if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n            components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n        }\n        //find scheme handler\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n        //check if scheme can't handle IRIs\n        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n            //if host component is a domain name\n            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            }\n            //convert IRI -> URI\n            _normalizeComponentEncoding(components, URI_PROTOCOL);\n        } else {\n            //normalize encodings\n            _normalizeComponentEncoding(components, protocol);\n        }\n        //perform scheme specific parsing\n        if (schemeHandler && schemeHandler.parse) {\n            schemeHandler.parse(components, options);\n        }\n    } else {\n        components.error = components.error || \"URI can not be parsed.\";\n    }\n    return components;\n}\n\nfunction _recomposeAuthority(components, options) {\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    if (components.userinfo !== undefined) {\n        uriTokens.push(components.userinfo);\n        uriTokens.push(\"@\");\n    }\n    if (components.host !== undefined) {\n        //normalize IP hosts, add brackets and escape zone separator for IPv6\n        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {\n            return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n        }));\n    }\n    if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n        uriTokens.push(\":\");\n        uriTokens.push(String(components.port));\n    }\n    return uriTokens.length ? uriTokens.join(\"\") : undefined;\n}\n\nvar RDS1 = /^\\.\\.?\\//;\nvar RDS2 = /^\\/\\.(\\/|$)/;\nvar RDS3 = /^\\/\\.\\.(\\/|$)/;\nvar RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\nfunction removeDotSegments(input) {\n    var output = [];\n    while (input.length) {\n        if (input.match(RDS1)) {\n            input = input.replace(RDS1, \"\");\n        } else if (input.match(RDS2)) {\n            input = input.replace(RDS2, \"/\");\n        } else if (input.match(RDS3)) {\n            input = input.replace(RDS3, \"/\");\n            output.pop();\n        } else if (input === \".\" || input === \"..\") {\n            input = \"\";\n        } else {\n            var im = input.match(RDS5);\n            if (im) {\n                var s = im[0];\n                input = input.slice(s.length);\n                output.push(s);\n            } else {\n                throw new Error(\"Unexpected dot segment condition\");\n            }\n        }\n    }\n    return output.join(\"\");\n}\n\nfunction serialize(components) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    //find scheme handler\n    var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n    //perform scheme specific serialization\n    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n    if (components.host) {\n        //if host component is an IPv6 address\n        if (protocol.IPV6ADDRESS.test(components.host)) {}\n        //TODO: normalize IPv6 address as per RFC 5952\n\n        //if host component is a domain name\n        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n                //convert IDN via punycode\n                try {\n                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n            }\n    }\n    //normalize encoding\n    _normalizeComponentEncoding(components, protocol);\n    if (options.reference !== \"suffix\" && components.scheme) {\n        uriTokens.push(components.scheme);\n        uriTokens.push(\":\");\n    }\n    var authority = _recomposeAuthority(components, options);\n    if (authority !== undefined) {\n        if (options.reference !== \"suffix\") {\n            uriTokens.push(\"//\");\n        }\n        uriTokens.push(authority);\n        if (components.path && components.path.charAt(0) !== \"/\") {\n            uriTokens.push(\"/\");\n        }\n    }\n    if (components.path !== undefined) {\n        var s = components.path;\n        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n            s = removeDotSegments(s);\n        }\n        if (authority === undefined) {\n            s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n        }\n        uriTokens.push(s);\n    }\n    if (components.query !== undefined) {\n        uriTokens.push(\"?\");\n        uriTokens.push(components.query);\n    }\n    if (components.fragment !== undefined) {\n        uriTokens.push(\"#\");\n        uriTokens.push(components.fragment);\n    }\n    return uriTokens.join(\"\"); //merge tokens into a string\n}\n\nfunction resolveComponents(base, relative) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var skipNormalization = arguments[3];\n\n    var target = {};\n    if (!skipNormalization) {\n        base = parse(serialize(base, options), options); //normalize base components\n        relative = parse(serialize(relative, options), options); //normalize relative components\n    }\n    options = options || {};\n    if (!options.tolerant && relative.scheme) {\n        target.scheme = relative.scheme;\n        //target.authority = relative.authority;\n        target.userinfo = relative.userinfo;\n        target.host = relative.host;\n        target.port = relative.port;\n        target.path = removeDotSegments(relative.path || \"\");\n        target.query = relative.query;\n    } else {\n        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n            //target.authority = relative.authority;\n            target.userinfo = relative.userinfo;\n            target.host = relative.host;\n            target.port = relative.port;\n            target.path = removeDotSegments(relative.path || \"\");\n            target.query = relative.query;\n        } else {\n            if (!relative.path) {\n                target.path = base.path;\n                if (relative.query !== undefined) {\n                    target.query = relative.query;\n                } else {\n                    target.query = base.query;\n                }\n            } else {\n                if (relative.path.charAt(0) === \"/\") {\n                    target.path = removeDotSegments(relative.path);\n                } else {\n                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n                        target.path = \"/\" + relative.path;\n                    } else if (!base.path) {\n                        target.path = relative.path;\n                    } else {\n                        target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n                    }\n                    target.path = removeDotSegments(target.path);\n                }\n                target.query = relative.query;\n            }\n            //target.authority = base.authority;\n            target.userinfo = base.userinfo;\n            target.host = base.host;\n            target.port = base.port;\n        }\n        target.scheme = base.scheme;\n    }\n    target.fragment = relative.fragment;\n    return target;\n}\n\nfunction resolve(baseURI, relativeURI, options) {\n    var schemelessOptions = assign({ scheme: 'null' }, options);\n    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n}\n\nfunction normalize(uri, options) {\n    if (typeof uri === \"string\") {\n        uri = serialize(parse(uri, options), options);\n    } else if (typeOf(uri) === \"object\") {\n        uri = parse(serialize(uri, options), options);\n    }\n    return uri;\n}\n\nfunction equal(uriA, uriB, options) {\n    if (typeof uriA === \"string\") {\n        uriA = serialize(parse(uriA, options), options);\n    } else if (typeOf(uriA) === \"object\") {\n        uriA = serialize(uriA, options);\n    }\n    if (typeof uriB === \"string\") {\n        uriB = serialize(parse(uriB, options), options);\n    } else if (typeOf(uriB) === \"object\") {\n        uriB = serialize(uriB, options);\n    }\n    return uriA === uriB;\n}\n\nfunction escapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n}\n\nfunction unescapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n}\n\nvar handler = {\n    scheme: \"http\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        //report missing host\n        if (!components.host) {\n            components.error = components.error || \"HTTP URIs must have a host.\";\n        }\n        return components;\n    },\n    serialize: function serialize(components, options) {\n        var secure = String(components.scheme).toLowerCase() === \"https\";\n        //normalize the default port\n        if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n            components.port = undefined;\n        }\n        //normalize the empty path\n        if (!components.path) {\n            components.path = \"/\";\n        }\n        //NOTE: We do not parse query strings for HTTP URIs\n        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n        //and not the HTTP spec.\n        return components;\n    }\n};\n\nvar handler$1 = {\n    scheme: \"https\",\n    domainHost: handler.domainHost,\n    parse: handler.parse,\n    serialize: handler.serialize\n};\n\nfunction isSecure(wsComponents) {\n    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n//RFC 6455\nvar handler$2 = {\n    scheme: \"ws\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        var wsComponents = components;\n        //indicate if the secure flag is set\n        wsComponents.secure = isSecure(wsComponents);\n        //construct resouce name\n        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n        wsComponents.path = undefined;\n        wsComponents.query = undefined;\n        return wsComponents;\n    },\n    serialize: function serialize(wsComponents, options) {\n        //normalize the default port\n        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n            wsComponents.port = undefined;\n        }\n        //ensure scheme matches secure flag\n        if (typeof wsComponents.secure === 'boolean') {\n            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';\n            wsComponents.secure = undefined;\n        }\n        //reconstruct path from resource name\n        if (wsComponents.resourceName) {\n            var _wsComponents$resourc = wsComponents.resourceName.split('?'),\n                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),\n                path = _wsComponents$resourc2[0],\n                query = _wsComponents$resourc2[1];\n\n            wsComponents.path = path && path !== '/' ? path : undefined;\n            wsComponents.query = query;\n            wsComponents.resourceName = undefined;\n        }\n        //forbid fragment component\n        wsComponents.fragment = undefined;\n        return wsComponents;\n    }\n};\n\nvar handler$3 = {\n    scheme: \"wss\",\n    domainHost: handler$2.domainHost,\n    parse: handler$2.parse,\n    serialize: handler$2.serialize\n};\n\nvar O = {};\nvar isIRI = true;\n//RFC 3986\nvar UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nvar HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\nvar PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nvar ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nvar QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nvar VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nvar SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nvar UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nvar PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nvar NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nvar NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nvar NOT_HFVALUE = NOT_HFNAME;\nfunction decodeUnreserved(str) {\n    var decStr = pctDecChars(str);\n    return !decStr.match(UNRESERVED) ? str : decStr;\n}\nvar handler$4 = {\n    scheme: \"mailto\",\n    parse: function parse$$1(components, options) {\n        var mailtoComponents = components;\n        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n        mailtoComponents.path = undefined;\n        if (mailtoComponents.query) {\n            var unknownHeaders = false;\n            var headers = {};\n            var hfields = mailtoComponents.query.split(\"&\");\n            for (var x = 0, xl = hfields.length; x < xl; ++x) {\n                var hfield = hfields[x].split(\"=\");\n                switch (hfield[0]) {\n                    case \"to\":\n                        var toAddrs = hfield[1].split(\",\");\n                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {\n                            to.push(toAddrs[_x]);\n                        }\n                        break;\n                    case \"subject\":\n                        mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                        break;\n                    case \"body\":\n                        mailtoComponents.body = unescapeComponent(hfield[1], options);\n                        break;\n                    default:\n                        unknownHeaders = true;\n                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                        break;\n                }\n            }\n            if (unknownHeaders) mailtoComponents.headers = headers;\n        }\n        mailtoComponents.query = undefined;\n        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {\n            var addr = to[_x2].split(\"@\");\n            addr[0] = unescapeComponent(addr[0]);\n            if (!options.unicodeSupport) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n                } catch (e) {\n                    mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            } else {\n                addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n            }\n            to[_x2] = addr.join(\"@\");\n        }\n        return mailtoComponents;\n    },\n    serialize: function serialize$$1(mailtoComponents, options) {\n        var components = mailtoComponents;\n        var to = toArray(mailtoComponents.to);\n        if (to) {\n            for (var x = 0, xl = to.length; x < xl; ++x) {\n                var toAddr = String(to[x]);\n                var atIdx = toAddr.lastIndexOf(\"@\");\n                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n                var domain = toAddr.slice(atIdx + 1);\n                //convert IDN via punycode\n                try {\n                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n                } catch (e) {\n                    components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n                to[x] = localPart + \"@\" + domain;\n            }\n            components.path = to.join(\",\");\n        }\n        var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n        if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n        if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n        var fields = [];\n        for (var name in headers) {\n            if (headers[name] !== O[name]) {\n                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n            }\n        }\n        if (fields.length) {\n            components.query = fields.join(\"&\");\n        }\n        return components;\n    }\n};\n\nvar URN_PARSE = /^([^\\:]+)\\:(.*)/;\n//RFC 2141\nvar handler$5 = {\n    scheme: \"urn\",\n    parse: function parse$$1(components, options) {\n        var matches = components.path && components.path.match(URN_PARSE);\n        var urnComponents = components;\n        if (matches) {\n            var scheme = options.scheme || urnComponents.scheme || \"urn\";\n            var nid = matches[1].toLowerCase();\n            var nss = matches[2];\n            var urnScheme = scheme + \":\" + (options.nid || nid);\n            var schemeHandler = SCHEMES[urnScheme];\n            urnComponents.nid = nid;\n            urnComponents.nss = nss;\n            urnComponents.path = undefined;\n            if (schemeHandler) {\n                urnComponents = schemeHandler.parse(urnComponents, options);\n            }\n        } else {\n            urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n        }\n        return urnComponents;\n    },\n    serialize: function serialize$$1(urnComponents, options) {\n        var scheme = options.scheme || urnComponents.scheme || \"urn\";\n        var nid = urnComponents.nid;\n        var urnScheme = scheme + \":\" + (options.nid || nid);\n        var schemeHandler = SCHEMES[urnScheme];\n        if (schemeHandler) {\n            urnComponents = schemeHandler.serialize(urnComponents, options);\n        }\n        var uriComponents = urnComponents;\n        var nss = urnComponents.nss;\n        uriComponents.path = (nid || options.nid) + \":\" + nss;\n        return uriComponents;\n    }\n};\n\nvar UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n//RFC 4122\nvar handler$6 = {\n    scheme: \"urn:uuid\",\n    parse: function parse(urnComponents, options) {\n        var uuidComponents = urnComponents;\n        uuidComponents.uuid = uuidComponents.nss;\n        uuidComponents.nss = undefined;\n        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n            uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n        }\n        return uuidComponents;\n    },\n    serialize: function serialize(uuidComponents, options) {\n        var urnComponents = uuidComponents;\n        //normalize UUID\n        urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n        return urnComponents;\n    }\n};\n\nSCHEMES[handler.scheme] = handler;\nSCHEMES[handler$1.scheme] = handler$1;\nSCHEMES[handler$2.scheme] = handler$2;\nSCHEMES[handler$3.scheme] = handler$3;\nSCHEMES[handler$4.scheme] = handler$4;\nSCHEMES[handler$5.scheme] = handler$5;\nSCHEMES[handler$6.scheme] = handler$6;\n\nexports.SCHEMES = SCHEMES;\nexports.pctEncChar = pctEncChar;\nexports.pctDecChars = pctDecChars;\nexports.parse = parse;\nexports.removeDotSegments = removeDotSegments;\nexports.serialize = serialize;\nexports.resolveComponents = resolveComponents;\nexports.resolve = resolve;\nexports.normalize = normalize;\nexports.equal = equal;\nexports.escapeComponent = escapeComponent;\nexports.unescapeComponent = unescapeComponent;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=uri.all.js.map\n","\n\n\n// queueMicrotask shim\n{\n\t// not defined or not a function\n\tif('function' !== typeof queueMicrotask) {\n\t\t// create resolved promise\n\t\tlet dp_resolve = Promise.resolve();\n\n\t\t// try to redefine\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-global-assign\n\t\t\tqueueMicrotask = fk => dp_resolve.then(fk)\n\t\t\t\t.catch(e_callback => setTimeout(() => {\n\t\t\t\t\tthrow e_callback;\n\t\t\t\t}, 0));\n\t\t}\n\t\t// oh well, at least we tried\n\t\tcatch(e_define) {}\n\t}\n}\n\n\n\nconst uri = require('uri-js');\nconst string_decoder = require('string_decoder');\n\nconst stream = require('@graphy/core.iso.stream');\nconst factory = require('@graphy/core.data.factory');\nconst quad = k => factory.quad(k._kt_subject, k._kt_predicate, k._kt_object, k._kt_graph);\n\n// eslint-disable-next-line no-misleading-character-class\nconst RT_PREFIXED_NAME_NAMESPACE_VALID = /^([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}]([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}.]*[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}])?)?$/u;\n// eslint-disable-next-line no-misleading-character-class\nconst RT_PREFIXED_NAME_LOCAL_NAME_VALID = /^([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_:0-9]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&'()*+,;=/?#@%])(([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}.:]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&'()*+,;=/?#@%])*([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}:]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&'()*+,;=/?#@%]))?$/u;\n// eslint-disable-next-line no-misleading-character-class\nconst RT_BLANK_NODE_VALID = /^[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_0-9]([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}.]*[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}])?$/u;\nconst RT_NAMED_NODE_VALID = /^([^\\0-\\x20<>\"{}|^`\\\\]|\\\\u[A-Fa-f0-9]{4}|\\\\U[A-Fa-f0-9]{8})*$/;\nconst RT_NAMED_NODE_ESCAPELESS_VALID = /^([^\\0-\\x20<>\"{}|^`])*$/;\n\nconst RT_LITERAL_CONTENTS_VALID = /^(?:[^\\\\]|\\\\[tbnrf\"'\\\\]|\\\\u[A-Fa-f0-9]{4}|\\\\U[A-Fa-f0-9]{8})*$/;\n\nconst R_UNICODE_ANY = /\\\\u([0-9A-Fa-f]{4})|\\\\U([0-9A-Fa-f]{8})/g;\n\nconst F_REPLACE_UNICODE_ANY = \t(s_, s_4, s_8) => String.fromCodePoint(parseInt(s_4 || s_8, 16));\n\nconst OPHOP = Object.prototype.hasOwnProperty;\n\n\n\nconst R_PREFIXED_NAME_QUICK = /([A-Za-z][A-Za-z0-9_-]*)?:([A-Za-z_0-9:][A-Za-z0-9_:-]*)(?:\\s+|(?=\\.?[<[(\"';,)\\]#{}]|\\.[\\s\\0]))/y;\n\n\nconst R_PREFIXED_NAME_ESCAPELESS = /([^\\s#@<[(\"':_{}][^\\s#@<[(\"':{}]*)?:((?:[^\\s#@<[(\"'.;,{})\\]\\\\](?:[^\\s#@<[(\"';,{})\\]\\\\]*[^\\s#@<[(\"'.;,{})\\]\\\\])?)?)(?:\\s+|(?=\\.?[<[(\"';,)\\]#{}]|\\.[\\s\\0]))/y;\n\n\n\nconst R_PREFIXED_NAME = /([^\\s#@<[(\"':_{}][^\\s#@<[(\"':{}]*)?:((?:(?:[^\\s#@<[(\"'.;,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"]))(?:(?:[^\\s#@<[(\"';,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"]))*(?:[^\\s#@<[(\"'.;,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"])))?)?)(?:\\s+|(?=\\.?[<[(\"';,)\\]#{}]|\\.[\\s\\0]))/y;\n\nconst R_PN_LOCAL_ESCAPES = /\\\\(.)/g;\n\n\nconst R_BLANK_NODE_LABEL = /_:(.(?:[^\\s:<;,)\\]#}]*[^\\s:<.;,)\\]#}])?)(?:\\s+|(?=[<:{,;\\])#]))/y;\nconst R_BLANK_NODE_LABEL_TERMINAL = /_:(.(?:[^\\s:<;,)\\]#}]*[^\\s:<.;,)\\]#}])?)(?:\\s+|(?=\\.?[<:{,;\\])#])|(?=\\.[\\s@#<({[}]))/y;\n\nconst R_IRIREF_ESCAPELESS = /<([^\\\\>]*)>\\s*/y;\nconst R_IRIREF = /<([^>]*)>\\s*/y;\n\nconst R_NUMERIC_LITERAL = /([+-]?(?:[0-9]+(\\.[0-9]+)?|(\\.[0-9]+))(\\.?[eE][+-]?[0-9]+)?)(?:\\s+|(?=\\.[^eE0-9]|[;,)\\]]))/y;\nconst R_BOOLEAN_LITERAL = /(?:(true|TRUE)|false|FALSE)\\s*/y;\nconst R_A = /a(?:\\s+|(?=[[(\"'<#]))/y;\n\nconst R_DOUBLE_CARET = /\\^\\^/y;\nconst R_WS = /\\s*/y;\nconst R_LANGTAG = /@([A-Za-z]+(?:-[A-Za-z0-9-]+)*)(?:\\s+|(?=[.},;\\])#]))/y;\n\nconst R_PREFIX_KEYWORD = /(?:(@prefix)|[pP][rR][eE][fF][iI][xX])\\s*/y;\nconst R_PREFIX_ID = /([^#:]*):\\s*/iy;\nconst R_BASE_KEYWORD = /(?:(@base)|[bB][aA][sS][eE])\\s*/y;\n\nconst R_GRAPH_IRI_ESCAPELESS = /(?:graph)?\\s*<([^\\\\>]*)>\\s*\\{\\s*/iy;\nconst R_GRAPH_PREFIXED_NAME = /(?:graph)?\\s*([^\\s#@<[(\"':_{}][^\\s#@<[(\"':{}]*)?:((?:(?:[^\\s#@<[(\"'.;,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"]))(?:(?:[^\\s#@<[(\"';,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"]))*(?:[^\\s#@<[(\"'.;,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"])))?)?)\\s*\\{\\s*/iy;\nconst R_GRAPH_LABELED_BLANK_NODE = /(?:graph)?\\s*_:(.(?:[^\\s:<;,)\\]#}]*[^\\s:<.;,)\\]#}])?)\\s*\\{\\s*/iy;\nconst R_GRAPH_ANONYMOUS_BLANK_NODE = /(?:graph)?\\s*\\[\\s*\\]\\s*\\{\\s*/iy;\nconst R_GRAPH_IRI = /(?:graph)?\\s*<([^>]*)>\\s*\\{\\s*/iy;\nconst R_GRAPH = /graph(?:\\s+|(?=[#<[{]))/iy;\n\nconst R_COMMENT = /(#[^\\n]*\\n\\s*)+/y;\n\nconst RT_IRI_ABSOLUTE = /^[A-Za-z][A-Za-z0-9.\\-+]*:/;\nconst R_RELATIVE_URI = /^(\\/[^?#]+)([?#].*)?$/;\nconst R_BASE_IRI = /^((([A-Za-z0-9.\\-+]*:\\/)?\\/[^/>]*)?(\\/(?:[^/>]*\\/)*)?[^>]*)$/;\n\nconst R_ANONYMOUS_BLANK_NODE = /\\[\\s*\\]\\s*/y;\nconst R_CHAR_BLANK_NODE = /\\[(?:\\s+|(?=[^\\]]))/y;\nconst R_CHAR_COLLECTION = /\\(\\s*/y;\n\nconst R_CHAR_KET = /\\]\\s*/y;\n\nconst R_CHAR_OPEN = /\\{\\s*/y;\nconst R_CHAR_CLOSE = /\\}\\s*/y;\n\nconst R_CHAR_STOP = /\\.\\s*/y;\n\n\n\nconst R_STRLIT_SHORT_DOUBLE_BREAK = /[\\\\\"\\r\\n]/g;\nconst R_STRLIT_SHORT_SINGLE_BREAK = /[\\\\'\\r\\n]/g;\n\nconst R_STRLIT_LONG_DOUBLE_UNFINISHED_TERM = /\"{1,2}$/g;\nconst R_STRLIT_LONG_SINGLE_UNFINISHED_TERM = /'{1,2}$/g;\n\nconst R_STRLIT_LONG_DOUBLE_BREAK = /(\\\\|\"\"\")/g;\nconst R_STRLIT_LONG_SINGLE_BREAK = /(\\\\|''')/g;\n\n\nconst F_REPLACE_STRLIT_CONTENTS = (s_, s_whitespace, s_auto, s_4, s_8, s_invalid) => {\n\tif(s_whitespace) {\n\t\tswitch(s_whitespace) {\n\t\t\tcase 't': return '\\t';\n\t\t\tcase 'n': return '\\n';\n\t\t\tcase 'r': return '\\r';\n\t\t\tcase 'f': return '\\f';\n\t\t\tcase 'b': return '\\b';\n\t\t\tdefault: {\n\t\t\t\tconsole.assert(`bad regex escape char mapping: '${s_whitespace}'`);\n\t\t\t}\n\t\t}\n\t}\n\telse if(s_auto) {\n\t\treturn s_auto;\n\t}\n\telse if(s_4) {\n\t\treturn String.fromCodePoint(parseInt(s_4, 16));\n\t}\n\telse if(s_8) {\n\t\treturn String.fromCodePoint(parseInt(s_8, 16));\n\t}\n\telse if(s_invalid) {\n\t\t// pointless escape\n\t\tif('\\\\' === s_invalid[0]) {\n\t\t\t\t// // relaxed\n\t\t\t\t// return s_invalid[1];\n\t\t\t// if relaxed then return s_invalid, otherwise throw:\n\t\t\tthrow new Error(`expected string_literal but invalid escape sequence within contents: '${s_invalid}'. failed to parse a valid token`);\n\t\t}\n\t\t// bad character\n\t\telse {\n\t\t\tthrow new Error(`expected string_literal but invalid whitespace character within contents: ${JSON.stringify(s_invalid)}. failed to parse a valid token`);\n\t\t}\n\t}\n\telse {\n\t\tconsole.assert(`unexpected no match branch in escape sequence replace callback`);\n\t}\n};\n\n\nconst R_STRLIT_SHORT_CONTENTS_ESCAPES_HARD = /(?:\\\\(?:([tnrfb])|([\\\\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|([\\r\\n]|\\\\.))/g;\nconst R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT = /(?:\\\\(?:([tnrfb])|([\\\\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|([\\r\\n]|\\\\[^uU]|\\\\u[^]{4}|\\\\U[^]{8}))/g;\n\nconst unescape_literal_short_hard = s_literal => s_literal\n\t.replace(R_STRLIT_SHORT_CONTENTS_ESCAPES_HARD, F_REPLACE_STRLIT_CONTENTS);\n\nconst unescape_literal_short_soft = (s_literal) => {\n\tlet m_incomplete = R_STRLIT_ESCAPE_INCOMPLETE.exec(s_literal);\n\n\t// incomplete escape\n\tif(m_incomplete) {\n\t\tlet i_safe = m_incomplete.index;\n\n\t\t// rewind\n\t\treturn [\n\t\t\ts_literal.slice(0, i_safe)\n\t\t\t\t.replace(R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),\n\t\t\ts_literal.slice(i_safe),\n\t\t];\n\t}\n\t// done\n\telse {\n\t\treturn [\n\t\t\ts_literal\n\t\t\t\t.replace(R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),\n\t\t\t'',\n\t\t];\n\t}\n};\n\n\nconst R_STRLIT_LONG_CONTENTS_ESCAPES_HARD = /(?:\\\\(?:([tnrfb])|([\\\\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|(\\\\.))/g;\nconst R_STRLIT_LONG_CONTENTS_ESCAPES_SOFT = /(?:\\\\(?:([tnrfb])|([\\\\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|(\\\\[^uU]|\\\\u[^]{4}|\\\\U[^]{8}))/g;\n\nconst unescape_literal_long_hard = s_literal => s_literal\n\t.replace(R_STRLIT_LONG_CONTENTS_ESCAPES_HARD, F_REPLACE_STRLIT_CONTENTS);\n\nconst unescape_literal_long_soft = (s_literal) => {\n\tlet m_incomplete = R_STRLIT_ESCAPE_INCOMPLETE.exec(s_literal);\n\n\t// incomplete escape\n\tif(m_incomplete) {\n\t\tlet i_safe = m_incomplete.index;\n\n\t\t// rewind\n\t\treturn [\n\t\t\ts_literal.slice(0, i_safe)\n\t\t\t\t.replace(R_STRLIT_LONG_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),\n\t\t\ts_literal.slice(i_safe),\n\t\t];\n\t}\n\t// done\n\telse {\n\t\treturn [\n\t\t\ts_literal\n\t\t\t\t.replace(R_STRLIT_LONG_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),\n\t\t\t'',\n\t\t];\n\t}\n};\n\n// lookbehind regexes\nconst [\n\tR_STRLIT_ESCAPE_INCOMPLETE,\n\tR_STRLIT_SHORT_DOUBLE_TERM,\n\tR_STRLIT_SHORT_SINGLE_TERM,\n\tR_STRLIT_LONG_DOUBLE_TERM,\n\tR_STRLIT_LONG_SINGLE_TERM,\n] = (() => {\n\tfunction RegExp_$lookbehind_polyfill(s_input) {\n\t\tlet m_match = RegExp.prototype.exec.call(this, s_input);\n\n\t\tif(m_match) {\n\t\t\tlet i_start = m_match[0].length - m_match[1].length;\n\t\t\tm_match.index += i_start;\n\t\t\tm_match[0] = m_match[0].slice(i_start);\n\t\t}\n\n\t\treturn m_match;\n\t}\n\tlet mk_lookbehind_regex = (() => {\n\t\ttry {\n\t\t\tnew RegExp('(?<!h)i');  // eslint-disable-line no-new\n\t\t}\n\t\tcatch(e_compile) {\n\t\t\treturn (f_lookbehind, r_polyfill, f_polyfill) => {\n\t\t\t\tr_polyfill.exec = f_polyfill;\n\t\t\t\treturn r_polyfill;\n\t\t\t};\n\t\t}\n\t\treturn f_lookbehind => f_lookbehind();\n\t})();\n\treturn [\n\t\t// R_STRLIT_ESCAPE_INCOMPLETE\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\\\\\\\\(|u[0-9A-Fa-f]{0,3}|U[0-9A-Fa-f]{0,7})$'),\n\t\t\t/^(?:(?:[^\\\\]|\\\\.)*)(\\\\(?:|u[0-9A-Fa-f]{0,3}|U[0-9A-Fa-f]{0,7}))$/,\n\t\t\tfunction RegExp_$lookbehind_polyfill_n(s_input) {\n\t\t\t\tlet m_match = RegExp.prototype.exec.call(this, s_input);\n\t\t\t\tif(m_match) {\n\t\t\t\t\tm_match.index += m_match[0].length - m_match[1].length;\n\t\t\t\t}\n\n\t\t\t\treturn m_match;\n\t\t\t},\n\t\t),\n\t\t// R_STRLIT_SHORT_DOUBLE_TERM\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\"\\\\s*', 'g'),\n\t\t\t/(?:[^\\\\\"]|\\\\.)*(\"\\s*)/y,\n\t\t\tRegExp_$lookbehind_polyfill,\n\t\t),\n\t\t// R_STRLIT_SHORT_SINGLE_TERM\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\\'\\\\s*', 'g'),\n\t\t\t/(?:[^\\\\']|\\\\.)*('\\s*)/y,\n\t\t\tRegExp_$lookbehind_polyfill,\n\t\t),\n\n\t\t// R_STRLIT_LONG_DOUBLE_TERM\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\"\"\"\\\\s*', 'g'),\n\t\t\t/(?:[^\\\\\"]|\\\\.|\"\"?(?!\"))*(\"\"\"\\s*)/y,\n\t\t\tRegExp_$lookbehind_polyfill,\n\t\t),\n\n\t\t// R_STRLIT_LONG_SINGLE_TERM\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\\'\\'\\'\\\\s*', 'g'),\n\t\t\t/(?:[^\\\\']|\\\\.|''?(?!'))*('''\\s*)/y,\n\t\t\tRegExp_$lookbehind_polyfill,\n\t\t),\n\n\t];\n})();\n\nconst match_prefixed_name_quick = (s, i) => {\n\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\treturn [R_PREFIXED_NAME_QUICK.exec(s), R_PREFIXED_NAME_QUICK.lastIndex];\n};\n\nconst match_prefixed_name_escapeless = (s, i) => {\n\tR_PREFIXED_NAME_ESCAPELESS.lastIndex = i;\n\treturn [R_PREFIXED_NAME_ESCAPELESS.exec(s), R_PREFIXED_NAME_ESCAPELESS.lastIndex];\n};\n\nconst match_prefixed_name = (s, i) => {\n\tR_PREFIXED_NAME.lastIndex = i;\n\treturn [R_PREFIXED_NAME.exec(s), R_PREFIXED_NAME.lastIndex];\n};\n\n\n\nfunction Reader$syntax_error(k_self, i, si_state, s_info) {\n\tlet i_off = Math.min(i, Math.abs(i-15));\n\n\tlet s = k_self.s;\n\n\treturn k_self.error(`\\n\\`${s.substr(i_off, i_off+90).replace(/[\\n\\t]/g, ' ')}\\`\\n`\n\t\t+` ${' '.repeat(i-i_off)}^\\n`\n\t\t+`expected ${si_state} ${s_info || ''}.  failed to parse a valid token starting at ${s[i]? '\"'+s[i]+'\"': '<<EOF>>'}`);\n}\n\n\n\nclass TriG_Reader extends stream.Transform {\n\tconstructor(g_impls) {\n\t\tsuper({\n\t\t\t// do not decode strings into buffers\n\t\t\tdecodeStrings: false,\n\n\t\t\t// accept strings as input on writable side\n\t\t\twritableObjectMode: false,\n\n\t\t\t// output quad objects on readable side\n\t\t\treadableObjectMode: true,\n\n\t\t\t// implementations\n\t\t\tflush: g_impls.flush,\n\t\t\ttransform: g_impls.transform,\n\t\t});\n\t}\n\n\t// intercept pipe\n\tpipe(ds_out) {\n\t\tlet ds_dst = ds_out;\n\n\t\t// non-object mode\n\t\tif(!ds_dst._writableState.objectMode) {\n\t\t\t// transform to JSON\n\t\t\tds_out = stream.quads_to_json();\n\t\t}\n\t\t// yet object mode and graphy writable\n\t\telse if(ds_out.isGraphyWritable) {\n\t\t\t// transform to writable data events\n\t\t\tds_out = stream.quads_to_writable();\n\t\t}\n\n\t\t// interim stream created\n\t\tif(ds_out !== ds_dst) {\n\t\t\t// forward output to super\n\t\t\tsuper.pipe(ds_out);\n\n\t\t\t// pipe outpu to destination\n\t\t\treturn ds_out.pipe(ds_dst);\n\t\t}\n\t\t// forward as-is to super\n\t\telse {\n\t\t\treturn super.pipe(ds_dst);\n\t\t}\n\t}\n}\n\n\nclass Reader {\n\tconstructor(g_config={}) {\n\t\t// impl-specific configs\n\t\tlet {\n\t\t\t// input medium\n\t\t\tinput: g_input=null,\n\n\t\t\t// a state to inherit\n\t\t\tstate: g_state={},\n\t\t} = g_config;\n\n\t\t// inherit state from creator\n\t\tlet {\n\t\t\t// index for anonymous blank node labels\n\t\t\tblank_node_index: i_anon=0,\n\n\t\t\t// prefix map\n\t\t\tprefixes: h_prefixes={},\n\n\t\t\t// blank node label map\n\t\t\tlabels: h_labels={},\n\t\t} = g_state;\n\n\n\t\tlet dc_factory = factory.adopt(g_config.dataFactory || g_config.data_factory || factory.unfiltered);\n\n\t\tlet kt_default_graph = dc_factory.defaultGraph();\n\n\t\t// if data factory is not graphy, it might be returning the same object on each call to .defaultGraph()\n\t\tif(dc_factory !== factory.unfiltered) {\n\t\t\t// do not trust it, create a new object\n\t\t\tkt_default_graph = Object.create(kt_default_graph);\n\t\t}\n\n\t\tlet kt_rdf_first = dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#first');\n\n\t\tlet blankNode = dc_factory.blankNode;\n\t\tlet namedNode = dc_factory.namedNode;\n\n\t\tthis.emit_data = factory.unfiltered === dc_factory\n\t\t\t? function() {\n\t\t\t\tds_transform.push(quad(this));\n\t\t\t}\n\t\t\t: function() {\n\t\t\t\tlet g_quad = dc_factory.quad(this._kt_subject, this._kt_predicate, this._kt_object, this._kt_graph);\n\t\t\t\tds_transform.push(g_quad);\n\t\t\t};\n\n\t\t// fields\n\t\tObject.assign(this, {\n\t\t\t// read index\n\t\t\ti: 0,\n\n\t\t\t// string buffer\n\t\t\ts: '',\n\n\t\t\t// string buffer length\n\t\t\tn: 0,\n\n\t\t\t// left-over string from previous data chunk\n\t\t\tpre: g_config.prepend || '',\n\n\t\t\t// debug state\n\t\t\t_b_debug: g_config.debug || false,\n\n\t\t\t// relax\n\t\t\t_b_relax: g_config.relax || false,\n\n\t\t\t// factory\n\t\t\t_dc_factory: dc_factory,\n\n\t\t\t// current reader state\n\t\t\t_f_state: this.block,\n\n\t\t\t// map of current prefix ids => iris\n\t\t\t_h_prefixes: h_prefixes,\n\n\n\t\t\t// reader was destroyed by an error\n\t\t\t_b_destroyed: false,\n\n\t\t\t// current @base url\n\t\t\t_s_base_url: '',\n\t\t\t_s_base_url_scheme: '',\n\t\t\t_s_base_url_root: '',\n\t\t\t_s_base_url_path: '',\n\n\t\t\t// current data\n\t\t\t_kt_subject: null,\n\t\t\t_kt_predicate: kt_rdf_first,\n\t\t\t_kt_object: null,\n\t\t\t_kt_graph: kt_default_graph,\n\t\t\t_s_literal: '',\n\n\t\t\t// static terms\n\t\t\t_kt_rdf_type: dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),\n\t\t\t_kt_rdf_first: kt_rdf_first,\n\t\t\t_kt_rdf_rest: dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#rest'),\n\t\t\t_kt_rdf_nil: dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#nil'),\n\t\t\t_kt_default_graph: kt_default_graph,\n\n\t\t\t// queue of nested subject, predicate, state for blanknodes and collections\n\t\t\t_a_nested: [],\n\n\t\t\t// hash to keep track of all blank node labels in use\n\t\t\t_h_labels: h_labels,\n\n\t\t\t// event routing\n\t\t\tevent: this.emit,\n\t\t\tdata: this.emit_data,\n\n\t\t\t// for restoring the original event callback when resuming paused stream\n\t\t\trestore_data: this.emit_data,\n\n\t\t\t// keep a queue of data events to hold onto until stream resumes (only happens in rare conditions)\n\t\t\t_a_queue_event: [],\n\n\t\t\t// helper states\n\t\t\t_b_expecting_full_stop: false,\n\t\t\t_s_temp_prefix_id: null,\n\t\t\t_b_trim_start: true,\n\n\t\t\tanonymous_blank_node: s_label => blankNode(s_label, true),\n\n\t\t\t// finds the next non-conflicting blank node label\n\t\t\tnext_label() {\n\t\t\t\tlet s_label = '';\n\t\t\t\tdo {\n\t\t\t\t\ts_label = 'g'+(i_anon++);\n\t\t\t\t} while(this._h_labels[s_label]);\n\n\t\t\t\t// claim this label, and remember that we invented it\n\t\t\t\tthis._h_labels[s_label] = 2;\n\n\t\t\t\t// return the label\n\t\t\t\treturn s_label;\n\t\t\t},\n\n\t\t\t// what to do when reach eos\n\t\t\teos: null,\n\n\t\t\t// which state to go to after end of statement\n\t\t\tafter_end_of_statement: this.post_object,\n\n\t\t\t// maximum length of a token: defaults to 2048 => http://stackoverflow.com/a/417184/1641160\n\t\t\t_n_max_token_length: g_config.max_token_length || g_config.maxTokenLength || 2048,\n\n\t\t\t// maximum length of a string (overrides max_token_length): defaults to Infinity\n\t\t\t_n_max_string_length: g_config.max_string_length || g_config.maxStringLength || Infinity,\n\n\t\t\t// byte tracking\n\t\t\t_b_byte_tracking: g_config.byte_tracking || g_config.byteTracking || false,\n\t\t\t_nb_seen: 0,\n\t\t\t_nb_last: 0,\n\t\t\t_nb_curr: 0,\n\t\t});\n\n\t\tif(g_config.relaxed) {\n\t\t\tconsole.warn((new Error(`no such option 'relaxed'; did you mean 'relax' ?`)).stack.replace(/^Error:/, 'Warning:'));\n\t\t}\n\t\tif('validate' in g_config) {\n\t\t\tconsole.warn((new Error(`option 'validate' has been deprecated. Validation is now enabled by default. Use the 'relax' option if you wish to disable validation.`)).stack.replace(/^Error:/, 'Warning:'));\n\t\t}\n\n\n\n\t\t// term constructors\n\t\tObject.assign(this, !g_config.relax\n\t\t\t? {\n\t\t\t\tblank_node(s_label) {\n\t\t\t\t\t// test valid blank node label\n\t\t\t\t\tif(!RT_BLANK_NODE_VALID.test(s_label)) return this.error(`invalid blank node label: \"${s_label}\"`);\n\n\t\t\t\t\t// not first time use of label\n\t\t\t\t\tlet z_label_state = this._h_labels[s_label];\n\t\t\t\t\tif(z_label_state) {\n\t\t\t\t\t\t// label was used previously by document and has no conflict\n\t\t\t\t\t\tif(1 === z_label_state) {}  // eslint-disable-line no-empty\n\t\t\t\t\t\t// label is in use by invention, this would cause a conflict\n\t\t\t\t\t\telse if(2 === z_label_state) {\n\t\t\t\t\t\t\t// so create a redirect mapping for this actual label & use it instead\n\t\t\t\t\t\t\ts_label = this._h_labels[s_label] = this.next_label();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// label already has a redirect mapping\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// use redirected label\n\t\t\t\t\t\t\ts_label = this._h_labels[s_label];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// first time use of label\n\t\t\t\t\telse {\n\t\t\t\t\t\t// store label in hash so we avoid future collisions\n\t\t\t\t\t\tthis._h_labels[s_label] = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// make term\n\t\t\t\t\treturn blankNode(s_label);\n\t\t\t\t},\n\n\t\t\t\tcheck_named_node(p_iri) {\n\t\t\t\t\tif(!RT_NAMED_NODE_VALID.test(p_iri)) return this.error(`invalid IRI: \"${p_iri}\"`);\n\t\t\t\t\treturn namedNode(p_iri);\n\t\t\t\t},\n\n\t\t\t\tcheck_named_node_escapeless(p_iri) {\n\t\t\t\t\tif(!RT_NAMED_NODE_ESCAPELESS_VALID.test(p_iri)) return this.error(`invalid IRI: \"${p_iri}\"`);\n\t\t\t\t\treturn namedNode(p_iri);\n\t\t\t\t},\n\n\t\t\t\tmatch_prefixed_name_quick(s, i) {\n\t\t\t\t\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\t\t\t\t\treturn [R_PREFIXED_NAME_QUICK.exec(s), R_PREFIXED_NAME_QUICK.lastIndex];\n\t\t\t\t},\n\n\t\t\t\tmatch_prefixed_name_escapeless(s, i) {\n\t\t\t\t\tlet [m_prefixed_name_e, im_prefixed_name_e] = match_prefixed_name_escapeless(s, i);\n\t\t\t\t\tif(m_prefixed_name_e) {\n\t\t\t\t\t\t// invalid local name\n\t\t\t\t\t\tif(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name_e[2]) && m_prefixed_name_e[2]) {\n\t\t\t\t\t\t\tthis.error(`invalid prefixed name local name: \"${m_prefixed_name_e[2]}:\"`);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [m_prefixed_name_e, im_prefixed_name_e];\n\t\t\t\t},\n\n\t\t\t\tmatch_prefixed_name(s, i) {\n\t\t\t\t\tlet [m_prefixed_name, im_prefixed_name] = match_prefixed_name(s, i);\n\t\t\t\t\tif(m_prefixed_name) {\n\t\t\t\t\t\t// invalid local name\n\t\t\t\t\t\tif(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name[2])) {\n\t\t\t\t\t\t\tthis.error(`invalid prefixed name local name: \"${m_prefixed_name[2]}:\"`);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [m_prefixed_name, im_prefixed_name];\n\t\t\t\t},\n\t\t\t}\n\t\t\t: {\n\t\t\t\t// term constructors\n\t\t\t\tblank_node(s_label) {\n\t\t\t\t\t// not first time use of label\n\t\t\t\t\tlet z_label_state = this._h_labels[s_label];\n\t\t\t\t\tif(z_label_state) {\n\t\t\t\t\t\t// label was used previously by document and has no conflict\n\t\t\t\t\t\tif(1 === z_label_state) {}  // eslint-disable-line no-empty\n\t\t\t\t\t\t// label is in use by invention, this would cause a conflict\n\t\t\t\t\t\telse if(2 === z_label_state) {\n\t\t\t\t\t\t\t// so create a redirect mapping for this actual label & use it instead\n\t\t\t\t\t\t\ts_label = this._h_labels[s_label] = this.next_label();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// label already has a redirect mapping\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// use redirected label\n\t\t\t\t\t\t\ts_label = this._h_labels[s_label];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// first time use of label\n\t\t\t\t\telse {\n\t\t\t\t\t\t// store label in hash so we avoid future collisions\n\t\t\t\t\t\tthis._h_labels[s_label] = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// make term\n\t\t\t\t\treturn blankNode(s_label);\n\t\t\t\t},\n\n\t\t\t\tcheck_named_node: namedNode,\n\n\t\t\t\tcheck_named_node_escapeless: namedNode,\n\n\t\t\t\tmatch_prefixed_name_escapeless,\n\n\t\t\t\tmatch_prefixed_name,\n\t\t\t});\n\n\n\t\tthis.named_node = namedNode;\n\n\t\tthis.prefixed_name = function(si_prefix, s_suffix) {\n\t\t\treturn namedNode(h_prefixes[si_prefix] + s_suffix);\n\t\t};\n\n\n\t\t// oops -- user passed string into `base`\n\t\tif('string' === typeof g_config.base) {\n\t\t\tthrow new TypeError(`invalid type 'string' was given for 'base' event listener: '${g_config.base}'\\n`\n\t\t\t\t+`did you mean to use the 'base_uri' key instead?`);\n\t\t}\n\n\t\t// base uri\n\t\tlet p_set_base_uri = g_config.base_uri || g_config.baseUri || g_config.baseURI || g_config.base_iri || g_config.baseIri || g_config.baseIRI;\n\t\tif(p_set_base_uri) {\n\t\t\tlet m_base_iri = R_BASE_IRI.exec(p_set_base_uri);\n\t\t\tthis._s_base_url = m_base_iri[1];\n\t\t\tthis._s_base_url_root = m_base_iri[2] || '';\n\t\t\tthis._s_base_url_scheme = m_base_iri[3] || '';\n\t\t\tthis._s_base_url_path = m_base_iri[4] || '';\n\t\t}\n\t\t// not set; 'url' variant is\n\t\telse if(g_config.base_url || g_config.baseUrl || g_config.baseURL) {\n\t\t\tthrow new Error(`invalid option: .base${g_config.base_url? '_url': g_config.baseUrl? 'Url': g_config.baseURL? 'URL': ''}; use the '.base_uri' key instead`);\n\t\t}\n\n\t\t// transform stream\n\t\tlet ds_transform = this.transform = new TriG_Reader({\n\t\t\t// on data event\n\t\t\ttransform: (s_chunk, s_encoding, fke_chunk) => {\n\t\t\t\t// concatenate current chunk to previous chunk\n\t\t\t\tlet s = this.s = this.pre + s_chunk;\n\n\t\t\t\t// cache chunk length\n\t\t\t\tthis.n = s.length;\n\n\t\t\t\t// eat whitespace before token and reset index\n\t\t\t\tif(this._b_trim_start) {\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\tR_WS.lastIndex = 0;\n\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\tthis.i = R_WS.lastIndex;\n\t\t\t\t}\n\t\t\t\t// do not eat whitespace; start at beginning\n\t\t\t\telse {\n\t\t\t\t\tthis.i = 0;\n\t\t\t\t}\n\n\t\t\t\t// resume parsing; no errors\n\t\t\t\tif(this.safe_parse(true)) {\n\t\t\t\t\t// emit progress event updates\n\t\t\t\t\tds_transform.emit('progress', s_chunk.length);\n\n\t\t\t\t\t// done transforming this chunk\n\t\t\t\t\tfke_chunk();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// once there's no more data to consume, invoke eof\n\t\t\tflush: (fke_flush) => {\n\t\t\t\t// now that input stream has ended, clean up remainder\n\t\t\t\ttry {\n\t\t\t\t\tthis.eof(1);\n\t\t\t\t}\n\t\t\t\t// read error occurred\n\t\t\t\tcatch(e_eof) {\n\t\t\t\t\t// destroy self and stream\n\t\t\t\t\tthis.destroy(e_eof);\n\n\t\t\t\t\t// exit gracefully\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// no errors. done flushing, close read stream\n\t\t\t\tfke_flush();\n\t\t\t},\n\t\t});\n\n\t\t// when the writable side is piped into\n\t\tds_transform.on('pipe', (ds_input) => {\n\t\t\tthis._ds_input = ds_input;\n\n\t\t\tlet b_byte_tracking = this._b_byte_tracking;\n\n\t\t\t// byte-tracking is disable & input stream has encoding option; ensure stream encoding is utf8\n\t\t\tif(!b_byte_tracking && 'function' === typeof ds_input.setEncoding) {\n\t\t\t\tds_input.setEncoding('utf8');\n\t\t\t}\n\t\t\t// set decoding on write\n\t\t\telse {\n\t\t\t\tlet f_write = ds_transform.write;\n\t\t\t\tlet d_decoder = new string_decoder.StringDecoder('utf8');\n\n\t\t\t\tlet f_write_track = (s_chunk, s_encoding, fk_write) => {\n\t\t\t\t\t// TODO: optimize by testing for multibyte chars and using string length instead?\n\t\t\t\t\tlet nb_chunk = Buffer.from(s_chunk, 'utf8').length;\n\t\t\t\t\tthis._nb_seen += nb_chunk;\n\t\t\t\t\tthis._nb_last = nb_chunk;\n\t\t\t\t\treturn f_write.call(ds_transform, s_chunk, s_encoding, fk_write);\n\t\t\t\t};\n\n\t\t\t\tlet f_decode_write_track = (ab_chunk, s_encoding, fk_write) => {\n\t\t\t\t\tlet nb_chunk = this._nb_last = ab_chunk.length;\n\t\t\t\t\tthis._nb_seen += nb_chunk;\n\t\t\t\t\treturn f_write.call(ds_transform, d_decoder.write(ab_chunk), s_encoding, fk_write);\n\t\t\t\t};\n\n\t\t\t\tlet f_decode_write = (ab_chunk, s_encoding, fk_write) => f_write.call(ds_transform, d_decoder.write(ab_chunk), s_encoding, fk_write);\n\n\t\t\t\tds_transform.write = function(z_chunk, s_encoding, fk_write) {\n\t\t\t\t\t// not null\n\t\t\t\t\tif(null !== z_chunk) {\n\t\t\t\t\t\t// chunk is string; adapt by resetting method to original\n\t\t\t\t\t\tif('string' === typeof z_chunk) {\n\t\t\t\t\t\t\tds_transform.write = b_byte_tracking? f_write_track: f_write;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// chunk is buffer; adapt by setting decoder write method\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tds_transform.write = b_byte_tracking? f_decode_write_track: f_decode_write;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// use set method\n\t\t\t\t\t\treturn ds_transform.write(z_chunk, s_encoding, fk_write);\n\t\t\t\t\t}\n\n\t\t\t\t\t// null, use parent\n\t\t\t\t\treturn f_write.call(ds_transform, z_chunk, s_encoding, fk_write);\n\t\t\t\t};\n\n\t\t\t\t// byte tracking is enabled\n\t\t\t\tif(b_byte_tracking) {\n\t\t\t\t\t// overwrite emit_data method\n\t\t\t\t\tthis.emit_data = this.data = this.restore_data = function() {\n\t\t\t\t\t\tlet g_quad = this._dc_factory.quad(this._kt_subject, this._kt_predicate, this._kt_object, this._kt_graph);\n\t\t\t\t\t\tlet nb_post = Buffer.from(this.s.slice(this.i)).length;\n\t\t\t\t\t\tlet ib_post = this._nb_seen - nb_post;\n\t\t\t\t\t\tg_quad.byteRange = [this._nb_curr, ib_post];\n\t\t\t\t\t\tthis._nb_curr = ib_post;\n\t\t\t\t\t\tthis.transform.push(g_quad);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// new listener added\n\t\tds_transform.on('newListener', (s_event) => {\n\t\t\t// comment\n\t\t\tif('comment' === s_event) {\n\t\t\t\tthis.emit_comments = (s_captured) => {\n\t\t\t\t\tlet a_comments = s_captured.slice(1).replace(/\\n\\s+$/, '').split(/\\n+\\s*#/g);\n\n\t\t\t\t\tfor(let s_comment of a_comments) {\n\t\t\t\t\t\tds_transform.emit('comment', s_comment);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\t// destroy\n\t\tds_transform._destroy = (...a_args) => {\n\t\t\tthis.destroy(...a_args);\n\t\t};\n\n\t\t// bind events to transform stream\n\t\tthis.bind(g_config);\n\n\t\t// input given\n\t\tif(g_input) {\n\t\t\t// input is stream\n\t\t\tif(g_input.stream) {\n\t\t\t\tlet ds_input = g_input.stream;\n\n\t\t\t\t// go async so caller has chance to bind event listeners\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tds_input.pipe(ds_transform);\n\t\t\t\t});\n\t\t\t}\n\t\t\t// string\n\t\t\telse if('string' === typeof g_input.string) {\n\t\t\t\tlet s_input = g_input.string;\n\n\t\t\t\t// go async so caller has chance to bind event listeners\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tds_transform.end(s_input, 'utf8');\n\t\t\t\t});\n\t\t\t}\n\t\t\t// invalid arg\n\t\t\telse {\n\t\t\t\tthrow new TypeError(`Invalid argument for input parameter: ${'object' === typeof g_input? JSON.stringify(g_input): g_input}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t// begin parsing, keep applying until no more stack bail-outs\n\tsafe_parse() {\n\t\ttry {\n\t\t\tlet f_sync = this._f_state();\n\t\t\twhile('function' === typeof f_sync) {\n\t\t\t\tf_sync = f_sync.apply(this);\n\t\t\t}\n\t\t}\n\t\t// read error occurred\n\t\tcatch(e_read) {\n\t\t\t// destroy self and stream\n\t\t\tthis.destroy(e_read);\n\n\t\t\t// failure\n\t\t\treturn false;\n\t\t}\n\n\t\t// okay\n\t\treturn true;\n\t}\n\n\n\temit(s_event, ...a_args) {\n\t\tthis.transform.emit(s_event, ...a_args);\n\t}\n\n\tqueue(s_event, ...a_args) {\n\t\tthis._a_queue_event.push({\n\t\t\tevent: s_event,\n\t\t\targs: a_args,\n\t\t});\n\t}\n\n\terror(s_message) {\n\t\t// bail out\n\t\tthrow new Error(s_message);\n\t}\n\n\t// parse_error (not meant to be an event callback)\n\tparse_error(s_expected, b_eof=false) {\n\t\tlet i = this.i;\n\n\t\tlet i_off = Math.min(i, Math.abs(i-15));\n\n\t\tlet s = this.s;\n\n\t\treturn this.error(`\\n\\`${s.substr(i_off, i_off+90).replace(/[\\n\\t]/g, ' ')}\\`\\n`\n\t\t\t+` ${' '.repeat(i-i_off)}^\\n`\n\t\t\t+`expected ${s_expected} ${b_eof? 'but encountered <<EOF>>': ''}.  failed to parse a valid token starting at ${s[i]? '\"'+s[i]+'\"': '<<EOF>>'}`);\n\t}\n\n\tinfo_error(s_message) {\n\t\tlet i = this.i;\n\n\t\tlet i_off = Math.min(i, Math.abs(i-15));\n\n\t\tlet s = this.s;\n\n\t\tthis.error(`\\n\\`${s.substr(i_off, i_off+90).replace(/[\\n\\t]/g, ' ')}\\`\\n`\n\t\t\t+` ${' '.repeat(i-i_off)}^\\n`\n\t\t\t+s_message);\n\t}\n\n\t// end of file\n\teof() {\n\t\t// there are events queued\n\t\tif(this._a_queue_event.length) {\n\t\t\tlet a_queue = this._a_queue_event;\n\n\t\t\t// drain event queue\n\t\t\twhile(a_queue.length) {\n\t\t\t\t// remove event from front of queue\n\t\t\t\tlet h_event = a_queue.shift();\n\n\t\t\t\t// make event callback\n\t\t\t\tthis[h_event.event](h_event.data);\n\t\t\t}\n\t\t}\n\n\t\t// invalid parsing state\n\t\tif(this.block !== this._f_state) {\n\t\t\t// append EOF char\n\t\t\tthis.s += '\\0';\n\n\t\t\t// exit \"flowing\" mode\n\t\t\tthis.n = this.s.length;\n\n\t\t\t// resume parsing; no errors\n\t\t\tif(this.safe_parse()) {\n\t\t\t\t// eof has occurred under safe parse\n\t\t\t\tif(null === this.s) return;\n\n\t\t\t\t// still invalid parsing state\n\t\t\t\tif(this.block !== this._f_state) {\n\t\t\t\t\treturn this.parse_error(this._f_state.name, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// there are still unparsed characters\n\t\tif(this.i < this.n) {\n\t\t\t// consume whitespace and comments\n\t\t\tlet s = this.s;\n\t\t\tlet i = this.i;\n\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\tR_WS.lastIndex = i;\n\t\t\tR_WS.exec(s);\n\t\t\ti = R_WS.lastIndex;\n\t\t\tR_COMMENT.lastIndex = i;\n\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t// advance beyond comment\n\t\t\tif(R_COMMENT.lastIndex > i) {\n\t\t\t\tthis.i = i = R_COMMENT.lastIndex;\n\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t}\n\n\t\t\t// still unparsed characters\n\t\t\tif(i < this.n) {\n\t\t\t\t// not EOF\n\t\t\t\tif(!(i === this.n - 1 && '\\0' === s[i])) {\n\t\t\t\t\t// bad input; parse error\n\t\t\t\t\treturn this.parse_error(this._f_state.name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// make buffer's alloc eligible for gc\n\t\tthis.s = null;\n\n\t\t// transform stream\n\t\tlet ds_transform = this.transform;\n\n\t\t// final progress update: no additional bytes were read\n\t\tds_transform.emit('progress', 0);\n\n\t\t// call end event listener\n\t\tds_transform.emit('eof', this._h_prefixes);\n\n\t\t// close write stream (EOF-signaling)\n\t\tds_transform.push(null);\n\t}\n\n\n\n\t// bind event listeners to transform stream\n\tbind(g_config) {\n\t\tlet ds_transform = this.transform;\n\t\tif(g_config.base) ds_transform.on('base', g_config.base);\n\t\tif(g_config.prefix) ds_transform.on('prefix', g_config.prefix);\n\t\tif(g_config.enter) ds_transform.on('enter', g_config.enter);\n\t\tif(g_config.exit) ds_transform.on('exit', g_config.exit);\n\t\tif(g_config.comment) ds_transform.on('comment', g_config.comment);\n\t\tif(g_config.error) ds_transform.on('error', g_config.error);\n\t\tif(g_config.read) ds_transform.once('read', g_config.read);\n\t\tif(g_config.progress) ds_transform.on('progress', g_config.progress);\n\t\tif(g_config.eof) ds_transform.once('eof', g_config.eof);\n\t\tif(g_config.end) ds_transform.once('end', g_config.end);\n\t\tif(g_config.finish) ds_transform.once('finish', g_config.finish);\n\t\tif(g_config.data) ds_transform.on('data', g_config.data);\n\t}\n\n\t// after a blank node subject (either property-list or colleciton)\n\tpost_blank_subject() {\n\t\tlet {s, i} = this;\n\t\tif('.' === s[i]) {\n\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\tR_WS.lastIndex = i+1;\n\t\t\tR_WS.exec(s);\n\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t// not inside block\n\t\t\tif(this._kt_default_graph === this._kt_graph) {\n\t\t\t\treturn this.block();\n\t\t\t}\n\t\t\t// inside block\n\t\t\telse {\n\t\t\t\treturn this.statement();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// prepare sticky regex index\n\t\t\tR_CHAR_CLOSE.lastIndex = i;\n\n\t\t\tif(R_CHAR_CLOSE.exec(s)) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_CHAR_CLOSE.lastIndex;\n\t\t\t\t// empty collection\n\t\t\t\tif(this._kt_rdf_nil.equals(this._kt_subject)) {\n\t\t\t\t\treturn this.error('empty collection');\n\t\t\t\t}\n\n\t\t\t\t// emit graph_close event\n\t\t\t\tthis.emit('exit', this._kt_graph);\n\n\t\t\t\t// reset graph\n\t\t\t\tthis._kt_graph = this._kt_default_graph;\n\n\t\t\t\t// goto block state\n\t\t\t\treturn this.block();\n\t\t\t}\n\t\t} // brace #1\n\n\t\treturn this.pairs();\n\t}\n\n\n\n\t// parse state for statement\n\tstatement() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// prefixed name quick\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_pnq_subject = R_PREFIXED_NAME_QUICK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_pnq_subject) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_PREFIXED_NAME_QUICK.lastIndex;\n\t\t\t\t// check valid prefix\n\t\t\t\tlet s_prefix_id = m_pnq_subject[1] || '';\n\t\t\t\t// invalid prefix\n\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t// commit subject iri from resolve prefixed name\n\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, m_pnq_subject[2]);\n\n\t\t\t\t// predicate-object pairs state\n\t\t\t\treturn this.pairs();\n\n\t\t\t// iriref\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_e_subject = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_e_subject) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_e_subject[1];\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set subject\n\t\t\t\t\t\tthis._kt_subject = this.check_named_node_escapeless(s_iri);\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis._kt_subject = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t}\n\n\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\treturn this.pairs();\n\n\n\n\t\t\t\t// prefixed name\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// try match\n\t\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t\t// stack bail out\n\t\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\t\tlet [m_prefixed_named_e_subject, im_prefixed_named_e_subject] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\t\tif(m_prefixed_named_e_subject) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = im_prefixed_named_e_subject;\n\n\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_subject[1] || '';\n\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, m_prefixed_named_e_subject[2]);\n\n\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t// blank node label\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_blank_node_label_subject = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_blank_node_label_subject) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t\t// extract label\n\t\t\t\t\t\t\tlet s_label = m_blank_node_label_subject[1];\n\n\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\tthis._kt_subject = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t// anonymous blank node subject\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_ANONYMOUS_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\t\tif(R_ANONYMOUS_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_ANONYMOUS_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\t// set new blank node as subject\n\t\t\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t\t// anonymous blank node property list subject\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_CHAR_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\t\t\tif(R_CHAR_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\t\t// enter blank node\n\t\t\t\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t\t// how to resume when we pop state\n\t\t\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'post_blank_subject']);\n\n\t\t\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t\t\t// rdf collection\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\tR_CHAR_COLLECTION.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\tif(R_CHAR_COLLECTION.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_COLLECTION.lastIndex;\n\t\t\t\t\t\t\t\t\t\t// indicate that collection subject should emit an initial statement\n\t\t\t\t\t\t\t\t\t\tthis._kt_subject = null;\n\n// (don't push state, we don't have a subject yet)\n\n\t\t\t\t\t\t\t\t\t\t// goto collection-subject state\n\t\t\t\t\t\t\t\t\t\treturn this.collection_subject();\n\n\n\t\t\t\t\t\t\t\t\t// closing graph '}'\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_CHAR_CLOSE.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\tif(R_CHAR_CLOSE.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_CLOSE.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t// emit graph_close event\n\t\t\t\t\t\t\t\t\t\t\tthis.emit('exit', this._kt_graph);\n\n\t\t\t\t\t\t\t\t\t\t\t// reset graph\n\t\t\t\t\t\t\t\t\t\t\tthis._kt_graph = this._kt_default_graph;\n\n\t\t\t\t\t\t\t\t\t\t\t// goto block state\n\t\t\t\t\t\t\t\t\t\t\treturn this.block();\n\n\t\t\t\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\tlet m_iriref_subject = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\tif(m_iriref_subject) {\n\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_subject[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// set subject\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_subject, im_prefixed_named_subject] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\t\t\t\tif(m_prefixed_named_subject) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_subject;\n\t\t\t\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_subject[1] || '';\n\t\t\t\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_subject[2]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.pairs();\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t// comment\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not blank node label, not prefix id, not base\n\t\t\t// match counter: 10\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} // brace #10\n\t\t\t\t\t\t\t\t\t\t\t} // brace #9\n\t\t\t\t\t\t\t\t\t\t} // brace #8\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('statement');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.statement;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for block\n\tblock() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// prepare sticky regex index\n\t\t\tR_GRAPH_IRI_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_graph_iriref_e_graph = R_GRAPH_IRI_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_graph_iriref_e_graph) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_GRAPH_IRI_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_graph_iriref_e_graph[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set graph\n\t\t\t\t\tthis._kt_graph = this.check_named_node_escapeless(s_iri);\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_graph = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t}\n\n\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t// statement state\n\t\t\t\treturn this.statement();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_GRAPH_PREFIXED_NAME.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_graph_prefixed_name = R_GRAPH_PREFIXED_NAME.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_graph_prefixed_name) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_GRAPH_PREFIXED_NAME.lastIndex;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_graph_prefixed_name[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// make subject key\n\t\t\t\t\tthis._kt_graph = this.prefixed_name(s_prefix_id, m_graph_prefixed_name[2]);\n\n\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t// statement state\n\t\t\t\t\treturn this.statement();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_CHAR_OPEN.lastIndex = i;\n\n\t\t\t\t\tif(R_CHAR_OPEN.exec(s)) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_CHAR_OPEN.lastIndex;\n\t\t\t\t\t\t// make new default graph\n\t\t\t\t\t\tthis._kt_graph = this._dc_factory.defaultGraph();\n\n\t\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t\t// goto statement state\n\t\t\t\t\t\treturn this.statement();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_GRAPH_ANONYMOUS_BLANK_NODE.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_graph_anonymous_blank_node = R_GRAPH_ANONYMOUS_BLANK_NODE.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_graph_anonymous_blank_node) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_GRAPH_ANONYMOUS_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t// make new label & set graph to blank node\n\t\t\t\t\t\t\tthis._kt_graph = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t\t\t// statement state\n\t\t\t\t\t\t\treturn this.statement();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_GRAPH_LABELED_BLANK_NODE.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_graph_labeled_blank_node = R_GRAPH_LABELED_BLANK_NODE.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_graph_labeled_blank_node) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_GRAPH_LABELED_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\tlet s_label = m_graph_labeled_blank_node[1];\n\n\t\t\t\t\t\t\t\tthis._kt_graph = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t\t\t\t// statement state\n\t\t\t\t\t\t\t\treturn this.statement();\n\n\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\tlet m_iriref_e_graph_subject = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\tif(m_iriref_e_graph_subject) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_e_graph_subject[1];\n\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t// set subject\n\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node_escapeless(s_iri);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// graph or subject\n\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\n\n\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_e_subject, im_prefixed_named_e_subject] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\t\t\t\t\t\tif(m_prefixed_named_e_subject) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_e_subject;\n\n\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_subject[1] || '';\n\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, m_prefixed_named_e_subject[2]);\n\n\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\t\t\t\t\t\t\t\t\t// blank node label\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\tlet m_blank_node_label_subject = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\tif(m_blank_node_label_subject) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\tthis.i = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t// extract label\n\t\t\t\t\t\t\t\t\t\t\tlet s_label = m_blank_node_label_subject[1];\n\n\t\t\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\t\t\t\t\t\t\t\t\t\t// anonymous blank node subject\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\tR_ANONYMOUS_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\t\tif(R_ANONYMOUS_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_ANONYMOUS_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t// set new blank node as subject\n\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\t\t\t\t\t\t\t\t\t\t\t// anonymous blank node property list subject\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\tR_CHAR_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif(R_CHAR_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t// enter blank node\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// how to resume when we pop state\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'post_blank_subject']);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject_property_list();\n\n\t\t\t\t\t\t\t\t\t\t\t\t// rdf collection\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\tR_CHAR_COLLECTION.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(R_CHAR_COLLECTION.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_COLLECTION.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// indicate that collection subject should emit an initial statement\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = null;\n\n// (don't push state, we don't have a subject yet)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// goto collection-subject state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.collection_subject();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// prefix with interupt (e.g., a comment)\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_PREFIX_KEYWORD.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_prefix_keyword = R_PREFIX_KEYWORD.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_prefix_keyword) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_PREFIX_KEYWORD.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// save whether or not to expect a full stop\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._b_expecting_full_stop = !!m_prefix_keyword[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// goto prefix state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.prefix_id();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// base with interupt (e.g., a comment)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_BASE_KEYWORD.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_base_keyword = R_BASE_KEYWORD.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_base_keyword) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_BASE_KEYWORD.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// save whether or not to expect a full stop\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._b_expecting_full_stop = !!m_base_keyword[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// goto base state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.base_iri();\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_iriref_subject = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_iriref_subject) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_subject[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// set subject\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_subject, im_prefixed_named_subject] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_prefixed_named_subject) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_subject;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_subject[1] || '';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_subject[2]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_GRAPH_IRI.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_graph_iriref_graph = R_GRAPH_IRI.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_graph_iriref_graph) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_GRAPH_IRI.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_iri = m_graph_iriref_graph[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// set graph\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_graph = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_graph = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// statement state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.statement();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// comment\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_GRAPH.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(R_GRAPH.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_GRAPH.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_keyword();\n\n\t\t\t\t// not iriref, not prefixed name, not blank node label, not prefix id, not base\n\t\t\t\t// match counter: 17\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #17\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #16\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #15\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #14\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #13\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #12\n\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #11\n\t\t\t\t\t\t\t\t\t\t\t\t} // brace #10\n\t\t\t\t\t\t\t\t\t\t\t} // brace #9\n\t\t\t\t\t\t\t\t\t\t} // brace #8\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('block');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.block;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_or_subject\n\tgraph_or_subject() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet x = s[i];\n\n\t\t\tif('{' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// shift placeholder subject\n\t\t\t\tthis._kt_graph = this._kt_subject;\n\n\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t// reset subject in case of collections\n\t\t\t\tthis._kt_subject = null;\n\n\t\t\t\t// statement state\n\t\t\t\treturn this.statement();\n\n\t\t\t// non-comment\n\t\t\t}\n\t\t\telse if('#' !== x) {\n\t\t\t\treturn this.pairs();\n\n\t\t\t// comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_or_subject');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_or_subject;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_or_subject_property_list\n\tgraph_or_subject_property_list() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet x = s[i];\n\n\t\t\tif(']' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// next state\n\t\t\t\treturn this.graph_or_subject_anon();\n\n\t\t\t// non-comment\n\t\t\t}\n\t\t\telse if('#' !== x) {\n\t\t\t\treturn this.pairs();\n\n\t\t\t// comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_or_subject_property_list');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_or_subject_property_list;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_or_subject_anon\n\tgraph_or_subject_anon() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet x = s[i];\n\n\t\t\tif('{' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// shift placeholder subject\n\t\t\t\tthis._kt_graph = this._kt_subject;\n\n\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t// reset subject in case of collections\n\t\t\t\tthis._kt_subject = null;\n\n\t\t\t\t// pop dummy state\n\t\t\t\tthis._a_nested.pop();\n\n\t\t\t\t// statement state\n\t\t\t\treturn this.statement();\n\n\t\t\t// non-comment\n\t\t\t}\n\t\t\telse if('#' !== x) {\n\t\t\t\treturn this.pairs();\n\n\t\t\t// comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_or_subject_anon');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_or_subject_anon;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_keyword\n\tgraph_keyword() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// prefixed name\n\t\t\t// try match\n\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t// stack bail out\n\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\tlet [m_prefixed_named_e_graph, im_prefixed_named_e_graph] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\tif(m_prefixed_named_e_graph) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = im_prefixed_named_e_graph;\n\n\t\t\t\t// check valid prefix\n\t\t\t\tlet s_prefix_id = m_prefixed_named_e_graph[1] || '';\n\t\t\t\t// invalid prefix\n\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t// make subject key\n\t\t\t\tthis._kt_graph = this.prefixed_name(s_prefix_id, m_prefixed_named_e_graph[2]);\n\n\t\t\t\t// predicate-object pairs state\n\t\t\t\treturn this.graph_post_name();\n\n\t\t\t// iriref\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_e_graph = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_e_graph) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_e_graph[1];\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set graph\n\t\t\t\t\t\tthis._kt_graph = this.check_named_node_escapeless(s_iri);\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis._kt_graph = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t}\n\n\t\t\t\t\t// graph\n\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t// blank node label\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_blank_node_label_graph = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_blank_node_label_graph) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t// extract label\n\t\t\t\t\t\tlet s_label = m_blank_node_label_graph[1];\n\n\t\t\t\t\t\t// make graph key\n\t\t\t\t\t\tthis._kt_graph = this.blank_node(s_label);\n\n\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t\t// anonymous blank node graph\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_ANONYMOUS_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\tif(R_ANONYMOUS_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_ANONYMOUS_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t// set new blank node as graph\n\t\t\t\t\t\t\tthis._kt_graph = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_iriref_graph = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_iriref_graph) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\tlet s_iri = m_iriref_graph[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t// set graph\n\t\t\t\t\t\t\t\t\tthis._kt_graph = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tthis._kt_graph = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\tlet [m_prefixed_named_graph, im_prefixed_named_graph] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\tif(m_prefixed_named_graph) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_graph;\n\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_graph[1] || '';\n\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_graph[2]\n\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\tthis._kt_graph = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t\t\t\t\t// comment\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t// not iriref, not prefixed name, not blank node label, not prefix id, not base\n\t\t\t\t// match counter: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_keyword');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_keyword;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_post_name\n\tgraph_post_name() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet x = s[i];\n\n\t\t\tif('{' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t// statement state\n\t\t\t\treturn this.statement();\n\n\t\t\t// comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_post_name');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_post_name;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for pairs\n\tpairs() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// benchmarks indicate: regex for end of blank node property list faster than ch\n\n\n// iriref\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_predicate = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_predicate) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_predicate[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set predicate\n\t\t\t\t\tthis._kt_predicate = this.check_named_node_escapeless(s_iri);\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_predicate = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t}\n\n\t\t\t\t// object-list state\n\t\t\t\treturn this.object_list();\n\n\t\t\t// prefixed name\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// try match\n\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t// stack bail out\n\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\tlet [m_prefixed_named_e_predicate, im_prefixed_named_e_predicate] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\tif(m_prefixed_named_e_predicate) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = im_prefixed_named_e_predicate;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_predicate[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// make predicate key\n\t\t\t\t\tthis._kt_predicate = this.prefixed_name(s_prefix_id, m_prefixed_named_e_predicate[2]);\n\n\t\t\t\t\t// object-list state\n\t\t\t\t\treturn this.object_list();\n\n\t\t\t\t// 'a'\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_A.lastIndex = i;\n\n\t\t\t\t\tif(R_A.exec(s)) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_A.lastIndex;\n\t\t\t\t\t\t// make predicate key\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_type;\n\n\t\t\t\t\t\t// object-list state\n\t\t\t\t\t\treturn this.object_list();\n\n\t\t\t\t\t// ']' end of blank node property list\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_CHAR_KET.lastIndex = i;\n\n\t\t\t\t\t\tif(R_CHAR_KET.exec(s)) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_CHAR_KET.lastIndex;\n\t\t\t\t\t\t\tlet s_resume_state;\n\t\t\t\t\t\t\t[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();\n\t\t\t\t\t\t\treturn this[s_resume_state]();\n\n\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_iriref_predicate = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_iriref_predicate) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\tlet s_iri = m_iriref_predicate[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t// set predicate\n\t\t\t\t\t\t\t\t\tthis._kt_predicate = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tthis._kt_predicate = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// object-list state\n\t\t\t\t\t\t\t\treturn this.object_list();\n\n\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\tlet [m_prefixed_named_predicate, im_prefixed_named_predicate] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\tif(m_prefixed_named_predicate) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_predicate;\n\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_predicate[1] || '';\n\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_predicate[2]\n\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t// make predicate key\n\t\t\t\t\t\t\t\t\tthis._kt_predicate = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t\t\t\t\t\t\t// object-list state\n\t\t\t\t\t\t\t\t\treturn this.object_list();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not 'a'\n\t\t\t// match counter: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('pairs');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.pairs;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for object_list\n\tobject_list() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref char\n\t\t\tlet x = s[i];\n\n\t\t\t// string literal * double\n\t\t\tif('\"' === x) {\n\t\t\t\t// enough chars to deduce type\n\t\t\t\tif((i+2) < n) {\n\t\t\t\t\t// long type\n\t\t\t\t\tif('\"' === s[i+1] && '\"' === s[i+2]) {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 3;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_long_double();\n\t\t\t\t\t}\n\t\t\t\t\t// not long type\n\t\t\t\t\telse {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_short_double();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// enough chars to eliminate long type\n\t\t\t\telse if((i+1) < n && '\"' !== s[i+1]) {\n\t\t\t\t\t// advance index beyond token\n\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t// read contents\n\t\t\t\t\treturn this.string_literal_short_double();\n\t\t\t\t}\n\t\t\t\t// not enough chars to deduce type; retry next chunk\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t// prefixed name quick\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_pnq_object = R_PREFIXED_NAME_QUICK.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_pnq_object) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_PREFIXED_NAME_QUICK.lastIndex;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_pnq_object[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, m_pnq_object[2]);\n\n\t\t\t\t// iriref\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_iriref_e_object = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_iriref_e_object) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\tlet s_iri = m_iriref_e_object[1];\n\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t// set object\n\t\t\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(s_iri);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// prefixed name\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// try match\n\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\t\t\tlet [m_prefixed_named_e_object, im_prefixed_named_e_object] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\t\t\tif(m_prefixed_named_e_object) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = im_prefixed_named_e_object;\n\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_object[1] || '';\n\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, m_prefixed_named_e_object[2]);\n\n\t\t\t\t\t\t// string literal * single\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('\\'' === x) {\n\t\t\t\t\t\t\t// enough chars to deduce type\n\t\t\t\t\t\t\tif((i+2) < n) {\n\t\t\t\t\t\t\t\t// long type\n\t\t\t\t\t\t\t\tif(\"'\" === s[i+1] && \"'\" === s[i+2]) {\n\t\t\t\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\t\t\t\tthis.i = i + 3;\n\n\t\t\t\t\t\t\t\t\t// read contents\n\t\t\t\t\t\t\t\t\treturn this.string_literal_long_single();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// not long type\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t\t\t\t// read contents\n\t\t\t\t\t\t\t\t\treturn this.string_literal_short_single();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// enough chars to eliminate long type\n\t\t\t\t\t\t\telse if((i+1) < n && \"'\" !== s[i+1]) {\n\t\t\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t\t\t// read contents\n\t\t\t\t\t\t\t\treturn this.string_literal_short_single();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// not enough chars to deduce type; retry next chunk\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// numeric literal\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_NUMERIC_LITERAL.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_numeric_literal = R_NUMERIC_LITERAL.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_numeric_literal) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_NUMERIC_LITERAL.lastIndex;\n\t\t\t\t\t\t\t\t// it has exponent term, xsd:double\n\t\t\t\t\t\t\t\tif(m_numeric_literal[4]) {\n\t\t\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.double(m_numeric_literal[1]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// contains decimal point, xsd:decimal\n\t\t\t\t\t\t\t\telse if(m_numeric_literal[2] || m_numeric_literal[3]) {\n\t\t\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.decimal(m_numeric_literal[1]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// otherwise, it is an integer\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.integer(m_numeric_literal[1]);\n\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t// boolean literal\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_BOOLEAN_LITERAL.lastIndex = i;\n\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\tlet m_boolean_literal = R_BOOLEAN_LITERAL.exec(s);\n\n\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\tif(m_boolean_literal) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = R_BOOLEAN_LITERAL.lastIndex;\n\t\t\t\t\t\t\t\t\t// make literal\n\t\t\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.boolean(!!m_boolean_literal[1]);\n\n\n\t\t\t\t\t\t\t\t// blank node property list\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse \tif('[' === x) {\n\t\t\t\t// advance index to next token\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t\t\t// make object\n\t\t\t\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t\t// emit statement event\n\t\t\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t\t\t// push state to stack\n\t\t\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'post_object']);\n\n\t\t\t\t\t\t\t\t\t// set new subject\n\t\t\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\n\t\t\t\t\t\t\t\t\t// goto parsing pairs state\n\t\t\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t\t\t// labeled blank node\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\tR_BLANK_NODE_LABEL_TERMINAL.lastIndex = i;\n\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\tlet m_blank_node_label_object = R_BLANK_NODE_LABEL_TERMINAL.exec(s);\n\n\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\tif(m_blank_node_label_object) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\tthis.i = R_BLANK_NODE_LABEL_TERMINAL.lastIndex;\n\t\t\t\t\t\t\t\t\t\t// ref blank node label\n\t\t\t\t\t\t\t\t\t\tlet s_label = m_blank_node_label_object[1];\n\n\t\t\t\t\t\t\t\t\t\t// make object\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t\t\t// collection\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse \tif('(' === x) {\n\t\t\t\t// advance index to next token\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t// state to resume after collection ends\n\t\t\t\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'post_object']);\n\n\t\t\t\t\t\t\t\t\t\t// goto collection-object state\n\t\t\t\t\t\t\t\t\t\treturn this.collection_object();\n\n\t\t\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\tlet m_iriref_object = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\tif(m_iriref_object) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_object[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t\t\t// set object\n\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_object, im_prefixed_named_object] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\t\t\tif(m_prefixed_named_object) {\n\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_object;\n\t\t\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_object[1] || '';\n\t\t\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_object[2]\n\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, s_suffix);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection\n\t\t\t// match counter: 9\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t} // brace #9\n\t\t\t\t\t\t\t\t\t\t} // brace #8\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\n\n\t\t\t// fall through for cases that did not change state on their own\n\t\t\t// at this point, a new statement has been parsed\n\t\t\tthis.data();\n\n\n\t\t\t// goto next parsing state; bail out of stack\n\t\t\treturn this.after_end_of_statement;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('object_list');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.object_list;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal_short_double\n\tstring_literal_short_double() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\tstring_literal_short_double: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// something breaks string in this chunk\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_STRLIT_SHORT_DOUBLE_BREAK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_break = R_STRLIT_SHORT_DOUBLE_BREAK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_break) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_STRLIT_SHORT_DOUBLE_BREAK.lastIndex;\n\t\t\t\t// index of break\n\t\t\t\tlet i_break = m_break.index;\n\n\t\t\t\t// add to contents\n\t\t\t\tthis._s_literal += s.slice(i, i_break);\n\n\t\t\t\t// depending on char\n\t\t\t\tswitch(s[i_break]) {\n\t\t\t\t\t// terminator\n\t\t\t\t\tcase '\"': {\n\t\t\t\t\t// advance index to next token beyond delimiter\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\tR_WS.lastIndex = i_break + 1;\n\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t}\n\n\t\t\t\t\t// escape\n\t\t\t\t\tcase '\\\\': {\n\t\t\t\t\t\t// try to find end\n\t\t\t\t\t\tR_STRLIT_SHORT_DOUBLE_TERM.lastIndex = i_break;\n\t\t\t\t\t\tlet m_term = R_STRLIT_SHORT_DOUBLE_TERM.exec(s);\n\n\t\t\t\t\t\t// end is in this chunk\n\t\t\t\t\t\tif(m_term) {\n\t\t\t\t\t\t\t// index of terminator\n\t\t\t\t\t\t\tlet i_term = m_term.index;\n\n\t\t\t\t\t\t\t// extract dirty potion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break, i_term);\n\n\t\t\t\t\t\t\t// clean and save\n\t\t\t\t\t\t\tthis._s_literal += unescape_literal_short_hard(s_dirty);\n\n\t\t\t\t\t\t\t// advance index beyond terminator\n\t\t\t\t\t\t\tthis.i = i_term + m_term[0].length;\n\n\t\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// end is not in this chunk\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// extract whole portion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break);\n\n\t\t\t\t\t\t\t// unescape to clean part\n\t\t\t\t\t\t\tlet [s_clean, s_incomplete] = unescape_literal_short_soft(s_dirty);\n\n\t\t\t\t\t\t\t// save\n\t\t\t\t\t\t\tthis._s_literal += s_clean;\n\n\t\t\t\t\t\t\t// set unparsed index\n\t\t\t\t\t\t\ti = n - s_incomplete.length;\n\n\t\t\t\t\t\t\t// reached eos; pause normally\n\t\t\t\t\t\t\tbreak string_literal_short_double;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid '\\n'\n\t\t\t\t\tcase '\\n': {\n\t\t\t\t\t\treturn this.info_error(`expected string_literal_short_double but invalid line feed character '\\\\n' (newline) within contents. failed to parse a valid token`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid '\\r'\n\t\t\t\t\tcase '\\r': {\n\t\t\t\t\t\treturn this.info_error(`expected string_literal_short_double but invalid form feed character '\\\\r' (carriage return) within contents. failed to parse a valid token`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconsole.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_short_double`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t// no terminator and nothing to escape\n\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// save\n\t\t\t\tthis._s_literal += i? s.slice(i): s;\n\n\t\t\t\t// set unparsed index\n\t\t\t\ti = n;\n\n\t\t\t\t// reached eos; pause normally\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// do not eat whitespace at start of next chunk\n\t\tthis._b_trim_start = false;\n\n\t// ran out of characters\n\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('string_literal_short_double');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal_short_double;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal_short_single\n\tstring_literal_short_single() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\tstring_literal_short_single: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// something breaks string in this chunk\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_STRLIT_SHORT_SINGLE_BREAK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_break = R_STRLIT_SHORT_SINGLE_BREAK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_break) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_STRLIT_SHORT_SINGLE_BREAK.lastIndex;\n\t\t\t\t// index of break\n\t\t\t\tlet i_break = m_break.index;\n\n\t\t\t\t// add to contents\n\t\t\t\tthis._s_literal += s.slice(i, i_break);\n\n\t\t\t\t// depending on char\n\t\t\t\tswitch(s[i_break]) {\n\t\t\t\t\t// terminator\n\t\t\t\t\tcase \"'\": {\n\t\t\t\t\t// advance index to next token beyond delimiter\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\tR_WS.lastIndex = i_break + 1;\n\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t}\n\n\t\t\t\t\t// escape\n\t\t\t\t\tcase '\\\\': {\n\t\t\t\t\t\t// try to find end\n\t\t\t\t\t\tR_STRLIT_SHORT_SINGLE_TERM.lastIndex = i_break;\n\t\t\t\t\t\tlet m_term = R_STRLIT_SHORT_SINGLE_TERM.exec(s);\n\n\t\t\t\t\t\t// end is in this chunk\n\t\t\t\t\t\tif(m_term) {\n\t\t\t\t\t\t\t// index of terminator\n\t\t\t\t\t\t\tlet i_term = m_term.index;\n\n\t\t\t\t\t\t\t// extract dirty potion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break, i_term);\n\n\t\t\t\t\t\t\t// clean and save\n\t\t\t\t\t\t\tthis._s_literal += unescape_literal_short_hard(s_dirty);\n\n\t\t\t\t\t\t\t// advance index beyond terminator\n\t\t\t\t\t\t\tthis.i = i_term + m_term[0].length;\n\n\t\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// end is not in this chunk\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// extract whole portion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break);\n\n\t\t\t\t\t\t\t// unescape to clean part\n\t\t\t\t\t\t\tlet [s_clean, s_incomplete] = unescape_literal_short_soft(s_dirty);\n\n\t\t\t\t\t\t\t// save\n\t\t\t\t\t\t\tthis._s_literal += s_clean;\n\n\t\t\t\t\t\t\t// set unparsed index\n\t\t\t\t\t\t\ti = n - s_incomplete.length;\n\n\t\t\t\t\t\t\t// reached eos; pause normally\n\t\t\t\t\t\t\tbreak string_literal_short_single;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid '\\n'\n\t\t\t\t\tcase '\\n': {\n\t\t\t\t\t\treturn this.info_error(`expected string_literal_short_single but invalid line feed character '\\\\n' (newline) within contents. failed to parse a valid token`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid '\\r'\n\t\t\t\t\tcase '\\r': {\n\t\t\t\t\t\treturn this.info_error(`expected string_literal_short_single but invalid form feed character '\\\\r' (carriage return) within contents. failed to parse a valid token`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconsole.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_short_single`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t// no terminator and nothing to escape\n\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// save\n\t\t\t\tthis._s_literal += i? s.slice(i): s;\n\n\t\t\t\t// set unparsed index\n\t\t\t\ti = n;\n\n\t\t\t\t// reached eos; pause normally\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// do not eat whitespace at start of next chunk\n\t\tthis._b_trim_start = false;\n\n\t// ran out of characters\n\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('string_literal_short_single');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal_short_single;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal_long_double\n\tstring_literal_long_double() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\tstring_literal_long_double: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// something breaks string in this chunk\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_STRLIT_LONG_DOUBLE_BREAK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_break = R_STRLIT_LONG_DOUBLE_BREAK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_break) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_STRLIT_LONG_DOUBLE_BREAK.lastIndex;\n\t\t\t\t// index of break\n\t\t\t\tlet i_break = m_break.index;\n\n\t\t\t\t// add to contents\n\t\t\t\tthis._s_literal += s.slice(i, i_break);\n\n\t\t\t\t// depending on char\n\t\t\t\tswitch(s[i_break]) {\n\t\t\t\t\t// terminator\n\t\t\t\t\tcase '\"': {\n\t\t\t\t\t// advance index to next token beyond delimiter\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\tR_WS.lastIndex = i_break + 3;\n\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t}\n\n\t\t\t\t\t// escape\n\t\t\t\t\tcase '\\\\': {\n\t\t\t\t\t\t// try to find end\n\t\t\t\t\t\tR_STRLIT_LONG_DOUBLE_TERM.lastIndex = i_break;\n\t\t\t\t\t\tlet m_term = R_STRLIT_LONG_DOUBLE_TERM.exec(s);\n\n\t\t\t\t\t\t// end is in this chunk\n\t\t\t\t\t\tif(m_term) {\n\t\t\t\t\t\t\t// index of terminator\n\t\t\t\t\t\t\tlet i_term = m_term.index;\n\n\t\t\t\t\t\t\t// extract dirty potion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break, i_term);\n\n\t\t\t\t\t\t\t// clean and save\n\t\t\t\t\t\t\tthis._s_literal += unescape_literal_long_hard(s_dirty);\n\n\t\t\t\t\t\t\t// advance index beyond terminator\n\t\t\t\t\t\t\tthis.i = i_term + m_term[0].length;\n\n\t\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// end is not in this chunk\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// extract whole portion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break);\n\n\t\t\t\t\t\t\t// unescape to clean part\n\t\t\t\t\t\t\tlet [s_clean, s_incomplete] = unescape_literal_long_soft(s_dirty);\n\n\t\t\t\t\t\t\t// save\n\t\t\t\t\t\t\tthis._s_literal += s_clean;\n\n\t\t\t\t\t\t\t// set unparsed index\n\t\t\t\t\t\t\ti = n - s_incomplete.length;\n\n\t\t\t\t\t\t\t// reached eos; pause normally\n\t\t\t\t\t\t\tbreak string_literal_long_double;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconsole.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_long_double`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t// no terminator and nothing to escape\n\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// could be unfinished terminator\n\t\t\t\tR_STRLIT_LONG_DOUBLE_UNFINISHED_TERM.lastIndex = i;\n\t\t\t\tlet m_unfinished = R_STRLIT_LONG_DOUBLE_UNFINISHED_TERM.exec(s);\n\n\t\t\t\t// unfinished terminator\n\t\t\t\tif(m_unfinished) {\n\t\t\t\t\t// save valid portion\n\t\t\t\t\tthis._s_literal += s.slice(i, m_unfinished.index);\n\n\t\t\t\t\t// set unparsed index\n\t\t\t\t\ti = m_unfinished.index;\n\t\t\t\t}\n\t\t\t\t// not unfinished\n\t\t\t\telse {\n\t\t\t\t\t// save\n\t\t\t\t\tthis._s_literal += i? s.slice(i): s;\n\n\t\t\t\t\t// set unparsed index\n\t\t\t\t\ti = n;\n\t\t\t\t}\n\n\t\t\t\t// reached eos; pause normally\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// do not eat whitespace at start of next chunk\n\t\tthis._b_trim_start = false;\n\n\t// ran out of characters\n\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('string_literal_long_double');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal_long_double;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal_long_single\n\tstring_literal_long_single() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\tstring_literal_long_single: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// something breaks string in this chunk\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_STRLIT_LONG_SINGLE_BREAK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_break = R_STRLIT_LONG_SINGLE_BREAK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_break) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_STRLIT_LONG_SINGLE_BREAK.lastIndex;\n\t\t\t\t// index of break\n\t\t\t\tlet i_break = m_break.index;\n\n\t\t\t\t// add to contents\n\t\t\t\tthis._s_literal += s.slice(i, i_break);\n\n\t\t\t\t// depending on char\n\t\t\t\tswitch(s[i_break]) {\n\t\t\t\t\t// terminator\n\t\t\t\t\tcase \"'\": {\n\t\t\t\t\t// advance index to next token beyond delimiter\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\tR_WS.lastIndex = i_break + 3;\n\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t}\n\n\t\t\t\t\t// escape\n\t\t\t\t\tcase '\\\\': {\n\t\t\t\t\t\t// try to find end\n\t\t\t\t\t\tR_STRLIT_LONG_SINGLE_TERM.lastIndex = i_break;\n\t\t\t\t\t\tlet m_term = R_STRLIT_LONG_SINGLE_TERM.exec(s);\n\n\t\t\t\t\t\t// end is in this chunk\n\t\t\t\t\t\tif(m_term) {\n\t\t\t\t\t\t\t// index of terminator\n\t\t\t\t\t\t\tlet i_term = m_term.index;\n\n\t\t\t\t\t\t\t// extract dirty potion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break, i_term);\n\n\t\t\t\t\t\t\t// clean and save\n\t\t\t\t\t\t\tthis._s_literal += unescape_literal_long_hard(s_dirty);\n\n\t\t\t\t\t\t\t// advance index beyond terminator\n\t\t\t\t\t\t\tthis.i = i_term + m_term[0].length;\n\n\t\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// end is not in this chunk\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// extract whole portion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break);\n\n\t\t\t\t\t\t\t// unescape to clean part\n\t\t\t\t\t\t\tlet [s_clean, s_incomplete] = unescape_literal_long_soft(s_dirty);\n\n\t\t\t\t\t\t\t// save\n\t\t\t\t\t\t\tthis._s_literal += s_clean;\n\n\t\t\t\t\t\t\t// set unparsed index\n\t\t\t\t\t\t\ti = n - s_incomplete.length;\n\n\t\t\t\t\t\t\t// reached eos; pause normally\n\t\t\t\t\t\t\tbreak string_literal_long_single;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconsole.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_long_single`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t// no terminator and nothing to escape\n\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// could be unfinished terminator\n\t\t\t\tR_STRLIT_LONG_SINGLE_UNFINISHED_TERM.lastIndex = i;\n\t\t\t\tlet m_unfinished = R_STRLIT_LONG_SINGLE_UNFINISHED_TERM.exec(s);\n\n\t\t\t\t// unfinished terminator\n\t\t\t\tif(m_unfinished) {\n\t\t\t\t\t// save valid portion\n\t\t\t\t\tthis._s_literal += s.slice(i, m_unfinished.index);\n\n\t\t\t\t\t// set unparsed index\n\t\t\t\t\ti = m_unfinished.index;\n\t\t\t\t}\n\t\t\t\t// not unfinished\n\t\t\t\telse {\n\t\t\t\t\t// save\n\t\t\t\t\tthis._s_literal += i? s.slice(i): s;\n\n\t\t\t\t\t// set unparsed index\n\t\t\t\t\ti = n;\n\t\t\t\t}\n\n\t\t\t\t// reached eos; pause normally\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// do not eat whitespace at start of next chunk\n\t\tthis._b_trim_start = false;\n\n\t// ran out of characters\n\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('string_literal_long_single');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal_long_single;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal\n\tstring_literal() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref character\n\t\t\tlet x = s[i];\n\n\t\t\t// string literal * double\n\t\t\tif('\"' === x) {\n\t\t\t\t// enough chars to deduce type\n\t\t\t\tif((i+2) < n) {\n\t\t\t\t\t// long type\n\t\t\t\t\tif('\"' === s[i+1] && '\"' === s[i+2]) {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 3;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_long_double();\n\t\t\t\t\t}\n\t\t\t\t\t// not long type\n\t\t\t\t\telse {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_short_double();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// enough chars to eliminate long type\n\t\t\t\telse if((i+1) < n && '\"' !== s[i+1]) {\n\t\t\t\t\t// advance index beyond token\n\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t// read contents\n\t\t\t\t\treturn this.string_literal_short_double();\n\t\t\t\t}\n\t\t\t\t// not enough chars to deduce type; retry next chunk\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t// string literal * single\n\t\t\t}\n\t\t\telse \tif('\\'' === x) {\n\t\t\t\t// enough chars to deduce type\n\t\t\t\tif((i+2) < n) {\n\t\t\t\t\t// long type\n\t\t\t\t\tif(\"'\" === s[i+1] && \"'\" === s[i+2]) {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 3;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_long_single();\n\t\t\t\t\t}\n\t\t\t\t\t// not long type\n\t\t\t\t\telse {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_short_single();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// enough chars to eliminate long type\n\t\t\t\telse if((i+1) < n && \"'\" !== s[i+1]) {\n\t\t\t\t\t// advance index beyond token\n\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t// read contents\n\t\t\t\t\treturn this.string_literal_short_single();\n\t\t\t\t}\n\t\t\t\t// not enough chars to deduce type; retry next chunk\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t// not string literal long single quote, not string literal single quote\n\t\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_string_length) {\n\t\t\t\t\treturn this.parse_error('string_literal');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for datatype_or_langtag\n\tdatatype_or_langtag() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref character\n\t\t\tlet x = s[i];\n\n\t\t\t// next token indicates datatype or langtag\n\t\t\tif('^' === x || '@' === x) {\n// '^^' datatype\n\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_DOUBLE_CARET.lastIndex = i;\n\n\t\t\t\tif(R_DOUBLE_CARET.exec(s)) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_DOUBLE_CARET.lastIndex;\n\t\t\t\t\treturn this.datatype();\n\n\t\t\t\t// '@' language tag\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_LANGTAG.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_langtag = R_LANGTAG.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_langtag) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_LANGTAG.lastIndex;\n\t\t\t\t\t\tthis._kt_object = this._dc_factory.languagedLiteral(this._s_literal, m_langtag[1]);\n\n\t\t\t\t\t\t// reset literal\n\t\t\t\t\t\tthis._s_literal = '';\n\n\t\t\t\t// next token definitely datatype or langtag, we are just being interrupted by eos\n\t\t\t\t// match counter: 1\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} // brace #1\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_object = this._dc_factory.simpleLiteral(this._s_literal);\n\n\t\t\t\t\t// reset literal\n\t\t\t\t\tthis._s_literal = '';\n\n\t\t\t\t// not datatype, not language tag => that's okay! those are optional\n\t\t\t\t}\n\t\t\t} // brace #1\n\n\n\t\t\t// goto end of statement state\n\t\t\t// at this point, a new statement has been parsed\n\t\t\tthis.data();\n\n\n\t\t\t// goto next parsing state; bail out of stack\n\t\t\treturn this.after_end_of_statement;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('datatype_or_langtag');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.datatype_or_langtag;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for datatype\n\tdatatype() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet kt_datatype = null;\n\n// prefixed name quick\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_pnq_datatype = R_PREFIXED_NAME_QUICK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_pnq_datatype) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_PREFIXED_NAME_QUICK.lastIndex;\n\t\t\t\t// check valid prefix\n\t\t\t\tlet s_prefix_id = m_pnq_datatype[1] || '';\n\t\t\t\t// invalid prefix\n\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\tkt_datatype = this.prefixed_name(s_prefix_id, m_pnq_datatype[2]);\n\n\t\t\t// iriref\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_e_datatype = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_e_datatype) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\t\t\t\t\tlet p_datatype;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_e_datatype[1];\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set p_datatype\n\t\t\t\t\t\tp_datatype = s_iri;\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tp_datatype = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t\t}\n\n\t\t\t\t\tkt_datatype = this.check_named_node_escapeless(p_datatype);\n\n\t\t\t\t// prefixed name\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// try match\n\t\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t\t// stack bail out\n\t\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\t\tlet [m_prefixed_named_e_datatype, im_prefixed_named_e_datatype] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\t\tif(m_prefixed_named_e_datatype) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = im_prefixed_named_e_datatype;\n\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_datatype[1] || '';\n\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\tkt_datatype = this.prefixed_name(s_prefix_id, m_prefixed_named_e_datatype[2]);\n\n\t\t\t\t\t// iriref\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_iriref_datatype = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_iriref_datatype) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\t\t\t\t\t\t\tlet p_datatype;\n\n\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\tlet s_iri = m_iriref_e_datatype[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t// set p_datatype\n\t\t\t\t\t\t\t\tp_datatype = s_iri;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tp_datatype = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tkt_datatype = this.check_named_node(p_datatype);\n\n\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\tlet [m_prefixed_named_datatype, im_prefixed_named_datatype] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\tif(m_prefixed_named_datatype) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_datatype;\n\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_datatype[1] || '';\n\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_datatype[2]\n\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t// set literal datatype\n\t\t\t\t\t\t\t\tkt_datatype = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t// not iriref, not prefixed name\n\t\t\t// match counter: 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\n\n\t\t\tthis._kt_object = this._dc_factory.datatypedLiteral(this._s_literal, kt_datatype);\n\n\t\t\t// reset literal\n\t\t\tthis._s_literal = '';\n\n\t\t\t// goto end of statement state\n\t\t\t// at this point, a new statement has been parsed\n\t\t\tthis.data();\n\n\n\t\t\t// goto next parsing state; bail out of stack\n\t\t\treturn this.after_end_of_statement;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('datatype');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.datatype;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for post_object\n\tpost_object() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet i_reset = i;\n\n\t\t\t// benchmarks confirm: character ref faster than regexes in this context\n\t\t\tlet x = s[i];\n\n\t\t\t// advance index to next token beyond delimiter\n\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\tR_WS.lastIndex = i+1;\n\t\t\tR_WS.exec(s);\n\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t// ',' more objects\n\t\t\tif(',' === x) {\n\t\t\t\treturn this.object_list();\n\n\t\t\t// ';' more predicate-object pairs\n\t\t\t}\n\t\t\telse \tif(';' === x) {\n\t\t\t\tfor(;;) {\n\t\t\t\t\t// next token is end of outer section\n\t\t\t\t\tlet s_peek = s[this.i];\n\t\t\t\t\tif('.' === s_peek || ']' === s_peek || ';' === s_peek || '}' === s_peek) {\n\t\t\t\t\t\t// goto post_object state\n\t\t\t\t\t\treturn this.post_object();\n\t\t\t\t\t}\n\t\t\t\t\t// comment\n\t\t\t\t\telse if('#' === s_peek) {\n\t\t\t\t\t\t// comment\n\t\t\t\t\t\ti = this.i;\n\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t// retry\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t// no eol to close comment (yet)\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// already consumed\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// eos\n\t\t\t\t\telse if(this.i === n) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// something else\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn this.pairs();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// rather than pushing a dedicated state, just try again next chunk\n\t\t\t\ti = i_reset;\n\t\t\t\tbreak;\n\n\t\t\t// '.' end of statement\n\t\t\t}\n\t\t\telse \tif('.' === x) {\n\t\t\t\t// assert not nested\n\t\t\t\tif(this._a_nested.length) {\n\t\t\t\t\t// reset index to that character\n\t\t\t\t\tthis.i = i;\n\n\t\t\t\t\t// emit parse error\n\t\t\t\t\treturn this.parse_error('end_of_property_list');\n\t\t\t\t}\n\n\t\t\t\treturn (this._kt_default_graph === this._kt_graph)? this.block(): this.statement();\n\n\t\t\t// ']' end of property-object pairs\n\t\t\t}\n\t\t\telse \tif(']' === x) {\n\t\t\t\tlet s_resume_state;\n\t\t\t\t[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();\n\t\t\t\treturn this[s_resume_state]();\n\n\t\t\t// ')' end of collection\n\t\t\t}\n\t\t\telse \tif(')' === x) {\n\t\t\t\t// should not be here\n\t\t\t\treturn Reader$syntax_error(this, i, 'post_object', 'but encountered end of collection');\n\n\t\t\t// closing graph '}'\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_CHAR_CLOSE.lastIndex = i;\n\n\t\t\t\tif(R_CHAR_CLOSE.exec(s)) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_CHAR_CLOSE.lastIndex;\n\t\t\t\t\t// emit graph_close event\n\t\t\t\t\tthis.emit('exit', this._kt_graph);\n\n\t\t\t\t\t// reset graph\n\t\t\t\t\tthis._kt_graph = this._kt_default_graph;\n\n\t\t\t\t\treturn this.block();\n\n\t\t\t\t// comment\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t// do not change state\n\t\t\t\t\t\tcontinue;\n\n\t\t\t// comment interrupted by eos?\n\t\t\t// match counter: 2\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('post_object');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.post_object;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for base_iri\n\tbase_iri() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// prefix id\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_base = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_base) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_base[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set base_url\n\t\t\t\t\tthis._s_base_url = s_iri;\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._s_base_url = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t}\t\tlet m_base_iri = R_BASE_IRI.exec(this._s_base_url);\n\t\t\t\tthis._s_base_url = m_base_iri[1];\n\t\t\t\tthis._s_base_url_root = m_base_iri[2] || '';\n\t\t\t\tthis._s_base_url_scheme = m_base_iri[3] || '';\n\t\t\t\tthis._s_base_url_path = m_base_iri[4] || '';\n\n\n\t\t\t\t// emit base event\n\t\t\t\tthis.emit('base', this._s_base_url);\n\n\t\t\t\tif(this._b_expecting_full_stop) {\n\t\t\t\t\t// change state\n\t\t\t\t\treturn this.full_stop();\n\t\t\t\t}\n\n\t\t\t\t// goto prefix iri state\n\t\t\t\treturn this.block();\n\n\t\t\t// prefix id\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_base = R_IRIREF.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_base) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_base[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set base_url\n\t\t\t\t\t\tthis._s_base_url = s_iri;\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis._s_base_url = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t\t}\t\tlet m_base_iri = R_BASE_IRI.exec(this._s_base_url);\n\t\t\t\t\tthis._s_base_url = m_base_iri[1];\n\t\t\t\t\tthis._s_base_url_root = m_base_iri[2] || '';\n\t\t\t\t\tthis._s_base_url_scheme = m_base_iri[3] || '';\n\t\t\t\t\tthis._s_base_url_path = m_base_iri[4] || '';\n\n\n\t\t\t\t\t// emit base event\n\t\t\t\t\tthis.emit('base', this._s_base_url);\n\n\t\t\t\t\tif(this._b_expecting_full_stop) {\n\t\t\t\t\t\t// change state\n\t\t\t\t\t\treturn this.full_stop();\n\t\t\t\t\t}\n\n\t\t\t\t\t// goto prefix iri state\n\t\t\t\t\treturn this.block();\n\n\t\t\t\t// for poorly-placed comments\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t// do not change state\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t// match counter: 2\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('base_iri');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.base_iri;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for prefix_id\n\tprefix_id() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// prefix id\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_PREFIX_ID.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_prefix_id = R_PREFIX_ID.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_prefix_id) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_PREFIX_ID.lastIndex;\n\t\t\t\t// set temp prefix id\n\t\t\t\tthis._s_temp_prefix_id = m_prefix_id[1];\n\n\t\t\t\t// goto prefix iri state\n\t\t\t\treturn this.prefix_iri();\n\n\t\t\t// for poorly-placed comments\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t// do not change state\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('prefix_id');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.prefix_id;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for prefix_iri\n\tprefix_iri() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet h_prefixes = this._h_prefixes;\n\t\t\tlet s_prefix_id = this._s_temp_prefix_id;\n\t\t\tlet p_prefix_iri;\n\n// prefix iri\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_prefix = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_prefix) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_prefix[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set p_prefix_iri\n\t\t\t\t\tp_prefix_iri = s_iri;\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tp_prefix_iri = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t}\n\n\t\t\t\tlet b_relax = this._b_relax;\n\n// existing mapping\n\n\t\t\t\tif(s_prefix_id in h_prefixes) {\n\t\t\t\t\t// doesn't match existing\n\t\t\t\t\tif(p_prefix_iri !== h_prefixes[s_prefix_id]) {\n\t\t\t\t\t\t// emit change event\n\t\t\t\t\t\tif(this.prefix_change) {\n\t\t\t\t\t\t\tthis.prefix_change(s_prefix_id, h_prefixes[s_prefix_id], p_prefix_iri);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// update prefix\n\t\t\t\t\t\th_prefixes[s_prefix_id] = p_prefix_iri;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// first mapping\n\t\t\t\telse {\n\t\t\t\t\t// check namespace, invalid\n\t\t\t\t\tif(!b_relax && !RT_PREFIXED_NAME_NAMESPACE_VALID.test(s_prefix_id)) {\n\t\t\t\t\t\treturn this.error(`Invalid namespace for prefixed name: \"${s_prefix_id}:\"`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// set prefix\n\t\t\t\t\th_prefixes[s_prefix_id] = p_prefix_iri;\n\t\t\t\t}\n\n\t\t\t\t// check iri, invalid\n\t\t\t\tif(!b_relax && !RT_NAMED_NODE_VALID.test(p_prefix_iri)) {\n\t\t\t\t\treturn this.error(`Invalid IRI found in prefix delcaration: \"${s_iri}\"`);\n\t\t\t\t}\n\n\t\t\t\t// emit prefix event\n\t\t\t\tthis.event('prefix', s_prefix_id, p_prefix_iri);\n\n\t\t\t\tif(this._b_expecting_full_stop) {\n\t\t\t\t\t// change state\n\t\t\t\t\treturn this.full_stop();\n\t\t\t\t}\n\n\t\t\t\t// goto statement state\n\t\t\t\treturn this.block();\n\n\t\t\t// prefix iri\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_prefix = R_IRIREF.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_prefix) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_prefix[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set p_prefix_iri\n\t\t\t\t\t\tp_prefix_iri = s_iri;\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tp_prefix_iri = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet b_relax = this._b_relax;\n\n// existing mapping\n\n\t\t\t\t\tif(s_prefix_id in h_prefixes) {\n\t\t\t\t\t\t// doesn't match existing\n\t\t\t\t\t\tif(p_prefix_iri !== h_prefixes[s_prefix_id]) {\n\t\t\t\t\t\t\t// emit change event\n\t\t\t\t\t\t\tif(this.prefix_change) {\n\t\t\t\t\t\t\t\tthis.prefix_change(s_prefix_id, h_prefixes[s_prefix_id], p_prefix_iri);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// update prefix\n\t\t\t\t\t\t\th_prefixes[s_prefix_id] = p_prefix_iri;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// first mapping\n\t\t\t\t\telse {\n\t\t\t\t\t\t// check namespace, invalid\n\t\t\t\t\t\tif(!b_relax && !RT_PREFIXED_NAME_NAMESPACE_VALID.test(s_prefix_id)) {\n\t\t\t\t\t\t\treturn this.error(`Invalid namespace for prefixed name: \"${s_prefix_id}:\"`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// set prefix\n\t\t\t\t\t\th_prefixes[s_prefix_id] = p_prefix_iri;\n\t\t\t\t\t}\n\n\t\t\t\t\t// check iri, invalid\n\t\t\t\t\tif(!b_relax && !RT_NAMED_NODE_VALID.test(p_prefix_iri)) {\n\t\t\t\t\t\treturn this.error(`Invalid IRI found in prefix delcaration: \"${s_iri}\"`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// emit prefix event\n\t\t\t\t\tthis.event('prefix', s_prefix_id, p_prefix_iri);\n\n\t\t\t\t\tif(this._b_expecting_full_stop) {\n\t\t\t\t\t\t// change state\n\t\t\t\t\t\treturn this.full_stop();\n\t\t\t\t\t}\n\n\t\t\t\t\t// goto statement state\n\t\t\t\t\treturn this.block();\n\n\t\t\t\t// for poorly-placed comments\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t// do not change state\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t// match counter: 2\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('prefix_iri');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.prefix_iri;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n// in case eos happens twice during prefix / base (extremely unlikely)\n\n\n\t// parse state for full_stop\n\tfull_stop() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// prepare sticky regex index\n\t\t\tR_CHAR_STOP.lastIndex = i;\n\n\t\t\tif(R_CHAR_STOP.exec(s)) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_CHAR_STOP.lastIndex;\n\t\t\t\t// resume statement\n\t\t\t\treturn this.block();\n\n\t\t\t// poorly-placed comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t// try again\n\t\t\t\t\tcontinue;\n\n\t\t\t// possibly interrupted by eos\n\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('full_stop');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.full_stop;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for collection_subject\n\tcollection_subject() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref char\n\t\t\tlet x = s[i];\n\n\t\t\t// end of collection\n\t\t\tif(')' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// no items in collection subject\n\t\t\t\tif(null === this._kt_subject) {\n\t\t\t\t\t// prepare subject\n\t\t\t\t\tthis._kt_subject = this._kt_rdf_nil;\n\n\t\t\t\t\t// state was never pushed to stack, jump to post_subject state\n\t\t\t\t\treturn this.post_blank_subject();\n\t\t\t\t}\n// otherwise, there must be items in collection\n\n\t\t\t\t// commit collection end\n\t\t\t\tthis._kt_object = this._kt_rdf_nil;\n\t\t\t\tthis.data();\n\n\n\t\t\t\t// restore state from stack\n\t\t\t\tlet s_resume_state;\n\t\t\t\t[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();\n\t\t\t\treturn this[s_resume_state]();\n\t\t\t}\n\n\n\n\t\t\t// otherwise, pre-emptively secure the next blank node label\n\t\t\tlet s_pointer_label;\n\n\t\t\t// very first collection object\n\t\t\tlet b_pushed = false;\n\t\t\tif(null === this._kt_subject) {\n\t\t\t\t// set quasi subject (really for resume state)\n\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\tthis._kt_subject = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'pairs']);\n\t\t\t\t// reset subject for later conditional branch\n\t\t\t\tthis._kt_subject = null;\n\t\t\t\tb_pushed = true;\n\t\t\t}\n\n// iriref\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_object = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_object) {\n\t\t\t\t// advance index\n\t\t\t\ti = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_object[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set object\n\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(s_iri);\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t}\n\n\t\t\t// prefixed name\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// try match\n\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t// stack bail out\n\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\tlet [m_prefixed_named_e_object, im_prefixed_named_e_object] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\tif(m_prefixed_named_e_object) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = im_prefixed_named_e_object;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_object[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, m_prefixed_named_e_object[2]);\n\n\t\t\t\t// string literal\n\t\t\t\t}\n\t\t\t\telse \tif('\"' === x || '\\'' === x) {\n\t\t\t\t\t// first item in list\n\t\t\t\t\tif(null === this._kt_subject) {\n\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t}\n\t\t\t\t\t// not first item in list\n\t\t\t\t\telse {\n\t\t\t\t\t\t// make nest list item\n\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t// setup for object literal\n\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t}\n\n\t\t\t\t\t// how to resume collection subject state after object literal\n\t\t\t\t\tthis.after_end_of_statement = function() {\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\tthis.after_end_of_statement = this.post_object;\n\t\t\t\t\t\treturn this.collection_subject();\n\t\t\t\t\t};\n\t\t\t\t\treturn this.string_literal();\n\n\t\t\t\t// numeric literal\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_NUMERIC_LITERAL.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_numeric_literal = R_NUMERIC_LITERAL.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_numeric_literal) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_NUMERIC_LITERAL.lastIndex;\n\t\t\t\t\t\t// it has exponent term, xsd:double\n\t\t\t\t\t\tif(m_numeric_literal[4]) {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.double(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// contains decimal point, xsd:decimal\n\t\t\t\t\t\telse if(m_numeric_literal[2] || m_numeric_literal[3]) {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.decimal(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// otherwise, it is an integer\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.integer(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t// boolean literal\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_BOOLEAN_LITERAL.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_boolean_literal = R_BOOLEAN_LITERAL.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_boolean_literal) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\ti = R_BOOLEAN_LITERAL.lastIndex;\n\t\t\t\t\t\t\t// make literal\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.boolean(!!m_boolean_literal[1]);\n\n\t\t\t\t\t\t// blank node property list\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('[' === x) {\n\t\t\t\t// advance index to next token\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t// this blank node is just the next item in the list\n\t\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\t\tlet kt_blank_node;\n\t\t\t\t\t\t\tif(null !== this._kt_subject) {\n\t\t\t\t\t\t\t\tkt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\t\t\tthis.data();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// subject needs to be set\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node || this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t\t\tlet s_label = this.next_label();\n\t\t\t\t\t\t\tkt_blank_node = this._kt_object = this.anonymous_blank_node(s_label);\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// when resume\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\n\t\t\t\t\t\t\t// push state\n\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_subject']);\n\n\t\t\t\t\t\t\t// prepare next triple\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\n\t\t\t\t\t\t\t// goto parsing pairs state\n\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t// new collection\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('(' === x) {\n\t\t\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\ti = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t// empty collection\n\t\t\t\t\t\t\tif(')' === s[i]) {\n\t\t\t\t\t\t\t\tthis.i = i;\n\t\t\t\t\t\t\t\tthis._kt_subject = this._a_nested[this._a_nested.length-1][0];\n\t\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t\t\t\tthis._a_nested.push([\n\t\t\t\t\t\t\t\t\tthis._kt_subject,\n\t\t\t\t\t\t\t\t\tthis._kt_rdf_rest,\n\t\t\t\t\t\t\t\t\t'collection_subject',\n\t\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t\t\treturn this.collection_object();\n\t\t\t\t\t\t\t}\n\n\n\n\t\t\t\t\t\t\t// commit list item pointer\n\t\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// add this list as an item to the outer list\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_object']);\n\n\t\t\t\t\t\t\t// prepare next triple\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\n\n\n\t\t\t\t\t\t\t// flowing\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t// labeled blank node\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_blank_node_label_object = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_blank_node_label_object) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\ti = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t\t\t// ref blank node label\n\t\t\t\t\t\t\t\tlet s_label = m_blank_node_label_object[1];\n\n\t\t\t\t\t\t\t\t// make object\n\t\t\t\t\t\t\t\tthis._kt_object = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\tlet m_iriref_object = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\tif(m_iriref_object) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\ti = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_object[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t// set object\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_object, im_prefixed_named_object] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\tif(m_prefixed_named_object) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\ti = im_prefixed_named_object;\n\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_object[1] || '';\n\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_object[2]\n\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, s_suffix);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection\n\t\t\t// match counter: 7\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// ran out of characters after pushing state, pop it\n\t\t\t\t\t\t\t\t\t\t\tif(b_pushed) this._a_nested.pop();\n\n\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\n\n\t\t\tlet kt_blank_node_outer;\n\t\t\tif(!s_pointer_label) s_pointer_label = this.next_label();\n\n\t\t\t// not the very first item of collection subject\n\t\t\tif(this._kt_subject !== null) {\n\t\t\t\t// ref object\n\t\t\t\tlet w_object = this._kt_object;\n\n\t\t\t\t// create blanknode to embed list\n\t\t\t\tkt_blank_node_outer = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\n\t\t\t\t// emit statement that functions as collection's head \"pointer\"\n\t\t\t\tthis.data();\n\n\n\t\t\t\t// swap back object\n\t\t\t\tthis._kt_object = w_object;\n\t\t\t}\n\n\t\t\t// emit statement that is item\n\t\t\tthis._kt_subject = kt_blank_node_outer || this.anonymous_blank_node(s_pointer_label);\n\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\tthis.data();\n\n\n\t\t\t// prepare next predicate\n\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('collection_subject');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.collection_subject;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for collection_object\n\tcollection_object() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref char\n\t\t\tlet x = s[i];\n\n\t\t\t// end of collection\n\t\t\tif(')' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// make & emit collection's tail \"pointer\"\n\t\t\t\tthis._kt_object = this._kt_rdf_nil;\n\t\t\t\tthis.data();\n\n\n\t\t\t\t// restore previous state\n\t\t\t\tlet s_resume_state;\n\t\t\t\t[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();\n\t\t\t\treturn this[s_resume_state]();\n\t\t\t}\n\n\n\n\t\t\t// otherwise, pre-emptively secure the next blank node label\n\t\t\tlet s_pointer_label;\n\n// iriref\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_object = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_object) {\n\t\t\t\t// advance index\n\t\t\t\ti = R_IRIREF_ESCAPELESS.lastIndex;\n// commit object iri as is\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_object[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set object\n\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(s_iri);\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t}\n\n\t\t\t// prefixed name\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// try match\n\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t// stack bail out\n\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\tlet [m_prefixed_named_e_object, im_prefixed_named_e_object] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\tif(m_prefixed_named_e_object) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = im_prefixed_named_e_object;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_object[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, m_prefixed_named_e_object[2]);\n\n\t\t\t\t// string literal\n\t\t\t\t}\n\t\t\t\telse \tif('\"' === x || '\\'' === x) {\n\t\t\t\t\t// update index before changing states\n\t\t\t\t\tthis.i = i;\n\n\t\t\t\t\t// create blanknode to embed list\n\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t// emit statement that functions as collection's head \"pointer\"\n\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t// prepare statement that is item\n\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\n\t\t\t\t\tthis.after_end_of_statement = function() {\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\tthis.after_end_of_statement = this.post_object;\n\t\t\t\t\t\treturn this.collection_object();\n\t\t\t\t\t};\n\t\t\t\t\treturn this.string_literal();\n\n\t\t\t\t// numeric literal\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_NUMERIC_LITERAL.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_numeric_literal = R_NUMERIC_LITERAL.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_numeric_literal) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_NUMERIC_LITERAL.lastIndex;\n\t\t\t\t\t\t// it has exponent term, xsd:double\n\t\t\t\t\t\tif(m_numeric_literal[4]) {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.double(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// contains decimal point, xsd:decimal\n\t\t\t\t\t\telse if(m_numeric_literal[2] || m_numeric_literal[3]) {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.decimal(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// otherwise, it is an integer\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.integer(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t// boolean literal\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_BOOLEAN_LITERAL.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_boolean_literal = R_BOOLEAN_LITERAL.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_boolean_literal) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\ti = R_BOOLEAN_LITERAL.lastIndex;\n\t\t\t\t\t\t\t// make literal\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.boolean(!!m_boolean_literal[1]);\n\n\t\t\t\t\t\t// blank node property list\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('[' === x) {\n\t\t\t\t// advance index to next token\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t// commit head of list pointer\n\t\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// setup state to resume and push\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_object']);\n\n\t\t\t\t\t\t\t// enter blank node\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t\t\tkt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// prepare next triple\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\n\t\t\t\t\t\t\t// goto parsing pairs state\n\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t// new collection\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('(' === x) {\n\t\t\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\ti = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t// commit list item pointer\n\t\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\t\tif(null === this._kt_subject) {\n\t\t\t\t\t\t\t\tlet a_recent = this._a_nested[this._a_nested.length-1];\n\t\t\t\t\t\t\t\tthis._kt_subject = a_recent[0];\n\t\t\t\t\t\t\t\tthis._kt_predicate = a_recent[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// add this list as an item to the outer list\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_object']);\n\n\t\t\t\t\t\t\t// prepare next triple\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\n\t\t\t\t\t\t\t// flowing\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t// labeled blank node\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_blank_node_label_object = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_blank_node_label_object) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\ti = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t\t\t// ref blank node label\n\t\t\t\t\t\t\t\tlet s_label = m_blank_node_label_object[1];\n\n\t\t\t\t\t\t\t\t// make collection pointer label first\n\t\t\t\t\t\t\t\ts_pointer_label = this.next_label();\n\n\t\t\t\t\t\t\t\t// make object\n\t\t\t\t\t\t\t\tthis._kt_object = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\tlet m_iriref_object = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\tif(m_iriref_object) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\ti = R_IRIREF.lastIndex;\n// commit object iri as is\n\n\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_object[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t// set object\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_object, im_prefixed_named_object] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\tif(m_prefixed_named_object) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\ti = im_prefixed_named_object;\n\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_object[1] || '';\n\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_object[2]\n\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, s_suffix);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection\n\t\t\t// match counter: 7\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\n\n\n\t\t\t// ref object\n\t\t\tlet w_object = this._kt_object;\n\n\t\t\t// create blanknode to embed list\n\t\t\tif(!s_pointer_label) s_pointer_label = this.next_label();\n\t\t\tlet kt_blank_node_outer = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\n\t\t\t// emit statement that functions as collection's head \"pointer\"\n\t\t\tthis.data();\n\n\n\t\t\t// emit statement that is item\n\t\t\tthis._kt_subject = kt_blank_node_outer;\n\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\tthis._kt_object = w_object;\n\t\t\tthis.data();\n\n\n\t\t\t// prepare next predicate\n\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('collection_object');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.collection_object;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\tdestroy(e_destroy) {\n\t\tthis.post_blank_subject = () => {};\n\n\t\tthis.statement = () => {};\n\n\t\tthis.block = () => {};\n\n\t\tthis.graph_or_subject = () => {};\n\n\t\tthis.graph_or_subject_property_list = () => {};\n\n\t\tthis.graph_or_subject_anon = () => {};\n\n\t\tthis.graph_keyword = () => {};\n\n\t\tthis.graph_post_name = () => {};\n\n\t\tthis.pairs = () => {};\n\n\t\tthis.object_list = () => {};\n\n\t\tthis.string_literal_short_double = () => {};\n\n\t\tthis.string_literal_short_single = () => {};\n\n\t\tthis.string_literal_long_double = () => {};\n\n\t\tthis.string_literal_long_single = () => {};\n\n\t\tthis.string_literal = () => {};\n\n\t\tthis.datatype_or_langtag = () => {};\n\n\t\tthis.datatype = () => {};\n\n\t\tthis.post_object = () => {};\n\n\t\tthis.base_iri = () => {};\n\n\t\tthis.prefix_id = () => {};\n\n\t\tthis.prefix_iri = () => {};\n\n\t\tthis.full_stop = () => {};\n\n\t\tthis.collection_subject = () => {};\n\n\t\tthis.collection_object = () => {};\n\n\n\t\tthis.eof = () => {\n\t\t\tthis.s = null;\n\t\t};\n\n\t\tthis._b_destroyed = true;\n\n\t\t// propagate input destroy\n\t\tif(!e_destroy && this._ds_input) {\n\t\t\tthis._ds_input.destroy(e_destroy);\n\t\t}\n\n\t\tthis.transform.demolish(e_destroy);\n\t}\n}\n\nmodule.exports = function(...a_args) {\n\tlet g_config = {};\n\n\t// at least one argument\n\tif(a_args.length) {\n\t\tlet z_arg_0 = a_args[0];\n\n\t\t// input given unspecified\n\t\tif(z_arg_0 && z_arg_0.input && 'undefined' === typeof z_arg_0.input.string && !z_arg_0.input.stream) {\n\t\t\tz_arg_0 = z_arg_0.input;\n\t\t}\n\n\t\t// string\n\t\tif('string' === typeof z_arg_0) {\n\t\t\tg_config.input = {string:z_arg_0};\n\t\t}\n\t\t// null\n\t\telse if(null === z_arg_0) {\n\t\t\tg_config.input = null;\n\t\t}\n\t\t// node stream\n\t\telse if('function' === typeof z_arg_0.setEncoding) {\n\t\t\tg_config.input = {stream:z_arg_0};\n\t\t}\n\t\t// whatwg stream\n\t\telse if('function' === typeof z_arg_0.pipeTo) {\n\t\t\tthrow new TypeError(`Sorry, WHATWG streams are currently not supported :(`);\n\t\t// g_config.input = {stream:z_arg_0};\n\t\t}\n\t\t// config struct\n\t\telse if(z_arg_0 && 'object' === typeof z_arg_0 && '[object Object]' === Object.prototype.toString.call(z_arg_0)) {\n\t\t\tg_config = z_arg_0;\n\n\t\t\t// more args; invalid\n\t\t\tif(a_args.length > 1) {\n\t\t\t\tthrow new TypeError(`unexpected argument(s) after config struct: ${a_args.slice(1)}`);\n\t\t\t}\n\t\t}\n\t\t// unknown\n\t\telse {\n\t\t\tthrow new TypeError(`unexpected input type: ${z_arg_0}`);\n\t\t}\n\n\t\t// more args\n\t\tif(a_args.length > 1) {\n\t\t\t// copy onto struct\n\t\t\tObject.assign(g_config, a_args[1]);\n\n\t\t\t// more args\n\t\t\tif(a_args.length > 2) {\n\t\t\t\tthrow new TypeError(`unexpected argument(s) after input and config struct: ${a_args.slice(2)}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t// create reader, return transform stream\n\treturn (new Reader(g_config)).transform;\n};\n"],"names":["global","factory","exports","this","merge","_len","sets","_key","xl","x","subexp","str","typeOf","o","toUpperCase","toArray","obj","assign","target","source","key","buildExps","isIRI","ALPHA$$","DIGIT$$","HEXDIG$$","PCT_ENCODED$","GEN_DELIMS$$","SUB_DELIMS$$","RESERVED$$","UCSCHAR$$","IPRIVATE$$","UNRESERVED$$","DEC_OCTET_RELAXED$","IPV4ADDRESS$","H16$","LS32$","IPV6ADDRESS1$","IPV6ADDRESS2$","IPV6ADDRESS3$","IPV6ADDRESS4$","IPV6ADDRESS5$","IPV6ADDRESS6$","IPV6ADDRESS7$","IPV6ADDRESS8$","IPV6ADDRESS9$","IPV6ADDRESS$","ZONEID$","PCHAR$","URI_PROTOCOL","IRI_PROTOCOL","slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","_i","_s","err","toConsumableArray","arr2","maxInt","base","tMin","tMax","skew","damp","initialBias","initialN","delimiter","regexPunycode","regexNonASCII","regexSeparators","errors","baseMinusTMin","floor","stringFromCharCode","error$1","type","map","array","fn","result","length","mapDomain","string","parts","labels","encoded","ucs2decode","output","counter","value","extra","ucs2encode","basicToDigit","codePoint","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","k","decode","input","inputLength","n","bias","basic","j","index","oldi","w","t","baseMinusT","out","encode","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","_currentValue2","basicLength","handledCPCount","m","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","currentValue","handledCPCountPlusOne","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","_currentValue","q","qMinusT","toUnicode","toASCII","punycode","SCHEMES","pctEncChar","chr","c","e","pctDecChars","newStr","il","c2","_c","c3","_normalizeComponentEncoding","components","protocol","decodeUnreserved","decStr","_stripLeadingZeros","_normalizeIPv4","host","matches","_matches","address","_normalizeIPv6","_matches2","zone","_address$toLowerCase$","_address$toLowerCase$2","last","first","firstFields","lastFields","isLastFieldIPv4Address","fieldCount","lastFieldsStart","fields","allZeroFields","acc","field","lastLongest","longestZeroFields","a","b","newHost","newFirst","newLast","URI_PARSE","NO_MATCH_IS_UNDEFINED","parse","uriString","options","schemeHandler","_recomposeAuthority","uriTokens","_","$1","$2","RDS1","RDS2","RDS3","RDS5","removeDotSegments","im","s","serialize","authority","resolveComponents","relative","skipNormalization","resolve","baseURI","relativeURI","schemelessOptions","normalize","uri","equal","uriA","uriB","escapeComponent","unescapeComponent","handler","secure","handler$1","isSecure","wsComponents","handler$2","_wsComponents$resourc","_wsComponents$resourc2","path","query","handler$3","O","ATEXT$$","QTEXT$$","VCHAR$$","SOME_DELIMS$$","UNRESERVED","PCT_ENCODED","NOT_LOCAL_PART","NOT_HFNAME","NOT_HFVALUE","handler$4","mailtoComponents","to","unknownHeaders","headers","hfields","hfield","toAddrs","_x","_xl","_x2","_xl2","addr","toAddr","atIdx","localPart","domain","name","URN_PARSE","handler$5","urnComponents","scheme","nid","nss","urnScheme","uriComponents","UUID","handler$6","uuidComponents","dp_resolve","fk","e_callback","require$$0","string_decoder","require$$1","stream","require$$2","require$$3","quad","RT_PREFIXED_NAME_NAMESPACE_VALID","RT_PREFIXED_NAME_LOCAL_NAME_VALID","RT_BLANK_NODE_VALID","RT_NAMED_NODE_VALID","RT_NAMED_NODE_ESCAPELESS_VALID","R_UNICODE_ANY","F_REPLACE_UNICODE_ANY","s_","s_4","s_8","OPHOP","R_PREFIXED_NAME_QUICK","R_PREFIXED_NAME_ESCAPELESS","R_PREFIXED_NAME","R_PN_LOCAL_ESCAPES","R_BLANK_NODE_LABEL","R_BLANK_NODE_LABEL_TERMINAL","R_IRIREF_ESCAPELESS","R_IRIREF","R_NUMERIC_LITERAL","R_BOOLEAN_LITERAL","R_A","R_DOUBLE_CARET","R_WS","R_LANGTAG","R_PREFIX_KEYWORD","R_PREFIX_ID","R_BASE_KEYWORD","R_GRAPH_IRI_ESCAPELESS","R_GRAPH_PREFIXED_NAME","R_GRAPH_LABELED_BLANK_NODE","R_GRAPH_ANONYMOUS_BLANK_NODE","R_GRAPH_IRI","R_GRAPH","R_COMMENT","RT_IRI_ABSOLUTE","R_BASE_IRI","R_ANONYMOUS_BLANK_NODE","R_CHAR_BLANK_NODE","R_CHAR_COLLECTION","R_CHAR_KET","R_CHAR_OPEN","R_CHAR_CLOSE","R_CHAR_STOP","R_STRLIT_SHORT_DOUBLE_BREAK","R_STRLIT_SHORT_SINGLE_BREAK","R_STRLIT_LONG_DOUBLE_UNFINISHED_TERM","R_STRLIT_LONG_SINGLE_UNFINISHED_TERM","R_STRLIT_LONG_DOUBLE_BREAK","R_STRLIT_LONG_SINGLE_BREAK","F_REPLACE_STRLIT_CONTENTS","s_whitespace","s_auto","s_invalid","R_STRLIT_SHORT_CONTENTS_ESCAPES_HARD","R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT","unescape_literal_short_hard","s_literal","unescape_literal_short_soft","m_incomplete","R_STRLIT_ESCAPE_INCOMPLETE","i_safe","R_STRLIT_LONG_CONTENTS_ESCAPES_HARD","R_STRLIT_LONG_CONTENTS_ESCAPES_SOFT","unescape_literal_long_hard","unescape_literal_long_soft","R_STRLIT_SHORT_DOUBLE_TERM","R_STRLIT_SHORT_SINGLE_TERM","R_STRLIT_LONG_DOUBLE_TERM","R_STRLIT_LONG_SINGLE_TERM","RegExp_$lookbehind_polyfill","s_input","m_match","i_start","mk_lookbehind_regex","f_lookbehind","r_polyfill","f_polyfill","match_prefixed_name_escapeless","match_prefixed_name","Reader$syntax_error","k_self","si_state","s_info","i_off","TriG_Reader","g_impls","ds_out","ds_dst","Reader","g_config","g_input","g_state","i_anon","h_prefixes","h_labels","dc_factory","kt_default_graph","kt_rdf_first","blankNode","namedNode","ds_transform","g_quad","s_label","z_label_state","p_iri","m_prefixed_name_e","im_prefixed_name_e","m_prefixed_name","im_prefixed_name","si_prefix","s_suffix","p_set_base_uri","m_base_iri","s_chunk","s_encoding","fke_chunk","fke_flush","e_eof","ds_input","b_byte_tracking","f_write","d_decoder","f_write_track","fk_write","nb_chunk","Buffer","f_decode_write_track","ab_chunk","f_decode_write","z_chunk","nb_post","ib_post","s_event","s_captured","a_comments","s_comment","a_args","f_sync","e_read","s_message","s_expected","b_eof","a_queue","h_event","m_comment","m_pnq_subject","s_prefix_id","m_iriref_e_subject","s_iri","aw_valid_this_match_prefixed_name_escapeless","m_prefixed_named_e_subject","im_prefixed_named_e_subject","m_blank_node_label_subject","m_iriref_subject","aw_valid_this_match_prefixed_name","m_prefixed_named_subject","im_prefixed_named_subject","m_graph_iriref_e_graph","m_graph_prefixed_name","m_graph_labeled_blank_node","m_iriref_e_graph_subject","m_prefix_keyword","m_base_keyword","m_graph_iriref_graph","m_prefixed_named_e_graph","im_prefixed_named_e_graph","m_iriref_e_graph","m_blank_node_label_graph","m_iriref_graph","m_prefixed_named_graph","im_prefixed_named_graph","m_iriref_e_predicate","m_prefixed_named_e_predicate","im_prefixed_named_e_predicate","s_resume_state","m_iriref_predicate","m_prefixed_named_predicate","im_prefixed_named_predicate","m_pnq_object","m_iriref_e_object","m_prefixed_named_e_object","im_prefixed_named_e_object","m_numeric_literal","m_boolean_literal","kt_blank_node","m_blank_node_label_object","m_iriref_object","m_prefixed_named_object","im_prefixed_named_object","string_literal_short_double","m_break","i_break","m_term","i_term","s_dirty","s_clean","s_incomplete","string_literal_short_single","string_literal_long_double","m_unfinished","string_literal_long_single","m_langtag","kt_datatype","m_pnq_datatype","m_iriref_e_datatype","p_datatype","m_prefixed_named_e_datatype","im_prefixed_named_e_datatype","m_prefixed_named_datatype","im_prefixed_named_datatype","i_reset","s_peek","m_iriref_e_base","m_iriref_base","m_prefix_id","p_prefix_iri","m_iriref_e_prefix","b_relax","m_iriref_prefix","s_pointer_label","b_pushed","kt_blank_node_outer","w_object","a_recent","e_destroy","main","z_arg_0"],"mappings":"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","x_google_ignoreList":[0,1]}