{"version":3,"file":"index-BBVcuumq.js","sources":["../node_modules/relative-to-absolute-iri/lib/Resolve.js","../node_modules/relative-to-absolute-iri/index.js","../node_modules/rdf-data-factory/lib/BlankNode.js","../node_modules/rdf-data-factory/lib/DefaultGraph.js","../node_modules/rdf-data-factory/lib/NamedNode.js","../node_modules/rdf-data-factory/lib/Literal.js","../node_modules/rdf-data-factory/lib/Quad.js","../node_modules/rdf-data-factory/lib/Variable.js","../node_modules/rdf-data-factory/lib/DataFactory.js","../node_modules/rdf-data-factory/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.removeDotSegmentsOfPath = exports.removeDotSegments = exports.resolve = void 0;\n/**\n * Convert the given relative IRI to an absolute IRI\n * by taking into account the given optional baseIRI.\n *\n * @param {string} relativeIRI The relative IRI to convert to an absolute IRI.\n * @param {string} baseIRI The optional base IRI.\n * @return {string} an absolute IRI.\n */\nfunction resolve(relativeIRI, baseIRI) {\n    baseIRI = baseIRI || '';\n    const baseFragmentPos = baseIRI.indexOf('#');\n    // Ignore any fragments in the base IRI\n    if (baseFragmentPos > 0) {\n        baseIRI = baseIRI.substr(0, baseFragmentPos);\n    }\n    // Convert empty value directly to base IRI\n    if (!relativeIRI.length) {\n        // At this point, the baseIRI MUST be absolute, otherwise we error\n        if (baseIRI.indexOf(':') < 0) {\n            throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n        }\n        return baseIRI;\n    }\n    // If the value starts with a query character, concat directly (but strip the existing query)\n    if (relativeIRI.startsWith('?')) {\n        const baseQueryPos = baseIRI.indexOf('?');\n        if (baseQueryPos > 0) {\n            baseIRI = baseIRI.substr(0, baseQueryPos);\n        }\n        return baseIRI + relativeIRI;\n    }\n    // If the value starts with a fragment character, concat directly\n    if (relativeIRI.startsWith('#')) {\n        return baseIRI + relativeIRI;\n    }\n    // Ignore baseIRI if it is empty\n    if (!baseIRI.length) {\n        const relativeColonPos = relativeIRI.indexOf(':');\n        if (relativeColonPos < 0) {\n            throw new Error(`Found invalid relative IRI '${relativeIRI}' for a missing baseIRI`);\n        }\n        return removeDotSegmentsOfPath(relativeIRI, relativeColonPos);\n    }\n    // Ignore baseIRI if the value is absolute\n    const valueColonPos = relativeIRI.indexOf(':');\n    if (valueColonPos >= 0) {\n        return removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // At this point, the baseIRI MUST be absolute, otherwise we error\n    const baseColonPos = baseIRI.indexOf(':');\n    if (baseColonPos < 0) {\n        throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n    }\n    const baseIRIScheme = baseIRI.substr(0, baseColonPos + 1);\n    // Inherit the baseIRI scheme if the value starts with '//'\n    if (relativeIRI.indexOf('//') === 0) {\n        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // Check cases where '://' occurs in the baseIRI, and where there is no '/' after a ':' anymore.\n    let baseSlashAfterColonPos;\n    if (baseIRI.indexOf('//', baseColonPos) === baseColonPos + 1) {\n        // If there is no additional '/' after the '//'.\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 3);\n        if (baseSlashAfterColonPos < 0) {\n            // If something other than a '/' follows the '://', append the value after a '/',\n            // otherwise, prefix the value with only the baseIRI scheme.\n            if (baseIRI.length > baseColonPos + 3) {\n                return baseIRI + '/' + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n            else {\n                return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n        }\n    }\n    else {\n        // If there is not even a single '/' after the ':'\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 1);\n        if (baseSlashAfterColonPos < 0) {\n            // If we don't have a '/' after the ':',\n            // prefix the value with only the baseIRI scheme.\n            return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n        }\n    }\n    // If the value starts with a '/', then prefix it with everything before the first effective slash of the base IRI.\n    if (relativeIRI.indexOf('/') === 0) {\n        return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);\n    }\n    let baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);\n    const baseIRILastSlashPos = baseIRIPath.lastIndexOf('/');\n    // Ignore everything after the last '/' in the baseIRI path\n    if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {\n        baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1);\n        // Also remove the first character of the relative path if it starts with '.' (and not '..' or './')\n        // This change is only allowed if there is something else following the path\n        if (relativeIRI[0] === '.' && relativeIRI[1] !== '.' && relativeIRI[1] !== '/' && relativeIRI[2]) {\n            relativeIRI = relativeIRI.substr(1);\n        }\n    }\n    // Prefix the value with the baseIRI path where\n    relativeIRI = baseIRIPath + relativeIRI;\n    // Remove dot segment from the IRI\n    relativeIRI = removeDotSegments(relativeIRI);\n    // Prefix our transformed value with the part of the baseIRI until the first '/' after the first ':'.\n    return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;\n}\nexports.resolve = resolve;\n/**\n * Remove dot segments from the given path,\n * as described in https://www.ietf.org/rfc/rfc3986.txt (page 32).\n * @param {string} path An IRI path.\n * @return {string} A path, will always start with a '/'.\n */\nfunction removeDotSegments(path) {\n    // Prepare a buffer with segments between each '/.\n    // Each segment represents an array of characters.\n    const segmentBuffers = [];\n    let i = 0;\n    while (i < path.length) {\n        // Remove '/.' or '/..'\n        switch (path[i]) {\n            case '/':\n                if (path[i + 1] === '.') {\n                    if (path[i + 2] === '.') {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Go to parent directory,\n                        // so we remove a parent segment\n                        segmentBuffers.pop();\n                        // Ensure that we end with a slash if there is a trailing '/..'\n                        if (!path[i + 3]) {\n                            segmentBuffers.push([]);\n                        }\n                        i += 3;\n                    }\n                    else {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Ensure that we end with a slash if there is a trailing '/.'\n                        if (!path[i + 2]) {\n                            segmentBuffers.push([]);\n                        }\n                        // Go to the current directory,\n                        // so we do nothing\n                        i += 2;\n                    }\n                }\n                else {\n                    // Start a new segment\n                    segmentBuffers.push([]);\n                    i++;\n                }\n                break;\n            case '#':\n            case '?':\n                // Query and fragment string should be appended unchanged\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path.substr(i));\n                // Break the while loop\n                i = path.length;\n                break;\n            default:\n                // Not a special character, just append it to our buffer\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path[i]);\n                i++;\n                break;\n        }\n    }\n    return '/' + segmentBuffers.map((buffer) => buffer.join('')).join('/');\n}\nexports.removeDotSegments = removeDotSegments;\n/**\n * Removes dot segments of the given IRI.\n * @param {string} iri An IRI (or part of IRI).\n * @param {number} colonPosition The position of the first ':' in the IRI.\n * @return {string} The IRI where dot segments were removed.\n */\nfunction removeDotSegmentsOfPath(iri, colonPosition) {\n    // Determine where we should start looking for the first '/' that indicates the start of the path\n    let searchOffset = colonPosition + 1;\n    if (colonPosition >= 0) {\n        if (iri[colonPosition + 1] === '/' && iri[colonPosition + 2] === '/') {\n            searchOffset = colonPosition + 3;\n        }\n    }\n    else {\n        if (iri[0] === '/' && iri[1] === '/') {\n            searchOffset = 2;\n        }\n    }\n    // Determine the path\n    const pathSeparator = iri.indexOf('/', searchOffset);\n    if (pathSeparator < 0) {\n        return iri;\n    }\n    const base = iri.substr(0, pathSeparator);\n    const path = iri.substr(pathSeparator);\n    // Remove dot segments from the path\n    return base + removeDotSegments(path);\n}\nexports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;\nfunction isCharacterAllowedAfterRelativePathSegment(character) {\n    return !character || character === '#' || character === '?' || character === '/';\n}\n//# sourceMappingURL=Resolve.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/Resolve\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlankNode = void 0;\n/**\n * A term that represents an RDF blank node with a label.\n */\nclass BlankNode {\n    constructor(value) {\n        this.termType = 'BlankNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'BlankNode' && other.value === this.value;\n    }\n}\nexports.BlankNode = BlankNode;\n//# sourceMappingURL=BlankNode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultGraph = void 0;\n/**\n * A singleton term instance that represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass DefaultGraph {\n    constructor() {\n        this.termType = 'DefaultGraph';\n        this.value = '';\n        // Private constructor\n    }\n    equals(other) {\n        return !!other && other.termType === 'DefaultGraph';\n    }\n}\nexports.DefaultGraph = DefaultGraph;\nDefaultGraph.INSTANCE = new DefaultGraph();\n//# sourceMappingURL=DefaultGraph.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NamedNode = void 0;\n/**\n * A term that contains an IRI.\n */\nclass NamedNode {\n    constructor(value) {\n        this.termType = 'NamedNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'NamedNode' && other.value === this.value;\n    }\n}\nexports.NamedNode = NamedNode;\n//# sourceMappingURL=NamedNode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Literal = void 0;\nconst NamedNode_1 = require(\"./NamedNode\");\n/**\n * A term that represents an RDF literal, containing a string with an optional language tag or datatype.\n */\nclass Literal {\n    constructor(value, languageOrDatatype) {\n        this.termType = 'Literal';\n        this.value = value;\n        if (typeof languageOrDatatype === 'string') {\n            this.language = languageOrDatatype;\n            this.datatype = Literal.RDF_LANGUAGE_STRING;\n        }\n        else if (languageOrDatatype) {\n            this.language = '';\n            this.datatype = languageOrDatatype;\n        }\n        else {\n            this.language = '';\n            this.datatype = Literal.XSD_STRING;\n        }\n    }\n    equals(other) {\n        return !!other && other.termType === 'Literal' && other.value === this.value &&\n            other.language === this.language && other.datatype.equals(this.datatype);\n    }\n}\nexports.Literal = Literal;\nLiteral.RDF_LANGUAGE_STRING = new NamedNode_1.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');\nLiteral.XSD_STRING = new NamedNode_1.NamedNode('http://www.w3.org/2001/XMLSchema#string');\n//# sourceMappingURL=Literal.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Quad = void 0;\n/**\n * An instance of DefaultGraph represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass Quad {\n    constructor(subject, predicate, object, graph) {\n        this.termType = 'Quad';\n        this.value = '';\n        this.subject = subject;\n        this.predicate = predicate;\n        this.object = object;\n        this.graph = graph;\n    }\n    equals(other) {\n        // `|| !other.termType` is for backwards-compatibility with old factories without RDF* support.\n        return !!other && (other.termType === 'Quad' || !other.termType) &&\n            this.subject.equals(other.subject) &&\n            this.predicate.equals(other.predicate) &&\n            this.object.equals(other.object) &&\n            this.graph.equals(other.graph);\n    }\n}\nexports.Quad = Quad;\n//# sourceMappingURL=Quad.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Variable = void 0;\n/**\n * A term that represents a variable.\n */\nclass Variable {\n    constructor(value) {\n        this.termType = 'Variable';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'Variable' && other.value === this.value;\n    }\n}\nexports.Variable = Variable;\n//# sourceMappingURL=Variable.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataFactory = void 0;\nconst BlankNode_1 = require(\"./BlankNode\");\nconst DefaultGraph_1 = require(\"./DefaultGraph\");\nconst Literal_1 = require(\"./Literal\");\nconst NamedNode_1 = require(\"./NamedNode\");\nconst Quad_1 = require(\"./Quad\");\nconst Variable_1 = require(\"./Variable\");\nlet dataFactoryCounter = 0;\n/**\n * A factory for instantiating RDF terms and quads.\n */\nclass DataFactory {\n    constructor(options) {\n        this.blankNodeCounter = 0;\n        options = options || {};\n        this.blankNodePrefix = options.blankNodePrefix || `df_${dataFactoryCounter++}_`;\n    }\n    /**\n     * @param value The IRI for the named node.\n     * @return A new instance of NamedNode.\n     * @see NamedNode\n     */\n    namedNode(value) {\n        return new NamedNode_1.NamedNode(value);\n    }\n    /**\n     * @param value The optional blank node identifier.\n     * @return A new instance of BlankNode.\n     *         If the `value` parameter is undefined a new identifier\n     *         for the blank node is generated for each call.\n     * @see BlankNode\n     */\n    blankNode(value) {\n        return new BlankNode_1.BlankNode(value || `${this.blankNodePrefix}${this.blankNodeCounter++}`);\n    }\n    /**\n     * @param value              The literal value.\n     * @param languageOrDatatype The optional language or datatype.\n     *                           If `languageOrDatatype` is a NamedNode,\n     *                           then it is used for the value of `NamedNode.datatype`.\n     *                           Otherwise `languageOrDatatype` is used for the value\n     *                           of `NamedNode.language`.\n     * @return A new instance of Literal.\n     * @see Literal\n     */\n    literal(value, languageOrDatatype) {\n        return new Literal_1.Literal(value, languageOrDatatype);\n    }\n    /**\n     * This method is optional.\n     * @param value The variable name\n     * @return A new instance of Variable.\n     * @see Variable\n     */\n    variable(value) {\n        return new Variable_1.Variable(value);\n    }\n    /**\n     * @return An instance of DefaultGraph.\n     */\n    defaultGraph() {\n        return DefaultGraph_1.DefaultGraph.INSTANCE;\n    }\n    /**\n     * @param subject   The quad subject term.\n     * @param predicate The quad predicate term.\n     * @param object    The quad object term.\n     * @param graph     The quad graph term.\n     * @return A new instance of Quad.\n     * @see Quad\n     */\n    quad(subject, predicate, object, graph) {\n        return new Quad_1.Quad(subject, predicate, object, graph || this.defaultGraph());\n    }\n    /**\n     * Create a deep copy of the given term using this data factory.\n     * @param original An RDF term.\n     * @return A deep copy of the given term.\n     */\n    fromTerm(original) {\n        // TODO: remove nasty any casts when this TS bug has been fixed:\n        //  https://github.com/microsoft/TypeScript/issues/26933\n        switch (original.termType) {\n            case 'NamedNode':\n                return this.namedNode(original.value);\n            case 'BlankNode':\n                return this.blankNode(original.value);\n            case 'Literal':\n                if (original.language) {\n                    return this.literal(original.value, original.language);\n                }\n                if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {\n                    return this.literal(original.value, this.fromTerm(original.datatype));\n                }\n                return this.literal(original.value);\n            case 'Variable':\n                return this.variable(original.value);\n            case 'DefaultGraph':\n                return this.defaultGraph();\n            case 'Quad':\n                return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));\n        }\n    }\n    /**\n     * Create a deep copy of the given quad using this data factory.\n     * @param original An RDF quad.\n     * @return A deep copy of the given quad.\n     */\n    fromQuad(original) {\n        return this.fromTerm(original);\n    }\n    /**\n     * Reset the internal blank node counter.\n     */\n    resetBlankNodeCounter() {\n        this.blankNodeCounter = 0;\n    }\n}\nexports.DataFactory = DataFactory;\n//# sourceMappingURL=DataFactory.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/BlankNode\"), exports);\n__exportStar(require(\"./lib/DataFactory\"), exports);\n__exportStar(require(\"./lib/DefaultGraph\"), exports);\n__exportStar(require(\"./lib/Literal\"), exports);\n__exportStar(require(\"./lib/NamedNode\"), exports);\n__exportStar(require(\"./lib/Quad\"), exports);\n__exportStar(require(\"./lib/Variable\"), exports);\n//# sourceMappingURL=index.js.map"],"names":["Resolve","resolve","relativeIRI","baseIRI","baseFragmentPos","baseQueryPos","relativeColonPos","removeDotSegmentsOfPath","valueColonPos","baseColonPos","baseIRIScheme","baseSlashAfterColonPos","removeDotSegments","baseIRIPath","baseIRILastSlashPos","path","segmentBuffers","i","isCharacterAllowedAfterRelativePathSegment","buffer","iri","colonPosition","searchOffset","pathSeparator","base","character","__createBinding","this","o","m","k","k2","__exportStar","exports","p","require$$0","BlankNode_1","BlankNode","value","other","DefaultGraph_1","DefaultGraph","NamedNode_1","NamedNode","Literal_1","Literal","languageOrDatatype","Quad_1","Quad","subject","predicate","object","graph","Variable_1","Variable","DataFactory_1","require$$1","require$$2","require$$3","require$$4","require$$5","dataFactoryCounter","DataFactory","options","original","require$$6"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9]}